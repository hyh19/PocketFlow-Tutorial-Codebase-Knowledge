2025-05-21 12:25:07,362 - INFO - PROMPT: Hello, how are you?
2025-05-21 12:25:09,402 - INFO - RESPONSE: I'm doing well, thank you for asking! How are you today?
2025-05-21 12:27:04,110 - INFO - PROMPT: 
For the project `flutter`:

Codebase Context:
--- File Index 0: packages/flutter/lib/src/widgets/pages.dart ---
// Copyright 2014 The Flutter Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

/// @docImport 'navigator.dart';
library;

import 'basic.dart';
import 'framework.dart';
import 'routes.dart';

/// A modal route that replaces the entire screen.
///
/// The [PageRouteBuilder] subclass provides a way to create a [PageRoute] using
/// callbacks rather than by defining a new class via subclassing.
///
/// If `barrierDismissible` is true, then pressing the escape key on the keyboard
/// will cause the current route to be popped with null as the value.
///
/// See also:
///
///  * [Route], which documents the meaning of the `T` generic type argument.
abstract class PageRoute<T> extends ModalRoute<T> {
  /// Creates a modal route that replaces the entire screen.
  PageRoute({
    super.settings,
    super.requestFocus,
    this.fullscreenDialog = false,
    this.allowSnapshotting = true,
    bool barrierDismissible = false,
  }) : _barrierDismissible = barrierDismissible;

  /// {@template flutter.widgets.PageRoute.fullscreenDialog}
  /// Whether this page route is a full-screen dialog.
  ///
  /// In Material and Cupertino, being fullscreen has the effects of making
  /// the app bars have a close button instead of a back button. On
  /// iOS, dialogs transitions animate differently and are also not closeable
  /// with the back swipe gesture.
  /// {@endtemplate}
  final bool fullscreenDialog;

  @override
  final bool allowSnapshotting;

  @override
  bool get opaque => true;

  @override
  bool get barrierDismissible => _barrierDismissible;
  final bool _barrierDismissible;

  @override
  bool canTransitionTo(TransitionRoute<dynamic> nextRoute) => nextRoute is PageRoute;

  @override
  bool canTransitionFrom(TransitionRoute<dynamic> previousRoute) => previousRoute is PageRoute;

  @override
  bool get popGestureEnabled {
    // Fullscreen dialogs aren't dismissible by back swipe.
    return !fullscreenDialog && super.popGestureEnabled;
  }
}

Widget _defaultTransitionsBuilder(
  BuildContext context,
  Animation<double> animation,
  Animation<double> secondaryAnimation,
  Widget child,
) {
  return child;
}

/// A utility class for defining one-off page routes in terms of callbacks.
///
/// Callers must define the [pageBuilder] function which creates the route's
/// primary contents. To add transitions define the [transitionsBuilder] function.
///
/// The `T` generic type argument corresponds to the type argument of the
/// created [Route] objects.
///
/// See also:
///
///  * [Route], which documents the meaning of the `T` generic type argument.
class PageRouteBuilder<T> extends PageRoute<T> {
  /// Creates a route that delegates to builder callbacks.
  PageRouteBuilder({
    super.settings,
    super.requestFocus,
    required this.pageBuilder,
    this.transitionsBuilder = _defaultTransitionsBuilder,
    this.transitionDuration = const Duration(milliseconds: 300),
    this.reverseTransitionDuration = const Duration(milliseconds: 300),
    this.opaque = true,
    this.barrierDismissible = false,
    this.barrierColor,
    this.barrierLabel,
    this.maintainState = true,
    super.fullscreenDialog,
    super.allowSnapshotting = true,
  });

  /// {@template flutter.widgets.pageRouteBuilder.pageBuilder}
  /// Used build the route's primary contents.
  ///
  /// See [ModalRoute.buildPage] for complete definition of the parameters.
  /// {@endtemplate}
  final RoutePageBuilder pageBuilder;

  /// {@template flutter.widgets.pageRouteBuilder.transitionsBuilder}
  /// Used to build the route's transitions.
  ///
  /// See [ModalRoute.buildTransitions] for complete definition of the parameters.
  /// {@endtemplate}
  ///
  /// The default transition is a jump cut (i.e. no animation).
  final RouteTransitionsBuilder transitionsBuilder;

  @override
  final Duration transitionDuration;

  @override
  final Duration reverseTransitionDuration;

  @override
  final bool opaque;

  @override
  final bool barrierDismissible;

  @override
  final Color? barrierColor;

  @override
  final String? barrierLabel;

  @override
  final bool maintainState;

  @override
  Widget buildPage(
    BuildContext context,
    Animation<double> animation,
    Animation<double> secondaryAnimation,
  ) {
    return pageBuilder(context, animation, secondaryAnimation);
  }

  @override
  Widget buildTransitions(
    BuildContext context,
    Animation<double> animation,
    Animation<double> secondaryAnimation,
    Widget child,
  ) {
    return transitionsBuilder(context, animation, secondaryAnimation, child);
  }
}




Analyze the codebase context.
Identify the top 5-10 core most important abstractions to help those new to the codebase.

For each abstraction, provide:
1. A concise `name`.
2. A beginner-friendly `description` explaining what it is with a simple analogy, in around 100 words.
3. A list of relevant `file_indices` (integers) using the format `idx # path/comment`.

List of file indices and paths present in the context:
- 0 # packages/flutter/lib/src/widgets/pages.dart

Format the output as a YAML list of dictionaries:

```yaml
- name: |
    Query Processing
  description: |
    Explains what the abstraction does.
    It's like a central dispatcher routing requests.
  file_indices:
    - 0 # path/to/file1.py
    - 3 # path/to/related.py
- name: |
    Query Optimization
  description: |
    Another core concept, similar to a blueprint for objects.
  file_indices:
    - 5 # path/to/another.js
# ... up to 10 abstractions
```
2025-05-21 12:27:07,032 - INFO - RESPONSE: ```yaml
- name: |
    PageRoute
  description: |
    Imagine your app is a stack of physical cards. A PageRoute represents one full-screen card (or page) in that stack. When you navigate to a new page, you're essentially placing a new card on top of the stack. It's abstract because different types of pages (like a simple content page or a dialog) will have slightly different behaviors, like how they transition in and out.
  file_indices:
    - 0 # packages/flutter/lib/src/widgets/pages.dart
- name: |
    PageRouteBuilder
  description: |
    Think of PageRouteBuilder as a quick way to create one of those "page cards" without needing to design a whole new type of card from scratch. You provide it with instructions (callbacks) on what the page should look like (`pageBuilder`) and how it should animate (`transitionsBuilder`). It's like filling out a simple form to get a custom-designed card instead of having to craft it by hand.
  file_indices:
    - 0 # packages/flutter/lib/src/widgets/pages.dart
```
2025-05-21 12:27:07,037 - INFO - PROMPT: 
Based on the following abstractions and relevant code snippets from the project `flutter`:

List of Abstraction Indices and Names:
0 # PageRoute

1 # PageRouteBuilder


Context (Abstractions, Descriptions, Code):
Identified Abstractions:\n- Index 0: PageRoute
 (Relevant file indices: [0])\n  Description: Imagine your app is a stack of physical cards. A PageRoute represents one full-screen card (or page) in that stack. When you navigate to a new page, you're essentially placing a new card on top of the stack. It's abstract because different types of pages (like a simple content page or a dialog) will have slightly different behaviors, like how they transition in and out.
\n- Index 1: PageRouteBuilder
 (Relevant file indices: [0])\n  Description: Think of PageRouteBuilder as a quick way to create one of those "page cards" without needing to design a whole new type of card from scratch. You provide it with instructions (callbacks) on what the page should look like (`pageBuilder`) and how it should animate (`transitionsBuilder`). It's like filling out a simple form to get a custom-designed card instead of having to craft it by hand.
\n\nRelevant File Snippets (Referenced by Index and Path):\n--- File: 0 # packages/flutter/lib/src/widgets/pages.dart ---\n// Copyright 2014 The Flutter Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

/// @docImport 'navigator.dart';
library;

import 'basic.dart';
import 'framework.dart';
import 'routes.dart';

/// A modal route that replaces the entire screen.
///
/// The [PageRouteBuilder] subclass provides a way to create a [PageRoute] using
/// callbacks rather than by defining a new class via subclassing.
///
/// If `barrierDismissible` is true, then pressing the escape key on the keyboard
/// will cause the current route to be popped with null as the value.
///
/// See also:
///
///  * [Route], which documents the meaning of the `T` generic type argument.
abstract class PageRoute<T> extends ModalRoute<T> {
  /// Creates a modal route that replaces the entire screen.
  PageRoute({
    super.settings,
    super.requestFocus,
    this.fullscreenDialog = false,
    this.allowSnapshotting = true,
    bool barrierDismissible = false,
  }) : _barrierDismissible = barrierDismissible;

  /// {@template flutter.widgets.PageRoute.fullscreenDialog}
  /// Whether this page route is a full-screen dialog.
  ///
  /// In Material and Cupertino, being fullscreen has the effects of making
  /// the app bars have a close button instead of a back button. On
  /// iOS, dialogs transitions animate differently and are also not closeable
  /// with the back swipe gesture.
  /// {@endtemplate}
  final bool fullscreenDialog;

  @override
  final bool allowSnapshotting;

  @override
  bool get opaque => true;

  @override
  bool get barrierDismissible => _barrierDismissible;
  final bool _barrierDismissible;

  @override
  bool canTransitionTo(TransitionRoute<dynamic> nextRoute) => nextRoute is PageRoute;

  @override
  bool canTransitionFrom(TransitionRoute<dynamic> previousRoute) => previousRoute is PageRoute;

  @override
  bool get popGestureEnabled {
    // Fullscreen dialogs aren't dismissible by back swipe.
    return !fullscreenDialog && super.popGestureEnabled;
  }
}

Widget _defaultTransitionsBuilder(
  BuildContext context,
  Animation<double> animation,
  Animation<double> secondaryAnimation,
  Widget child,
) {
  return child;
}

/// A utility class for defining one-off page routes in terms of callbacks.
///
/// Callers must define the [pageBuilder] function which creates the route's
/// primary contents. To add transitions define the [transitionsBuilder] function.
///
/// The `T` generic type argument corresponds to the type argument of the
/// created [Route] objects.
///
/// See also:
///
///  * [Route], which documents the meaning of the `T` generic type argument.
class PageRouteBuilder<T> extends PageRoute<T> {
  /// Creates a route that delegates to builder callbacks.
  PageRouteBuilder({
    super.settings,
    super.requestFocus,
    required this.pageBuilder,
    this.transitionsBuilder = _defaultTransitionsBuilder,
    this.transitionDuration = const Duration(milliseconds: 300),
    this.reverseTransitionDuration = const Duration(milliseconds: 300),
    this.opaque = true,
    this.barrierDismissible = false,
    this.barrierColor,
    this.barrierLabel,
    this.maintainState = true,
    super.fullscreenDialog,
    super.allowSnapshotting = true,
  });

  /// {@template flutter.widgets.pageRouteBuilder.pageBuilder}
  /// Used build the route's primary contents.
  ///
  /// See [ModalRoute.buildPage] for complete definition of the parameters.
  /// {@endtemplate}
  final RoutePageBuilder pageBuilder;

  /// {@template flutter.widgets.pageRouteBuilder.transitionsBuilder}
  /// Used to build the route's transitions.
  ///
  /// See [ModalRoute.buildTransitions] for complete definition of the parameters.
  /// {@endtemplate}
  ///
  /// The default transition is a jump cut (i.e. no animation).
  final RouteTransitionsBuilder transitionsBuilder;

  @override
  final Duration transitionDuration;

  @override
  final Duration reverseTransitionDuration;

  @override
  final bool opaque;

  @override
  final bool barrierDismissible;

  @override
  final Color? barrierColor;

  @override
  final String? barrierLabel;

  @override
  final bool maintainState;

  @override
  Widget buildPage(
    BuildContext context,
    Animation<double> animation,
    Animation<double> secondaryAnimation,
  ) {
    return pageBuilder(context, animation, secondaryAnimation);
  }

  @override
  Widget buildTransitions(
    BuildContext context,
    Animation<double> animation,
    Animation<double> secondaryAnimation,
    Widget child,
  ) {
    return transitionsBuilder(context, animation, secondaryAnimation, child);
  }
}


Please provide:
1. A high-level `summary` of the project's main purpose and functionality in a few beginner-friendly sentences. Use markdown formatting with **bold** and *italic* text to highlight important concepts.
2. A list (`relationships`) describing the key interactions between these abstractions. For each relationship, specify:
    - `from_abstraction`: Index of the source abstraction (e.g., `0 # AbstractionName1`)
    - `to_abstraction`: Index of the target abstraction (e.g., `1 # AbstractionName2`)
    - `label`: A brief label for the interaction **in just a few words** (e.g., "Manages", "Inherits", "Uses").
    Ideally the relationship should be backed by one abstraction calling or passing parameters to another.
    Simplify the relationship and exclude those non-important ones.

IMPORTANT: Make sure EVERY abstraction is involved in at least ONE relationship (either as source or target). Each abstraction index must appear at least once across all relationships.

Format the output as YAML:

```yaml
summary: |
  A brief, simple explanation of the project.
  Can span multiple lines with **bold** and *italic* for emphasis.
relationships:
  - from_abstraction: 0 # AbstractionName1
    to_abstraction: 1 # AbstractionName2
    label: "Manages"
  - from_abstraction: 2 # AbstractionName3
    to_abstraction: 0 # AbstractionName1
    label: "Provides config"
  # ... other relationships
```

Now, provide the YAML output:

2025-05-21 12:27:09,128 - INFO - RESPONSE: ```yaml
summary: |
  This project is the core of *Flutter*, a UI toolkit for building beautiful, natively compiled applications for mobile, web, and desktop from a single codebase. It handles how different *screens* or **pages** of your app are organized and how you move between them, using concepts like stacked *pages* and transitions.
relationships:
  - from_abstraction: 1 # PageRouteBuilder
    to_abstraction: 0 # PageRoute
    label: "Inherits from"
```
2025-05-21 12:27:09,132 - INFO - PROMPT: 
Given the following project abstractions and their relationships for the project ```` flutter ````:

Abstractions (Index # Name):
- 0 # PageRoute

- 1 # PageRouteBuilder


Context about relationships and project summary:
Project Summary:
This project is the core of *Flutter*, a UI toolkit for building beautiful, natively compiled applications for mobile, web, and desktop from a single codebase. It handles how different *screens* or **pages** of your app are organized and how you move between them, using concepts like stacked *pages* and transitions.


Relationships (Indices refer to abstractions above):
- From 1 (PageRouteBuilder
) to 0 (PageRoute
): Inherits from


If you are going to make a tutorial for ```` flutter ````, what is the best order to explain these abstractions, from first to last?
Ideally, first explain those that are the most important or foundational, perhaps user-facing concepts or entry points. Then move to more detailed, lower-level implementation details or supporting concepts.

Output the ordered list of abstraction indices, including the name in a comment for clarity. Use the format `idx # AbstractionName`.

```yaml
- 2 # FoundationalConcept
- 0 # CoreClassA
- 1 # CoreClassB (uses CoreClassA)
- ...
```

Now, provide the YAML output:

2025-05-21 12:27:11,116 - INFO - RESPONSE: ```yaml
- 0 # PageRoute
- 1 # PageRouteBuilder
```
2025-05-21 12:27:11,120 - INFO - PROMPT: 
Write a very beginner-friendly tutorial chapter (in Markdown format) for the project `flutter` about the concept: "PageRoute
". This is Chapter 1.

Concept Details:
- Name: PageRoute

- Description:
Imagine your app is a stack of physical cards. A PageRoute represents one full-screen card (or page) in that stack. When you navigate to a new page, you're essentially placing a new card on top of the stack. It's abstract because different types of pages (like a simple content page or a dialog) will have slightly different behaviors, like how they transition in and out.


Complete Tutorial Structure:
1. [PageRoute
](01_pageroute_.md)
2. [PageRouteBuilder
](02_pageroutebuilder_.md)

Context from previous chapters:
This is the first chapter.

Relevant Code Snippets (Code itself remains unchanged):
--- File: packages/flutter/lib/src/widgets/pages.dart ---
// Copyright 2014 The Flutter Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

/// @docImport 'navigator.dart';
library;

import 'basic.dart';
import 'framework.dart';
import 'routes.dart';

/// A modal route that replaces the entire screen.
///
/// The [PageRouteBuilder] subclass provides a way to create a [PageRoute] using
/// callbacks rather than by defining a new class via subclassing.
///
/// If `barrierDismissible` is true, then pressing the escape key on the keyboard
/// will cause the current route to be popped with null as the value.
///
/// See also:
///
///  * [Route], which documents the meaning of the `T` generic type argument.
abstract class PageRoute<T> extends ModalRoute<T> {
  /// Creates a modal route that replaces the entire screen.
  PageRoute({
    super.settings,
    super.requestFocus,
    this.fullscreenDialog = false,
    this.allowSnapshotting = true,
    bool barrierDismissible = false,
  }) : _barrierDismissible = barrierDismissible;

  /// {@template flutter.widgets.PageRoute.fullscreenDialog}
  /// Whether this page route is a full-screen dialog.
  ///
  /// In Material and Cupertino, being fullscreen has the effects of making
  /// the app bars have a close button instead of a back button. On
  /// iOS, dialogs transitions animate differently and are also not closeable
  /// with the back swipe gesture.
  /// {@endtemplate}
  final bool fullscreenDialog;

  @override
  final bool allowSnapshotting;

  @override
  bool get opaque => true;

  @override
  bool get barrierDismissible => _barrierDismissible;
  final bool _barrierDismissible;

  @override
  bool canTransitionTo(TransitionRoute<dynamic> nextRoute) => nextRoute is PageRoute;

  @override
  bool canTransitionFrom(TransitionRoute<dynamic> previousRoute) => previousRoute is PageRoute;

  @override
  bool get popGestureEnabled {
    // Fullscreen dialogs aren't dismissible by back swipe.
    return !fullscreenDialog && super.popGestureEnabled;
  }
}

Widget _defaultTransitionsBuilder(
  BuildContext context,
  Animation<double> animation,
  Animation<double> secondaryAnimation,
  Widget child,
) {
  return child;
}

/// A utility class for defining one-off page routes in terms of callbacks.
///
/// Callers must define the [pageBuilder] function which creates the route's
/// primary contents. To add transitions define the [transitionsBuilder] function.
///
/// The `T` generic type argument corresponds to the type argument of the
/// created [Route] objects.
///
/// See also:
///
///  * [Route], which documents the meaning of the `T` generic type argument.
class PageRouteBuilder<T> extends PageRoute<T> {
  /// Creates a route that delegates to builder callbacks.
  PageRouteBuilder({
    super.settings,
    super.requestFocus,
    required this.pageBuilder,
    this.transitionsBuilder = _defaultTransitionsBuilder,
    this.transitionDuration = const Duration(milliseconds: 300),
    this.reverseTransitionDuration = const Duration(milliseconds: 300),
    this.opaque = true,
    this.barrierDismissible = false,
    this.barrierColor,
    this.barrierLabel,
    this.maintainState = true,
    super.fullscreenDialog,
    super.allowSnapshotting = true,
  });

  /// {@template flutter.widgets.pageRouteBuilder.pageBuilder}
  /// Used build the route's primary contents.
  ///
  /// See [ModalRoute.buildPage] for complete definition of the parameters.
  /// {@endtemplate}
  final RoutePageBuilder pageBuilder;

  /// {@template flutter.widgets.pageRouteBuilder.transitionsBuilder}
  /// Used to build the route's transitions.
  ///
  /// See [ModalRoute.buildTransitions] for complete definition of the parameters.
  /// {@endtemplate}
  ///
  /// The default transition is a jump cut (i.e. no animation).
  final RouteTransitionsBuilder transitionsBuilder;

  @override
  final Duration transitionDuration;

  @override
  final Duration reverseTransitionDuration;

  @override
  final bool opaque;

  @override
  final bool barrierDismissible;

  @override
  final Color? barrierColor;

  @override
  final String? barrierLabel;

  @override
  final bool maintainState;

  @override
  Widget buildPage(
    BuildContext context,
    Animation<double> animation,
    Animation<double> secondaryAnimation,
  ) {
    return pageBuilder(context, animation, secondaryAnimation);
  }

  @override
  Widget buildTransitions(
    BuildContext context,
    Animation<double> animation,
    Animation<double> secondaryAnimation,
    Widget child,
  ) {
    return transitionsBuilder(context, animation, secondaryAnimation, child);
  }
}


Instructions for the chapter (Generate content in English unless specified otherwise):
- Start with a clear heading (e.g., `# Chapter 1: PageRoute
`). Use the provided concept name.

- If this is not the first chapter, begin with a brief transition from the previous chapter, referencing it with a proper Markdown link using its name.

- Begin with a high-level motivation explaining what problem this abstraction solves. Start with a central use case as a concrete example. The whole chapter should guide the reader to understand how to solve this use case. Make it very minimal and friendly to beginners.

- If the abstraction is complex, break it down into key concepts. Explain each concept one-by-one in a very beginner-friendly way.

- Explain how to use this abstraction to solve the use case. Give example inputs and outputs for code snippets (if the output isn't values, describe at a high level what will happen).

- Each code block should be BELOW 10 lines! If longer code blocks are needed, break them down into smaller pieces and walk through them one-by-one. Aggresively simplify the code to make it minimal. Use comments to skip non-important implementation details. Each code block should have a beginner friendly explanation right after it.

- Describe the internal implementation to help understand what's under the hood. First provide a non-code or code-light walkthrough on what happens step-by-step when the abstraction is called. It's recommended to use a simple sequenceDiagram with a dummy example - keep it minimal with at most 5 participants to ensure clarity. If participant name has space, use: `participant QP as Query Processing`. .

- Then dive deeper into code for the internal implementation with references to files. Provide example code blocks, but make them similarly simple and beginner-friendly. Explain.

- IMPORTANT: When you need to refer to other core abstractions covered in other chapters, ALWAYS use proper Markdown links like this: [Chapter Title](filename.md). Use the Complete Tutorial Structure above to find the correct filename and the chapter title. Translate the surrounding text.

- Use mermaid diagrams to illustrate complex concepts (```mermaid``` format). .

- Heavily use analogies and examples throughout to help beginners understand.

- End the chapter with a brief conclusion that summarizes what was learned and provides a transition to the next chapter. If there is a next chapter, use a proper Markdown link: [Next Chapter Title](next_chapter_filename).

- Ensure the tone is welcoming and easy for a newcomer to understand.

- Output *only* the Markdown content for this chapter.

Now, directly provide a super beginner-friendly Markdown output (DON'T need ```markdown``` tags):

2025-05-21 12:27:24,111 - INFO - RESPONSE: # Chapter 1: PageRoute

Welcome to the exciting world of building mobile apps with Flutter! In this chapter, we'll introduce a fundamental concept that helps us organize and navigate between different "screens" in our app: the `PageRoute`.

Imagine your app is like a book, and each page in the book is a different screen you can see. When you tap a button, you want to "turn the page" and show a new screen. How does Flutter handle this transition? That's where `PageRoute` comes in!

## What is a PageRoute?

Think of a `PageRoute` as a blueprint or a recipe for creating a single, full-screen "page" in your app. When you want to display something new, you create a `PageRoute` for that something, and Flutter knows how to show it.

It's abstract because even though every `PageRoute` represents a screen, different types of screens might behave slightly differently. For example, a regular screen might slide in from the side, while a little pop-up dialog might fade in from the center. The `PageRoute` provides a common way to manage these different page types.

## Solving a Common Problem: Navigating Between Screens

A very common task in any app is moving from one screen to another. Let's say you have a home screen and a details screen. When the user taps an item on the home screen, you want to show them the details screen. The `PageRoute` is the key to making this happen smoothly!

Here's the basic idea:

1.  You create a `PageRoute` that describes your details screen.
2.  You tell Flutter's navigation system (called the `Navigator`) to "push" this `PageRoute` onto a stack of pages.
3.  Flutter handles the animation and displays the new page on top of the old one.

## How to Use PageRoute (Simplified)

While `PageRoute` itself is an abstract class (meaning you don't usually create `PageRoute` objects directly), other classes inherit from it to create specific types of pages. A very common way to use a `PageRoute` for simple navigation is with helper classes provided by Flutter's Material or Cupertino libraries, or by using something called a `PageRouteBuilder` (which we'll talk about in the next chapter).

For now, let's look at how you might *conceptually* use a `PageRoute` when telling the `Navigator` to go to a new screen. You don't need to write this exact code yet, but it illustrates the concept:

```dart
// Imagine you have a widget for your details screen
class DetailScreen extends StatelessWidget {
  // ... code for your details screen ...
}

// When you want to navigate to the DetailScreen
// You would create a PageRoute for it and push it:
Navigator.of(context).push(
  // This is where a PageRoute would be used
  // For example, using a MaterialPageRoute or CupertinoPageRoute
  // which are specific types of PageRoute
  MaterialPageRoute(builder: (context) => DetailScreen()),
);
```

**Explanation:**

*   `Navigator.of(context)` gets the navigator for your current screen.
*   `.push()` tells the navigator to add a new page to the top of the stack.
*   Inside `push()`, we provide an instance of something that *is* a `PageRoute`. Here, `MaterialPageRoute` is a common type of `PageRoute` that creates a standard page designed with Material Design styling.
*   `builder: (context) => DetailScreen()` tells the `MaterialPageRoute` how to build the actual visual content of the new page (our `DetailScreen` widget).

When you run this code, Flutter will create the `DetailScreen` page using the `PageRoute`, animate it onto the screen, and now the user sees the `DetailScreen`.

## What Happens Under the Hood (Simple Explanation)

Let's visualize what happens when you push a new `PageRoute` onto the `Navigator`:

```mermaid
sequenceDiagram
    participant User as User Interaction (e.g. Button Tap)
    participant WidgetTree as Your App Widgets
    participant Navigator as Flutter Navigator
    participant PageRoute as The new PageRoute
    participant NewPageWidget as The new Page's Content

    User->>WidgetTree: Event (e.g. tap)
    WidgetTree->>Navigator: Call Navigator.push(PageRoute)
    Navigator->>PageRoute: Ask to build the new page
    PageRoute->>NewPageWidget: Build the widget content
    NewPageWidget-->>PageRoute: Return the widget
    PageRoute-->>Navigator: Return the built page
    Navigator->>Navigator: Animate the new page on top
    Navigator->>User: Display the new page
```

**Step-by-Step:**

1.  The user does something (like tapping a button).
2.  Your app responds and calls `Navigator.push()`, providing the `PageRoute` for the screen you want to go to.
3.  The `Navigator` asks the `PageRoute` to create the actual visual content for this new screen.
4.  The `PageRoute` uses the widget you provided (like `DetailScreen`) to build the new page's UI.
5.  The `Navigator` takes this new page's UI and adds it to the screen stack, animating it in according to the `PageRoute`'s specific behavior (e.g., sliding from the side).
6.  The user now sees the new page.

The original page isn't destroyed! It's just hidden behind the new page on the stack. When you "pop" the current page (like pressing the back button), Flutter will remove the top page, and the previous page will be revealed again.

## Looking at the Code (Simplified)

Let's peek at a small part of the `PageRoute` code definition in `packages/flutter/lib/src/widgets/pages.dart`. Remember, this is an abstract class, so it defines the *basic* behavior and properties that all specific `PageRoute` types will have.

```dart
abstract class PageRoute<T> extends ModalRoute<T> {
  /// Creates a modal route that replaces the entire screen.
  PageRoute({
    super.settings,
    super.requestFocus,
    this.fullscreenDialog = false,
    this.allowSnapshotting = true,
    bool barrierDismissible = false,
  }) : _barrierDismissible = barrierDismissible;

  /// Whether this page route is a full-screen dialog.
  final bool fullscreenDialog;

  @override
  final bool allowSnapshotting;

  @override
  bool get opaque => true;

  // ... other properties and methods ...
}
```

**Explanation:**

*   `abstract class PageRoute<T> extends ModalRoute<T>`: This line tells us that `PageRoute` is an `abstract` class (meaning you can't create an instance directly) and it *extends* another class called `ModalRoute`. `ModalRoute` is a more general concept for routes that cover the screen.
*   `fullscreenDialog`: This property allows you to indicate if this page should appear as a full-screen dialog. This affects how it transitions and behaves (like having a "close" button instead of a "back" button in some designs).
*   `opaque`: This property is inherited from `ModalRoute`. `opaque: true` means that the page completely covers whatever is underneath it. `PageRoute`s are typically opaque because they replace the entire screen.

This small glimpse shows some of the built-in capabilities that `PageRoute` provides – defining whether it's a fullscreen dialog and ensuring it covers the screen fully. Specific `PageRoute` implementations (like `MaterialPageRoute`) add more details, such as how the page should animate onto the screen.

## Conclusion

In this chapter, we learned that a `PageRoute` is Flutter's way of representing a single, full-screen page in your app. It's the crucial concept that allows you to define what a screen looks like and how it should behave when navigating to it. While `PageRoute` is abstract, it forms the base for concrete page types like `MaterialPageRoute`.

We saw how `PageRoute`s are used with the `Navigator` to move between screens, and we got a conceptual idea of what happens internally.

In the next chapter, we'll look at [PageRouteBuilder](02_pageroutebuilder_.md), a powerful tool that lets you create custom `PageRoute`s on the fly without needing to build a whole new class!

[Next Chapter: PageRouteBuilder](02_pageroutebuilder_.md)
2025-05-21 12:27:24,113 - INFO - PROMPT: 
Write a very beginner-friendly tutorial chapter (in Markdown format) for the project `flutter` about the concept: "PageRouteBuilder
". This is Chapter 2.

Concept Details:
- Name: PageRouteBuilder

- Description:
Think of PageRouteBuilder as a quick way to create one of those "page cards" without needing to design a whole new type of card from scratch. You provide it with instructions (callbacks) on what the page should look like (`pageBuilder`) and how it should animate (`transitionsBuilder`). It's like filling out a simple form to get a custom-designed card instead of having to craft it by hand.


Complete Tutorial Structure:
1. [PageRoute
](01_pageroute_.md)
2. [PageRouteBuilder
](02_pageroutebuilder_.md)

Context from previous chapters:
# Chapter 1: PageRoute

Welcome to the exciting world of building mobile apps with Flutter! In this chapter, we'll introduce a fundamental concept that helps us organize and navigate between different "screens" in our app: the `PageRoute`.

Imagine your app is like a book, and each page in the book is a different screen you can see. When you tap a button, you want to "turn the page" and show a new screen. How does Flutter handle this transition? That's where `PageRoute` comes in!

## What is a PageRoute?

Think of a `PageRoute` as a blueprint or a recipe for creating a single, full-screen "page" in your app. When you want to display something new, you create a `PageRoute` for that something, and Flutter knows how to show it.

It's abstract because even though every `PageRoute` represents a screen, different types of screens might behave slightly differently. For example, a regular screen might slide in from the side, while a little pop-up dialog might fade in from the center. The `PageRoute` provides a common way to manage these different page types.

## Solving a Common Problem: Navigating Between Screens

A very common task in any app is moving from one screen to another. Let's say you have a home screen and a details screen. When the user taps an item on the home screen, you want to show them the details screen. The `PageRoute` is the key to making this happen smoothly!

Here's the basic idea:

1.  You create a `PageRoute` that describes your details screen.
2.  You tell Flutter's navigation system (called the `Navigator`) to "push" this `PageRoute` onto a stack of pages.
3.  Flutter handles the animation and displays the new page on top of the old one.

## How to Use PageRoute (Simplified)

While `PageRoute` itself is an abstract class (meaning you don't usually create `PageRoute` objects directly), other classes inherit from it to create specific types of pages. A very common way to use a `PageRoute` for simple navigation is with helper classes provided by Flutter's Material or Cupertino libraries, or by using something called a `PageRouteBuilder` (which we'll talk about in the next chapter).

For now, let's look at how you might *conceptually* use a `PageRoute` when telling the `Navigator` to go to a new screen. You don't need to write this exact code yet, but it illustrates the concept:

```dart
// Imagine you have a widget for your details screen
class DetailScreen extends StatelessWidget {
  // ... code for your details screen ...
}

// When you want to navigate to the DetailScreen
// You would create a PageRoute for it and push it:
Navigator.of(context).push(
  // This is where a PageRoute would be used
  // For example, using a MaterialPageRoute or CupertinoPageRoute
  // which are specific types of PageRoute
  MaterialPageRoute(builder: (context) => DetailScreen()),
);
```

**Explanation:**

*   `Navigator.of(context)` gets the navigator for your current screen.
*   `.push()` tells the navigator to add a new page to the top of the stack.
*   Inside `push()`, we provide an instance of something that *is* a `PageRoute`. Here, `MaterialPageRoute` is a common type of `PageRoute` that creates a standard page designed with Material Design styling.
*   `builder: (context) => DetailScreen()` tells the `MaterialPageRoute` how to build the actual visual content of the new page (our `DetailScreen` widget).

When you run this code, Flutter will create the `DetailScreen` page using the `PageRoute`, animate it onto the screen, and now the user sees the `DetailScreen`.

## What Happens Under the Hood (Simple Explanation)

Let's visualize what happens when you push a new `PageRoute` onto the `Navigator`:

```mermaid
sequenceDiagram
    participant User as User Interaction (e.g. Button Tap)
    participant WidgetTree as Your App Widgets
    participant Navigator as Flutter Navigator
    participant PageRoute as The new PageRoute
    participant NewPageWidget as The new Page's Content

    User->>WidgetTree: Event (e.g. tap)
    WidgetTree->>Navigator: Call Navigator.push(PageRoute)
    Navigator->>PageRoute: Ask to build the new page
    PageRoute->>NewPageWidget: Build the widget content
    NewPageWidget-->>PageRoute: Return the widget
    PageRoute-->>Navigator: Return the built page
    Navigator->>Navigator: Animate the new page on top
    Navigator->>User: Display the new page
```

**Step-by-Step:**

1.  The user does something (like tapping a button).
2.  Your app responds and calls `Navigator.push()`, providing the `PageRoute` for the screen you want to go to.
3.  The `Navigator` asks the `PageRoute` to create the actual visual content for this new screen.
4.  The `PageRoute` uses the widget you provided (like `DetailScreen`) to build the new page's UI.
5.  The `Navigator` takes this new page's UI and adds it to the screen stack, animating it in according to the `PageRoute`'s specific behavior (e.g., sliding from the side).
6.  The user now sees the new page.

The original page isn't destroyed! It's just hidden behind the new page on the stack. When you "pop" the current page (like pressing the back button), Flutter will remove the top page, and the previous page will be revealed again.

## Looking at the Code (Simplified)

Let's peek at a small part of the `PageRoute` code definition in `packages/flutter/lib/src/widgets/pages.dart`. Remember, this is an abstract class, so it defines the *basic* behavior and properties that all specific `PageRoute` types will have.

```dart
abstract class PageRoute<T> extends ModalRoute<T> {
  /// Creates a modal route that replaces the entire screen.
  PageRoute({
    super.settings,
    super.requestFocus,
    this.fullscreenDialog = false,
    this.allowSnapshotting = true,
    bool barrierDismissible = false,
  }) : _barrierDismissible = barrierDismissible;

  /// Whether this page route is a full-screen dialog.
  final bool fullscreenDialog;

  @override
  final bool allowSnapshotting;

  @override
  bool get opaque => true;

  // ... other properties and methods ...
}
```

**Explanation:**

*   `abstract class PageRoute<T> extends ModalRoute<T>`: This line tells us that `PageRoute` is an `abstract` class (meaning you can't create an instance directly) and it *extends* another class called `ModalRoute`. `ModalRoute` is a more general concept for routes that cover the screen.
*   `fullscreenDialog`: This property allows you to indicate if this page should appear as a full-screen dialog. This affects how it transitions and behaves (like having a "close" button instead of a "back" button in some designs).
*   `opaque`: This property is inherited from `ModalRoute`. `opaque: true` means that the page completely covers whatever is underneath it. `PageRoute`s are typically opaque because they replace the entire screen.

This small glimpse shows some of the built-in capabilities that `PageRoute` provides – defining whether it's a fullscreen dialog and ensuring it covers the screen fully. Specific `PageRoute` implementations (like `MaterialPageRoute`) add more details, such as how the page should animate onto the screen.

## Conclusion

In this chapter, we learned that a `PageRoute` is Flutter's way of representing a single, full-screen page in your app. It's the crucial concept that allows you to define what a screen looks like and how it should behave when navigating to it. While `PageRoute` is abstract, it forms the base for concrete page types like `MaterialPageRoute`.

We saw how `PageRoute`s are used with the `Navigator` to move between screens, and we got a conceptual idea of what happens internally.

In the next chapter, we'll look at [PageRouteBuilder](02_pageroutebuilder_.md), a powerful tool that lets you create custom `PageRoute`s on the fly without needing to build a whole new class!

[Next Chapter: PageRouteBuilder](02_pageroutebuilder_.md)

Relevant Code Snippets (Code itself remains unchanged):
--- File: packages/flutter/lib/src/widgets/pages.dart ---
// Copyright 2014 The Flutter Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

/// @docImport 'navigator.dart';
library;

import 'basic.dart';
import 'framework.dart';
import 'routes.dart';

/// A modal route that replaces the entire screen.
///
/// The [PageRouteBuilder] subclass provides a way to create a [PageRoute] using
/// callbacks rather than by defining a new class via subclassing.
///
/// If `barrierDismissible` is true, then pressing the escape key on the keyboard
/// will cause the current route to be popped with null as the value.
///
/// See also:
///
///  * [Route], which documents the meaning of the `T` generic type argument.
abstract class PageRoute<T> extends ModalRoute<T> {
  /// Creates a modal route that replaces the entire screen.
  PageRoute({
    super.settings,
    super.requestFocus,
    this.fullscreenDialog = false,
    this.allowSnapshotting = true,
    bool barrierDismissible = false,
  }) : _barrierDismissible = barrierDismissible;

  /// {@template flutter.widgets.PageRoute.fullscreenDialog}
  /// Whether this page route is a full-screen dialog.
  ///
  /// In Material and Cupertino, being fullscreen has the effects of making
  /// the app bars have a close button instead of a back button. On
  /// iOS, dialogs transitions animate differently and are also not closeable
  /// with the back swipe gesture.
  /// {@endtemplate}
  final bool fullscreenDialog;

  @override
  final bool allowSnapshotting;

  @override
  bool get opaque => true;

  @override
  bool get barrierDismissible => _barrierDismissible;
  final bool _barrierDismissible;

  @override
  bool canTransitionTo(TransitionRoute<dynamic> nextRoute) => nextRoute is PageRoute;

  @override
  bool canTransitionFrom(TransitionRoute<dynamic> previousRoute) => previousRoute is PageRoute;

  @override
  bool get popGestureEnabled {
    // Fullscreen dialogs aren't dismissible by back swipe.
    return !fullscreenDialog && super.popGestureEnabled;
  }
}

Widget _defaultTransitionsBuilder(
  BuildContext context,
  Animation<double> animation,
  Animation<double> secondaryAnimation,
  Widget child,
) {
  return child;
}

/// A utility class for defining one-off page routes in terms of callbacks.
///
/// Callers must define the [pageBuilder] function which creates the route's
/// primary contents. To add transitions define the [transitionsBuilder] function.
///
/// The `T` generic type argument corresponds to the type argument of the
/// created [Route] objects.
///
/// See also:
///
///  * [Route], which documents the meaning of the `T` generic type argument.
class PageRouteBuilder<T> extends PageRoute<T> {
  /// Creates a route that delegates to builder callbacks.
  PageRouteBuilder({
    super.settings,
    super.requestFocus,
    required this.pageBuilder,
    this.transitionsBuilder = _defaultTransitionsBuilder,
    this.transitionDuration = const Duration(milliseconds: 300),
    this.reverseTransitionDuration = const Duration(milliseconds: 300),
    this.opaque = true,
    this.barrierDismissible = false,
    this.barrierColor,
    this.barrierLabel,
    this.maintainState = true,
    super.fullscreenDialog,
    super.allowSnapshotting = true,
  });

  /// {@template flutter.widgets.pageRouteBuilder.pageBuilder}
  /// Used build the route's primary contents.
  ///
  /// See [ModalRoute.buildPage] for complete definition of the parameters.
  /// {@endtemplate}
  final RoutePageBuilder pageBuilder;

  /// {@template flutter.widgets.pageRouteBuilder.transitionsBuilder}
  /// Used to build the route's transitions.
  ///
  /// See [ModalRoute.buildTransitions] for complete definition of the parameters.
  /// {@endtemplate}
  ///
  /// The default transition is a jump cut (i.e. no animation).
  final RouteTransitionsBuilder transitionsBuilder;

  @override
  final Duration transitionDuration;

  @override
  final Duration reverseTransitionDuration;

  @override
  final bool opaque;

  @override
  final bool barrierDismissible;

  @override
  final Color? barrierColor;

  @override
  final String? barrierLabel;

  @override
  final bool maintainState;

  @override
  Widget buildPage(
    BuildContext context,
    Animation<double> animation,
    Animation<double> secondaryAnimation,
  ) {
    return pageBuilder(context, animation, secondaryAnimation);
  }

  @override
  Widget buildTransitions(
    BuildContext context,
    Animation<double> animation,
    Animation<double> secondaryAnimation,
    Widget child,
  ) {
    return transitionsBuilder(context, animation, secondaryAnimation, child);
  }
}


Instructions for the chapter (Generate content in English unless specified otherwise):
- Start with a clear heading (e.g., `# Chapter 2: PageRouteBuilder
`). Use the provided concept name.

- If this is not the first chapter, begin with a brief transition from the previous chapter, referencing it with a proper Markdown link using its name.

- Begin with a high-level motivation explaining what problem this abstraction solves. Start with a central use case as a concrete example. The whole chapter should guide the reader to understand how to solve this use case. Make it very minimal and friendly to beginners.

- If the abstraction is complex, break it down into key concepts. Explain each concept one-by-one in a very beginner-friendly way.

- Explain how to use this abstraction to solve the use case. Give example inputs and outputs for code snippets (if the output isn't values, describe at a high level what will happen).

- Each code block should be BELOW 10 lines! If longer code blocks are needed, break them down into smaller pieces and walk through them one-by-one. Aggresively simplify the code to make it minimal. Use comments to skip non-important implementation details. Each code block should have a beginner friendly explanation right after it.

- Describe the internal implementation to help understand what's under the hood. First provide a non-code or code-light walkthrough on what happens step-by-step when the abstraction is called. It's recommended to use a simple sequenceDiagram with a dummy example - keep it minimal with at most 5 participants to ensure clarity. If participant name has space, use: `participant QP as Query Processing`. .

- Then dive deeper into code for the internal implementation with references to files. Provide example code blocks, but make them similarly simple and beginner-friendly. Explain.

- IMPORTANT: When you need to refer to other core abstractions covered in other chapters, ALWAYS use proper Markdown links like this: [Chapter Title](filename.md). Use the Complete Tutorial Structure above to find the correct filename and the chapter title. Translate the surrounding text.

- Use mermaid diagrams to illustrate complex concepts (```mermaid``` format). .

- Heavily use analogies and examples throughout to help beginners understand.

- End the chapter with a brief conclusion that summarizes what was learned and provides a transition to the next chapter. If there is a next chapter, use a proper Markdown link: [Next Chapter Title](next_chapter_filename).

- Ensure the tone is welcoming and easy for a newcomer to understand.

- Output *only* the Markdown content for this chapter.

Now, directly provide a super beginner-friendly Markdown output (DON'T need ```markdown``` tags):

2025-05-21 12:27:42,272 - INFO - RESPONSE: # Chapter 2: PageRouteBuilder

Welcome back, future Flutter developer! In the previous chapter, [PageRoute](01_pageroute_.md), we learned that a `PageRoute` is like a blueprint for a single screen in your app. We saw how it helps `Navigator` figure out what page to show and how it should generally behave.

Now, imagine you want to go to a new screen, but you want it to have a *special* animation when it appears. Maybe instead of sliding from the side like `MaterialPageRoute` does, you want it to fade in, or scale up from the center. How can you do that without building a whole new `PageRoute` subclass from scratch?

That's where `PageRouteBuilder` comes in!

## What is PageRouteBuilder?

Think of `PageRouteBuilder` as a shortcut. Instead of defining a complete `class extends PageRoute`, you can use `PageRouteBuilder` to quickly create a `PageRoute` on the fly by giving it just two key pieces of information:

1.  **What the page looks like:** You provide a function that tells `PageRouteBuilder` how to build the main content of the new page (the actual widgets!).
2.  **How the page animates:** You provide another function that tells `PageRouteBuilder` how to transition the page onto the screen.

It's like filling out a simple form instead of writing a whole detailed specification.

## Solving the Problem: Custom Page Transitions

The main problem `PageRouteBuilder` helps solve is giving you easy control over the transition animation when you navigate to a new page. Standard `PageRoute`s like `MaterialPageRoute` come with built-in animations, but `PageRouteBuilder` lets you define your own.

Let's say you have a `HomePage` and a `DetailsPage`. You want to navigate from `HomePage` to `DetailsPage`, but instead of the default slide animation, you want the `DetailsPage` to fade in. `PageRouteBuilder` is perfect for this!

## How to Use PageRouteBuilder

Using `PageRouteBuilder` involves creating an instance of it and passing it to the `Navigator.push()` method, just like you would with a `MaterialPageRoute`. The key difference is *what* you put inside the `PageRouteBuilder`.

You need to provide two main callbacks:

1.  `pageBuilder`: This function builds the content of the new page.
2.  `transitionsBuilder`: This function defines how the page animates during the transition.

Here's a simple example showing how to navigate to a `DetailsPage` with a fade transition using `PageRouteBuilder`:

```dart
class DetailsPage extends StatelessWidget {
  const DetailsPage({super.key});

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(title: const Text('Details Page')),
      body: const Center(
        child: Text('Welcome to the details!'),
      ),
    );
  }
}

// When you want to go to the DetailsPage with a fade animation:
void _navigateToDetailsWithFade(BuildContext context) {
  Navigator.of(context).push(
    PageRouteBuilder(
      // 1. What the page looks like
      pageBuilder: (context, animation, secondaryAnimation) => const DetailsPage(),

      // 2. How the page animates
      transitionsBuilder: (context, animation, secondaryAnimation, child) {
        // This is a simple fade transition
        return FadeTransition(
          opacity: animation, // Fade in from 0.0 to 1.0
          child: child,       // The actual page content
        );
      },
      // Optional: Control the duration
      transitionDuration: const Duration(milliseconds: 500),
    ),
  );
}
```

**Explanation:**

*   We define a simple `DetailsPage` widget, just like any other page.
*   In the `_navigateToDetailsWithFade` function (which you might call from a button press, for example), we create a `PageRouteBuilder`.
*   `pageBuilder`: This part is easy! We just tell it to return our `DetailsPage` widget. The `context`, `animation`, and `secondaryAnimation` parameters are provided by Flutter, but we don't need them to *build* the basic page content.
*   `transitionsBuilder`: This is where the magic happens.
    *   It receives the `context`, the main `animation` for the new page coming in, the `secondaryAnimation` for the previous page going out, and the `child` (which is the actual `DetailsPage` built by `pageBuilder`).
    *   We wrap the `child` (`DetailsPage`) in a `FadeTransition` widget.
    *   `FadeTransition` changes the opacity of its `child` based on an `Animation`. We give it the `animation` provided by Flutter. As the animation value goes from 0.0 to 1.0, the page will fade from fully transparent to fully opaque.
*   `transitionDuration`: This sets how long the animation should last. 500 milliseconds (half a second) is a common duration.

When you call `_navigateToDetailsWithFade`, Flutter will use the `PageRouteBuilder` to create the `DetailsPage`, and then use the `transitionsBuilder` to animate it fading onto the screen!

You can create all sorts of custom animations in the `transitionsBuilder`, like sliding, scaling, or combinations of different effects.

## What Happens Under the Hood (Simple Explanation)

Similar to the [PageRoute](01_pageroute_.md) in the previous chapter, when you push a `PageRouteBuilder`, the `Navigator` orchestrates the transition. Here's a simplified view:

```mermaid
sequenceDiagram
    participant User as User Interaction
    participant WidgetTree as Your App Widgets
    participant Navigator as Flutter Navigator
    participant PageRouteBuilder as The new PageRouteBuilder
    participant PageBuilderCallback as Your pageBuilder() function
    participant TransitionsBuilderCallback as Your transitionsBuilder() function
    participant NewPageWidget as The new Page's Content (built by pageBuilder)
    participant AnimatedWidget as The Widget with Animation (built by transitionsBuilder)


    User->>WidgetTree: Event (e.g. tap button)
    WidgetTree->>Navigator: Navigator.push(PageRouteBuilder)
    Navigator->>PageRouteBuilder: Ask to build the new route
    PageRouteBuilder->>PageBuilderCallback: Call pageBuilder()
    PageBuilderCallback->>NewPageWidget: Create the page content (e.g., DetailsPage)
    NewPageWidget-->>PageBuilderCallback: Return the widget
    PageBuilderCallback-->>PageRouteBuilder: Return the page content
    PageRouteBuilder->>TransitionsBuilderCallback: Ask to build transitions, giving it the page content and animations
    TransitionsBuilderCallback->>AnimatedWidget: Wrap the page content in animation widgets (e.g., FadeTransition)
    AnimatedWidget-->>TransitionsBuilderCallback: Return the animated widget
    TransitionsBuilderCallback-->>PageRouteBuilder: Return the animated page
    PageRouteBuilder-->>Navigator: Return the fully built & animated route
    Navigator->>Navigator: Start the animation and add the route to the display stack
    Navigator->>User: Display the new page with the custom animation
```

**Step-by-Step:**

1.  The user interacts, your code calls `Navigator.push()`.
2.  You pass a `PageRouteBuilder` instance to `push()`.
3.  The `Navigator` starts setting up the new page.
4.  The `Navigator` calls the `PageRouteBuilder`'s internal methods.
5.  `PageRouteBuilder` first calls your `pageBuilder` function to get the actual visual layout of the new screen (the `DetailsPage` in our example).
6.  Then, `PageRouteBuilder` calls your `transitionsBuilder` function. It gives `transitionsBuilder` the widget built by `pageBuilder` and the animation values Flutter is currently providing.
7.  Your `transitionsBuilder` wraps the page content in animation widgets (like `FadeTransition`).
8.  `PageRouteBuilder` returns this final, animated widget representation of the page back to the `Navigator`.
9.  The `Navigator` now has the fully built page wrapped in your custom animation logic. It starts the animation and adds the page to the screen stack.
10. The user sees the new page appearing using your defined transition!

## Looking at the Code (Simple Explanation)

Let's peek at a small part of the `PageRouteBuilder` code definition in `packages/flutter/lib/src/widgets/pages.dart`, building upon what we saw in the previous chapter with [PageRoute](01_pageroute_.md).

```dart
/// A utility class for defining one-off page routes in terms of callbacks.
/// ...
class PageRouteBuilder<T> extends PageRoute<T> {
  /// Creates a route that delegates to builder callbacks.
  PageRouteBuilder({
    // ... other parameters ...
    required this.pageBuilder,
    this.transitionsBuilder = _defaultTransitionsBuilder, // Default is no animation
    this.transitionDuration = const Duration(milliseconds: 300),
    // ... other parameters ...
  });

  /// Used build the route's primary contents.
  final RoutePageBuilder pageBuilder;

  /// Used to build the route's transitions.
  final RouteTransitionsBuilder transitionsBuilder;

  @override
  final Duration transitionDuration;

  // ... overridden methods that use the builders ...

  @override
  Widget buildPage( // This method is called by the Navigator to get the page content
    BuildContext context,
    Animation<double> animation,
    Animation<double> secondaryAnimation,
  ) {
    return pageBuilder(context, animation, secondaryAnimation); // Just calls *your* pageBuilder!
  }

  @override
  Widget buildTransitions( // This method is called by the Navigator to get the animated page
    BuildContext context,
    Animation<double> animation,
    Animation<double> secondaryAnimation,
    Widget child, // This 'child' is the widget built by buildPage
  ) {
    return transitionsBuilder(context, animation, secondaryAnimation, child); // Just calls *your* transitionsBuilder!
  }
}
```

**Explanation:**

*   `class PageRouteBuilder<T> extends PageRoute<T>`: Just like `MaterialPageRoute`, `PageRouteBuilder` is a specific type of `PageRoute`. This confirms it's designed to work with the `Navigator` and handle tasks like covering the screen.
*   `pageBuilder` and `transitionsBuilder`: These are the crucial properties of `PageRouteBuilder`. They store the functions *you* provide when creating an instance.
*   `transitionDuration`: This property directly controls how long the animation provided by `transitionsBuilder` will run. You can customize this.
*   `buildPage` and `buildTransitions`: These are methods inherited from `PageRoute` (and `ModalRoute`) that the `Navigator` calls internally. Notice how `PageRouteBuilder` simply calls *your* `pageBuilder` and *your* `transitionsBuilder` functions inside these methods. This is how it uses your provided logic to build the page and its animations.

This minimal code shows that `PageRouteBuilder` is essentially a shell that takes your custom functions for building the page and building the transitions and plugs them into the standard `PageRoute` flow.

## Conclusion

In this chapter, we explored `PageRouteBuilder`, a flexible way to create custom [PageRoute](01_pageroute_.md) transitions without needing to define new classes. We learned that it works by providing two callback functions: `pageBuilder` for the page content and `transitionsBuilder` for the animation logic. This allows us to easily implement custom animations like fading, scaling, or any other combination for our screen transitions.

We saw how to use it with `Navigator.push()` and understood the basic flow of how `PageRouteBuilder` uses your code under the hood. Now you have the power to make your app's page transitions look just the way you want!

In the next chapter, we don't have a specific topic listed, but you now have a solid understanding of the fundamental building blocks for structuring and navigating between pages in your Flutter app using [PageRoute](01_pageroute_.md) and `PageRouteBuilder`. Keep practicing and experimenting with different `transitionsBuilder` implementations!
2025-05-21 12:31:19,582 - INFO - PROMPT: 
For the project `flutter`:

Codebase Context:
--- File Index 0: packages/flutter/lib/src/cupertino/route.dart ---
// Copyright 2014 The Flutter Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

/// @docImport 'dart:ui';
///
/// @docImport 'package:flutter/material.dart';
/// @docImport 'package:flutter/services.dart';
///
/// @docImport 'app.dart';
/// @docImport 'button.dart';
/// @docImport 'dialog.dart';
/// @docImport 'nav_bar.dart';
/// @docImport 'page_scaffold.dart';
/// @docImport 'tab_scaffold.dart';
library;

import 'dart:math';
import 'dart:ui' show ImageFilter;

import 'package:flutter/foundation.dart';
import 'package:flutter/gestures.dart';
import 'package:flutter/physics.dart';
import 'package:flutter/rendering.dart';
import 'package:flutter/widgets.dart';

import 'colors.dart';
import 'interface_level.dart';
import 'localizations.dart';

const double _kBackGestureWidth = 20.0;
const double _kMinFlingVelocity = 1.0; // Screen widths per second.

// The duration for a page to animate when the user releases it mid-swipe.
const Duration _kDroppedSwipePageAnimationDuration = Duration(milliseconds: 350);

/// Barrier color used for a barrier visible during transitions for Cupertino
/// page routes.
///
/// This barrier color is only used for full-screen page routes with
/// `fullscreenDialog: false`.
///
/// By default, `fullscreenDialog` Cupertino route transitions have no
/// `barrierColor`, and [CupertinoDialogRoute]s and [CupertinoModalPopupRoute]s
/// have a `barrierColor` defined by [kCupertinoModalBarrierColor].
///
/// A relatively rigorous eyeball estimation.
const Color _kCupertinoPageTransitionBarrierColor = Color(0x18000000);

/// Barrier color for a Cupertino modal barrier.
///
/// Extracted from https://developer.apple.com/design/resources/.
const Color kCupertinoModalBarrierColor = CupertinoDynamicColor.withBrightness(
  color: Color(0x33000000),
  darkColor: Color(0x7A000000),
);

// The duration of the transition used when a modal popup is shown.
const Duration _kModalPopupTransitionDuration = Duration(milliseconds: 335);

// Offset from offscreen to the right to fully on screen.
final Animatable<Offset> _kRightMiddleTween = Tween<Offset>(
  begin: const Offset(1.0, 0.0),
  end: Offset.zero,
);

// Offset from fully on screen to 1/3 offscreen to the left.
final Animatable<Offset> _kMiddleLeftTween = Tween<Offset>(
  begin: Offset.zero,
  end: const Offset(-1.0 / 3.0, 0.0),
);

// Offset from offscreen below to fully on screen.
final Animatable<Offset> _kBottomUpTween = Tween<Offset>(
  begin: const Offset(0.0, 1.0),
  end: Offset.zero,
);

/// A mixin that replaces the entire screen with an iOS transition for a
/// [PageRoute].
///
/// {@template flutter.cupertino.cupertinoRouteTransitionMixin}
/// The page slides in from the right and exits in reverse. The page also shifts
/// to the left in parallax when another page enters to cover it.
///
/// The page slides in from the bottom and exits in reverse with no parallax
/// effect for fullscreen dialogs.
/// {@endtemplate}
///
/// See also:
///
///  * [MaterialRouteTransitionMixin], which is a mixin that provides
///    platform-appropriate transitions for a [PageRoute].
///  * [CupertinoPageRoute], which is a [PageRoute] that leverages this mixin.
mixin CupertinoRouteTransitionMixin<T> on PageRoute<T> {
  /// Builds the primary contents of the route.
  @protected
  Widget buildContent(BuildContext context);

  /// {@template flutter.cupertino.CupertinoRouteTransitionMixin.title}
  /// A title string for this route.
  ///
  /// Used to auto-populate [CupertinoNavigationBar] and
  /// [CupertinoSliverNavigationBar]'s `middle`/`largeTitle` widgets when
  /// one is not manually supplied.
  /// {@endtemplate}
  String? get title;

  ValueNotifier<String?>? _previousTitle;

  /// The title string of the previous [CupertinoPageRoute].
  ///
  /// The [ValueListenable]'s value is readable after the route is installed
  /// onto a [Navigator]. The [ValueListenable] will also notify its listeners
  /// if the value changes (such as by replacing the previous route).
  ///
  /// The [ValueListenable] itself will be null before the route is installed.
  /// Its content value will be null if the previous route has no title or
  /// is not a [CupertinoPageRoute].
  ///
  /// See also:
  ///
  ///  * [ValueListenableBuilder], which can be used to listen and rebuild
  ///    widgets based on a ValueListenable.
  ValueListenable<String?> get previousTitle {
    assert(
      _previousTitle != null,
      'Cannot read the previousTitle for a route that has not yet been installed',
    );
    return _previousTitle!;
  }

  @override
  void dispose() {
    _previousTitle?.dispose();
    super.dispose();
  }

  @override
  void didChangePrevious(Route<dynamic>? previousRoute) {
    final String? previousTitleString =
        previousRoute is CupertinoRouteTransitionMixin ? previousRoute.title : null;
    if (_previousTitle == null) {
      _previousTitle = ValueNotifier<String?>(previousTitleString);
    } else {
      _previousTitle!.value = previousTitleString;
    }
    super.didChangePrevious(previousRoute);
  }

  @override
  // A relatively rigorous eyeball estimation.
  Duration get transitionDuration => const Duration(milliseconds: 500);

  @override
  Color? get barrierColor => fullscreenDialog ? null : _kCupertinoPageTransitionBarrierColor;

  @override
  String? get barrierLabel => null;

  @override
  bool canTransitionTo(TransitionRoute<dynamic> nextRoute) {
    // Don't perform outgoing animation if the next route is a fullscreen dialog.
    final bool nextRouteIsNotFullscreen =
        (nextRoute is! PageRoute<T>) || !nextRoute.fullscreenDialog;

    // If the next route has a delegated transition, then this route is able to
    // use that delegated transition to smoothly sync with the next route's
    // transition.
    final bool nextRouteHasDelegatedTransition =
        nextRoute is ModalRoute<T> && nextRoute.delegatedTransition != null;

    // Otherwise if the next route has the same route transition mixin as this
    // one, then this route will already be synced with its transition.
    return nextRouteIsNotFullscreen &&
        ((nextRoute is CupertinoRouteTransitionMixin) || nextRouteHasDelegatedTransition);
  }

  @override
  bool canTransitionFrom(TransitionRoute<dynamic> previousRoute) {
    // Supress previous route from transitioning if this is a fullscreenDialog route.
    return previousRoute is PageRoute && !fullscreenDialog;
  }

  @override
  Widget buildPage(
    BuildContext context,
    Animation<double> animation,
    Animation<double> secondaryAnimation,
  ) {
    final Widget child = buildContent(context);
    return Semantics(scopesRoute: true, explicitChildNodes: true, child: child);
  }

  // Called by _CupertinoBackGestureDetector when a pop ("back") drag start
  // gesture is detected. The returned controller handles all of the subsequent
  // drag events.
  static _CupertinoBackGestureController<T> _startPopGesture<T>(PageRoute<T> route) {
    assert(route.popGestureEnabled);

    return _CupertinoBackGestureController<T>(
      navigator: route.navigator!,
      getIsCurrent: () => route.isCurrent,
      getIsActive: () => route.isActive,
      controller: route.controller!, // protected access
    );
  }

  /// Returns a [CupertinoFullscreenDialogTransition] if [route] is a full
  /// screen dialog, otherwise a [CupertinoPageTransition] is returned.
  ///
  /// Used by [CupertinoPageRoute.buildTransitions].
  ///
  /// This method can be applied to any [PageRoute], not just
  /// [CupertinoPageRoute]. It's typically used to provide a Cupertino style
  /// horizontal transition for material widgets when the target platform
  /// is [TargetPlatform.iOS].
  ///
  /// See also:
  ///
  ///  * [CupertinoPageTransitionsBuilder], which uses this method to define a
  ///    [PageTransitionsBuilder] for the [PageTransitionsTheme].
  static Widget buildPageTransitions<T>(
    PageRoute<T> route,
    BuildContext context,
    Animation<double> animation,
    Animation<double> secondaryAnimation,
    Widget child,
  ) {
    // Check if the route has an animation that's currently participating
    // in a back swipe gesture.
    //
    // In the middle of a back gesture drag, let the transition be linear to
    // match finger motions.
    final bool linearTransition = route.popGestureInProgress;
    if (route.fullscreenDialog) {
      return CupertinoFullscreenDialogTransition(
        primaryRouteAnimation: animation,
        secondaryRouteAnimation: secondaryAnimation,
        linearTransition: linearTransition,
        child: child,
      );
    } else {
      return CupertinoPageTransition(
        primaryRouteAnimation: animation,
        secondaryRouteAnimation: secondaryAnimation,
        linearTransition: linearTransition,
        child: _CupertinoBackGestureDetector<T>(
          enabledCallback: () => route.popGestureEnabled,
          onStartPopGesture: () => _startPopGesture<T>(route),
          child: child,
        ),
      );
    }
  }

  @override
  Widget buildTransitions(
    BuildContext context,
    Animation<double> animation,
    Animation<double> secondaryAnimation,
    Widget child,
  ) {
    return buildPageTransitions<T>(this, context, animation, secondaryAnimation, child);
  }
}

/// A modal route that replaces the entire screen with an iOS transition.
///
/// {@macro flutter.cupertino.cupertinoRouteTransitionMixin}
///
/// By default, when a modal route is replaced by another, the previous route
/// remains in memory. To free all the resources when this is not necessary, set
/// [maintainState] to false.
///
/// The type `T` specifies the return type of the route which can be supplied as
/// the route is popped from the stack via [Navigator.pop] when an optional
/// `result` can be provided.
///
/// If `barrierDismissible` is true, then pressing the escape key on the keyboard
/// will cause the current route to be popped with null as the value.
///
/// See also:
///
///  * [CupertinoRouteTransitionMixin], for a mixin that provides iOS transition
///    for this modal route.
///  * [MaterialPageRoute], for an adaptive [PageRoute] that uses a
///    platform-appropriate transition.
///  * [CupertinoPageScaffold], for applications that have one page with a fixed
///    navigation bar on top.
///  * [CupertinoTabScaffold], for applications that have a tab bar at the
///    bottom with multiple pages.
///  * [CupertinoPage], for a [Page] version of this class.
class CupertinoPageRoute<T> extends PageRoute<T> with CupertinoRouteTransitionMixin<T> {
  /// Creates a page route for use in an iOS designed app.
  ///
  /// The [builder], [maintainState], and [fullscreenDialog] arguments must not
  /// be null.
  CupertinoPageRoute({
    required this.builder,
    this.title,
    super.settings,
    super.requestFocus,
    this.maintainState = true,
    super.fullscreenDialog,
    super.allowSnapshotting = true,
    super.barrierDismissible = false,
  }) {
    assert(opaque);
  }

  @override
  DelegatedTransitionBuilder? get delegatedTransition =>
      CupertinoPageTransition.delegatedTransition;

  /// Builds the primary contents of the route.
  final WidgetBuilder builder;

  @override
  Widget buildContent(BuildContext context) => builder(context);

  @override
  final String? title;

  @override
  final bool maintainState;

  @override
  String get debugLabel => '${super.debugLabel}(${settings.name})';
}

// A page-based version of CupertinoPageRoute.
//
// This route uses the builder from the page to build its content. This ensures
// the content is up to date after page updates.
class _PageBasedCupertinoPageRoute<T> extends PageRoute<T> with CupertinoRouteTransitionMixin<T> {
  _PageBasedCupertinoPageRoute({required CupertinoPage<T> page, super.allowSnapshotting = true})
    : super(settings: page) {
    assert(opaque);
  }

  @override
  DelegatedTransitionBuilder? get delegatedTransition =>
      this.fullscreenDialog ? null : CupertinoPageTransition.delegatedTransition;

  CupertinoPage<T> get _page => settings as CupertinoPage<T>;

  @override
  Widget buildContent(BuildContext context) => _page.child;

  @override
  String? get title => _page.title;

  @override
  bool get maintainState => _page.maintainState;

  @override
  bool get fullscreenDialog => _page.fullscreenDialog;

  @override
  String get debugLabel => '${super.debugLabel}(${_page.name})';
}

/// A page that creates a cupertino style [PageRoute].
///
/// {@macro flutter.cupertino.cupertinoRouteTransitionMixin}
///
/// By default, when a created modal route is replaced by another, the previous
/// route remains in memory. To free all the resources when this is not
/// necessary, set [maintainState] to false.
///
/// The type `T` specifies the return type of the route which can be supplied as
/// the route is popped from the stack via [Navigator.transitionDelegate] by
/// providing the optional `result` argument to the
/// [RouteTransitionRecord.markForPop] in the [TransitionDelegate.resolve].
///
/// See also:
///
///  * [CupertinoPageRoute], for a [PageRoute] version of this class.
class CupertinoPage<T> extends Page<T> {
  /// Creates a cupertino page.
  const CupertinoPage({
    required this.child,
    this.maintainState = true,
    this.title,
    this.fullscreenDialog = false,
    this.allowSnapshotting = true,
    super.canPop,
    super.onPopInvoked,
    super.key,
    super.name,
    super.arguments,
    super.restorationId,
  });

  /// The content to be shown in the [Route] created by this page.
  final Widget child;

  /// {@macro flutter.cupertino.CupertinoRouteTransitionMixin.title}
  final String? title;

  /// {@macro flutter.widgets.ModalRoute.maintainState}
  final bool maintainState;

  /// {@macro flutter.widgets.PageRoute.fullscreenDialog}
  final bool fullscreenDialog;

  /// {@macro flutter.widgets.TransitionRoute.allowSnapshotting}
  final bool allowSnapshotting;

  @override
  Route<T> createRoute(BuildContext context) {
    return _PageBasedCupertinoPageRoute<T>(page: this, allowSnapshotting: allowSnapshotting);
  }
}

/// Provides an iOS-style page transition animation.
///
/// The page slides in from the right and exits in reverse. It also shifts to the left in
/// a parallax motion when another page enters to cover it.
class CupertinoPageTransition extends StatefulWidget {
  /// Creates an iOS-style page transition.
  ///
  const CupertinoPageTransition({
    super.key,
    required this.primaryRouteAnimation,
    required this.secondaryRouteAnimation,
    required this.child,
    required this.linearTransition,
  });

  /// The widget below this widget in the tree.
  final Widget child;

  ///  * `primaryRouteAnimation` is a linear route animation from 0.0 to 1.0
  ///    when this screen is being pushed.
  final Animation<double> primaryRouteAnimation;

  ///  * `secondaryRouteAnimation` is a linear route animation from 0.0 to 1.0
  ///    when another screen is being pushed on top of this one.
  final Animation<double> secondaryRouteAnimation;

  ///  * `linearTransition` is whether to perform the transitions linearly.
  ///    Used to precisely track back gesture drags.
  final bool linearTransition;

  /// The Cupertino styled [DelegatedTransitionBuilder] provided to the previous
  /// route.
  ///
  /// {@macro flutter.widgets.delegatedTransition}
  static Widget? delegatedTransition(
    BuildContext context,
    Animation<double> animation,
    Animation<double> secondaryAnimation,
    bool allowSnapshotting,
    Widget? child,
  ) {
    final CurvedAnimation animation = CurvedAnimation(
      parent: secondaryAnimation,
      curve: Curves.linearToEaseOut,
      reverseCurve: Curves.easeInToLinear,
    );
    final Animation<Offset> delegatedPositionAnimation = animation.drive(_kMiddleLeftTween);
    animation.dispose();

    assert(debugCheckHasDirectionality(context));
    final TextDirection textDirection = Directionality.of(context);
    return SlideTransition(
      position: delegatedPositionAnimation,
      textDirection: textDirection,
      transformHitTests: false,
      child: child,
    );
  }

  @override
  State<CupertinoPageTransition> createState() => _CupertinoPageTransitionState();
}

class _CupertinoPageTransitionState extends State<CupertinoPageTransition> {
  // When this page is coming in to cover another page.
  late Animation<Offset> _primaryPositionAnimation;
  // When this page is becoming covered by another page.
  late Animation<Offset> _secondaryPositionAnimation;
  // Shadow of page which is coming in to cover another page.
  late Animation<Decoration> _primaryShadowAnimation;
  // Curve of primary page which is coming in to cover another page.
  CurvedAnimation? _primaryPositionCurve;
  // Curve of secondary page which is becoming covered by another page.
  CurvedAnimation? _secondaryPositionCurve;
  // Curve of primary page's shadow.
  CurvedAnimation? _primaryShadowCurve;

  @override
  void initState() {
    super.initState();
    _setupAnimation();
  }

  @override
  void didUpdateWidget(covariant CupertinoPageTransition oldWidget) {
    super.didUpdateWidget(oldWidget);
    if (oldWidget.primaryRouteAnimation != widget.primaryRouteAnimation ||
        oldWidget.secondaryRouteAnimation != widget.secondaryRouteAnimation ||
        oldWidget.linearTransition != widget.linearTransition) {
      _disposeCurve();
      _setupAnimation();
    }
  }

  @override
  void dispose() {
    _disposeCurve();
    super.dispose();
  }

  void _disposeCurve() {
    _primaryPositionCurve?.dispose();
    _secondaryPositionCurve?.dispose();
    _primaryShadowCurve?.dispose();
    _primaryPositionCurve = null;
    _secondaryPositionCurve = null;
    _primaryShadowCurve = null;
  }

  void _setupAnimation() {
    if (!widget.linearTransition) {
      _primaryPositionCurve = CurvedAnimation(
        parent: widget.primaryRouteAnimation,
        curve: Curves.fastEaseInToSlowEaseOut,
        reverseCurve: Curves.fastEaseInToSlowEaseOut.flipped,
      );
      _secondaryPositionCurve = CurvedAnimation(
        parent: widget.secondaryRouteAnimation,
        curve: Curves.linearToEaseOut,
        reverseCurve: Curves.easeInToLinear,
      );
      _primaryShadowCurve = CurvedAnimation(
        parent: widget.primaryRouteAnimation,
        curve: Curves.linearToEaseOut,
      );
    }
    _primaryPositionAnimation = (_primaryPositionCurve ?? widget.primaryRouteAnimation).drive(
      _kRightMiddleTween,
    );
    _secondaryPositionAnimation = (_secondaryPositionCurve ?? widget.secondaryRouteAnimation).drive(
      _kMiddleLeftTween,
    );
    _primaryShadowAnimation = (_primaryShadowCurve ?? widget.primaryRouteAnimation).drive(
      _CupertinoEdgeShadowDecoration.kTween,
    );
  }

  @override
  Widget build(BuildContext context) {
    assert(debugCheckHasDirectionality(context));
    final TextDirection textDirection = Directionality.of(context);
    return SlideTransition(
      position: _secondaryPositionAnimation,
      textDirection: textDirection,
      transformHitTests: false,
      child: SlideTransition(
        position: _primaryPositionAnimation,
        textDirection: textDirection,
        child: DecoratedBoxTransition(decoration: _primaryShadowAnimation, child: widget.child),
      ),
    );
  }
}

/// An iOS-style transition used for summoning fullscreen dialogs.
///
/// For example, used when creating a new calendar event by bringing in the next
/// screen from the bottom.
class CupertinoFullscreenDialogTransition extends StatefulWidget {
  /// Creates an iOS-style transition used for summoning fullscreen dialogs.
  ///
  const CupertinoFullscreenDialogTransition({
    super.key,
    required this.primaryRouteAnimation,
    required this.secondaryRouteAnimation,
    required this.child,
    required this.linearTransition,
  });

  ///  * `primaryRouteAnimation` is a linear route animation from 0.0 to 1.0
  ///    when this screen is being pushed.
  final Animation<double> primaryRouteAnimation;

  ///  * `secondaryRouteAnimation` is a linear route animation from 0.0 to 1.0
  ///    when another screen is being pushed on top of this one.
  final Animation<double> secondaryRouteAnimation;

  ///  * `linearTransition` is whether to perform the transitions linearly.
  ///    Used to precisely track back gesture drags.
  final bool linearTransition;

  /// The widget below this widget in the tree.
  final Widget child;

  @override
  State<CupertinoFullscreenDialogTransition> createState() =>
      _CupertinoFullscreenDialogTransitionState();
}

class _CupertinoFullscreenDialogTransitionState extends State<CupertinoFullscreenDialogTransition> {
  /// When this page is coming in to cover another page.
  late Animation<Offset> _primaryPositionAnimation;

  /// When this page is becoming covered by another page.
  late Animation<Offset> _secondaryPositionAnimation;

  /// Curve of primary page which is coming in to cover another page.
  CurvedAnimation? _primaryPositionCurve;

  /// Curve of secondary page which is becoming covered by another page.
  CurvedAnimation? _secondaryPositionCurve;

  @override
  void initState() {
    super.initState();
    _setupAnimation();
  }

  @override
  void didUpdateWidget(covariant CupertinoFullscreenDialogTransition oldWidget) {
    super.didUpdateWidget(oldWidget);
    if (oldWidget.primaryRouteAnimation != widget.primaryRouteAnimation ||
        oldWidget.secondaryRouteAnimation != widget.secondaryRouteAnimation ||
        oldWidget.linearTransition != widget.linearTransition) {
      _disposeCurve();
      _setupAnimation();
    }
  }

  @override
  void dispose() {
    _disposeCurve();
    super.dispose();
  }

  void _disposeCurve() {
    _primaryPositionCurve?.dispose();
    _secondaryPositionCurve?.dispose();
    _primaryPositionCurve = null;
    _secondaryPositionCurve = null;
  }

  void _setupAnimation() {
    _primaryPositionAnimation = (_primaryPositionCurve = CurvedAnimation(
          parent: widget.primaryRouteAnimation,
          curve: Curves.linearToEaseOut,
          // The curve must be flipped so that the reverse animation doesn't play
          // an ease-in curve, which iOS does not use.
          reverseCurve: Curves.linearToEaseOut.flipped,
        ))
        .drive(_kBottomUpTween);
    _secondaryPositionAnimation = (widget.linearTransition
            ? widget.secondaryRouteAnimation
            : _secondaryPositionCurve = CurvedAnimation(
              parent: widget.secondaryRouteAnimation,
              curve: Curves.linearToEaseOut,
              reverseCurve: Curves.easeInToLinear,
            ))
        .drive(_kMiddleLeftTween);
  }

  @override
  Widget build(BuildContext context) {
    assert(debugCheckHasDirectionality(context));
    final TextDirection textDirection = Directionality.of(context);
    return SlideTransition(
      position: _secondaryPositionAnimation,
      textDirection: textDirection,
      transformHitTests: false,
      child: SlideTransition(position: _primaryPositionAnimation, child: widget.child),
    );
  }
}

/// This is the widget side of [_CupertinoBackGestureController].
///
/// This widget provides a gesture recognizer which, when it determines the
/// route can be closed with a back gesture, creates the controller and
/// feeds it the input from the gesture recognizer.
///
/// The gesture data is converted from absolute coordinates to logical
/// coordinates by this widget.
///
/// The type `T` specifies the return type of the route with which this gesture
/// detector is associated.
class _CupertinoBackGestureDetector<T> extends StatefulWidget {
  const _CupertinoBackGestureDetector({
    super.key,
    required this.enabledCallback,
    required this.onStartPopGesture,
    required this.child,
  });

  final Widget child;

  final ValueGetter<bool> enabledCallback;

  final ValueGetter<_CupertinoBackGestureController<T>> onStartPopGesture;

  @override
  _CupertinoBackGestureDetectorState<T> createState() => _CupertinoBackGestureDetectorState<T>();
}

class _CupertinoBackGestureDetectorState<T> extends State<_CupertinoBackGestureDetector<T>> {
  _CupertinoBackGestureController<T>? _backGestureController;

  late HorizontalDragGestureRecognizer _recognizer;

  @override
  void initState() {
    super.initState();
    _recognizer =
        HorizontalDragGestureRecognizer(debugOwner: this)
          ..onStart = _handleDragStart
          ..onUpdate = _handleDragUpdate
          ..onEnd = _handleDragEnd
          ..onCancel = _handleDragCancel;
  }

  @override
  void dispose() {
    _recognizer.dispose();

    // If this is disposed during a drag, call navigator.didStopUserGesture.
    if (_backGestureController != null) {
      WidgetsBinding.instance.addPostFrameCallback((_) {
        if (_backGestureController?.navigator.mounted ?? false) {
          _backGestureController?.navigator.didStopUserGesture();
        }
        _backGestureController = null;
      });
    }
    super.dispose();
  }

  void _handleDragStart(DragStartDetails details) {
    assert(mounted);
    assert(_backGestureController == null);
    _backGestureController = widget.onStartPopGesture();
  }

  void _handleDragUpdate(DragUpdateDetails details) {
    assert(mounted);
    assert(_backGestureController != null);
    _backGestureController!.dragUpdate(
      _convertToLogical(details.primaryDelta! / context.size!.width),
    );
  }

  void _handleDragEnd(DragEndDetails details) {
    assert(mounted);
    assert(_backGestureController != null);
    _backGestureController!.dragEnd(
      _convertToLogical(details.velocity.pixelsPerSecond.dx / context.size!.width),
    );
    _backGestureController = null;
  }

  void _handleDragCancel() {
    assert(mounted);
    // This can be called even if start is not called, paired with the "down" event
    // that we don't consider here.
    _backGestureController?.dragEnd(0.0);
    _backGestureController = null;
  }

  void _handlePointerDown(PointerDownEvent event) {
    if (widget.enabledCallback()) {
      _recognizer.addPointer(event);
    }
  }

  double _convertToLogical(double value) {
    return switch (Directionality.of(context)) {
      TextDirection.rtl => -value,
      TextDirection.ltr => value,
    };
  }

  @override
  Widget build(BuildContext context) {
    assert(debugCheckHasDirectionality(context));
    // For devices with notches, the drag area needs to be larger on the side
    // that has the notch.
    final double dragAreaWidth = switch (Directionality.of(context)) {
      TextDirection.rtl => MediaQuery.paddingOf(context).right,
      TextDirection.ltr => MediaQuery.paddingOf(context).left,
    };
    return Stack(
      fit: StackFit.passthrough,
      children: <Widget>[
        widget.child,
        PositionedDirectional(
          start: 0.0,
          width: max(dragAreaWidth, _kBackGestureWidth),
          top: 0.0,
          bottom: 0.0,
          child: Listener(onPointerDown: _handlePointerDown, behavior: HitTestBehavior.translucent),
        ),
      ],
    );
  }
}

/// A controller for an iOS-style back gesture.
///
/// This is created by a [CupertinoPageRoute] in response from a gesture caught
/// by a [_CupertinoBackGestureDetector] widget, which then also feeds it input
/// from the gesture. It controls the animation controller owned by the route,
/// based on the input provided by the gesture detector.
///
/// This class works entirely in logical coordinates (0.0 is new page dismissed,
/// 1.0 is new page on top).
///
/// The type `T` specifies the return type of the route with which this gesture
/// detector controller is associated.
class _CupertinoBackGestureController<T> {
  /// Creates a controller for an iOS-style back gesture.
  _CupertinoBackGestureController({
    required this.navigator,
    required this.controller,
    required this.getIsActive,
    required this.getIsCurrent,
  }) {
    navigator.didStartUserGesture();
  }

  final AnimationController controller;
  final NavigatorState navigator;
  final ValueGetter<bool> getIsActive;
  final ValueGetter<bool> getIsCurrent;

  /// The drag gesture has changed by [delta]. The total range of the drag
  /// should be 0.0 to 1.0.
  void dragUpdate(double delta) {
    controller.value -= delta;
  }

  /// The drag gesture has ended with a horizontal motion of [velocity] as a
  /// fraction of screen width per second.
  void dragEnd(double velocity) {
    // Fling in the appropriate direction.
    //
    // This curve has been determined through rigorously eyeballing native iOS
    // animations.
    const Curve animationCurve = Curves.fastEaseInToSlowEaseOut;
    final bool isCurrent = getIsCurrent();
    final bool animateForward;

    if (!isCurrent) {
      // If the page has already been navigated away from, then the animation
      // direction depends on whether or not it's still in the navigation stack,
      // regardless of velocity or drag position. For example, if a route is
      // being slowly dragged back by just a few pixels, but then a programmatic
      // pop occurs, the route should still be animated off the screen.
      // See https://github.com/flutter/flutter/issues/141268.
      animateForward = getIsActive();
    } else if (velocity.abs() >= _kMinFlingVelocity) {
      // If the user releases the page before mid screen with sufficient velocity,
      // or after mid screen, we should animate the page out. Otherwise, the page
      // should be animated back in.
      animateForward = velocity <= 0;
    } else {
      animateForward = controller.value > 0.5;
    }

    if (animateForward) {
      controller.animateTo(
        1.0,
        duration: _kDroppedSwipePageAnimationDuration,
        curve: animationCurve,
      );
    } else {
      if (isCurrent) {
        // This route is destined to pop at this point. Reuse navigator's pop.
        navigator.pop();
      }

      // The popping may have finished inline if already at the target destination.
      if (controller.isAnimating) {
        controller.animateBack(
          0.0,
          duration: _kDroppedSwipePageAnimationDuration,
          curve: animationCurve,
        );
      }
    }

    if (controller.isAnimating) {
      // Keep the userGestureInProgress in true state so we don't change the
      // curve of the page transition mid-flight since CupertinoPageTransition
      // depends on userGestureInProgress.
      late AnimationStatusListener animationStatusCallback;
      animationStatusCallback = (AnimationStatus status) {
        navigator.didStopUserGesture();
        controller.removeStatusListener(animationStatusCallback);
      };
      controller.addStatusListener(animationStatusCallback);
    } else {
      navigator.didStopUserGesture();
    }
  }
}

// A custom [Decoration] used to paint an extra shadow on the start edge of the
// box it's decorating. It's like a [BoxDecoration] with only a gradient except
// it paints on the start side of the box instead of behind the box.
class _CupertinoEdgeShadowDecoration extends Decoration {
  const _CupertinoEdgeShadowDecoration._([this._colors]);

  static DecorationTween kTween = DecorationTween(
    begin: const _CupertinoEdgeShadowDecoration._(), // No decoration initially.
    end: const _CupertinoEdgeShadowDecoration._(
      // Eyeballed gradient used to mimic a drop shadow on the start side only.
      <Color>[Color(0x04000000), CupertinoColors.transparent],
    ),
  );

  // Colors used to paint a gradient at the start edge of the box it is
  // decorating.
  //
  // The first color in the list is used at the start of the gradient, which
  // is located at the start edge of the decorated box.
  //
  // If this is null, no shadow is drawn.
  //
  // The list must have at least two colors in it (otherwise it would not be a
  // gradient).
  final List<Color>? _colors;

  // Linearly interpolate between two edge shadow decorations decorations.
  //
  // The `t` argument represents position on the timeline, with 0.0 meaning
  // that the interpolation has not started, returning `a` (or something
  // equivalent to `a`), 1.0 meaning that the interpolation has finished,
  // returning `b` (or something equivalent to `b`), and values in between
  // meaning that the interpolation is at the relevant point on the timeline
  // between `a` and `b`. The interpolation can be extrapolated beyond 0.0 and
  // 1.0, so negative values and values greater than 1.0 are valid (and can
  // easily be generated by curves such as [Curves.elasticInOut]).
  //
  // Values for `t` are usually obtained from an [Animation<double>], such as
  // an [AnimationController].
  //
  // See also:
  //
  //  * [Decoration.lerp].
  static _CupertinoEdgeShadowDecoration? lerp(
    _CupertinoEdgeShadowDecoration? a,
    _CupertinoEdgeShadowDecoration? b,
    double t,
  ) {
    if (identical(a, b)) {
      return a;
    }
    if (a == null) {
      return b!._colors == null
          ? b
          : _CupertinoEdgeShadowDecoration._(
            b._colors!.map<Color>((Color color) => Color.lerp(null, color, t)!).toList(),
          );
    }
    if (b == null) {
      return a._colors == null
          ? a
          : _CupertinoEdgeShadowDecoration._(
            a._colors.map<Color>((Color color) => Color.lerp(null, color, 1.0 - t)!).toList(),
          );
    }
    assert(b._colors != null || a._colors != null);
    // If it ever becomes necessary, we could allow decorations with different
    // length' here, similarly to how it is handled in [LinearGradient.lerp].
    assert(b._colors == null || a._colors == null || a._colors.length == b._colors.length);
    return _CupertinoEdgeShadowDecoration._(<Color>[
      for (int i = 0; i < b._colors!.length; i += 1) Color.lerp(a._colors?[i], b._colors[i], t)!,
    ]);
  }

  @override
  _CupertinoEdgeShadowDecoration lerpFrom(Decoration? a, double t) {
    if (a is _CupertinoEdgeShadowDecoration) {
      return _CupertinoEdgeShadowDecoration.lerp(a, this, t)!;
    }
    return _CupertinoEdgeShadowDecoration.lerp(null, this, t)!;
  }

  @override
  _CupertinoEdgeShadowDecoration lerpTo(Decoration? b, double t) {
    if (b is _CupertinoEdgeShadowDecoration) {
      return _CupertinoEdgeShadowDecoration.lerp(this, b, t)!;
    }
    return _CupertinoEdgeShadowDecoration.lerp(this, null, t)!;
  }

  @override
  _CupertinoEdgeShadowPainter createBoxPainter([VoidCallback? onChanged]) {
    return _CupertinoEdgeShadowPainter(this, onChanged);
  }

  @override
  bool operator ==(Object other) {
    if (other.runtimeType != runtimeType) {
      return false;
    }
    return other is _CupertinoEdgeShadowDecoration && other._colors == _colors;
  }

  @override
  int get hashCode => _colors.hashCode;

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties.add(IterableProperty<Color>('colors', _colors));
  }
}

/// A [BoxPainter] used to draw the page transition shadow using gradients.
class _CupertinoEdgeShadowPainter extends BoxPainter {
  _CupertinoEdgeShadowPainter(this._decoration, super.onChanged)
    : assert(_decoration._colors == null || _decoration._colors.length > 1);

  final _CupertinoEdgeShadowDecoration _decoration;

  @override
  void paint(Canvas canvas, Offset offset, ImageConfiguration configuration) {
    final List<Color>? colors = _decoration._colors;
    if (colors == null) {
      return;
    }

    // The following code simulates drawing a [LinearGradient] configured as
    // follows:
    //
    // LinearGradient(
    //   begin: AlignmentDirectional(0.90, 0.0), // Spans 5% of the page.
    //   colors: _decoration._colors,
    // )
    //
    // A performance evaluation on Feb 8, 2021 showed, that drawing the gradient
    // manually as implemented below is more performant than relying on
    // [LinearGradient.createShader] because compiling that shader takes a long
    // time. On an iPhone XR, the implementation below reduced the worst frame
    // time for a cupertino page transition of a newly installed app from ~95ms
    // down to ~30ms, mainly because there's no longer a need to compile a
    // shader for the LinearGradient.
    //
    // The implementation below divides the width of the shadow into multiple
    // bands of equal width, one for each color interval defined by
    // `_decoration._colors`. Band x is filled with a gradient going from
    // `_decoration._colors[x]` to `_decoration._colors[x + 1]` by drawing a
    // bunch of 1px wide rects. The rects change their color by lerping between
    // the two colors that define the interval of the band.

    // Shadow spans 5% of the page.
    final double shadowWidth = 0.05 * configuration.size!.width;
    final double shadowHeight = configuration.size!.height;
    final double bandWidth = shadowWidth / (colors.length - 1);

    final TextDirection? textDirection = configuration.textDirection;
    assert(textDirection != null);
    final (double shadowDirection, double start) = switch (textDirection!) {
      TextDirection.rtl => (1, offset.dx + configuration.size!.width),
      TextDirection.ltr => (-1, offset.dx),
    };

    int bandColorIndex = 0;
    for (int dx = 0; dx < shadowWidth; dx += 1) {
      if (dx ~/ bandWidth != bandColorIndex) {
        bandColorIndex += 1;
      }
      final Paint paint =
          Paint()
            ..color =
                Color.lerp(
                  colors[bandColorIndex],
                  colors[bandColorIndex + 1],
                  (dx % bandWidth) / bandWidth,
                )!;
      final double x = start + shadowDirection * dx;
      canvas.drawRect(Rect.fromLTWH(x - 1.0, offset.dy, 1.0, shadowHeight), paint);
    }
  }
}

// The stiffness used by dialogs and action sheets.
//
// The stiffness value is obtained by examining the properties of
// `CASpringAnimation` in Xcode. The damping value is derived similarly, with
// additional precision calculated based on `_kStandardStiffness` to ensure a
// damping ratio of 1 (critically damped): damping = 2 * sqrt(stiffness)
const double _kStandardStiffness = 522.35;
const double _kStandardDamping = 45.7099552;
const SpringDescription _kStandardSpring = SpringDescription(
  mass: 1,
  stiffness: _kStandardStiffness,
  damping: _kStandardDamping,
);
// The iOS spring animation duration is 0.404 seconds, based on the properties
// of `CASpringAnimation` in Xcode. At this point, the spring's position
// `x(0.404)` is approximately 0.9990000, suggesting that iOS uses a position
// tolerance of 1e-3 (matching the default `_epsilonDefault` value).
//
// However, the spring's velocity `dx(0.404)` is about 0.02, indicating that iOS
// may not consider velocity when determining the animation's end condition. To
// account for this, a larger velocity tolerance is applied here for added
// safety.
const Tolerance _kStandardTolerance = Tolerance(velocity: 0.03);

/// A route that shows a modal iOS-style popup that slides up from the
/// bottom of the screen.
///
/// Such a popup is an alternative to a menu or a dialog and prevents the user
/// from interacting with the rest of the app.
///
/// It is used internally by [showCupertinoModalPopup] or can be directly pushed
/// onto the [Navigator] stack to enable state restoration. See
/// [showCupertinoModalPopup] for a state restoration app example.
///
/// The `barrierColor` argument determines the [Color] of the barrier underneath
/// the popup. When unspecified, the barrier color defaults to a light opacity
/// black scrim based on iOS's dialog screens. To correctly have iOS resolve
/// to the appropriate modal colors, pass in
/// `CupertinoDynamicColor.resolve(kCupertinoModalBarrierColor, context)`.
///
/// The `barrierDismissible` argument determines whether clicking outside the
/// popup results in dismissal. It is `true` by default.
///
/// The `semanticsDismissible` argument is used to determine whether the
/// semantics of the modal barrier are included in the semantics tree.
///
/// The `routeSettings` argument is used to provide [RouteSettings] to the
/// created Route.
///
/// {@macro flutter.widgets.RawDialogRoute}
///
/// See also:
///
///  * [DisplayFeatureSubScreen], which documents the specifics of how
///    [DisplayFeature]s can split the screen into sub-screens.
///  * [CupertinoActionSheet], which is the widget usually returned by the
///    `builder` argument.
///  * <https://developer.apple.com/design/human-interface-guidelines/ios/views/action-sheets/>
class CupertinoModalPopupRoute<T> extends PopupRoute<T> {
  /// A route that shows a modal iOS-style popup that slides up from the
  /// bottom of the screen.
  CupertinoModalPopupRoute({
    required this.builder,
    this.barrierLabel = 'Dismiss',
    this.barrierColor = kCupertinoModalBarrierColor,
    bool barrierDismissible = true,
    bool semanticsDismissible = false,
    super.filter,
    super.settings,
    super.requestFocus,
    this.anchorPoint,
  }) : _barrierDismissible = barrierDismissible,
       _semanticsDismissible = semanticsDismissible;

  /// A builder that builds the widget tree for the [CupertinoModalPopupRoute].
  ///
  /// The [builder] argument typically builds a [CupertinoActionSheet] widget.
  ///
  /// Content below the widget is dimmed with a [ModalBarrier]. The widget built
  /// by the [builder] does not share a context with the route it was originally
  /// built from. Use a [StatefulBuilder] or a custom [StatefulWidget] if the
  /// widget needs to update dynamically.
  final WidgetBuilder builder;

  final bool _barrierDismissible;

  final bool _semanticsDismissible;

  @override
  final String barrierLabel;

  @override
  final Color? barrierColor;

  @override
  bool get barrierDismissible => _barrierDismissible;

  @override
  bool get semanticsDismissible => _semanticsDismissible;

  @override
  Duration get transitionDuration => _kModalPopupTransitionDuration;

  /// {@macro flutter.widgets.DisplayFeatureSubScreen.anchorPoint}
  final Offset? anchorPoint;

  @override
  Simulation createSimulation({required bool forward}) {
    assert(!debugTransitionCompleted(), 'Cannot reuse a $runtimeType after disposing it.');
    final double end = forward ? 1.0 : 0.0;
    return SpringSimulation(
      _kStandardSpring,
      controller!.value,
      end,
      0,
      tolerance: _kStandardTolerance,
      snapToEnd: true,
    );
  }

  @override
  Widget buildPage(
    BuildContext context,
    Animation<double> animation,
    Animation<double> secondaryAnimation,
  ) {
    return CupertinoUserInterfaceLevel(
      data: CupertinoUserInterfaceLevelData.elevated,
      child: DisplayFeatureSubScreen(anchorPoint: anchorPoint, child: Builder(builder: builder)),
    );
  }

  @override
  Widget buildTransitions(
    BuildContext context,
    Animation<double> animation,
    Animation<double> secondaryAnimation,
    Widget child,
  ) {
    return Align(
      alignment: Alignment.bottomCenter,
      child: FractionalTranslation(translation: _offsetTween.evaluate(animation), child: child),
    );
  }

  static final Tween<Offset> _offsetTween = Tween<Offset>(
    begin: const Offset(0.0, 1.0),
    end: Offset.zero,
  );
}

/// Shows a modal iOS-style popup that slides up from the bottom of the screen.
///
/// Such a popup is an alternative to a menu or a dialog and prevents the user
/// from interacting with the rest of the app.
///
/// The `context` argument is used to look up the [Navigator] for the popup.
/// It is only used when the method is called. Its corresponding widget can be
/// safely removed from the tree before the popup is closed.
///
/// The `barrierColor` argument determines the [Color] of the barrier underneath
/// the popup. When unspecified, the barrier color defaults to a light opacity
/// black scrim based on iOS's dialog screens.
///
/// The `barrierDismissible` argument determines whether clicking outside the
/// popup results in dismissal. It is `true` by default.
///
/// The `useRootNavigator` argument is used to determine whether to push the
/// popup to the [Navigator] furthest from or nearest to the given `context`. It
/// is `true` by default.
///
/// The `semanticsDismissible` argument is used to determine whether the
/// semantics of the modal barrier are included in the semantics tree.
///
/// The `routeSettings` argument is used to provide [RouteSettings] to the
/// created Route.
///
/// The `builder` argument typically builds a [CupertinoActionSheet] widget.
/// Content below the widget is dimmed with a [ModalBarrier]. The widget built
/// by the `builder` does not share a context with the location that
/// [showCupertinoModalPopup] is originally called from. Use a
/// [StatefulBuilder] or a custom [StatefulWidget] if the widget needs to
/// update dynamically.
///
/// {@macro flutter.widgets.RawDialogRoute}
///
/// Returns a `Future` that resolves to the value that was passed to
/// [Navigator.pop] when the popup was closed.
///
/// ### State Restoration in Modals
///
/// Using this method will not enable state restoration for the modal. In order
/// to enable state restoration for a modal, use [Navigator.restorablePush]
/// or [Navigator.restorablePushNamed] with [CupertinoModalPopupRoute].
///
/// For more information about state restoration, see [RestorationManager].
///
/// {@tool dartpad}
/// This sample demonstrates how to create a restorable Cupertino modal route.
/// This is accomplished by enabling state restoration by specifying
/// [CupertinoApp.restorationScopeId] and using [Navigator.restorablePush] to
/// push [CupertinoModalPopupRoute] when the [CupertinoButton] is tapped.
///
/// {@macro flutter.widgets.RestorationManager}
///
/// ** See code in examples/api/lib/cupertino/route/show_cupertino_modal_popup.0.dart **
/// {@end-tool}
///
/// See also:
///
///  * [DisplayFeatureSubScreen], which documents the specifics of how
///    [DisplayFeature]s can split the screen into sub-screens.
///  * [CupertinoActionSheet], which is the widget usually returned by the
///    `builder` argument to [showCupertinoModalPopup].
///  * <https://developer.apple.com/design/human-interface-guidelines/ios/views/action-sheets/>
Future<T?> showCupertinoModalPopup<T>({
  required BuildContext context,
  required WidgetBuilder builder,
  ImageFilter? filter,
  Color barrierColor = kCupertinoModalBarrierColor,
  bool barrierDismissible = true,
  bool useRootNavigator = true,
  bool semanticsDismissible = false,
  RouteSettings? routeSettings,
  Offset? anchorPoint,
}) {
  return Navigator.of(context, rootNavigator: useRootNavigator).push(
    CupertinoModalPopupRoute<T>(
      builder: builder,
      filter: filter,
      barrierColor: CupertinoDynamicColor.resolve(barrierColor, context),
      barrierDismissible: barrierDismissible,
      semanticsDismissible: semanticsDismissible,
      settings: routeSettings,
      anchorPoint: anchorPoint,
    ),
  );
}

Widget _buildCupertinoDialogTransitions(
  BuildContext context,
  Animation<double> animation,
  Animation<double> secondaryAnimation,
  Widget child,
) {
  return child;
}

/// Displays an iOS-style dialog above the current contents of the app, with
/// iOS-style entrance and exit animations, modal barrier color, and modal
/// barrier behavior (by default, the dialog is not dismissible with a tap on
/// the barrier).
///
/// This function takes a `builder` which typically builds a [CupertinoAlertDialog]
/// widget. Content below the dialog is dimmed with a [ModalBarrier]. The widget
/// returned by the `builder` does not share a context with the location that
/// [showCupertinoDialog] is originally called from. Use a [StatefulBuilder] or
/// a custom [StatefulWidget] if the dialog needs to update dynamically.
///
/// The `context` argument is used to look up the [Navigator] for the dialog.
/// It is only used when the method is called. Its corresponding widget can
/// be safely removed from the tree before the dialog is closed.
///
/// The `useRootNavigator` argument is used to determine whether to push the
/// dialog to the [Navigator] furthest from or nearest to the given `context`.
/// By default, `useRootNavigator` is `true` and the dialog route created by
/// this method is pushed to the root navigator.
///
/// {@macro flutter.widgets.RawDialogRoute}
///
/// If the application has multiple [Navigator] objects, it may be necessary to
/// call `Navigator.of(context, rootNavigator: true).pop(result)` to close the
/// dialog rather than just `Navigator.pop(context, result)`.
///
/// Returns a [Future] that resolves to the value (if any) that was passed to
/// [Navigator.pop] when the dialog was closed.
///
/// ### State Restoration in Dialogs
///
/// Using this method will not enable state restoration for the dialog. In order
/// to enable state restoration for a dialog, use [Navigator.restorablePush]
/// or [Navigator.restorablePushNamed] with [CupertinoDialogRoute].
///
/// For more information about state restoration, see [RestorationManager].
///
/// {@tool dartpad}
/// This sample demonstrates how to create a restorable Cupertino dialog. This is
/// accomplished by enabling state restoration by specifying
/// [CupertinoApp.restorationScopeId] and using [Navigator.restorablePush] to
/// push [CupertinoDialogRoute] when the [CupertinoButton] is tapped.
///
/// {@macro flutter.widgets.RestorationManager}
///
/// ** See code in examples/api/lib/cupertino/route/show_cupertino_dialog.0.dart **
/// {@end-tool}
///
/// See also:
///
///  * [CupertinoAlertDialog], an iOS-style alert dialog.
///  * [showDialog], which displays a Material-style dialog.
///  * [showGeneralDialog], which allows for customization of the dialog popup.
///  * [DisplayFeatureSubScreen], which documents the specifics of how
///    [DisplayFeature]s can split the screen into sub-screens.
///  * <https://developer.apple.com/design/human-interface-guidelines/alerts/>
Future<T?> showCupertinoDialog<T>({
  required BuildContext context,
  required WidgetBuilder builder,
  String? barrierLabel,
  bool useRootNavigator = true,
  bool barrierDismissible = false,
  RouteSettings? routeSettings,
  Offset? anchorPoint,
}) {
  return Navigator.of(context, rootNavigator: useRootNavigator).push<T>(
    CupertinoDialogRoute<T>(
      builder: builder,
      context: context,
      barrierDismissible: barrierDismissible,
      barrierLabel: barrierLabel,
      barrierColor: CupertinoDynamicColor.resolve(kCupertinoModalBarrierColor, context),
      settings: routeSettings,
      anchorPoint: anchorPoint,
    ),
  );
}

/// A dialog route that shows an iOS-style dialog.
///
/// It is used internally by [showCupertinoDialog] or can be directly pushed
/// onto the [Navigator] stack to enable state restoration. See
/// [showCupertinoDialog] for a state restoration app example.
///
/// This function takes a `builder` which typically builds a [Dialog] widget.
/// Content below the dialog is dimmed with a [ModalBarrier]. The widget
/// returned by the `builder` does not share a context with the location that
/// `showDialog` is originally called from. Use a [StatefulBuilder] or a
/// custom [StatefulWidget] if the dialog needs to update dynamically.
///
/// The `context` argument is used to look up
/// [CupertinoLocalizations.modalBarrierDismissLabel], which provides the
/// modal with a localized accessibility label that will be used for the
/// modal's barrier. However, a custom `barrierLabel` can be passed in as well.
///
/// The `barrierDismissible` argument is used to indicate whether tapping on the
/// barrier will dismiss the dialog. It is `true` by default and cannot be `null`.
///
/// The `barrierColor` argument is used to specify the color of the modal
/// barrier that darkens everything below the dialog. If `null`, then
/// [CupertinoDynamicColor.resolve] is used to compute the modal color.
///
/// The `settings` argument define the settings for this route. See
/// [RouteSettings] for details.
///
/// {@macro flutter.widgets.RawDialogRoute}
///
/// See also:
///
///  * [showCupertinoDialog], which is a way to display
///     an iOS-style dialog.
///  * [showGeneralDialog], which allows for customization of the dialog popup.
///  * [showDialog], which displays a Material dialog.
///  * [DisplayFeatureSubScreen], which documents the specifics of how
///    [DisplayFeature]s can split the screen into sub-screens.
class CupertinoDialogRoute<T> extends RawDialogRoute<T> {
  /// A dialog route that shows an iOS-style dialog.
  CupertinoDialogRoute({
    required WidgetBuilder builder,
    required BuildContext context,
    super.barrierDismissible,
    Color? barrierColor,
    String? barrierLabel,
    // This transition duration was eyeballed comparing with iOS
    super.transitionDuration = const Duration(milliseconds: 250),
    this.transitionBuilder,
    super.settings,
    super.requestFocus,
    super.anchorPoint,
  }) : super(
         pageBuilder: (
           BuildContext context,
           Animation<double> animation,
           Animation<double> secondaryAnimation,
         ) {
           return builder(context);
         },
         transitionBuilder: transitionBuilder ?? _buildCupertinoDialogTransitions,
         barrierLabel: barrierLabel ?? CupertinoLocalizations.of(context).modalBarrierDismissLabel,
         barrierColor:
             barrierColor ?? CupertinoDynamicColor.resolve(kCupertinoModalBarrierColor, context),
       );

  /// Custom transition builder
  RouteTransitionsBuilder? transitionBuilder;

  CurvedAnimation? _fadeAnimation;

  @override
  Simulation createSimulation({required bool forward}) {
    assert(!debugTransitionCompleted(), 'Cannot reuse a $runtimeType after disposing it.');
    final double end = forward ? 1.0 : 0.0;
    return SpringSimulation(
      _kStandardSpring,
      controller!.value,
      end,
      0,
      tolerance: _kStandardTolerance,
      snapToEnd: true,
    );
  }

  @override
  Widget buildTransitions(
    BuildContext context,
    Animation<double> animation,
    Animation<double> secondaryAnimation,
    Widget child,
  ) {
    if (transitionBuilder != null) {
      return super.buildTransitions(context, animation, secondaryAnimation, child);
    }

    if (animation.status == AnimationStatus.reverse) {
      return FadeTransition(opacity: animation, child: child);
    }
    return FadeTransition(
      opacity: animation,
      child: ScaleTransition(scale: animation.drive(_dialogScaleTween), child: child),
    );
  }

  @override
  void dispose() {
    _fadeAnimation?.dispose();
    super.dispose();
  }

  // The curve and initial scale values were mostly eyeballed from iOS, however
  // they reuse the same animation curve that was modeled after native page
  // transitions.
  static final Tween<double> _dialogScaleTween = Tween<double>(begin: 1.3, end: 1.0);
}


--- File Index 1: packages/flutter/lib/src/material/page.dart ---
// Copyright 2014 The Flutter Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

import 'package:flutter/cupertino.dart';

import 'page_transitions_theme.dart';
import 'theme.dart';

/// A modal route that replaces the entire screen with a platform-adaptive
/// transition.
///
/// {@macro flutter.material.materialRouteTransitionMixin}
///
/// By default, when a modal route is replaced by another, the previous route
/// remains in memory. To free all the resources when this is not necessary, set
/// [maintainState] to false.
///
/// The `fullscreenDialog` property specifies whether the incoming route is a
/// fullscreen modal dialog. On iOS, those routes animate from the bottom to the
/// top rather than horizontally.
///
/// If `barrierDismissible` is true, then pressing the escape key on the keyboard
/// will cause the current route to be popped with null as the value.
///
/// The type `T` specifies the return type of the route which can be supplied as
/// the route is popped from the stack via [Navigator.pop] by providing the
/// optional `result` argument.
///
/// See also:
///
///  * [MaterialRouteTransitionMixin], which provides the material transition
///    for this route.
///  * [MaterialPage], which is a [Page] of this class.
class MaterialPageRoute<T> extends PageRoute<T> with MaterialRouteTransitionMixin<T> {
  /// Construct a MaterialPageRoute whose contents are defined by [builder].
  MaterialPageRoute({
    required this.builder,
    super.settings,
    super.requestFocus,
    this.maintainState = true,
    super.fullscreenDialog,
    super.allowSnapshotting = true,
    super.barrierDismissible = false,
  }) {
    assert(opaque);
  }

  /// Builds the primary contents of the route.
  final WidgetBuilder builder;

  @override
  Widget buildContent(BuildContext context) => builder(context);

  @override
  final bool maintainState;

  @override
  String get debugLabel => '${super.debugLabel}(${settings.name})';
}

/// A mixin that provides platform-adaptive transitions for a [PageRoute].
///
/// {@template flutter.material.materialRouteTransitionMixin}
/// For Android, the entrance transition for the page zooms in and fades in
/// while the exiting page zooms out and fades out. The exit transition is similar,
/// but in reverse.
///
/// For iOS, the page slides in from the right and exits in reverse. The page
/// also shifts to the left in parallax when another page enters to cover it.
/// (These directions are flipped in environments with a right-to-left reading
/// direction.)
/// {@endtemplate}
///
/// See also:
///
///  * [PageTransitionsTheme], which defines the default page transitions used
///    by the [MaterialRouteTransitionMixin.buildTransitions].
///  * [ZoomPageTransitionsBuilder], which is the default page transition used
///    by the [PageTransitionsTheme].
///  * [CupertinoPageTransitionsBuilder], which is the default page transition
///    for iOS and macOS.
mixin MaterialRouteTransitionMixin<T> on PageRoute<T> {
  /// Builds the primary contents of the route.
  @protected
  Widget buildContent(BuildContext context);

  @override
  Duration get transitionDuration =>
      _getPageTransitionBuilder(navigator!.context)?.transitionDuration ??
      const Duration(microseconds: 300);

  @override
  Duration get reverseTransitionDuration =>
      _getPageTransitionBuilder(navigator!.context)?.reverseTransitionDuration ??
      const Duration(microseconds: 300);

  PageTransitionsBuilder? _getPageTransitionBuilder(BuildContext context) {
    final TargetPlatform platform = Theme.of(context).platform;
    final PageTransitionsTheme pageTransitionsTheme = Theme.of(context).pageTransitionsTheme;
    return pageTransitionsTheme.builders[platform];
  }

  // The transitionDuration is used to create the AnimationController which is only
  // built once, so when page transition builder is updated and transitionDuration
  // has a new value, the AnimationController cannot be updated automatically. So we
  // manually update its duration here.
  // TODO(quncCccccc): Clean up this override method when controller can be updated as the transitionDuration is changed.
  @override
  TickerFuture didPush() {
    controller?.duration = transitionDuration;
    return super.didPush();
  }

  // The reverseTransitionDuration is used to create the AnimationController
  // which is only built once, so when page transition builder is updated and
  // reverseTransitionDuration has a new value, the AnimationController cannot
  // be updated automatically. So we manually update its reverseDuration here.
  // TODO(quncCccccc): Clean up this override method when controller can beupdated as the reverseTransitionDuration is changed.
  @override
  bool didPop(T? result) {
    controller?.reverseDuration = reverseTransitionDuration;
    return super.didPop(result);
  }

  @override
  Color? get barrierColor => null;

  @override
  String? get barrierLabel => null;

  @override
  DelegatedTransitionBuilder? get delegatedTransition => _delegatedTransition;

  static Widget? _delegatedTransition(
    BuildContext context,
    Animation<double> animation,
    Animation<double> secondaryAnimation,
    bool allowSnapshotting,
    Widget? child,
  ) {
    final PageTransitionsTheme theme = Theme.of(context).pageTransitionsTheme;
    final TargetPlatform platform = Theme.of(context).platform;
    final DelegatedTransitionBuilder? themeDelegatedTransition = theme.delegatedTransition(
      platform,
    );
    return themeDelegatedTransition != null
        ? themeDelegatedTransition(context, animation, secondaryAnimation, allowSnapshotting, child)
        : null;
  }

  @override
  bool canTransitionTo(TransitionRoute<dynamic> nextRoute) {
    // Don't perform outgoing animation if the next route is a fullscreen dialog,
    // or there is no matching transition to use.
    // Don't perform outgoing animation if the next route is a fullscreen dialog.
    final bool nextRouteIsNotFullscreen =
        (nextRoute is! PageRoute<T>) || !nextRoute.fullscreenDialog;

    // If the next route has a delegated transition, then this route is able to
    // use that delegated transition to smoothly sync with the next route's
    // transition.
    final bool nextRouteHasDelegatedTransition =
        nextRoute is ModalRoute<T> && nextRoute.delegatedTransition != null;

    // Otherwise if the next route has the same route transition mixin as this
    // one, then this route will already be synced with its transition.
    return nextRouteIsNotFullscreen &&
        ((nextRoute is MaterialRouteTransitionMixin) || nextRouteHasDelegatedTransition);
  }

  @override
  bool canTransitionFrom(TransitionRoute<dynamic> previousRoute) {
    // Supress previous route from transitioning if this is a fullscreenDialog route.
    return previousRoute is PageRoute && !fullscreenDialog;
  }

  @override
  Widget buildPage(
    BuildContext context,
    Animation<double> animation,
    Animation<double> secondaryAnimation,
  ) {
    final Widget result = buildContent(context);
    return Semantics(scopesRoute: true, explicitChildNodes: true, child: result);
  }

  @override
  Widget buildTransitions(
    BuildContext context,
    Animation<double> animation,
    Animation<double> secondaryAnimation,
    Widget child,
  ) {
    final PageTransitionsTheme theme = Theme.of(context).pageTransitionsTheme;
    return theme.buildTransitions<T>(this, context, animation, secondaryAnimation, child);
  }
}

/// A page that creates a material style [PageRoute].
///
/// {@macro flutter.material.materialRouteTransitionMixin}
///
/// By default, when the created route is replaced by another, the previous
/// route remains in memory. To free all the resources when this is not
/// necessary, set [maintainState] to false.
///
/// The `fullscreenDialog` property specifies whether the created route is a
/// fullscreen modal dialog. On iOS, those routes animate from the bottom to the
/// top rather than horizontally.
///
/// The type `T` specifies the return type of the route which can be supplied as
/// the route is popped from the stack via [Navigator.transitionDelegate] by
/// providing the optional `result` argument to the
/// [RouteTransitionRecord.markForPop] in the [TransitionDelegate.resolve].
///
/// See also:
///
///  * [MaterialPageRoute], which is the [PageRoute] version of this class
class MaterialPage<T> extends Page<T> {
  /// Creates a material page.
  const MaterialPage({
    required this.child,
    this.maintainState = true,
    this.fullscreenDialog = false,
    this.allowSnapshotting = true,
    super.key,
    super.canPop,
    super.onPopInvoked,
    super.name,
    super.arguments,
    super.restorationId,
  });

  /// The content to be shown in the [Route] created by this page.
  final Widget child;

  /// {@macro flutter.widgets.ModalRoute.maintainState}
  final bool maintainState;

  /// {@macro flutter.widgets.PageRoute.fullscreenDialog}
  final bool fullscreenDialog;

  /// {@macro flutter.widgets.TransitionRoute.allowSnapshotting}
  final bool allowSnapshotting;

  @override
  Route<T> createRoute(BuildContext context) {
    return _PageBasedMaterialPageRoute<T>(page: this, allowSnapshotting: allowSnapshotting);
  }
}

// A page-based version of MaterialPageRoute.
//
// This route uses the builder from the page to build its content. This ensures
// the content is up to date after page updates.
class _PageBasedMaterialPageRoute<T> extends PageRoute<T> with MaterialRouteTransitionMixin<T> {
  _PageBasedMaterialPageRoute({required MaterialPage<T> page, super.allowSnapshotting})
    : super(settings: page) {
    assert(opaque);
  }

  MaterialPage<T> get _page => settings as MaterialPage<T>;

  @override
  Widget buildContent(BuildContext context) {
    return _page.child;
  }

  @override
  bool get maintainState => _page.maintainState;

  @override
  bool get fullscreenDialog => _page.fullscreenDialog;

  @override
  String get debugLabel => '${super.debugLabel}(${_page.name})';
}


--- File Index 2: packages/flutter/lib/src/widgets/pages.dart ---
// Copyright 2014 The Flutter Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

/// @docImport 'navigator.dart';
library;

import 'basic.dart';
import 'framework.dart';
import 'routes.dart';

/// A modal route that replaces the entire screen.
///
/// The [PageRouteBuilder] subclass provides a way to create a [PageRoute] using
/// callbacks rather than by defining a new class via subclassing.
///
/// If `barrierDismissible` is true, then pressing the escape key on the keyboard
/// will cause the current route to be popped with null as the value.
///
/// See also:
///
///  * [Route], which documents the meaning of the `T` generic type argument.
abstract class PageRoute<T> extends ModalRoute<T> {
  /// Creates a modal route that replaces the entire screen.
  PageRoute({
    super.settings,
    super.requestFocus,
    this.fullscreenDialog = false,
    this.allowSnapshotting = true,
    bool barrierDismissible = false,
  }) : _barrierDismissible = barrierDismissible;

  /// {@template flutter.widgets.PageRoute.fullscreenDialog}
  /// Whether this page route is a full-screen dialog.
  ///
  /// In Material and Cupertino, being fullscreen has the effects of making
  /// the app bars have a close button instead of a back button. On
  /// iOS, dialogs transitions animate differently and are also not closeable
  /// with the back swipe gesture.
  /// {@endtemplate}
  final bool fullscreenDialog;

  @override
  final bool allowSnapshotting;

  @override
  bool get opaque => true;

  @override
  bool get barrierDismissible => _barrierDismissible;
  final bool _barrierDismissible;

  @override
  bool canTransitionTo(TransitionRoute<dynamic> nextRoute) => nextRoute is PageRoute;

  @override
  bool canTransitionFrom(TransitionRoute<dynamic> previousRoute) => previousRoute is PageRoute;

  @override
  bool get popGestureEnabled {
    // Fullscreen dialogs aren't dismissible by back swipe.
    return !fullscreenDialog && super.popGestureEnabled;
  }
}

Widget _defaultTransitionsBuilder(
  BuildContext context,
  Animation<double> animation,
  Animation<double> secondaryAnimation,
  Widget child,
) {
  return child;
}

/// A utility class for defining one-off page routes in terms of callbacks.
///
/// Callers must define the [pageBuilder] function which creates the route's
/// primary contents. To add transitions define the [transitionsBuilder] function.
///
/// The `T` generic type argument corresponds to the type argument of the
/// created [Route] objects.
///
/// See also:
///
///  * [Route], which documents the meaning of the `T` generic type argument.
class PageRouteBuilder<T> extends PageRoute<T> {
  /// Creates a route that delegates to builder callbacks.
  PageRouteBuilder({
    super.settings,
    super.requestFocus,
    required this.pageBuilder,
    this.transitionsBuilder = _defaultTransitionsBuilder,
    this.transitionDuration = const Duration(milliseconds: 300),
    this.reverseTransitionDuration = const Duration(milliseconds: 300),
    this.opaque = true,
    this.barrierDismissible = false,
    this.barrierColor,
    this.barrierLabel,
    this.maintainState = true,
    super.fullscreenDialog,
    super.allowSnapshotting = true,
  });

  /// {@template flutter.widgets.pageRouteBuilder.pageBuilder}
  /// Used build the route's primary contents.
  ///
  /// See [ModalRoute.buildPage] for complete definition of the parameters.
  /// {@endtemplate}
  final RoutePageBuilder pageBuilder;

  /// {@template flutter.widgets.pageRouteBuilder.transitionsBuilder}
  /// Used to build the route's transitions.
  ///
  /// See [ModalRoute.buildTransitions] for complete definition of the parameters.
  /// {@endtemplate}
  ///
  /// The default transition is a jump cut (i.e. no animation).
  final RouteTransitionsBuilder transitionsBuilder;

  @override
  final Duration transitionDuration;

  @override
  final Duration reverseTransitionDuration;

  @override
  final bool opaque;

  @override
  final bool barrierDismissible;

  @override
  final Color? barrierColor;

  @override
  final String? barrierLabel;

  @override
  final bool maintainState;

  @override
  Widget buildPage(
    BuildContext context,
    Animation<double> animation,
    Animation<double> secondaryAnimation,
  ) {
    return pageBuilder(context, animation, secondaryAnimation);
  }

  @override
  Widget buildTransitions(
    BuildContext context,
    Animation<double> animation,
    Animation<double> secondaryAnimation,
    Widget child,
  ) {
    return transitionsBuilder(context, animation, secondaryAnimation, child);
  }
}




Analyze the codebase context.
Identify the top 5-10 core most important abstractions to help those new to the codebase.

For each abstraction, provide:
1. A concise `name`.
2. A beginner-friendly `description` explaining what it is with a simple analogy, in around 100 words.
3. A list of relevant `file_indices` (integers) using the format `idx # path/comment`.

List of file indices and paths present in the context:
- 0 # packages/flutter/lib/src/cupertino/route.dart
- 1 # packages/flutter/lib/src/material/page.dart
- 2 # packages/flutter/lib/src/widgets/pages.dart

Format the output as a YAML list of dictionaries:

```yaml
- name: |
    Query Processing
  description: |
    Explains what the abstraction does.
    It's like a central dispatcher routing requests.
  file_indices:
    - 0 # path/to/file1.py
    - 3 # path/to/related.py
- name: |
    Query Optimization
  description: |
    Another core concept, similar to a blueprint for objects.
  file_indices:
    - 5 # path/to/another.js
# ... up to 10 abstractions
```
2025-05-21 12:31:28,306 - INFO - RESPONSE: ```yaml
- name: |
    PageRoute
  description: |
    Imagine your app screens are like distinct locations in a building. A `PageRoute` is the plan for how to get from one room (screen) to another. It defines what the new screen looks like, how long the transition takes, and what its behavior is (like if you can dismiss it easily). It's the blueprint for a single "page" or screen in your app's navigation history.
  file_indices:
    - 2 # packages/flutter/lib/src/widgets/pages.dart
    - 0 # packages/flutter/lib/src/cupertino/route.dart
    - 1 # packages/flutter/lib/src/material/page.dart
- name: |
    CupertinoPageRoute
  description: |
    Building on the `PageRoute` concept, a `CupertinoPageRoute` is specifically designed for apps that look and feel like they belong on Apple's iOS devices. It uses the characteristic sliding transitions from the right and other iOS visual cues when you move between screens. It's like a specialized "iOS-style" blueprint for navigating between pages.
  file_indices:
    - 0 # packages/flutter/lib/src/cupertino/route.dart
- name: |
    MaterialPageRoute
  description: |
    Similar to `CupertinoPageRoute`, the `MaterialPageRoute` is for apps that follow Google's Material Design guidelines. It provides platform-adaptive transitions, meaning it uses an Android-style fade and zoom on Android devices and an iOS-style slide on iOS devices. It's a "Material Design" blueprint that adapts its transition style based on the device being used.
  file_indices:
    - 1 # packages/flutter/lib/src/material/page.dart
- name: |
    CupertinoRouteTransitionMixin
  description: |
    This is like a recipe for adding iOS-style screen transitions (like sliding from the right or from the bottom for dialogs) to any `PageRoute`. Instead of having to write the transition code from scratch every time, you can "mix in" this behavior to your `PageRoute` to get the signature Cupertino look and feel for your navigations.
  file_indices:
    - 0 # packages/flutter/lib/src/cupertino/route.dart
- name: |
    MaterialRouteTransitionMixin
  description: |
    This is the Material Design counterpart to `CupertinoRouteTransitionMixin`. It provides the "ingredients" for implementing platform-adaptive transitions for a `PageRoute`. This mixin makes sure that your screen transitions follow the Material Design guidelines, using appropriate animations based on the operating system (Android or iOS).
  file_indices:
    - 1 # packages/flutter/lib/src/material/page.dart
- name: |
    CupertinoPageTransition
  description: |
    This widget represents the actual animation you see when a new Cupertino-style page slides in from the right. It takes the animation progress and the new screen's content and visually transforms it from off-screen to on-screen, often with a parallax effect on the previous screen. It's the "visual effect" part of the Cupertino page navigation.
  file_indices:
    - 0 # packages/flutter/lib/src/cupertino/route.dart
- name: |
    CupertinoFullscreenDialogTransition
  description: |
    This is a specialized transition widget specifically for full-screen dialogs in the Cupertino style. Unlike regular pages that slide horizontally, these dialogs typically animate up from the bottom of the screen. This widget handles the visual animation for these specific types of pop-ups.
  file_indices:
    - 0 # packages/flutter/lib/src/cupertino/route.dart
- name: |
    CupertinoModalPopupRoute
  description: |
    Imagine a smaller panel that pops up from the bottom of the screen to ask you something or present options, without covering the whole screen. This is what a `CupertinoModalPopupRoute` handles. It defines the behavior and appearance of these non-fullscreen, bottom-sliding pop-ups often used in iOS for action sheets and other temporary interfaces.
  file_indices:
    - 0 # packages/flutter/lib/src/cupertino/route.dart
- name: |
    CupertinoDialogRoute
  description: |
    This is the route for showing those classic iOS-style alert boxes that appear in the center of the screen asking for confirmation or providing important information. It manages the subtle fade-in and scaling animation for these dialogs and handles things like the dimmed background behind the dialog.
  file_indices:
    - 0 # packages/flutter/lib/src/cupertino/route.dart
```
2025-05-21 12:31:28,316 - INFO - PROMPT: 
Based on the following abstractions and relevant code snippets from the project `flutter`:

List of Abstraction Indices and Names:
0 # PageRoute

1 # CupertinoPageRoute

2 # MaterialPageRoute

3 # CupertinoRouteTransitionMixin

4 # MaterialRouteTransitionMixin

5 # CupertinoPageTransition

6 # CupertinoFullscreenDialogTransition

7 # CupertinoModalPopupRoute

8 # CupertinoDialogRoute


Context (Abstractions, Descriptions, Code):
Identified Abstractions:\n- Index 0: PageRoute
 (Relevant file indices: [0, 1, 2])\n  Description: Imagine your app screens are like distinct locations in a building. A `PageRoute` is the plan for how to get from one room (screen) to another. It defines what the new screen looks like, how long the transition takes, and what its behavior is (like if you can dismiss it easily). It's the blueprint for a single "page" or screen in your app's navigation history.
\n- Index 1: CupertinoPageRoute
 (Relevant file indices: [0])\n  Description: Building on the `PageRoute` concept, a `CupertinoPageRoute` is specifically designed for apps that look and feel like they belong on Apple's iOS devices. It uses the characteristic sliding transitions from the right and other iOS visual cues when you move between screens. It's like a specialized "iOS-style" blueprint for navigating between pages.
\n- Index 2: MaterialPageRoute
 (Relevant file indices: [1])\n  Description: Similar to `CupertinoPageRoute`, the `MaterialPageRoute` is for apps that follow Google's Material Design guidelines. It provides platform-adaptive transitions, meaning it uses an Android-style fade and zoom on Android devices and an iOS-style slide on iOS devices. It's a "Material Design" blueprint that adapts its transition style based on the device being used.
\n- Index 3: CupertinoRouteTransitionMixin
 (Relevant file indices: [0])\n  Description: This is like a recipe for adding iOS-style screen transitions (like sliding from the right or from the bottom for dialogs) to any `PageRoute`. Instead of having to write the transition code from scratch every time, you can "mix in" this behavior to your `PageRoute` to get the signature Cupertino look and feel for your navigations.
\n- Index 4: MaterialRouteTransitionMixin
 (Relevant file indices: [1])\n  Description: This is the Material Design counterpart to `CupertinoRouteTransitionMixin`. It provides the "ingredients" for implementing platform-adaptive transitions for a `PageRoute`. This mixin makes sure that your screen transitions follow the Material Design guidelines, using appropriate animations based on the operating system (Android or iOS).
\n- Index 5: CupertinoPageTransition
 (Relevant file indices: [0])\n  Description: This widget represents the actual animation you see when a new Cupertino-style page slides in from the right. It takes the animation progress and the new screen's content and visually transforms it from off-screen to on-screen, often with a parallax effect on the previous screen. It's the "visual effect" part of the Cupertino page navigation.
\n- Index 6: CupertinoFullscreenDialogTransition
 (Relevant file indices: [0])\n  Description: This is a specialized transition widget specifically for full-screen dialogs in the Cupertino style. Unlike regular pages that slide horizontally, these dialogs typically animate up from the bottom of the screen. This widget handles the visual animation for these specific types of pop-ups.
\n- Index 7: CupertinoModalPopupRoute
 (Relevant file indices: [0])\n  Description: Imagine a smaller panel that pops up from the bottom of the screen to ask you something or present options, without covering the whole screen. This is what a `CupertinoModalPopupRoute` handles. It defines the behavior and appearance of these non-fullscreen, bottom-sliding pop-ups often used in iOS for action sheets and other temporary interfaces.
\n- Index 8: CupertinoDialogRoute
 (Relevant file indices: [0])\n  Description: This is the route for showing those classic iOS-style alert boxes that appear in the center of the screen asking for confirmation or providing important information. It manages the subtle fade-in and scaling animation for these dialogs and handles things like the dimmed background behind the dialog.
\n\nRelevant File Snippets (Referenced by Index and Path):\n--- File: 0 # packages/flutter/lib/src/cupertino/route.dart ---\n// Copyright 2014 The Flutter Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

/// @docImport 'dart:ui';
///
/// @docImport 'package:flutter/material.dart';
/// @docImport 'package:flutter/services.dart';
///
/// @docImport 'app.dart';
/// @docImport 'button.dart';
/// @docImport 'dialog.dart';
/// @docImport 'nav_bar.dart';
/// @docImport 'page_scaffold.dart';
/// @docImport 'tab_scaffold.dart';
library;

import 'dart:math';
import 'dart:ui' show ImageFilter;

import 'package:flutter/foundation.dart';
import 'package:flutter/gestures.dart';
import 'package:flutter/physics.dart';
import 'package:flutter/rendering.dart';
import 'package:flutter/widgets.dart';

import 'colors.dart';
import 'interface_level.dart';
import 'localizations.dart';

const double _kBackGestureWidth = 20.0;
const double _kMinFlingVelocity = 1.0; // Screen widths per second.

// The duration for a page to animate when the user releases it mid-swipe.
const Duration _kDroppedSwipePageAnimationDuration = Duration(milliseconds: 350);

/// Barrier color used for a barrier visible during transitions for Cupertino
/// page routes.
///
/// This barrier color is only used for full-screen page routes with
/// `fullscreenDialog: false`.
///
/// By default, `fullscreenDialog` Cupertino route transitions have no
/// `barrierColor`, and [CupertinoDialogRoute]s and [CupertinoModalPopupRoute]s
/// have a `barrierColor` defined by [kCupertinoModalBarrierColor].
///
/// A relatively rigorous eyeball estimation.
const Color _kCupertinoPageTransitionBarrierColor = Color(0x18000000);

/// Barrier color for a Cupertino modal barrier.
///
/// Extracted from https://developer.apple.com/design/resources/.
const Color kCupertinoModalBarrierColor = CupertinoDynamicColor.withBrightness(
  color: Color(0x33000000),
  darkColor: Color(0x7A000000),
);

// The duration of the transition used when a modal popup is shown.
const Duration _kModalPopupTransitionDuration = Duration(milliseconds: 335);

// Offset from offscreen to the right to fully on screen.
final Animatable<Offset> _kRightMiddleTween = Tween<Offset>(
  begin: const Offset(1.0, 0.0),
  end: Offset.zero,
);

// Offset from fully on screen to 1/3 offscreen to the left.
final Animatable<Offset> _kMiddleLeftTween = Tween<Offset>(
  begin: Offset.zero,
  end: const Offset(-1.0 / 3.0, 0.0),
);

// Offset from offscreen below to fully on screen.
final Animatable<Offset> _kBottomUpTween = Tween<Offset>(
  begin: const Offset(0.0, 1.0),
  end: Offset.zero,
);

/// A mixin that replaces the entire screen with an iOS transition for a
/// [PageRoute].
///
/// {@template flutter.cupertino.cupertinoRouteTransitionMixin}
/// The page slides in from the right and exits in reverse. The page also shifts
/// to the left in parallax when another page enters to cover it.
///
/// The page slides in from the bottom and exits in reverse with no parallax
/// effect for fullscreen dialogs.
/// {@endtemplate}
///
/// See also:
///
///  * [MaterialRouteTransitionMixin], which is a mixin that provides
///    platform-appropriate transitions for a [PageRoute].
///  * [CupertinoPageRoute], which is a [PageRoute] that leverages this mixin.
mixin CupertinoRouteTransitionMixin<T> on PageRoute<T> {
  /// Builds the primary contents of the route.
  @protected
  Widget buildContent(BuildContext context);

  /// {@template flutter.cupertino.CupertinoRouteTransitionMixin.title}
  /// A title string for this route.
  ///
  /// Used to auto-populate [CupertinoNavigationBar] and
  /// [CupertinoSliverNavigationBar]'s `middle`/`largeTitle` widgets when
  /// one is not manually supplied.
  /// {@endtemplate}
  String? get title;

  ValueNotifier<String?>? _previousTitle;

  /// The title string of the previous [CupertinoPageRoute].
  ///
  /// The [ValueListenable]'s value is readable after the route is installed
  /// onto a [Navigator]. The [ValueListenable] will also notify its listeners
  /// if the value changes (such as by replacing the previous route).
  ///
  /// The [ValueListenable] itself will be null before the route is installed.
  /// Its content value will be null if the previous route has no title or
  /// is not a [CupertinoPageRoute].
  ///
  /// See also:
  ///
  ///  * [ValueListenableBuilder], which can be used to listen and rebuild
  ///    widgets based on a ValueListenable.
  ValueListenable<String?> get previousTitle {
    assert(
      _previousTitle != null,
      'Cannot read the previousTitle for a route that has not yet been installed',
    );
    return _previousTitle!;
  }

  @override
  void dispose() {
    _previousTitle?.dispose();
    super.dispose();
  }

  @override
  void didChangePrevious(Route<dynamic>? previousRoute) {
    final String? previousTitleString =
        previousRoute is CupertinoRouteTransitionMixin ? previousRoute.title : null;
    if (_previousTitle == null) {
      _previousTitle = ValueNotifier<String?>(previousTitleString);
    } else {
      _previousTitle!.value = previousTitleString;
    }
    super.didChangePrevious(previousRoute);
  }

  @override
  // A relatively rigorous eyeball estimation.
  Duration get transitionDuration => const Duration(milliseconds: 500);

  @override
  Color? get barrierColor => fullscreenDialog ? null : _kCupertinoPageTransitionBarrierColor;

  @override
  String? get barrierLabel => null;

  @override
  bool canTransitionTo(TransitionRoute<dynamic> nextRoute) {
    // Don't perform outgoing animation if the next route is a fullscreen dialog.
    final bool nextRouteIsNotFullscreen =
        (nextRoute is! PageRoute<T>) || !nextRoute.fullscreenDialog;

    // If the next route has a delegated transition, then this route is able to
    // use that delegated transition to smoothly sync with the next route's
    // transition.
    final bool nextRouteHasDelegatedTransition =
        nextRoute is ModalRoute<T> && nextRoute.delegatedTransition != null;

    // Otherwise if the next route has the same route transition mixin as this
    // one, then this route will already be synced with its transition.
    return nextRouteIsNotFullscreen &&
        ((nextRoute is CupertinoRouteTransitionMixin) || nextRouteHasDelegatedTransition);
  }

  @override
  bool canTransitionFrom(TransitionRoute<dynamic> previousRoute) {
    // Supress previous route from transitioning if this is a fullscreenDialog route.
    return previousRoute is PageRoute && !fullscreenDialog;
  }

  @override
  Widget buildPage(
    BuildContext context,
    Animation<double> animation,
    Animation<double> secondaryAnimation,
  ) {
    final Widget child = buildContent(context);
    return Semantics(scopesRoute: true, explicitChildNodes: true, child: child);
  }

  // Called by _CupertinoBackGestureDetector when a pop ("back") drag start
  // gesture is detected. The returned controller handles all of the subsequent
  // drag events.
  static _CupertinoBackGestureController<T> _startPopGesture<T>(PageRoute<T> route) {
    assert(route.popGestureEnabled);

    return _CupertinoBackGestureController<T>(
      navigator: route.navigator!,
      getIsCurrent: () => route.isCurrent,
      getIsActive: () => route.isActive,
      controller: route.controller!, // protected access
    );
  }

  /// Returns a [CupertinoFullscreenDialogTransition] if [route] is a full
  /// screen dialog, otherwise a [CupertinoPageTransition] is returned.
  ///
  /// Used by [CupertinoPageRoute.buildTransitions].
  ///
  /// This method can be applied to any [PageRoute], not just
  /// [CupertinoPageRoute]. It's typically used to provide a Cupertino style
  /// horizontal transition for material widgets when the target platform
  /// is [TargetPlatform.iOS].
  ///
  /// See also:
  ///
  ///  * [CupertinoPageTransitionsBuilder], which uses this method to define a
  ///    [PageTransitionsBuilder] for the [PageTransitionsTheme].
  static Widget buildPageTransitions<T>(
    PageRoute<T> route,
    BuildContext context,
    Animation<double> animation,
    Animation<double> secondaryAnimation,
    Widget child,
  ) {
    // Check if the route has an animation that's currently participating
    // in a back swipe gesture.
    //
    // In the middle of a back gesture drag, let the transition be linear to
    // match finger motions.
    final bool linearTransition = route.popGestureInProgress;
    if (route.fullscreenDialog) {
      return CupertinoFullscreenDialogTransition(
        primaryRouteAnimation: animation,
        secondaryRouteAnimation: secondaryAnimation,
        linearTransition: linearTransition,
        child: child,
      );
    } else {
      return CupertinoPageTransition(
        primaryRouteAnimation: animation,
        secondaryRouteAnimation: secondaryAnimation,
        linearTransition: linearTransition,
        child: _CupertinoBackGestureDetector<T>(
          enabledCallback: () => route.popGestureEnabled,
          onStartPopGesture: () => _startPopGesture<T>(route),
          child: child,
        ),
      );
    }
  }

  @override
  Widget buildTransitions(
    BuildContext context,
    Animation<double> animation,
    Animation<double> secondaryAnimation,
    Widget child,
  ) {
    return buildPageTransitions<T>(this, context, animation, secondaryAnimation, child);
  }
}

/// A modal route that replaces the entire screen with an iOS transition.
///
/// {@macro flutter.cupertino.cupertinoRouteTransitionMixin}
///
/// By default, when a modal route is replaced by another, the previous route
/// remains in memory. To free all the resources when this is not necessary, set
/// [maintainState] to false.
///
/// The type `T` specifies the return type of the route which can be supplied as
/// the route is popped from the stack via [Navigator.pop] when an optional
/// `result` can be provided.
///
/// If `barrierDismissible` is true, then pressing the escape key on the keyboard
/// will cause the current route to be popped with null as the value.
///
/// See also:
///
///  * [CupertinoRouteTransitionMixin], for a mixin that provides iOS transition
///    for this modal route.
///  * [MaterialPageRoute], for an adaptive [PageRoute] that uses a
///    platform-appropriate transition.
///  * [CupertinoPageScaffold], for applications that have one page with a fixed
///    navigation bar on top.
///  * [CupertinoTabScaffold], for applications that have a tab bar at the
///    bottom with multiple pages.
///  * [CupertinoPage], for a [Page] version of this class.
class CupertinoPageRoute<T> extends PageRoute<T> with CupertinoRouteTransitionMixin<T> {
  /// Creates a page route for use in an iOS designed app.
  ///
  /// The [builder], [maintainState], and [fullscreenDialog] arguments must not
  /// be null.
  CupertinoPageRoute({
    required this.builder,
    this.title,
    super.settings,
    super.requestFocus,
    this.maintainState = true,
    super.fullscreenDialog,
    super.allowSnapshotting = true,
    super.barrierDismissible = false,
  }) {
    assert(opaque);
  }

  @override
  DelegatedTransitionBuilder? get delegatedTransition =>
      CupertinoPageTransition.delegatedTransition;

  /// Builds the primary contents of the route.
  final WidgetBuilder builder;

  @override
  Widget buildContent(BuildContext context) => builder(context);

  @override
  final String? title;

  @override
  final bool maintainState;

  @override
  String get debugLabel => '${super.debugLabel}(${settings.name})';
}

// A page-based version of CupertinoPageRoute.
//
// This route uses the builder from the page to build its content. This ensures
// the content is up to date after page updates.
class _PageBasedCupertinoPageRoute<T> extends PageRoute<T> with CupertinoRouteTransitionMixin<T> {
  _PageBasedCupertinoPageRoute({required CupertinoPage<T> page, super.allowSnapshotting = true})
    : super(settings: page) {
    assert(opaque);
  }

  @override
  DelegatedTransitionBuilder? get delegatedTransition =>
      this.fullscreenDialog ? null : CupertinoPageTransition.delegatedTransition;

  CupertinoPage<T> get _page => settings as CupertinoPage<T>;

  @override
  Widget buildContent(BuildContext context) => _page.child;

  @override
  String? get title => _page.title;

  @override
  bool get maintainState => _page.maintainState;

  @override
  bool get fullscreenDialog => _page.fullscreenDialog;

  @override
  String get debugLabel => '${super.debugLabel}(${_page.name})';
}

/// A page that creates a cupertino style [PageRoute].
///
/// {@macro flutter.cupertino.cupertinoRouteTransitionMixin}
///
/// By default, when a created modal route is replaced by another, the previous
/// route remains in memory. To free all the resources when this is not
/// necessary, set [maintainState] to false.
///
/// The type `T` specifies the return type of the route which can be supplied as
/// the route is popped from the stack via [Navigator.transitionDelegate] by
/// providing the optional `result` argument to the
/// [RouteTransitionRecord.markForPop] in the [TransitionDelegate.resolve].
///
/// See also:
///
///  * [CupertinoPageRoute], for a [PageRoute] version of this class.
class CupertinoPage<T> extends Page<T> {
  /// Creates a cupertino page.
  const CupertinoPage({
    required this.child,
    this.maintainState = true,
    this.title,
    this.fullscreenDialog = false,
    this.allowSnapshotting = true,
    super.canPop,
    super.onPopInvoked,
    super.key,
    super.name,
    super.arguments,
    super.restorationId,
  });

  /// The content to be shown in the [Route] created by this page.
  final Widget child;

  /// {@macro flutter.cupertino.CupertinoRouteTransitionMixin.title}
  final String? title;

  /// {@macro flutter.widgets.ModalRoute.maintainState}
  final bool maintainState;

  /// {@macro flutter.widgets.PageRoute.fullscreenDialog}
  final bool fullscreenDialog;

  /// {@macro flutter.widgets.TransitionRoute.allowSnapshotting}
  final bool allowSnapshotting;

  @override
  Route<T> createRoute(BuildContext context) {
    return _PageBasedCupertinoPageRoute<T>(page: this, allowSnapshotting: allowSnapshotting);
  }
}

/// Provides an iOS-style page transition animation.
///
/// The page slides in from the right and exits in reverse. It also shifts to the left in
/// a parallax motion when another page enters to cover it.
class CupertinoPageTransition extends StatefulWidget {
  /// Creates an iOS-style page transition.
  ///
  const CupertinoPageTransition({
    super.key,
    required this.primaryRouteAnimation,
    required this.secondaryRouteAnimation,
    required this.child,
    required this.linearTransition,
  });

  /// The widget below this widget in the tree.
  final Widget child;

  ///  * `primaryRouteAnimation` is a linear route animation from 0.0 to 1.0
  ///    when this screen is being pushed.
  final Animation<double> primaryRouteAnimation;

  ///  * `secondaryRouteAnimation` is a linear route animation from 0.0 to 1.0
  ///    when another screen is being pushed on top of this one.
  final Animation<double> secondaryRouteAnimation;

  ///  * `linearTransition` is whether to perform the transitions linearly.
  ///    Used to precisely track back gesture drags.
  final bool linearTransition;

  /// The Cupertino styled [DelegatedTransitionBuilder] provided to the previous
  /// route.
  ///
  /// {@macro flutter.widgets.delegatedTransition}
  static Widget? delegatedTransition(
    BuildContext context,
    Animation<double> animation,
    Animation<double> secondaryAnimation,
    bool allowSnapshotting,
    Widget? child,
  ) {
    final CurvedAnimation animation = CurvedAnimation(
      parent: secondaryAnimation,
      curve: Curves.linearToEaseOut,
      reverseCurve: Curves.easeInToLinear,
    );
    final Animation<Offset> delegatedPositionAnimation = animation.drive(_kMiddleLeftTween);
    animation.dispose();

    assert(debugCheckHasDirectionality(context));
    final TextDirection textDirection = Directionality.of(context);
    return SlideTransition(
      position: delegatedPositionAnimation,
      textDirection: textDirection,
      transformHitTests: false,
      child: child,
    );
  }

  @override
  State<CupertinoPageTransition> createState() => _CupertinoPageTransitionState();
}

class _CupertinoPageTransitionState extends State<CupertinoPageTransition> {
  // When this page is coming in to cover another page.
  late Animation<Offset> _primaryPositionAnimation;
  // When this page is becoming covered by another page.
  late Animation<Offset> _secondaryPositionAnimation;
  // Shadow of page which is coming in to cover another page.
  late Animation<Decoration> _primaryShadowAnimation;
  // Curve of primary page which is coming in to cover another page.
  CurvedAnimation? _primaryPositionCurve;
  // Curve of secondary page which is becoming covered by another page.
  CurvedAnimation? _secondaryPositionCurve;
  // Curve of primary page's shadow.
  CurvedAnimation? _primaryShadowCurve;

  @override
  void initState() {
    super.initState();
    _setupAnimation();
  }

  @override
  void didUpdateWidget(covariant CupertinoPageTransition oldWidget) {
    super.didUpdateWidget(oldWidget);
    if (oldWidget.primaryRouteAnimation != widget.primaryRouteAnimation ||
        oldWidget.secondaryRouteAnimation != widget.secondaryRouteAnimation ||
        oldWidget.linearTransition != widget.linearTransition) {
      _disposeCurve();
      _setupAnimation();
    }
  }

  @override
  void dispose() {
    _disposeCurve();
    super.dispose();
  }

  void _disposeCurve() {
    _primaryPositionCurve?.dispose();
    _secondaryPositionCurve?.dispose();
    _primaryShadowCurve?.dispose();
    _primaryPositionCurve = null;
    _secondaryPositionCurve = null;
    _primaryShadowCurve = null;
  }

  void _setupAnimation() {
    if (!widget.linearTransition) {
      _primaryPositionCurve = CurvedAnimation(
        parent: widget.primaryRouteAnimation,
        curve: Curves.fastEaseInToSlowEaseOut,
        reverseCurve: Curves.fastEaseInToSlowEaseOut.flipped,
      );
      _secondaryPositionCurve = CurvedAnimation(
        parent: widget.secondaryRouteAnimation,
        curve: Curves.linearToEaseOut,
        reverseCurve: Curves.easeInToLinear,
      );
      _primaryShadowCurve = CurvedAnimation(
        parent: widget.primaryRouteAnimation,
        curve: Curves.linearToEaseOut,
      );
    }
    _primaryPositionAnimation = (_primaryPositionCurve ?? widget.primaryRouteAnimation).drive(
      _kRightMiddleTween,
    );
    _secondaryPositionAnimation = (_secondaryPositionCurve ?? widget.secondaryRouteAnimation).drive(
      _kMiddleLeftTween,
    );
    _primaryShadowAnimation = (_primaryShadowCurve ?? widget.primaryRouteAnimation).drive(
      _CupertinoEdgeShadowDecoration.kTween,
    );
  }

  @override
  Widget build(BuildContext context) {
    assert(debugCheckHasDirectionality(context));
    final TextDirection textDirection = Directionality.of(context);
    return SlideTransition(
      position: _secondaryPositionAnimation,
      textDirection: textDirection,
      transformHitTests: false,
      child: SlideTransition(
        position: _primaryPositionAnimation,
        textDirection: textDirection,
        child: DecoratedBoxTransition(decoration: _primaryShadowAnimation, child: widget.child),
      ),
    );
  }
}

/// An iOS-style transition used for summoning fullscreen dialogs.
///
/// For example, used when creating a new calendar event by bringing in the next
/// screen from the bottom.
class CupertinoFullscreenDialogTransition extends StatefulWidget {
  /// Creates an iOS-style transition used for summoning fullscreen dialogs.
  ///
  const CupertinoFullscreenDialogTransition({
    super.key,
    required this.primaryRouteAnimation,
    required this.secondaryRouteAnimation,
    required this.child,
    required this.linearTransition,
  });

  ///  * `primaryRouteAnimation` is a linear route animation from 0.0 to 1.0
  ///    when this screen is being pushed.
  final Animation<double> primaryRouteAnimation;

  ///  * `secondaryRouteAnimation` is a linear route animation from 0.0 to 1.0
  ///    when another screen is being pushed on top of this one.
  final Animation<double> secondaryRouteAnimation;

  ///  * `linearTransition` is whether to perform the transitions linearly.
  ///    Used to precisely track back gesture drags.
  final bool linearTransition;

  /// The widget below this widget in the tree.
  final Widget child;

  @override
  State<CupertinoFullscreenDialogTransition> createState() =>
      _CupertinoFullscreenDialogTransitionState();
}

class _CupertinoFullscreenDialogTransitionState extends State<CupertinoFullscreenDialogTransition> {
  /// When this page is coming in to cover another page.
  late Animation<Offset> _primaryPositionAnimation;

  /// When this page is becoming covered by another page.
  late Animation<Offset> _secondaryPositionAnimation;

  /// Curve of primary page which is coming in to cover another page.
  CurvedAnimation? _primaryPositionCurve;

  /// Curve of secondary page which is becoming covered by another page.
  CurvedAnimation? _secondaryPositionCurve;

  @override
  void initState() {
    super.initState();
    _setupAnimation();
  }

  @override
  void didUpdateWidget(covariant CupertinoFullscreenDialogTransition oldWidget) {
    super.didUpdateWidget(oldWidget);
    if (oldWidget.primaryRouteAnimation != widget.primaryRouteAnimation ||
        oldWidget.secondaryRouteAnimation != widget.secondaryRouteAnimation ||
        oldWidget.linearTransition != widget.linearTransition) {
      _disposeCurve();
      _setupAnimation();
    }
  }

  @override
  void dispose() {
    _disposeCurve();
    super.dispose();
  }

  void _disposeCurve() {
    _primaryPositionCurve?.dispose();
    _secondaryPositionCurve?.dispose();
    _primaryPositionCurve = null;
    _secondaryPositionCurve = null;
  }

  void _setupAnimation() {
    _primaryPositionAnimation = (_primaryPositionCurve = CurvedAnimation(
          parent: widget.primaryRouteAnimation,
          curve: Curves.linearToEaseOut,
          // The curve must be flipped so that the reverse animation doesn't play
          // an ease-in curve, which iOS does not use.
          reverseCurve: Curves.linearToEaseOut.flipped,
        ))
        .drive(_kBottomUpTween);
    _secondaryPositionAnimation = (widget.linearTransition
            ? widget.secondaryRouteAnimation
            : _secondaryPositionCurve = CurvedAnimation(
              parent: widget.secondaryRouteAnimation,
              curve: Curves.linearToEaseOut,
              reverseCurve: Curves.easeInToLinear,
            ))
        .drive(_kMiddleLeftTween);
  }

  @override
  Widget build(BuildContext context) {
    assert(debugCheckHasDirectionality(context));
    final TextDirection textDirection = Directionality.of(context);
    return SlideTransition(
      position: _secondaryPositionAnimation,
      textDirection: textDirection,
      transformHitTests: false,
      child: SlideTransition(position: _primaryPositionAnimation, child: widget.child),
    );
  }
}

/// This is the widget side of [_CupertinoBackGestureController].
///
/// This widget provides a gesture recognizer which, when it determines the
/// route can be closed with a back gesture, creates the controller and
/// feeds it the input from the gesture recognizer.
///
/// The gesture data is converted from absolute coordinates to logical
/// coordinates by this widget.
///
/// The type `T` specifies the return type of the route with which this gesture
/// detector is associated.
class _CupertinoBackGestureDetector<T> extends StatefulWidget {
  const _CupertinoBackGestureDetector({
    super.key,
    required this.enabledCallback,
    required this.onStartPopGesture,
    required this.child,
  });

  final Widget child;

  final ValueGetter<bool> enabledCallback;

  final ValueGetter<_CupertinoBackGestureController<T>> onStartPopGesture;

  @override
  _CupertinoBackGestureDetectorState<T> createState() => _CupertinoBackGestureDetectorState<T>();
}

class _CupertinoBackGestureDetectorState<T> extends State<_CupertinoBackGestureDetector<T>> {
  _CupertinoBackGestureController<T>? _backGestureController;

  late HorizontalDragGestureRecognizer _recognizer;

  @override
  void initState() {
    super.initState();
    _recognizer =
        HorizontalDragGestureRecognizer(debugOwner: this)
          ..onStart = _handleDragStart
          ..onUpdate = _handleDragUpdate
          ..onEnd = _handleDragEnd
          ..onCancel = _handleDragCancel;
  }

  @override
  void dispose() {
    _recognizer.dispose();

    // If this is disposed during a drag, call navigator.didStopUserGesture.
    if (_backGestureController != null) {
      WidgetsBinding.instance.addPostFrameCallback((_) {
        if (_backGestureController?.navigator.mounted ?? false) {
          _backGestureController?.navigator.didStopUserGesture();
        }
        _backGestureController = null;
      });
    }
    super.dispose();
  }

  void _handleDragStart(DragStartDetails details) {
    assert(mounted);
    assert(_backGestureController == null);
    _backGestureController = widget.onStartPopGesture();
  }

  void _handleDragUpdate(DragUpdateDetails details) {
    assert(mounted);
    assert(_backGestureController != null);
    _backGestureController!.dragUpdate(
      _convertToLogical(details.primaryDelta! / context.size!.width),
    );
  }

  void _handleDragEnd(DragEndDetails details) {
    assert(mounted);
    assert(_backGestureController != null);
    _backGestureController!.dragEnd(
      _convertToLogical(details.velocity.pixelsPerSecond.dx / context.size!.width),
    );
    _backGestureController = null;
  }

  void _handleDragCancel() {
    assert(mounted);
    // This can be called even if start is not called, paired with the "down" event
    // that we don't consider here.
    _backGestureController?.dragEnd(0.0);
    _backGestureController = null;
  }

  void _handlePointerDown(PointerDownEvent event) {
    if (widget.enabledCallback()) {
      _recognizer.addPointer(event);
    }
  }

  double _convertToLogical(double value) {
    return switch (Directionality.of(context)) {
      TextDirection.rtl => -value,
      TextDirection.ltr => value,
    };
  }

  @override
  Widget build(BuildContext context) {
    assert(debugCheckHasDirectionality(context));
    // For devices with notches, the drag area needs to be larger on the side
    // that has the notch.
    final double dragAreaWidth = switch (Directionality.of(context)) {
      TextDirection.rtl => MediaQuery.paddingOf(context).right,
      TextDirection.ltr => MediaQuery.paddingOf(context).left,
    };
    return Stack(
      fit: StackFit.passthrough,
      children: <Widget>[
        widget.child,
        PositionedDirectional(
          start: 0.0,
          width: max(dragAreaWidth, _kBackGestureWidth),
          top: 0.0,
          bottom: 0.0,
          child: Listener(onPointerDown: _handlePointerDown, behavior: HitTestBehavior.translucent),
        ),
      ],
    );
  }
}

/// A controller for an iOS-style back gesture.
///
/// This is created by a [CupertinoPageRoute] in response from a gesture caught
/// by a [_CupertinoBackGestureDetector] widget, which then also feeds it input
/// from the gesture. It controls the animation controller owned by the route,
/// based on the input provided by the gesture detector.
///
/// This class works entirely in logical coordinates (0.0 is new page dismissed,
/// 1.0 is new page on top).
///
/// The type `T` specifies the return type of the route with which this gesture
/// detector controller is associated.
class _CupertinoBackGestureController<T> {
  /// Creates a controller for an iOS-style back gesture.
  _CupertinoBackGestureController({
    required this.navigator,
    required this.controller,
    required this.getIsActive,
    required this.getIsCurrent,
  }) {
    navigator.didStartUserGesture();
  }

  final AnimationController controller;
  final NavigatorState navigator;
  final ValueGetter<bool> getIsActive;
  final ValueGetter<bool> getIsCurrent;

  /// The drag gesture has changed by [delta]. The total range of the drag
  /// should be 0.0 to 1.0.
  void dragUpdate(double delta) {
    controller.value -= delta;
  }

  /// The drag gesture has ended with a horizontal motion of [velocity] as a
  /// fraction of screen width per second.
  void dragEnd(double velocity) {
    // Fling in the appropriate direction.
    //
    // This curve has been determined through rigorously eyeballing native iOS
    // animations.
    const Curve animationCurve = Curves.fastEaseInToSlowEaseOut;
    final bool isCurrent = getIsCurrent();
    final bool animateForward;

    if (!isCurrent) {
      // If the page has already been navigated away from, then the animation
      // direction depends on whether or not it's still in the navigation stack,
      // regardless of velocity or drag position. For example, if a route is
      // being slowly dragged back by just a few pixels, but then a programmatic
      // pop occurs, the route should still be animated off the screen.
      // See https://github.com/flutter/flutter/issues/141268.
      animateForward = getIsActive();
    } else if (velocity.abs() >= _kMinFlingVelocity) {
      // If the user releases the page before mid screen with sufficient velocity,
      // or after mid screen, we should animate the page out. Otherwise, the page
      // should be animated back in.
      animateForward = velocity <= 0;
    } else {
      animateForward = controller.value > 0.5;
    }

    if (animateForward) {
      controller.animateTo(
        1.0,
        duration: _kDroppedSwipePageAnimationDuration,
        curve: animationCurve,
      );
    } else {
      if (isCurrent) {
        // This route is destined to pop at this point. Reuse navigator's pop.
        navigator.pop();
      }

      // The popping may have finished inline if already at the target destination.
      if (controller.isAnimating) {
        controller.animateBack(
          0.0,
          duration: _kDroppedSwipePageAnimationDuration,
          curve: animationCurve,
        );
      }
    }

    if (controller.isAnimating) {
      // Keep the userGestureInProgress in true state so we don't change the
      // curve of the page transition mid-flight since CupertinoPageTransition
      // depends on userGestureInProgress.
      late AnimationStatusListener animationStatusCallback;
      animationStatusCallback = (AnimationStatus status) {
        navigator.didStopUserGesture();
        controller.removeStatusListener(animationStatusCallback);
      };
      controller.addStatusListener(animationStatusCallback);
    } else {
      navigator.didStopUserGesture();
    }
  }
}

// A custom [Decoration] used to paint an extra shadow on the start edge of the
// box it's decorating. It's like a [BoxDecoration] with only a gradient except
// it paints on the start side of the box instead of behind the box.
class _CupertinoEdgeShadowDecoration extends Decoration {
  const _CupertinoEdgeShadowDecoration._([this._colors]);

  static DecorationTween kTween = DecorationTween(
    begin: const _CupertinoEdgeShadowDecoration._(), // No decoration initially.
    end: const _CupertinoEdgeShadowDecoration._(
      // Eyeballed gradient used to mimic a drop shadow on the start side only.
      <Color>[Color(0x04000000), CupertinoColors.transparent],
    ),
  );

  // Colors used to paint a gradient at the start edge of the box it is
  // decorating.
  //
  // The first color in the list is used at the start of the gradient, which
  // is located at the start edge of the decorated box.
  //
  // If this is null, no shadow is drawn.
  //
  // The list must have at least two colors in it (otherwise it would not be a
  // gradient).
  final List<Color>? _colors;

  // Linearly interpolate between two edge shadow decorations decorations.
  //
  // The `t` argument represents position on the timeline, with 0.0 meaning
  // that the interpolation has not started, returning `a` (or something
  // equivalent to `a`), 1.0 meaning that the interpolation has finished,
  // returning `b` (or something equivalent to `b`), and values in between
  // meaning that the interpolation is at the relevant point on the timeline
  // between `a` and `b`. The interpolation can be extrapolated beyond 0.0 and
  // 1.0, so negative values and values greater than 1.0 are valid (and can
  // easily be generated by curves such as [Curves.elasticInOut]).
  //
  // Values for `t` are usually obtained from an [Animation<double>], such as
  // an [AnimationController].
  //
  // See also:
  //
  //  * [Decoration.lerp].
  static _CupertinoEdgeShadowDecoration? lerp(
    _CupertinoEdgeShadowDecoration? a,
    _CupertinoEdgeShadowDecoration? b,
    double t,
  ) {
    if (identical(a, b)) {
      return a;
    }
    if (a == null) {
      return b!._colors == null
          ? b
          : _CupertinoEdgeShadowDecoration._(
            b._colors!.map<Color>((Color color) => Color.lerp(null, color, t)!).toList(),
          );
    }
    if (b == null) {
      return a._colors == null
          ? a
          : _CupertinoEdgeShadowDecoration._(
            a._colors.map<Color>((Color color) => Color.lerp(null, color, 1.0 - t)!).toList(),
          );
    }
    assert(b._colors != null || a._colors != null);
    // If it ever becomes necessary, we could allow decorations with different
    // length' here, similarly to how it is handled in [LinearGradient.lerp].
    assert(b._colors == null || a._colors == null || a._colors.length == b._colors.length);
    return _CupertinoEdgeShadowDecoration._(<Color>[
      for (int i = 0; i < b._colors!.length; i += 1) Color.lerp(a._colors?[i], b._colors[i], t)!,
    ]);
  }

  @override
  _CupertinoEdgeShadowDecoration lerpFrom(Decoration? a, double t) {
    if (a is _CupertinoEdgeShadowDecoration) {
      return _CupertinoEdgeShadowDecoration.lerp(a, this, t)!;
    }
    return _CupertinoEdgeShadowDecoration.lerp(null, this, t)!;
  }

  @override
  _CupertinoEdgeShadowDecoration lerpTo(Decoration? b, double t) {
    if (b is _CupertinoEdgeShadowDecoration) {
      return _CupertinoEdgeShadowDecoration.lerp(this, b, t)!;
    }
    return _CupertinoEdgeShadowDecoration.lerp(this, null, t)!;
  }

  @override
  _CupertinoEdgeShadowPainter createBoxPainter([VoidCallback? onChanged]) {
    return _CupertinoEdgeShadowPainter(this, onChanged);
  }

  @override
  bool operator ==(Object other) {
    if (other.runtimeType != runtimeType) {
      return false;
    }
    return other is _CupertinoEdgeShadowDecoration && other._colors == _colors;
  }

  @override
  int get hashCode => _colors.hashCode;

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties.add(IterableProperty<Color>('colors', _colors));
  }
}

/// A [BoxPainter] used to draw the page transition shadow using gradients.
class _CupertinoEdgeShadowPainter extends BoxPainter {
  _CupertinoEdgeShadowPainter(this._decoration, super.onChanged)
    : assert(_decoration._colors == null || _decoration._colors.length > 1);

  final _CupertinoEdgeShadowDecoration _decoration;

  @override
  void paint(Canvas canvas, Offset offset, ImageConfiguration configuration) {
    final List<Color>? colors = _decoration._colors;
    if (colors == null) {
      return;
    }

    // The following code simulates drawing a [LinearGradient] configured as
    // follows:
    //
    // LinearGradient(
    //   begin: AlignmentDirectional(0.90, 0.0), // Spans 5% of the page.
    //   colors: _decoration._colors,
    // )
    //
    // A performance evaluation on Feb 8, 2021 showed, that drawing the gradient
    // manually as implemented below is more performant than relying on
    // [LinearGradient.createShader] because compiling that shader takes a long
    // time. On an iPhone XR, the implementation below reduced the worst frame
    // time for a cupertino page transition of a newly installed app from ~95ms
    // down to ~30ms, mainly because there's no longer a need to compile a
    // shader for the LinearGradient.
    //
    // The implementation below divides the width of the shadow into multiple
    // bands of equal width, one for each color interval defined by
    // `_decoration._colors`. Band x is filled with a gradient going from
    // `_decoration._colors[x]` to `_decoration._colors[x + 1]` by drawing a
    // bunch of 1px wide rects. The rects change their color by lerping between
    // the two colors that define the interval of the band.

    // Shadow spans 5% of the page.
    final double shadowWidth = 0.05 * configuration.size!.width;
    final double shadowHeight = configuration.size!.height;
    final double bandWidth = shadowWidth / (colors.length - 1);

    final TextDirection? textDirection = configuration.textDirection;
    assert(textDirection != null);
    final (double shadowDirection, double start) = switch (textDirection!) {
      TextDirection.rtl => (1, offset.dx + configuration.size!.width),
      TextDirection.ltr => (-1, offset.dx),
    };

    int bandColorIndex = 0;
    for (int dx = 0; dx < shadowWidth; dx += 1) {
      if (dx ~/ bandWidth != bandColorIndex) {
        bandColorIndex += 1;
      }
      final Paint paint =
          Paint()
            ..color =
                Color.lerp(
                  colors[bandColorIndex],
                  colors[bandColorIndex + 1],
                  (dx % bandWidth) / bandWidth,
                )!;
      final double x = start + shadowDirection * dx;
      canvas.drawRect(Rect.fromLTWH(x - 1.0, offset.dy, 1.0, shadowHeight), paint);
    }
  }
}

// The stiffness used by dialogs and action sheets.
//
// The stiffness value is obtained by examining the properties of
// `CASpringAnimation` in Xcode. The damping value is derived similarly, with
// additional precision calculated based on `_kStandardStiffness` to ensure a
// damping ratio of 1 (critically damped): damping = 2 * sqrt(stiffness)
const double _kStandardStiffness = 522.35;
const double _kStandardDamping = 45.7099552;
const SpringDescription _kStandardSpring = SpringDescription(
  mass: 1,
  stiffness: _kStandardStiffness,
  damping: _kStandardDamping,
);
// The iOS spring animation duration is 0.404 seconds, based on the properties
// of `CASpringAnimation` in Xcode. At this point, the spring's position
// `x(0.404)` is approximately 0.9990000, suggesting that iOS uses a position
// tolerance of 1e-3 (matching the default `_epsilonDefault` value).
//
// However, the spring's velocity `dx(0.404)` is about 0.02, indicating that iOS
// may not consider velocity when determining the animation's end condition. To
// account for this, a larger velocity tolerance is applied here for added
// safety.
const Tolerance _kStandardTolerance = Tolerance(velocity: 0.03);

/// A route that shows a modal iOS-style popup that slides up from the
/// bottom of the screen.
///
/// Such a popup is an alternative to a menu or a dialog and prevents the user
/// from interacting with the rest of the app.
///
/// It is used internally by [showCupertinoModalPopup] or can be directly pushed
/// onto the [Navigator] stack to enable state restoration. See
/// [showCupertinoModalPopup] for a state restoration app example.
///
/// The `barrierColor` argument determines the [Color] of the barrier underneath
/// the popup. When unspecified, the barrier color defaults to a light opacity
/// black scrim based on iOS's dialog screens. To correctly have iOS resolve
/// to the appropriate modal colors, pass in
/// `CupertinoDynamicColor.resolve(kCupertinoModalBarrierColor, context)`.
///
/// The `barrierDismissible` argument determines whether clicking outside the
/// popup results in dismissal. It is `true` by default.
///
/// The `semanticsDismissible` argument is used to determine whether the
/// semantics of the modal barrier are included in the semantics tree.
///
/// The `routeSettings` argument is used to provide [RouteSettings] to the
/// created Route.
///
/// {@macro flutter.widgets.RawDialogRoute}
///
/// See also:
///
///  * [DisplayFeatureSubScreen], which documents the specifics of how
///    [DisplayFeature]s can split the screen into sub-screens.
///  * [CupertinoActionSheet], which is the widget usually returned by the
///    `builder` argument.
///  * <https://developer.apple.com/design/human-interface-guidelines/ios/views/action-sheets/>
class CupertinoModalPopupRoute<T> extends PopupRoute<T> {
  /// A route that shows a modal iOS-style popup that slides up from the
  /// bottom of the screen.
  CupertinoModalPopupRoute({
    required this.builder,
    this.barrierLabel = 'Dismiss',
    this.barrierColor = kCupertinoModalBarrierColor,
    bool barrierDismissible = true,
    bool semanticsDismissible = false,
    super.filter,
    super.settings,
    super.requestFocus,
    this.anchorPoint,
  }) : _barrierDismissible = barrierDismissible,
       _semanticsDismissible = semanticsDismissible;

  /// A builder that builds the widget tree for the [CupertinoModalPopupRoute].
  ///
  /// The [builder] argument typically builds a [CupertinoActionSheet] widget.
  ///
  /// Content below the widget is dimmed with a [ModalBarrier]. The widget built
  /// by the [builder] does not share a context with the route it was originally
  /// built from. Use a [StatefulBuilder] or a custom [StatefulWidget] if the
  /// widget needs to update dynamically.
  final WidgetBuilder builder;

  final bool _barrierDismissible;

  final bool _semanticsDismissible;

  @override
  final String barrierLabel;

  @override
  final Color? barrierColor;

  @override
  bool get barrierDismissible => _barrierDismissible;

  @override
  bool get semanticsDismissible => _semanticsDismissible;

  @override
  Duration get transitionDuration => _kModalPopupTransitionDuration;

  /// {@macro flutter.widgets.DisplayFeatureSubScreen.anchorPoint}
  final Offset? anchorPoint;

  @override
  Simulation createSimulation({required bool forward}) {
    assert(!debugTransitionCompleted(), 'Cannot reuse a $runtimeType after disposing it.');
    final double end = forward ? 1.0 : 0.0;
    return SpringSimulation(
      _kStandardSpring,
      controller!.value,
      end,
      0,
      tolerance: _kStandardTolerance,
      snapToEnd: true,
    );
  }

  @override
  Widget buildPage(
    BuildContext context,
    Animation<double> animation,
    Animation<double> secondaryAnimation,
  ) {
    return CupertinoUserInterfaceLevel(
      data: CupertinoUserInterfaceLevelData.elevated,
      child: DisplayFeatureSubScreen(anchorPoint: anchorPoint, child: Builder(builder: builder)),
    );
  }

  @override
  Widget buildTransitions(
    BuildContext context,
    Animation<double> animation,
    Animation<double> secondaryAnimation,
    Widget child,
  ) {
    return Align(
      alignment: Alignment.bottomCenter,
      child: FractionalTranslation(translation: _offsetTween.evaluate(animation), child: child),
    );
  }

  static final Tween<Offset> _offsetTween = Tween<Offset>(
    begin: const Offset(0.0, 1.0),
    end: Offset.zero,
  );
}

/// Shows a modal iOS-style popup that slides up from the bottom of the screen.
///
/// Such a popup is an alternative to a menu or a dialog and prevents the user
/// from interacting with the rest of the app.
///
/// The `context` argument is used to look up the [Navigator] for the popup.
/// It is only used when the method is called. Its corresponding widget can be
/// safely removed from the tree before the popup is closed.
///
/// The `barrierColor` argument determines the [Color] of the barrier underneath
/// the popup. When unspecified, the barrier color defaults to a light opacity
/// black scrim based on iOS's dialog screens.
///
/// The `barrierDismissible` argument determines whether clicking outside the
/// popup results in dismissal. It is `true` by default.
///
/// The `useRootNavigator` argument is used to determine whether to push the
/// popup to the [Navigator] furthest from or nearest to the given `context`. It
/// is `true` by default.
///
/// The `semanticsDismissible` argument is used to determine whether the
/// semantics of the modal barrier are included in the semantics tree.
///
/// The `routeSettings` argument is used to provide [RouteSettings] to the
/// created Route.
///
/// The `builder` argument typically builds a [CupertinoActionSheet] widget.
/// Content below the widget is dimmed with a [ModalBarrier]. The widget built
/// by the `builder` does not share a context with the location that
/// [showCupertinoModalPopup] is originally called from. Use a
/// [StatefulBuilder] or a custom [StatefulWidget] if the widget needs to
/// update dynamically.
///
/// {@macro flutter.widgets.RawDialogRoute}
///
/// Returns a `Future` that resolves to the value that was passed to
/// [Navigator.pop] when the popup was closed.
///
/// ### State Restoration in Modals
///
/// Using this method will not enable state restoration for the modal. In order
/// to enable state restoration for a modal, use [Navigator.restorablePush]
/// or [Navigator.restorablePushNamed] with [CupertinoModalPopupRoute].
///
/// For more information about state restoration, see [RestorationManager].
///
/// {@tool dartpad}
/// This sample demonstrates how to create a restorable Cupertino modal route.
/// This is accomplished by enabling state restoration by specifying
/// [CupertinoApp.restorationScopeId] and using [Navigator.restorablePush] to
/// push [CupertinoModalPopupRoute] when the [CupertinoButton] is tapped.
///
/// {@macro flutter.widgets.RestorationManager}
///
/// ** See code in examples/api/lib/cupertino/route/show_cupertino_modal_popup.0.dart **
/// {@end-tool}
///
/// See also:
///
///  * [DisplayFeatureSubScreen], which documents the specifics of how
///    [DisplayFeature]s can split the screen into sub-screens.
///  * [CupertinoActionSheet], which is the widget usually returned by the
///    `builder` argument to [showCupertinoModalPopup].
///  * <https://developer.apple.com/design/human-interface-guidelines/ios/views/action-sheets/>
Future<T?> showCupertinoModalPopup<T>({
  required BuildContext context,
  required WidgetBuilder builder,
  ImageFilter? filter,
  Color barrierColor = kCupertinoModalBarrierColor,
  bool barrierDismissible = true,
  bool useRootNavigator = true,
  bool semanticsDismissible = false,
  RouteSettings? routeSettings,
  Offset? anchorPoint,
}) {
  return Navigator.of(context, rootNavigator: useRootNavigator).push(
    CupertinoModalPopupRoute<T>(
      builder: builder,
      filter: filter,
      barrierColor: CupertinoDynamicColor.resolve(barrierColor, context),
      barrierDismissible: barrierDismissible,
      semanticsDismissible: semanticsDismissible,
      settings: routeSettings,
      anchorPoint: anchorPoint,
    ),
  );
}

Widget _buildCupertinoDialogTransitions(
  BuildContext context,
  Animation<double> animation,
  Animation<double> secondaryAnimation,
  Widget child,
) {
  return child;
}

/// Displays an iOS-style dialog above the current contents of the app, with
/// iOS-style entrance and exit animations, modal barrier color, and modal
/// barrier behavior (by default, the dialog is not dismissible with a tap on
/// the barrier).
///
/// This function takes a `builder` which typically builds a [CupertinoAlertDialog]
/// widget. Content below the dialog is dimmed with a [ModalBarrier]. The widget
/// returned by the `builder` does not share a context with the location that
/// [showCupertinoDialog] is originally called from. Use a [StatefulBuilder] or
/// a custom [StatefulWidget] if the dialog needs to update dynamically.
///
/// The `context` argument is used to look up the [Navigator] for the dialog.
/// It is only used when the method is called. Its corresponding widget can
/// be safely removed from the tree before the dialog is closed.
///
/// The `useRootNavigator` argument is used to determine whether to push the
/// dialog to the [Navigator] furthest from or nearest to the given `context`.
/// By default, `useRootNavigator` is `true` and the dialog route created by
/// this method is pushed to the root navigator.
///
/// {@macro flutter.widgets.RawDialogRoute}
///
/// If the application has multiple [Navigator] objects, it may be necessary to
/// call `Navigator.of(context, rootNavigator: true).pop(result)` to close the
/// dialog rather than just `Navigator.pop(context, result)`.
///
/// Returns a [Future] that resolves to the value (if any) that was passed to
/// [Navigator.pop] when the dialog was closed.
///
/// ### State Restoration in Dialogs
///
/// Using this method will not enable state restoration for the dialog. In order
/// to enable state restoration for a dialog, use [Navigator.restorablePush]
/// or [Navigator.restorablePushNamed] with [CupertinoDialogRoute].
///
/// For more information about state restoration, see [RestorationManager].
///
/// {@tool dartpad}
/// This sample demonstrates how to create a restorable Cupertino dialog. This is
/// accomplished by enabling state restoration by specifying
/// [CupertinoApp.restorationScopeId] and using [Navigator.restorablePush] to
/// push [CupertinoDialogRoute] when the [CupertinoButton] is tapped.
///
/// {@macro flutter.widgets.RestorationManager}
///
/// ** See code in examples/api/lib/cupertino/route/show_cupertino_dialog.0.dart **
/// {@end-tool}
///
/// See also:
///
///  * [CupertinoAlertDialog], an iOS-style alert dialog.
///  * [showDialog], which displays a Material-style dialog.
///  * [showGeneralDialog], which allows for customization of the dialog popup.
///  * [DisplayFeatureSubScreen], which documents the specifics of how
///    [DisplayFeature]s can split the screen into sub-screens.
///  * <https://developer.apple.com/design/human-interface-guidelines/alerts/>
Future<T?> showCupertinoDialog<T>({
  required BuildContext context,
  required WidgetBuilder builder,
  String? barrierLabel,
  bool useRootNavigator = true,
  bool barrierDismissible = false,
  RouteSettings? routeSettings,
  Offset? anchorPoint,
}) {
  return Navigator.of(context, rootNavigator: useRootNavigator).push<T>(
    CupertinoDialogRoute<T>(
      builder: builder,
      context: context,
      barrierDismissible: barrierDismissible,
      barrierLabel: barrierLabel,
      barrierColor: CupertinoDynamicColor.resolve(kCupertinoModalBarrierColor, context),
      settings: routeSettings,
      anchorPoint: anchorPoint,
    ),
  );
}

/// A dialog route that shows an iOS-style dialog.
///
/// It is used internally by [showCupertinoDialog] or can be directly pushed
/// onto the [Navigator] stack to enable state restoration. See
/// [showCupertinoDialog] for a state restoration app example.
///
/// This function takes a `builder` which typically builds a [Dialog] widget.
/// Content below the dialog is dimmed with a [ModalBarrier]. The widget
/// returned by the `builder` does not share a context with the location that
/// `showDialog` is originally called from. Use a [StatefulBuilder] or a
/// custom [StatefulWidget] if the dialog needs to update dynamically.
///
/// The `context` argument is used to look up
/// [CupertinoLocalizations.modalBarrierDismissLabel], which provides the
/// modal with a localized accessibility label that will be used for the
/// modal's barrier. However, a custom `barrierLabel` can be passed in as well.
///
/// The `barrierDismissible` argument is used to indicate whether tapping on the
/// barrier will dismiss the dialog. It is `true` by default and cannot be `null`.
///
/// The `barrierColor` argument is used to specify the color of the modal
/// barrier that darkens everything below the dialog. If `null`, then
/// [CupertinoDynamicColor.resolve] is used to compute the modal color.
///
/// The `settings` argument define the settings for this route. See
/// [RouteSettings] for details.
///
/// {@macro flutter.widgets.RawDialogRoute}
///
/// See also:
///
///  * [showCupertinoDialog], which is a way to display
///     an iOS-style dialog.
///  * [showGeneralDialog], which allows for customization of the dialog popup.
///  * [showDialog], which displays a Material dialog.
///  * [DisplayFeatureSubScreen], which documents the specifics of how
///    [DisplayFeature]s can split the screen into sub-screens.
class CupertinoDialogRoute<T> extends RawDialogRoute<T> {
  /// A dialog route that shows an iOS-style dialog.
  CupertinoDialogRoute({
    required WidgetBuilder builder,
    required BuildContext context,
    super.barrierDismissible,
    Color? barrierColor,
    String? barrierLabel,
    // This transition duration was eyeballed comparing with iOS
    super.transitionDuration = const Duration(milliseconds: 250),
    this.transitionBuilder,
    super.settings,
    super.requestFocus,
    super.anchorPoint,
  }) : super(
         pageBuilder: (
           BuildContext context,
           Animation<double> animation,
           Animation<double> secondaryAnimation,
         ) {
           return builder(context);
         },
         transitionBuilder: transitionBuilder ?? _buildCupertinoDialogTransitions,
         barrierLabel: barrierLabel ?? CupertinoLocalizations.of(context).modalBarrierDismissLabel,
         barrierColor:
             barrierColor ?? CupertinoDynamicColor.resolve(kCupertinoModalBarrierColor, context),
       );

  /// Custom transition builder
  RouteTransitionsBuilder? transitionBuilder;

  CurvedAnimation? _fadeAnimation;

  @override
  Simulation createSimulation({required bool forward}) {
    assert(!debugTransitionCompleted(), 'Cannot reuse a $runtimeType after disposing it.');
    final double end = forward ? 1.0 : 0.0;
    return SpringSimulation(
      _kStandardSpring,
      controller!.value,
      end,
      0,
      tolerance: _kStandardTolerance,
      snapToEnd: true,
    );
  }

  @override
  Widget buildTransitions(
    BuildContext context,
    Animation<double> animation,
    Animation<double> secondaryAnimation,
    Widget child,
  ) {
    if (transitionBuilder != null) {
      return super.buildTransitions(context, animation, secondaryAnimation, child);
    }

    if (animation.status == AnimationStatus.reverse) {
      return FadeTransition(opacity: animation, child: child);
    }
    return FadeTransition(
      opacity: animation,
      child: ScaleTransition(scale: animation.drive(_dialogScaleTween), child: child),
    );
  }

  @override
  void dispose() {
    _fadeAnimation?.dispose();
    super.dispose();
  }

  // The curve and initial scale values were mostly eyeballed from iOS, however
  // they reuse the same animation curve that was modeled after native page
  // transitions.
  static final Tween<double> _dialogScaleTween = Tween<double>(begin: 1.3, end: 1.0);
}
\n\n--- File: 1 # packages/flutter/lib/src/material/page.dart ---\n// Copyright 2014 The Flutter Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

import 'package:flutter/cupertino.dart';

import 'page_transitions_theme.dart';
import 'theme.dart';

/// A modal route that replaces the entire screen with a platform-adaptive
/// transition.
///
/// {@macro flutter.material.materialRouteTransitionMixin}
///
/// By default, when a modal route is replaced by another, the previous route
/// remains in memory. To free all the resources when this is not necessary, set
/// [maintainState] to false.
///
/// The `fullscreenDialog` property specifies whether the incoming route is a
/// fullscreen modal dialog. On iOS, those routes animate from the bottom to the
/// top rather than horizontally.
///
/// If `barrierDismissible` is true, then pressing the escape key on the keyboard
/// will cause the current route to be popped with null as the value.
///
/// The type `T` specifies the return type of the route which can be supplied as
/// the route is popped from the stack via [Navigator.pop] by providing the
/// optional `result` argument.
///
/// See also:
///
///  * [MaterialRouteTransitionMixin], which provides the material transition
///    for this route.
///  * [MaterialPage], which is a [Page] of this class.
class MaterialPageRoute<T> extends PageRoute<T> with MaterialRouteTransitionMixin<T> {
  /// Construct a MaterialPageRoute whose contents are defined by [builder].
  MaterialPageRoute({
    required this.builder,
    super.settings,
    super.requestFocus,
    this.maintainState = true,
    super.fullscreenDialog,
    super.allowSnapshotting = true,
    super.barrierDismissible = false,
  }) {
    assert(opaque);
  }

  /// Builds the primary contents of the route.
  final WidgetBuilder builder;

  @override
  Widget buildContent(BuildContext context) => builder(context);

  @override
  final bool maintainState;

  @override
  String get debugLabel => '${super.debugLabel}(${settings.name})';
}

/// A mixin that provides platform-adaptive transitions for a [PageRoute].
///
/// {@template flutter.material.materialRouteTransitionMixin}
/// For Android, the entrance transition for the page zooms in and fades in
/// while the exiting page zooms out and fades out. The exit transition is similar,
/// but in reverse.
///
/// For iOS, the page slides in from the right and exits in reverse. The page
/// also shifts to the left in parallax when another page enters to cover it.
/// (These directions are flipped in environments with a right-to-left reading
/// direction.)
/// {@endtemplate}
///
/// See also:
///
///  * [PageTransitionsTheme], which defines the default page transitions used
///    by the [MaterialRouteTransitionMixin.buildTransitions].
///  * [ZoomPageTransitionsBuilder], which is the default page transition used
///    by the [PageTransitionsTheme].
///  * [CupertinoPageTransitionsBuilder], which is the default page transition
///    for iOS and macOS.
mixin MaterialRouteTransitionMixin<T> on PageRoute<T> {
  /// Builds the primary contents of the route.
  @protected
  Widget buildContent(BuildContext context);

  @override
  Duration get transitionDuration =>
      _getPageTransitionBuilder(navigator!.context)?.transitionDuration ??
      const Duration(microseconds: 300);

  @override
  Duration get reverseTransitionDuration =>
      _getPageTransitionBuilder(navigator!.context)?.reverseTransitionDuration ??
      const Duration(microseconds: 300);

  PageTransitionsBuilder? _getPageTransitionBuilder(BuildContext context) {
    final TargetPlatform platform = Theme.of(context).platform;
    final PageTransitionsTheme pageTransitionsTheme = Theme.of(context).pageTransitionsTheme;
    return pageTransitionsTheme.builders[platform];
  }

  // The transitionDuration is used to create the AnimationController which is only
  // built once, so when page transition builder is updated and transitionDuration
  // has a new value, the AnimationController cannot be updated automatically. So we
  // manually update its duration here.
  // TODO(quncCccccc): Clean up this override method when controller can be updated as the transitionDuration is changed.
  @override
  TickerFuture didPush() {
    controller?.duration = transitionDuration;
    return super.didPush();
  }

  // The reverseTransitionDuration is used to create the AnimationController
  // which is only built once, so when page transition builder is updated and
  // reverseTransitionDuration has a new value, the AnimationController cannot
  // be updated automatically. So we manually update its reverseDuration here.
  // TODO(quncCccccc): Clean up this override method when controller can beupdated as the reverseTransitionDuration is changed.
  @override
  bool didPop(T? result) {
    controller?.reverseDuration = reverseTransitionDuration;
    return super.didPop(result);
  }

  @override
  Color? get barrierColor => null;

  @override
  String? get barrierLabel => null;

  @override
  DelegatedTransitionBuilder? get delegatedTransition => _delegatedTransition;

  static Widget? _delegatedTransition(
    BuildContext context,
    Animation<double> animation,
    Animation<double> secondaryAnimation,
    bool allowSnapshotting,
    Widget? child,
  ) {
    final PageTransitionsTheme theme = Theme.of(context).pageTransitionsTheme;
    final TargetPlatform platform = Theme.of(context).platform;
    final DelegatedTransitionBuilder? themeDelegatedTransition = theme.delegatedTransition(
      platform,
    );
    return themeDelegatedTransition != null
        ? themeDelegatedTransition(context, animation, secondaryAnimation, allowSnapshotting, child)
        : null;
  }

  @override
  bool canTransitionTo(TransitionRoute<dynamic> nextRoute) {
    // Don't perform outgoing animation if the next route is a fullscreen dialog,
    // or there is no matching transition to use.
    // Don't perform outgoing animation if the next route is a fullscreen dialog.
    final bool nextRouteIsNotFullscreen =
        (nextRoute is! PageRoute<T>) || !nextRoute.fullscreenDialog;

    // If the next route has a delegated transition, then this route is able to
    // use that delegated transition to smoothly sync with the next route's
    // transition.
    final bool nextRouteHasDelegatedTransition =
        nextRoute is ModalRoute<T> && nextRoute.delegatedTransition != null;

    // Otherwise if the next route has the same route transition mixin as this
    // one, then this route will already be synced with its transition.
    return nextRouteIsNotFullscreen &&
        ((nextRoute is MaterialRouteTransitionMixin) || nextRouteHasDelegatedTransition);
  }

  @override
  bool canTransitionFrom(TransitionRoute<dynamic> previousRoute) {
    // Supress previous route from transitioning if this is a fullscreenDialog route.
    return previousRoute is PageRoute && !fullscreenDialog;
  }

  @override
  Widget buildPage(
    BuildContext context,
    Animation<double> animation,
    Animation<double> secondaryAnimation,
  ) {
    final Widget result = buildContent(context);
    return Semantics(scopesRoute: true, explicitChildNodes: true, child: result);
  }

  @override
  Widget buildTransitions(
    BuildContext context,
    Animation<double> animation,
    Animation<double> secondaryAnimation,
    Widget child,
  ) {
    final PageTransitionsTheme theme = Theme.of(context).pageTransitionsTheme;
    return theme.buildTransitions<T>(this, context, animation, secondaryAnimation, child);
  }
}

/// A page that creates a material style [PageRoute].
///
/// {@macro flutter.material.materialRouteTransitionMixin}
///
/// By default, when the created route is replaced by another, the previous
/// route remains in memory. To free all the resources when this is not
/// necessary, set [maintainState] to false.
///
/// The `fullscreenDialog` property specifies whether the created route is a
/// fullscreen modal dialog. On iOS, those routes animate from the bottom to the
/// top rather than horizontally.
///
/// The type `T` specifies the return type of the route which can be supplied as
/// the route is popped from the stack via [Navigator.transitionDelegate] by
/// providing the optional `result` argument to the
/// [RouteTransitionRecord.markForPop] in the [TransitionDelegate.resolve].
///
/// See also:
///
///  * [MaterialPageRoute], which is the [PageRoute] version of this class
class MaterialPage<T> extends Page<T> {
  /// Creates a material page.
  const MaterialPage({
    required this.child,
    this.maintainState = true,
    this.fullscreenDialog = false,
    this.allowSnapshotting = true,
    super.key,
    super.canPop,
    super.onPopInvoked,
    super.name,
    super.arguments,
    super.restorationId,
  });

  /// The content to be shown in the [Route] created by this page.
  final Widget child;

  /// {@macro flutter.widgets.ModalRoute.maintainState}
  final bool maintainState;

  /// {@macro flutter.widgets.PageRoute.fullscreenDialog}
  final bool fullscreenDialog;

  /// {@macro flutter.widgets.TransitionRoute.allowSnapshotting}
  final bool allowSnapshotting;

  @override
  Route<T> createRoute(BuildContext context) {
    return _PageBasedMaterialPageRoute<T>(page: this, allowSnapshotting: allowSnapshotting);
  }
}

// A page-based version of MaterialPageRoute.
//
// This route uses the builder from the page to build its content. This ensures
// the content is up to date after page updates.
class _PageBasedMaterialPageRoute<T> extends PageRoute<T> with MaterialRouteTransitionMixin<T> {
  _PageBasedMaterialPageRoute({required MaterialPage<T> page, super.allowSnapshotting})
    : super(settings: page) {
    assert(opaque);
  }

  MaterialPage<T> get _page => settings as MaterialPage<T>;

  @override
  Widget buildContent(BuildContext context) {
    return _page.child;
  }

  @override
  bool get maintainState => _page.maintainState;

  @override
  bool get fullscreenDialog => _page.fullscreenDialog;

  @override
  String get debugLabel => '${super.debugLabel}(${_page.name})';
}
\n\n--- File: 2 # packages/flutter/lib/src/widgets/pages.dart ---\n// Copyright 2014 The Flutter Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

/// @docImport 'navigator.dart';
library;

import 'basic.dart';
import 'framework.dart';
import 'routes.dart';

/// A modal route that replaces the entire screen.
///
/// The [PageRouteBuilder] subclass provides a way to create a [PageRoute] using
/// callbacks rather than by defining a new class via subclassing.
///
/// If `barrierDismissible` is true, then pressing the escape key on the keyboard
/// will cause the current route to be popped with null as the value.
///
/// See also:
///
///  * [Route], which documents the meaning of the `T` generic type argument.
abstract class PageRoute<T> extends ModalRoute<T> {
  /// Creates a modal route that replaces the entire screen.
  PageRoute({
    super.settings,
    super.requestFocus,
    this.fullscreenDialog = false,
    this.allowSnapshotting = true,
    bool barrierDismissible = false,
  }) : _barrierDismissible = barrierDismissible;

  /// {@template flutter.widgets.PageRoute.fullscreenDialog}
  /// Whether this page route is a full-screen dialog.
  ///
  /// In Material and Cupertino, being fullscreen has the effects of making
  /// the app bars have a close button instead of a back button. On
  /// iOS, dialogs transitions animate differently and are also not closeable
  /// with the back swipe gesture.
  /// {@endtemplate}
  final bool fullscreenDialog;

  @override
  final bool allowSnapshotting;

  @override
  bool get opaque => true;

  @override
  bool get barrierDismissible => _barrierDismissible;
  final bool _barrierDismissible;

  @override
  bool canTransitionTo(TransitionRoute<dynamic> nextRoute) => nextRoute is PageRoute;

  @override
  bool canTransitionFrom(TransitionRoute<dynamic> previousRoute) => previousRoute is PageRoute;

  @override
  bool get popGestureEnabled {
    // Fullscreen dialogs aren't dismissible by back swipe.
    return !fullscreenDialog && super.popGestureEnabled;
  }
}

Widget _defaultTransitionsBuilder(
  BuildContext context,
  Animation<double> animation,
  Animation<double> secondaryAnimation,
  Widget child,
) {
  return child;
}

/// A utility class for defining one-off page routes in terms of callbacks.
///
/// Callers must define the [pageBuilder] function which creates the route's
/// primary contents. To add transitions define the [transitionsBuilder] function.
///
/// The `T` generic type argument corresponds to the type argument of the
/// created [Route] objects.
///
/// See also:
///
///  * [Route], which documents the meaning of the `T` generic type argument.
class PageRouteBuilder<T> extends PageRoute<T> {
  /// Creates a route that delegates to builder callbacks.
  PageRouteBuilder({
    super.settings,
    super.requestFocus,
    required this.pageBuilder,
    this.transitionsBuilder = _defaultTransitionsBuilder,
    this.transitionDuration = const Duration(milliseconds: 300),
    this.reverseTransitionDuration = const Duration(milliseconds: 300),
    this.opaque = true,
    this.barrierDismissible = false,
    this.barrierColor,
    this.barrierLabel,
    this.maintainState = true,
    super.fullscreenDialog,
    super.allowSnapshotting = true,
  });

  /// {@template flutter.widgets.pageRouteBuilder.pageBuilder}
  /// Used build the route's primary contents.
  ///
  /// See [ModalRoute.buildPage] for complete definition of the parameters.
  /// {@endtemplate}
  final RoutePageBuilder pageBuilder;

  /// {@template flutter.widgets.pageRouteBuilder.transitionsBuilder}
  /// Used to build the route's transitions.
  ///
  /// See [ModalRoute.buildTransitions] for complete definition of the parameters.
  /// {@endtemplate}
  ///
  /// The default transition is a jump cut (i.e. no animation).
  final RouteTransitionsBuilder transitionsBuilder;

  @override
  final Duration transitionDuration;

  @override
  final Duration reverseTransitionDuration;

  @override
  final bool opaque;

  @override
  final bool barrierDismissible;

  @override
  final Color? barrierColor;

  @override
  final String? barrierLabel;

  @override
  final bool maintainState;

  @override
  Widget buildPage(
    BuildContext context,
    Animation<double> animation,
    Animation<double> secondaryAnimation,
  ) {
    return pageBuilder(context, animation, secondaryAnimation);
  }

  @override
  Widget buildTransitions(
    BuildContext context,
    Animation<double> animation,
    Animation<double> secondaryAnimation,
    Widget child,
  ) {
    return transitionsBuilder(context, animation, secondaryAnimation, child);
  }
}


Please provide:
1. A high-level `summary` of the project's main purpose and functionality in a few beginner-friendly sentences. Use markdown formatting with **bold** and *italic* text to highlight important concepts.
2. A list (`relationships`) describing the key interactions between these abstractions. For each relationship, specify:
    - `from_abstraction`: Index of the source abstraction (e.g., `0 # AbstractionName1`)
    - `to_abstraction`: Index of the target abstraction (e.g., `1 # AbstractionName2`)
    - `label`: A brief label for the interaction **in just a few words** (e.g., "Manages", "Inherits", "Uses").
    Ideally the relationship should be backed by one abstraction calling or passing parameters to another.
    Simplify the relationship and exclude those non-important ones.

IMPORTANT: Make sure EVERY abstraction is involved in at least ONE relationship (either as source or target). Each abstraction index must appear at least once across all relationships.

Format the output as YAML:

```yaml
summary: |
  A brief, simple explanation of the project.
  Can span multiple lines with **bold** and *italic* for emphasis.
relationships:
  - from_abstraction: 0 # AbstractionName1
    to_abstraction: 1 # AbstractionName2
    label: "Manages"
  - from_abstraction: 2 # AbstractionName3
    to_abstraction: 0 # AbstractionName1
    label: "Provides config"
  # ... other relationships
```

Now, provide the YAML output:

2025-05-21 12:31:32,086 - INFO - RESPONSE: ```yaml
summary: |
  This Flutter code defines how different **screens** or *pages* in your app appear and transition between each other. It provides specific styles for creating *iOS-like* (Cupertino) and *Android-like* (Material Design) navigation experiences, including handling full-screen pop-ups and dialogs with their unique animations.
relationships:
  - from_abstraction: 1 # CupertinoPageRoute
    to_abstraction: 0 # PageRoute
    label: "Is a type of"
  - from_abstraction: 2 # MaterialPageRoute
    to_abstraction: 0 # PageRoute
    label: "Is a type of"
  - from_abstraction: 1 # CupertinoPageRoute
    to_abstraction: 3 # CupertinoRouteTransitionMixin
    label: "Uses mixin"
  - from_abstraction: 2 # MaterialPageRoute
    to_abstraction: 4 # MaterialRouteTransitionMixin
    label: "Uses mixin"
  - from_abstraction: 3 # CupertinoRouteTransitionMixin
    to_abstraction: 5 # CupertinoPageTransition
    label: "Builds"
  - from_abstraction: 3 # CupertinoRouteTransitionMixin
    to_abstraction: 6 # CupertinoFullscreenDialogTransition
    label: "Builds full-screen"
  - from_abstraction: 7 # CupertinoModalPopupRoute
    to_abstraction: 0 # PageRoute
    label: "Is a type of"
  - from_abstraction: 8 # CupertinoDialogRoute
    to_abstraction: 0 # PageRoute
    label: "Is a type of"
```
2025-05-21 12:31:32,094 - INFO - PROMPT: 
Given the following project abstractions and their relationships for the project ```` flutter ````:

Abstractions (Index # Name):
- 0 # PageRoute

- 1 # CupertinoPageRoute

- 2 # MaterialPageRoute

- 3 # CupertinoRouteTransitionMixin

- 4 # MaterialRouteTransitionMixin

- 5 # CupertinoPageTransition

- 6 # CupertinoFullscreenDialogTransition

- 7 # CupertinoModalPopupRoute

- 8 # CupertinoDialogRoute


Context about relationships and project summary:
Project Summary:
This Flutter code defines how different **screens** or *pages* in your app appear and transition between each other. It provides specific styles for creating *iOS-like* (Cupertino) and *Android-like* (Material Design) navigation experiences, including handling full-screen pop-ups and dialogs with their unique animations.


Relationships (Indices refer to abstractions above):
- From 1 (CupertinoPageRoute
) to 0 (PageRoute
): Is a type of
- From 2 (MaterialPageRoute
) to 0 (PageRoute
): Is a type of
- From 1 (CupertinoPageRoute
) to 3 (CupertinoRouteTransitionMixin
): Uses mixin
- From 2 (MaterialPageRoute
) to 4 (MaterialRouteTransitionMixin
): Uses mixin
- From 3 (CupertinoRouteTransitionMixin
) to 5 (CupertinoPageTransition
): Builds
- From 3 (CupertinoRouteTransitionMixin
) to 6 (CupertinoFullscreenDialogTransition
): Builds full-screen
- From 7 (CupertinoModalPopupRoute
) to 0 (PageRoute
): Is a type of
- From 8 (CupertinoDialogRoute
) to 0 (PageRoute
): Is a type of


If you are going to make a tutorial for ```` flutter ````, what is the best order to explain these abstractions, from first to last?
Ideally, first explain those that are the most important or foundational, perhaps user-facing concepts or entry points. Then move to more detailed, lower-level implementation details or supporting concepts.

Output the ordered list of abstraction indices, including the name in a comment for clarity. Use the format `idx # AbstractionName`.

```yaml
- 2 # FoundationalConcept
- 0 # CoreClassA
- 1 # CoreClassB (uses CoreClassA)
- ...
```

Now, provide the YAML output:

2025-05-21 12:31:35,063 - INFO - RESPONSE: ```yaml
- 0 # PageRoute
- 2 # MaterialPageRoute
- 4 # MaterialRouteTransitionMixin
- 1 # CupertinoPageRoute
- 3 # CupertinoRouteTransitionMixin
- 5 # CupertinoPageTransition
- 6 # CupertinoFullscreenDialogTransition
- 7 # CupertinoModalPopupRoute
- 8 # CupertinoDialogRoute
```
2025-05-21 12:31:35,069 - INFO - PROMPT: 
Write a very beginner-friendly tutorial chapter (in Markdown format) for the project `flutter` about the concept: "PageRoute
". This is Chapter 1.

Concept Details:
- Name: PageRoute

- Description:
Imagine your app screens are like distinct locations in a building. A `PageRoute` is the plan for how to get from one room (screen) to another. It defines what the new screen looks like, how long the transition takes, and what its behavior is (like if you can dismiss it easily). It's the blueprint for a single "page" or screen in your app's navigation history.


Complete Tutorial Structure:
1. [PageRoute
](01_pageroute_.md)
2. [MaterialPageRoute
](02_materialpageroute_.md)
3. [MaterialRouteTransitionMixin
](03_materialroutetransitionmixin_.md)
4. [CupertinoPageRoute
](04_cupertinopageroute_.md)
5. [CupertinoRouteTransitionMixin
](05_cupertinoroutetransitionmixin_.md)
6. [CupertinoPageTransition
](06_cupertinopagetransition_.md)
7. [CupertinoFullscreenDialogTransition
](07_cupertinofullscreendialogtransition_.md)
8. [CupertinoModalPopupRoute
](08_cupertinomodalpopuproute_.md)
9. [CupertinoDialogRoute
](09_cupertinodialogroute_.md)

Context from previous chapters:
This is the first chapter.

Relevant Code Snippets (Code itself remains unchanged):
--- File: packages/flutter/lib/src/cupertino/route.dart ---
// Copyright 2014 The Flutter Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

/// @docImport 'dart:ui';
///
/// @docImport 'package:flutter/material.dart';
/// @docImport 'package:flutter/services.dart';
///
/// @docImport 'app.dart';
/// @docImport 'button.dart';
/// @docImport 'dialog.dart';
/// @docImport 'nav_bar.dart';
/// @docImport 'page_scaffold.dart';
/// @docImport 'tab_scaffold.dart';
library;

import 'dart:math';
import 'dart:ui' show ImageFilter;

import 'package:flutter/foundation.dart';
import 'package:flutter/gestures.dart';
import 'package:flutter/physics.dart';
import 'package:flutter/rendering.dart';
import 'package:flutter/widgets.dart';

import 'colors.dart';
import 'interface_level.dart';
import 'localizations.dart';

const double _kBackGestureWidth = 20.0;
const double _kMinFlingVelocity = 1.0; // Screen widths per second.

// The duration for a page to animate when the user releases it mid-swipe.
const Duration _kDroppedSwipePageAnimationDuration = Duration(milliseconds: 350);

/// Barrier color used for a barrier visible during transitions for Cupertino
/// page routes.
///
/// This barrier color is only used for full-screen page routes with
/// `fullscreenDialog: false`.
///
/// By default, `fullscreenDialog` Cupertino route transitions have no
/// `barrierColor`, and [CupertinoDialogRoute]s and [CupertinoModalPopupRoute]s
/// have a `barrierColor` defined by [kCupertinoModalBarrierColor].
///
/// A relatively rigorous eyeball estimation.
const Color _kCupertinoPageTransitionBarrierColor = Color(0x18000000);

/// Barrier color for a Cupertino modal barrier.
///
/// Extracted from https://developer.apple.com/design/resources/.
const Color kCupertinoModalBarrierColor = CupertinoDynamicColor.withBrightness(
  color: Color(0x33000000),
  darkColor: Color(0x7A000000),
);

// The duration of the transition used when a modal popup is shown.
const Duration _kModalPopupTransitionDuration = Duration(milliseconds: 335);

// Offset from offscreen to the right to fully on screen.
final Animatable<Offset> _kRightMiddleTween = Tween<Offset>(
  begin: const Offset(1.0, 0.0),
  end: Offset.zero,
);

// Offset from fully on screen to 1/3 offscreen to the left.
final Animatable<Offset> _kMiddleLeftTween = Tween<Offset>(
  begin: Offset.zero,
  end: const Offset(-1.0 / 3.0, 0.0),
);

// Offset from offscreen below to fully on screen.
final Animatable<Offset> _kBottomUpTween = Tween<Offset>(
  begin: const Offset(0.0, 1.0),
  end: Offset.zero,
);

/// A mixin that replaces the entire screen with an iOS transition for a
/// [PageRoute].
///
/// {@template flutter.cupertino.cupertinoRouteTransitionMixin}
/// The page slides in from the right and exits in reverse. The page also shifts
/// to the left in parallax when another page enters to cover it.
///
/// The page slides in from the bottom and exits in reverse with no parallax
/// effect for fullscreen dialogs.
/// {@endtemplate}
///
/// See also:
///
///  * [MaterialRouteTransitionMixin], which is a mixin that provides
///    platform-appropriate transitions for a [PageRoute].
///  * [CupertinoPageRoute], which is a [PageRoute] that leverages this mixin.
mixin CupertinoRouteTransitionMixin<T> on PageRoute<T> {
  /// Builds the primary contents of the route.
  @protected
  Widget buildContent(BuildContext context);

  /// {@template flutter.cupertino.CupertinoRouteTransitionMixin.title}
  /// A title string for this route.
  ///
  /// Used to auto-populate [CupertinoNavigationBar] and
  /// [CupertinoSliverNavigationBar]'s `middle`/`largeTitle` widgets when
  /// one is not manually supplied.
  /// {@endtemplate}
  String? get title;

  ValueNotifier<String?>? _previousTitle;

  /// The title string of the previous [CupertinoPageRoute].
  ///
  /// The [ValueListenable]'s value is readable after the route is installed
  /// onto a [Navigator]. The [ValueListenable] will also notify its listeners
  /// if the value changes (such as by replacing the previous route).
  ///
  /// The [ValueListenable] itself will be null before the route is installed.
  /// Its content value will be null if the previous route has no title or
  /// is not a [CupertinoPageRoute].
  ///
  /// See also:
  ///
  ///  * [ValueListenableBuilder], which can be used to listen and rebuild
  ///    widgets based on a ValueListenable.
  ValueListenable<String?> get previousTitle {
    assert(
      _previousTitle != null,
      'Cannot read the previousTitle for a route that has not yet been installed',
    );
    return _previousTitle!;
  }

  @override
  void dispose() {
    _previousTitle?.dispose();
    super.dispose();
  }

  @override
  void didChangePrevious(Route<dynamic>? previousRoute) {
    final String? previousTitleString =
        previousRoute is CupertinoRouteTransitionMixin ? previousRoute.title : null;
    if (_previousTitle == null) {
      _previousTitle = ValueNotifier<String?>(previousTitleString);
    } else {
      _previousTitle!.value = previousTitleString;
    }
    super.didChangePrevious(previousRoute);
  }

  @override
  // A relatively rigorous eyeball estimation.
  Duration get transitionDuration => const Duration(milliseconds: 500);

  @override
  Color? get barrierColor => fullscreenDialog ? null : _kCupertinoPageTransitionBarrierColor;

  @override
  String? get barrierLabel => null;

  @override
  bool canTransitionTo(TransitionRoute<dynamic> nextRoute) {
    // Don't perform outgoing animation if the next route is a fullscreen dialog.
    final bool nextRouteIsNotFullscreen =
        (nextRoute is! PageRoute<T>) || !nextRoute.fullscreenDialog;

    // If the next route has a delegated transition, then this route is able to
    // use that delegated transition to smoothly sync with the next route's
    // transition.
    final bool nextRouteHasDelegatedTransition =
        nextRoute is ModalRoute<T> && nextRoute.delegatedTransition != null;

    // Otherwise if the next route has the same route transition mixin as this
    // one, then this route will already be synced with its transition.
    return nextRouteIsNotFullscreen &&
        ((nextRoute is CupertinoRouteTransitionMixin) || nextRouteHasDelegatedTransition);
  }

  @override
  bool canTransitionFrom(TransitionRoute<dynamic> previousRoute) {
    // Supress previous route from transitioning if this is a fullscreenDialog route.
    return previousRoute is PageRoute && !fullscreenDialog;
  }

  @override
  Widget buildPage(
    BuildContext context,
    Animation<double> animation,
    Animation<double> secondaryAnimation,
  ) {
    final Widget child = buildContent(context);
    return Semantics(scopesRoute: true, explicitChildNodes: true, child: child);
  }

  // Called by _CupertinoBackGestureDetector when a pop ("back") drag start
  // gesture is detected. The returned controller handles all of the subsequent
  // drag events.
  static _CupertinoBackGestureController<T> _startPopGesture<T>(PageRoute<T> route) {
    assert(route.popGestureEnabled);

    return _CupertinoBackGestureController<T>(
      navigator: route.navigator!,
      getIsCurrent: () => route.isCurrent,
      getIsActive: () => route.isActive,
      controller: route.controller!, // protected access
    );
  }

  /// Returns a [CupertinoFullscreenDialogTransition] if [route] is a full
  /// screen dialog, otherwise a [CupertinoPageTransition] is returned.
  ///
  /// Used by [CupertinoPageRoute.buildTransitions].
  ///
  /// This method can be applied to any [PageRoute], not just
  /// [CupertinoPageRoute]. It's typically used to provide a Cupertino style
  /// horizontal transition for material widgets when the target platform
  /// is [TargetPlatform.iOS].
  ///
  /// See also:
  ///
  ///  * [CupertinoPageTransitionsBuilder], which uses this method to define a
  ///    [PageTransitionsBuilder] for the [PageTransitionsTheme].
  static Widget buildPageTransitions<T>(
    PageRoute<T> route,
    BuildContext context,
    Animation<double> animation,
    Animation<double> secondaryAnimation,
    Widget child,
  ) {
    // Check if the route has an animation that's currently participating
    // in a back swipe gesture.
    //
    // In the middle of a back gesture drag, let the transition be linear to
    // match finger motions.
    final bool linearTransition = route.popGestureInProgress;
    if (route.fullscreenDialog) {
      return CupertinoFullscreenDialogTransition(
        primaryRouteAnimation: animation,
        secondaryRouteAnimation: secondaryAnimation,
        linearTransition: linearTransition,
        child: child,
      );
    } else {
      return CupertinoPageTransition(
        primaryRouteAnimation: animation,
        secondaryRouteAnimation: secondaryAnimation,
        linearTransition: linearTransition,
        child: _CupertinoBackGestureDetector<T>(
          enabledCallback: () => route.popGestureEnabled,
          onStartPopGesture: () => _startPopGesture<T>(route),
          child: child,
        ),
      );
    }
  }

  @override
  Widget buildTransitions(
    BuildContext context,
    Animation<double> animation,
    Animation<double> secondaryAnimation,
    Widget child,
  ) {
    return buildPageTransitions<T>(this, context, animation, secondaryAnimation, child);
  }
}

/// A modal route that replaces the entire screen with an iOS transition.
///
/// {@macro flutter.cupertino.cupertinoRouteTransitionMixin}
///
/// By default, when a modal route is replaced by another, the previous route
/// remains in memory. To free all the resources when this is not necessary, set
/// [maintainState] to false.
///
/// The type `T` specifies the return type of the route which can be supplied as
/// the route is popped from the stack via [Navigator.pop] when an optional
/// `result` can be provided.
///
/// If `barrierDismissible` is true, then pressing the escape key on the keyboard
/// will cause the current route to be popped with null as the value.
///
/// See also:
///
///  * [CupertinoRouteTransitionMixin], for a mixin that provides iOS transition
///    for this modal route.
///  * [MaterialPageRoute], for an adaptive [PageRoute] that uses a
///    platform-appropriate transition.
///  * [CupertinoPageScaffold], for applications that have one page with a fixed
///    navigation bar on top.
///  * [CupertinoTabScaffold], for applications that have a tab bar at the
///    bottom with multiple pages.
///  * [CupertinoPage], for a [Page] version of this class.
class CupertinoPageRoute<T> extends PageRoute<T> with CupertinoRouteTransitionMixin<T> {
  /// Creates a page route for use in an iOS designed app.
  ///
  /// The [builder], [maintainState], and [fullscreenDialog] arguments must not
  /// be null.
  CupertinoPageRoute({
    required this.builder,
    this.title,
    super.settings,
    super.requestFocus,
    this.maintainState = true,
    super.fullscreenDialog,
    super.allowSnapshotting = true,
    super.barrierDismissible = false,
  }) {
    assert(opaque);
  }

  @override
  DelegatedTransitionBuilder? get delegatedTransition =>
      CupertinoPageTransition.delegatedTransition;

  /// Builds the primary contents of the route.
  final WidgetBuilder builder;

  @override
  Widget buildContent(BuildContext context) => builder(context);

  @override
  final String? title;

  @override
  final bool maintainState;

  @override
  String get debugLabel => '${super.debugLabel}(${settings.name})';
}

// A page-based version of CupertinoPageRoute.
//
// This route uses the builder from the page to build its content. This ensures
// the content is up to date after page updates.
class _PageBasedCupertinoPageRoute<T> extends PageRoute<T> with CupertinoRouteTransitionMixin<T> {
  _PageBasedCupertinoPageRoute({required CupertinoPage<T> page, super.allowSnapshotting = true})
    : super(settings: page) {
    assert(opaque);
  }

  @override
  DelegatedTransitionBuilder? get delegatedTransition =>
      this.fullscreenDialog ? null : CupertinoPageTransition.delegatedTransition;

  CupertinoPage<T> get _page => settings as CupertinoPage<T>;

  @override
  Widget buildContent(BuildContext context) => _page.child;

  @override
  String? get title => _page.title;

  @override
  bool get maintainState => _page.maintainState;

  @override
  bool get fullscreenDialog => _page.fullscreenDialog;

  @override
  String get debugLabel => '${super.debugLabel}(${_page.name})';
}

/// A page that creates a cupertino style [PageRoute].
///
/// {@macro flutter.cupertino.cupertinoRouteTransitionMixin}
///
/// By default, when a created modal route is replaced by another, the previous
/// route remains in memory. To free all the resources when this is not
/// necessary, set [maintainState] to false.
///
/// The type `T` specifies the return type of the route which can be supplied as
/// the route is popped from the stack via [Navigator.transitionDelegate] by
/// providing the optional `result` argument to the
/// [RouteTransitionRecord.markForPop] in the [TransitionDelegate.resolve].
///
/// See also:
///
///  * [CupertinoPageRoute], for a [PageRoute] version of this class.
class CupertinoPage<T> extends Page<T> {
  /// Creates a cupertino page.
  const CupertinoPage({
    required this.child,
    this.maintainState = true,
    this.title,
    this.fullscreenDialog = false,
    this.allowSnapshotting = true,
    super.canPop,
    super.onPopInvoked,
    super.key,
    super.name,
    super.arguments,
    super.restorationId,
  });

  /// The content to be shown in the [Route] created by this page.
  final Widget child;

  /// {@macro flutter.cupertino.CupertinoRouteTransitionMixin.title}
  final String? title;

  /// {@macro flutter.widgets.ModalRoute.maintainState}
  final bool maintainState;

  /// {@macro flutter.widgets.PageRoute.fullscreenDialog}
  final bool fullscreenDialog;

  /// {@macro flutter.widgets.TransitionRoute.allowSnapshotting}
  final bool allowSnapshotting;

  @override
  Route<T> createRoute(BuildContext context) {
    return _PageBasedCupertinoPageRoute<T>(page: this, allowSnapshotting: allowSnapshotting);
  }
}

/// Provides an iOS-style page transition animation.
///
/// The page slides in from the right and exits in reverse. It also shifts to the left in
/// a parallax motion when another page enters to cover it.
class CupertinoPageTransition extends StatefulWidget {
  /// Creates an iOS-style page transition.
  ///
  const CupertinoPageTransition({
    super.key,
    required this.primaryRouteAnimation,
    required this.secondaryRouteAnimation,
    required this.child,
    required this.linearTransition,
  });

  /// The widget below this widget in the tree.
  final Widget child;

  ///  * `primaryRouteAnimation` is a linear route animation from 0.0 to 1.0
  ///    when this screen is being pushed.
  final Animation<double> primaryRouteAnimation;

  ///  * `secondaryRouteAnimation` is a linear route animation from 0.0 to 1.0
  ///    when another screen is being pushed on top of this one.
  final Animation<double> secondaryRouteAnimation;

  ///  * `linearTransition` is whether to perform the transitions linearly.
  ///    Used to precisely track back gesture drags.
  final bool linearTransition;

  /// The Cupertino styled [DelegatedTransitionBuilder] provided to the previous
  /// route.
  ///
  /// {@macro flutter.widgets.delegatedTransition}
  static Widget? delegatedTransition(
    BuildContext context,
    Animation<double> animation,
    Animation<double> secondaryAnimation,
    bool allowSnapshotting,
    Widget? child,
  ) {
    final CurvedAnimation animation = CurvedAnimation(
      parent: secondaryAnimation,
      curve: Curves.linearToEaseOut,
      reverseCurve: Curves.easeInToLinear,
    );
    final Animation<Offset> delegatedPositionAnimation = animation.drive(_kMiddleLeftTween);
    animation.dispose();

    assert(debugCheckHasDirectionality(context));
    final TextDirection textDirection = Directionality.of(context);
    return SlideTransition(
      position: delegatedPositionAnimation,
      textDirection: textDirection,
      transformHitTests: false,
      child: child,
    );
  }

  @override
  State<CupertinoPageTransition> createState() => _CupertinoPageTransitionState();
}

class _CupertinoPageTransitionState extends State<CupertinoPageTransition> {
  // When this page is coming in to cover another page.
  late Animation<Offset> _primaryPositionAnimation;
  // When this page is becoming covered by another page.
  late Animation<Offset> _secondaryPositionAnimation;
  // Shadow of page which is coming in to cover another page.
  late Animation<Decoration> _primaryShadowAnimation;
  // Curve of primary page which is coming in to cover another page.
  CurvedAnimation? _primaryPositionCurve;
  // Curve of secondary page which is becoming covered by another page.
  CurvedAnimation? _secondaryPositionCurve;
  // Curve of primary page's shadow.
  CurvedAnimation? _primaryShadowCurve;

  @override
  void initState() {
    super.initState();
    _setupAnimation();
  }

  @override
  void didUpdateWidget(covariant CupertinoPageTransition oldWidget) {
    super.didUpdateWidget(oldWidget);
    if (oldWidget.primaryRouteAnimation != widget.primaryRouteAnimation ||
        oldWidget.secondaryRouteAnimation != widget.secondaryRouteAnimation ||
        oldWidget.linearTransition != widget.linearTransition) {
      _disposeCurve();
      _setupAnimation();
    }
  }

  @override
  void dispose() {
    _disposeCurve();
    super.dispose();
  }

  void _disposeCurve() {
    _primaryPositionCurve?.dispose();
    _secondaryPositionCurve?.dispose();
    _primaryShadowCurve?.dispose();
    _primaryPositionCurve = null;
    _secondaryPositionCurve = null;
    _primaryShadowCurve = null;
  }

  void _setupAnimation() {
    if (!widget.linearTransition) {
      _primaryPositionCurve = CurvedAnimation(
        parent: widget.primaryRouteAnimation,
        curve: Curves.fastEaseInToSlowEaseOut,
        reverseCurve: Curves.fastEaseInToSlowEaseOut.flipped,
      );
      _secondaryPositionCurve = CurvedAnimation(
        parent: widget.secondaryRouteAnimation,
        curve: Curves.linearToEaseOut,
        reverseCurve: Curves.easeInToLinear,
      );
      _primaryShadowCurve = CurvedAnimation(
        parent: widget.primaryRouteAnimation,
        curve: Curves.linearToEaseOut,
      );
    }
    _primaryPositionAnimation = (_primaryPositionCurve ?? widget.primaryRouteAnimation).drive(
      _kRightMiddleTween,
    );
    _secondaryPositionAnimation = (_secondaryPositionCurve ?? widget.secondaryRouteAnimation).drive(
      _kMiddleLeftTween,
    );
    _primaryShadowAnimation = (_primaryShadowCurve ?? widget.primaryRouteAnimation).drive(
      _CupertinoEdgeShadowDecoration.kTween,
    );
  }

  @override
  Widget build(BuildContext context) {
    assert(debugCheckHasDirectionality(context));
    final TextDirection textDirection = Directionality.of(context);
    return SlideTransition(
      position: _secondaryPositionAnimation,
      textDirection: textDirection,
      transformHitTests: false,
      child: SlideTransition(
        position: _primaryPositionAnimation,
        textDirection: textDirection,
        child: DecoratedBoxTransition(decoration: _primaryShadowAnimation, child: widget.child),
      ),
    );
  }
}

/// An iOS-style transition used for summoning fullscreen dialogs.
///
/// For example, used when creating a new calendar event by bringing in the next
/// screen from the bottom.
class CupertinoFullscreenDialogTransition extends StatefulWidget {
  /// Creates an iOS-style transition used for summoning fullscreen dialogs.
  ///
  const CupertinoFullscreenDialogTransition({
    super.key,
    required this.primaryRouteAnimation,
    required this.secondaryRouteAnimation,
    required this.child,
    required this.linearTransition,
  });

  ///  * `primaryRouteAnimation` is a linear route animation from 0.0 to 1.0
  ///    when this screen is being pushed.
  final Animation<double> primaryRouteAnimation;

  ///  * `secondaryRouteAnimation` is a linear route animation from 0.0 to 1.0
  ///    when another screen is being pushed on top of this one.
  final Animation<double> secondaryRouteAnimation;

  ///  * `linearTransition` is whether to perform the transitions linearly.
  ///    Used to precisely track back gesture drags.
  final bool linearTransition;

  /// The widget below this widget in the tree.
  final Widget child;

  @override
  State<CupertinoFullscreenDialogTransition> createState() =>
      _CupertinoFullscreenDialogTransitionState();
}

class _CupertinoFullscreenDialogTransitionState extends State<CupertinoFullscreenDialogTransition> {
  /// When this page is coming in to cover another page.
  late Animation<Offset> _primaryPositionAnimation;

  /// When this page is becoming covered by another page.
  late Animation<Offset> _secondaryPositionAnimation;

  /// Curve of primary page which is coming in to cover another page.
  CurvedAnimation? _primaryPositionCurve;

  /// Curve of secondary page which is becoming covered by another page.
  CurvedAnimation? _secondaryPositionCurve;

  @override
  void initState() {
    super.initState();
    _setupAnimation();
  }

  @override
  void didUpdateWidget(covariant CupertinoFullscreenDialogTransition oldWidget) {
    super.didUpdateWidget(oldWidget);
    if (oldWidget.primaryRouteAnimation != widget.primaryRouteAnimation ||
        oldWidget.secondaryRouteAnimation != widget.secondaryRouteAnimation ||
        oldWidget.linearTransition != widget.linearTransition) {
      _disposeCurve();
      _setupAnimation();
    }
  }

  @override
  void dispose() {
    _disposeCurve();
    super.dispose();
  }

  void _disposeCurve() {
    _primaryPositionCurve?.dispose();
    _secondaryPositionCurve?.dispose();
    _primaryPositionCurve = null;
    _secondaryPositionCurve = null;
  }

  void _setupAnimation() {
    _primaryPositionAnimation = (_primaryPositionCurve = CurvedAnimation(
          parent: widget.primaryRouteAnimation,
          curve: Curves.linearToEaseOut,
          // The curve must be flipped so that the reverse animation doesn't play
          // an ease-in curve, which iOS does not use.
          reverseCurve: Curves.linearToEaseOut.flipped,
        ))
        .drive(_kBottomUpTween);
    _secondaryPositionAnimation = (widget.linearTransition
            ? widget.secondaryRouteAnimation
            : _secondaryPositionCurve = CurvedAnimation(
              parent: widget.secondaryRouteAnimation,
              curve: Curves.linearToEaseOut,
              reverseCurve: Curves.easeInToLinear,
            ))
        .drive(_kMiddleLeftTween);
  }

  @override
  Widget build(BuildContext context) {
    assert(debugCheckHasDirectionality(context));
    final TextDirection textDirection = Directionality.of(context);
    return SlideTransition(
      position: _secondaryPositionAnimation,
      textDirection: textDirection,
      transformHitTests: false,
      child: SlideTransition(position: _primaryPositionAnimation, child: widget.child),
    );
  }
}

/// This is the widget side of [_CupertinoBackGestureController].
///
/// This widget provides a gesture recognizer which, when it determines the
/// route can be closed with a back gesture, creates the controller and
/// feeds it the input from the gesture recognizer.
///
/// The gesture data is converted from absolute coordinates to logical
/// coordinates by this widget.
///
/// The type `T` specifies the return type of the route with which this gesture
/// detector is associated.
class _CupertinoBackGestureDetector<T> extends StatefulWidget {
  const _CupertinoBackGestureDetector({
    super.key,
    required this.enabledCallback,
    required this.onStartPopGesture,
    required this.child,
  });

  final Widget child;

  final ValueGetter<bool> enabledCallback;

  final ValueGetter<_CupertinoBackGestureController<T>> onStartPopGesture;

  @override
  _CupertinoBackGestureDetectorState<T> createState() => _CupertinoBackGestureDetectorState<T>();
}

class _CupertinoBackGestureDetectorState<T> extends State<_CupertinoBackGestureDetector<T>> {
  _CupertinoBackGestureController<T>? _backGestureController;

  late HorizontalDragGestureRecognizer _recognizer;

  @override
  void initState() {
    super.initState();
    _recognizer =
        HorizontalDragGestureRecognizer(debugOwner: this)
          ..onStart = _handleDragStart
          ..onUpdate = _handleDragUpdate
          ..onEnd = _handleDragEnd
          ..onCancel = _handleDragCancel;
  }

  @override
  void dispose() {
    _recognizer.dispose();

    // If this is disposed during a drag, call navigator.didStopUserGesture.
    if (_backGestureController != null) {
      WidgetsBinding.instance.addPostFrameCallback((_) {
        if (_backGestureController?.navigator.mounted ?? false) {
          _backGestureController?.navigator.didStopUserGesture();
        }
        _backGestureController = null;
      });
    }
    super.dispose();
  }

  void _handleDragStart(DragStartDetails details) {
    assert(mounted);
    assert(_backGestureController == null);
    _backGestureController = widget.onStartPopGesture();
  }

  void _handleDragUpdate(DragUpdateDetails details) {
    assert(mounted);
    assert(_backGestureController != null);
    _backGestureController!.dragUpdate(
      _convertToLogical(details.primaryDelta! / context.size!.width),
    );
  }

  void _handleDragEnd(DragEndDetails details) {
    assert(mounted);
    assert(_backGestureController != null);
    _backGestureController!.dragEnd(
      _convertToLogical(details.velocity.pixelsPerSecond.dx / context.size!.width),
    );
    _backGestureController = null;
  }

  void _handleDragCancel() {
    assert(mounted);
    // This can be called even if start is not called, paired with the "down" event
    // that we don't consider here.
    _backGestureController?.dragEnd(0.0);
    _backGestureController = null;
  }

  void _handlePointerDown(PointerDownEvent event) {
    if (widget.enabledCallback()) {
      _recognizer.addPointer(event);
    }
  }

  double _convertToLogical(double value) {
    return switch (Directionality.of(context)) {
      TextDirection.rtl => -value,
      TextDirection.ltr => value,
    };
  }

  @override
  Widget build(BuildContext context) {
    assert(debugCheckHasDirectionality(context));
    // For devices with notches, the drag area needs to be larger on the side
    // that has the notch.
    final double dragAreaWidth = switch (Directionality.of(context)) {
      TextDirection.rtl => MediaQuery.paddingOf(context).right,
      TextDirection.ltr => MediaQuery.paddingOf(context).left,
    };
    return Stack(
      fit: StackFit.passthrough,
      children: <Widget>[
        widget.child,
        PositionedDirectional(
          start: 0.0,
          width: max(dragAreaWidth, _kBackGestureWidth),
          top: 0.0,
          bottom: 0.0,
          child: Listener(onPointerDown: _handlePointerDown, behavior: HitTestBehavior.translucent),
        ),
      ],
    );
  }
}

/// A controller for an iOS-style back gesture.
///
/// This is created by a [CupertinoPageRoute] in response from a gesture caught
/// by a [_CupertinoBackGestureDetector] widget, which then also feeds it input
/// from the gesture. It controls the animation controller owned by the route,
/// based on the input provided by the gesture detector.
///
/// This class works entirely in logical coordinates (0.0 is new page dismissed,
/// 1.0 is new page on top).
///
/// The type `T` specifies the return type of the route with which this gesture
/// detector controller is associated.
class _CupertinoBackGestureController<T> {
  /// Creates a controller for an iOS-style back gesture.
  _CupertinoBackGestureController({
    required this.navigator,
    required this.controller,
    required this.getIsActive,
    required this.getIsCurrent,
  }) {
    navigator.didStartUserGesture();
  }

  final AnimationController controller;
  final NavigatorState navigator;
  final ValueGetter<bool> getIsActive;
  final ValueGetter<bool> getIsCurrent;

  /// The drag gesture has changed by [delta]. The total range of the drag
  /// should be 0.0 to 1.0.
  void dragUpdate(double delta) {
    controller.value -= delta;
  }

  /// The drag gesture has ended with a horizontal motion of [velocity] as a
  /// fraction of screen width per second.
  void dragEnd(double velocity) {
    // Fling in the appropriate direction.
    //
    // This curve has been determined through rigorously eyeballing native iOS
    // animations.
    const Curve animationCurve = Curves.fastEaseInToSlowEaseOut;
    final bool isCurrent = getIsCurrent();
    final bool animateForward;

    if (!isCurrent) {
      // If the page has already been navigated away from, then the animation
      // direction depends on whether or not it's still in the navigation stack,
      // regardless of velocity or drag position. For example, if a route is
      // being slowly dragged back by just a few pixels, but then a programmatic
      // pop occurs, the route should still be animated off the screen.
      // See https://github.com/flutter/flutter/issues/141268.
      animateForward = getIsActive();
    } else if (velocity.abs() >= _kMinFlingVelocity) {
      // If the user releases the page before mid screen with sufficient velocity,
      // or after mid screen, we should animate the page out. Otherwise, the page
      // should be animated back in.
      animateForward = velocity <= 0;
    } else {
      animateForward = controller.value > 0.5;
    }

    if (animateForward) {
      controller.animateTo(
        1.0,
        duration: _kDroppedSwipePageAnimationDuration,
        curve: animationCurve,
      );
    } else {
      if (isCurrent) {
        // This route is destined to pop at this point. Reuse navigator's pop.
        navigator.pop();
      }

      // The popping may have finished inline if already at the target destination.
      if (controller.isAnimating) {
        controller.animateBack(
          0.0,
          duration: _kDroppedSwipePageAnimationDuration,
          curve: animationCurve,
        );
      }
    }

    if (controller.isAnimating) {
      // Keep the userGestureInProgress in true state so we don't change the
      // curve of the page transition mid-flight since CupertinoPageTransition
      // depends on userGestureInProgress.
      late AnimationStatusListener animationStatusCallback;
      animationStatusCallback = (AnimationStatus status) {
        navigator.didStopUserGesture();
        controller.removeStatusListener(animationStatusCallback);
      };
      controller.addStatusListener(animationStatusCallback);
    } else {
      navigator.didStopUserGesture();
    }
  }
}

// A custom [Decoration] used to paint an extra shadow on the start edge of the
// box it's decorating. It's like a [BoxDecoration] with only a gradient except
// it paints on the start side of the box instead of behind the box.
class _CupertinoEdgeShadowDecoration extends Decoration {
  const _CupertinoEdgeShadowDecoration._([this._colors]);

  static DecorationTween kTween = DecorationTween(
    begin: const _CupertinoEdgeShadowDecoration._(), // No decoration initially.
    end: const _CupertinoEdgeShadowDecoration._(
      // Eyeballed gradient used to mimic a drop shadow on the start side only.
      <Color>[Color(0x04000000), CupertinoColors.transparent],
    ),
  );

  // Colors used to paint a gradient at the start edge of the box it is
  // decorating.
  //
  // The first color in the list is used at the start of the gradient, which
  // is located at the start edge of the decorated box.
  //
  // If this is null, no shadow is drawn.
  //
  // The list must have at least two colors in it (otherwise it would not be a
  // gradient).
  final List<Color>? _colors;

  // Linearly interpolate between two edge shadow decorations decorations.
  //
  // The `t` argument represents position on the timeline, with 0.0 meaning
  // that the interpolation has not started, returning `a` (or something
  // equivalent to `a`), 1.0 meaning that the interpolation has finished,
  // returning `b` (or something equivalent to `b`), and values in between
  // meaning that the interpolation is at the relevant point on the timeline
  // between `a` and `b`. The interpolation can be extrapolated beyond 0.0 and
  // 1.0, so negative values and values greater than 1.0 are valid (and can
  // easily be generated by curves such as [Curves.elasticInOut]).
  //
  // Values for `t` are usually obtained from an [Animation<double>], such as
  // an [AnimationController].
  //
  // See also:
  //
  //  * [Decoration.lerp].
  static _CupertinoEdgeShadowDecoration? lerp(
    _CupertinoEdgeShadowDecoration? a,
    _CupertinoEdgeShadowDecoration? b,
    double t,
  ) {
    if (identical(a, b)) {
      return a;
    }
    if (a == null) {
      return b!._colors == null
          ? b
          : _CupertinoEdgeShadowDecoration._(
            b._colors!.map<Color>((Color color) => Color.lerp(null, color, t)!).toList(),
          );
    }
    if (b == null) {
      return a._colors == null
          ? a
          : _CupertinoEdgeShadowDecoration._(
            a._colors.map<Color>((Color color) => Color.lerp(null, color, 1.0 - t)!).toList(),
          );
    }
    assert(b._colors != null || a._colors != null);
    // If it ever becomes necessary, we could allow decorations with different
    // length' here, similarly to how it is handled in [LinearGradient.lerp].
    assert(b._colors == null || a._colors == null || a._colors.length == b._colors.length);
    return _CupertinoEdgeShadowDecoration._(<Color>[
      for (int i = 0; i < b._colors!.length; i += 1) Color.lerp(a._colors?[i], b._colors[i], t)!,
    ]);
  }

  @override
  _CupertinoEdgeShadowDecoration lerpFrom(Decoration? a, double t) {
    if (a is _CupertinoEdgeShadowDecoration) {
      return _CupertinoEdgeShadowDecoration.lerp(a, this, t)!;
    }
    return _CupertinoEdgeShadowDecoration.lerp(null, this, t)!;
  }

  @override
  _CupertinoEdgeShadowDecoration lerpTo(Decoration? b, double t) {
    if (b is _CupertinoEdgeShadowDecoration) {
      return _CupertinoEdgeShadowDecoration.lerp(this, b, t)!;
    }
    return _CupertinoEdgeShadowDecoration.lerp(this, null, t)!;
  }

  @override
  _CupertinoEdgeShadowPainter createBoxPainter([VoidCallback? onChanged]) {
    return _CupertinoEdgeShadowPainter(this, onChanged);
  }

  @override
  bool operator ==(Object other) {
    if (other.runtimeType != runtimeType) {
      return false;
    }
    return other is _CupertinoEdgeShadowDecoration && other._colors == _colors;
  }

  @override
  int get hashCode => _colors.hashCode;

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties.add(IterableProperty<Color>('colors', _colors));
  }
}

/// A [BoxPainter] used to draw the page transition shadow using gradients.
class _CupertinoEdgeShadowPainter extends BoxPainter {
  _CupertinoEdgeShadowPainter(this._decoration, super.onChanged)
    : assert(_decoration._colors == null || _decoration._colors.length > 1);

  final _CupertinoEdgeShadowDecoration _decoration;

  @override
  void paint(Canvas canvas, Offset offset, ImageConfiguration configuration) {
    final List<Color>? colors = _decoration._colors;
    if (colors == null) {
      return;
    }

    // The following code simulates drawing a [LinearGradient] configured as
    // follows:
    //
    // LinearGradient(
    //   begin: AlignmentDirectional(0.90, 0.0), // Spans 5% of the page.
    //   colors: _decoration._colors,
    // )
    //
    // A performance evaluation on Feb 8, 2021 showed, that drawing the gradient
    // manually as implemented below is more performant than relying on
    // [LinearGradient.createShader] because compiling that shader takes a long
    // time. On an iPhone XR, the implementation below reduced the worst frame
    // time for a cupertino page transition of a newly installed app from ~95ms
    // down to ~30ms, mainly because there's no longer a need to compile a
    // shader for the LinearGradient.
    //
    // The implementation below divides the width of the shadow into multiple
    // bands of equal width, one for each color interval defined by
    // `_decoration._colors`. Band x is filled with a gradient going from
    // `_decoration._colors[x]` to `_decoration._colors[x + 1]` by drawing a
    // bunch of 1px wide rects. The rects change their color by lerping between
    // the two colors that define the interval of the band.

    // Shadow spans 5% of the page.
    final double shadowWidth = 0.05 * configuration.size!.width;
    final double shadowHeight = configuration.size!.height;
    final double bandWidth = shadowWidth / (colors.length - 1);

    final TextDirection? textDirection = configuration.textDirection;
    assert(textDirection != null);
    final (double shadowDirection, double start) = switch (textDirection!) {
      TextDirection.rtl => (1, offset.dx + configuration.size!.width),
      TextDirection.ltr => (-1, offset.dx),
    };

    int bandColorIndex = 0;
    for (int dx = 0; dx < shadowWidth; dx += 1) {
      if (dx ~/ bandWidth != bandColorIndex) {
        bandColorIndex += 1;
      }
      final Paint paint =
          Paint()
            ..color =
                Color.lerp(
                  colors[bandColorIndex],
                  colors[bandColorIndex + 1],
                  (dx % bandWidth) / bandWidth,
                )!;
      final double x = start + shadowDirection * dx;
      canvas.drawRect(Rect.fromLTWH(x - 1.0, offset.dy, 1.0, shadowHeight), paint);
    }
  }
}

// The stiffness used by dialogs and action sheets.
//
// The stiffness value is obtained by examining the properties of
// `CASpringAnimation` in Xcode. The damping value is derived similarly, with
// additional precision calculated based on `_kStandardStiffness` to ensure a
// damping ratio of 1 (critically damped): damping = 2 * sqrt(stiffness)
const double _kStandardStiffness = 522.35;
const double _kStandardDamping = 45.7099552;
const SpringDescription _kStandardSpring = SpringDescription(
  mass: 1,
  stiffness: _kStandardStiffness,
  damping: _kStandardDamping,
);
// The iOS spring animation duration is 0.404 seconds, based on the properties
// of `CASpringAnimation` in Xcode. At this point, the spring's position
// `x(0.404)` is approximately 0.9990000, suggesting that iOS uses a position
// tolerance of 1e-3 (matching the default `_epsilonDefault` value).
//
// However, the spring's velocity `dx(0.404)` is about 0.02, indicating that iOS
// may not consider velocity when determining the animation's end condition. To
// account for this, a larger velocity tolerance is applied here for added
// safety.
const Tolerance _kStandardTolerance = Tolerance(velocity: 0.03);

/// A route that shows a modal iOS-style popup that slides up from the
/// bottom of the screen.
///
/// Such a popup is an alternative to a menu or a dialog and prevents the user
/// from interacting with the rest of the app.
///
/// It is used internally by [showCupertinoModalPopup] or can be directly pushed
/// onto the [Navigator] stack to enable state restoration. See
/// [showCupertinoModalPopup] for a state restoration app example.
///
/// The `barrierColor` argument determines the [Color] of the barrier underneath
/// the popup. When unspecified, the barrier color defaults to a light opacity
/// black scrim based on iOS's dialog screens. To correctly have iOS resolve
/// to the appropriate modal colors, pass in
/// `CupertinoDynamicColor.resolve(kCupertinoModalBarrierColor, context)`.
///
/// The `barrierDismissible` argument determines whether clicking outside the
/// popup results in dismissal. It is `true` by default.
///
/// The `semanticsDismissible` argument is used to determine whether the
/// semantics of the modal barrier are included in the semantics tree.
///
/// The `routeSettings` argument is used to provide [RouteSettings] to the
/// created Route.
///
/// {@macro flutter.widgets.RawDialogRoute}
///
/// See also:
///
///  * [DisplayFeatureSubScreen], which documents the specifics of how
///    [DisplayFeature]s can split the screen into sub-screens.
///  * [CupertinoActionSheet], which is the widget usually returned by the
///    `builder` argument.
///  * <https://developer.apple.com/design/human-interface-guidelines/ios/views/action-sheets/>
class CupertinoModalPopupRoute<T> extends PopupRoute<T> {
  /// A route that shows a modal iOS-style popup that slides up from the
  /// bottom of the screen.
  CupertinoModalPopupRoute({
    required this.builder,
    this.barrierLabel = 'Dismiss',
    this.barrierColor = kCupertinoModalBarrierColor,
    bool barrierDismissible = true,
    bool semanticsDismissible = false,
    super.filter,
    super.settings,
    super.requestFocus,
    this.anchorPoint,
  }) : _barrierDismissible = barrierDismissible,
       _semanticsDismissible = semanticsDismissible;

  /// A builder that builds the widget tree for the [CupertinoModalPopupRoute].
  ///
  /// The [builder] argument typically builds a [CupertinoActionSheet] widget.
  ///
  /// Content below the widget is dimmed with a [ModalBarrier]. The widget built
  /// by the [builder] does not share a context with the route it was originally
  /// built from. Use a [StatefulBuilder] or a custom [StatefulWidget] if the
  /// widget needs to update dynamically.
  final WidgetBuilder builder;

  final bool _barrierDismissible;

  final bool _semanticsDismissible;

  @override
  final String barrierLabel;

  @override
  final Color? barrierColor;

  @override
  bool get barrierDismissible => _barrierDismissible;

  @override
  bool get semanticsDismissible => _semanticsDismissible;

  @override
  Duration get transitionDuration => _kModalPopupTransitionDuration;

  /// {@macro flutter.widgets.DisplayFeatureSubScreen.anchorPoint}
  final Offset? anchorPoint;

  @override
  Simulation createSimulation({required bool forward}) {
    assert(!debugTransitionCompleted(), 'Cannot reuse a $runtimeType after disposing it.');
    final double end = forward ? 1.0 : 0.0;
    return SpringSimulation(
      _kStandardSpring,
      controller!.value,
      end,
      0,
      tolerance: _kStandardTolerance,
      snapToEnd: true,
    );
  }

  @override
  Widget buildPage(
    BuildContext context,
    Animation<double> animation,
    Animation<double> secondaryAnimation,
  ) {
    return CupertinoUserInterfaceLevel(
      data: CupertinoUserInterfaceLevelData.elevated,
      child: DisplayFeatureSubScreen(anchorPoint: anchorPoint, child: Builder(builder: builder)),
    );
  }

  @override
  Widget buildTransitions(
    BuildContext context,
    Animation<double> animation,
    Animation<double> secondaryAnimation,
    Widget child,
  ) {
    return Align(
      alignment: Alignment.bottomCenter,
      child: FractionalTranslation(translation: _offsetTween.evaluate(animation), child: child),
    );
  }

  static final Tween<Offset> _offsetTween = Tween<Offset>(
    begin: const Offset(0.0, 1.0),
    end: Offset.zero,
  );
}

/// Shows a modal iOS-style popup that slides up from the bottom of the screen.
///
/// Such a popup is an alternative to a menu or a dialog and prevents the user
/// from interacting with the rest of the app.
///
/// The `context` argument is used to look up the [Navigator] for the popup.
/// It is only used when the method is called. Its corresponding widget can be
/// safely removed from the tree before the popup is closed.
///
/// The `barrierColor` argument determines the [Color] of the barrier underneath
/// the popup. When unspecified, the barrier color defaults to a light opacity
/// black scrim based on iOS's dialog screens.
///
/// The `barrierDismissible` argument determines whether clicking outside the
/// popup results in dismissal. It is `true` by default.
///
/// The `useRootNavigator` argument is used to determine whether to push the
/// popup to the [Navigator] furthest from or nearest to the given `context`. It
/// is `true` by default.
///
/// The `semanticsDismissible` argument is used to determine whether the
/// semantics of the modal barrier are included in the semantics tree.
///
/// The `routeSettings` argument is used to provide [RouteSettings] to the
/// created Route.
///
/// The `builder` argument typically builds a [CupertinoActionSheet] widget.
/// Content below the widget is dimmed with a [ModalBarrier]. The widget built
/// by the `builder` does not share a context with the location that
/// [showCupertinoModalPopup] is originally called from. Use a
/// [StatefulBuilder] or a custom [StatefulWidget] if the widget needs to
/// update dynamically.
///
/// {@macro flutter.widgets.RawDialogRoute}
///
/// Returns a `Future` that resolves to the value that was passed to
/// [Navigator.pop] when the popup was closed.
///
/// ### State Restoration in Modals
///
/// Using this method will not enable state restoration for the modal. In order
/// to enable state restoration for a modal, use [Navigator.restorablePush]
/// or [Navigator.restorablePushNamed] with [CupertinoModalPopupRoute].
///
/// For more information about state restoration, see [RestorationManager].
///
/// {@tool dartpad}
/// This sample demonstrates how to create a restorable Cupertino modal route.
/// This is accomplished by enabling state restoration by specifying
/// [CupertinoApp.restorationScopeId] and using [Navigator.restorablePush] to
/// push [CupertinoModalPopupRoute] when the [CupertinoButton] is tapped.
///
/// {@macro flutter.widgets.RestorationManager}
///
/// ** See code in examples/api/lib/cupertino/route/show_cupertino_modal_popup.0.dart **
/// {@end-tool}
///
/// See also:
///
///  * [DisplayFeatureSubScreen], which documents the specifics of how
///    [DisplayFeature]s can split the screen into sub-screens.
///  * [CupertinoActionSheet], which is the widget usually returned by the
///    `builder` argument to [showCupertinoModalPopup].
///  * <https://developer.apple.com/design/human-interface-guidelines/ios/views/action-sheets/>
Future<T?> showCupertinoModalPopup<T>({
  required BuildContext context,
  required WidgetBuilder builder,
  ImageFilter? filter,
  Color barrierColor = kCupertinoModalBarrierColor,
  bool barrierDismissible = true,
  bool useRootNavigator = true,
  bool semanticsDismissible = false,
  RouteSettings? routeSettings,
  Offset? anchorPoint,
}) {
  return Navigator.of(context, rootNavigator: useRootNavigator).push(
    CupertinoModalPopupRoute<T>(
      builder: builder,
      filter: filter,
      barrierColor: CupertinoDynamicColor.resolve(barrierColor, context),
      barrierDismissible: barrierDismissible,
      semanticsDismissible: semanticsDismissible,
      settings: routeSettings,
      anchorPoint: anchorPoint,
    ),
  );
}

Widget _buildCupertinoDialogTransitions(
  BuildContext context,
  Animation<double> animation,
  Animation<double> secondaryAnimation,
  Widget child,
) {
  return child;
}

/// Displays an iOS-style dialog above the current contents of the app, with
/// iOS-style entrance and exit animations, modal barrier color, and modal
/// barrier behavior (by default, the dialog is not dismissible with a tap on
/// the barrier).
///
/// This function takes a `builder` which typically builds a [CupertinoAlertDialog]
/// widget. Content below the dialog is dimmed with a [ModalBarrier]. The widget
/// returned by the `builder` does not share a context with the location that
/// [showCupertinoDialog] is originally called from. Use a [StatefulBuilder] or
/// a custom [StatefulWidget] if the dialog needs to update dynamically.
///
/// The `context` argument is used to look up the [Navigator] for the dialog.
/// It is only used when the method is called. Its corresponding widget can
/// be safely removed from the tree before the dialog is closed.
///
/// The `useRootNavigator` argument is used to determine whether to push the
/// dialog to the [Navigator] furthest from or nearest to the given `context`.
/// By default, `useRootNavigator` is `true` and the dialog route created by
/// this method is pushed to the root navigator.
///
/// {@macro flutter.widgets.RawDialogRoute}
///
/// If the application has multiple [Navigator] objects, it may be necessary to
/// call `Navigator.of(context, rootNavigator: true).pop(result)` to close the
/// dialog rather than just `Navigator.pop(context, result)`.
///
/// Returns a [Future] that resolves to the value (if any) that was passed to
/// [Navigator.pop] when the dialog was closed.
///
/// ### State Restoration in Dialogs
///
/// Using this method will not enable state restoration for the dialog. In order
/// to enable state restoration for a dialog, use [Navigator.restorablePush]
/// or [Navigator.restorablePushNamed] with [CupertinoDialogRoute].
///
/// For more information about state restoration, see [RestorationManager].
///
/// {@tool dartpad}
/// This sample demonstrates how to create a restorable Cupertino dialog. This is
/// accomplished by enabling state restoration by specifying
/// [CupertinoApp.restorationScopeId] and using [Navigator.restorablePush] to
/// push [CupertinoDialogRoute] when the [CupertinoButton] is tapped.
///
/// {@macro flutter.widgets.RestorationManager}
///
/// ** See code in examples/api/lib/cupertino/route/show_cupertino_dialog.0.dart **
/// {@end-tool}
///
/// See also:
///
///  * [CupertinoAlertDialog], an iOS-style alert dialog.
///  * [showDialog], which displays a Material-style dialog.
///  * [showGeneralDialog], which allows for customization of the dialog popup.
///  * [DisplayFeatureSubScreen], which documents the specifics of how
///    [DisplayFeature]s can split the screen into sub-screens.
///  * <https://developer.apple.com/design/human-interface-guidelines/alerts/>
Future<T?> showCupertinoDialog<T>({
  required BuildContext context,
  required WidgetBuilder builder,
  String? barrierLabel,
  bool useRootNavigator = true,
  bool barrierDismissible = false,
  RouteSettings? routeSettings,
  Offset? anchorPoint,
}) {
  return Navigator.of(context, rootNavigator: useRootNavigator).push<T>(
    CupertinoDialogRoute<T>(
      builder: builder,
      context: context,
      barrierDismissible: barrierDismissible,
      barrierLabel: barrierLabel,
      barrierColor: CupertinoDynamicColor.resolve(kCupertinoModalBarrierColor, context),
      settings: routeSettings,
      anchorPoint: anchorPoint,
    ),
  );
}

/// A dialog route that shows an iOS-style dialog.
///
/// It is used internally by [showCupertinoDialog] or can be directly pushed
/// onto the [Navigator] stack to enable state restoration. See
/// [showCupertinoDialog] for a state restoration app example.
///
/// This function takes a `builder` which typically builds a [Dialog] widget.
/// Content below the dialog is dimmed with a [ModalBarrier]. The widget
/// returned by the `builder` does not share a context with the location that
/// `showDialog` is originally called from. Use a [StatefulBuilder] or a
/// custom [StatefulWidget] if the dialog needs to update dynamically.
///
/// The `context` argument is used to look up
/// [CupertinoLocalizations.modalBarrierDismissLabel], which provides the
/// modal with a localized accessibility label that will be used for the
/// modal's barrier. However, a custom `barrierLabel` can be passed in as well.
///
/// The `barrierDismissible` argument is used to indicate whether tapping on the
/// barrier will dismiss the dialog. It is `true` by default and cannot be `null`.
///
/// The `barrierColor` argument is used to specify the color of the modal
/// barrier that darkens everything below the dialog. If `null`, then
/// [CupertinoDynamicColor.resolve] is used to compute the modal color.
///
/// The `settings` argument define the settings for this route. See
/// [RouteSettings] for details.
///
/// {@macro flutter.widgets.RawDialogRoute}
///
/// See also:
///
///  * [showCupertinoDialog], which is a way to display
///     an iOS-style dialog.
///  * [showGeneralDialog], which allows for customization of the dialog popup.
///  * [showDialog], which displays a Material dialog.
///  * [DisplayFeatureSubScreen], which documents the specifics of how
///    [DisplayFeature]s can split the screen into sub-screens.
class CupertinoDialogRoute<T> extends RawDialogRoute<T> {
  /// A dialog route that shows an iOS-style dialog.
  CupertinoDialogRoute({
    required WidgetBuilder builder,
    required BuildContext context,
    super.barrierDismissible,
    Color? barrierColor,
    String? barrierLabel,
    // This transition duration was eyeballed comparing with iOS
    super.transitionDuration = const Duration(milliseconds: 250),
    this.transitionBuilder,
    super.settings,
    super.requestFocus,
    super.anchorPoint,
  }) : super(
         pageBuilder: (
           BuildContext context,
           Animation<double> animation,
           Animation<double> secondaryAnimation,
         ) {
           return builder(context);
         },
         transitionBuilder: transitionBuilder ?? _buildCupertinoDialogTransitions,
         barrierLabel: barrierLabel ?? CupertinoLocalizations.of(context).modalBarrierDismissLabel,
         barrierColor:
             barrierColor ?? CupertinoDynamicColor.resolve(kCupertinoModalBarrierColor, context),
       );

  /// Custom transition builder
  RouteTransitionsBuilder? transitionBuilder;

  CurvedAnimation? _fadeAnimation;

  @override
  Simulation createSimulation({required bool forward}) {
    assert(!debugTransitionCompleted(), 'Cannot reuse a $runtimeType after disposing it.');
    final double end = forward ? 1.0 : 0.0;
    return SpringSimulation(
      _kStandardSpring,
      controller!.value,
      end,
      0,
      tolerance: _kStandardTolerance,
      snapToEnd: true,
    );
  }

  @override
  Widget buildTransitions(
    BuildContext context,
    Animation<double> animation,
    Animation<double> secondaryAnimation,
    Widget child,
  ) {
    if (transitionBuilder != null) {
      return super.buildTransitions(context, animation, secondaryAnimation, child);
    }

    if (animation.status == AnimationStatus.reverse) {
      return FadeTransition(opacity: animation, child: child);
    }
    return FadeTransition(
      opacity: animation,
      child: ScaleTransition(scale: animation.drive(_dialogScaleTween), child: child),
    );
  }

  @override
  void dispose() {
    _fadeAnimation?.dispose();
    super.dispose();
  }

  // The curve and initial scale values were mostly eyeballed from iOS, however
  // they reuse the same animation curve that was modeled after native page
  // transitions.
  static final Tween<double> _dialogScaleTween = Tween<double>(begin: 1.3, end: 1.0);
}


--- File: packages/flutter/lib/src/material/page.dart ---
// Copyright 2014 The Flutter Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

import 'package:flutter/cupertino.dart';

import 'page_transitions_theme.dart';
import 'theme.dart';

/// A modal route that replaces the entire screen with a platform-adaptive
/// transition.
///
/// {@macro flutter.material.materialRouteTransitionMixin}
///
/// By default, when a modal route is replaced by another, the previous route
/// remains in memory. To free all the resources when this is not necessary, set
/// [maintainState] to false.
///
/// The `fullscreenDialog` property specifies whether the incoming route is a
/// fullscreen modal dialog. On iOS, those routes animate from the bottom to the
/// top rather than horizontally.
///
/// If `barrierDismissible` is true, then pressing the escape key on the keyboard
/// will cause the current route to be popped with null as the value.
///
/// The type `T` specifies the return type of the route which can be supplied as
/// the route is popped from the stack via [Navigator.pop] by providing the
/// optional `result` argument.
///
/// See also:
///
///  * [MaterialRouteTransitionMixin], which provides the material transition
///    for this route.
///  * [MaterialPage], which is a [Page] of this class.
class MaterialPageRoute<T> extends PageRoute<T> with MaterialRouteTransitionMixin<T> {
  /// Construct a MaterialPageRoute whose contents are defined by [builder].
  MaterialPageRoute({
    required this.builder,
    super.settings,
    super.requestFocus,
    this.maintainState = true,
    super.fullscreenDialog,
    super.allowSnapshotting = true,
    super.barrierDismissible = false,
  }) {
    assert(opaque);
  }

  /// Builds the primary contents of the route.
  final WidgetBuilder builder;

  @override
  Widget buildContent(BuildContext context) => builder(context);

  @override
  final bool maintainState;

  @override
  String get debugLabel => '${super.debugLabel}(${settings.name})';
}

/// A mixin that provides platform-adaptive transitions for a [PageRoute].
///
/// {@template flutter.material.materialRouteTransitionMixin}
/// For Android, the entrance transition for the page zooms in and fades in
/// while the exiting page zooms out and fades out. The exit transition is similar,
/// but in reverse.
///
/// For iOS, the page slides in from the right and exits in reverse. The page
/// also shifts to the left in parallax when another page enters to cover it.
/// (These directions are flipped in environments with a right-to-left reading
/// direction.)
/// {@endtemplate}
///
/// See also:
///
///  * [PageTransitionsTheme], which defines the default page transitions used
///    by the [MaterialRouteTransitionMixin.buildTransitions].
///  * [ZoomPageTransitionsBuilder], which is the default page transition used
///    by the [PageTransitionsTheme].
///  * [CupertinoPageTransitionsBuilder], which is the default page transition
///    for iOS and macOS.
mixin MaterialRouteTransitionMixin<T> on PageRoute<T> {
  /// Builds the primary contents of the route.
  @protected
  Widget buildContent(BuildContext context);

  @override
  Duration get transitionDuration =>
      _getPageTransitionBuilder(navigator!.context)?.transitionDuration ??
      const Duration(microseconds: 300);

  @override
  Duration get reverseTransitionDuration =>
      _getPageTransitionBuilder(navigator!.context)?.reverseTransitionDuration ??
      const Duration(microseconds: 300);

  PageTransitionsBuilder? _getPageTransitionBuilder(BuildContext context) {
    final TargetPlatform platform = Theme.of(context).platform;
    final PageTransitionsTheme pageTransitionsTheme = Theme.of(context).pageTransitionsTheme;
    return pageTransitionsTheme.builders[platform];
  }

  // The transitionDuration is used to create the AnimationController which is only
  // built once, so when page transition builder is updated and transitionDuration
  // has a new value, the AnimationController cannot be updated automatically. So we
  // manually update its duration here.
  // TODO(quncCccccc): Clean up this override method when controller can be updated as the transitionDuration is changed.
  @override
  TickerFuture didPush() {
    controller?.duration = transitionDuration;
    return super.didPush();
  }

  // The reverseTransitionDuration is used to create the AnimationController
  // which is only built once, so when page transition builder is updated and
  // reverseTransitionDuration has a new value, the AnimationController cannot
  // be updated automatically. So we manually update its reverseDuration here.
  // TODO(quncCccccc): Clean up this override method when controller can beupdated as the reverseTransitionDuration is changed.
  @override
  bool didPop(T? result) {
    controller?.reverseDuration = reverseTransitionDuration;
    return super.didPop(result);
  }

  @override
  Color? get barrierColor => null;

  @override
  String? get barrierLabel => null;

  @override
  DelegatedTransitionBuilder? get delegatedTransition => _delegatedTransition;

  static Widget? _delegatedTransition(
    BuildContext context,
    Animation<double> animation,
    Animation<double> secondaryAnimation,
    bool allowSnapshotting,
    Widget? child,
  ) {
    final PageTransitionsTheme theme = Theme.of(context).pageTransitionsTheme;
    final TargetPlatform platform = Theme.of(context).platform;
    final DelegatedTransitionBuilder? themeDelegatedTransition = theme.delegatedTransition(
      platform,
    );
    return themeDelegatedTransition != null
        ? themeDelegatedTransition(context, animation, secondaryAnimation, allowSnapshotting, child)
        : null;
  }

  @override
  bool canTransitionTo(TransitionRoute<dynamic> nextRoute) {
    // Don't perform outgoing animation if the next route is a fullscreen dialog,
    // or there is no matching transition to use.
    // Don't perform outgoing animation if the next route is a fullscreen dialog.
    final bool nextRouteIsNotFullscreen =
        (nextRoute is! PageRoute<T>) || !nextRoute.fullscreenDialog;

    // If the next route has a delegated transition, then this route is able to
    // use that delegated transition to smoothly sync with the next route's
    // transition.
    final bool nextRouteHasDelegatedTransition =
        nextRoute is ModalRoute<T> && nextRoute.delegatedTransition != null;

    // Otherwise if the next route has the same route transition mixin as this
    // one, then this route will already be synced with its transition.
    return nextRouteIsNotFullscreen &&
        ((nextRoute is MaterialRouteTransitionMixin) || nextRouteHasDelegatedTransition);
  }

  @override
  bool canTransitionFrom(TransitionRoute<dynamic> previousRoute) {
    // Supress previous route from transitioning if this is a fullscreenDialog route.
    return previousRoute is PageRoute && !fullscreenDialog;
  }

  @override
  Widget buildPage(
    BuildContext context,
    Animation<double> animation,
    Animation<double> secondaryAnimation,
  ) {
    final Widget result = buildContent(context);
    return Semantics(scopesRoute: true, explicitChildNodes: true, child: result);
  }

  @override
  Widget buildTransitions(
    BuildContext context,
    Animation<double> animation,
    Animation<double> secondaryAnimation,
    Widget child,
  ) {
    final PageTransitionsTheme theme = Theme.of(context).pageTransitionsTheme;
    return theme.buildTransitions<T>(this, context, animation, secondaryAnimation, child);
  }
}

/// A page that creates a material style [PageRoute].
///
/// {@macro flutter.material.materialRouteTransitionMixin}
///
/// By default, when the created route is replaced by another, the previous
/// route remains in memory. To free all the resources when this is not
/// necessary, set [maintainState] to false.
///
/// The `fullscreenDialog` property specifies whether the created route is a
/// fullscreen modal dialog. On iOS, those routes animate from the bottom to the
/// top rather than horizontally.
///
/// The type `T` specifies the return type of the route which can be supplied as
/// the route is popped from the stack via [Navigator.transitionDelegate] by
/// providing the optional `result` argument to the
/// [RouteTransitionRecord.markForPop] in the [TransitionDelegate.resolve].
///
/// See also:
///
///  * [MaterialPageRoute], which is the [PageRoute] version of this class
class MaterialPage<T> extends Page<T> {
  /// Creates a material page.
  const MaterialPage({
    required this.child,
    this.maintainState = true,
    this.fullscreenDialog = false,
    this.allowSnapshotting = true,
    super.key,
    super.canPop,
    super.onPopInvoked,
    super.name,
    super.arguments,
    super.restorationId,
  });

  /// The content to be shown in the [Route] created by this page.
  final Widget child;

  /// {@macro flutter.widgets.ModalRoute.maintainState}
  final bool maintainState;

  /// {@macro flutter.widgets.PageRoute.fullscreenDialog}
  final bool fullscreenDialog;

  /// {@macro flutter.widgets.TransitionRoute.allowSnapshotting}
  final bool allowSnapshotting;

  @override
  Route<T> createRoute(BuildContext context) {
    return _PageBasedMaterialPageRoute<T>(page: this, allowSnapshotting: allowSnapshotting);
  }
}

// A page-based version of MaterialPageRoute.
//
// This route uses the builder from the page to build its content. This ensures
// the content is up to date after page updates.
class _PageBasedMaterialPageRoute<T> extends PageRoute<T> with MaterialRouteTransitionMixin<T> {
  _PageBasedMaterialPageRoute({required MaterialPage<T> page, super.allowSnapshotting})
    : super(settings: page) {
    assert(opaque);
  }

  MaterialPage<T> get _page => settings as MaterialPage<T>;

  @override
  Widget buildContent(BuildContext context) {
    return _page.child;
  }

  @override
  bool get maintainState => _page.maintainState;

  @override
  bool get fullscreenDialog => _page.fullscreenDialog;

  @override
  String get debugLabel => '${super.debugLabel}(${_page.name})';
}


--- File: packages/flutter/lib/src/widgets/pages.dart ---
// Copyright 2014 The Flutter Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

/// @docImport 'navigator.dart';
library;

import 'basic.dart';
import 'framework.dart';
import 'routes.dart';

/// A modal route that replaces the entire screen.
///
/// The [PageRouteBuilder] subclass provides a way to create a [PageRoute] using
/// callbacks rather than by defining a new class via subclassing.
///
/// If `barrierDismissible` is true, then pressing the escape key on the keyboard
/// will cause the current route to be popped with null as the value.
///
/// See also:
///
///  * [Route], which documents the meaning of the `T` generic type argument.
abstract class PageRoute<T> extends ModalRoute<T> {
  /// Creates a modal route that replaces the entire screen.
  PageRoute({
    super.settings,
    super.requestFocus,
    this.fullscreenDialog = false,
    this.allowSnapshotting = true,
    bool barrierDismissible = false,
  }) : _barrierDismissible = barrierDismissible;

  /// {@template flutter.widgets.PageRoute.fullscreenDialog}
  /// Whether this page route is a full-screen dialog.
  ///
  /// In Material and Cupertino, being fullscreen has the effects of making
  /// the app bars have a close button instead of a back button. On
  /// iOS, dialogs transitions animate differently and are also not closeable
  /// with the back swipe gesture.
  /// {@endtemplate}
  final bool fullscreenDialog;

  @override
  final bool allowSnapshotting;

  @override
  bool get opaque => true;

  @override
  bool get barrierDismissible => _barrierDismissible;
  final bool _barrierDismissible;

  @override
  bool canTransitionTo(TransitionRoute<dynamic> nextRoute) => nextRoute is PageRoute;

  @override
  bool canTransitionFrom(TransitionRoute<dynamic> previousRoute) => previousRoute is PageRoute;

  @override
  bool get popGestureEnabled {
    // Fullscreen dialogs aren't dismissible by back swipe.
    return !fullscreenDialog && super.popGestureEnabled;
  }
}

Widget _defaultTransitionsBuilder(
  BuildContext context,
  Animation<double> animation,
  Animation<double> secondaryAnimation,
  Widget child,
) {
  return child;
}

/// A utility class for defining one-off page routes in terms of callbacks.
///
/// Callers must define the [pageBuilder] function which creates the route's
/// primary contents. To add transitions define the [transitionsBuilder] function.
///
/// The `T` generic type argument corresponds to the type argument of the
/// created [Route] objects.
///
/// See also:
///
///  * [Route], which documents the meaning of the `T` generic type argument.
class PageRouteBuilder<T> extends PageRoute<T> {
  /// Creates a route that delegates to builder callbacks.
  PageRouteBuilder({
    super.settings,
    super.requestFocus,
    required this.pageBuilder,
    this.transitionsBuilder = _defaultTransitionsBuilder,
    this.transitionDuration = const Duration(milliseconds: 300),
    this.reverseTransitionDuration = const Duration(milliseconds: 300),
    this.opaque = true,
    this.barrierDismissible = false,
    this.barrierColor,
    this.barrierLabel,
    this.maintainState = true,
    super.fullscreenDialog,
    super.allowSnapshotting = true,
  });

  /// {@template flutter.widgets.pageRouteBuilder.pageBuilder}
  /// Used build the route's primary contents.
  ///
  /// See [ModalRoute.buildPage] for complete definition of the parameters.
  /// {@endtemplate}
  final RoutePageBuilder pageBuilder;

  /// {@template flutter.widgets.pageRouteBuilder.transitionsBuilder}
  /// Used to build the route's transitions.
  ///
  /// See [ModalRoute.buildTransitions] for complete definition of the parameters.
  /// {@endtemplate}
  ///
  /// The default transition is a jump cut (i.e. no animation).
  final RouteTransitionsBuilder transitionsBuilder;

  @override
  final Duration transitionDuration;

  @override
  final Duration reverseTransitionDuration;

  @override
  final bool opaque;

  @override
  final bool barrierDismissible;

  @override
  final Color? barrierColor;

  @override
  final String? barrierLabel;

  @override
  final bool maintainState;

  @override
  Widget buildPage(
    BuildContext context,
    Animation<double> animation,
    Animation<double> secondaryAnimation,
  ) {
    return pageBuilder(context, animation, secondaryAnimation);
  }

  @override
  Widget buildTransitions(
    BuildContext context,
    Animation<double> animation,
    Animation<double> secondaryAnimation,
    Widget child,
  ) {
    return transitionsBuilder(context, animation, secondaryAnimation, child);
  }
}


Instructions for the chapter (Generate content in English unless specified otherwise):
- Start with a clear heading (e.g., `# Chapter 1: PageRoute
`). Use the provided concept name.

- If this is not the first chapter, begin with a brief transition from the previous chapter, referencing it with a proper Markdown link using its name.

- Begin with a high-level motivation explaining what problem this abstraction solves. Start with a central use case as a concrete example. The whole chapter should guide the reader to understand how to solve this use case. Make it very minimal and friendly to beginners.

- If the abstraction is complex, break it down into key concepts. Explain each concept one-by-one in a very beginner-friendly way.

- Explain how to use this abstraction to solve the use case. Give example inputs and outputs for code snippets (if the output isn't values, describe at a high level what will happen).

- Each code block should be BELOW 10 lines! If longer code blocks are needed, break them down into smaller pieces and walk through them one-by-one. Aggresively simplify the code to make it minimal. Use comments to skip non-important implementation details. Each code block should have a beginner friendly explanation right after it.

- Describe the internal implementation to help understand what's under the hood. First provide a non-code or code-light walkthrough on what happens step-by-step when the abstraction is called. It's recommended to use a simple sequenceDiagram with a dummy example - keep it minimal with at most 5 participants to ensure clarity. If participant name has space, use: `participant QP as Query Processing`. .

- Then dive deeper into code for the internal implementation with references to files. Provide example code blocks, but make them similarly simple and beginner-friendly. Explain.

- IMPORTANT: When you need to refer to other core abstractions covered in other chapters, ALWAYS use proper Markdown links like this: [Chapter Title](filename.md). Use the Complete Tutorial Structure above to find the correct filename and the chapter title. Translate the surrounding text.

- Use mermaid diagrams to illustrate complex concepts (```mermaid``` format). .

- Heavily use analogies and examples throughout to help beginners understand.

- End the chapter with a brief conclusion that summarizes what was learned and provides a transition to the next chapter. If there is a next chapter, use a proper Markdown link: [Next Chapter Title](next_chapter_filename).

- Ensure the tone is welcoming and easy for a newcomer to understand.

- Output *only* the Markdown content for this chapter.

Now, directly provide a super beginner-friendly Markdown output (DON'T need ```markdown``` tags):

2025-05-21 12:31:49,512 - INFO - RESPONSE: # Chapter 1: PageRoute

Welcome to the first chapter of our Flutter navigation tutorial! Ever wonder how tapping a button in an app seamlessly takes you to a completely different screen? That's where the magic of navigation comes in! In Flutter, a core concept for managing these screen transitions is the `PageRoute`.

Imagine your Flutter app is like a building with many rooms (screens). When you want to go from one room (the "lobby") to another room (the "settings" screen), you need a plan or a map to get there. A `PageRoute` is exactly that – it's the blueprint, the plan, for a single "page" or screen in your app and how you would transition *to* it.

Think of it as defining:

*   **What the new screen looks like:** What widgets make up this new page?
*   **How the transition happens:** Does it slide from the side, fade in, or something else?
*   **How long the transition takes:** Is it a quick change or a smooth, longer one?
*   **Its behavior:** Can you easily "go back" or dismiss this screen?

The `PageRoute` doesn't *perform* the transition itself; it tells the `Navigator` (Flutter's system for managing screen stacks, like stacking rooms on top of each other) *how* to perform the transition to display its content.

### Our Goal: Showing a Simple New Screen

Throughout this chapter, our goal is to understand enough about `PageRoute` to accomplish a very common task: navigating from one simple screen to another.

Let's start with a basic example. We'll have a main screen with a button. When you tap the button, we want to go to a new, blank screen.

Here's a simplified look at what we might have initially:

```dart
import 'package:flutter/material.dart';

void main() {
  runApp(MyApp());
}

class MyApp extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return MaterialApp(
      home: HomeScreen(),
    );
  }
}

class HomeScreen extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(title: Text('Home Screen')),
      body: Center(
        child: ElevatedButton(
          onPressed: () {
            // We want to go to a new screen here!
          },
          child: Text('Go to New Screen'),
        ),
      ),
    );
  }
}

class NewScreen extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(title: Text('New Screen')),
      body: Center(
        child: Text('Welcome to the new screen!'),
      ),
    );
  }
}
```

In this code, we have `HomeScreen` and `NewScreen`. Our challenge is to connect the button on `HomeScreen` to show `NewScreen`. We need a `PageRoute` for `NewScreen`.

### Understanding PageRoute with PageRouteBuilder

Directly creating a raw `PageRoute` can be a bit advanced for our first step. Flutter provides a helpful class called `PageRouteBuilder` which lets us create a simple `PageRoute` using functions (callbacks). This is perfect for defining basic routes without creating a whole new class.

Let's look at how we can use `PageRouteBuilder` inside the `onPressed` of our `ElevatedButton`:

```dart
// ... inside HomeScreen onPressed ...
onPressed: () {
  Navigator.push(
    context,
    PageRouteBuilder( // Using PageRouteBuilder to define our route
      pageBuilder: (context, animation, secondaryAnimation) {
        // This function builds the actual screen content
        return NewScreen();
      },
      transitionsBuilder: (context, animation, secondaryAnimation, child) {
        // This function defines how the transition looks
        // For now, we'll do a simple fade transition as an example
        return FadeTransition(
          opacity: animation, // Controls the opacity of the new page
          child: child,
        );
      },
      transitionDuration: Duration(milliseconds: 500), // How long the transition takes
    ),
  );
},
// ... rest of HomeScreen ...
```

Let's break down what's happening here:

1.  **`Navigator.push(context, ...)`**: This is how we tell Flutter's navigation system to add a new screen on top of the current one. `context` tells the Navigator where we are in the widget tree.
2.  **`PageRouteBuilder(...)`**: We create an instance of `PageRouteBuilder` to define the characteristics of the new route.
3.  **`pageBuilder: (context, animation, secondaryAnimation) { return NewScreen(); }`**: This is a required function that `PageRouteBuilder` needs. It tells the builder *what* widget tree to display for this page. In our case, it's just our `NewScreen` widget. The `animation` and `secondaryAnimation` parameters are for transition animations, which we'll use in the next part.
4.  **`transitionsBuilder: (context, animation, secondaryAnimation, child) { ... }`**: This optional function defines how the transition *looks*. It takes the context, `animation` (for the incoming page), `secondaryAnimation` (for the outgoing page), and the `child` (which is the widget built by `pageBuilder`). We use a `FadeTransition` here, animating the `opacity` of the incoming page using the `animation` provided.
5.  **`transitionDuration: Duration(milliseconds: 500)`**: This sets how long the transition animation should take.

Now, when you tap the button, the `Navigator` will use this `PageRouteBuilder` to create a `PageRoute`, push it onto the navigation stack, and animate to the `NewScreen` using a 500ms fade effect.

### How it Works Under the Hood (Simplified)

Let's look at a slightly simplified view of what happens when you call `Navigator.push` with a `PageRoute`:

```mermaid
sequenceDiagram
    participant Button as Button Widget
    participant HomeScreen as HomeScreen Widget
    participant Navigator as Navigator
    participant PageRoute as PageRouteBuilder
    participant NewScreen as NewScreen Widget

    Button->HomeScreen: calls onPressed
    HomeScreen->Navigator: calls push(context, PageRoute)
    Navigator->PageRoute: asks for the page content and transitions
    PageRoute->PageRoute: uses pageBuilder to create NewScreen widget
    PageRoute->PageRoute: uses transitionsBuilder to wrap NewScreen with transition widgets
    Navigator->Navigator: Prepares
    Navigator->NewScreen: Builds and animates the transition
```

Essentially, the `Navigator` is like the conductor of an orchestra. You hand it a `PageRoute`, and it orchestrates the process of showing the new screen, including running the transitions defined by the `PageRoute`.

Inside the Flutter framework code for `PageRoute` (like in `packages/flutter/lib/src/widgets/pages.dart`), you'll find methods like `buildPage` and `buildTransitions`. These are the core parts that `PageRouteBuilder` uses its functions (`pageBuilder` and `transitionsBuilder`) to implement:

```dart
// Simplified example from PageRoute (similar to what PageRouteBuilder does internally)
abstract class PageRoute<T> extends ModalRoute<T> {
  // ... other properties ...

  // The PageRoute needs to know how to build the main content
  Widget buildPage(BuildContext context, Animation<double> animation, Animation<double> secondaryAnimation);

  // The PageRoute needs to know how to build the transitions
  Widget buildTransitions(BuildContext context, Animation<double> animation, Animation<double> secondaryAnimation, Widget child);

  // ... more methods for duration, color, etc. ...
}
```

`PageRouteBuilder` fills in these `buildPage` and `buildTransitions` methods using the functions you provide.

### Conclusion

In this chapter, we learned that a `PageRoute` is the fundamental concept in Flutter navigation that defines how a new screen is presented. We saw how to use `PageRouteBuilder` to create a simple `PageRoute` by specifying what the new screen looks like and how the transition should appear.

While `PageRouteBuilder` is great for simple custom transitions, Flutter provides pre-built `PageRoute` implementations for common design patterns, like the Material Design page transitions and the Cupertino (iOS) page transitions. These include standard animations and behaviors.

In the next chapter, we'll dive into one of these standard implementations: [MaterialPageRoute](02_materialpageroute_.md), which provides the familiar animations you see in Android apps.

[Next Chapter: MaterialPageRoute](02_materialpageroute_.md)
2025-05-21 12:31:49,518 - INFO - PROMPT: 
Write a very beginner-friendly tutorial chapter (in Markdown format) for the project `flutter` about the concept: "MaterialPageRoute
". This is Chapter 2.

Concept Details:
- Name: MaterialPageRoute

- Description:
Similar to `CupertinoPageRoute`, the `MaterialPageRoute` is for apps that follow Google's Material Design guidelines. It provides platform-adaptive transitions, meaning it uses an Android-style fade and zoom on Android devices and an iOS-style slide on iOS devices. It's a "Material Design" blueprint that adapts its transition style based on the device being used.


Complete Tutorial Structure:
1. [PageRoute
](01_pageroute_.md)
2. [MaterialPageRoute
](02_materialpageroute_.md)
3. [MaterialRouteTransitionMixin
](03_materialroutetransitionmixin_.md)
4. [CupertinoPageRoute
](04_cupertinopageroute_.md)
5. [CupertinoRouteTransitionMixin
](05_cupertinoroutetransitionmixin_.md)
6. [CupertinoPageTransition
](06_cupertinopagetransition_.md)
7. [CupertinoFullscreenDialogTransition
](07_cupertinofullscreendialogtransition_.md)
8. [CupertinoModalPopupRoute
](08_cupertinomodalpopuproute_.md)
9. [CupertinoDialogRoute
](09_cupertinodialogroute_.md)

Context from previous chapters:
# Chapter 1: PageRoute

Welcome to the first chapter of our Flutter navigation tutorial! Ever wonder how tapping a button in an app seamlessly takes you to a completely different screen? That's where the magic of navigation comes in! In Flutter, a core concept for managing these screen transitions is the `PageRoute`.

Imagine your Flutter app is like a building with many rooms (screens). When you want to go from one room (the "lobby") to another room (the "settings" screen), you need a plan or a map to get there. A `PageRoute` is exactly that – it's the blueprint, the plan, for a single "page" or screen in your app and how you would transition *to* it.

Think of it as defining:

*   **What the new screen looks like:** What widgets make up this new page?
*   **How the transition happens:** Does it slide from the side, fade in, or something else?
*   **How long the transition takes:** Is it a quick change or a smooth, longer one?
*   **Its behavior:** Can you easily "go back" or dismiss this screen?

The `PageRoute` doesn't *perform* the transition itself; it tells the `Navigator` (Flutter's system for managing screen stacks, like stacking rooms on top of each other) *how* to perform the transition to display its content.

### Our Goal: Showing a Simple New Screen

Throughout this chapter, our goal is to understand enough about `PageRoute` to accomplish a very common task: navigating from one simple screen to another.

Let's start with a basic example. We'll have a main screen with a button. When you tap the button, we want to go to a new, blank screen.

Here's a simplified look at what we might have initially:

```dart
import 'package:flutter/material.dart';

void main() {
  runApp(MyApp());
}

class MyApp extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return MaterialApp(
      home: HomeScreen(),
    );
  }
}

class HomeScreen extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(title: Text('Home Screen')),
      body: Center(
        child: ElevatedButton(
          onPressed: () {
            // We want to go to a new screen here!
          },
          child: Text('Go to New Screen'),
        ),
      ),
    );
  }
}

class NewScreen extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(title: Text('New Screen')),
      body: Center(
        child: Text('Welcome to the new screen!'),
      ),
    );
  }
}
```

In this code, we have `HomeScreen` and `NewScreen`. Our challenge is to connect the button on `HomeScreen` to show `NewScreen`. We need a `PageRoute` for `NewScreen`.

### Understanding PageRoute with PageRouteBuilder

Directly creating a raw `PageRoute` can be a bit advanced for our first step. Flutter provides a helpful class called `PageRouteBuilder` which lets us create a simple `PageRoute` using functions (callbacks). This is perfect for defining basic routes without creating a whole new class.

Let's look at how we can use `PageRouteBuilder` inside the `onPressed` of our `ElevatedButton`:

```dart
// ... inside HomeScreen onPressed ...
onPressed: () {
  Navigator.push(
    context,
    PageRouteBuilder( // Using PageRouteBuilder to define our route
      pageBuilder: (context, animation, secondaryAnimation) {
        // This function builds the actual screen content
        return NewScreen();
      },
      transitionsBuilder: (context, animation, secondaryAnimation, child) {
        // This function defines how the transition looks
        // For now, we'll do a simple fade transition as an example
        return FadeTransition(
          opacity: animation, // Controls the opacity of the new page
          child: child,
        );
      },
      transitionDuration: Duration(milliseconds: 500), // How long the transition takes
    ),
  );
},
// ... rest of HomeScreen ...
```

Let's break down what's happening here:

1.  **`Navigator.push(context, ...)`**: This is how we tell Flutter's navigation system to add a new screen on top of the current one. `context` tells the Navigator where we are in the widget tree.
2.  **`PageRouteBuilder(...)`**: We create an instance of `PageRouteBuilder` to define the characteristics of the new route.
3.  **`pageBuilder: (context, animation, secondaryAnimation) { return NewScreen(); }`**: This is a required function that `PageRouteBuilder` needs. It tells the builder *what* widget tree to display for this page. In our case, it's just our `NewScreen` widget. The `animation` and `secondaryAnimation` parameters are for transition animations, which we'll use in the next part.
4.  **`transitionsBuilder: (context, animation, secondaryAnimation, child) { ... }`**: This optional function defines how the transition *looks*. It takes the context, `animation` (for the incoming page), `secondaryAnimation` (for the outgoing page), and the `child` (which is the widget built by `pageBuilder`). We use a `FadeTransition` here, animating the `opacity` of the incoming page using the `animation` provided.
5.  **`transitionDuration: Duration(milliseconds: 500)`**: This sets how long the transition animation should take.

Now, when you tap the button, the `Navigator` will use this `PageRouteBuilder` to create a `PageRoute`, push it onto the navigation stack, and animate to the `NewScreen` using a 500ms fade effect.

### How it Works Under the Hood (Simplified)

Let's look at a slightly simplified view of what happens when you call `Navigator.push` with a `PageRoute`:

```mermaid
sequenceDiagram
    participant Button as Button Widget
    participant HomeScreen as HomeScreen Widget
    participant Navigator as Navigator
    participant PageRoute as PageRouteBuilder
    participant NewScreen as NewScreen Widget

    Button->HomeScreen: calls onPressed
    HomeScreen->Navigator: calls push(context, PageRoute)
    Navigator->PageRoute: asks for the page content and transitions
    PageRoute->PageRoute: uses pageBuilder to create NewScreen widget
    PageRoute->PageRoute: uses transitionsBuilder to wrap NewScreen with transition widgets
    Navigator->Navigator: Prepares
    Navigator->NewScreen: Builds and animates the transition
```

Essentially, the `Navigator` is like the conductor of an orchestra. You hand it a `PageRoute`, and it orchestrates the process of showing the new screen, including running the transitions defined by the `PageRoute`.

Inside the Flutter framework code for `PageRoute` (like in `packages/flutter/lib/src/widgets/pages.dart`), you'll find methods like `buildPage` and `buildTransitions`. These are the core parts that `PageRouteBuilder` uses its functions (`pageBuilder` and `transitionsBuilder`) to implement:

```dart
// Simplified example from PageRoute (similar to what PageRouteBuilder does internally)
abstract class PageRoute<T> extends ModalRoute<T> {
  // ... other properties ...

  // The PageRoute needs to know how to build the main content
  Widget buildPage(BuildContext context, Animation<double> animation, Animation<double> secondaryAnimation);

  // The PageRoute needs to know how to build the transitions
  Widget buildTransitions(BuildContext context, Animation<double> animation, Animation<double> secondaryAnimation, Widget child);

  // ... more methods for duration, color, etc. ...
}
```

`PageRouteBuilder` fills in these `buildPage` and `buildTransitions` methods using the functions you provide.

### Conclusion

In this chapter, we learned that a `PageRoute` is the fundamental concept in Flutter navigation that defines how a new screen is presented. We saw how to use `PageRouteBuilder` to create a simple `PageRoute` by specifying what the new screen looks like and how the transition should appear.

While `PageRouteBuilder` is great for simple custom transitions, Flutter provides pre-built `PageRoute` implementations for common design patterns, like the Material Design page transitions and the Cupertino (iOS) page transitions. These include standard animations and behaviors.

In the next chapter, we'll dive into one of these standard implementations: [MaterialPageRoute](02_materialpageroute_.md), which provides the familiar animations you see in Android apps.

[Next Chapter: MaterialPageRoute](02_materialpageroute_.md)

Relevant Code Snippets (Code itself remains unchanged):
--- File: packages/flutter/lib/src/material/page.dart ---
// Copyright 2014 The Flutter Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

import 'package:flutter/cupertino.dart';

import 'page_transitions_theme.dart';
import 'theme.dart';

/// A modal route that replaces the entire screen with a platform-adaptive
/// transition.
///
/// {@macro flutter.material.materialRouteTransitionMixin}
///
/// By default, when a modal route is replaced by another, the previous route
/// remains in memory. To free all the resources when this is not necessary, set
/// [maintainState] to false.
///
/// The `fullscreenDialog` property specifies whether the incoming route is a
/// fullscreen modal dialog. On iOS, those routes animate from the bottom to the
/// top rather than horizontally.
///
/// If `barrierDismissible` is true, then pressing the escape key on the keyboard
/// will cause the current route to be popped with null as the value.
///
/// The type `T` specifies the return type of the route which can be supplied as
/// the route is popped from the stack via [Navigator.pop] by providing the
/// optional `result` argument.
///
/// See also:
///
///  * [MaterialRouteTransitionMixin], which provides the material transition
///    for this route.
///  * [MaterialPage], which is a [Page] of this class.
class MaterialPageRoute<T> extends PageRoute<T> with MaterialRouteTransitionMixin<T> {
  /// Construct a MaterialPageRoute whose contents are defined by [builder].
  MaterialPageRoute({
    required this.builder,
    super.settings,
    super.requestFocus,
    this.maintainState = true,
    super.fullscreenDialog,
    super.allowSnapshotting = true,
    super.barrierDismissible = false,
  }) {
    assert(opaque);
  }

  /// Builds the primary contents of the route.
  final WidgetBuilder builder;

  @override
  Widget buildContent(BuildContext context) => builder(context);

  @override
  final bool maintainState;

  @override
  String get debugLabel => '${super.debugLabel}(${settings.name})';
}

/// A mixin that provides platform-adaptive transitions for a [PageRoute].
///
/// {@template flutter.material.materialRouteTransitionMixin}
/// For Android, the entrance transition for the page zooms in and fades in
/// while the exiting page zooms out and fades out. The exit transition is similar,
/// but in reverse.
///
/// For iOS, the page slides in from the right and exits in reverse. The page
/// also shifts to the left in parallax when another page enters to cover it.
/// (These directions are flipped in environments with a right-to-left reading
/// direction.)
/// {@endtemplate}
///
/// See also:
///
///  * [PageTransitionsTheme], which defines the default page transitions used
///    by the [MaterialRouteTransitionMixin.buildTransitions].
///  * [ZoomPageTransitionsBuilder], which is the default page transition used
///    by the [PageTransitionsTheme].
///  * [CupertinoPageTransitionsBuilder], which is the default page transition
///    for iOS and macOS.
mixin MaterialRouteTransitionMixin<T> on PageRoute<T> {
  /// Builds the primary contents of the route.
  @protected
  Widget buildContent(BuildContext context);

  @override
  Duration get transitionDuration =>
      _getPageTransitionBuilder(navigator!.context)?.transitionDuration ??
      const Duration(microseconds: 300);

  @override
  Duration get reverseTransitionDuration =>
      _getPageTransitionBuilder(navigator!.context)?.reverseTransitionDuration ??
      const Duration(microseconds: 300);

  PageTransitionsBuilder? _getPageTransitionBuilder(BuildContext context) {
    final TargetPlatform platform = Theme.of(context).platform;
    final PageTransitionsTheme pageTransitionsTheme = Theme.of(context).pageTransitionsTheme;
    return pageTransitionsTheme.builders[platform];
  }

  // The transitionDuration is used to create the AnimationController which is only
  // built once, so when page transition builder is updated and transitionDuration
  // has a new value, the AnimationController cannot be updated automatically. So we
  // manually update its duration here.
  // TODO(quncCccccc): Clean up this override method when controller can be updated as the transitionDuration is changed.
  @override
  TickerFuture didPush() {
    controller?.duration = transitionDuration;
    return super.didPush();
  }

  // The reverseTransitionDuration is used to create the AnimationController
  // which is only built once, so when page transition builder is updated and
  // reverseTransitionDuration has a new value, the AnimationController cannot
  // be updated automatically. So we manually update its reverseDuration here.
  // TODO(quncCccccc): Clean up this override method when controller can beupdated as the reverseTransitionDuration is changed.
  @override
  bool didPop(T? result) {
    controller?.reverseDuration = reverseTransitionDuration;
    return super.didPop(result);
  }

  @override
  Color? get barrierColor => null;

  @override
  String? get barrierLabel => null;

  @override
  DelegatedTransitionBuilder? get delegatedTransition => _delegatedTransition;

  static Widget? _delegatedTransition(
    BuildContext context,
    Animation<double> animation,
    Animation<double> secondaryAnimation,
    bool allowSnapshotting,
    Widget? child,
  ) {
    final PageTransitionsTheme theme = Theme.of(context).pageTransitionsTheme;
    final TargetPlatform platform = Theme.of(context).platform;
    final DelegatedTransitionBuilder? themeDelegatedTransition = theme.delegatedTransition(
      platform,
    );
    return themeDelegatedTransition != null
        ? themeDelegatedTransition(context, animation, secondaryAnimation, allowSnapshotting, child)
        : null;
  }

  @override
  bool canTransitionTo(TransitionRoute<dynamic> nextRoute) {
    // Don't perform outgoing animation if the next route is a fullscreen dialog,
    // or there is no matching transition to use.
    // Don't perform outgoing animation if the next route is a fullscreen dialog.
    final bool nextRouteIsNotFullscreen =
        (nextRoute is! PageRoute<T>) || !nextRoute.fullscreenDialog;

    // If the next route has a delegated transition, then this route is able to
    // use that delegated transition to smoothly sync with the next route's
    // transition.
    final bool nextRouteHasDelegatedTransition =
        nextRoute is ModalRoute<T> && nextRoute.delegatedTransition != null;

    // Otherwise if the next route has the same route transition mixin as this
    // one, then this route will already be synced with its transition.
    return nextRouteIsNotFullscreen &&
        ((nextRoute is MaterialRouteTransitionMixin) || nextRouteHasDelegatedTransition);
  }

  @override
  bool canTransitionFrom(TransitionRoute<dynamic> previousRoute) {
    // Supress previous route from transitioning if this is a fullscreenDialog route.
    return previousRoute is PageRoute && !fullscreenDialog;
  }

  @override
  Widget buildPage(
    BuildContext context,
    Animation<double> animation,
    Animation<double> secondaryAnimation,
  ) {
    final Widget result = buildContent(context);
    return Semantics(scopesRoute: true, explicitChildNodes: true, child: result);
  }

  @override
  Widget buildTransitions(
    BuildContext context,
    Animation<double> animation,
    Animation<double> secondaryAnimation,
    Widget child,
  ) {
    final PageTransitionsTheme theme = Theme.of(context).pageTransitionsTheme;
    return theme.buildTransitions<T>(this, context, animation, secondaryAnimation, child);
  }
}

/// A page that creates a material style [PageRoute].
///
/// {@macro flutter.material.materialRouteTransitionMixin}
///
/// By default, when the created route is replaced by another, the previous
/// route remains in memory. To free all the resources when this is not
/// necessary, set [maintainState] to false.
///
/// The `fullscreenDialog` property specifies whether the created route is a
/// fullscreen modal dialog. On iOS, those routes animate from the bottom to the
/// top rather than horizontally.
///
/// The type `T` specifies the return type of the route which can be supplied as
/// the route is popped from the stack via [Navigator.transitionDelegate] by
/// providing the optional `result` argument to the
/// [RouteTransitionRecord.markForPop] in the [TransitionDelegate.resolve].
///
/// See also:
///
///  * [MaterialPageRoute], which is the [PageRoute] version of this class
class MaterialPage<T> extends Page<T> {
  /// Creates a material page.
  const MaterialPage({
    required this.child,
    this.maintainState = true,
    this.fullscreenDialog = false,
    this.allowSnapshotting = true,
    super.key,
    super.canPop,
    super.onPopInvoked,
    super.name,
    super.arguments,
    super.restorationId,
  });

  /// The content to be shown in the [Route] created by this page.
  final Widget child;

  /// {@macro flutter.widgets.ModalRoute.maintainState}
  final bool maintainState;

  /// {@macro flutter.widgets.PageRoute.fullscreenDialog}
  final bool fullscreenDialog;

  /// {@macro flutter.widgets.TransitionRoute.allowSnapshotting}
  final bool allowSnapshotting;

  @override
  Route<T> createRoute(BuildContext context) {
    return _PageBasedMaterialPageRoute<T>(page: this, allowSnapshotting: allowSnapshotting);
  }
}

// A page-based version of MaterialPageRoute.
//
// This route uses the builder from the page to build its content. This ensures
// the content is up to date after page updates.
class _PageBasedMaterialPageRoute<T> extends PageRoute<T> with MaterialRouteTransitionMixin<T> {
  _PageBasedMaterialPageRoute({required MaterialPage<T> page, super.allowSnapshotting})
    : super(settings: page) {
    assert(opaque);
  }

  MaterialPage<T> get _page => settings as MaterialPage<T>;

  @override
  Widget buildContent(BuildContext context) {
    return _page.child;
  }

  @override
  bool get maintainState => _page.maintainState;

  @override
  bool get fullscreenDialog => _page.fullscreenDialog;

  @override
  String get debugLabel => '${super.debugLabel}(${_page.name})';
}


Instructions for the chapter (Generate content in English unless specified otherwise):
- Start with a clear heading (e.g., `# Chapter 2: MaterialPageRoute
`). Use the provided concept name.

- If this is not the first chapter, begin with a brief transition from the previous chapter, referencing it with a proper Markdown link using its name.

- Begin with a high-level motivation explaining what problem this abstraction solves. Start with a central use case as a concrete example. The whole chapter should guide the reader to understand how to solve this use case. Make it very minimal and friendly to beginners.

- If the abstraction is complex, break it down into key concepts. Explain each concept one-by-one in a very beginner-friendly way.

- Explain how to use this abstraction to solve the use case. Give example inputs and outputs for code snippets (if the output isn't values, describe at a high level what will happen).

- Each code block should be BELOW 10 lines! If longer code blocks are needed, break them down into smaller pieces and walk through them one-by-one. Aggresively simplify the code to make it minimal. Use comments to skip non-important implementation details. Each code block should have a beginner friendly explanation right after it.

- Describe the internal implementation to help understand what's under the hood. First provide a non-code or code-light walkthrough on what happens step-by-step when the abstraction is called. It's recommended to use a simple sequenceDiagram with a dummy example - keep it minimal with at most 5 participants to ensure clarity. If participant name has space, use: `participant QP as Query Processing`. .

- Then dive deeper into code for the internal implementation with references to files. Provide example code blocks, but make them similarly simple and beginner-friendly. Explain.

- IMPORTANT: When you need to refer to other core abstractions covered in other chapters, ALWAYS use proper Markdown links like this: [Chapter Title](filename.md). Use the Complete Tutorial Structure above to find the correct filename and the chapter title. Translate the surrounding text.

- Use mermaid diagrams to illustrate complex concepts (```mermaid``` format). .

- Heavily use analogies and examples throughout to help beginners understand.

- End the chapter with a brief conclusion that summarizes what was learned and provides a transition to the next chapter. If there is a next chapter, use a proper Markdown link: [Next Chapter Title](next_chapter_filename).

- Ensure the tone is welcoming and easy for a newcomer to understand.

- Output *only* the Markdown content for this chapter.

Now, directly provide a super beginner-friendly Markdown output (DON'T need ```markdown``` tags):

2025-05-21 12:32:01,073 - INFO - RESPONSE: # Chapter 2: MaterialPageRoute

Welcome back! In [Chapter 1: PageRoute](01_pageroute_.md), we learned that a `PageRoute` is the blueprint for displaying a new screen and defining its transition. We saw how `PageRouteBuilder` let us create custom routes with animations.

Now, let's explore a really common and useful type of `PageRoute` used in Flutter apps that follow Google's Material Design: the `MaterialPageRoute`.

### What is MaterialPageRoute?

If you've ever used an Android phone, you've likely seen specific ways new screens appear when you tap something – often, they fade in and zoom slightly. `MaterialPageRoute` is designed to give you that native Android look and feel for your screen transitions, *automatically*.

Think of it as a pre-made `PageRoute` specifically built for Material Design. Instead of defining the fade/zoom transition yourself with `PageRouteBuilder`, `MaterialPageRoute` handles it for you.

But here's a cool trick: `MaterialPageRoute` is also platform-adaptive! This means that if you run your app on an iOS device, it will automatically use the standard iOS slide-from-the-right transition. You get the right native feel on both Android and iOS with just one `MaterialPageRoute`!

**Motivation:** We want to navigate from our `HomeScreen` to our `NewScreen` using the standard Material Design (Android-style) transitions on Android and the standard Cupertino (iOS-style) transitions on iOS, without manually building the transition animation ourselves.

### Using MaterialPageRoute

Using `MaterialPageRoute` is much simpler than `PageRouteBuilder` for standard transitions. You just need to tell it *what* screen to build.

Let's go back to our
`HomeScreen` button's `onPressed` and replace the `PageRouteBuilder` with a `MaterialPageRoute`:

```dart
// ... inside HomeScreen onPressed ...
onPressed: () {
  Navigator.push(
    context,
    MaterialPageRoute( // Using MaterialPageRoute!
      builder: (context) {
        // Just provide the widget for the new screen
        return NewScreen();
      },
    ),
  );
},
// ... rest of HomeScreen ...
```

That's it! Notice how much simpler it is?

*   We still use `Navigator.push` to initiate the navigation.
*   We create a `MaterialPageRoute` instance.
*   We provide a `builder` function, which is similar to `pageBuilder` in `PageRouteBuilder`. This function simply returns the widget for the new screen (`NewScreen`).
*   We *don't* need to specify a `transitionsBuilder` or `transitionDuration` explicitly. `MaterialPageRoute` uses default ones suitable for Material Design, chosen automatically based on the device's operating system.

Now, when you tap the button:
*   On an Android device, `NewScreen` will fade in and slightly zoom.
*   On an iOS device, `NewScreen` will slide in from the right.

### How it Works Under the Hood (Simplified)

When you use `MaterialPageRoute`, like with any `PageRoute`, you hand it to the `Navigator`.

```mermaid
sequenceDiagram
    participant Button as Button Widget
    participant HomeScreen as HomeScreen Widget
    participant Navigator as Navigator
    participant MaterialPageRoute as MaterialPageRoute
    participant NewScreen as NewScreen Widget
    participant Theme as Theme Data

    Button->HomeScreen: calls onPressed
    HomeScreen->Navigator: calls push(context, MaterialPageRoute)
    Navigator->MaterialPageRoute: asks for page content and transitions
    MaterialPageRoute->MaterialPageRoute: calls builder() to create NewScreen widget
    MaterialPageRoute->Theme: checks current platform (Android/iOS)
    MaterialPageRoute->MaterialPageRoute: selects relevant transition based on platform
    MaterialPageRoute->NewScreen: Builds and wraps with selected transition widgets
    Navigator->Navigator: Prepares
    Navigator->NewScreen: Animates the transition
```

The key difference from using `PageRouteBuilder` with a custom fade is that `MaterialPageRoute` internally checks the theme and the platform to pick the right animation blueprint.

Let's peek into the Flutter framework code for `MaterialPageRoute` in `packages/flutter/lib/src/material/page.dart`.

You'll see the `MaterialPageRoute` class definition inherits from `PageRoute` and also uses something called `MaterialRouteTransitionMixin` (we'll talk about mixins more later, but for now, think of it as sharing helpful code).

```dart
// Simplified from packages/flutter/lib/src/material/page.dart
class MaterialPageRoute<T> extends PageRoute<T> with MaterialRouteTransitionMixin<T> {
  // ... constructor and other properties ...

  /// Builds the primary contents of the route.
  final WidgetBuilder builder; // This holds the function you passed in!

  @override
  Widget buildContent(BuildContext context) => builder(context); // Uses your builder

  // ... other overrides ...
}
```

The `buildContent` method is where your `builder` function is called to create the `NewScreen` widget.

Where does the platform-adaptive transition logic come from? It's mostly handled by the `MaterialRouteTransitionMixin` and interacts with Flutter's `Theme` and `PageTransitionsTheme`.

```dart
// Simplified/conceptual example from MaterialRouteTransitionMixin
mixin MaterialRouteTransitionMixin<T> on PageRoute<T> {
  // ... other properties ...

  @override
  Widget buildTransitions( // This is where the transition is built!
    BuildContext context,
    Animation<double> animation,
    Animation<double> secondaryAnimation,
    Widget child, // This 'child' is the widget from buildContent (your NewScreen)
  ) {
    // Internally looks at Theme.of(context).platform (Android or iOS)
    // Then looks up the correct transition from Theme.of(context).pageTransitionsTheme
    // Returns the correct transition widget (like a FadeTransition for Android,
    // or a SlideTransition for iOS) wrapping the 'child' (your screen).
    final PageTransitionsTheme theme = Theme.of(context).pageTransitionsTheme;
    return theme.buildTransitions<T>(this, context, animation, secondaryAnimation, child);
  }

  // ... other properties like transitionDuration ...
}
```

So, `MaterialPageRoute` uses the `builder` you provide to show the content and relies on the `MaterialRouteTransitionMixin` (and Flutter's theming system) to automatically select and apply the right transition animation based on the device's platform.

### Conclusion

`MaterialPageRoute` is your go-to `PageRoute` when you want standard Material Design page transitions (fade/zoom on Android, slide on iOS) without needing to manually define the animations. It simplifies the process of creating new routes by providing sensible defaults that match platform conventions. It's a foundational component for navigation in many Flutter applications.

In the next chapter, we'll take a brief look at the `MaterialRouteTransitionMixin` itself, which is the piece that provides the magic platform-adaptive transitions for `MaterialPageRoute`.

[Next Chapter: MaterialRouteTransitionMixin](03_materialroutetransitionmixin_.md)
2025-05-21 12:32:01,079 - INFO - PROMPT: 
Write a very beginner-friendly tutorial chapter (in Markdown format) for the project `flutter` about the concept: "MaterialRouteTransitionMixin
". This is Chapter 3.

Concept Details:
- Name: MaterialRouteTransitionMixin

- Description:
This is the Material Design counterpart to `CupertinoRouteTransitionMixin`. It provides the "ingredients" for implementing platform-adaptive transitions for a `PageRoute`. This mixin makes sure that your screen transitions follow the Material Design guidelines, using appropriate animations based on the operating system (Android or iOS).


Complete Tutorial Structure:
1. [PageRoute
](01_pageroute_.md)
2. [MaterialPageRoute
](02_materialpageroute_.md)
3. [MaterialRouteTransitionMixin
](03_materialroutetransitionmixin_.md)
4. [CupertinoPageRoute
](04_cupertinopageroute_.md)
5. [CupertinoRouteTransitionMixin
](05_cupertinoroutetransitionmixin_.md)
6. [CupertinoPageTransition
](06_cupertinopagetransition_.md)
7. [CupertinoFullscreenDialogTransition
](07_cupertinofullscreendialogtransition_.md)
8. [CupertinoModalPopupRoute
](08_cupertinomodalpopuproute_.md)
9. [CupertinoDialogRoute
](09_cupertinodialogroute_.md)

Context from previous chapters:
# Chapter 1: PageRoute

Welcome to the first chapter of our Flutter navigation tutorial! Ever wonder how tapping a button in an app seamlessly takes you to a completely different screen? That's where the magic of navigation comes in! In Flutter, a core concept for managing these screen transitions is the `PageRoute`.

Imagine your Flutter app is like a building with many rooms (screens). When you want to go from one room (the "lobby") to another room (the "settings" screen), you need a plan or a map to get there. A `PageRoute` is exactly that – it's the blueprint, the plan, for a single "page" or screen in your app and how you would transition *to* it.

Think of it as defining:

*   **What the new screen looks like:** What widgets make up this new page?
*   **How the transition happens:** Does it slide from the side, fade in, or something else?
*   **How long the transition takes:** Is it a quick change or a smooth, longer one?
*   **Its behavior:** Can you easily "go back" or dismiss this screen?

The `PageRoute` doesn't *perform* the transition itself; it tells the `Navigator` (Flutter's system for managing screen stacks, like stacking rooms on top of each other) *how* to perform the transition to display its content.

### Our Goal: Showing a Simple New Screen

Throughout this chapter, our goal is to understand enough about `PageRoute` to accomplish a very common task: navigating from one simple screen to another.

Let's start with a basic example. We'll have a main screen with a button. When you tap the button, we want to go to a new, blank screen.

Here's a simplified look at what we might have initially:

```dart
import 'package:flutter/material.dart';

void main() {
  runApp(MyApp());
}

class MyApp extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return MaterialApp(
      home: HomeScreen(),
    );
  }
}

class HomeScreen extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(title: Text('Home Screen')),
      body: Center(
        child: ElevatedButton(
          onPressed: () {
            // We want to go to a new screen here!
          },
          child: Text('Go to New Screen'),
        ),
      ),
    );
  }
}

class NewScreen extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(title: Text('New Screen')),
      body: Center(
        child: Text('Welcome to the new screen!'),
      ),
    );
  }
}
```

In this code, we have `HomeScreen` and `NewScreen`. Our challenge is to connect the button on `HomeScreen` to show `NewScreen`. We need a `PageRoute` for `NewScreen`.

### Understanding PageRoute with PageRouteBuilder

Directly creating a raw `PageRoute` can be a bit advanced for our first step. Flutter provides a helpful class called `PageRouteBuilder` which lets us create a simple `PageRoute` using functions (callbacks). This is perfect for defining basic routes without creating a whole new class.

Let's look at how we can use `PageRouteBuilder` inside the `onPressed` of our `ElevatedButton`:

```dart
// ... inside HomeScreen onPressed ...
onPressed: () {
  Navigator.push(
    context,
    PageRouteBuilder( // Using PageRouteBuilder to define our route
      pageBuilder: (context, animation, secondaryAnimation) {
        // This function builds the actual screen content
        return NewScreen();
      },
      transitionsBuilder: (context, animation, secondaryAnimation, child) {
        // This function defines how the transition looks
        // For now, we'll do a simple fade transition as an example
        return FadeTransition(
          opacity: animation, // Controls the opacity of the new page
          child: child,
        );
      },
      transitionDuration: Duration(milliseconds: 500), // How long the transition takes
    ),
  );
},
// ... rest of HomeScreen ...
```

Let's break down what's happening here:

1.  **`Navigator.push(context, ...)`**: This is how we tell Flutter's navigation system to add a new screen on top of the current one. `context` tells the Navigator where we are in the widget tree.
2.  **`PageRouteBuilder(...)`**: We create an instance of `PageRouteBuilder` to define the characteristics of the new route.
3.  **`pageBuilder: (context, animation, secondaryAnimation) { return NewScreen(); }`**: This is a required function that `PageRouteBuilder` needs. It tells the builder *what* widget tree to display for this page. In our case, it's just our `NewScreen` widget. The `animation` and `secondaryAnimation` parameters are for transition animations, which we'll use in the next part.
4.  **`transitionsBuilder: (context, animation, secondaryAnimation, child) { ... }`**: This optional function defines how the transition *looks*. It takes the context, `animation` (for the incoming page), `secondaryAnimation` (for the outgoing page), and the `child` (which is the widget built by `pageBuilder`). We use a `FadeTransition` here, animating the `opacity` of the incoming page using the `animation` provided.
5.  **`transitionDuration: Duration(milliseconds: 500)`**: This sets how long the transition animation should take.

Now, when you tap the button, the `Navigator` will use this `PageRouteBuilder` to create a `PageRoute`, push it onto the navigation stack, and animate to the `NewScreen` using a 500ms fade effect.

### How it Works Under the Hood (Simplified)

Let's look at a slightly simplified view of what happens when you call `Navigator.push` with a `PageRoute`:

```mermaid
sequenceDiagram
    participant Button as Button Widget
    participant HomeScreen as HomeScreen Widget
    participant Navigator as Navigator
    participant PageRoute as PageRouteBuilder
    participant NewScreen as NewScreen Widget

    Button->HomeScreen: calls onPressed
    HomeScreen->Navigator: calls push(context, PageRoute)
    Navigator->PageRoute: asks for the page content and transitions
    PageRoute->PageRoute: uses pageBuilder to create NewScreen widget
    PageRoute->PageRoute: uses transitionsBuilder to wrap NewScreen with transition widgets
    Navigator->Navigator: Prepares
    Navigator->NewScreen: Builds and animates the transition
```

Essentially, the `Navigator` is like the conductor of an orchestra. You hand it a `PageRoute`, and it orchestrates the process of showing the new screen, including running the transitions defined by the `PageRoute`.

Inside the Flutter framework code for `PageRoute` (like in `packages/flutter/lib/src/widgets/pages.dart`), you'll find methods like `buildPage` and `buildTransitions`. These are the core parts that `PageRouteBuilder` uses its functions (`pageBuilder` and `transitionsBuilder`) to implement:

```dart
// Simplified example from PageRoute (similar to what PageRouteBuilder does internally)
abstract class PageRoute<T> extends ModalRoute<T> {
  // ... other properties ...

  // The PageRoute needs to know how to build the main content
  Widget buildPage(BuildContext context, Animation<double> animation, Animation<double> secondaryAnimation);

  // The PageRoute needs to know how to build the transitions
  Widget buildTransitions(BuildContext context, Animation<double> animation, Animation<double> secondaryAnimation, Widget child);

  // ... more methods for duration, color, etc. ...
}
```

`PageRouteBuilder` fills in these `buildPage` and `buildTransitions` methods using the functions you provide.

### Conclusion

In this chapter, we learned that a `PageRoute` is the fundamental concept in Flutter navigation that defines how a new screen is presented. We saw how to use `PageRouteBuilder` to create a simple `PageRoute` by specifying what the new screen looks like and how the transition should appear.

While `PageRouteBuilder` is great for simple custom transitions, Flutter provides pre-built `PageRoute` implementations for common design patterns, like the Material Design page transitions and the Cupertino (iOS) page transitions. These include standard animations and behaviors.

In the next chapter, we'll dive into one of these standard implementations: [MaterialPageRoute](02_materialpageroute_.md), which provides the familiar animations you see in Android apps.

[Next Chapter: MaterialPageRoute](02_materialpageroute_.md)
---
# Chapter 2: MaterialPageRoute

Welcome back! In [Chapter 1: PageRoute](01_pageroute_.md), we learned that a `PageRoute` is the blueprint for displaying a new screen and defining its transition. We saw how `PageRouteBuilder` let us create custom routes with animations.

Now, let's explore a really common and useful type of `PageRoute` used in Flutter apps that follow Google's Material Design: the `MaterialPageRoute`.

### What is MaterialPageRoute?

If you've ever used an Android phone, you've likely seen specific ways new screens appear when you tap something – often, they fade in and zoom slightly. `MaterialPageRoute` is designed to give you that native Android look and feel for your screen transitions, *automatically*.

Think of it as a pre-made `PageRoute` specifically built for Material Design. Instead of defining the fade/zoom transition yourself with `PageRouteBuilder`, `MaterialPageRoute` handles it for you.

But here's a cool trick: `MaterialPageRoute` is also platform-adaptive! This means that if you run your app on an iOS device, it will automatically use the standard iOS slide-from-the-right transition. You get the right native feel on both Android and iOS with just one `MaterialPageRoute`!

**Motivation:** We want to navigate from our `HomeScreen` to our `NewScreen` using the standard Material Design (Android-style) transitions on Android and the standard Cupertino (iOS-style) transitions on iOS, without manually building the transition animation ourselves.

### Using MaterialPageRoute

Using `MaterialPageRoute` is much simpler than `PageRouteBuilder` for standard transitions. You just need to tell it *what* screen to build.

Let's go back to our
`HomeScreen` button's `onPressed` and replace the `PageRouteBuilder` with a `MaterialPageRoute`:

```dart
// ... inside HomeScreen onPressed ...
onPressed: () {
  Navigator.push(
    context,
    MaterialPageRoute( // Using MaterialPageRoute!
      builder: (context) {
        // Just provide the widget for the new screen
        return NewScreen();
      },
    ),
  );
},
// ... rest of HomeScreen ...
```

That's it! Notice how much simpler it is?

*   We still use `Navigator.push` to initiate the navigation.
*   We create a `MaterialPageRoute` instance.
*   We provide a `builder` function, which is similar to `pageBuilder` in `PageRouteBuilder`. This function simply returns the widget for the new screen (`NewScreen`).
*   We *don't* need to specify a `transitionsBuilder` or `transitionDuration` explicitly. `MaterialPageRoute` uses default ones suitable for Material Design, chosen automatically based on the device's operating system.

Now, when you tap the button:
*   On an Android device, `NewScreen` will fade in and slightly zoom.
*   On an iOS device, `NewScreen` will slide in from the right.

### How it Works Under the Hood (Simplified)

When you use `MaterialPageRoute`, like with any `PageRoute`, you hand it to the `Navigator`.

```mermaid
sequenceDiagram
    participant Button as Button Widget
    participant HomeScreen as HomeScreen Widget
    participant Navigator as Navigator
    participant MaterialPageRoute as MaterialPageRoute
    participant NewScreen as NewScreen Widget
    participant Theme as Theme Data

    Button->HomeScreen: calls onPressed
    HomeScreen->Navigator: calls push(context, MaterialPageRoute)
    Navigator->MaterialPageRoute: asks for page content and transitions
    MaterialPageRoute->MaterialPageRoute: calls builder() to create NewScreen widget
    MaterialPageRoute->Theme: checks current platform (Android/iOS)
    MaterialPageRoute->MaterialPageRoute: selects relevant transition based on platform
    MaterialPageRoute->NewScreen: Builds and wraps with selected transition widgets
    Navigator->Navigator: Prepares
    Navigator->NewScreen: Animates the transition
```

The key difference from using `PageRouteBuilder` with a custom fade is that `MaterialPageRoute` internally checks the theme and the platform to pick the right animation blueprint.

Let's peek into the Flutter framework code for `MaterialPageRoute` in `packages/flutter/lib/src/material/page.dart`.

You'll see the `MaterialPageRoute` class definition inherits from `PageRoute` and also uses something called `MaterialRouteTransitionMixin` (we'll talk about mixins more later, but for now, think of it as sharing helpful code).

```dart
// Simplified from packages/flutter/lib/src/material/page.dart
class MaterialPageRoute<T> extends PageRoute<T> with MaterialRouteTransitionMixin<T> {
  // ... constructor and other properties ...

  /// Builds the primary contents of the route.
  final WidgetBuilder builder; // This holds the function you passed in!

  @override
  Widget buildContent(BuildContext context) => builder(context); // Uses your builder

  // ... other overrides ...
}
```

The `buildContent` method is where your `builder` function is called to create the `NewScreen` widget.

Where does the platform-adaptive transition logic come from? It's mostly handled by the `MaterialRouteTransitionMixin` and interacts with Flutter's `Theme` and `PageTransitionsTheme`.

```dart
// Simplified/conceptual example from MaterialRouteTransitionMixin
mixin MaterialRouteTransitionMixin<T> on PageRoute<T> {
  // ... other properties ...

  @override
  Widget buildTransitions( // This is where the transition is built!
    BuildContext context,
    Animation<double> animation,
    Animation<double> secondaryAnimation,
    Widget child, // This 'child' is the widget from buildContent (your NewScreen)
  ) {
    // Internally looks at Theme.of(context).platform (Android or iOS)
    // Then looks up the correct transition from Theme.of(context).pageTransitionsTheme
    // Returns the correct transition widget (like a FadeTransition for Android,
    // or a SlideTransition for iOS) wrapping the 'child' (your screen).
    final PageTransitionsTheme theme = Theme.of(context).pageTransitionsTheme;
    return theme.buildTransitions<T>(this, context, animation, secondaryAnimation, child);
  }

  // ... other properties like transitionDuration ...
}
```

So, `MaterialPageRoute` uses the `builder` you provide to show the content and relies on the `MaterialRouteTransitionMixin` (and Flutter's theming system) to automatically select and apply the right transition animation based on the device's platform.

### Conclusion

`MaterialPageRoute` is your go-to `PageRoute` when you want standard Material Design page transitions (fade/zoom on Android, slide on iOS) without needing to manually define the animations. It simplifies the process of creating new routes by providing sensible defaults that match platform conventions. It's a foundational component for navigation in many Flutter applications.

In the next chapter, we'll take a brief look at the `MaterialRouteTransitionMixin` itself, which is the piece that provides the magic platform-adaptive transitions for `MaterialPageRoute`.

[Next Chapter: MaterialRouteTransitionMixin](03_materialroutetransitionmixin_.md)

Relevant Code Snippets (Code itself remains unchanged):
--- File: packages/flutter/lib/src/material/page.dart ---
// Copyright 2014 The Flutter Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

import 'package:flutter/cupertino.dart';

import 'page_transitions_theme.dart';
import 'theme.dart';

/// A modal route that replaces the entire screen with a platform-adaptive
/// transition.
///
/// {@macro flutter.material.materialRouteTransitionMixin}
///
/// By default, when a modal route is replaced by another, the previous route
/// remains in memory. To free all the resources when this is not necessary, set
/// [maintainState] to false.
///
/// The `fullscreenDialog` property specifies whether the incoming route is a
/// fullscreen modal dialog. On iOS, those routes animate from the bottom to the
/// top rather than horizontally.
///
/// If `barrierDismissible` is true, then pressing the escape key on the keyboard
/// will cause the current route to be popped with null as the value.
///
/// The type `T` specifies the return type of the route which can be supplied as
/// the route is popped from the stack via [Navigator.pop] by providing the
/// optional `result` argument.
///
/// See also:
///
///  * [MaterialRouteTransitionMixin], which provides the material transition
///    for this route.
///  * [MaterialPage], which is a [Page] of this class.
class MaterialPageRoute<T> extends PageRoute<T> with MaterialRouteTransitionMixin<T> {
  /// Construct a MaterialPageRoute whose contents are defined by [builder].
  MaterialPageRoute({
    required this.builder,
    super.settings,
    super.requestFocus,
    this.maintainState = true,
    super.fullscreenDialog,
    super.allowSnapshotting = true,
    super.barrierDismissible = false,
  }) {
    assert(opaque);
  }

  /// Builds the primary contents of the route.
  final WidgetBuilder builder;

  @override
  Widget buildContent(BuildContext context) => builder(context);

  @override
  final bool maintainState;

  @override
  String get debugLabel => '${super.debugLabel}(${settings.name})';
}

/// A mixin that provides platform-adaptive transitions for a [PageRoute].
///
/// {@template flutter.material.materialRouteTransitionMixin}
/// For Android, the entrance transition for the page zooms in and fades in
/// while the exiting page zooms out and fades out. The exit transition is similar,
/// but in reverse.
///
/// For iOS, the page slides in from the right and exits in reverse. The page
/// also shifts to the left in parallax when another page enters to cover it.
/// (These directions are flipped in environments with a right-to-left reading
/// direction.)
/// {@endtemplate}
///
/// See also:
///
///  * [PageTransitionsTheme], which defines the default page transitions used
///    by the [MaterialRouteTransitionMixin.buildTransitions].
///  * [ZoomPageTransitionsBuilder], which is the default page transition used
///    by the [PageTransitionsTheme].
///  * [CupertinoPageTransitionsBuilder], which is the default page transition
///    for iOS and macOS.
mixin MaterialRouteTransitionMixin<T> on PageRoute<T> {
  /// Builds the primary contents of the route.
  @protected
  Widget buildContent(BuildContext context);

  @override
  Duration get transitionDuration =>
      _getPageTransitionBuilder(navigator!.context)?.transitionDuration ??
      const Duration(microseconds: 300);

  @override
  Duration get reverseTransitionDuration =>
      _getPageTransitionBuilder(navigator!.context)?.reverseTransitionDuration ??
      const Duration(microseconds: 300);

  PageTransitionsBuilder? _getPageTransitionBuilder(BuildContext context) {
    final TargetPlatform platform = Theme.of(context).platform;
    final PageTransitionsTheme pageTransitionsTheme = Theme.of(context).pageTransitionsTheme;
    return pageTransitionsTheme.builders[platform];
  }

  // The transitionDuration is used to create the AnimationController which is only
  // built once, so when page transition builder is updated and transitionDuration
  // has a new value, the AnimationController cannot be updated automatically. So we
  // manually update its duration here.
  // TODO(quncCccccc): Clean up this override method when controller can be updated as the transitionDuration is changed.
  @override
  TickerFuture didPush() {
    controller?.duration = transitionDuration;
    return super.didPush();
  }

  // The reverseTransitionDuration is used to create the AnimationController
  // which is only built once, so when page transition builder is updated and
  // reverseTransitionDuration has a new value, the AnimationController cannot
  // be updated automatically. So we manually update its reverseDuration here.
  // TODO(quncCccccc): Clean up this override method when controller can beupdated as the reverseTransitionDuration is changed.
  @override
  bool didPop(T? result) {
    controller?.reverseDuration = reverseTransitionDuration;
    return super.didPop(result);
  }

  @override
  Color? get barrierColor => null;

  @override
  String? get barrierLabel => null;

  @override
  DelegatedTransitionBuilder? get delegatedTransition => _delegatedTransition;

  static Widget? _delegatedTransition(
    BuildContext context,
    Animation<double> animation,
    Animation<double> secondaryAnimation,
    bool allowSnapshotting,
    Widget? child,
  ) {
    final PageTransitionsTheme theme = Theme.of(context).pageTransitionsTheme;
    final TargetPlatform platform = Theme.of(context).platform;
    final DelegatedTransitionBuilder? themeDelegatedTransition = theme.delegatedTransition(
      platform,
    );
    return themeDelegatedTransition != null
        ? themeDelegatedTransition(context, animation, secondaryAnimation, allowSnapshotting, child)
        : null;
  }

  @override
  bool canTransitionTo(TransitionRoute<dynamic> nextRoute) {
    // Don't perform outgoing animation if the next route is a fullscreen dialog,
    // or there is no matching transition to use.
    // Don't perform outgoing animation if the next route is a fullscreen dialog.
    final bool nextRouteIsNotFullscreen =
        (nextRoute is! PageRoute<T>) || !nextRoute.fullscreenDialog;

    // If the next route has a delegated transition, then this route is able to
    // use that delegated transition to smoothly sync with the next route's
    // transition.
    final bool nextRouteHasDelegatedTransition =
        nextRoute is ModalRoute<T> && nextRoute.delegatedTransition != null;

    // Otherwise if the next route has the same route transition mixin as this
    // one, then this route will already be synced with its transition.
    return nextRouteIsNotFullscreen &&
        ((nextRoute is MaterialRouteTransitionMixin) || nextRouteHasDelegatedTransition);
  }

  @override
  bool canTransitionFrom(TransitionRoute<dynamic> previousRoute) {
    // Supress previous route from transitioning if this is a fullscreenDialog route.
    return previousRoute is PageRoute && !fullscreenDialog;
  }

  @override
  Widget buildPage(
    BuildContext context,
    Animation<double> animation,
    Animation<double> secondaryAnimation,
  ) {
    final Widget result = buildContent(context);
    return Semantics(scopesRoute: true, explicitChildNodes: true, child: result);
  }

  @override
  Widget buildTransitions(
    BuildContext context,
    Animation<double> animation,
    Animation<double> secondaryAnimation,
    Widget child,
  ) {
    final PageTransitionsTheme theme = Theme.of(context).pageTransitionsTheme;
    return theme.buildTransitions<T>(this, context, animation, secondaryAnimation, child);
  }
}

/// A page that creates a material style [PageRoute].
///
/// {@macro flutter.material.materialRouteTransitionMixin}
///
/// By default, when the created route is replaced by another, the previous
/// route remains in memory. To free all the resources when this is not
/// necessary, set [maintainState] to false.
///
/// The `fullscreenDialog` property specifies whether the created route is a
/// fullscreen modal dialog. On iOS, those routes animate from the bottom to the
/// top rather than horizontally.
///
/// The type `T` specifies the return type of the route which can be supplied as
/// the route is popped from the stack via [Navigator.transitionDelegate] by
/// providing the optional `result` argument to the
/// [RouteTransitionRecord.markForPop] in the [TransitionDelegate.resolve].
///
/// See also:
///
///  * [MaterialPageRoute], which is the [PageRoute] version of this class
class MaterialPage<T> extends Page<T> {
  /// Creates a material page.
  const MaterialPage({
    required this.child,
    this.maintainState = true,
    this.fullscreenDialog = false,
    this.allowSnapshotting = true,
    super.key,
    super.canPop,
    super.onPopInvoked,
    super.name,
    super.arguments,
    super.restorationId,
  });

  /// The content to be shown in the [Route] created by this page.
  final Widget child;

  /// {@macro flutter.widgets.ModalRoute.maintainState}
  final bool maintainState;

  /// {@macro flutter.widgets.PageRoute.fullscreenDialog}
  final bool fullscreenDialog;

  /// {@macro flutter.widgets.TransitionRoute.allowSnapshotting}
  final bool allowSnapshotting;

  @override
  Route<T> createRoute(BuildContext context) {
    return _PageBasedMaterialPageRoute<T>(page: this, allowSnapshotting: allowSnapshotting);
  }
}

// A page-based version of MaterialPageRoute.
//
// This route uses the builder from the page to build its content. This ensures
// the content is up to date after page updates.
class _PageBasedMaterialPageRoute<T> extends PageRoute<T> with MaterialRouteTransitionMixin<T> {
  _PageBasedMaterialPageRoute({required MaterialPage<T> page, super.allowSnapshotting})
    : super(settings: page) {
    assert(opaque);
  }

  MaterialPage<T> get _page => settings as MaterialPage<T>;

  @override
  Widget buildContent(BuildContext context) {
    return _page.child;
  }

  @override
  bool get maintainState => _page.maintainState;

  @override
  bool get fullscreenDialog => _page.fullscreenDialog;

  @override
  String get debugLabel => '${super.debugLabel}(${_page.name})';
}


Instructions for the chapter (Generate content in English unless specified otherwise):
- Start with a clear heading (e.g., `# Chapter 3: MaterialRouteTransitionMixin
`). Use the provided concept name.

- If this is not the first chapter, begin with a brief transition from the previous chapter, referencing it with a proper Markdown link using its name.

- Begin with a high-level motivation explaining what problem this abstraction solves. Start with a central use case as a concrete example. The whole chapter should guide the reader to understand how to solve this use case. Make it very minimal and friendly to beginners.

- If the abstraction is complex, break it down into key concepts. Explain each concept one-by-one in a very beginner-friendly way.

- Explain how to use this abstraction to solve the use case. Give example inputs and outputs for code snippets (if the output isn't values, describe at a high level what will happen).

- Each code block should be BELOW 10 lines! If longer code blocks are needed, break them down into smaller pieces and walk through them one-by-one. Aggresively simplify the code to make it minimal. Use comments to skip non-important implementation details. Each code block should have a beginner friendly explanation right after it.

- Describe the internal implementation to help understand what's under the hood. First provide a non-code or code-light walkthrough on what happens step-by-step when the abstraction is called. It's recommended to use a simple sequenceDiagram with a dummy example - keep it minimal with at most 5 participants to ensure clarity. If participant name has space, use: `participant QP as Query Processing`. .

- Then dive deeper into code for the internal implementation with references to files. Provide example code blocks, but make them similarly simple and beginner-friendly. Explain.

- IMPORTANT: When you need to refer to other core abstractions covered in other chapters, ALWAYS use proper Markdown links like this: [Chapter Title](filename.md). Use the Complete Tutorial Structure above to find the correct filename and the chapter title. Translate the surrounding text.

- Use mermaid diagrams to illustrate complex concepts (```mermaid``` format). .

- Heavily use analogies and examples throughout to help beginners understand.

- End the chapter with a brief conclusion that summarizes what was learned and provides a transition to the next chapter. If there is a next chapter, use a proper Markdown link: [Next Chapter Title](next_chapter_filename).

- Ensure the tone is welcoming and easy for a newcomer to understand.

- Output *only* the Markdown content for this chapter.

Now, directly provide a super beginner-friendly Markdown output (DON'T need ```markdown``` tags):

2025-05-21 12:32:11,811 - INFO - RESPONSE: # Chapter 3: MaterialRouteTransitionMixin

Welcome back! In [Chapter 2: MaterialPageRoute](02_materialpageroute_.md), we learned how `MaterialPageRoute` gives us those sweet, platform-adaptive screen transitions (fade/zoom on Android, slide on iOS) without us having to code the animations ourselves.

We briefly saw that the code for `MaterialPageRoute` includes something called `with MaterialRouteTransitionMixin`. This chapter is about that `MaterialRouteTransitionMixin`.

### What is MaterialRouteTransitionMixin?

Imagine you have a recipe for delicious cookies. The recipe lists all the ingredients and the steps. A "mixin" in Flutter is like a list of extra ingredients and techniques you can add to your recipe to make it special.

`MaterialRouteTransitionMixin` is not a complete recipe (it's not a full `PageRoute` itself), but it's a collection of "ingredients" and "techniques" specifically for creating **Material Design page transitions** that adapt to the platform.

It provides the core logic for:

1.  **How long** the transition should take (duration).
2.  **How the animation looks** (the transition effect itself, like fading or sliding).
3.  **How this route interacts** with other routes during transitions (can they transition together smoothly?).

Essentially, `MaterialRouteTransitionMixin` is the helper that `MaterialPageRoute` uses to get its standard, platform-adaptive transition behavior. It's what makes `MaterialPageRoute` special!

You won't usually create a `MaterialRouteTransitionMixin` directly. Instead, you'll see other `PageRoute` implementations (like `MaterialPageRoute`) "mix it in" to gain its transition capabilities.

**Motivation:** Our goal is to understand where the automatic, platform-adaptive transition logic in `MaterialPageRoute` comes from. It comes from `MaterialRouteTransitionMixin`.

### How Mixins Work (Simply)

Think of a mixin as a way to share code between different classes without using traditional inheritance (like a child class inheriting from a parent class).

If you have `ClassA` and `MixinB`, `ClassA` can use `MixinB`'s methods and properties by saying `class ClassA with MixinB`. It's like `ClassA` is adding `MixinB`'s features to itself.

In our case, `MaterialPageRoute` is a class, and it uses `MaterialRouteTransitionMixin` like this:

```dart
// Simplified
class MaterialPageRoute<T> extends PageRoute<T> with MaterialRouteTransitionMixin<T> {
  // MaterialPageRoute now has access to the methods inside MaterialRouteTransitionMixin
  // ... rest of MaterialPageRoute code ...
}
```

By using `with MaterialRouteTransitionMixin`, `MaterialPageRoute` automatically gains the `buildTransitions` method and other transition-related logic defined within the mixin.

### How it Connects to Building Transitions

Remember in [Chapter 1: PageRoute](01_pageroute_.md), we saw that a `PageRoute` needs to implement a `buildTransitions` method to define how the animation looks?

`MaterialRouteTransitionMixin` provides the **implementation** for this crucial `buildTransitions` method for Material Design transitions.

When `Navigator.push` is called with a `MaterialPageRoute`, the Navigator asks the `MaterialPageRoute` (which uses `MaterialRouteTransitionMixin`'s logic) to build the transition widget tree.

Here's a look inside the mixin (simplified):

```dart
// Simplified/conceptual example from packages/flutter/lib/src/material/page.dart
mixin MaterialRouteTransitionMixin<T> on PageRoute<T> {
  // ... other properties like transitionDuration ...

  @override
  Widget buildTransitions( // This method is provided by the mixin!
    BuildContext context,
    Animation<double> animation, // Animation for the incoming page
    Animation<double> secondaryAnimation, // Animation for the outgoing page
    Widget child, // The actual content of the page (your NewScreen)
  ) {
    // Inside here, the mixin's code runs.
    // It checks the platform (Android/iOS) using Theme.of(context).platform.
    // It looks up the correct transition animation based on the platform
    // from the PageTransitionsTheme.
    // It returns the chosen animation widget (like FadeTransition or SlideTransition)
    // wrapping the 'child' (your NewScreen widget).

    // This line is the core – it asks the Theme for the right transition!
    final PageTransitionsTheme theme = Theme.of(context).pageTransitionsTheme;
    return theme.buildTransitions<T>(this, context, animation, secondaryAnimation, child);
  }

  // ... other methods ...
}
```

So, `MaterialRouteTransitionMixin` contains the `buildTransitions` method that looks at the current `Theme` (which knows the platform) and asks the `PageTransitionsTheme` within the `Theme` to provide the actual transition widget code.

This design is clever because:
*   `MaterialPageRoute` handles knowing *what* screen to show (`builder`).
*   `MaterialRouteTransitionMixin` handles knowing *how* to transition, querying the `Theme` for the platform-specific implementation.
*   The `PageTransitionsTheme` holds the actual animation builders (like the code for the fade/zoom or the slide animations).

This separation of concerns makes the code more organized and maintainable!

### You Don't Use It Directly (Usually)

As a beginner, you won't typically need to directly use `MaterialRouteTransitionMixin`. Its purpose is to provide the transition logic *to* classes like `MaterialPageRoute`. When you use `MaterialPageRoute`, you are indirectly benefiting from the code in `MaterialRouteTransitionMixin`.

Think of it like buying a car. You use the steering wheel and pedals (`MaterialPageRoute`), and the engine ("mixin") makes it go, but you don't interact directly with the engine parts every time you drive.

### Conclusion

`MaterialRouteTransitionMixin` is a key piece of the puzzle behind `MaterialPageRoute`'s automatic, platform-adaptive transitions. It provides the core logic for determining transition duration and building the correct transition animation based on the device's operating system by interacting with the Flutter `Theme` system. While you won't often use it directly, understanding its role helps clarify how `MaterialPageRoute` works.

In the next chapter, we'll shift our focus to the iOS side of things and introduce `CupertinoPageRoute`, which is the counterpart to `MaterialPageRoute` for Cupertino (iOS) design.

[Next Chapter: CupertinoPageRoute](04_cupertinopageroute_.md)
2025-05-21 12:32:11,818 - INFO - PROMPT: 
Write a very beginner-friendly tutorial chapter (in Markdown format) for the project `flutter` about the concept: "CupertinoPageRoute
". This is Chapter 4.

Concept Details:
- Name: CupertinoPageRoute

- Description:
Building on the `PageRoute` concept, a `CupertinoPageRoute` is specifically designed for apps that look and feel like they belong on Apple's iOS devices. It uses the characteristic sliding transitions from the right and other iOS visual cues when you move between screens. It's like a specialized "iOS-style" blueprint for navigating between pages.


Complete Tutorial Structure:
1. [PageRoute
](01_pageroute_.md)
2. [MaterialPageRoute
](02_materialpageroute_.md)
3. [MaterialRouteTransitionMixin
](03_materialroutetransitionmixin_.md)
4. [CupertinoPageRoute
](04_cupertinopageroute_.md)
5. [CupertinoRouteTransitionMixin
](05_cupertinoroutetransitionmixin_.md)
6. [CupertinoPageTransition
](06_cupertinopagetransition_.md)
7. [CupertinoFullscreenDialogTransition
](07_cupertinofullscreendialogtransition_.md)
8. [CupertinoModalPopupRoute
](08_cupertinomodalpopuproute_.md)
9. [CupertinoDialogRoute
](09_cupertinodialogroute_.md)

Context from previous chapters:
# Chapter 1: PageRoute

Welcome to the first chapter of our Flutter navigation tutorial! Ever wonder how tapping a button in an app seamlessly takes you to a completely different screen? That's where the magic of navigation comes in! In Flutter, a core concept for managing these screen transitions is the `PageRoute`.

Imagine your Flutter app is like a building with many rooms (screens). When you want to go from one room (the "lobby") to another room (the "settings" screen), you need a plan or a map to get there. A `PageRoute` is exactly that – it's the blueprint, the plan, for a single "page" or screen in your app and how you would transition *to* it.

Think of it as defining:

*   **What the new screen looks like:** What widgets make up this new page?
*   **How the transition happens:** Does it slide from the side, fade in, or something else?
*   **How long the transition takes:** Is it a quick change or a smooth, longer one?
*   **Its behavior:** Can you easily "go back" or dismiss this screen?

The `PageRoute` doesn't *perform* the transition itself; it tells the `Navigator` (Flutter's system for managing screen stacks, like stacking rooms on top of each other) *how* to perform the transition to display its content.

### Our Goal: Showing a Simple New Screen

Throughout this chapter, our goal is to understand enough about `PageRoute` to accomplish a very common task: navigating from one simple screen to another.

Let's start with a basic example. We'll have a main screen with a button. When you tap the button, we want to go to a new, blank screen.

Here's a simplified look at what we might have initially:

```dart
import 'package:flutter/material.dart';

void main() {
  runApp(MyApp());
}

class MyApp extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return MaterialApp(
      home: HomeScreen(),
    );
  }
}

class HomeScreen extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(title: Text('Home Screen')),
      body: Center(
        child: ElevatedButton(
          onPressed: () {
            // We want to go to a new screen here!
          },
          child: Text('Go to New Screen'),
        ),
      ),
    );
  }
}

class NewScreen extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(title: Text('New Screen')),
      body: Center(
        child: Text('Welcome to the new screen!'),
      ),
    );
  }
}
```

In this code, we have `HomeScreen` and `NewScreen`. Our challenge is to connect the button on `HomeScreen` to show `NewScreen`. We need a `PageRoute` for `NewScreen`.

### Understanding PageRoute with PageRouteBuilder

Directly creating a raw `PageRoute` can be a bit advanced for our first step. Flutter provides a helpful class called `PageRouteBuilder` which lets us create a simple `PageRoute` using functions (callbacks). This is perfect for defining basic routes without creating a whole new class.

Let's look at how we can use `PageRouteBuilder` inside the `onPressed` of our `ElevatedButton`:

```dart
// ... inside HomeScreen onPressed ...
onPressed: () {
  Navigator.push(
    context,
    PageRouteBuilder( // Using PageRouteBuilder to define our route
      pageBuilder: (context, animation, secondaryAnimation) {
        // This function builds the actual screen content
        return NewScreen();
      },
      transitionsBuilder: (context, animation, secondaryAnimation, child) {
        // This function defines how the transition looks
        // For now, we'll do a simple fade transition as an example
        return FadeTransition(
          opacity: animation, // Controls the opacity of the new page
          child: child,
        );
      },
      transitionDuration: Duration(milliseconds: 500), // How long the transition takes
    ),
  );
},
// ... rest of HomeScreen ...
```

Let's break down what's happening here:

1.  **`Navigator.push(context, ...)`**: This is how we tell Flutter's navigation system to add a new screen on top of the current one. `context` tells the Navigator where we are in the widget tree.
2.  **`PageRouteBuilder(...)`**: We create an instance of `PageRouteBuilder` to define the characteristics of the new route.
3.  **`pageBuilder: (context, animation, secondaryAnimation) { return NewScreen(); }`**: This is a required function that `PageRouteBuilder` needs. It tells the builder *what* widget tree to display for this page. In our case, it's just our `NewScreen` widget. The `animation` and `secondaryAnimation` parameters are for transition animations, which we'll use in the next part.
4.  **`transitionsBuilder: (context, animation, secondaryAnimation, child) { ... }`**: This optional function defines how the transition *looks*. It takes the context, `animation` (for the incoming page), `secondaryAnimation` (for the outgoing page), and the `child` (which is the widget built by `pageBuilder`). We use a `FadeTransition` here, animating the `opacity` of the incoming page using the `animation` provided.
5.  **`transitionDuration: Duration(milliseconds: 500)`**: This sets how long the transition animation should take.

Now, when you tap the button, the `Navigator` will use this `PageRouteBuilder` to create a `PageRoute`, push it onto the navigation stack, and animate to the `NewScreen` using a 500ms fade effect.

### How it Works Under the Hood (Simplified)

Let's look at a slightly simplified view of what happens when you call `Navigator.push` with a `PageRoute`:

```mermaid
sequenceDiagram
    participant Button as Button Widget
    participant HomeScreen as HomeScreen Widget
    participant Navigator as Navigator
    participant PageRoute as PageRouteBuilder
    participant NewScreen as NewScreen Widget

    Button->HomeScreen: calls onPressed
    HomeScreen->Navigator: calls push(context, PageRoute)
    Navigator->PageRoute: asks for the page content and transitions
    PageRoute->PageRoute: uses pageBuilder to create NewScreen widget
    PageRoute->PageRoute: uses transitionsBuilder to wrap NewScreen with transition widgets
    Navigator->Navigator: Prepares
    Navigator->NewScreen: Builds and animates the transition
```

Essentially, the `Navigator` is like the conductor of an orchestra. You hand it a `PageRoute`, and it orchestrates the process of showing the new screen, including running the transitions defined by the `PageRoute`.

Inside the Flutter framework code for `PageRoute` (like in `packages/flutter/lib/src/widgets/pages.dart`), you'll find methods like `buildPage` and `buildTransitions`. These are the core parts that `PageRouteBuilder` uses its functions (`pageBuilder` and `transitionsBuilder`) to implement:

```dart
// Simplified example from PageRoute (similar to what PageRouteBuilder does internally)
abstract class PageRoute<T> extends ModalRoute<T> {
  // ... other properties ...

  // The PageRoute needs to know how to build the main content
  Widget buildPage(BuildContext context, Animation<double> animation, Animation<double> secondaryAnimation);

  // The PageRoute needs to know how to build the transitions
  Widget buildTransitions(BuildContext context, Animation<double> animation, Animation<double> secondaryAnimation, Widget child);

  // ... more methods for duration, color, etc. ...
}
```

`PageRouteBuilder` fills in these `buildPage` and `buildTransitions` methods using the functions you provide.

### Conclusion

In this chapter, we learned that a `PageRoute` is the fundamental concept in Flutter navigation that defines how a new screen is presented. We saw how to use `PageRouteBuilder` to create a simple `PageRoute` by specifying what the new screen looks like and how the transition should appear.

While `PageRouteBuilder` is great for simple custom transitions, Flutter provides pre-built `PageRoute` implementations for common design patterns, like the Material Design page transitions and the Cupertino (iOS) page transitions. These include standard animations and behaviors.

In the next chapter, we'll dive into one of these standard implementations: [MaterialPageRoute](02_materialpageroute_.md), which provides the familiar animations you see in Android apps.

[Next Chapter: MaterialPageRoute](02_materialpageroute_.md)
---
# Chapter 2: MaterialPageRoute

Welcome back! In [Chapter 1: PageRoute](01_pageroute_.md), we learned that a `PageRoute` is the blueprint for displaying a new screen and defining its transition. We saw how `PageRouteBuilder` let us create custom routes with animations.

Now, let's explore a really common and useful type of `PageRoute` used in Flutter apps that follow Google's Material Design: the `MaterialPageRoute`.

### What is MaterialPageRoute?

If you've ever used an Android phone, you've likely seen specific ways new screens appear when you tap something – often, they fade in and zoom slightly. `MaterialPageRoute` is designed to give you that native Android look and feel for your screen transitions, *automatically*.

Think of it as a pre-made `PageRoute` specifically built for Material Design. Instead of defining the fade/zoom transition yourself with `PageRouteBuilder`, `MaterialPageRoute` handles it for you.

But here's a cool trick: `MaterialPageRoute` is also platform-adaptive! This means that if you run your app on an iOS device, it will automatically use the standard iOS slide-from-the-right transition. You get the right native feel on both Android and iOS with just one `MaterialPageRoute`!

**Motivation:** We want to navigate from our `HomeScreen` to our `NewScreen` using the standard Material Design (Android-style) transitions on Android and the standard Cupertino (iOS-style) transitions on iOS, without manually building the transition animation ourselves.

### Using MaterialPageRoute

Using `MaterialPageRoute` is much simpler than `PageRouteBuilder` for standard transitions. You just need to tell it *what* screen to build.

Let's go back to our
`HomeScreen` button's `onPressed` and replace the `PageRouteBuilder` with a `MaterialPageRoute`:

```dart
// ... inside HomeScreen onPressed ...
onPressed: () {
  Navigator.push(
    context,
    MaterialPageRoute( // Using MaterialPageRoute!
      builder: (context) {
        // Just provide the widget for the new screen
        return NewScreen();
      },
    ),
  );
},
// ... rest of HomeScreen ...
```

That's it! Notice how much simpler it is?

*   We still use `Navigator.push` to initiate the navigation.
*   We create a `MaterialPageRoute` instance.
*   We provide a `builder` function, which is similar to `pageBuilder` in `PageRouteBuilder`. This function simply returns the widget for the new screen (`NewScreen`).
*   We *don't* need to specify a `transitionsBuilder` or `transitionDuration` explicitly. `MaterialPageRoute` uses default ones suitable for Material Design, chosen automatically based on the device's operating system.

Now, when you tap the button:
*   On an Android device, `NewScreen` will fade in and slightly zoom.
*   On an iOS device, `NewScreen` will slide in from the right.

### How it Works Under the Hood (Simplified)

When you use `MaterialPageRoute`, like with any `PageRoute`, you hand it to the `Navigator`.

```mermaid
sequenceDiagram
    participant Button as Button Widget
    participant HomeScreen as HomeScreen Widget
    participant Navigator as Navigator
    participant MaterialPageRoute as MaterialPageRoute
    participant NewScreen as NewScreen Widget
    participant Theme as Theme Data

    Button->HomeScreen: calls onPressed
    HomeScreen->Navigator: calls push(context, MaterialPageRoute)
    Navigator->MaterialPageRoute: asks for page content and transitions
    MaterialPageRoute->MaterialPageRoute: calls builder() to create NewScreen widget
    MaterialPageRoute->Theme: checks current platform (Android/iOS)
    MaterialPageRoute->MaterialPageRoute: selects relevant transition based on platform
    MaterialPageRoute->NewScreen: Builds and wraps with selected transition widgets
    Navigator->Navigator: Prepares
    Navigator->NewScreen: Animates the transition
```

The key difference from using `PageRouteBuilder` with a custom fade is that `MaterialPageRoute` internally checks the theme and the platform to pick the right animation blueprint.

Let's peek into the Flutter framework code for `MaterialPageRoute` in `packages/flutter/lib/src/material/page.dart`.

You'll see the `MaterialPageRoute` class definition inherits from `PageRoute` and also uses something called `MaterialRouteTransitionMixin` (we'll talk about mixins more later, but for now, think of it as sharing helpful code).

```dart
// Simplified from packages/flutter/lib/src/material/page.dart
class MaterialPageRoute<T> extends PageRoute<T> with MaterialRouteTransitionMixin<T> {
  // ... constructor and other properties ...

  /// Builds the primary contents of the route.
  final WidgetBuilder builder; // This holds the function you passed in!

  @override
  Widget buildContent(BuildContext context) => builder(context); // Uses your builder

  // ... other overrides ...
}
```

The `buildContent` method is where your `builder` function is called to create the `NewScreen` widget.

Where does the platform-adaptive transition logic come from? It's mostly handled by the `MaterialRouteTransitionMixin` and interacts with Flutter's `Theme` and `PageTransitionsTheme`.

```dart
// Simplified/conceptual example from MaterialRouteTransitionMixin
mixin MaterialRouteTransitionMixin<T> on PageRoute<T> {
  // ... other properties ...

  @override
  Widget buildTransitions( // This is where the transition is built!
    BuildContext context,
    Animation<double> animation,
    Animation<double> secondaryAnimation,
    Widget child, // This 'child' is the widget from buildContent (your NewScreen)
  ) {
    // Internally looks at Theme.of(context).platform (Android or iOS)
    // Then looks up the correct transition from Theme.of(context).pageTransitionsTheme
    // Returns the correct transition widget (like a FadeTransition for Android,
    // or a SlideTransition for iOS) wrapping the 'child' (your screen).
    final PageTransitionsTheme theme = Theme.of(context).pageTransitionsTheme;
    return theme.buildTransitions<T>(this, context, animation, secondaryAnimation, child);
  }

  // ... other properties like transitionDuration ...
}
```

So, `MaterialPageRoute` uses the `builder` you provide to show the content and relies on the `MaterialRouteTransitionMixin` (and Flutter's theming system) to automatically select and apply the right transition animation based on the device's platform.

### Conclusion

`MaterialPageRoute` is your go-to `PageRoute` when you want standard Material Design page transitions (fade/zoom on Android, slide on iOS) without needing to manually define the animations. It simplifies the process of creating new routes by providing sensible defaults that match platform conventions. It's a foundational component for navigation in many Flutter applications.

In the next chapter, we'll take a brief look at the `MaterialRouteTransitionMixin` itself, which is the piece that provides the magic platform-adaptive transitions for `MaterialPageRoute`.

[Next Chapter: MaterialRouteTransitionMixin](03_materialroutetransitionmixin_.md)
---
# Chapter 3: MaterialRouteTransitionMixin

Welcome back! In [Chapter 2: MaterialPageRoute](02_materialpageroute_.md), we learned how `MaterialPageRoute` gives us those sweet, platform-adaptive screen transitions (fade/zoom on Android, slide on iOS) without us having to code the animations ourselves.

We briefly saw that the code for `MaterialPageRoute` includes something called `with MaterialRouteTransitionMixin`. This chapter is about that `MaterialRouteTransitionMixin`.

### What is MaterialRouteTransitionMixin?

Imagine you have a recipe for delicious cookies. The recipe lists all the ingredients and the steps. A "mixin" in Flutter is like a list of extra ingredients and techniques you can add to your recipe to make it special.

`MaterialRouteTransitionMixin` is not a complete recipe (it's not a full `PageRoute` itself), but it's a collection of "ingredients" and "techniques" specifically for creating **Material Design page transitions** that adapt to the platform.

It provides the core logic for:

1.  **How long** the transition should take (duration).
2.  **How the animation looks** (the transition effect itself, like fading or sliding).
3.  **How this route interacts** with other routes during transitions (can they transition together smoothly?).

Essentially, `MaterialRouteTransitionMixin` is the helper that `MaterialPageRoute` uses to get its standard, platform-adaptive transition behavior. It's what makes `MaterialPageRoute` special!

You won't usually create a `MaterialRouteTransitionMixin` directly. Instead, you'll see other `PageRoute` implementations (like `MaterialPageRoute`) "mix it in" to gain its transition capabilities.

**Motivation:** Our goal is to understand where the automatic, platform-adaptive transition logic in `MaterialPageRoute` comes from. It comes from `MaterialRouteTransitionMixin`.

### How Mixins Work (Simply)

Think of a mixin as a way to share code between different classes without using traditional inheritance (like a child class inheriting from a parent class).

If you have `ClassA` and `MixinB`, `ClassA` can use `MixinB`'s methods and properties by saying `class ClassA with MixinB`. It's like `ClassA` is adding `MixinB`'s features to itself.

In our case, `MaterialPageRoute` is a class, and it uses `MaterialRouteTransitionMixin` like this:

```dart
// Simplified
class MaterialPageRoute<T> extends PageRoute<T> with MaterialRouteTransitionMixin<T> {
  // MaterialPageRoute now has access to the methods inside MaterialRouteTransitionMixin
  // ... rest of MaterialPageRoute code ...
}
```

By using `with MaterialRouteTransitionMixin`, `MaterialPageRoute` automatically gains the `buildTransitions` method and other transition-related logic defined within the mixin.

### How it Connects to Building Transitions

Remember in [Chapter 1: PageRoute](01_pageroute_.md), we saw that a `PageRoute` needs to implement a `buildTransitions` method to define how the animation looks?

`MaterialRouteTransitionMixin` provides the **implementation** for this crucial `buildTransitions` method for Material Design transitions.

When `Navigator.push` is called with a `MaterialPageRoute`, the Navigator asks the `MaterialPageRoute` (which uses `MaterialRouteTransitionMixin`'s logic) to build the transition widget tree.

Here's a look inside the mixin (simplified):

```dart
// Simplified/conceptual example from packages/flutter/lib/src/material/page.dart
mixin MaterialRouteTransitionMixin<T> on PageRoute<T> {
  // ... other properties like transitionDuration ...

  @override
  Widget buildTransitions( // This method is provided by the mixin!
    BuildContext context,
    Animation<double> animation, // Animation for the incoming page
    Animation<double> secondaryAnimation, // Animation for the outgoing page
    Widget child, // The actual content of the page (your NewScreen)
  ) {
    // Inside here, the mixin's code runs.
    // It checks the platform (Android/iOS) using Theme.of(context).platform.
    // It looks up the correct transition animation based on the platform
    // from the PageTransitionsTheme.
    // It returns the chosen animation widget (like FadeTransition or SlideTransition)
    // wrapping the 'child' (your NewScreen widget).

    // This line is the core – it asks the Theme for the right transition!
    final PageTransitionsTheme theme = Theme.of(context).pageTransitionsTheme;
    return theme.buildTransitions<T>(this, context, animation, secondaryAnimation, child);
  }

  // ... other methods ...
}
```

So, `MaterialRouteTransitionMixin` contains the `buildTransitions` method that looks at the current `Theme` (which knows the platform) and asks the `PageTransitionsTheme` within the `Theme` to provide the actual transition widget code.

This design is clever because:
*   `MaterialPageRoute` handles knowing *what* screen to show (`builder`).
*   `MaterialRouteTransitionMixin` handles knowing *how* to transition, querying the `Theme` for the platform-specific implementation.
*   The `PageTransitionsTheme` holds the actual animation builders (like the code for the fade/zoom or the slide animations).

This separation of concerns makes the code more organized and maintainable!

### You Don't Use It Directly (Usually)

As a beginner, you won't typically need to directly use `MaterialRouteTransitionMixin`. Its purpose is to provide the transition logic *to* classes like `MaterialPageRoute`. When you use `MaterialPageRoute`, you are indirectly benefiting from the code in `MaterialRouteTransitionMixin`.

Think of it like buying a car. You use the steering wheel and pedals (`MaterialPageRoute`), and the engine ("mixin") makes it go, but you don't interact directly with the engine parts every time you drive.

### Conclusion

`MaterialRouteTransitionMixin` is a key piece of the puzzle behind `MaterialPageRoute`'s automatic, platform-adaptive transitions. It provides the core logic for determining transition duration and building the correct transition animation based on the device's operating system by interacting with the Flutter `Theme` system. While you won't often use it directly, understanding its role helps clarify how `MaterialPageRoute` works.

In the next chapter, we'll shift our focus to the iOS side of things and introduce `CupertinoPageRoute`, which is the counterpart to `MaterialPageRoute` for Cupertino (iOS) design.

[Next Chapter: CupertinoPageRoute](04_cupertinopageroute_.md)

Relevant Code Snippets (Code itself remains unchanged):
--- File: packages/flutter/lib/src/cupertino/route.dart ---
// Copyright 2014 The Flutter Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

/// @docImport 'dart:ui';
///
/// @docImport 'package:flutter/material.dart';
/// @docImport 'package:flutter/services.dart';
///
/// @docImport 'app.dart';
/// @docImport 'button.dart';
/// @docImport 'dialog.dart';
/// @docImport 'nav_bar.dart';
/// @docImport 'page_scaffold.dart';
/// @docImport 'tab_scaffold.dart';
library;

import 'dart:math';
import 'dart:ui' show ImageFilter;

import 'package:flutter/foundation.dart';
import 'package:flutter/gestures.dart';
import 'package:flutter/physics.dart';
import 'package:flutter/rendering.dart';
import 'package:flutter/widgets.dart';

import 'colors.dart';
import 'interface_level.dart';
import 'localizations.dart';

const double _kBackGestureWidth = 20.0;
const double _kMinFlingVelocity = 1.0; // Screen widths per second.

// The duration for a page to animate when the user releases it mid-swipe.
const Duration _kDroppedSwipePageAnimationDuration = Duration(milliseconds: 350);

/// Barrier color used for a barrier visible during transitions for Cupertino
/// page routes.
///
/// This barrier color is only used for full-screen page routes with
/// `fullscreenDialog: false`.
///
/// By default, `fullscreenDialog` Cupertino route transitions have no
/// `barrierColor`, and [CupertinoDialogRoute]s and [CupertinoModalPopupRoute]s
/// have a `barrierColor` defined by [kCupertinoModalBarrierColor].
///
/// A relatively rigorous eyeball estimation.
const Color _kCupertinoPageTransitionBarrierColor = Color(0x18000000);

/// Barrier color for a Cupertino modal barrier.
///
/// Extracted from https://developer.apple.com/design/resources/.
const Color kCupertinoModalBarrierColor = CupertinoDynamicColor.withBrightness(
  color: Color(0x33000000),
  darkColor: Color(0x7A000000),
);

// The duration of the transition used when a modal popup is shown.
const Duration _kModalPopupTransitionDuration = Duration(milliseconds: 335);

// Offset from offscreen to the right to fully on screen.
final Animatable<Offset> _kRightMiddleTween = Tween<Offset>(
  begin: const Offset(1.0, 0.0),
  end: Offset.zero,
);

// Offset from fully on screen to 1/3 offscreen to the left.
final Animatable<Offset> _kMiddleLeftTween = Tween<Offset>(
  begin: Offset.zero,
  end: const Offset(-1.0 / 3.0, 0.0),
);

// Offset from offscreen below to fully on screen.
final Animatable<Offset> _kBottomUpTween = Tween<Offset>(
  begin: const Offset(0.0, 1.0),
  end: Offset.zero,
);

/// A mixin that replaces the entire screen with an iOS transition for a
/// [PageRoute].
///
/// {@template flutter.cupertino.cupertinoRouteTransitionMixin}
/// The page slides in from the right and exits in reverse. The page also shifts
/// to the left in parallax when another page enters to cover it.
///
/// The page slides in from the bottom and exits in reverse with no parallax
/// effect for fullscreen dialogs.
/// {@endtemplate}
///
/// See also:
///
///  * [MaterialRouteTransitionMixin], which is a mixin that provides
///    platform-appropriate transitions for a [PageRoute].
///  * [CupertinoPageRoute], which is a [PageRoute] that leverages this mixin.
mixin CupertinoRouteTransitionMixin<T> on PageRoute<T> {
  /// Builds the primary contents of the route.
  @protected
  Widget buildContent(BuildContext context);

  /// {@template flutter.cupertino.CupertinoRouteTransitionMixin.title}
  /// A title string for this route.
  ///
  /// Used to auto-populate [CupertinoNavigationBar] and
  /// [CupertinoSliverNavigationBar]'s `middle`/`largeTitle` widgets when
  /// one is not manually supplied.
  /// {@endtemplate}
  String? get title;

  ValueNotifier<String?>? _previousTitle;

  /// The title string of the previous [CupertinoPageRoute].
  ///
  /// The [ValueListenable]'s value is readable after the route is installed
  /// onto a [Navigator]. The [ValueListenable] will also notify its listeners
  /// if the value changes (such as by replacing the previous route).
  ///
  /// The [ValueListenable] itself will be null before the route is installed.
  /// Its content value will be null if the previous route has no title or
  /// is not a [CupertinoPageRoute].
  ///
  /// See also:
  ///
  ///  * [ValueListenableBuilder], which can be used to listen and rebuild
  ///    widgets based on a ValueListenable.
  ValueListenable<String?> get previousTitle {
    assert(
      _previousTitle != null,
      'Cannot read the previousTitle for a route that has not yet been installed',
    );
    return _previousTitle!;
  }

  @override
  void dispose() {
    _previousTitle?.dispose();
    super.dispose();
  }

  @override
  void didChangePrevious(Route<dynamic>? previousRoute) {
    final String? previousTitleString =
        previousRoute is CupertinoRouteTransitionMixin ? previousRoute.title : null;
    if (_previousTitle == null) {
      _previousTitle = ValueNotifier<String?>(previousTitleString);
    } else {
      _previousTitle!.value = previousTitleString;
    }
    super.didChangePrevious(previousRoute);
  }

  @override
  // A relatively rigorous eyeball estimation.
  Duration get transitionDuration => const Duration(milliseconds: 500);

  @override
  Color? get barrierColor => fullscreenDialog ? null : _kCupertinoPageTransitionBarrierColor;

  @override
  String? get barrierLabel => null;

  @override
  bool canTransitionTo(TransitionRoute<dynamic> nextRoute) {
    // Don't perform outgoing animation if the next route is a fullscreen dialog.
    final bool nextRouteIsNotFullscreen =
        (nextRoute is! PageRoute<T>) || !nextRoute.fullscreenDialog;

    // If the next route has a delegated transition, then this route is able to
    // use that delegated transition to smoothly sync with the next route's
    // transition.
    final bool nextRouteHasDelegatedTransition =
        nextRoute is ModalRoute<T> && nextRoute.delegatedTransition != null;

    // Otherwise if the next route has the same route transition mixin as this
    // one, then this route will already be synced with its transition.
    return nextRouteIsNotFullscreen &&
        ((nextRoute is CupertinoRouteTransitionMixin) || nextRouteHasDelegatedTransition);
  }

  @override
  bool canTransitionFrom(TransitionRoute<dynamic> previousRoute) {
    // Supress previous route from transitioning if this is a fullscreenDialog route.
    return previousRoute is PageRoute && !fullscreenDialog;
  }

  @override
  Widget buildPage(
    BuildContext context,
    Animation<double> animation,
    Animation<double> secondaryAnimation,
  ) {
    final Widget child = buildContent(context);
    return Semantics(scopesRoute: true, explicitChildNodes: true, child: child);
  }

  // Called by _CupertinoBackGestureDetector when a pop ("back") drag start
  // gesture is detected. The returned controller handles all of the subsequent
  // drag events.
  static _CupertinoBackGestureController<T> _startPopGesture<T>(PageRoute<T> route) {
    assert(route.popGestureEnabled);

    return _CupertinoBackGestureController<T>(
      navigator: route.navigator!,
      getIsCurrent: () => route.isCurrent,
      getIsActive: () => route.isActive,
      controller: route.controller!, // protected access
    );
  }

  /// Returns a [CupertinoFullscreenDialogTransition] if [route] is a full
  /// screen dialog, otherwise a [CupertinoPageTransition] is returned.
  ///
  /// Used by [CupertinoPageRoute.buildTransitions].
  ///
  /// This method can be applied to any [PageRoute], not just
  /// [CupertinoPageRoute]. It's typically used to provide a Cupertino style
  /// horizontal transition for material widgets when the target platform
  /// is [TargetPlatform.iOS].
  ///
  /// See also:
  ///
  ///  * [CupertinoPageTransitionsBuilder], which uses this method to define a
  ///    [PageTransitionsBuilder] for the [PageTransitionsTheme].
  static Widget buildPageTransitions<T>(
    PageRoute<T> route,
    BuildContext context,
    Animation<double> animation,
    Animation<double> secondaryAnimation,
    Widget child,
  ) {
    // Check if the route has an animation that's currently participating
    // in a back swipe gesture.
    //
    // In the middle of a back gesture drag, let the transition be linear to
    // match finger motions.
    final bool linearTransition = route.popGestureInProgress;
    if (route.fullscreenDialog) {
      return CupertinoFullscreenDialogTransition(
        primaryRouteAnimation: animation,
        secondaryRouteAnimation: secondaryAnimation,
        linearTransition: linearTransition,
        child: child,
      );
    } else {
      return CupertinoPageTransition(
        primaryRouteAnimation: animation,
        secondaryRouteAnimation: secondaryAnimation,
        linearTransition: linearTransition,
        child: _CupertinoBackGestureDetector<T>(
          enabledCallback: () => route.popGestureEnabled,
          onStartPopGesture: () => _startPopGesture<T>(route),
          child: child,
        ),
      );
    }
  }

  @override
  Widget buildTransitions(
    BuildContext context,
    Animation<double> animation,
    Animation<double> secondaryAnimation,
    Widget child,
  ) {
    return buildPageTransitions<T>(this, context, animation, secondaryAnimation, child);
  }
}

/// A modal route that replaces the entire screen with an iOS transition.
///
/// {@macro flutter.cupertino.cupertinoRouteTransitionMixin}
///
/// By default, when a modal route is replaced by another, the previous route
/// remains in memory. To free all the resources when this is not necessary, set
/// [maintainState] to false.
///
/// The type `T` specifies the return type of the route which can be supplied as
/// the route is popped from the stack via [Navigator.pop] when an optional
/// `result` can be provided.
///
/// If `barrierDismissible` is true, then pressing the escape key on the keyboard
/// will cause the current route to be popped with null as the value.
///
/// See also:
///
///  * [CupertinoRouteTransitionMixin], for a mixin that provides iOS transition
///    for this modal route.
///  * [MaterialPageRoute], for an adaptive [PageRoute] that uses a
///    platform-appropriate transition.
///  * [CupertinoPageScaffold], for applications that have one page with a fixed
///    navigation bar on top.
///  * [CupertinoTabScaffold], for applications that have a tab bar at the
///    bottom with multiple pages.
///  * [CupertinoPage], for a [Page] version of this class.
class CupertinoPageRoute<T> extends PageRoute<T> with CupertinoRouteTransitionMixin<T> {
  /// Creates a page route for use in an iOS designed app.
  ///
  /// The [builder], [maintainState], and [fullscreenDialog] arguments must not
  /// be null.
  CupertinoPageRoute({
    required this.builder,
    this.title,
    super.settings,
    super.requestFocus,
    this.maintainState = true,
    super.fullscreenDialog,
    super.allowSnapshotting = true,
    super.barrierDismissible = false,
  }) {
    assert(opaque);
  }

  @override
  DelegatedTransitionBuilder? get delegatedTransition =>
      CupertinoPageTransition.delegatedTransition;

  /// Builds the primary contents of the route.
  final WidgetBuilder builder;

  @override
  Widget buildContent(BuildContext context) => builder(context);

  @override
  final String? title;

  @override
  final bool maintainState;

  @override
  String get debugLabel => '${super.debugLabel}(${settings.name})';
}

// A page-based version of CupertinoPageRoute.
//
// This route uses the builder from the page to build its content. This ensures
// the content is up to date after page updates.
class _PageBasedCupertinoPageRoute<T> extends PageRoute<T> with CupertinoRouteTransitionMixin<T> {
  _PageBasedCupertinoPageRoute({required CupertinoPage<T> page, super.allowSnapshotting = true})
    : super(settings: page) {
    assert(opaque);
  }

  @override
  DelegatedTransitionBuilder? get delegatedTransition =>
      this.fullscreenDialog ? null : CupertinoPageTransition.delegatedTransition;

  CupertinoPage<T> get _page => settings as CupertinoPage<T>;

  @override
  Widget buildContent(BuildContext context) => _page.child;

  @override
  String? get title => _page.title;

  @override
  bool get maintainState => _page.maintainState;

  @override
  bool get fullscreenDialog => _page.fullscreenDialog;

  @override
  String get debugLabel => '${super.debugLabel}(${_page.name})';
}

/// A page that creates a cupertino style [PageRoute].
///
/// {@macro flutter.cupertino.cupertinoRouteTransitionMixin}
///
/// By default, when a created modal route is replaced by another, the previous
/// route remains in memory. To free all the resources when this is not
/// necessary, set [maintainState] to false.
///
/// The type `T` specifies the return type of the route which can be supplied as
/// the route is popped from the stack via [Navigator.transitionDelegate] by
/// providing the optional `result` argument to the
/// [RouteTransitionRecord.markForPop] in the [TransitionDelegate.resolve].
///
/// See also:
///
///  * [CupertinoPageRoute], for a [PageRoute] version of this class.
class CupertinoPage<T> extends Page<T> {
  /// Creates a cupertino page.
  const CupertinoPage({
    required this.child,
    this.maintainState = true,
    this.title,
    this.fullscreenDialog = false,
    this.allowSnapshotting = true,
    super.canPop,
    super.onPopInvoked,
    super.key,
    super.name,
    super.arguments,
    super.restorationId,
  });

  /// The content to be shown in the [Route] created by this page.
  final Widget child;

  /// {@macro flutter.cupertino.CupertinoRouteTransitionMixin.title}
  final String? title;

  /// {@macro flutter.widgets.ModalRoute.maintainState}
  final bool maintainState;

  /// {@macro flutter.widgets.PageRoute.fullscreenDialog}
  final bool fullscreenDialog;

  /// {@macro flutter.widgets.TransitionRoute.allowSnapshotting}
  final bool allowSnapshotting;

  @override
  Route<T> createRoute(BuildContext context) {
    return _PageBasedCupertinoPageRoute<T>(page: this, allowSnapshotting: allowSnapshotting);
  }
}

/// Provides an iOS-style page transition animation.
///
/// The page slides in from the right and exits in reverse. It also shifts to the left in
/// a parallax motion when another page enters to cover it.
class CupertinoPageTransition extends StatefulWidget {
  /// Creates an iOS-style page transition.
  ///
  const CupertinoPageTransition({
    super.key,
    required this.primaryRouteAnimation,
    required this.secondaryRouteAnimation,
    required this.child,
    required this.linearTransition,
  });

  /// The widget below this widget in the tree.
  final Widget child;

  ///  * `primaryRouteAnimation` is a linear route animation from 0.0 to 1.0
  ///    when this screen is being pushed.
  final Animation<double> primaryRouteAnimation;

  ///  * `secondaryRouteAnimation` is a linear route animation from 0.0 to 1.0
  ///    when another screen is being pushed on top of this one.
  final Animation<double> secondaryRouteAnimation;

  ///  * `linearTransition` is whether to perform the transitions linearly.
  ///    Used to precisely track back gesture drags.
  final bool linearTransition;

  /// The Cupertino styled [DelegatedTransitionBuilder] provided to the previous
  /// route.
  ///
  /// {@macro flutter.widgets.delegatedTransition}
  static Widget? delegatedTransition(
    BuildContext context,
    Animation<double> animation,
    Animation<double> secondaryAnimation,
    bool allowSnapshotting,
    Widget? child,
  ) {
    final CurvedAnimation animation = CurvedAnimation(
      parent: secondaryAnimation,
      curve: Curves.linearToEaseOut,
      reverseCurve: Curves.easeInToLinear,
    );
    final Animation<Offset> delegatedPositionAnimation = animation.drive(_kMiddleLeftTween);
    animation.dispose();

    assert(debugCheckHasDirectionality(context));
    final TextDirection textDirection = Directionality.of(context);
    return SlideTransition(
      position: delegatedPositionAnimation,
      textDirection: textDirection,
      transformHitTests: false,
      child: child,
    );
  }

  @override
  State<CupertinoPageTransition> createState() => _CupertinoPageTransitionState();
}

class _CupertinoPageTransitionState extends State<CupertinoPageTransition> {
  // When this page is coming in to cover another page.
  late Animation<Offset> _primaryPositionAnimation;
  // When this page is becoming covered by another page.
  late Animation<Offset> _secondaryPositionAnimation;
  // Shadow of page which is coming in to cover another page.
  late Animation<Decoration> _primaryShadowAnimation;
  // Curve of primary page which is coming in to cover another page.
  CurvedAnimation? _primaryPositionCurve;
  // Curve of secondary page which is becoming covered by another page.
  CurvedAnimation? _secondaryPositionCurve;
  // Curve of primary page's shadow.
  CurvedAnimation? _primaryShadowCurve;

  @override
  void initState() {
    super.initState();
    _setupAnimation();
  }

  @override
  void didUpdateWidget(covariant CupertinoPageTransition oldWidget) {
    super.didUpdateWidget(oldWidget);
    if (oldWidget.primaryRouteAnimation != widget.primaryRouteAnimation ||
        oldWidget.secondaryRouteAnimation != widget.secondaryRouteAnimation ||
        oldWidget.linearTransition != widget.linearTransition) {
      _disposeCurve();
      _setupAnimation();
    }
  }

  @override
  void dispose() {
    _disposeCurve();
    super.dispose();
  }

  void _disposeCurve() {
    _primaryPositionCurve?.dispose();
    _secondaryPositionCurve?.dispose();
    _primaryShadowCurve?.dispose();
    _primaryPositionCurve = null;
    _secondaryPositionCurve = null;
    _primaryShadowCurve = null;
  }

  void _setupAnimation() {
    if (!widget.linearTransition) {
      _primaryPositionCurve = CurvedAnimation(
        parent: widget.primaryRouteAnimation,
        curve: Curves.fastEaseInToSlowEaseOut,
        reverseCurve: Curves.fastEaseInToSlowEaseOut.flipped,
      );
      _secondaryPositionCurve = CurvedAnimation(
        parent: widget.secondaryRouteAnimation,
        curve: Curves.linearToEaseOut,
        reverseCurve: Curves.easeInToLinear,
      );
      _primaryShadowCurve = CurvedAnimation(
        parent: widget.primaryRouteAnimation,
        curve: Curves.linearToEaseOut,
      );
    }
    _primaryPositionAnimation = (_primaryPositionCurve ?? widget.primaryRouteAnimation).drive(
      _kRightMiddleTween,
    );
    _secondaryPositionAnimation = (_secondaryPositionCurve ?? widget.secondaryRouteAnimation).drive(
      _kMiddleLeftTween,
    );
    _primaryShadowAnimation = (_primaryShadowCurve ?? widget.primaryRouteAnimation).drive(
      _CupertinoEdgeShadowDecoration.kTween,
    );
  }

  @override
  Widget build(BuildContext context) {
    assert(debugCheckHasDirectionality(context));
    final TextDirection textDirection = Directionality.of(context);
    return SlideTransition(
      position: _secondaryPositionAnimation,
      textDirection: textDirection,
      transformHitTests: false,
      child: SlideTransition(
        position: _primaryPositionAnimation,
        textDirection: textDirection,
        child: DecoratedBoxTransition(decoration: _primaryShadowAnimation, child: widget.child),
      ),
    );
  }
}

/// An iOS-style transition used for summoning fullscreen dialogs.
///
/// For example, used when creating a new calendar event by bringing in the next
/// screen from the bottom.
class CupertinoFullscreenDialogTransition extends StatefulWidget {
  /// Creates an iOS-style transition used for summoning fullscreen dialogs.
  ///
  const CupertinoFullscreenDialogTransition({
    super.key,
    required this.primaryRouteAnimation,
    required this.secondaryRouteAnimation,
    required this.child,
    required this.linearTransition,
  });

  ///  * `primaryRouteAnimation` is a linear route animation from 0.0 to 1.0
  ///    when this screen is being pushed.
  final Animation<double> primaryRouteAnimation;

  ///  * `secondaryRouteAnimation` is a linear route animation from 0.0 to 1.0
  ///    when another screen is being pushed on top of this one.
  final Animation<double> secondaryRouteAnimation;

  ///  * `linearTransition` is whether to perform the transitions linearly.
  ///    Used to precisely track back gesture drags.
  final bool linearTransition;

  /// The widget below this widget in the tree.
  final Widget child;

  @override
  State<CupertinoFullscreenDialogTransition> createState() =>
      _CupertinoFullscreenDialogTransitionState();
}

class _CupertinoFullscreenDialogTransitionState extends State<CupertinoFullscreenDialogTransition> {
  /// When this page is coming in to cover another page.
  late Animation<Offset> _primaryPositionAnimation;

  /// When this page is becoming covered by another page.
  late Animation<Offset> _secondaryPositionAnimation;

  /// Curve of primary page which is coming in to cover another page.
  CurvedAnimation? _primaryPositionCurve;

  /// Curve of secondary page which is becoming covered by another page.
  CurvedAnimation? _secondaryPositionCurve;

  @override
  void initState() {
    super.initState();
    _setupAnimation();
  }

  @override
  void didUpdateWidget(covariant CupertinoFullscreenDialogTransition oldWidget) {
    super.didUpdateWidget(oldWidget);
    if (oldWidget.primaryRouteAnimation != widget.primaryRouteAnimation ||
        oldWidget.secondaryRouteAnimation != widget.secondaryRouteAnimation ||
        oldWidget.linearTransition != widget.linearTransition) {
      _disposeCurve();
      _setupAnimation();
    }
  }

  @override
  void dispose() {
    _disposeCurve();
    super.dispose();
  }

  void _disposeCurve() {
    _primaryPositionCurve?.dispose();
    _secondaryPositionCurve?.dispose();
    _primaryPositionCurve = null;
    _secondaryPositionCurve = null;
  }

  void _setupAnimation() {
    _primaryPositionAnimation = (_primaryPositionCurve = CurvedAnimation(
          parent: widget.primaryRouteAnimation,
          curve: Curves.linearToEaseOut,
          // The curve must be flipped so that the reverse animation doesn't play
          // an ease-in curve, which iOS does not use.
          reverseCurve: Curves.linearToEaseOut.flipped,
        ))
        .drive(_kBottomUpTween);
    _secondaryPositionAnimation = (widget.linearTransition
            ? widget.secondaryRouteAnimation
            : _secondaryPositionCurve = CurvedAnimation(
              parent: widget.secondaryRouteAnimation,
              curve: Curves.linearToEaseOut,
              reverseCurve: Curves.easeInToLinear,
            ))
        .drive(_kMiddleLeftTween);
  }

  @override
  Widget build(BuildContext context) {
    assert(debugCheckHasDirectionality(context));
    final TextDirection textDirection = Directionality.of(context);
    return SlideTransition(
      position: _secondaryPositionAnimation,
      textDirection: textDirection,
      transformHitTests: false,
      child: SlideTransition(position: _primaryPositionAnimation, child: widget.child),
    );
  }
}

/// This is the widget side of [_CupertinoBackGestureController].
///
/// This widget provides a gesture recognizer which, when it determines the
/// route can be closed with a back gesture, creates the controller and
/// feeds it the input from the gesture recognizer.
///
/// The gesture data is converted from absolute coordinates to logical
/// coordinates by this widget.
///
/// The type `T` specifies the return type of the route with which this gesture
/// detector is associated.
class _CupertinoBackGestureDetector<T> extends StatefulWidget {
  const _CupertinoBackGestureDetector({
    super.key,
    required this.enabledCallback,
    required this.onStartPopGesture,
    required this.child,
  });

  final Widget child;

  final ValueGetter<bool> enabledCallback;

  final ValueGetter<_CupertinoBackGestureController<T>> onStartPopGesture;

  @override
  _CupertinoBackGestureDetectorState<T> createState() => _CupertinoBackGestureDetectorState<T>();
}

class _CupertinoBackGestureDetectorState<T> extends State<_CupertinoBackGestureDetector<T>> {
  _CupertinoBackGestureController<T>? _backGestureController;

  late HorizontalDragGestureRecognizer _recognizer;

  @override
  void initState() {
    super.initState();
    _recognizer =
        HorizontalDragGestureRecognizer(debugOwner: this)
          ..onStart = _handleDragStart
          ..onUpdate = _handleDragUpdate
          ..onEnd = _handleDragEnd
          ..onCancel = _handleDragCancel;
  }

  @override
  void dispose() {
    _recognizer.dispose();

    // If this is disposed during a drag, call navigator.didStopUserGesture.
    if (_backGestureController != null) {
      WidgetsBinding.instance.addPostFrameCallback((_) {
        if (_backGestureController?.navigator.mounted ?? false) {
          _backGestureController?.navigator.didStopUserGesture();
        }
        _backGestureController = null;
      });
    }
    super.dispose();
  }

  void _handleDragStart(DragStartDetails details) {
    assert(mounted);
    assert(_backGestureController == null);
    _backGestureController = widget.onStartPopGesture();
  }

  void _handleDragUpdate(DragUpdateDetails details) {
    assert(mounted);
    assert(_backGestureController != null);
    _backGestureController!.dragUpdate(
      _convertToLogical(details.primaryDelta! / context.size!.width),
    );
  }

  void _handleDragEnd(DragEndDetails details) {
    assert(mounted);
    assert(_backGestureController != null);
    _backGestureController!.dragEnd(
      _convertToLogical(details.velocity.pixelsPerSecond.dx / context.size!.width),
    );
    _backGestureController = null;
  }

  void _handleDragCancel() {
    assert(mounted);
    // This can be called even if start is not called, paired with the "down" event
    // that we don't consider here.
    _backGestureController?.dragEnd(0.0);
    _backGestureController = null;
  }

  void _handlePointerDown(PointerDownEvent event) {
    if (widget.enabledCallback()) {
      _recognizer.addPointer(event);
    }
  }

  double _convertToLogical(double value) {
    return switch (Directionality.of(context)) {
      TextDirection.rtl => -value,
      TextDirection.ltr => value,
    };
  }

  @override
  Widget build(BuildContext context) {
    assert(debugCheckHasDirectionality(context));
    // For devices with notches, the drag area needs to be larger on the side
    // that has the notch.
    final double dragAreaWidth = switch (Directionality.of(context)) {
      TextDirection.rtl => MediaQuery.paddingOf(context).right,
      TextDirection.ltr => MediaQuery.paddingOf(context).left,
    };
    return Stack(
      fit: StackFit.passthrough,
      children: <Widget>[
        widget.child,
        PositionedDirectional(
          start: 0.0,
          width: max(dragAreaWidth, _kBackGestureWidth),
          top: 0.0,
          bottom: 0.0,
          child: Listener(onPointerDown: _handlePointerDown, behavior: HitTestBehavior.translucent),
        ),
      ],
    );
  }
}

/// A controller for an iOS-style back gesture.
///
/// This is created by a [CupertinoPageRoute] in response from a gesture caught
/// by a [_CupertinoBackGestureDetector] widget, which then also feeds it input
/// from the gesture. It controls the animation controller owned by the route,
/// based on the input provided by the gesture detector.
///
/// This class works entirely in logical coordinates (0.0 is new page dismissed,
/// 1.0 is new page on top).
///
/// The type `T` specifies the return type of the route with which this gesture
/// detector controller is associated.
class _CupertinoBackGestureController<T> {
  /// Creates a controller for an iOS-style back gesture.
  _CupertinoBackGestureController({
    required this.navigator,
    required this.controller,
    required this.getIsActive,
    required this.getIsCurrent,
  }) {
    navigator.didStartUserGesture();
  }

  final AnimationController controller;
  final NavigatorState navigator;
  final ValueGetter<bool> getIsActive;
  final ValueGetter<bool> getIsCurrent;

  /// The drag gesture has changed by [delta]. The total range of the drag
  /// should be 0.0 to 1.0.
  void dragUpdate(double delta) {
    controller.value -= delta;
  }

  /// The drag gesture has ended with a horizontal motion of [velocity] as a
  /// fraction of screen width per second.
  void dragEnd(double velocity) {
    // Fling in the appropriate direction.
    //
    // This curve has been determined through rigorously eyeballing native iOS
    // animations.
    const Curve animationCurve = Curves.fastEaseInToSlowEaseOut;
    final bool isCurrent = getIsCurrent();
    final bool animateForward;

    if (!isCurrent) {
      // If the page has already been navigated away from, then the animation
      // direction depends on whether or not it's still in the navigation stack,
      // regardless of velocity or drag position. For example, if a route is
      // being slowly dragged back by just a few pixels, but then a programmatic
      // pop occurs, the route should still be animated off the screen.
      // See https://github.com/flutter/flutter/issues/141268.
      animateForward = getIsActive();
    } else if (velocity.abs() >= _kMinFlingVelocity) {
      // If the user releases the page before mid screen with sufficient velocity,
      // or after mid screen, we should animate the page out. Otherwise, the page
      // should be animated back in.
      animateForward = velocity <= 0;
    } else {
      animateForward = controller.value > 0.5;
    }

    if (animateForward) {
      controller.animateTo(
        1.0,
        duration: _kDroppedSwipePageAnimationDuration,
        curve: animationCurve,
      );
    } else {
      if (isCurrent) {
        // This route is destined to pop at this point. Reuse navigator's pop.
        navigator.pop();
      }

      // The popping may have finished inline if already at the target destination.
      if (controller.isAnimating) {
        controller.animateBack(
          0.0,
          duration: _kDroppedSwipePageAnimationDuration,
          curve: animationCurve,
        );
      }
    }

    if (controller.isAnimating) {
      // Keep the userGestureInProgress in true state so we don't change the
      // curve of the page transition mid-flight since CupertinoPageTransition
      // depends on userGestureInProgress.
      late AnimationStatusListener animationStatusCallback;
      animationStatusCallback = (AnimationStatus status) {
        navigator.didStopUserGesture();
        controller.removeStatusListener(animationStatusCallback);
      };
      controller.addStatusListener(animationStatusCallback);
    } else {
      navigator.didStopUserGesture();
    }
  }
}

// A custom [Decoration] used to paint an extra shadow on the start edge of the
// box it's decorating. It's like a [BoxDecoration] with only a gradient except
// it paints on the start side of the box instead of behind the box.
class _CupertinoEdgeShadowDecoration extends Decoration {
  const _CupertinoEdgeShadowDecoration._([this._colors]);

  static DecorationTween kTween = DecorationTween(
    begin: const _CupertinoEdgeShadowDecoration._(), // No decoration initially.
    end: const _CupertinoEdgeShadowDecoration._(
      // Eyeballed gradient used to mimic a drop shadow on the start side only.
      <Color>[Color(0x04000000), CupertinoColors.transparent],
    ),
  );

  // Colors used to paint a gradient at the start edge of the box it is
  // decorating.
  //
  // The first color in the list is used at the start of the gradient, which
  // is located at the start edge of the decorated box.
  //
  // If this is null, no shadow is drawn.
  //
  // The list must have at least two colors in it (otherwise it would not be a
  // gradient).
  final List<Color>? _colors;

  // Linearly interpolate between two edge shadow decorations decorations.
  //
  // The `t` argument represents position on the timeline, with 0.0 meaning
  // that the interpolation has not started, returning `a` (or something
  // equivalent to `a`), 1.0 meaning that the interpolation has finished,
  // returning `b` (or something equivalent to `b`), and values in between
  // meaning that the interpolation is at the relevant point on the timeline
  // between `a` and `b`. The interpolation can be extrapolated beyond 0.0 and
  // 1.0, so negative values and values greater than 1.0 are valid (and can
  // easily be generated by curves such as [Curves.elasticInOut]).
  //
  // Values for `t` are usually obtained from an [Animation<double>], such as
  // an [AnimationController].
  //
  // See also:
  //
  //  * [Decoration.lerp].
  static _CupertinoEdgeShadowDecoration? lerp(
    _CupertinoEdgeShadowDecoration? a,
    _CupertinoEdgeShadowDecoration? b,
    double t,
  ) {
    if (identical(a, b)) {
      return a;
    }
    if (a == null) {
      return b!._colors == null
          ? b
          : _CupertinoEdgeShadowDecoration._(
            b._colors!.map<Color>((Color color) => Color.lerp(null, color, t)!).toList(),
          );
    }
    if (b == null) {
      return a._colors == null
          ? a
          : _CupertinoEdgeShadowDecoration._(
            a._colors.map<Color>((Color color) => Color.lerp(null, color, 1.0 - t)!).toList(),
          );
    }
    assert(b._colors != null || a._colors != null);
    // If it ever becomes necessary, we could allow decorations with different
    // length' here, similarly to how it is handled in [LinearGradient.lerp].
    assert(b._colors == null || a._colors == null || a._colors.length == b._colors.length);
    return _CupertinoEdgeShadowDecoration._(<Color>[
      for (int i = 0; i < b._colors!.length; i += 1) Color.lerp(a._colors?[i], b._colors[i], t)!,
    ]);
  }

  @override
  _CupertinoEdgeShadowDecoration lerpFrom(Decoration? a, double t) {
    if (a is _CupertinoEdgeShadowDecoration) {
      return _CupertinoEdgeShadowDecoration.lerp(a, this, t)!;
    }
    return _CupertinoEdgeShadowDecoration.lerp(null, this, t)!;
  }

  @override
  _CupertinoEdgeShadowDecoration lerpTo(Decoration? b, double t) {
    if (b is _CupertinoEdgeShadowDecoration) {
      return _CupertinoEdgeShadowDecoration.lerp(this, b, t)!;
    }
    return _CupertinoEdgeShadowDecoration.lerp(this, null, t)!;
  }

  @override
  _CupertinoEdgeShadowPainter createBoxPainter([VoidCallback? onChanged]) {
    return _CupertinoEdgeShadowPainter(this, onChanged);
  }

  @override
  bool operator ==(Object other) {
    if (other.runtimeType != runtimeType) {
      return false;
    }
    return other is _CupertinoEdgeShadowDecoration && other._colors == _colors;
  }

  @override
  int get hashCode => _colors.hashCode;

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties.add(IterableProperty<Color>('colors', _colors));
  }
}

/// A [BoxPainter] used to draw the page transition shadow using gradients.
class _CupertinoEdgeShadowPainter extends BoxPainter {
  _CupertinoEdgeShadowPainter(this._decoration, super.onChanged)
    : assert(_decoration._colors == null || _decoration._colors.length > 1);

  final _CupertinoEdgeShadowDecoration _decoration;

  @override
  void paint(Canvas canvas, Offset offset, ImageConfiguration configuration) {
    final List<Color>? colors = _decoration._colors;
    if (colors == null) {
      return;
    }

    // The following code simulates drawing a [LinearGradient] configured as
    // follows:
    //
    // LinearGradient(
    //   begin: AlignmentDirectional(0.90, 0.0), // Spans 5% of the page.
    //   colors: _decoration._colors,
    // )
    //
    // A performance evaluation on Feb 8, 2021 showed, that drawing the gradient
    // manually as implemented below is more performant than relying on
    // [LinearGradient.createShader] because compiling that shader takes a long
    // time. On an iPhone XR, the implementation below reduced the worst frame
    // time for a cupertino page transition of a newly installed app from ~95ms
    // down to ~30ms, mainly because there's no longer a need to compile a
    // shader for the LinearGradient.
    //
    // The implementation below divides the width of the shadow into multiple
    // bands of equal width, one for each color interval defined by
    // `_decoration._colors`. Band x is filled with a gradient going from
    // `_decoration._colors[x]` to `_decoration._colors[x + 1]` by drawing a
    // bunch of 1px wide rects. The rects change their color by lerping between
    // the two colors that define the interval of the band.

    // Shadow spans 5% of the page.
    final double shadowWidth = 0.05 * configuration.size!.width;
    final double shadowHeight = configuration.size!.height;
    final double bandWidth = shadowWidth / (colors.length - 1);

    final TextDirection? textDirection = configuration.textDirection;
    assert(textDirection != null);
    final (double shadowDirection, double start) = switch (textDirection!) {
      TextDirection.rtl => (1, offset.dx + configuration.size!.width),
      TextDirection.ltr => (-1, offset.dx),
    };

    int bandColorIndex = 0;
    for (int dx = 0; dx < shadowWidth; dx += 1) {
      if (dx ~/ bandWidth != bandColorIndex) {
        bandColorIndex += 1;
      }
      final Paint paint =
          Paint()
            ..color =
                Color.lerp(
                  colors[bandColorIndex],
                  colors[bandColorIndex + 1],
                  (dx % bandWidth) / bandWidth,
                )!;
      final double x = start + shadowDirection * dx;
      canvas.drawRect(Rect.fromLTWH(x - 1.0, offset.dy, 1.0, shadowHeight), paint);
    }
  }
}

// The stiffness used by dialogs and action sheets.
//
// The stiffness value is obtained by examining the properties of
// `CASpringAnimation` in Xcode. The damping value is derived similarly, with
// additional precision calculated based on `_kStandardStiffness` to ensure a
// damping ratio of 1 (critically damped): damping = 2 * sqrt(stiffness)
const double _kStandardStiffness = 522.35;
const double _kStandardDamping = 45.7099552;
const SpringDescription _kStandardSpring = SpringDescription(
  mass: 1,
  stiffness: _kStandardStiffness,
  damping: _kStandardDamping,
);
// The iOS spring animation duration is 0.404 seconds, based on the properties
// of `CASpringAnimation` in Xcode. At this point, the spring's position
// `x(0.404)` is approximately 0.9990000, suggesting that iOS uses a position
// tolerance of 1e-3 (matching the default `_epsilonDefault` value).
//
// However, the spring's velocity `dx(0.404)` is about 0.02, indicating that iOS
// may not consider velocity when determining the animation's end condition. To
// account for this, a larger velocity tolerance is applied here for added
// safety.
const Tolerance _kStandardTolerance = Tolerance(velocity: 0.03);

/// A route that shows a modal iOS-style popup that slides up from the
/// bottom of the screen.
///
/// Such a popup is an alternative to a menu or a dialog and prevents the user
/// from interacting with the rest of the app.
///
/// It is used internally by [showCupertinoModalPopup] or can be directly pushed
/// onto the [Navigator] stack to enable state restoration. See
/// [showCupertinoModalPopup] for a state restoration app example.
///
/// The `barrierColor` argument determines the [Color] of the barrier underneath
/// the popup. When unspecified, the barrier color defaults to a light opacity
/// black scrim based on iOS's dialog screens. To correctly have iOS resolve
/// to the appropriate modal colors, pass in
/// `CupertinoDynamicColor.resolve(kCupertinoModalBarrierColor, context)`.
///
/// The `barrierDismissible` argument determines whether clicking outside the
/// popup results in dismissal. It is `true` by default.
///
/// The `semanticsDismissible` argument is used to determine whether the
/// semantics of the modal barrier are included in the semantics tree.
///
/// The `routeSettings` argument is used to provide [RouteSettings] to the
/// created Route.
///
/// {@macro flutter.widgets.RawDialogRoute}
///
/// See also:
///
///  * [DisplayFeatureSubScreen], which documents the specifics of how
///    [DisplayFeature]s can split the screen into sub-screens.
///  * [CupertinoActionSheet], which is the widget usually returned by the
///    `builder` argument.
///  * <https://developer.apple.com/design/human-interface-guidelines/ios/views/action-sheets/>
class CupertinoModalPopupRoute<T> extends PopupRoute<T> {
  /// A route that shows a modal iOS-style popup that slides up from the
  /// bottom of the screen.
  CupertinoModalPopupRoute({
    required this.builder,
    this.barrierLabel = 'Dismiss',
    this.barrierColor = kCupertinoModalBarrierColor,
    bool barrierDismissible = true,
    bool semanticsDismissible = false,
    super.filter,
    super.settings,
    super.requestFocus,
    this.anchorPoint,
  }) : _barrierDismissible = barrierDismissible,
       _semanticsDismissible = semanticsDismissible;

  /// A builder that builds the widget tree for the [CupertinoModalPopupRoute].
  ///
  /// The [builder] argument typically builds a [CupertinoActionSheet] widget.
  ///
  /// Content below the widget is dimmed with a [ModalBarrier]. The widget built
  /// by the [builder] does not share a context with the route it was originally
  /// built from. Use a [StatefulBuilder] or a custom [StatefulWidget] if the
  /// widget needs to update dynamically.
  final WidgetBuilder builder;

  final bool _barrierDismissible;

  final bool _semanticsDismissible;

  @override
  final String barrierLabel;

  @override
  final Color? barrierColor;

  @override
  bool get barrierDismissible => _barrierDismissible;

  @override
  bool get semanticsDismissible => _semanticsDismissible;

  @override
  Duration get transitionDuration => _kModalPopupTransitionDuration;

  /// {@macro flutter.widgets.DisplayFeatureSubScreen.anchorPoint}
  final Offset? anchorPoint;

  @override
  Simulation createSimulation({required bool forward}) {
    assert(!debugTransitionCompleted(), 'Cannot reuse a $runtimeType after disposing it.');
    final double end = forward ? 1.0 : 0.0;
    return SpringSimulation(
      _kStandardSpring,
      controller!.value,
      end,
      0,
      tolerance: _kStandardTolerance,
      snapToEnd: true,
    );
  }

  @override
  Widget buildPage(
    BuildContext context,
    Animation<double> animation,
    Animation<double> secondaryAnimation,
  ) {
    return CupertinoUserInterfaceLevel(
      data: CupertinoUserInterfaceLevelData.elevated,
      child: DisplayFeatureSubScreen(anchorPoint: anchorPoint, child: Builder(builder: builder)),
    );
  }

  @override
  Widget buildTransitions(
    BuildContext context,
    Animation<double> animation,
    Animation<double> secondaryAnimation,
    Widget child,
  ) {
    return Align(
      alignment: Alignment.bottomCenter,
      child: FractionalTranslation(translation: _offsetTween.evaluate(animation), child: child),
    );
  }

  static final Tween<Offset> _offsetTween = Tween<Offset>(
    begin: const Offset(0.0, 1.0),
    end: Offset.zero,
  );
}

/// Shows a modal iOS-style popup that slides up from the bottom of the screen.
///
/// Such a popup is an alternative to a menu or a dialog and prevents the user
/// from interacting with the rest of the app.
///
/// The `context` argument is used to look up the [Navigator] for the popup.
/// It is only used when the method is called. Its corresponding widget can be
/// safely removed from the tree before the popup is closed.
///
/// The `barrierColor` argument determines the [Color] of the barrier underneath
/// the popup. When unspecified, the barrier color defaults to a light opacity
/// black scrim based on iOS's dialog screens.
///
/// The `barrierDismissible` argument determines whether clicking outside the
/// popup results in dismissal. It is `true` by default.
///
/// The `useRootNavigator` argument is used to determine whether to push the
/// popup to the [Navigator] furthest from or nearest to the given `context`. It
/// is `true` by default.
///
/// The `semanticsDismissible` argument is used to determine whether the
/// semantics of the modal barrier are included in the semantics tree.
///
/// The `routeSettings` argument is used to provide [RouteSettings] to the
/// created Route.
///
/// The `builder` argument typically builds a [CupertinoActionSheet] widget.
/// Content below the widget is dimmed with a [ModalBarrier]. The widget built
/// by the `builder` does not share a context with the location that
/// [showCupertinoModalPopup] is originally called from. Use a
/// [StatefulBuilder] or a custom [StatefulWidget] if the widget needs to
/// update dynamically.
///
/// {@macro flutter.widgets.RawDialogRoute}
///
/// Returns a `Future` that resolves to the value that was passed to
/// [Navigator.pop] when the popup was closed.
///
/// ### State Restoration in Modals
///
/// Using this method will not enable state restoration for the modal. In order
/// to enable state restoration for a modal, use [Navigator.restorablePush]
/// or [Navigator.restorablePushNamed] with [CupertinoModalPopupRoute].
///
/// For more information about state restoration, see [RestorationManager].
///
/// {@tool dartpad}
/// This sample demonstrates how to create a restorable Cupertino modal route.
/// This is accomplished by enabling state restoration by specifying
/// [CupertinoApp.restorationScopeId] and using [Navigator.restorablePush] to
/// push [CupertinoModalPopupRoute] when the [CupertinoButton] is tapped.
///
/// {@macro flutter.widgets.RestorationManager}
///
/// ** See code in examples/api/lib/cupertino/route/show_cupertino_modal_popup.0.dart **
/// {@end-tool}
///
/// See also:
///
///  * [DisplayFeatureSubScreen], which documents the specifics of how
///    [DisplayFeature]s can split the screen into sub-screens.
///  * [CupertinoActionSheet], which is the widget usually returned by the
///    `builder` argument to [showCupertinoModalPopup].
///  * <https://developer.apple.com/design/human-interface-guidelines/ios/views/action-sheets/>
Future<T?> showCupertinoModalPopup<T>({
  required BuildContext context,
  required WidgetBuilder builder,
  ImageFilter? filter,
  Color barrierColor = kCupertinoModalBarrierColor,
  bool barrierDismissible = true,
  bool useRootNavigator = true,
  bool semanticsDismissible = false,
  RouteSettings? routeSettings,
  Offset? anchorPoint,
}) {
  return Navigator.of(context, rootNavigator: useRootNavigator).push(
    CupertinoModalPopupRoute<T>(
      builder: builder,
      filter: filter,
      barrierColor: CupertinoDynamicColor.resolve(barrierColor, context),
      barrierDismissible: barrierDismissible,
      semanticsDismissible: semanticsDismissible,
      settings: routeSettings,
      anchorPoint: anchorPoint,
    ),
  );
}

Widget _buildCupertinoDialogTransitions(
  BuildContext context,
  Animation<double> animation,
  Animation<double> secondaryAnimation,
  Widget child,
) {
  return child;
}

/// Displays an iOS-style dialog above the current contents of the app, with
/// iOS-style entrance and exit animations, modal barrier color, and modal
/// barrier behavior (by default, the dialog is not dismissible with a tap on
/// the barrier).
///
/// This function takes a `builder` which typically builds a [CupertinoAlertDialog]
/// widget. Content below the dialog is dimmed with a [ModalBarrier]. The widget
/// returned by the `builder` does not share a context with the location that
/// [showCupertinoDialog] is originally called from. Use a [StatefulBuilder] or
/// a custom [StatefulWidget] if the dialog needs to update dynamically.
///
/// The `context` argument is used to look up the [Navigator] for the dialog.
/// It is only used when the method is called. Its corresponding widget can
/// be safely removed from the tree before the dialog is closed.
///
/// The `useRootNavigator` argument is used to determine whether to push the
/// dialog to the [Navigator] furthest from or nearest to the given `context`.
/// By default, `useRootNavigator` is `true` and the dialog route created by
/// this method is pushed to the root navigator.
///
/// {@macro flutter.widgets.RawDialogRoute}
///
/// If the application has multiple [Navigator] objects, it may be necessary to
/// call `Navigator.of(context, rootNavigator: true).pop(result)` to close the
/// dialog rather than just `Navigator.pop(context, result)`.
///
/// Returns a [Future] that resolves to the value (if any) that was passed to
/// [Navigator.pop] when the dialog was closed.
///
/// ### State Restoration in Dialogs
///
/// Using this method will not enable state restoration for the dialog. In order
/// to enable state restoration for a dialog, use [Navigator.restorablePush]
/// or [Navigator.restorablePushNamed] with [CupertinoDialogRoute].
///
/// For more information about state restoration, see [RestorationManager].
///
/// {@tool dartpad}
/// This sample demonstrates how to create a restorable Cupertino dialog. This is
/// accomplished by enabling state restoration by specifying
/// [CupertinoApp.restorationScopeId] and using [Navigator.restorablePush] to
/// push [CupertinoDialogRoute] when the [CupertinoButton] is tapped.
///
/// {@macro flutter.widgets.RestorationManager}
///
/// ** See code in examples/api/lib/cupertino/route/show_cupertino_dialog.0.dart **
/// {@end-tool}
///
/// See also:
///
///  * [CupertinoAlertDialog], an iOS-style alert dialog.
///  * [showDialog], which displays a Material-style dialog.
///  * [showGeneralDialog], which allows for customization of the dialog popup.
///  * [DisplayFeatureSubScreen], which documents the specifics of how
///    [DisplayFeature]s can split the screen into sub-screens.
///  * <https://developer.apple.com/design/human-interface-guidelines/alerts/>
Future<T?> showCupertinoDialog<T>({
  required BuildContext context,
  required WidgetBuilder builder,
  String? barrierLabel,
  bool useRootNavigator = true,
  bool barrierDismissible = false,
  RouteSettings? routeSettings,
  Offset? anchorPoint,
}) {
  return Navigator.of(context, rootNavigator: useRootNavigator).push<T>(
    CupertinoDialogRoute<T>(
      builder: builder,
      context: context,
      barrierDismissible: barrierDismissible,
      barrierLabel: barrierLabel,
      barrierColor: CupertinoDynamicColor.resolve(kCupertinoModalBarrierColor, context),
      settings: routeSettings,
      anchorPoint: anchorPoint,
    ),
  );
}

/// A dialog route that shows an iOS-style dialog.
///
/// It is used internally by [showCupertinoDialog] or can be directly pushed
/// onto the [Navigator] stack to enable state restoration. See
/// [showCupertinoDialog] for a state restoration app example.
///
/// This function takes a `builder` which typically builds a [Dialog] widget.
/// Content below the dialog is dimmed with a [ModalBarrier]. The widget
/// returned by the `builder` does not share a context with the location that
/// `showDialog` is originally called from. Use a [StatefulBuilder] or a
/// custom [StatefulWidget] if the dialog needs to update dynamically.
///
/// The `context` argument is used to look up
/// [CupertinoLocalizations.modalBarrierDismissLabel], which provides the
/// modal with a localized accessibility label that will be used for the
/// modal's barrier. However, a custom `barrierLabel` can be passed in as well.
///
/// The `barrierDismissible` argument is used to indicate whether tapping on the
/// barrier will dismiss the dialog. It is `true` by default and cannot be `null`.
///
/// The `barrierColor` argument is used to specify the color of the modal
/// barrier that darkens everything below the dialog. If `null`, then
/// [CupertinoDynamicColor.resolve] is used to compute the modal color.
///
/// The `settings` argument define the settings for this route. See
/// [RouteSettings] for details.
///
/// {@macro flutter.widgets.RawDialogRoute}
///
/// See also:
///
///  * [showCupertinoDialog], which is a way to display
///     an iOS-style dialog.
///  * [showGeneralDialog], which allows for customization of the dialog popup.
///  * [showDialog], which displays a Material dialog.
///  * [DisplayFeatureSubScreen], which documents the specifics of how
///    [DisplayFeature]s can split the screen into sub-screens.
class CupertinoDialogRoute<T> extends RawDialogRoute<T> {
  /// A dialog route that shows an iOS-style dialog.
  CupertinoDialogRoute({
    required WidgetBuilder builder,
    required BuildContext context,
    super.barrierDismissible,
    Color? barrierColor,
    String? barrierLabel,
    // This transition duration was eyeballed comparing with iOS
    super.transitionDuration = const Duration(milliseconds: 250),
    this.transitionBuilder,
    super.settings,
    super.requestFocus,
    super.anchorPoint,
  }) : super(
         pageBuilder: (
           BuildContext context,
           Animation<double> animation,
           Animation<double> secondaryAnimation,
         ) {
           return builder(context);
         },
         transitionBuilder: transitionBuilder ?? _buildCupertinoDialogTransitions,
         barrierLabel: barrierLabel ?? CupertinoLocalizations.of(context).modalBarrierDismissLabel,
         barrierColor:
             barrierColor ?? CupertinoDynamicColor.resolve(kCupertinoModalBarrierColor, context),
       );

  /// Custom transition builder
  RouteTransitionsBuilder? transitionBuilder;

  CurvedAnimation? _fadeAnimation;

  @override
  Simulation createSimulation({required bool forward}) {
    assert(!debugTransitionCompleted(), 'Cannot reuse a $runtimeType after disposing it.');
    final double end = forward ? 1.0 : 0.0;
    return SpringSimulation(
      _kStandardSpring,
      controller!.value,
      end,
      0,
      tolerance: _kStandardTolerance,
      snapToEnd: true,
    );
  }

  @override
  Widget buildTransitions(
    BuildContext context,
    Animation<double> animation,
    Animation<double> secondaryAnimation,
    Widget child,
  ) {
    if (transitionBuilder != null) {
      return super.buildTransitions(context, animation, secondaryAnimation, child);
    }

    if (animation.status == AnimationStatus.reverse) {
      return FadeTransition(opacity: animation, child: child);
    }
    return FadeTransition(
      opacity: animation,
      child: ScaleTransition(scale: animation.drive(_dialogScaleTween), child: child),
    );
  }

  @override
  void dispose() {
    _fadeAnimation?.dispose();
    super.dispose();
  }

  // The curve and initial scale values were mostly eyeballed from iOS, however
  // they reuse the same animation curve that was modeled after native page
  // transitions.
  static final Tween<double> _dialogScaleTween = Tween<double>(begin: 1.3, end: 1.0);
}


Instructions for the chapter (Generate content in English unless specified otherwise):
- Start with a clear heading (e.g., `# Chapter 4: CupertinoPageRoute
`). Use the provided concept name.

- If this is not the first chapter, begin with a brief transition from the previous chapter, referencing it with a proper Markdown link using its name.

- Begin with a high-level motivation explaining what problem this abstraction solves. Start with a central use case as a concrete example. The whole chapter should guide the reader to understand how to solve this use case. Make it very minimal and friendly to beginners.

- If the abstraction is complex, break it down into key concepts. Explain each concept one-by-one in a very beginner-friendly way.

- Explain how to use this abstraction to solve the use case. Give example inputs and outputs for code snippets (if the output isn't values, describe at a high level what will happen).

- Each code block should be BELOW 10 lines! If longer code blocks are needed, break them down into smaller pieces and walk through them one-by-one. Aggresively simplify the code to make it minimal. Use comments to skip non-important implementation details. Each code block should have a beginner friendly explanation right after it.

- Describe the internal implementation to help understand what's under the hood. First provide a non-code or code-light walkthrough on what happens step-by-step when the abstraction is called. It's recommended to use a simple sequenceDiagram with a dummy example - keep it minimal with at most 5 participants to ensure clarity. If participant name has space, use: `participant QP as Query Processing`. .

- Then dive deeper into code for the internal implementation with references to files. Provide example code blocks, but make them similarly simple and beginner-friendly. Explain.

- IMPORTANT: When you need to refer to other core abstractions covered in other chapters, ALWAYS use proper Markdown links like this: [Chapter Title](filename.md). Use the Complete Tutorial Structure above to find the correct filename and the chapter title. Translate the surrounding text.

- Use mermaid diagrams to illustrate complex concepts (```mermaid``` format). .

- Heavily use analogies and examples throughout to help beginners understand.

- End the chapter with a brief conclusion that summarizes what was learned and provides a transition to the next chapter. If there is a next chapter, use a proper Markdown link: [Next Chapter Title](next_chapter_filename).

- Ensure the tone is welcoming and easy for a newcomer to understand.

- Output *only* the Markdown content for this chapter.

Now, directly provide a super beginner-friendly Markdown output (DON'T need ```markdown``` tags):

2025-05-21 12:32:24,933 - INFO - RESPONSE: # Chapter 4: CupertinoPageRoute

Welcome back, future Flutter navigators! In [Chapter 3: MaterialRouteTransitionMixin](03_materialroutetransitionmixin_.md), we explored how `MaterialRouteTransitionMixin` is the helper that gives `MaterialPageRoute` its cool, platform-adaptive animations. Now, let's turn our attention to the world of Apple's iOS design with `CupertinoPageRoute`.

### What is CupertinoPageRoute?

If you've ever used an iPhone or iPad, you've seen specific ways new screens slide into view, often from the right side of the screen, and how they slide back out when you go back. `CupertinoPageRoute` is Flutter's way of giving you that exact native iOS look and feel for your screen transitions, automatically!

Just like `MaterialPageRoute` is a pre-made blueprint for Material Design transitions, `CupertinoPageRoute` is a pre-made blueprint specifically built for Cupertino (iOS) design. It handles the characteristic sliding animations and other iOS visual cues when you navigate between pages.

**Motivation:** Our goal is to navigate from our `HomeScreen` to our `NewScreen` using the standard iOS slide-from-the-right transition when running on an iOS device, in a way that is natural and expected for iOS users.

### Using CupertinoPageRoute

Using `CupertinoPageRoute` is very similar to using `MaterialPageRoute`. You simply tell it which widget represents the new screen.

Let's go back to our `HomeScreen` button's `onPressed` and replace the `MaterialPageRoute` with a `CupertinoPageRoute`:

```dart
import 'package:flutter/cupertino.dart'; // Import Cupertino widgets!
import 'package:flutter/material.dart'; // Still need Material for Scaffold, AppBar, etc.

// ... rest of MyApp and HomeScreen classes ...

class HomeScreen extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return Scaffold( // Using Material Scaffold for simplicity in this example
      appBar: AppBar(title: Text('Home Screen')),
      body: Center(
        child: ElevatedButton(
          onPressed: () {
            Navigator.push(
              context,
              CupertinoPageRoute( // Using CupertinoPageRoute!
                builder: (context) {
                  // Just provide the widget for the new screen
                  return NewScreen();
                },
              ),
            );
          },
          child: Text('Go to New Screen'),
        ),
      ),
    );
  }
}

// ... rest of NewScreen class ...
```

See the difference? We changed `MaterialPageRoute` to `CupertinoPageRoute` and made sure to import `flutter/cupertino.dart`.

Now, when you tap the button:

*   On an iOS device, `NewScreen` will smoothly slide in from the right, with the previous screen slightly moving to the left (a parallax effect). When you go back, it slides out to the right.
*   On an Android device, because we're using a `CupertinoPageRoute`, it will *still* try to use the Cupertino (iOS) style transition, even though it's running on Android. This is different from `MaterialPageRoute` which is platform-adaptive. If you want platform-adaptive behavior, `MaterialPageRoute` is often the better choice. `CupertinoPageRoute` is primarily for building apps that *always* have the iOS feel.

### How it Works Under the Hood (Simplified)

When you use `CupertinoPageRoute`, you hand it to the `Navigator` just like any other `PageRoute`.

```mermaid
sequenceDiagram
    participant Button as Button Widget
    participant HomeScreen as HomeScreen Widget
    participant Navigator as Navigator
    participant CupertinoPageRoute as CupertinoPageRoute
    participant NewScreen as NewScreen Widget
    participant iOS Theme as iOS Theme Data (Conceptual)

    Button->HomeScreen: calls onPressed
    HomeScreen->Navigator: calls push(context, CupertinoPageRoute)
    Navigator->CupertinoPageRoute: asks for page content and transitions
    CupertinoPageRoute->CupertinoPageRoute: calls builder() to create NewScreen widget
    CupertinoPageRoute->iOS Theme: Requests iOS-style transition details
    CupertinoPageRoute->CupertinoPageRoute: Uses transition logic from mixin
    CupertinoPageRoute->NewScreen: Builds and wraps with Cupertino transition widgets
    Navigator->Navigator: Prepares
    Navigator->NewScreen: Animates the transition (iOS style)
```

The process is very similar to `MaterialPageRoute`, but instead of checking the general platform to pick between Material and Cupertino, `CupertinoPageRoute` *always* uses the Cupertino style transition logic.

Let's peek into the Flutter framework code for `CupertinoPageRoute` in `packages/flutter/lib/src/cupertino/route.dart`.

You'll find the `CupertinoPageRoute` class definition inherits from `PageRoute` and, just like `MaterialPageRoute` uses a mixin for its transitions, `CupertinoPageRoute` uses something similar: `CupertinoRouteTransitionMixin`.

```dart
// Simplified from packages/flutter/lib/src/cupertino/route.dart
class CupertinoPageRoute<T> extends PageRoute<T> with CupertinoRouteTransitionMixin<T> {
  // ... constructor and other properties ...

  /// Builds the primary contents of the route.
  final WidgetBuilder builder; // This holds the function you passed in!

  @override
  Widget buildContent(BuildContext context) => builder(context); // Uses your builder

  // ... other overrides ...
}
```

Similar to `MaterialPageRoute`, `CupertinoPageRoute` takes your `builder` function and calls its `buildContent` method to create the widget for the new page.

The iOS-style transition magic (the sliding from the right, the parallax effect) comes from the `CupertinoRouteTransitionMixin` that is mixed into `CupertinoPageRoute`. This mixin implements the `buildTransitions` method using specific iOS animations:

```dart
// Simplified/conceptual example from CupertinoRouteTransitionMixin
mixin CupertinoRouteTransitionMixin<T> on PageRoute<T> {
  // ... other properties like transitionDuration ...

  @override
  Widget buildTransitions( // This method is provided by the mixin!
    BuildContext context,
    Animation<double> animation, // Animation for the incoming page
    Animation<double> secondaryAnimation, // Animation for the outgoing page
    Widget child, // The actual content of the page (your NewScreen)
  ) {
    // Inside here, the mixin's code runs.
    // It builds specific iOS transition widgets...
    // For normal pages, it uses CupertinoPageTransition.
    // For fullscreen dialogs, it uses CupertinoFullscreenDialogTransition.
    // It uses the animations (primaryRouteAnimation and secondaryRouteAnimation)
    // and wraps the 'child' (your NewScreen widget) with them.

    // A simplified call to the actual transition builder:
    return buildPageTransitions<T>(this, context, animation, secondaryAnimation, child);
  }

  // ... other methods ...
}
```

When the `Navigator` needs to show `CupertinoPageRoute`, it asks the route to `buildTransitions`. `CupertinoPageRoute` uses the `buildTransitions` method from `CupertinoRouteTransitionMixin`. This mixin then uses dedicated transition widgets like `CupertinoPageTransition` to create the visually distinct iOS sliding effect, using the provided `animation` objects to control the movement. We'll learn more about `CupertinoPageTransition` in a later chapter.

`CupertinoPageRoute` also has support for distinguishing between regular page transitions and fullscreen dialog transitions (like presenting a modal from the bottom on iOS), using different animation styles for each case, which is also handled by the `CupertinoRouteTransitionMixin`.

### Conclusion

`CupertinoPageRoute` is the specialized `PageRoute` for bringing the native iOS page transition experience (sliding from the right, parallax effect) to your Flutter apps, regardless of the actual device platform. It uses the `CupertinoRouteTransitionMixin` to manage the transition logic and apply the appropriate iOS-style animations. While `MaterialPageRoute` is usually preferred for platform-adaptive behavior in a single codebase, `CupertinoPageRoute` is perfect when you want a consistent iOS feel.

In the next chapter, we'll dive deeper into the `CupertinoRouteTransitionMixin` itself, similar to how we looked at its Material counterpart, to see exactly where this iOS transition magic comes from.

[Next Chapter: CupertinoRouteTransitionMixin](05_cupertinoroutetransitionmixin_.md)
2025-05-21 12:32:24,940 - INFO - PROMPT: 
Write a very beginner-friendly tutorial chapter (in Markdown format) for the project `flutter` about the concept: "CupertinoRouteTransitionMixin
". This is Chapter 5.

Concept Details:
- Name: CupertinoRouteTransitionMixin

- Description:
This is like a recipe for adding iOS-style screen transitions (like sliding from the right or from the bottom for dialogs) to any `PageRoute`. Instead of having to write the transition code from scratch every time, you can "mix in" this behavior to your `PageRoute` to get the signature Cupertino look and feel for your navigations.


Complete Tutorial Structure:
1. [PageRoute
](01_pageroute_.md)
2. [MaterialPageRoute
](02_materialpageroute_.md)
3. [MaterialRouteTransitionMixin
](03_materialroutetransitionmixin_.md)
4. [CupertinoPageRoute
](04_cupertinopageroute_.md)
5. [CupertinoRouteTransitionMixin
](05_cupertinoroutetransitionmixin_.md)
6. [CupertinoPageTransition
](06_cupertinopagetransition_.md)
7. [CupertinoFullscreenDialogTransition
](07_cupertinofullscreendialogtransition_.md)
8. [CupertinoModalPopupRoute
](08_cupertinomodalpopuproute_.md)
9. [CupertinoDialogRoute
](09_cupertinodialogroute_.md)

Context from previous chapters:
# Chapter 1: PageRoute

Welcome to the first chapter of our Flutter navigation tutorial! Ever wonder how tapping a button in an app seamlessly takes you to a completely different screen? That's where the magic of navigation comes in! In Flutter, a core concept for managing these screen transitions is the `PageRoute`.

Imagine your Flutter app is like a building with many rooms (screens). When you want to go from one room (the "lobby") to another room (the "settings" screen), you need a plan or a map to get there. A `PageRoute` is exactly that – it's the blueprint, the plan, for a single "page" or screen in your app and how you would transition *to* it.

Think of it as defining:

*   **What the new screen looks like:** What widgets make up this new page?
*   **How the transition happens:** Does it slide from the side, fade in, or something else?
*   **How long the transition takes:** Is it a quick change or a smooth, longer one?
*   **Its behavior:** Can you easily "go back" or dismiss this screen?

The `PageRoute` doesn't *perform* the transition itself; it tells the `Navigator` (Flutter's system for managing screen stacks, like stacking rooms on top of each other) *how* to perform the transition to display its content.

### Our Goal: Showing a Simple New Screen

Throughout this chapter, our goal is to understand enough about `PageRoute` to accomplish a very common task: navigating from one simple screen to another.

Let's start with a basic example. We'll have a main screen with a button. When you tap the button, we want to go to a new, blank screen.

Here's a simplified look at what we might have initially:

```dart
import 'package:flutter/material.dart';

void main() {
  runApp(MyApp());
}

class MyApp extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return MaterialApp(
      home: HomeScreen(),
    );
  }
}

class HomeScreen extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(title: Text('Home Screen')),
      body: Center(
        child: ElevatedButton(
          onPressed: () {
            // We want to go to a new screen here!
          },
          child: Text('Go to New Screen'),
        ),
      ),
    );
  }
}

class NewScreen extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(title: Text('New Screen')),
      body: Center(
        child: Text('Welcome to the new screen!'),
      ),
    );
  }
}
```

In this code, we have `HomeScreen` and `NewScreen`. Our challenge is to connect the button on `HomeScreen` to show `NewScreen`. We need a `PageRoute` for `NewScreen`.

### Understanding PageRoute with PageRouteBuilder

Directly creating a raw `PageRoute` can be a bit advanced for our first step. Flutter provides a helpful class called `PageRouteBuilder` which lets us create a simple `PageRoute` using functions (callbacks). This is perfect for defining basic routes without creating a whole new class.

Let's look at how we can use `PageRouteBuilder` inside the `onPressed` of our `ElevatedButton`:

```dart
// ... inside HomeScreen onPressed ...
onPressed: () {
  Navigator.push(
    context,
    PageRouteBuilder( // Using PageRouteBuilder to define our route
      pageBuilder: (context, animation, secondaryAnimation) {
        // This function builds the actual screen content
        return NewScreen();
      },
      transitionsBuilder: (context, animation, secondaryAnimation, child) {
        // This function defines how the transition looks
        // For now, we'll do a simple fade transition as an example
        return FadeTransition(
          opacity: animation, // Controls the opacity of the new page
          child: child,
        );
      },
      transitionDuration: Duration(milliseconds: 500), // How long the transition takes
    ),
  );
},
// ... rest of HomeScreen ...
```

Let's break down what's happening here:

1.  **`Navigator.push(context, ...)`**: This is how we tell Flutter's navigation system to add a new screen on top of the current one. `context` tells the Navigator where we are in the widget tree.
2.  **`PageRouteBuilder(...)`**: We create an instance of `PageRouteBuilder` to define the characteristics of the new route.
3.  **`pageBuilder: (context, animation, secondaryAnimation) { return NewScreen(); }`**: This is a required function that `PageRouteBuilder` needs. It tells the builder *what* widget tree to display for this page. In our case, it's just our `NewScreen` widget. The `animation` and `secondaryAnimation` parameters are for transition animations, which we'll use in the next part.
4.  **`transitionsBuilder: (context, animation, secondaryAnimation, child) { ... }`**: This optional function defines how the transition *looks*. It takes the context, `animation` (for the incoming page), `secondaryAnimation` (for the outgoing page), and the `child` (which is the widget built by `pageBuilder`). We use a `FadeTransition` here, animating the `opacity` of the incoming page using the `animation` provided.
5.  **`transitionDuration: Duration(milliseconds: 500)`**: This sets how long the transition animation should take.

Now, when you tap the button, the `Navigator` will use this `PageRouteBuilder` to create a `PageRoute`, push it onto the navigation stack, and animate to the `NewScreen` using a 500ms fade effect.

### How it Works Under the Hood (Simplified)

Let's look at a slightly simplified view of what happens when you call `Navigator.push` with a `PageRoute`:

```mermaid
sequenceDiagram
    participant Button as Button Widget
    participant HomeScreen as HomeScreen Widget
    participant Navigator as Navigator
    participant PageRoute as PageRouteBuilder
    participant NewScreen as NewScreen Widget

    Button->HomeScreen: calls onPressed
    HomeScreen->Navigator: calls push(context, PageRoute)
    Navigator->PageRoute: asks for the page content and transitions
    PageRoute->PageRoute: uses pageBuilder to create NewScreen widget
    PageRoute->PageRoute: uses transitionsBuilder to wrap NewScreen with transition widgets
    Navigator->Navigator: Prepares
    Navigator->NewScreen: Builds and animates the transition
```

Essentially, the `Navigator` is like the conductor of an orchestra. You hand it a `PageRoute`, and it orchestrates the process of showing the new screen, including running the transitions defined by the `PageRoute`.

Inside the Flutter framework code for `PageRoute` (like in `packages/flutter/lib/src/widgets/pages.dart`), you'll find methods like `buildPage` and `buildTransitions`. These are the core parts that `PageRouteBuilder` uses its functions (`pageBuilder` and `transitionsBuilder`) to implement:

```dart
// Simplified example from PageRoute (similar to what PageRouteBuilder does internally)
abstract class PageRoute<T> extends ModalRoute<T> {
  // ... other properties ...

  // The PageRoute needs to know how to build the main content
  Widget buildPage(BuildContext context, Animation<double> animation, Animation<double> secondaryAnimation);

  // The PageRoute needs to know how to build the transitions
  Widget buildTransitions(BuildContext context, Animation<double> animation, Animation<double> secondaryAnimation, Widget child);

  // ... more methods for duration, color, etc. ...
}
```

`PageRouteBuilder` fills in these `buildPage` and `buildTransitions` methods using the functions you provide.

### Conclusion

In this chapter, we learned that a `PageRoute` is the fundamental concept in Flutter navigation that defines how a new screen is presented. We saw how to use `PageRouteBuilder` to create a simple `PageRoute` by specifying what the new screen looks like and how the transition should appear.

While `PageRouteBuilder` is great for simple custom transitions, Flutter provides pre-built `PageRoute` implementations for common design patterns, like the Material Design page transitions and the Cupertino (iOS) page transitions. These include standard animations and behaviors.

In the next chapter, we'll dive into one of these standard implementations: [MaterialPageRoute](02_materialpageroute_.md), which provides the familiar animations you see in Android apps.

[Next Chapter: MaterialPageRoute](02_materialpageroute_.md)
---
# Chapter 2: MaterialPageRoute

Welcome back! In [Chapter 1: PageRoute](01_pageroute_.md), we learned that a `PageRoute` is the blueprint for displaying a new screen and defining its transition. We saw how `PageRouteBuilder` let us create custom routes with animations.

Now, let's explore a really common and useful type of `PageRoute` used in Flutter apps that follow Google's Material Design: the `MaterialPageRoute`.

### What is MaterialPageRoute?

If you've ever used an Android phone, you've likely seen specific ways new screens appear when you tap something – often, they fade in and zoom slightly. `MaterialPageRoute` is designed to give you that native Android look and feel for your screen transitions, *automatically*.

Think of it as a pre-made `PageRoute` specifically built for Material Design. Instead of defining the fade/zoom transition yourself with `PageRouteBuilder`, `MaterialPageRoute` handles it for you.

But here's a cool trick: `MaterialPageRoute` is also platform-adaptive! This means that if you run your app on an iOS device, it will automatically use the standard iOS slide-from-the-right transition. You get the right native feel on both Android and iOS with just one `MaterialPageRoute`!

**Motivation:** We want to navigate from our `HomeScreen` to our `NewScreen` using the standard Material Design (Android-style) transitions on Android and the standard Cupertino (iOS-style) transitions on iOS, without manually building the transition animation ourselves.

### Using MaterialPageRoute

Using `MaterialPageRoute` is much simpler than `PageRouteBuilder` for standard transitions. You just need to tell it *what* screen to build.

Let's go back to our
`HomeScreen` button's `onPressed` and replace the `PageRouteBuilder` with a `MaterialPageRoute`:

```dart
// ... inside HomeScreen onPressed ...
onPressed: () {
  Navigator.push(
    context,
    MaterialPageRoute( // Using MaterialPageRoute!
      builder: (context) {
        // Just provide the widget for the new screen
        return NewScreen();
      },
    ),
  );
},
// ... rest of HomeScreen ...
```

That's it! Notice how much simpler it is?

*   We still use `Navigator.push` to initiate the navigation.
*   We create a `MaterialPageRoute` instance.
*   We provide a `builder` function, which is similar to `pageBuilder` in `PageRouteBuilder`. This function simply returns the widget for the new screen (`NewScreen`).
*   We *don't* need to specify a `transitionsBuilder` or `transitionDuration` explicitly. `MaterialPageRoute` uses default ones suitable for Material Design, chosen automatically based on the device's operating system.

Now, when you tap the button:
*   On an Android device, `NewScreen` will fade in and slightly zoom.
*   On an iOS device, `NewScreen` will slide in from the right.

### How it Works Under the Hood (Simplified)

When you use `MaterialPageRoute`, like with any `PageRoute`, you hand it to the `Navigator`.

```mermaid
sequenceDiagram
    participant Button as Button Widget
    participant HomeScreen as HomeScreen Widget
    participant Navigator as Navigator
    participant MaterialPageRoute as MaterialPageRoute
    participant NewScreen as NewScreen Widget
    participant Theme as Theme Data

    Button->HomeScreen: calls onPressed
    HomeScreen->Navigator: calls push(context, MaterialPageRoute)
    Navigator->MaterialPageRoute: asks for page content and transitions
    MaterialPageRoute->MaterialPageRoute: calls builder() to create NewScreen widget
    MaterialPageRoute->Theme: checks current platform (Android/iOS)
    MaterialPageRoute->MaterialPageRoute: selects relevant transition based on platform
    MaterialPageRoute->NewScreen: Builds and wraps with selected transition widgets
    Navigator->Navigator: Prepares
    Navigator->NewScreen: Animates the transition
```

The key difference from using `PageRouteBuilder` with a custom fade is that `MaterialPageRoute` internally checks the theme and the platform to pick the right animation blueprint.

Let's peek into the Flutter framework code for `MaterialPageRoute` in `packages/flutter/lib/src/material/page.dart`.

You'll see the `MaterialPageRoute` class definition inherits from `PageRoute` and also uses something called `MaterialRouteTransitionMixin` (we'll talk about mixins more later, but for now, think of it as sharing helpful code).

```dart
// Simplified from packages/flutter/lib/src/material/page.dart
class MaterialPageRoute<T> extends PageRoute<T> with MaterialRouteTransitionMixin<T> {
  // ... constructor and other properties ...

  /// Builds the primary contents of the route.
  final WidgetBuilder builder; // This holds the function you passed in!

  @override
  Widget buildContent(BuildContext context) => builder(context); // Uses your builder

  // ... other overrides ...
}
```

The `buildContent` method is where your `builder` function is called to create the `NewScreen` widget.

Where does the platform-adaptive transition logic come from? It's mostly handled by the `MaterialRouteTransitionMixin` and interacts with Flutter's `Theme` and `PageTransitionsTheme`.

```dart
// Simplified/conceptual example from MaterialRouteTransitionMixin
mixin MaterialRouteTransitionMixin<T> on PageRoute<T> {
  // ... other properties ...

  @override
  Widget buildTransitions( // This is where the transition is built!
    BuildContext context,
    Animation<double> animation,
    Animation<double> secondaryAnimation,
    Widget child, // This 'child' is the widget from buildContent (your NewScreen)
  ) {
    // Internally looks at Theme.of(context).platform (Android or iOS)
    // Then looks up the correct transition from Theme.of(context).pageTransitionsTheme
    // Returns the correct transition widget (like a FadeTransition for Android,
    // or a SlideTransition for iOS) wrapping the 'child' (your screen).
    final PageTransitionsTheme theme = Theme.of(context).pageTransitionsTheme;
    return theme.buildTransitions<T>(this, context, animation, secondaryAnimation, child);
  }

  // ... other properties like transitionDuration ...
}
```

So, `MaterialPageRoute` uses the `builder` you provide to show the content and relies on the `MaterialRouteTransitionMixin` (and Flutter's theming system) to automatically select and apply the right transition animation based on the device's platform.

### Conclusion

`MaterialPageRoute` is your go-to `PageRoute` when you want standard Material Design page transitions (fade/zoom on Android, slide on iOS) without needing to manually define the animations. It simplifies the process of creating new routes by providing sensible defaults that match platform conventions. It's a foundational component for navigation in many Flutter applications.

In the next chapter, we'll take a brief look at the `MaterialRouteTransitionMixin` itself, which is the piece that provides the magic platform-adaptive transitions for `MaterialPageRoute`.

[Next Chapter: MaterialRouteTransitionMixin](03_materialroutetransitionmixin_.md)
---
# Chapter 3: MaterialRouteTransitionMixin

Welcome back! In [Chapter 2: MaterialPageRoute](02_materialpageroute_.md), we learned how `MaterialPageRoute` gives us those sweet, platform-adaptive screen transitions (fade/zoom on Android, slide on iOS) without us having to code the animations ourselves.

We briefly saw that the code for `MaterialPageRoute` includes something called `with MaterialRouteTransitionMixin`. This chapter is about that `MaterialRouteTransitionMixin`.

### What is MaterialRouteTransitionMixin?

Imagine you have a recipe for delicious cookies. The recipe lists all the ingredients and the steps. A "mixin" in Flutter is like a list of extra ingredients and techniques you can add to your recipe to make it special.

`MaterialRouteTransitionMixin` is not a complete recipe (it's not a full `PageRoute` itself), but it's a collection of "ingredients" and "techniques" specifically for creating **Material Design page transitions** that adapt to the platform.

It provides the core logic for:

1.  **How long** the transition should take (duration).
2.  **How the animation looks** (the transition effect itself, like fading or sliding).
3.  **How this route interacts** with other routes during transitions (can they transition together smoothly?).

Essentially, `MaterialRouteTransitionMixin` is the helper that `MaterialPageRoute` uses to get its standard, platform-adaptive transition behavior. It's what makes `MaterialPageRoute` special!

You won't usually create a `MaterialRouteTransitionMixin` directly. Instead, you'll see other `PageRoute` implementations (like `MaterialPageRoute`) "mix it in" to gain its transition capabilities.

**Motivation:** Our goal is to understand where the automatic, platform-adaptive transition logic in `MaterialPageRoute` comes from. It comes from `MaterialRouteTransitionMixin`.

### How Mixins Work (Simply)

Think of a mixin as a way to share code between different classes without using traditional inheritance (like a child class inheriting from a parent class).

If you have `ClassA` and `MixinB`, `ClassA` can use `MixinB`'s methods and properties by saying `class ClassA with MixinB`. It's like `ClassA` is adding `MixinB`'s features to itself.

In our case, `MaterialPageRoute` is a class, and it uses `MaterialRouteTransitionMixin` like this:

```dart
// Simplified
class MaterialPageRoute<T> extends PageRoute<T> with MaterialRouteTransitionMixin<T> {
  // MaterialPageRoute now has access to the methods inside MaterialRouteTransitionMixin
  // ... rest of MaterialPageRoute code ...
}
```

By using `with MaterialRouteTransitionMixin`, `MaterialPageRoute` automatically gains the `buildTransitions` method and other transition-related logic defined within the mixin.

### How it Connects to Building Transitions

Remember in [Chapter 1: PageRoute](01_pageroute_.md), we saw that a `PageRoute` needs to implement a `buildTransitions` method to define how the animation looks?

`MaterialRouteTransitionMixin` provides the **implementation** for this crucial `buildTransitions` method for Material Design transitions.

When `Navigator.push` is called with a `MaterialPageRoute`, the Navigator asks the `MaterialPageRoute` (which uses `MaterialRouteTransitionMixin`'s logic) to build the transition widget tree.

Here's a look inside the mixin (simplified):

```dart
// Simplified/conceptual example from packages/flutter/lib/src/material/page.dart
mixin MaterialRouteTransitionMixin<T> on PageRoute<T> {
  // ... other properties like transitionDuration ...

  @override
  Widget buildTransitions( // This method is provided by the mixin!
    BuildContext context,
    Animation<double> animation, // Animation for the incoming page
    Animation<double> secondaryAnimation, // Animation for the outgoing page
    Widget child, // The actual content of the page (your NewScreen)
  ) {
    // Inside here, the mixin's code runs.
    // It checks the platform (Android/iOS) using Theme.of(context).platform.
    // It looks up the correct transition animation based on the platform
    // from the PageTransitionsTheme.
    // It returns the chosen animation widget (like FadeTransition or SlideTransition)
    // wrapping the 'child' (your NewScreen widget).

    // This line is the core – it asks the Theme for the right transition!
    final PageTransitionsTheme theme = Theme.of(context).pageTransitionsTheme;
    return theme.buildTransitions<T>(this, context, animation, secondaryAnimation, child);
  }

  // ... other methods ...
}
```

So, `MaterialRouteTransitionMixin` contains the `buildTransitions` method that looks at the current `Theme` (which knows the platform) and asks the `PageTransitionsTheme` within the `Theme` to provide the actual transition widget code.

This design is clever because:
*   `MaterialPageRoute` handles knowing *what* screen to show (`builder`).
*   `MaterialRouteTransitionMixin` handles knowing *how* to transition, querying the `Theme` for the platform-specific implementation.
*   The `PageTransitionsTheme` holds the actual animation builders (like the code for the fade/zoom or the slide animations).

This separation of concerns makes the code more organized and maintainable!

### You Don't Use It Directly (Usually)

As a beginner, you won't typically need to directly use `MaterialRouteTransitionMixin`. Its purpose is to provide the transition logic *to* classes like `MaterialPageRoute`. When you use `MaterialPageRoute`, you are indirectly benefiting from the code in `MaterialRouteTransitionMixin`.

Think of it like buying a car. You use the steering wheel and pedals (`MaterialPageRoute`), and the engine ("mixin") makes it go, but you don't interact directly with the engine parts every time you drive.

### Conclusion

`MaterialRouteTransitionMixin` is a key piece of the puzzle behind `MaterialPageRoute`'s automatic, platform-adaptive transitions. It provides the core logic for determining transition duration and building the correct transition animation based on the device's operating system by interacting with the Flutter `Theme` system. While you won't often use it directly, understanding its role helps clarify how `MaterialPageRoute` works.

In the next chapter, we'll shift our focus to the iOS side of things and introduce `CupertinoPageRoute`, which is the counterpart to `MaterialPageRoute` for Cupertino (iOS) design.

[Next Chapter: CupertinoPageRoute](04_cupertinopageroute_.md)
---
# Chapter 4: CupertinoPageRoute

Welcome back, future Flutter navigators! In [Chapter 3: MaterialRouteTransitionMixin](03_materialroutetransitionmixin_.md), we explored how `MaterialRouteTransitionMixin` is the helper that gives `MaterialPageRoute` its cool, platform-adaptive animations. Now, let's turn our attention to the world of Apple's iOS design with `CupertinoPageRoute`.

### What is CupertinoPageRoute?

If you've ever used an iPhone or iPad, you've seen specific ways new screens slide into view, often from the right side of the screen, and how they slide back out when you go back. `CupertinoPageRoute` is Flutter's way of giving you that exact native iOS look and feel for your screen transitions, automatically!

Just like `MaterialPageRoute` is a pre-made blueprint for Material Design transitions, `CupertinoPageRoute` is a pre-made blueprint specifically built for Cupertino (iOS) design. It handles the characteristic sliding animations and other iOS visual cues when you navigate between pages.

**Motivation:** Our goal is to navigate from our `HomeScreen` to our `NewScreen` using the standard iOS slide-from-the-right transition when running on an iOS device, in a way that is natural and expected for iOS users.

### Using CupertinoPageRoute

Using `CupertinoPageRoute` is very similar to using `MaterialPageRoute`. You simply tell it which widget represents the new screen.

Let's go back to our `HomeScreen` button's `onPressed` and replace the `MaterialPageRoute` with a `CupertinoPageRoute`:

```dart
import 'package:flutter/cupertino.dart'; // Import Cupertino widgets!
import 'package:flutter/material.dart'; // Still need Material for Scaffold, AppBar, etc.

// ... rest of MyApp and HomeScreen classes ...

class HomeScreen extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return Scaffold( // Using Material Scaffold for simplicity in this example
      appBar: AppBar(title: Text('Home Screen')),
      body: Center(
        child: ElevatedButton(
          onPressed: () {
            Navigator.push(
              context,
              CupertinoPageRoute( // Using CupertinoPageRoute!
                builder: (context) {
                  // Just provide the widget for the new screen
                  return NewScreen();
                },
              ),
            );
          },
          child: Text('Go to New Screen'),
        ),
      ),
    );
  }
}

// ... rest of NewScreen class ...
```

See the difference? We changed `MaterialPageRoute` to `CupertinoPageRoute` and made sure to import `flutter/cupertino.dart`.

Now, when you tap the button:

*   On an iOS device, `NewScreen` will smoothly slide in from the right, with the previous screen slightly moving to the left (a parallax effect). When you go back, it slides out to the right.
*   On an Android device, because we're using a `CupertinoPageRoute`, it will *still* try to use the Cupertino (iOS) style transition, even though it's running on Android. This is different from `MaterialPageRoute` which is platform-adaptive. If you want platform-adaptive behavior, `MaterialPageRoute` is often the better choice. `CupertinoPageRoute` is primarily for building apps that *always* have the iOS feel.

### How it Works Under the Hood (Simplified)

When you use `CupertinoPageRoute`, you hand it to the `Navigator` just like any other `PageRoute`.

```mermaid
sequenceDiagram
    participant Button as Button Widget
    participant HomeScreen as HomeScreen Widget
    participant Navigator as Navigator
    participant CupertinoPageRoute as CupertinoPageRoute
    participant NewScreen as NewScreen Widget
    participant iOS Theme as iOS Theme Data (Conceptual)

    Button->HomeScreen: calls onPressed
    HomeScreen->Navigator: calls push(context, CupertinoPageRoute)
    Navigator->CupertinoPageRoute: asks for page content and transitions
    CupertinoPageRoute->CupertinoPageRoute: calls builder() to create NewScreen widget
    CupertinoPageRoute->iOS Theme: Requests iOS-style transition details
    CupertinoPageRoute->CupertinoPageRoute: Uses transition logic from mixin
    CupertinoPageRoute->NewScreen: Builds and wraps with Cupertino transition widgets
    Navigator->Navigator: Prepares
    Navigator->NewScreen: Animates the transition (iOS style)
```

The process is very similar to `MaterialPageRoute`, but instead of checking the general platform to pick between Material and Cupertino, `CupertinoPageRoute` *always* uses the Cupertino style transition logic.

Let's peek into the Flutter framework code for `CupertinoPageRoute` in `packages/flutter/lib/src/cupertino/route.dart`.

You'll find the `CupertinoPageRoute` class definition inherits from `PageRoute` and, just like `MaterialPageRoute` uses a mixin for its transitions, `CupertinoPageRoute` uses something similar: `CupertinoRouteTransitionMixin`.

```dart
// Simplified from packages/flutter/lib/src/cupertino/route.dart
class CupertinoPageRoute<T> extends PageRoute<T> with CupertinoRouteTransitionMixin<T> {
  // ... constructor and other properties ...

  /// Builds the primary contents of the route.
  final WidgetBuilder builder; // This holds the function you passed in!

  @override
  Widget buildContent(BuildContext context) => builder(context); // Uses your builder

  // ... other overrides ...
}
```

Similar to `MaterialPageRoute`, `CupertinoPageRoute` takes your `builder` function and calls its `buildContent` method to create the widget for the new page.

The iOS-style transition magic (the sliding from the right, the parallax effect) comes from the `CupertinoRouteTransitionMixin` that is mixed into `CupertinoPageRoute`. This mixin implements the `buildTransitions` method using specific iOS animations:

```dart
// Simplified/conceptual example from CupertinoRouteTransitionMixin
mixin CupertinoRouteTransitionMixin<T> on PageRoute<T> {
  // ... other properties like transitionDuration ...

  @override
  Widget buildTransitions( // This method is provided by the mixin!
    BuildContext context,
    Animation<double> animation, // Animation for the incoming page
    Animation<double> secondaryAnimation, // Animation for the outgoing page
    Widget child, // The actual content of the page (your NewScreen)
  ) {
    // Inside here, the mixin's code runs.
    // It builds specific iOS transition widgets...
    // For normal pages, it uses CupertinoPageTransition.
    // For fullscreen dialogs, it uses CupertinoFullscreenDialogTransition.
    // It uses the animations (primaryRouteAnimation and secondaryRouteAnimation)
    // and wraps the 'child' (your NewScreen widget) with them.

    // A simplified call to the actual transition builder:
    return buildPageTransitions<T>(this, context, animation, secondaryAnimation, child);
  }

  // ... other methods ...
}
```

When the `Navigator` needs to show `CupertinoPageRoute`, it asks the route to `buildTransitions`. `CupertinoPageRoute` uses the `buildTransitions` method from `CupertinoRouteTransitionMixin`. This mixin then uses dedicated transition widgets like `CupertinoPageTransition` to create the visually distinct iOS sliding effect, using the provided `animation` objects to control the movement. We'll learn more about `CupertinoPageTransition` in a later chapter.

`CupertinoPageRoute` also has support for distinguishing between regular page transitions and fullscreen dialog transitions (like presenting a modal from the bottom on iOS), using different animation styles for each case, which is also handled by the `CupertinoRouteTransitionMixin`.

### Conclusion

`CupertinoPageRoute` is the specialized `PageRoute` for bringing the native iOS page transition experience (sliding from the right, parallax effect) to your Flutter apps, regardless of the actual device platform. It uses the `CupertinoRouteTransitionMixin` to manage the transition logic and apply the appropriate iOS-style animations. While `MaterialPageRoute` is usually preferred for platform-adaptive behavior in a single codebase, `CupertinoPageRoute` is perfect when you want a consistent iOS feel.

In the next chapter, we'll dive deeper into the `CupertinoRouteTransitionMixin` itself, similar to how we looked at its Material counterpart, to see exactly where this iOS transition magic comes from.

[Next Chapter: CupertinoRouteTransitionMixin](05_cupertinoroutetransitionmixin_.md)

Relevant Code Snippets (Code itself remains unchanged):
--- File: packages/flutter/lib/src/cupertino/route.dart ---
// Copyright 2014 The Flutter Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

/// @docImport 'dart:ui';
///
/// @docImport 'package:flutter/material.dart';
/// @docImport 'package:flutter/services.dart';
///
/// @docImport 'app.dart';
/// @docImport 'button.dart';
/// @docImport 'dialog.dart';
/// @docImport 'nav_bar.dart';
/// @docImport 'page_scaffold.dart';
/// @docImport 'tab_scaffold.dart';
library;

import 'dart:math';
import 'dart:ui' show ImageFilter;

import 'package:flutter/foundation.dart';
import 'package:flutter/gestures.dart';
import 'package:flutter/physics.dart';
import 'package:flutter/rendering.dart';
import 'package:flutter/widgets.dart';

import 'colors.dart';
import 'interface_level.dart';
import 'localizations.dart';

const double _kBackGestureWidth = 20.0;
const double _kMinFlingVelocity = 1.0; // Screen widths per second.

// The duration for a page to animate when the user releases it mid-swipe.
const Duration _kDroppedSwipePageAnimationDuration = Duration(milliseconds: 350);

/// Barrier color used for a barrier visible during transitions for Cupertino
/// page routes.
///
/// This barrier color is only used for full-screen page routes with
/// `fullscreenDialog: false`.
///
/// By default, `fullscreenDialog` Cupertino route transitions have no
/// `barrierColor`, and [CupertinoDialogRoute]s and [CupertinoModalPopupRoute]s
/// have a `barrierColor` defined by [kCupertinoModalBarrierColor].
///
/// A relatively rigorous eyeball estimation.
const Color _kCupertinoPageTransitionBarrierColor = Color(0x18000000);

/// Barrier color for a Cupertino modal barrier.
///
/// Extracted from https://developer.apple.com/design/resources/.
const Color kCupertinoModalBarrierColor = CupertinoDynamicColor.withBrightness(
  color: Color(0x33000000),
  darkColor: Color(0x7A000000),
);

// The duration of the transition used when a modal popup is shown.
const Duration _kModalPopupTransitionDuration = Duration(milliseconds: 335);

// Offset from offscreen to the right to fully on screen.
final Animatable<Offset> _kRightMiddleTween = Tween<Offset>(
  begin: const Offset(1.0, 0.0),
  end: Offset.zero,
);

// Offset from fully on screen to 1/3 offscreen to the left.
final Animatable<Offset> _kMiddleLeftTween = Tween<Offset>(
  begin: Offset.zero,
  end: const Offset(-1.0 / 3.0, 0.0),
);

// Offset from offscreen below to fully on screen.
final Animatable<Offset> _kBottomUpTween = Tween<Offset>(
  begin: const Offset(0.0, 1.0),
  end: Offset.zero,
);

/// A mixin that replaces the entire screen with an iOS transition for a
/// [PageRoute].
///
/// {@template flutter.cupertino.cupertinoRouteTransitionMixin}
/// The page slides in from the right and exits in reverse. The page also shifts
/// to the left in parallax when another page enters to cover it.
///
/// The page slides in from the bottom and exits in reverse with no parallax
/// effect for fullscreen dialogs.
/// {@endtemplate}
///
/// See also:
///
///  * [MaterialRouteTransitionMixin], which is a mixin that provides
///    platform-appropriate transitions for a [PageRoute].
///  * [CupertinoPageRoute], which is a [PageRoute] that leverages this mixin.
mixin CupertinoRouteTransitionMixin<T> on PageRoute<T> {
  /// Builds the primary contents of the route.
  @protected
  Widget buildContent(BuildContext context);

  /// {@template flutter.cupertino.CupertinoRouteTransitionMixin.title}
  /// A title string for this route.
  ///
  /// Used to auto-populate [CupertinoNavigationBar] and
  /// [CupertinoSliverNavigationBar]'s `middle`/`largeTitle` widgets when
  /// one is not manually supplied.
  /// {@endtemplate}
  String? get title;

  ValueNotifier<String?>? _previousTitle;

  /// The title string of the previous [CupertinoPageRoute].
  ///
  /// The [ValueListenable]'s value is readable after the route is installed
  /// onto a [Navigator]. The [ValueListenable] will also notify its listeners
  /// if the value changes (such as by replacing the previous route).
  ///
  /// The [ValueListenable] itself will be null before the route is installed.
  /// Its content value will be null if the previous route has no title or
  /// is not a [CupertinoPageRoute].
  ///
  /// See also:
  ///
  ///  * [ValueListenableBuilder], which can be used to listen and rebuild
  ///    widgets based on a ValueListenable.
  ValueListenable<String?> get previousTitle {
    assert(
      _previousTitle != null,
      'Cannot read the previousTitle for a route that has not yet been installed',
    );
    return _previousTitle!;
  }

  @override
  void dispose() {
    _previousTitle?.dispose();
    super.dispose();
  }

  @override
  void didChangePrevious(Route<dynamic>? previousRoute) {
    final String? previousTitleString =
        previousRoute is CupertinoRouteTransitionMixin ? previousRoute.title : null;
    if (_previousTitle == null) {
      _previousTitle = ValueNotifier<String?>(previousTitleString);
    } else {
      _previousTitle!.value = previousTitleString;
    }
    super.didChangePrevious(previousRoute);
  }

  @override
  // A relatively rigorous eyeball estimation.
  Duration get transitionDuration => const Duration(milliseconds: 500);

  @override
  Color? get barrierColor => fullscreenDialog ? null : _kCupertinoPageTransitionBarrierColor;

  @override
  String? get barrierLabel => null;

  @override
  bool canTransitionTo(TransitionRoute<dynamic> nextRoute) {
    // Don't perform outgoing animation if the next route is a fullscreen dialog.
    final bool nextRouteIsNotFullscreen =
        (nextRoute is! PageRoute<T>) || !nextRoute.fullscreenDialog;

    // If the next route has a delegated transition, then this route is able to
    // use that delegated transition to smoothly sync with the next route's
    // transition.
    final bool nextRouteHasDelegatedTransition =
        nextRoute is ModalRoute<T> && nextRoute.delegatedTransition != null;

    // Otherwise if the next route has the same route transition mixin as this
    // one, then this route will already be synced with its transition.
    return nextRouteIsNotFullscreen &&
        ((nextRoute is CupertinoRouteTransitionMixin) || nextRouteHasDelegatedTransition);
  }

  @override
  bool canTransitionFrom(TransitionRoute<dynamic> previousRoute) {
    // Supress previous route from transitioning if this is a fullscreenDialog route.
    return previousRoute is PageRoute && !fullscreenDialog;
  }

  @override
  Widget buildPage(
    BuildContext context,
    Animation<double> animation,
    Animation<double> secondaryAnimation,
  ) {
    final Widget child = buildContent(context);
    return Semantics(scopesRoute: true, explicitChildNodes: true, child: child);
  }

  // Called by _CupertinoBackGestureDetector when a pop ("back") drag start
  // gesture is detected. The returned controller handles all of the subsequent
  // drag events.
  static _CupertinoBackGestureController<T> _startPopGesture<T>(PageRoute<T> route) {
    assert(route.popGestureEnabled);

    return _CupertinoBackGestureController<T>(
      navigator: route.navigator!,
      getIsCurrent: () => route.isCurrent,
      getIsActive: () => route.isActive,
      controller: route.controller!, // protected access
    );
  }

  /// Returns a [CupertinoFullscreenDialogTransition] if [route] is a full
  /// screen dialog, otherwise a [CupertinoPageTransition] is returned.
  ///
  /// Used by [CupertinoPageRoute.buildTransitions].
  ///
  /// This method can be applied to any [PageRoute], not just
  /// [CupertinoPageRoute]. It's typically used to provide a Cupertino style
  /// horizontal transition for material widgets when the target platform
  /// is [TargetPlatform.iOS].
  ///
  /// See also:
  ///
  ///  * [CupertinoPageTransitionsBuilder], which uses this method to define a
  ///    [PageTransitionsBuilder] for the [PageTransitionsTheme].
  static Widget buildPageTransitions<T>(
    PageRoute<T> route,
    BuildContext context,
    Animation<double> animation,
    Animation<double> secondaryAnimation,
    Widget child,
  ) {
    // Check if the route has an animation that's currently participating
    // in a back swipe gesture.
    //
    // In the middle of a back gesture drag, let the transition be linear to
    // match finger motions.
    final bool linearTransition = route.popGestureInProgress;
    if (route.fullscreenDialog) {
      return CupertinoFullscreenDialogTransition(
        primaryRouteAnimation: animation,
        secondaryRouteAnimation: secondaryAnimation,
        linearTransition: linearTransition,
        child: child,
      );
    } else {
      return CupertinoPageTransition(
        primaryRouteAnimation: animation,
        secondaryRouteAnimation: secondaryAnimation,
        linearTransition: linearTransition,
        child: _CupertinoBackGestureDetector<T>(
          enabledCallback: () => route.popGestureEnabled,
          onStartPopGesture: () => _startPopGesture<T>(route),
          child: child,
        ),
      );
    }
  }

  @override
  Widget buildTransitions(
    BuildContext context,
    Animation<double> animation,
    Animation<double> secondaryAnimation,
    Widget child,
  ) {
    return buildPageTransitions<T>(this, context, animation, secondaryAnimation, child);
  }
}

/// A modal route that replaces the entire screen with an iOS transition.
///
/// {@macro flutter.cupertino.cupertinoRouteTransitionMixin}
///
/// By default, when a modal route is replaced by another, the previous route
/// remains in memory. To free all the resources when this is not necessary, set
/// [maintainState] to false.
///
/// The type `T` specifies the return type of the route which can be supplied as
/// the route is popped from the stack via [Navigator.pop] when an optional
/// `result` can be provided.
///
/// If `barrierDismissible` is true, then pressing the escape key on the keyboard
/// will cause the current route to be popped with null as the value.
///
/// See also:
///
///  * [CupertinoRouteTransitionMixin], for a mixin that provides iOS transition
///    for this modal route.
///  * [MaterialPageRoute], for an adaptive [PageRoute] that uses a
///    platform-appropriate transition.
///  * [CupertinoPageScaffold], for applications that have one page with a fixed
///    navigation bar on top.
///  * [CupertinoTabScaffold], for applications that have a tab bar at the
///    bottom with multiple pages.
///  * [CupertinoPage], for a [Page] version of this class.
class CupertinoPageRoute<T> extends PageRoute<T> with CupertinoRouteTransitionMixin<T> {
  /// Creates a page route for use in an iOS designed app.
  ///
  /// The [builder], [maintainState], and [fullscreenDialog] arguments must not
  /// be null.
  CupertinoPageRoute({
    required this.builder,
    this.title,
    super.settings,
    super.requestFocus,
    this.maintainState = true,
    super.fullscreenDialog,
    super.allowSnapshotting = true,
    super.barrierDismissible = false,
  }) {
    assert(opaque);
  }

  @override
  DelegatedTransitionBuilder? get delegatedTransition =>
      CupertinoPageTransition.delegatedTransition;

  /// Builds the primary contents of the route.
  final WidgetBuilder builder;

  @override
  Widget buildContent(BuildContext context) => builder(context);

  @override
  final String? title;

  @override
  final bool maintainState;

  @override
  String get debugLabel => '${super.debugLabel}(${settings.name})';
}

// A page-based version of CupertinoPageRoute.
//
// This route uses the builder from the page to build its content. This ensures
// the content is up to date after page updates.
class _PageBasedCupertinoPageRoute<T> extends PageRoute<T> with CupertinoRouteTransitionMixin<T> {
  _PageBasedCupertinoPageRoute({required CupertinoPage<T> page, super.allowSnapshotting = true})
    : super(settings: page) {
    assert(opaque);
  }

  @override
  DelegatedTransitionBuilder? get delegatedTransition =>
      this.fullscreenDialog ? null : CupertinoPageTransition.delegatedTransition;

  CupertinoPage<T> get _page => settings as CupertinoPage<T>;

  @override
  Widget buildContent(BuildContext context) => _page.child;

  @override
  String? get title => _page.title;

  @override
  bool get maintainState => _page.maintainState;

  @override
  bool get fullscreenDialog => _page.fullscreenDialog;

  @override
  String get debugLabel => '${super.debugLabel}(${_page.name})';
}

/// A page that creates a cupertino style [PageRoute].
///
/// {@macro flutter.cupertino.cupertinoRouteTransitionMixin}
///
/// By default, when a created modal route is replaced by another, the previous
/// route remains in memory. To free all the resources when this is not
/// necessary, set [maintainState] to false.
///
/// The type `T` specifies the return type of the route which can be supplied as
/// the route is popped from the stack via [Navigator.transitionDelegate] by
/// providing the optional `result` argument to the
/// [RouteTransitionRecord.markForPop] in the [TransitionDelegate.resolve].
///
/// See also:
///
///  * [CupertinoPageRoute], for a [PageRoute] version of this class.
class CupertinoPage<T> extends Page<T> {
  /// Creates a cupertino page.
  const CupertinoPage({
    required this.child,
    this.maintainState = true,
    this.title,
    this.fullscreenDialog = false,
    this.allowSnapshotting = true,
    super.canPop,
    super.onPopInvoked,
    super.key,
    super.name,
    super.arguments,
    super.restorationId,
  });

  /// The content to be shown in the [Route] created by this page.
  final Widget child;

  /// {@macro flutter.cupertino.CupertinoRouteTransitionMixin.title}
  final String? title;

  /// {@macro flutter.widgets.ModalRoute.maintainState}
  final bool maintainState;

  /// {@macro flutter.widgets.PageRoute.fullscreenDialog}
  final bool fullscreenDialog;

  /// {@macro flutter.widgets.TransitionRoute.allowSnapshotting}
  final bool allowSnapshotting;

  @override
  Route<T> createRoute(BuildContext context) {
    return _PageBasedCupertinoPageRoute<T>(page: this, allowSnapshotting: allowSnapshotting);
  }
}

/// Provides an iOS-style page transition animation.
///
/// The page slides in from the right and exits in reverse. It also shifts to the left in
/// a parallax motion when another page enters to cover it.
class CupertinoPageTransition extends StatefulWidget {
  /// Creates an iOS-style page transition.
  ///
  const CupertinoPageTransition({
    super.key,
    required this.primaryRouteAnimation,
    required this.secondaryRouteAnimation,
    required this.child,
    required this.linearTransition,
  });

  /// The widget below this widget in the tree.
  final Widget child;

  ///  * `primaryRouteAnimation` is a linear route animation from 0.0 to 1.0
  ///    when this screen is being pushed.
  final Animation<double> primaryRouteAnimation;

  ///  * `secondaryRouteAnimation` is a linear route animation from 0.0 to 1.0
  ///    when another screen is being pushed on top of this one.
  final Animation<double> secondaryRouteAnimation;

  ///  * `linearTransition` is whether to perform the transitions linearly.
  ///    Used to precisely track back gesture drags.
  final bool linearTransition;

  /// The Cupertino styled [DelegatedTransitionBuilder] provided to the previous
  /// route.
  ///
  /// {@macro flutter.widgets.delegatedTransition}
  static Widget? delegatedTransition(
    BuildContext context,
    Animation<double> animation,
    Animation<double> secondaryAnimation,
    bool allowSnapshotting,
    Widget? child,
  ) {
    final CurvedAnimation animation = CurvedAnimation(
      parent: secondaryAnimation,
      curve: Curves.linearToEaseOut,
      reverseCurve: Curves.easeInToLinear,
    );
    final Animation<Offset> delegatedPositionAnimation = animation.drive(_kMiddleLeftTween);
    animation.dispose();

    assert(debugCheckHasDirectionality(context));
    final TextDirection textDirection = Directionality.of(context);
    return SlideTransition(
      position: delegatedPositionAnimation,
      textDirection: textDirection,
      transformHitTests: false,
      child: child,
    );
  }

  @override
  State<CupertinoPageTransition> createState() => _CupertinoPageTransitionState();
}

class _CupertinoPageTransitionState extends State<CupertinoPageTransition> {
  // When this page is coming in to cover another page.
  late Animation<Offset> _primaryPositionAnimation;
  // When this page is becoming covered by another page.
  late Animation<Offset> _secondaryPositionAnimation;
  // Shadow of page which is coming in to cover another page.
  late Animation<Decoration> _primaryShadowAnimation;
  // Curve of primary page which is coming in to cover another page.
  CurvedAnimation? _primaryPositionCurve;
  // Curve of secondary page which is becoming covered by another page.
  CurvedAnimation? _secondaryPositionCurve;
  // Curve of primary page's shadow.
  CurvedAnimation? _primaryShadowCurve;

  @override
  void initState() {
    super.initState();
    _setupAnimation();
  }

  @override
  void didUpdateWidget(covariant CupertinoPageTransition oldWidget) {
    super.didUpdateWidget(oldWidget);
    if (oldWidget.primaryRouteAnimation != widget.primaryRouteAnimation ||
        oldWidget.secondaryRouteAnimation != widget.secondaryRouteAnimation ||
        oldWidget.linearTransition != widget.linearTransition) {
      _disposeCurve();
      _setupAnimation();
    }
  }

  @override
  void dispose() {
    _disposeCurve();
    super.dispose();
  }

  void _disposeCurve() {
    _primaryPositionCurve?.dispose();
    _secondaryPositionCurve?.dispose();
    _primaryShadowCurve?.dispose();
    _primaryPositionCurve = null;
    _secondaryPositionCurve = null;
    _primaryShadowCurve = null;
  }

  void _setupAnimation() {
    if (!widget.linearTransition) {
      _primaryPositionCurve = CurvedAnimation(
        parent: widget.primaryRouteAnimation,
        curve: Curves.fastEaseInToSlowEaseOut,
        reverseCurve: Curves.fastEaseInToSlowEaseOut.flipped,
      );
      _secondaryPositionCurve = CurvedAnimation(
        parent: widget.secondaryRouteAnimation,
        curve: Curves.linearToEaseOut,
        reverseCurve: Curves.easeInToLinear,
      );
      _primaryShadowCurve = CurvedAnimation(
        parent: widget.primaryRouteAnimation,
        curve: Curves.linearToEaseOut,
      );
    }
    _primaryPositionAnimation = (_primaryPositionCurve ?? widget.primaryRouteAnimation).drive(
      _kRightMiddleTween,
    );
    _secondaryPositionAnimation = (_secondaryPositionCurve ?? widget.secondaryRouteAnimation).drive(
      _kMiddleLeftTween,
    );
    _primaryShadowAnimation = (_primaryShadowCurve ?? widget.primaryRouteAnimation).drive(
      _CupertinoEdgeShadowDecoration.kTween,
    );
  }

  @override
  Widget build(BuildContext context) {
    assert(debugCheckHasDirectionality(context));
    final TextDirection textDirection = Directionality.of(context);
    return SlideTransition(
      position: _secondaryPositionAnimation,
      textDirection: textDirection,
      transformHitTests: false,
      child: SlideTransition(
        position: _primaryPositionAnimation,
        textDirection: textDirection,
        child: DecoratedBoxTransition(decoration: _primaryShadowAnimation, child: widget.child),
      ),
    );
  }
}

/// An iOS-style transition used for summoning fullscreen dialogs.
///
/// For example, used when creating a new calendar event by bringing in the next
/// screen from the bottom.
class CupertinoFullscreenDialogTransition extends StatefulWidget {
  /// Creates an iOS-style transition used for summoning fullscreen dialogs.
  ///
  const CupertinoFullscreenDialogTransition({
    super.key,
    required this.primaryRouteAnimation,
    required this.secondaryRouteAnimation,
    required this.child,
    required this.linearTransition,
  });

  ///  * `primaryRouteAnimation` is a linear route animation from 0.0 to 1.0
  ///    when this screen is being pushed.
  final Animation<double> primaryRouteAnimation;

  ///  * `secondaryRouteAnimation` is a linear route animation from 0.0 to 1.0
  ///    when another screen is being pushed on top of this one.
  final Animation<double> secondaryRouteAnimation;

  ///  * `linearTransition` is whether to perform the transitions linearly.
  ///    Used to precisely track back gesture drags.
  final bool linearTransition;

  /// The widget below this widget in the tree.
  final Widget child;

  @override
  State<CupertinoFullscreenDialogTransition> createState() =>
      _CupertinoFullscreenDialogTransitionState();
}

class _CupertinoFullscreenDialogTransitionState extends State<CupertinoFullscreenDialogTransition> {
  /// When this page is coming in to cover another page.
  late Animation<Offset> _primaryPositionAnimation;

  /// When this page is becoming covered by another page.
  late Animation<Offset> _secondaryPositionAnimation;

  /// Curve of primary page which is coming in to cover another page.
  CurvedAnimation? _primaryPositionCurve;

  /// Curve of secondary page which is becoming covered by another page.
  CurvedAnimation? _secondaryPositionCurve;

  @override
  void initState() {
    super.initState();
    _setupAnimation();
  }

  @override
  void didUpdateWidget(covariant CupertinoFullscreenDialogTransition oldWidget) {
    super.didUpdateWidget(oldWidget);
    if (oldWidget.primaryRouteAnimation != widget.primaryRouteAnimation ||
        oldWidget.secondaryRouteAnimation != widget.secondaryRouteAnimation ||
        oldWidget.linearTransition != widget.linearTransition) {
      _disposeCurve();
      _setupAnimation();
    }
  }

  @override
  void dispose() {
    _disposeCurve();
    super.dispose();
  }

  void _disposeCurve() {
    _primaryPositionCurve?.dispose();
    _secondaryPositionCurve?.dispose();
    _primaryPositionCurve = null;
    _secondaryPositionCurve = null;
  }

  void _setupAnimation() {
    _primaryPositionAnimation = (_primaryPositionCurve = CurvedAnimation(
          parent: widget.primaryRouteAnimation,
          curve: Curves.linearToEaseOut,
          // The curve must be flipped so that the reverse animation doesn't play
          // an ease-in curve, which iOS does not use.
          reverseCurve: Curves.linearToEaseOut.flipped,
        ))
        .drive(_kBottomUpTween);
    _secondaryPositionAnimation = (widget.linearTransition
            ? widget.secondaryRouteAnimation
            : _secondaryPositionCurve = CurvedAnimation(
              parent: widget.secondaryRouteAnimation,
              curve: Curves.linearToEaseOut,
              reverseCurve: Curves.easeInToLinear,
            ))
        .drive(_kMiddleLeftTween);
  }

  @override
  Widget build(BuildContext context) {
    assert(debugCheckHasDirectionality(context));
    final TextDirection textDirection = Directionality.of(context);
    return SlideTransition(
      position: _secondaryPositionAnimation,
      textDirection: textDirection,
      transformHitTests: false,
      child: SlideTransition(position: _primaryPositionAnimation, child: widget.child),
    );
  }
}

/// This is the widget side of [_CupertinoBackGestureController].
///
/// This widget provides a gesture recognizer which, when it determines the
/// route can be closed with a back gesture, creates the controller and
/// feeds it the input from the gesture recognizer.
///
/// The gesture data is converted from absolute coordinates to logical
/// coordinates by this widget.
///
/// The type `T` specifies the return type of the route with which this gesture
/// detector is associated.
class _CupertinoBackGestureDetector<T> extends StatefulWidget {
  const _CupertinoBackGestureDetector({
    super.key,
    required this.enabledCallback,
    required this.onStartPopGesture,
    required this.child,
  });

  final Widget child;

  final ValueGetter<bool> enabledCallback;

  final ValueGetter<_CupertinoBackGestureController<T>> onStartPopGesture;

  @override
  _CupertinoBackGestureDetectorState<T> createState() => _CupertinoBackGestureDetectorState<T>();
}

class _CupertinoBackGestureDetectorState<T> extends State<_CupertinoBackGestureDetector<T>> {
  _CupertinoBackGestureController<T>? _backGestureController;

  late HorizontalDragGestureRecognizer _recognizer;

  @override
  void initState() {
    super.initState();
    _recognizer =
        HorizontalDragGestureRecognizer(debugOwner: this)
          ..onStart = _handleDragStart
          ..onUpdate = _handleDragUpdate
          ..onEnd = _handleDragEnd
          ..onCancel = _handleDragCancel;
  }

  @override
  void dispose() {
    _recognizer.dispose();

    // If this is disposed during a drag, call navigator.didStopUserGesture.
    if (_backGestureController != null) {
      WidgetsBinding.instance.addPostFrameCallback((_) {
        if (_backGestureController?.navigator.mounted ?? false) {
          _backGestureController?.navigator.didStopUserGesture();
        }
        _backGestureController = null;
      });
    }
    super.dispose();
  }

  void _handleDragStart(DragStartDetails details) {
    assert(mounted);
    assert(_backGestureController == null);
    _backGestureController = widget.onStartPopGesture();
  }

  void _handleDragUpdate(DragUpdateDetails details) {
    assert(mounted);
    assert(_backGestureController != null);
    _backGestureController!.dragUpdate(
      _convertToLogical(details.primaryDelta! / context.size!.width),
    );
  }

  void _handleDragEnd(DragEndDetails details) {
    assert(mounted);
    assert(_backGestureController != null);
    _backGestureController!.dragEnd(
      _convertToLogical(details.velocity.pixelsPerSecond.dx / context.size!.width),
    );
    _backGestureController = null;
  }

  void _handleDragCancel() {
    assert(mounted);
    // This can be called even if start is not called, paired with the "down" event
    // that we don't consider here.
    _backGestureController?.dragEnd(0.0);
    _backGestureController = null;
  }

  void _handlePointerDown(PointerDownEvent event) {
    if (widget.enabledCallback()) {
      _recognizer.addPointer(event);
    }
  }

  double _convertToLogical(double value) {
    return switch (Directionality.of(context)) {
      TextDirection.rtl => -value,
      TextDirection.ltr => value,
    };
  }

  @override
  Widget build(BuildContext context) {
    assert(debugCheckHasDirectionality(context));
    // For devices with notches, the drag area needs to be larger on the side
    // that has the notch.
    final double dragAreaWidth = switch (Directionality.of(context)) {
      TextDirection.rtl => MediaQuery.paddingOf(context).right,
      TextDirection.ltr => MediaQuery.paddingOf(context).left,
    };
    return Stack(
      fit: StackFit.passthrough,
      children: <Widget>[
        widget.child,
        PositionedDirectional(
          start: 0.0,
          width: max(dragAreaWidth, _kBackGestureWidth),
          top: 0.0,
          bottom: 0.0,
          child: Listener(onPointerDown: _handlePointerDown, behavior: HitTestBehavior.translucent),
        ),
      ],
    );
  }
}

/// A controller for an iOS-style back gesture.
///
/// This is created by a [CupertinoPageRoute] in response from a gesture caught
/// by a [_CupertinoBackGestureDetector] widget, which then also feeds it input
/// from the gesture. It controls the animation controller owned by the route,
/// based on the input provided by the gesture detector.
///
/// This class works entirely in logical coordinates (0.0 is new page dismissed,
/// 1.0 is new page on top).
///
/// The type `T` specifies the return type of the route with which this gesture
/// detector controller is associated.
class _CupertinoBackGestureController<T> {
  /// Creates a controller for an iOS-style back gesture.
  _CupertinoBackGestureController({
    required this.navigator,
    required this.controller,
    required this.getIsActive,
    required this.getIsCurrent,
  }) {
    navigator.didStartUserGesture();
  }

  final AnimationController controller;
  final NavigatorState navigator;
  final ValueGetter<bool> getIsActive;
  final ValueGetter<bool> getIsCurrent;

  /// The drag gesture has changed by [delta]. The total range of the drag
  /// should be 0.0 to 1.0.
  void dragUpdate(double delta) {
    controller.value -= delta;
  }

  /// The drag gesture has ended with a horizontal motion of [velocity] as a
  /// fraction of screen width per second.
  void dragEnd(double velocity) {
    // Fling in the appropriate direction.
    //
    // This curve has been determined through rigorously eyeballing native iOS
    // animations.
    const Curve animationCurve = Curves.fastEaseInToSlowEaseOut;
    final bool isCurrent = getIsCurrent();
    final bool animateForward;

    if (!isCurrent) {
      // If the page has already been navigated away from, then the animation
      // direction depends on whether or not it's still in the navigation stack,
      // regardless of velocity or drag position. For example, if a route is
      // being slowly dragged back by just a few pixels, but then a programmatic
      // pop occurs, the route should still be animated off the screen.
      // See https://github.com/flutter/flutter/issues/141268.
      animateForward = getIsActive();
    } else if (velocity.abs() >= _kMinFlingVelocity) {
      // If the user releases the page before mid screen with sufficient velocity,
      // or after mid screen, we should animate the page out. Otherwise, the page
      // should be animated back in.
      animateForward = velocity <= 0;
    } else {
      animateForward = controller.value > 0.5;
    }

    if (animateForward) {
      controller.animateTo(
        1.0,
        duration: _kDroppedSwipePageAnimationDuration,
        curve: animationCurve,
      );
    } else {
      if (isCurrent) {
        // This route is destined to pop at this point. Reuse navigator's pop.
        navigator.pop();
      }

      // The popping may have finished inline if already at the target destination.
      if (controller.isAnimating) {
        controller.animateBack(
          0.0,
          duration: _kDroppedSwipePageAnimationDuration,
          curve: animationCurve,
        );
      }
    }

    if (controller.isAnimating) {
      // Keep the userGestureInProgress in true state so we don't change the
      // curve of the page transition mid-flight since CupertinoPageTransition
      // depends on userGestureInProgress.
      late AnimationStatusListener animationStatusCallback;
      animationStatusCallback = (AnimationStatus status) {
        navigator.didStopUserGesture();
        controller.removeStatusListener(animationStatusCallback);
      };
      controller.addStatusListener(animationStatusCallback);
    } else {
      navigator.didStopUserGesture();
    }
  }
}

// A custom [Decoration] used to paint an extra shadow on the start edge of the
// box it's decorating. It's like a [BoxDecoration] with only a gradient except
// it paints on the start side of the box instead of behind the box.
class _CupertinoEdgeShadowDecoration extends Decoration {
  const _CupertinoEdgeShadowDecoration._([this._colors]);

  static DecorationTween kTween = DecorationTween(
    begin: const _CupertinoEdgeShadowDecoration._(), // No decoration initially.
    end: const _CupertinoEdgeShadowDecoration._(
      // Eyeballed gradient used to mimic a drop shadow on the start side only.
      <Color>[Color(0x04000000), CupertinoColors.transparent],
    ),
  );

  // Colors used to paint a gradient at the start edge of the box it is
  // decorating.
  //
  // The first color in the list is used at the start of the gradient, which
  // is located at the start edge of the decorated box.
  //
  // If this is null, no shadow is drawn.
  //
  // The list must have at least two colors in it (otherwise it would not be a
  // gradient).
  final List<Color>? _colors;

  // Linearly interpolate between two edge shadow decorations decorations.
  //
  // The `t` argument represents position on the timeline, with 0.0 meaning
  // that the interpolation has not started, returning `a` (or something
  // equivalent to `a`), 1.0 meaning that the interpolation has finished,
  // returning `b` (or something equivalent to `b`), and values in between
  // meaning that the interpolation is at the relevant point on the timeline
  // between `a` and `b`. The interpolation can be extrapolated beyond 0.0 and
  // 1.0, so negative values and values greater than 1.0 are valid (and can
  // easily be generated by curves such as [Curves.elasticInOut]).
  //
  // Values for `t` are usually obtained from an [Animation<double>], such as
  // an [AnimationController].
  //
  // See also:
  //
  //  * [Decoration.lerp].
  static _CupertinoEdgeShadowDecoration? lerp(
    _CupertinoEdgeShadowDecoration? a,
    _CupertinoEdgeShadowDecoration? b,
    double t,
  ) {
    if (identical(a, b)) {
      return a;
    }
    if (a == null) {
      return b!._colors == null
          ? b
          : _CupertinoEdgeShadowDecoration._(
            b._colors!.map<Color>((Color color) => Color.lerp(null, color, t)!).toList(),
          );
    }
    if (b == null) {
      return a._colors == null
          ? a
          : _CupertinoEdgeShadowDecoration._(
            a._colors.map<Color>((Color color) => Color.lerp(null, color, 1.0 - t)!).toList(),
          );
    }
    assert(b._colors != null || a._colors != null);
    // If it ever becomes necessary, we could allow decorations with different
    // length' here, similarly to how it is handled in [LinearGradient.lerp].
    assert(b._colors == null || a._colors == null || a._colors.length == b._colors.length);
    return _CupertinoEdgeShadowDecoration._(<Color>[
      for (int i = 0; i < b._colors!.length; i += 1) Color.lerp(a._colors?[i], b._colors[i], t)!,
    ]);
  }

  @override
  _CupertinoEdgeShadowDecoration lerpFrom(Decoration? a, double t) {
    if (a is _CupertinoEdgeShadowDecoration) {
      return _CupertinoEdgeShadowDecoration.lerp(a, this, t)!;
    }
    return _CupertinoEdgeShadowDecoration.lerp(null, this, t)!;
  }

  @override
  _CupertinoEdgeShadowDecoration lerpTo(Decoration? b, double t) {
    if (b is _CupertinoEdgeShadowDecoration) {
      return _CupertinoEdgeShadowDecoration.lerp(this, b, t)!;
    }
    return _CupertinoEdgeShadowDecoration.lerp(this, null, t)!;
  }

  @override
  _CupertinoEdgeShadowPainter createBoxPainter([VoidCallback? onChanged]) {
    return _CupertinoEdgeShadowPainter(this, onChanged);
  }

  @override
  bool operator ==(Object other) {
    if (other.runtimeType != runtimeType) {
      return false;
    }
    return other is _CupertinoEdgeShadowDecoration && other._colors == _colors;
  }

  @override
  int get hashCode => _colors.hashCode;

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties.add(IterableProperty<Color>('colors', _colors));
  }
}

/// A [BoxPainter] used to draw the page transition shadow using gradients.
class _CupertinoEdgeShadowPainter extends BoxPainter {
  _CupertinoEdgeShadowPainter(this._decoration, super.onChanged)
    : assert(_decoration._colors == null || _decoration._colors.length > 1);

  final _CupertinoEdgeShadowDecoration _decoration;

  @override
  void paint(Canvas canvas, Offset offset, ImageConfiguration configuration) {
    final List<Color>? colors = _decoration._colors;
    if (colors == null) {
      return;
    }

    // The following code simulates drawing a [LinearGradient] configured as
    // follows:
    //
    // LinearGradient(
    //   begin: AlignmentDirectional(0.90, 0.0), // Spans 5% of the page.
    //   colors: _decoration._colors,
    // )
    //
    // A performance evaluation on Feb 8, 2021 showed, that drawing the gradient
    // manually as implemented below is more performant than relying on
    // [LinearGradient.createShader] because compiling that shader takes a long
    // time. On an iPhone XR, the implementation below reduced the worst frame
    // time for a cupertino page transition of a newly installed app from ~95ms
    // down to ~30ms, mainly because there's no longer a need to compile a
    // shader for the LinearGradient.
    //
    // The implementation below divides the width of the shadow into multiple
    // bands of equal width, one for each color interval defined by
    // `_decoration._colors`. Band x is filled with a gradient going from
    // `_decoration._colors[x]` to `_decoration._colors[x + 1]` by drawing a
    // bunch of 1px wide rects. The rects change their color by lerping between
    // the two colors that define the interval of the band.

    // Shadow spans 5% of the page.
    final double shadowWidth = 0.05 * configuration.size!.width;
    final double shadowHeight = configuration.size!.height;
    final double bandWidth = shadowWidth / (colors.length - 1);

    final TextDirection? textDirection = configuration.textDirection;
    assert(textDirection != null);
    final (double shadowDirection, double start) = switch (textDirection!) {
      TextDirection.rtl => (1, offset.dx + configuration.size!.width),
      TextDirection.ltr => (-1, offset.dx),
    };

    int bandColorIndex = 0;
    for (int dx = 0; dx < shadowWidth; dx += 1) {
      if (dx ~/ bandWidth != bandColorIndex) {
        bandColorIndex += 1;
      }
      final Paint paint =
          Paint()
            ..color =
                Color.lerp(
                  colors[bandColorIndex],
                  colors[bandColorIndex + 1],
                  (dx % bandWidth) / bandWidth,
                )!;
      final double x = start + shadowDirection * dx;
      canvas.drawRect(Rect.fromLTWH(x - 1.0, offset.dy, 1.0, shadowHeight), paint);
    }
  }
}

// The stiffness used by dialogs and action sheets.
//
// The stiffness value is obtained by examining the properties of
// `CASpringAnimation` in Xcode. The damping value is derived similarly, with
// additional precision calculated based on `_kStandardStiffness` to ensure a
// damping ratio of 1 (critically damped): damping = 2 * sqrt(stiffness)
const double _kStandardStiffness = 522.35;
const double _kStandardDamping = 45.7099552;
const SpringDescription _kStandardSpring = SpringDescription(
  mass: 1,
  stiffness: _kStandardStiffness,
  damping: _kStandardDamping,
);
// The iOS spring animation duration is 0.404 seconds, based on the properties
// of `CASpringAnimation` in Xcode. At this point, the spring's position
// `x(0.404)` is approximately 0.9990000, suggesting that iOS uses a position
// tolerance of 1e-3 (matching the default `_epsilonDefault` value).
//
// However, the spring's velocity `dx(0.404)` is about 0.02, indicating that iOS
// may not consider velocity when determining the animation's end condition. To
// account for this, a larger velocity tolerance is applied here for added
// safety.
const Tolerance _kStandardTolerance = Tolerance(velocity: 0.03);

/// A route that shows a modal iOS-style popup that slides up from the
/// bottom of the screen.
///
/// Such a popup is an alternative to a menu or a dialog and prevents the user
/// from interacting with the rest of the app.
///
/// It is used internally by [showCupertinoModalPopup] or can be directly pushed
/// onto the [Navigator] stack to enable state restoration. See
/// [showCupertinoModalPopup] for a state restoration app example.
///
/// The `barrierColor` argument determines the [Color] of the barrier underneath
/// the popup. When unspecified, the barrier color defaults to a light opacity
/// black scrim based on iOS's dialog screens. To correctly have iOS resolve
/// to the appropriate modal colors, pass in
/// `CupertinoDynamicColor.resolve(kCupertinoModalBarrierColor, context)`.
///
/// The `barrierDismissible` argument determines whether clicking outside the
/// popup results in dismissal. It is `true` by default.
///
/// The `semanticsDismissible` argument is used to determine whether the
/// semantics of the modal barrier are included in the semantics tree.
///
/// The `routeSettings` argument is used to provide [RouteSettings] to the
/// created Route.
///
/// {@macro flutter.widgets.RawDialogRoute}
///
/// See also:
///
///  * [DisplayFeatureSubScreen], which documents the specifics of how
///    [DisplayFeature]s can split the screen into sub-screens.
///  * [CupertinoActionSheet], which is the widget usually returned by the
///    `builder` argument.
///  * <https://developer.apple.com/design/human-interface-guidelines/ios/views/action-sheets/>
class CupertinoModalPopupRoute<T> extends PopupRoute<T> {
  /// A route that shows a modal iOS-style popup that slides up from the
  /// bottom of the screen.
  CupertinoModalPopupRoute({
    required this.builder,
    this.barrierLabel = 'Dismiss',
    this.barrierColor = kCupertinoModalBarrierColor,
    bool barrierDismissible = true,
    bool semanticsDismissible = false,
    super.filter,
    super.settings,
    super.requestFocus,
    this.anchorPoint,
  }) : _barrierDismissible = barrierDismissible,
       _semanticsDismissible = semanticsDismissible;

  /// A builder that builds the widget tree for the [CupertinoModalPopupRoute].
  ///
  /// The [builder] argument typically builds a [CupertinoActionSheet] widget.
  ///
  /// Content below the widget is dimmed with a [ModalBarrier]. The widget built
  /// by the [builder] does not share a context with the route it was originally
  /// built from. Use a [StatefulBuilder] or a custom [StatefulWidget] if the
  /// widget needs to update dynamically.
  final WidgetBuilder builder;

  final bool _barrierDismissible;

  final bool _semanticsDismissible;

  @override
  final String barrierLabel;

  @override
  final Color? barrierColor;

  @override
  bool get barrierDismissible => _barrierDismissible;

  @override
  bool get semanticsDismissible => _semanticsDismissible;

  @override
  Duration get transitionDuration => _kModalPopupTransitionDuration;

  /// {@macro flutter.widgets.DisplayFeatureSubScreen.anchorPoint}
  final Offset? anchorPoint;

  @override
  Simulation createSimulation({required bool forward}) {
    assert(!debugTransitionCompleted(), 'Cannot reuse a $runtimeType after disposing it.');
    final double end = forward ? 1.0 : 0.0;
    return SpringSimulation(
      _kStandardSpring,
      controller!.value,
      end,
      0,
      tolerance: _kStandardTolerance,
      snapToEnd: true,
    );
  }

  @override
  Widget buildPage(
    BuildContext context,
    Animation<double> animation,
    Animation<double> secondaryAnimation,
  ) {
    return CupertinoUserInterfaceLevel(
      data: CupertinoUserInterfaceLevelData.elevated,
      child: DisplayFeatureSubScreen(anchorPoint: anchorPoint, child: Builder(builder: builder)),
    );
  }

  @override
  Widget buildTransitions(
    BuildContext context,
    Animation<double> animation,
    Animation<double> secondaryAnimation,
    Widget child,
  ) {
    return Align(
      alignment: Alignment.bottomCenter,
      child: FractionalTranslation(translation: _offsetTween.evaluate(animation), child: child),
    );
  }

  static final Tween<Offset> _offsetTween = Tween<Offset>(
    begin: const Offset(0.0, 1.0),
    end: Offset.zero,
  );
}

/// Shows a modal iOS-style popup that slides up from the bottom of the screen.
///
/// Such a popup is an alternative to a menu or a dialog and prevents the user
/// from interacting with the rest of the app.
///
/// The `context` argument is used to look up the [Navigator] for the popup.
/// It is only used when the method is called. Its corresponding widget can be
/// safely removed from the tree before the popup is closed.
///
/// The `barrierColor` argument determines the [Color] of the barrier underneath
/// the popup. When unspecified, the barrier color defaults to a light opacity
/// black scrim based on iOS's dialog screens.
///
/// The `barrierDismissible` argument determines whether clicking outside the
/// popup results in dismissal. It is `true` by default.
///
/// The `useRootNavigator` argument is used to determine whether to push the
/// popup to the [Navigator] furthest from or nearest to the given `context`. It
/// is `true` by default.
///
/// The `semanticsDismissible` argument is used to determine whether the
/// semantics of the modal barrier are included in the semantics tree.
///
/// The `routeSettings` argument is used to provide [RouteSettings] to the
/// created Route.
///
/// The `builder` argument typically builds a [CupertinoActionSheet] widget.
/// Content below the widget is dimmed with a [ModalBarrier]. The widget built
/// by the `builder` does not share a context with the location that
/// [showCupertinoModalPopup] is originally called from. Use a
/// [StatefulBuilder] or a custom [StatefulWidget] if the widget needs to
/// update dynamically.
///
/// {@macro flutter.widgets.RawDialogRoute}
///
/// Returns a `Future` that resolves to the value that was passed to
/// [Navigator.pop] when the popup was closed.
///
/// ### State Restoration in Modals
///
/// Using this method will not enable state restoration for the modal. In order
/// to enable state restoration for a modal, use [Navigator.restorablePush]
/// or [Navigator.restorablePushNamed] with [CupertinoModalPopupRoute].
///
/// For more information about state restoration, see [RestorationManager].
///
/// {@tool dartpad}
/// This sample demonstrates how to create a restorable Cupertino modal route.
/// This is accomplished by enabling state restoration by specifying
/// [CupertinoApp.restorationScopeId] and using [Navigator.restorablePush] to
/// push [CupertinoModalPopupRoute] when the [CupertinoButton] is tapped.
///
/// {@macro flutter.widgets.RestorationManager}
///
/// ** See code in examples/api/lib/cupertino/route/show_cupertino_modal_popup.0.dart **
/// {@end-tool}
///
/// See also:
///
///  * [DisplayFeatureSubScreen], which documents the specifics of how
///    [DisplayFeature]s can split the screen into sub-screens.
///  * [CupertinoActionSheet], which is the widget usually returned by the
///    `builder` argument to [showCupertinoModalPopup].
///  * <https://developer.apple.com/design/human-interface-guidelines/ios/views/action-sheets/>
Future<T?> showCupertinoModalPopup<T>({
  required BuildContext context,
  required WidgetBuilder builder,
  ImageFilter? filter,
  Color barrierColor = kCupertinoModalBarrierColor,
  bool barrierDismissible = true,
  bool useRootNavigator = true,
  bool semanticsDismissible = false,
  RouteSettings? routeSettings,
  Offset? anchorPoint,
}) {
  return Navigator.of(context, rootNavigator: useRootNavigator).push(
    CupertinoModalPopupRoute<T>(
      builder: builder,
      filter: filter,
      barrierColor: CupertinoDynamicColor.resolve(barrierColor, context),
      barrierDismissible: barrierDismissible,
      semanticsDismissible: semanticsDismissible,
      settings: routeSettings,
      anchorPoint: anchorPoint,
    ),
  );
}

Widget _buildCupertinoDialogTransitions(
  BuildContext context,
  Animation<double> animation,
  Animation<double> secondaryAnimation,
  Widget child,
) {
  return child;
}

/// Displays an iOS-style dialog above the current contents of the app, with
/// iOS-style entrance and exit animations, modal barrier color, and modal
/// barrier behavior (by default, the dialog is not dismissible with a tap on
/// the barrier).
///
/// This function takes a `builder` which typically builds a [CupertinoAlertDialog]
/// widget. Content below the dialog is dimmed with a [ModalBarrier]. The widget
/// returned by the `builder` does not share a context with the location that
/// [showCupertinoDialog] is originally called from. Use a [StatefulBuilder] or
/// a custom [StatefulWidget] if the dialog needs to update dynamically.
///
/// The `context` argument is used to look up the [Navigator] for the dialog.
/// It is only used when the method is called. Its corresponding widget can
/// be safely removed from the tree before the dialog is closed.
///
/// The `useRootNavigator` argument is used to determine whether to push the
/// dialog to the [Navigator] furthest from or nearest to the given `context`.
/// By default, `useRootNavigator` is `true` and the dialog route created by
/// this method is pushed to the root navigator.
///
/// {@macro flutter.widgets.RawDialogRoute}
///
/// If the application has multiple [Navigator] objects, it may be necessary to
/// call `Navigator.of(context, rootNavigator: true).pop(result)` to close the
/// dialog rather than just `Navigator.pop(context, result)`.
///
/// Returns a [Future] that resolves to the value (if any) that was passed to
/// [Navigator.pop] when the dialog was closed.
///
/// ### State Restoration in Dialogs
///
/// Using this method will not enable state restoration for the dialog. In order
/// to enable state restoration for a dialog, use [Navigator.restorablePush]
/// or [Navigator.restorablePushNamed] with [CupertinoDialogRoute].
///
/// For more information about state restoration, see [RestorationManager].
///
/// {@tool dartpad}
/// This sample demonstrates how to create a restorable Cupertino dialog. This is
/// accomplished by enabling state restoration by specifying
/// [CupertinoApp.restorationScopeId] and using [Navigator.restorablePush] to
/// push [CupertinoDialogRoute] when the [CupertinoButton] is tapped.
///
/// {@macro flutter.widgets.RestorationManager}
///
/// ** See code in examples/api/lib/cupertino/route/show_cupertino_dialog.0.dart **
/// {@end-tool}
///
/// See also:
///
///  * [CupertinoAlertDialog], an iOS-style alert dialog.
///  * [showDialog], which displays a Material-style dialog.
///  * [showGeneralDialog], which allows for customization of the dialog popup.
///  * [DisplayFeatureSubScreen], which documents the specifics of how
///    [DisplayFeature]s can split the screen into sub-screens.
///  * <https://developer.apple.com/design/human-interface-guidelines/alerts/>
Future<T?> showCupertinoDialog<T>({
  required BuildContext context,
  required WidgetBuilder builder,
  String? barrierLabel,
  bool useRootNavigator = true,
  bool barrierDismissible = false,
  RouteSettings? routeSettings,
  Offset? anchorPoint,
}) {
  return Navigator.of(context, rootNavigator: useRootNavigator).push<T>(
    CupertinoDialogRoute<T>(
      builder: builder,
      context: context,
      barrierDismissible: barrierDismissible,
      barrierLabel: barrierLabel,
      barrierColor: CupertinoDynamicColor.resolve(kCupertinoModalBarrierColor, context),
      settings: routeSettings,
      anchorPoint: anchorPoint,
    ),
  );
}

/// A dialog route that shows an iOS-style dialog.
///
/// It is used internally by [showCupertinoDialog] or can be directly pushed
/// onto the [Navigator] stack to enable state restoration. See
/// [showCupertinoDialog] for a state restoration app example.
///
/// This function takes a `builder` which typically builds a [Dialog] widget.
/// Content below the dialog is dimmed with a [ModalBarrier]. The widget
/// returned by the `builder` does not share a context with the location that
/// `showDialog` is originally called from. Use a [StatefulBuilder] or a
/// custom [StatefulWidget] if the dialog needs to update dynamically.
///
/// The `context` argument is used to look up
/// [CupertinoLocalizations.modalBarrierDismissLabel], which provides the
/// modal with a localized accessibility label that will be used for the
/// modal's barrier. However, a custom `barrierLabel` can be passed in as well.
///
/// The `barrierDismissible` argument is used to indicate whether tapping on the
/// barrier will dismiss the dialog. It is `true` by default and cannot be `null`.
///
/// The `barrierColor` argument is used to specify the color of the modal
/// barrier that darkens everything below the dialog. If `null`, then
/// [CupertinoDynamicColor.resolve] is used to compute the modal color.
///
/// The `settings` argument define the settings for this route. See
/// [RouteSettings] for details.
///
/// {@macro flutter.widgets.RawDialogRoute}
///
/// See also:
///
///  * [showCupertinoDialog], which is a way to display
///     an iOS-style dialog.
///  * [showGeneralDialog], which allows for customization of the dialog popup.
///  * [showDialog], which displays a Material dialog.
///  * [DisplayFeatureSubScreen], which documents the specifics of how
///    [DisplayFeature]s can split the screen into sub-screens.
class CupertinoDialogRoute<T> extends RawDialogRoute<T> {
  /// A dialog route that shows an iOS-style dialog.
  CupertinoDialogRoute({
    required WidgetBuilder builder,
    required BuildContext context,
    super.barrierDismissible,
    Color? barrierColor,
    String? barrierLabel,
    // This transition duration was eyeballed comparing with iOS
    super.transitionDuration = const Duration(milliseconds: 250),
    this.transitionBuilder,
    super.settings,
    super.requestFocus,
    super.anchorPoint,
  }) : super(
         pageBuilder: (
           BuildContext context,
           Animation<double> animation,
           Animation<double> secondaryAnimation,
         ) {
           return builder(context);
         },
         transitionBuilder: transitionBuilder ?? _buildCupertinoDialogTransitions,
         barrierLabel: barrierLabel ?? CupertinoLocalizations.of(context).modalBarrierDismissLabel,
         barrierColor:
             barrierColor ?? CupertinoDynamicColor.resolve(kCupertinoModalBarrierColor, context),
       );

  /// Custom transition builder
  RouteTransitionsBuilder? transitionBuilder;

  CurvedAnimation? _fadeAnimation;

  @override
  Simulation createSimulation({required bool forward}) {
    assert(!debugTransitionCompleted(), 'Cannot reuse a $runtimeType after disposing it.');
    final double end = forward ? 1.0 : 0.0;
    return SpringSimulation(
      _kStandardSpring,
      controller!.value,
      end,
      0,
      tolerance: _kStandardTolerance,
      snapToEnd: true,
    );
  }

  @override
  Widget buildTransitions(
    BuildContext context,
    Animation<double> animation,
    Animation<double> secondaryAnimation,
    Widget child,
  ) {
    if (transitionBuilder != null) {
      return super.buildTransitions(context, animation, secondaryAnimation, child);
    }

    if (animation.status == AnimationStatus.reverse) {
      return FadeTransition(opacity: animation, child: child);
    }
    return FadeTransition(
      opacity: animation,
      child: ScaleTransition(scale: animation.drive(_dialogScaleTween), child: child),
    );
  }

  @override
  void dispose() {
    _fadeAnimation?.dispose();
    super.dispose();
  }

  // The curve and initial scale values were mostly eyeballed from iOS, however
  // they reuse the same animation curve that was modeled after native page
  // transitions.
  static final Tween<double> _dialogScaleTween = Tween<double>(begin: 1.3, end: 1.0);
}


Instructions for the chapter (Generate content in English unless specified otherwise):
- Start with a clear heading (e.g., `# Chapter 5: CupertinoRouteTransitionMixin
`). Use the provided concept name.

- If this is not the first chapter, begin with a brief transition from the previous chapter, referencing it with a proper Markdown link using its name.

- Begin with a high-level motivation explaining what problem this abstraction solves. Start with a central use case as a concrete example. The whole chapter should guide the reader to understand how to solve this use case. Make it very minimal and friendly to beginners.

- If the abstraction is complex, break it down into key concepts. Explain each concept one-by-one in a very beginner-friendly way.

- Explain how to use this abstraction to solve the use case. Give example inputs and outputs for code snippets (if the output isn't values, describe at a high level what will happen).

- Each code block should be BELOW 10 lines! If longer code blocks are needed, break them down into smaller pieces and walk through them one-by-one. Aggresively simplify the code to make it minimal. Use comments to skip non-important implementation details. Each code block should have a beginner friendly explanation right after it.

- Describe the internal implementation to help understand what's under the hood. First provide a non-code or code-light walkthrough on what happens step-by-step when the abstraction is called. It's recommended to use a simple sequenceDiagram with a dummy example - keep it minimal with at most 5 participants to ensure clarity. If participant name has space, use: `participant QP as Query Processing`. .

- Then dive deeper into code for the internal implementation with references to files. Provide example code blocks, but make them similarly simple and beginner-friendly. Explain.

- IMPORTANT: When you need to refer to other core abstractions covered in other chapters, ALWAYS use proper Markdown links like this: [Chapter Title](filename.md). Use the Complete Tutorial Structure above to find the correct filename and the chapter title. Translate the surrounding text.

- Use mermaid diagrams to illustrate complex concepts (```mermaid``` format). .

- Heavily use analogies and examples throughout to help beginners understand.

- End the chapter with a brief conclusion that summarizes what was learned and provides a transition to the next chapter. If there is a next chapter, use a proper Markdown link: [Next Chapter Title](next_chapter_filename).

- Ensure the tone is welcoming and easy for a newcomer to understand.

- Output *only* the Markdown content for this chapter.

Now, directly provide a super beginner-friendly Markdown output (DON'T need ```markdown``` tags):

2025-05-21 12:32:38,084 - INFO - RESPONSE: # Chapter 5: CupertinoRouteTransitionMixin

Welcome back! In [Chapter 4: CupertinoPageRoute](04_cupertinopageroute_.md), we learned how `CupertinoPageRoute` helps us create iOS-style screen transitions automatically, giving our apps that native slide-from-the-right feel. We also briefly saw that `CupertinoPageRoute` uses something called `CupertinoRouteTransitionMixin` to get this behavior.

Now, it's time to shine a spotlight on the `CupertinoRouteTransitionMixin` itself!

### What is CupertinoRouteTransitionMixin?

Just like `MaterialRouteTransitionMixin` is the special recipe additive for Material Design transitions, `CupertinoRouteTransitionMixin` is the recipe additive for **Cupertino (iOS) page transitions**.

It's not a full `PageRoute` on its own, but it contains the vital instructions and ingredients needed to create the signature iOS sliding and fading animations for transitioning between screens.

Think of it as providing the "animation logic" that a `PageRoute` can use. Instead of writing the complex code to make a widget slide from the right and have the old page slightly move left (that parallax effect!), you can "mix in" `CupertinoRouteTransitionMixin` to automatically get that behavior.

It provides the core logic for:

1.  **How long** the transition takes (its duration).
2.  **How the animation fundamentally looks** (the sliding, the fading).
3.  **How it behaves** during interactive gestures, like swiping back from the edge of the screen on iOS.

`CupertinoPageRoute` itself uses `CupertinoRouteTransitionMixin` to implement its `buildTransitions` method, which is the core piece that tells the Navigator how to animate the new screen into view.

**Motivation:** We want to understand where the charming iOS sliding and parallax animations come from when we use `CupertinoPageRoute`. They come from `CupertinoRouteTransitionMixin`.

### How Mixins Work (A Quick Reminder)

As we talked about with `MaterialRouteTransitionMixin`, a mixin is a way to add a set of properties and methods from one class-like structure into another class, without needing traditional inheritance.

When a class `mixes in` a mixin, it gains all the public members of that mixin as if they were defined directly in the class itself.

`CupertinoPageRoute` uses `CupertinoRouteTransitionMixin` like this:

```dart
// Simplified from packages/flutter/lib/src/cupertino/route.dart
class CupertinoPageRoute<T> extends PageRoute<T> with CupertinoRouteTransitionMixin<T> {
  // CupertinoPageRoute now automatically has the buildTransitions method
  // and other properties defined in CupertinoRouteTransitionMixin
  // ... rest of CupertinoPageRoute code ...
}
```

This means `CupertinoPageRoute` doesn't have to write the `buildTransitions` code itself; it gets it "for free" by mixing in `CupertinoRouteTransitionMixin`.

### How it Connects to Building Transitions

The most important part that `CupertinoRouteTransitionMixin` provides is the implementation for the `buildTransitions` method that every `PageRoute` needs.

When you call `Navigator.push` with a `CupertinoPageRoute`, the Navigator needs to know how to animate the new page onto the screen. It calls the `buildTransitions` method of that `PageRoute`. Because `CupertinoPageRoute` mixed in `CupertinoRouteTransitionMixin`, it's actually the mixin's code that runs for `buildTransitions`.

Here's a look inside the mixin's `buildTransitions` method (simplified from the framework code):

```dart
// Simplified from packages/flutter/lib/src/cupertino/route.dart
mixin CupertinoRouteTransitionMixin<T> on PageRoute<T> {
  // ... other properties like transitionDuration ...

  @override
  Widget buildTransitions( // This method is provided by the mixin!
    BuildContext context,
    Animation<double> animation, // Animation for the incoming page
    Animation<double> secondaryAnimation, // Animation for the outgoing page
    Widget child, // The actual content of the page (your NewScreen)
  ) {
    // Inside here, the mixin's code figures out the right animation.
    // It uses specific transition widgets like CupertinoPageTransition
    // (or CupertinoFullscreenDialogTransition for dialogs).
    // It passes the 'child' (your new screen) and the 'animation' objects
    // to these transition widgets.

    // This line is the core – it calls dedicated builders for the transitions!
    return buildPageTransitions<T>(this, context, animation, secondaryAnimation, child);
  }

  // ... other methods ...
}
```

The `buildTransitions` method in `CupertinoRouteTransitionMixin` doesn't build the animation widget tree directly. Instead, it delegates that task to helper functions within the Cupertino library, specifically `buildPageTransitions`.

This `buildPageTransitions` helper method (which is part of the mixin's logic):

1.  Checks if this route is a normal page or a fullscreen dialog.
2.  Based on that, it chooses the correct transition widget.
    *   For normal pages, it picks `CupertinoPageTransition`.
    *   For fullscreen dialogs (like adding an event in the calendar), it picks `CupertinoFullscreenDialogTransition`.
3.  It creates an instance of the chosen transition widget, passing in:
    *   The `animation` for the incoming screen.
    *   The `secondaryAnimation` for the outgoing screen.
    *   Your actual screen widget (`child`).

So, the `CupertinoRouteTransitionMixin` acts as the orchestrator of the transition. It decides which specific animation widget to use and provides it with the necessary animation data.

Let's visualize this flow:

```mermaid
sequenceDiagram
    participant Navigator as Navigator
    participant CupertinoPageRoute as CupertinoPageRoute
    participant CRT_Mixin as CupertinoRouteTransitionMixin
    participant CPTransition as CupertinoPageTransition / CupertinoFullscreenDialogTransition
    participant NewScreen as NewScreen Widget

    Navigator->CupertinoPageRoute: calls buildTransitions(...)
    CupertinoPageRoute->CRT_Mixin: (delegates to mixin's method)
    CRT_Mixin->CRT_Mixin: calls buildPageTransitions(...)
    CRT_Mixin->CPTransition: creates CPTransition(...) with child and animations
    CPTransition->NewScreen: wraps NewScreen
    CRT_Mixin-->Navigator: returns CPTransition(NewScreen)
    Navigator->Navigator: Animates the transition using CPTransition
```

The `CupertinoPageTransition` and `CupertinoFullscreenDialogTransition` widgets are the ones that *actually perform* the visual animation (sliding the child widget using the provided animation values). We'll look at those in more detail in the next chapters!

### You Won't Necessarily Use It Directly

Similar to `MaterialRouteTransitionMixin`, you as a beginner app developer are typically not expected to directly use `CupertinoRouteTransitionMixin`. Its main purpose is to serve as a building block for other `PageRoute` types, most notably `CupertinoPageRoute`.

When you use `CupertinoPageRoute`, you automatically get the benefits of the transition logic contained within `CupertinoRouteTransitionMixin` without having to think about the mixin itself.

### Conclusion

`CupertinoRouteTransitionMixin` is the powerhouse behind `CupertinoPageRoute`'s native iOS transition animations. It provides the `buildTransitions` logic, deciding which specific Cupertino transition widget (`CupertinoPageTransition` or `CupertinoFullscreenDialogTransition`) to use based on the route type and giving it the necessary animation details to perform the visual effect. While you usually interact with `CupertinoPageRoute`, understanding that `CupertinoRouteTransitionMixin` provides the core animation recipe clarifies how these iOS-style transitions are achieved in Flutter.

In the next chapter, we'll focus on `CupertinoPageTransition`, the primary widget used by `CupertinoRouteTransitionMixin` to create the standard iOS page slide animation.

[Next Chapter: CupertinoPageTransition](06_cupertinopagetransition_.md)
2025-05-21 12:32:38,093 - INFO - PROMPT: 
Write a very beginner-friendly tutorial chapter (in Markdown format) for the project `flutter` about the concept: "CupertinoPageTransition
". This is Chapter 6.

Concept Details:
- Name: CupertinoPageTransition

- Description:
This widget represents the actual animation you see when a new Cupertino-style page slides in from the right. It takes the animation progress and the new screen's content and visually transforms it from off-screen to on-screen, often with a parallax effect on the previous screen. It's the "visual effect" part of the Cupertino page navigation.


Complete Tutorial Structure:
1. [PageRoute
](01_pageroute_.md)
2. [MaterialPageRoute
](02_materialpageroute_.md)
3. [MaterialRouteTransitionMixin
](03_materialroutetransitionmixin_.md)
4. [CupertinoPageRoute
](04_cupertinopageroute_.md)
5. [CupertinoRouteTransitionMixin
](05_cupertinoroutetransitionmixin_.md)
6. [CupertinoPageTransition
](06_cupertinopagetransition_.md)
7. [CupertinoFullscreenDialogTransition
](07_cupertinofullscreendialogtransition_.md)
8. [CupertinoModalPopupRoute
](08_cupertinomodalpopuproute_.md)
9. [CupertinoDialogRoute
](09_cupertinodialogroute_.md)

Context from previous chapters:
# Chapter 1: PageRoute

Welcome to the first chapter of our Flutter navigation tutorial! Ever wonder how tapping a button in an app seamlessly takes you to a completely different screen? That's where the magic of navigation comes in! In Flutter, a core concept for managing these screen transitions is the `PageRoute`.

Imagine your Flutter app is like a building with many rooms (screens). When you want to go from one room (the "lobby") to another room (the "settings" screen), you need a plan or a map to get there. A `PageRoute` is exactly that – it's the blueprint, the plan, for a single "page" or screen in your app and how you would transition *to* it.

Think of it as defining:

*   **What the new screen looks like:** What widgets make up this new page?
*   **How the transition happens:** Does it slide from the side, fade in, or something else?
*   **How long the transition takes:** Is it a quick change or a smooth, longer one?
*   **Its behavior:** Can you easily "go back" or dismiss this screen?

The `PageRoute` doesn't *perform* the transition itself; it tells the `Navigator` (Flutter's system for managing screen stacks, like stacking rooms on top of each other) *how* to perform the transition to display its content.

### Our Goal: Showing a Simple New Screen

Throughout this chapter, our goal is to understand enough about `PageRoute` to accomplish a very common task: navigating from one simple screen to another.

Let's start with a basic example. We'll have a main screen with a button. When you tap the button, we want to go to a new, blank screen.

Here's a simplified look at what we might have initially:

```dart
import 'package:flutter/material.dart';

void main() {
  runApp(MyApp());
}

class MyApp extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return MaterialApp(
      home: HomeScreen(),
    );
  }
}

class HomeScreen extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(title: Text('Home Screen')),
      body: Center(
        child: ElevatedButton(
          onPressed: () {
            // We want to go to a new screen here!
          },
          child: Text('Go to New Screen'),
        ),
      ),
    );
  }
}

class NewScreen extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(title: Text('New Screen')),
      body: Center(
        child: Text('Welcome to the new screen!'),
      ),
    );
  }
}
```

In this code, we have `HomeScreen` and `NewScreen`. Our challenge is to connect the button on `HomeScreen` to show `NewScreen`. We need a `PageRoute` for `NewScreen`.

### Understanding PageRoute with PageRouteBuilder

Directly creating a raw `PageRoute` can be a bit advanced for our first step. Flutter provides a helpful class called `PageRouteBuilder` which lets us create a simple `PageRoute` using functions (callbacks). This is perfect for defining basic routes without creating a whole new class.

Let's look at how we can use `PageRouteBuilder` inside the `onPressed` of our `ElevatedButton`:

```dart
// ... inside HomeScreen onPressed ...
onPressed: () {
  Navigator.push(
    context,
    PageRouteBuilder( // Using PageRouteBuilder to define our route
      pageBuilder: (context, animation, secondaryAnimation) {
        // This function builds the actual screen content
        return NewScreen();
      },
      transitionsBuilder: (context, animation, secondaryAnimation, child) {
        // This function defines how the transition looks
        // For now, we'll do a simple fade transition as an example
        return FadeTransition(
          opacity: animation, // Controls the opacity of the new page
          child: child,
        );
      },
      transitionDuration: Duration(milliseconds: 500), // How long the transition takes
    ),
  );
},
// ... rest of HomeScreen ...
```

Let's break down what's happening here:

1.  **`Navigator.push(context, ...)`**: This is how we tell Flutter's navigation system to add a new screen on top of the current one. `context` tells the Navigator where we are in the widget tree.
2.  **`PageRouteBuilder(...)`**: We create an instance of `PageRouteBuilder` to define the characteristics of the new route.
3.  **`pageBuilder: (context, animation, secondaryAnimation) { return NewScreen(); }`**: This is a required function that `PageRouteBuilder` needs. It tells the builder *what* widget tree to display for this page. In our case, it's just our `NewScreen` widget. The `animation` and `secondaryAnimation` parameters are for transition animations, which we'll use in the next part.
4.  **`transitionsBuilder: (context, animation, secondaryAnimation, child) { ... }`**: This optional function defines how the transition *looks*. It takes the context, `animation` (for the incoming page), `secondaryAnimation` (for the outgoing page), and the `child` (which is the widget built by `pageBuilder`). We use a `FadeTransition` here, animating the `opacity` of the incoming page using the `animation` provided.
5.  **`transitionDuration: Duration(milliseconds: 500)`**: This sets how long the transition animation should take.

Now, when you tap the button, the `Navigator` will use this `PageRouteBuilder` to create a `PageRoute`, push it onto the navigation stack, and animate to the `NewScreen` using a 500ms fade effect.

### How it Works Under the Hood (Simplified)

Let's look at a slightly simplified view of what happens when you call `Navigator.push` with a `PageRoute`:

```mermaid
sequenceDiagram
    participant Button as Button Widget
    participant HomeScreen as HomeScreen Widget
    participant Navigator as Navigator
    participant PageRoute as PageRouteBuilder
    participant NewScreen as NewScreen Widget

    Button->HomeScreen: calls onPressed
    HomeScreen->Navigator: calls push(context, PageRoute)
    Navigator->PageRoute: asks for the page content and transitions
    PageRoute->PageRoute: uses pageBuilder to create NewScreen widget
    PageRoute->PageRoute: uses transitionsBuilder to wrap NewScreen with transition widgets
    Navigator->Navigator: Prepares
    Navigator->NewScreen: Builds and animates the transition
```

Essentially, the `Navigator` is like the conductor of an orchestra. You hand it a `PageRoute`, and it orchestrates the process of showing the new screen, including running the transitions defined by the `PageRoute`.

Inside the Flutter framework code for `PageRoute` (like in `packages/flutter/lib/src/widgets/pages.dart`), you'll find methods like `buildPage` and `buildTransitions`. These are the core parts that `PageRouteBuilder` uses its functions (`pageBuilder` and `transitionsBuilder`) to implement:

```dart
// Simplified example from PageRoute (similar to what PageRouteBuilder does internally)
abstract class PageRoute<T> extends ModalRoute<T> {
  // ... other properties ...

  // The PageRoute needs to know how to build the main content
  Widget buildPage(BuildContext context, Animation<double> animation, Animation<double> secondaryAnimation);

  // The PageRoute needs to know how to build the transitions
  Widget buildTransitions(BuildContext context, Animation<double> animation, Animation<double> secondaryAnimation, Widget child);

  // ... more methods for duration, color, etc. ...
}
```

`PageRouteBuilder` fills in these `buildPage` and `buildTransitions` methods using the functions you provide.

### Conclusion

In this chapter, we learned that a `PageRoute` is the fundamental concept in Flutter navigation that defines how a new screen is presented. We saw how to use `PageRouteBuilder` to create a simple `PageRoute` by specifying what the new screen looks like and how the transition should appear.

While `PageRouteBuilder` is great for simple custom transitions, Flutter provides pre-built `PageRoute` implementations for common design patterns, like the Material Design page transitions and the Cupertino (iOS) page transitions. These include standard animations and behaviors.

In the next chapter, we'll dive into one of these standard implementations: [MaterialPageRoute](02_materialpageroute_.md), which provides the familiar animations you see in Android apps.

[Next Chapter: MaterialPageRoute](02_materialpageroute_.md)
---
# Chapter 2: MaterialPageRoute

Welcome back! In [Chapter 1: PageRoute](01_pageroute_.md), we learned that a `PageRoute` is the blueprint for displaying a new screen and defining its transition. We saw how `PageRouteBuilder` let us create custom routes with animations.

Now, let's explore a really common and useful type of `PageRoute` used in Flutter apps that follow Google's Material Design: the `MaterialPageRoute`.

### What is MaterialPageRoute?

If you've ever used an Android phone, you've likely seen specific ways new screens appear when you tap something – often, they fade in and zoom slightly. `MaterialPageRoute` is designed to give you that native Android look and feel for your screen transitions, *automatically*.

Think of it as a pre-made `PageRoute` specifically built for Material Design. Instead of defining the fade/zoom transition yourself with `PageRouteBuilder`, `MaterialPageRoute` handles it for you.

But here's a cool trick: `MaterialPageRoute` is also platform-adaptive! This means that if you run your app on an iOS device, it will automatically use the standard iOS slide-from-the-right transition. You get the right native feel on both Android and iOS with just one `MaterialPageRoute`!

**Motivation:** We want to navigate from our `HomeScreen` to our `NewScreen` using the standard Material Design (Android-style) transitions on Android and the standard Cupertino (iOS-style) transitions on iOS, without manually building the transition animation ourselves.

### Using MaterialPageRoute

Using `MaterialPageRoute` is much simpler than `PageRouteBuilder` for standard transitions. You just need to tell it *what* screen to build.

Let's go back to our
`HomeScreen` button's `onPressed` and replace the `PageRouteBuilder` with a `MaterialPageRoute`:

```dart
// ... inside HomeScreen onPressed ...
onPressed: () {
  Navigator.push(
    context,
    MaterialPageRoute( // Using MaterialPageRoute!
      builder: (context) {
        // Just provide the widget for the new screen
        return NewScreen();
      },
    ),
  );
},
// ... rest of HomeScreen ...
```

That's it! Notice how much simpler it is?

*   We still use `Navigator.push` to initiate the navigation.
*   We create a `MaterialPageRoute` instance.
*   We provide a `builder` function, which is similar to `pageBuilder` in `PageRouteBuilder`. This function simply returns the widget for the new screen (`NewScreen`).
*   We *don't* need to specify a `transitionsBuilder` or `transitionDuration` explicitly. `MaterialPageRoute` uses default ones suitable for Material Design, chosen automatically based on the device's operating system.

Now, when you tap the button:
*   On an Android device, `NewScreen` will fade in and slightly zoom.
*   On an iOS device, `NewScreen` will slide in from the right.

### How it Works Under the Hood (Simplified)

When you use `MaterialPageRoute`, like with any `PageRoute`, you hand it to the `Navigator`.

```mermaid
sequenceDiagram
    participant Button as Button Widget
    participant HomeScreen as HomeScreen Widget
    participant Navigator as Navigator
    participant MaterialPageRoute as MaterialPageRoute
    participant NewScreen as NewScreen Widget
    participant Theme as Theme Data

    Button->HomeScreen: calls onPressed
    HomeScreen->Navigator: calls push(context, MaterialPageRoute)
    Navigator->MaterialPageRoute: asks for page content and transitions
    MaterialPageRoute->MaterialPageRoute: calls builder() to create NewScreen widget
    MaterialPageRoute->Theme: checks current platform (Android/iOS)
    MaterialPageRoute->MaterialPageRoute: selects relevant transition based on platform
    MaterialPageRoute->NewScreen: Builds and wraps with selected transition widgets
    Navigator->Navigator: Prepares
    Navigator->NewScreen: Animates the transition
```

The key difference from using `PageRouteBuilder` with a custom fade is that `MaterialPageRoute` internally checks the theme and the platform to pick the right animation blueprint.

Let's peek into the Flutter framework code for `MaterialPageRoute` in `packages/flutter/lib/src/material/page.dart`.

You'll see the `MaterialPageRoute` class definition inherits from `PageRoute` and also uses something called `MaterialRouteTransitionMixin` (we'll talk about mixins more later, but for now, think of it as sharing helpful code).

```dart
// Simplified from packages/flutter/lib/src/material/page.dart
class MaterialPageRoute<T> extends PageRoute<T> with MaterialRouteTransitionMixin<T> {
  // ... constructor and other properties ...

  /// Builds the primary contents of the route.
  final WidgetBuilder builder; // This holds the function you passed in!

  @override
  Widget buildContent(BuildContext context) => builder(context); // Uses your builder

  // ... other overrides ...
}
```

The `buildContent` method is where your `builder` function is called to create the `NewScreen` widget.

Where does the platform-adaptive transition logic come from? It's mostly handled by the `MaterialRouteTransitionMixin` and interacts with Flutter's `Theme` and `PageTransitionsTheme`.

```dart
// Simplified/conceptual example from MaterialRouteTransitionMixin
mixin MaterialRouteTransitionMixin<T> on PageRoute<T> {
  // ... other properties ...

  @override
  Widget buildTransitions( // This is where the transition is built!
    BuildContext context,
    Animation<double> animation,
    Animation<double> secondaryAnimation,
    Widget child, // This 'child' is the widget from buildContent (your NewScreen)
  ) {
    // Internally looks at Theme.of(context).platform (Android or iOS)
    // Then looks up the correct transition from Theme.of(context).pageTransitionsTheme
    // Returns the correct transition widget (like a FadeTransition for Android,
    // or a SlideTransition for iOS) wrapping the 'child' (your screen).
    final PageTransitionsTheme theme = Theme.of(context).pageTransitionsTheme;
    return theme.buildTransitions<T>(this, context, animation, secondaryAnimation, child);
  }

  // ... other properties like transitionDuration ...
}
```

So, `MaterialPageRoute` uses the `builder` you provide to show the content and relies on the `MaterialRouteTransitionMixin` (and Flutter's theming system) to automatically select and apply the right transition animation based on the device's platform.

### Conclusion

`MaterialPageRoute` is your go-to `PageRoute` when you want standard Material Design page transitions (fade/zoom on Android, slide on iOS) without needing to manually define the animations. It simplifies the process of creating new routes by providing sensible defaults that match platform conventions. It's a foundational component for navigation in many Flutter applications.

In the next chapter, we'll take a brief look at the `MaterialRouteTransitionMixin` itself, which is the piece that provides the magic platform-adaptive transitions for `MaterialPageRoute`.

[Next Chapter: MaterialRouteTransitionMixin](03_materialroutetransitionmixin_.md)
---
# Chapter 3: MaterialRouteTransitionMixin

Welcome back! In [Chapter 2: MaterialPageRoute](02_materialpageroute_.md), we learned how `MaterialPageRoute` gives us those sweet, platform-adaptive screen transitions (fade/zoom on Android, slide on iOS) without us having to code the animations ourselves.

We briefly saw that the code for `MaterialPageRoute` includes something called `with MaterialRouteTransitionMixin`. This chapter is about that `MaterialRouteTransitionMixin`.

### What is MaterialRouteTransitionMixin?

Imagine you have a recipe for delicious cookies. The recipe lists all the ingredients and the steps. A "mixin" in Flutter is like a list of extra ingredients and techniques you can add to your recipe to make it special.

`MaterialRouteTransitionMixin` is not a complete recipe (it's not a full `PageRoute` itself), but it's a collection of "ingredients" and "techniques" specifically for creating **Material Design page transitions** that adapt to the platform.

It provides the core logic for:

1.  **How long** the transition should take (duration).
2.  **How the animation looks** (the transition effect itself, like fading or sliding).
3.  **How this route interacts** with other routes during transitions (can they transition together smoothly?).

Essentially, `MaterialRouteTransitionMixin` is the helper that `MaterialPageRoute` uses to get its standard, platform-adaptive transition behavior. It's what makes `MaterialPageRoute` special!

You won't usually create a `MaterialRouteTransitionMixin` directly. Instead, you'll see other `PageRoute` implementations (like `MaterialPageRoute`) "mix it in" to gain its transition capabilities.

**Motivation:** Our goal is to understand where the automatic, platform-adaptive transition logic in `MaterialPageRoute` comes from. It comes from `MaterialRouteTransitionMixin`.

### How Mixins Work (Simply)

Think of a mixin as a way to share code between different classes without using traditional inheritance (like a child class inheriting from a parent class).

If you have `ClassA` and `MixinB`, `ClassA` can use `MixinB`'s methods and properties by saying `class ClassA with MixinB`. It's like `ClassA` is adding `MixinB`'s features to itself.

In our case, `MaterialPageRoute` is a class, and it uses `MaterialRouteTransitionMixin` like this:

```dart
// Simplified
class MaterialPageRoute<T> extends PageRoute<T> with MaterialRouteTransitionMixin<T> {
  // MaterialPageRoute now has access to the methods inside MaterialRouteTransitionMixin
  // ... rest of MaterialPageRoute code ...
}
```

By using `with MaterialRouteTransitionMixin`, `MaterialPageRoute` automatically gains the `buildTransitions` method and other transition-related logic defined within the mixin.

### How it Connects to Building Transitions

Remember in [Chapter 1: PageRoute](01_pageroute_.md), we saw that a `PageRoute` needs to implement a `buildTransitions` method to define how the animation looks?

`MaterialRouteTransitionMixin` provides the **implementation** for this crucial `buildTransitions` method for Material Design transitions.

When `Navigator.push` is called with a `MaterialPageRoute`, the Navigator asks the `MaterialPageRoute` (which uses `MaterialRouteTransitionMixin`'s logic) to build the transition widget tree.

Here's a look inside the mixin (simplified):

```dart
// Simplified/conceptual example from packages/flutter/lib/src/material/page.dart
mixin MaterialRouteTransitionMixin<T> on PageRoute<T> {
  // ... other properties like transitionDuration ...

  @override
  Widget buildTransitions( // This method is provided by the mixin!
    BuildContext context,
    Animation<double> animation, // Animation for the incoming page
    Animation<double> secondaryAnimation, // Animation for the outgoing page
    Widget child, // The actual content of the page (your NewScreen)
  ) {
    // Inside here, the mixin's code runs.
    // It checks the platform (Android/iOS) using Theme.of(context).platform.
    // It looks up the correct transition animation based on the platform
    // from the PageTransitionsTheme.
    // It returns the chosen animation widget (like FadeTransition or SlideTransition)
    // wrapping the 'child' (your NewScreen widget).

    // This line is the core – it asks the Theme for the right transition!
    final PageTransitionsTheme theme = Theme.of(context).pageTransitionsTheme;
    return theme.buildTransitions<T>(this, context, animation, secondaryAnimation, child);
  }

  // ... other methods ...
}
```

So, `MaterialRouteTransitionMixin` contains the `buildTransitions` method that looks at the current `Theme` (which knows the platform) and asks the `PageTransitionsTheme` within the `Theme` to provide the actual transition widget code.

This design is clever because:
*   `MaterialPageRoute` handles knowing *what* screen to show (`builder`).
*   `MaterialRouteTransitionMixin` handles knowing *how* to transition, querying the `Theme` for the platform-specific implementation.
*   The `PageTransitionsTheme` holds the actual animation builders (like the code for the fade/zoom or the slide animations).

This separation of concerns makes the code more organized and maintainable!

### You Don't Use It Directly (Usually)

As a beginner, you won't typically need to directly use `MaterialRouteTransitionMixin`. Its purpose is to provide the transition logic *to* classes like `MaterialPageRoute`. When you use `MaterialPageRoute`, you are indirectly benefiting from the code in `MaterialRouteTransitionMixin`.

Think of it like buying a car. You use the steering wheel and pedals (`MaterialPageRoute`), and the engine ("mixin") makes it go, but you don't interact directly with the engine parts every time you drive.

### Conclusion

`MaterialRouteTransitionMixin` is a key piece of the puzzle behind `MaterialPageRoute`'s automatic, platform-adaptive transitions. It provides the core logic for determining transition duration and building the correct transition animation based on the device's operating system by interacting with the Flutter `Theme` system. While you won't often use it directly, understanding its role helps clarify how `MaterialPageRoute` works.

In the next chapter, we'll shift our focus to the iOS side of things and introduce `CupertinoPageRoute`, which is the counterpart to `MaterialPageRoute` for Cupertino (iOS) design.

[Next Chapter: CupertinoPageRoute](04_cupertinopageroute_.md)
---
# Chapter 4: CupertinoPageRoute

Welcome back, future Flutter navigators! In [Chapter 3: MaterialRouteTransitionMixin](03_materialroutetransitionmixin_.md), we explored how `MaterialRouteTransitionMixin` is the helper that gives `MaterialPageRoute` its cool, platform-adaptive animations. Now, let's turn our attention to the world of Apple's iOS design with `CupertinoPageRoute`.

### What is CupertinoPageRoute?

If you've ever used an iPhone or iPad, you've seen specific ways new screens slide into view, often from the right side of the screen, and how they slide back out when you go back. `CupertinoPageRoute` is Flutter's way of giving you that exact native iOS look and feel for your screen transitions, automatically!

Just like `MaterialPageRoute` is a pre-made blueprint for Material Design transitions, `CupertinoPageRoute` is a pre-made blueprint specifically built for Cupertino (iOS) design. It handles the characteristic sliding animations and other iOS visual cues when you navigate between pages.

**Motivation:** Our goal is to navigate from our `HomeScreen` to our `NewScreen` using the standard iOS slide-from-the-right transition when running on an iOS device, in a way that is natural and expected for iOS users.

### Using CupertinoPageRoute

Using `CupertinoPageRoute` is very similar to using `MaterialPageRoute`. You simply tell it which widget represents the new screen.

Let's go back to our `HomeScreen` button's `onPressed` and replace the `MaterialPageRoute` with a `CupertinoPageRoute`:

```dart
import 'package:flutter/cupertino.dart'; // Import Cupertino widgets!
import 'package:flutter/material.dart'; // Still need Material for Scaffold, AppBar, etc.

// ... rest of MyApp and HomeScreen classes ...

class HomeScreen extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return Scaffold( // Using Material Scaffold for simplicity in this example
      appBar: AppBar(title: Text('Home Screen')),
      body: Center(
        child: ElevatedButton(
          onPressed: () {
            Navigator.push(
              context,
              CupertinoPageRoute( // Using CupertinoPageRoute!
                builder: (context) {
                  // Just provide the widget for the new screen
                  return NewScreen();
                },
              ),
            );
          },
          child: Text('Go to New Screen'),
        ),
      ),
    );
  }
}

// ... rest of NewScreen class ...
```

See the difference? We changed `MaterialPageRoute` to `CupertinoPageRoute` and made sure to import `flutter/cupertino.dart`.

Now, when you tap the button:

*   On an iOS device, `NewScreen` will smoothly slide in from the right, with the previous screen slightly moving to the left (a parallax effect). When you go back, it slides out to the right.
*   On an Android device, because we're using a `CupertinoPageRoute`, it will *still* try to use the Cupertino (iOS) style transition, even though it's running on Android. This is different from `MaterialPageRoute` which is platform-adaptive. If you want platform-adaptive behavior, `MaterialPageRoute` is often the better choice. `CupertinoPageRoute` is primarily for building apps that *always* have the iOS feel.

### How it Works Under the Hood (Simplified)

When you use `CupertinoPageRoute`, you hand it to the `Navigator` just like any other `PageRoute`.

```mermaid
sequenceDiagram
    participant Button as Button Widget
    participant HomeScreen as HomeScreen Widget
    participant Navigator as Navigator
    participant CupertinoPageRoute as CupertinoPageRoute
    participant NewScreen as NewScreen Widget
    participant iOS Theme as iOS Theme Data (Conceptual)

    Button->HomeScreen: calls onPressed
    HomeScreen->Navigator: calls push(context, CupertinoPageRoute)
    Navigator->CupertinoPageRoute: asks for page content and transitions
    CupertinoPageRoute->CupertinoPageRoute: calls builder() to create NewScreen widget
    CupertinoPageRoute->iOS Theme: Requests iOS-style transition details
    CupertinoPageRoute->CupertinoPageRoute: Uses transition logic from mixin
    CupertinoPageRoute->NewScreen: Builds and wraps with Cupertino transition widgets
    Navigator->Navigator: Prepares
    Navigator->NewScreen: Animates the transition (iOS style)
```

The process is very similar to `MaterialPageRoute`, but instead of checking the general platform to pick between Material and Cupertino, `CupertinoPageRoute` *always* uses the Cupertino style transition logic.

Let's peek into the Flutter framework code for `CupertinoPageRoute` in `packages/flutter/lib/src/cupertino/route.dart`.

You'll find the `CupertinoPageRoute` class definition inherits from `PageRoute` and, just like `MaterialPageRoute` uses a mixin for its transitions, `CupertinoPageRoute` uses something similar: `CupertinoRouteTransitionMixin`.

```dart
// Simplified from packages/flutter/lib/src/cupertino/route.dart
class CupertinoPageRoute<T> extends PageRoute<T> with CupertinoRouteTransitionMixin<T> {
  // ... constructor and other properties ...

  /// Builds the primary contents of the route.
  final WidgetBuilder builder; // This holds the function you passed in!

  @override
  Widget buildContent(BuildContext context) => builder(context); // Uses your builder

  // ... other overrides ...
}
```

Similar to `MaterialPageRoute`, `CupertinoPageRoute` takes your `builder` function and calls its `buildContent` method to create the widget for the new page.

The iOS-style transition magic (the sliding from the right, the parallax effect) comes from the `CupertinoRouteTransitionMixin` that is mixed into `CupertinoPageRoute`. This mixin implements the `buildTransitions` method using specific iOS animations:

```dart
// Simplified/conceptual example from CupertinoRouteTransitionMixin
mixin CupertinoRouteTransitionMixin<T> on PageRoute<T> {
  // ... other properties like transitionDuration ...

  @override
  Widget buildTransitions( // This method is provided by the mixin!
    BuildContext context,
    Animation<double> animation, // Animation for the incoming page
    Animation<double> secondaryAnimation, // Animation for the outgoing page
    Widget child, // The actual content of the page (your NewScreen)
  ) {
    // Inside here, the mixin's code runs.
    // It builds specific iOS transition widgets...
    // For normal pages, it uses CupertinoPageTransition.
    // For fullscreen dialogs, it uses CupertinoFullscreenDialogTransition.
    // It uses the animations (primaryRouteAnimation and secondaryRouteAnimation)
    // and wraps the 'child' (your NewScreen widget) with them.

    // A simplified call to the actual transition builder:
    return buildPageTransitions<T>(this, context, animation, secondaryAnimation, child);
  }

  // ... other methods ...
}
```

When the `Navigator` needs to show `CupertinoPageRoute`, it asks the route to `buildTransitions`. `CupertinoPageRoute` uses the `buildTransitions` method from `CupertinoRouteTransitionMixin`. This mixin then uses dedicated transition widgets like `CupertinoPageTransition` to create the visually distinct iOS sliding effect, using the provided `animation` objects to control the movement. We'll learn more about `CupertinoPageTransition` in a later chapter.

`CupertinoPageRoute` also has support for distinguishing between regular page transitions and fullscreen dialog transitions (like presenting a modal from the bottom on iOS), using different animation styles for each case, which is also handled by the `CupertinoRouteTransitionMixin`.

### Conclusion

`CupertinoPageRoute` is the specialized `PageRoute` for bringing the native iOS page transition experience (sliding from the right, parallax effect) to your Flutter apps, regardless of the actual device platform. It uses the `CupertinoRouteTransitionMixin` to manage the transition logic and apply the appropriate iOS-style animations. While `MaterialPageRoute` is usually preferred for platform-adaptive behavior in a single codebase, `CupertinoPageRoute` is perfect when you want a consistent iOS feel.

In the next chapter, we'll dive deeper into the `CupertinoRouteTransitionMixin` itself, similar to how we looked at its Material counterpart, to see exactly where this iOS transition magic comes from.

[Next Chapter: CupertinoRouteTransitionMixin](05_cupertinoroutetransitionmixin_.md)
---
# Chapter 5: CupertinoRouteTransitionMixin

Welcome back! In [Chapter 4: CupertinoPageRoute](04_cupertinopageroute_.md), we learned how `CupertinoPageRoute` helps us create iOS-style screen transitions automatically, giving our apps that native slide-from-the-right feel. We also briefly saw that `CupertinoPageRoute` uses something called `CupertinoRouteTransitionMixin` to get this behavior.

Now, it's time to shine a spotlight on the `CupertinoRouteTransitionMixin` itself!

### What is CupertinoRouteTransitionMixin?

Just like `MaterialRouteTransitionMixin` is the special recipe additive for Material Design transitions, `CupertinoRouteTransitionMixin` is the recipe additive for **Cupertino (iOS) page transitions**.

It's not a full `PageRoute` on its own, but it contains the vital instructions and ingredients needed to create the signature iOS sliding and fading animations for transitioning between screens.

Think of it as providing the "animation logic" that a `PageRoute` can use. Instead of writing the complex code to make a widget slide from the right and have the old page slightly move left (that parallax effect!), you can "mix in" `CupertinoRouteTransitionMixin` to automatically get that behavior.

It provides the core logic for:

1.  **How long** the transition takes (its duration).
2.  **How the animation fundamentally looks** (the sliding, the fading).
3.  **How it behaves** during interactive gestures, like swiping back from the edge of the screen on iOS.

`CupertinoPageRoute` itself uses `CupertinoRouteTransitionMixin` to implement its `buildTransitions` method, which is the core piece that tells the Navigator how to animate the new screen into view.

**Motivation:** We want to understand where the charming iOS sliding and parallax animations come from when we use `CupertinoPageRoute`. They come from `CupertinoRouteTransitionMixin`.

### How Mixins Work (A Quick Reminder)

As we talked about with `MaterialRouteTransitionMixin`, a mixin is a way to add a set of properties and methods from one class-like structure into another class, without needing traditional inheritance.

When a class `mixes in` a mixin, it gains all the public members of that mixin as if they were defined directly in the class itself.

`CupertinoPageRoute` uses `CupertinoRouteTransitionMixin` like this:

```dart
// Simplified from packages/flutter/lib/src/cupertino/route.dart
class CupertinoPageRoute<T> extends PageRoute<T> with CupertinoRouteTransitionMixin<T> {
  // CupertinoPageRoute now automatically has the buildTransitions method
  // and other properties defined in CupertinoRouteTransitionMixin
  // ... rest of CupertinoPageRoute code ...
}
```

This means `CupertinoPageRoute` doesn't have to write the `buildTransitions` code itself; it gets it "for free" by mixing in `CupertinoRouteTransitionMixin`.

### How it Connects to Building Transitions

The most important part that `CupertinoRouteTransitionMixin` provides is the implementation for the `buildTransitions` method that every `PageRoute` needs.

When you call `Navigator.push` with a `CupertinoPageRoute`, the Navigator needs to know how to animate the new page onto the screen. It calls the `buildTransitions` method of that `PageRoute`. Because `CupertinoPageRoute` mixed in `CupertinoRouteTransitionMixin`, it's actually the mixin's code that runs for `buildTransitions`.

Here's a look inside the mixin's `buildTransitions` method (simplified from the framework code):

```dart
// Simplified from packages/flutter/lib/src/cupertino/route.dart
mixin CupertinoRouteTransitionMixin<T> on PageRoute<T> {
  // ... other properties like transitionDuration ...

  @override
  Widget buildTransitions( // This method is provided by the mixin!
    BuildContext context,
    Animation<double> animation, // Animation for the incoming page
    Animation<double> secondaryAnimation, // Animation for the outgoing page
    Widget child, // The actual content of the page (your NewScreen)
  ) {
    // Inside here, the mixin's code figures out the right animation.
    // It uses specific transition widgets like CupertinoPageTransition
    // (or CupertinoFullscreenDialogTransition for dialogs).
    // It passes the 'child' (your new screen) and the 'animation' objects
    // to these transition widgets.

    // This line is the core – it calls dedicated builders for the transitions!
    return buildPageTransitions<T>(this, context, animation, secondaryAnimation, child);
  }

  // ... other methods ...
}
```

The `buildTransitions` method in `CupertinoRouteTransitionMixin` doesn't build the animation widget tree directly. Instead, it delegates that task to helper functions within the Cupertino library, specifically `buildPageTransitions`.

This `buildPageTransitions` helper method (which is part of the mixin's logic):

1.  Checks if this route is a normal page or a fullscreen dialog.
2.  Based on that, it chooses the correct transition widget.
    *   For normal pages, it picks `CupertinoPageTransition`.
    *   For fullscreen dialogs (like adding an event in the calendar), it picks `CupertinoFullscreenDialogTransition`.
3.  It creates an instance of the chosen transition widget, passing in:
    *   The `animation` for the incoming screen.
    *   The `secondaryAnimation` for the outgoing screen.
    *   Your actual screen widget (`child`).

So, the `CupertinoRouteTransitionMixin` acts as the orchestrator of the transition. It decides which specific animation widget to use and provides it with the necessary animation data.

Let's visualize this flow:

```mermaid
sequenceDiagram
    participant Navigator as Navigator
    participant CupertinoPageRoute as CupertinoPageRoute
    participant CRT_Mixin as CupertinoRouteTransitionMixin
    participant CPTransition as CupertinoPageTransition / CupertinoFullscreenDialogTransition
    participant NewScreen as NewScreen Widget

    Navigator->CupertinoPageRoute: calls buildTransitions(...)
    CupertinoPageRoute->CRT_Mixin: (delegates to mixin's method)
    CRT_Mixin->CRT_Mixin: calls buildPageTransitions(...)
    CRT_Mixin->CPTransition: creates CPTransition(...) with child and animations
    CPTransition->NewScreen: wraps NewScreen
    CRT_Mixin-->Navigator: returns CPTransition(NewScreen)
    Navigator->Navigator: Animates the transition using CPTransition
```

The `CupertinoPageTransition` and `CupertinoFullscreenDialogTransition` widgets are the ones that *actually perform* the visual animation (sliding the child widget using the provided animation values). We'll look at those in more detail in the next chapters!

### You Won't Necessarily Use It Directly

Similar to `MaterialRouteTransitionMixin`, you as a beginner app developer are typically not expected to directly use `CupertinoRouteTransitionMixin`. Its main purpose is to serve as a building block for other `PageRoute` types, most notably `CupertinoPageRoute`.

When you use `CupertinoPageRoute`, you automatically get the benefits of the transition logic contained within `CupertinoRouteTransitionMixin` without having to think about the mixin itself.

### Conclusion

`CupertinoRouteTransitionMixin` is the powerhouse behind `CupertinoPageRoute`'s native iOS transition animations. It provides the `buildTransitions` logic, deciding which specific Cupertino transition widget (`CupertinoPageTransition` or `CupertinoFullscreenDialogTransition`) to use based on the route type and giving it the necessary animation details to perform the visual effect. While you usually interact with `CupertinoPageRoute`, understanding that `CupertinoRouteTransitionMixin` provides the core animation recipe clarifies how these iOS-style transitions are achieved in Flutter.

In the next chapter, we'll focus on `CupertinoPageTransition`, the primary widget used by `CupertinoRouteTransitionMixin` to create the standard iOS page slide animation.

[Next Chapter: CupertinoPageTransition](06_cupertinopagetransition_.md)

Relevant Code Snippets (Code itself remains unchanged):
--- File: packages/flutter/lib/src/cupertino/route.dart ---
// Copyright 2014 The Flutter Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

/// @docImport 'dart:ui';
///
/// @docImport 'package:flutter/material.dart';
/// @docImport 'package:flutter/services.dart';
///
/// @docImport 'app.dart';
/// @docImport 'button.dart';
/// @docImport 'dialog.dart';
/// @docImport 'nav_bar.dart';
/// @docImport 'page_scaffold.dart';
/// @docImport 'tab_scaffold.dart';
library;

import 'dart:math';
import 'dart:ui' show ImageFilter;

import 'package:flutter/foundation.dart';
import 'package:flutter/gestures.dart';
import 'package:flutter/physics.dart';
import 'package:flutter/rendering.dart';
import 'package:flutter/widgets.dart';

import 'colors.dart';
import 'interface_level.dart';
import 'localizations.dart';

const double _kBackGestureWidth = 20.0;
const double _kMinFlingVelocity = 1.0; // Screen widths per second.

// The duration for a page to animate when the user releases it mid-swipe.
const Duration _kDroppedSwipePageAnimationDuration = Duration(milliseconds: 350);

/// Barrier color used for a barrier visible during transitions for Cupertino
/// page routes.
///
/// This barrier color is only used for full-screen page routes with
/// `fullscreenDialog: false`.
///
/// By default, `fullscreenDialog` Cupertino route transitions have no
/// `barrierColor`, and [CupertinoDialogRoute]s and [CupertinoModalPopupRoute]s
/// have a `barrierColor` defined by [kCupertinoModalBarrierColor].
///
/// A relatively rigorous eyeball estimation.
const Color _kCupertinoPageTransitionBarrierColor = Color(0x18000000);

/// Barrier color for a Cupertino modal barrier.
///
/// Extracted from https://developer.apple.com/design/resources/.
const Color kCupertinoModalBarrierColor = CupertinoDynamicColor.withBrightness(
  color: Color(0x33000000),
  darkColor: Color(0x7A000000),
);

// The duration of the transition used when a modal popup is shown.
const Duration _kModalPopupTransitionDuration = Duration(milliseconds: 335);

// Offset from offscreen to the right to fully on screen.
final Animatable<Offset> _kRightMiddleTween = Tween<Offset>(
  begin: const Offset(1.0, 0.0),
  end: Offset.zero,
);

// Offset from fully on screen to 1/3 offscreen to the left.
final Animatable<Offset> _kMiddleLeftTween = Tween<Offset>(
  begin: Offset.zero,
  end: const Offset(-1.0 / 3.0, 0.0),
);

// Offset from offscreen below to fully on screen.
final Animatable<Offset> _kBottomUpTween = Tween<Offset>(
  begin: const Offset(0.0, 1.0),
  end: Offset.zero,
);

/// A mixin that replaces the entire screen with an iOS transition for a
/// [PageRoute].
///
/// {@template flutter.cupertino.cupertinoRouteTransitionMixin}
/// The page slides in from the right and exits in reverse. The page also shifts
/// to the left in parallax when another page enters to cover it.
///
/// The page slides in from the bottom and exits in reverse with no parallax
/// effect for fullscreen dialogs.
/// {@endtemplate}
///
/// See also:
///
///  * [MaterialRouteTransitionMixin], which is a mixin that provides
///    platform-appropriate transitions for a [PageRoute].
///  * [CupertinoPageRoute], which is a [PageRoute] that leverages this mixin.
mixin CupertinoRouteTransitionMixin<T> on PageRoute<T> {
  /// Builds the primary contents of the route.
  @protected
  Widget buildContent(BuildContext context);

  /// {@template flutter.cupertino.CupertinoRouteTransitionMixin.title}
  /// A title string for this route.
  ///
  /// Used to auto-populate [CupertinoNavigationBar] and
  /// [CupertinoSliverNavigationBar]'s `middle`/`largeTitle` widgets when
  /// one is not manually supplied.
  /// {@endtemplate}
  String? get title;

  ValueNotifier<String?>? _previousTitle;

  /// The title string of the previous [CupertinoPageRoute].
  ///
  /// The [ValueListenable]'s value is readable after the route is installed
  /// onto a [Navigator]. The [ValueListenable] will also notify its listeners
  /// if the value changes (such as by replacing the previous route).
  ///
  /// The [ValueListenable] itself will be null before the route is installed.
  /// Its content value will be null if the previous route has no title or
  /// is not a [CupertinoPageRoute].
  ///
  /// See also:
  ///
  ///  * [ValueListenableBuilder], which can be used to listen and rebuild
  ///    widgets based on a ValueListenable.
  ValueListenable<String?> get previousTitle {
    assert(
      _previousTitle != null,
      'Cannot read the previousTitle for a route that has not yet been installed',
    );
    return _previousTitle!;
  }

  @override
  void dispose() {
    _previousTitle?.dispose();
    super.dispose();
  }

  @override
  void didChangePrevious(Route<dynamic>? previousRoute) {
    final String? previousTitleString =
        previousRoute is CupertinoRouteTransitionMixin ? previousRoute.title : null;
    if (_previousTitle == null) {
      _previousTitle = ValueNotifier<String?>(previousTitleString);
    } else {
      _previousTitle!.value = previousTitleString;
    }
    super.didChangePrevious(previousRoute);
  }

  @override
  // A relatively rigorous eyeball estimation.
  Duration get transitionDuration => const Duration(milliseconds: 500);

  @override
  Color? get barrierColor => fullscreenDialog ? null : _kCupertinoPageTransitionBarrierColor;

  @override
  String? get barrierLabel => null;

  @override
  bool canTransitionTo(TransitionRoute<dynamic> nextRoute) {
    // Don't perform outgoing animation if the next route is a fullscreen dialog.
    final bool nextRouteIsNotFullscreen =
        (nextRoute is! PageRoute<T>) || !nextRoute.fullscreenDialog;

    // If the next route has a delegated transition, then this route is able to
    // use that delegated transition to smoothly sync with the next route's
    // transition.
    final bool nextRouteHasDelegatedTransition =
        nextRoute is ModalRoute<T> && nextRoute.delegatedTransition != null;

    // Otherwise if the next route has the same route transition mixin as this
    // one, then this route will already be synced with its transition.
    return nextRouteIsNotFullscreen &&
        ((nextRoute is CupertinoRouteTransitionMixin) || nextRouteHasDelegatedTransition);
  }

  @override
  bool canTransitionFrom(TransitionRoute<dynamic> previousRoute) {
    // Supress previous route from transitioning if this is a fullscreenDialog route.
    return previousRoute is PageRoute && !fullscreenDialog;
  }

  @override
  Widget buildPage(
    BuildContext context,
    Animation<double> animation,
    Animation<double> secondaryAnimation,
  ) {
    final Widget child = buildContent(context);
    return Semantics(scopesRoute: true, explicitChildNodes: true, child: child);
  }

  // Called by _CupertinoBackGestureDetector when a pop ("back") drag start
  // gesture is detected. The returned controller handles all of the subsequent
  // drag events.
  static _CupertinoBackGestureController<T> _startPopGesture<T>(PageRoute<T> route) {
    assert(route.popGestureEnabled);

    return _CupertinoBackGestureController<T>(
      navigator: route.navigator!,
      getIsCurrent: () => route.isCurrent,
      getIsActive: () => route.isActive,
      controller: route.controller!, // protected access
    );
  }

  /// Returns a [CupertinoFullscreenDialogTransition] if [route] is a full
  /// screen dialog, otherwise a [CupertinoPageTransition] is returned.
  ///
  /// Used by [CupertinoPageRoute.buildTransitions].
  ///
  /// This method can be applied to any [PageRoute], not just
  /// [CupertinoPageRoute]. It's typically used to provide a Cupertino style
  /// horizontal transition for material widgets when the target platform
  /// is [TargetPlatform.iOS].
  ///
  /// See also:
  ///
  ///  * [CupertinoPageTransitionsBuilder], which uses this method to define a
  ///    [PageTransitionsBuilder] for the [PageTransitionsTheme].
  static Widget buildPageTransitions<T>(
    PageRoute<T> route,
    BuildContext context,
    Animation<double> animation,
    Animation<double> secondaryAnimation,
    Widget child,
  ) {
    // Check if the route has an animation that's currently participating
    // in a back swipe gesture.
    //
    // In the middle of a back gesture drag, let the transition be linear to
    // match finger motions.
    final bool linearTransition = route.popGestureInProgress;
    if (route.fullscreenDialog) {
      return CupertinoFullscreenDialogTransition(
        primaryRouteAnimation: animation,
        secondaryRouteAnimation: secondaryAnimation,
        linearTransition: linearTransition,
        child: child,
      );
    } else {
      return CupertinoPageTransition(
        primaryRouteAnimation: animation,
        secondaryRouteAnimation: secondaryAnimation,
        linearTransition: linearTransition,
        child: _CupertinoBackGestureDetector<T>(
          enabledCallback: () => route.popGestureEnabled,
          onStartPopGesture: () => _startPopGesture<T>(route),
          child: child,
        ),
      );
    }
  }

  @override
  Widget buildTransitions(
    BuildContext context,
    Animation<double> animation,
    Animation<double> secondaryAnimation,
    Widget child,
  ) {
    return buildPageTransitions<T>(this, context, animation, secondaryAnimation, child);
  }
}

/// A modal route that replaces the entire screen with an iOS transition.
///
/// {@macro flutter.cupertino.cupertinoRouteTransitionMixin}
///
/// By default, when a modal route is replaced by another, the previous route
/// remains in memory. To free all the resources when this is not necessary, set
/// [maintainState] to false.
///
/// The type `T` specifies the return type of the route which can be supplied as
/// the route is popped from the stack via [Navigator.pop] when an optional
/// `result` can be provided.
///
/// If `barrierDismissible` is true, then pressing the escape key on the keyboard
/// will cause the current route to be popped with null as the value.
///
/// See also:
///
///  * [CupertinoRouteTransitionMixin], for a mixin that provides iOS transition
///    for this modal route.
///  * [MaterialPageRoute], for an adaptive [PageRoute] that uses a
///    platform-appropriate transition.
///  * [CupertinoPageScaffold], for applications that have one page with a fixed
///    navigation bar on top.
///  * [CupertinoTabScaffold], for applications that have a tab bar at the
///    bottom with multiple pages.
///  * [CupertinoPage], for a [Page] version of this class.
class CupertinoPageRoute<T> extends PageRoute<T> with CupertinoRouteTransitionMixin<T> {
  /// Creates a page route for use in an iOS designed app.
  ///
  /// The [builder], [maintainState], and [fullscreenDialog] arguments must not
  /// be null.
  CupertinoPageRoute({
    required this.builder,
    this.title,
    super.settings,
    super.requestFocus,
    this.maintainState = true,
    super.fullscreenDialog,
    super.allowSnapshotting = true,
    super.barrierDismissible = false,
  }) {
    assert(opaque);
  }

  @override
  DelegatedTransitionBuilder? get delegatedTransition =>
      CupertinoPageTransition.delegatedTransition;

  /// Builds the primary contents of the route.
  final WidgetBuilder builder;

  @override
  Widget buildContent(BuildContext context) => builder(context);

  @override
  final String? title;

  @override
  final bool maintainState;

  @override
  String get debugLabel => '${super.debugLabel}(${settings.name})';
}

// A page-based version of CupertinoPageRoute.
//
// This route uses the builder from the page to build its content. This ensures
// the content is up to date after page updates.
class _PageBasedCupertinoPageRoute<T> extends PageRoute<T> with CupertinoRouteTransitionMixin<T> {
  _PageBasedCupertinoPageRoute({required CupertinoPage<T> page, super.allowSnapshotting = true})
    : super(settings: page) {
    assert(opaque);
  }

  @override
  DelegatedTransitionBuilder? get delegatedTransition =>
      this.fullscreenDialog ? null : CupertinoPageTransition.delegatedTransition;

  CupertinoPage<T> get _page => settings as CupertinoPage<T>;

  @override
  Widget buildContent(BuildContext context) => _page.child;

  @override
  String? get title => _page.title;

  @override
  bool get maintainState => _page.maintainState;

  @override
  bool get fullscreenDialog => _page.fullscreenDialog;

  @override
  String get debugLabel => '${super.debugLabel}(${_page.name})';
}

/// A page that creates a cupertino style [PageRoute].
///
/// {@macro flutter.cupertino.cupertinoRouteTransitionMixin}
///
/// By default, when a created modal route is replaced by another, the previous
/// route remains in memory. To free all the resources when this is not
/// necessary, set [maintainState] to false.
///
/// The type `T` specifies the return type of the route which can be supplied as
/// the route is popped from the stack via [Navigator.transitionDelegate] by
/// providing the optional `result` argument to the
/// [RouteTransitionRecord.markForPop] in the [TransitionDelegate.resolve].
///
/// See also:
///
///  * [CupertinoPageRoute], for a [PageRoute] version of this class.
class CupertinoPage<T> extends Page<T> {
  /// Creates a cupertino page.
  const CupertinoPage({
    required this.child,
    this.maintainState = true,
    this.title,
    this.fullscreenDialog = false,
    this.allowSnapshotting = true,
    super.canPop,
    super.onPopInvoked,
    super.key,
    super.name,
    super.arguments,
    super.restorationId,
  });

  /// The content to be shown in the [Route] created by this page.
  final Widget child;

  /// {@macro flutter.cupertino.CupertinoRouteTransitionMixin.title}
  final String? title;

  /// {@macro flutter.widgets.ModalRoute.maintainState}
  final bool maintainState;

  /// {@macro flutter.widgets.PageRoute.fullscreenDialog}
  final bool fullscreenDialog;

  /// {@macro flutter.widgets.TransitionRoute.allowSnapshotting}
  final bool allowSnapshotting;

  @override
  Route<T> createRoute(BuildContext context) {
    return _PageBasedCupertinoPageRoute<T>(page: this, allowSnapshotting: allowSnapshotting);
  }
}

/// Provides an iOS-style page transition animation.
///
/// The page slides in from the right and exits in reverse. It also shifts to the left in
/// a parallax motion when another page enters to cover it.
class CupertinoPageTransition extends StatefulWidget {
  /// Creates an iOS-style page transition.
  ///
  const CupertinoPageTransition({
    super.key,
    required this.primaryRouteAnimation,
    required this.secondaryRouteAnimation,
    required this.child,
    required this.linearTransition,
  });

  /// The widget below this widget in the tree.
  final Widget child;

  ///  * `primaryRouteAnimation` is a linear route animation from 0.0 to 1.0
  ///    when this screen is being pushed.
  final Animation<double> primaryRouteAnimation;

  ///  * `secondaryRouteAnimation` is a linear route animation from 0.0 to 1.0
  ///    when another screen is being pushed on top of this one.
  final Animation<double> secondaryRouteAnimation;

  ///  * `linearTransition` is whether to perform the transitions linearly.
  ///    Used to precisely track back gesture drags.
  final bool linearTransition;

  /// The Cupertino styled [DelegatedTransitionBuilder] provided to the previous
  /// route.
  ///
  /// {@macro flutter.widgets.delegatedTransition}
  static Widget? delegatedTransition(
    BuildContext context,
    Animation<double> animation,
    Animation<double> secondaryAnimation,
    bool allowSnapshotting,
    Widget? child,
  ) {
    final CurvedAnimation animation = CurvedAnimation(
      parent: secondaryAnimation,
      curve: Curves.linearToEaseOut,
      reverseCurve: Curves.easeInToLinear,
    );
    final Animation<Offset> delegatedPositionAnimation = animation.drive(_kMiddleLeftTween);
    animation.dispose();

    assert(debugCheckHasDirectionality(context));
    final TextDirection textDirection = Directionality.of(context);
    return SlideTransition(
      position: delegatedPositionAnimation,
      textDirection: textDirection,
      transformHitTests: false,
      child: child,
    );
  }

  @override
  State<CupertinoPageTransition> createState() => _CupertinoPageTransitionState();
}

class _CupertinoPageTransitionState extends State<CupertinoPageTransition> {
  // When this page is coming in to cover another page.
  late Animation<Offset> _primaryPositionAnimation;
  // When this page is becoming covered by another page.
  late Animation<Offset> _secondaryPositionAnimation;
  // Shadow of page which is coming in to cover another page.
  late Animation<Decoration> _primaryShadowAnimation;
  // Curve of primary page which is coming in to cover another page.
  CurvedAnimation? _primaryPositionCurve;
  // Curve of secondary page which is becoming covered by another page.
  CurvedAnimation? _secondaryPositionCurve;
  // Curve of primary page's shadow.
  CurvedAnimation? _primaryShadowCurve;

  @override
  void initState() {
    super.initState();
    _setupAnimation();
  }

  @override
  void didUpdateWidget(covariant CupertinoPageTransition oldWidget) {
    super.didUpdateWidget(oldWidget);
    if (oldWidget.primaryRouteAnimation != widget.primaryRouteAnimation ||
        oldWidget.secondaryRouteAnimation != widget.secondaryRouteAnimation ||
        oldWidget.linearTransition != widget.linearTransition) {
      _disposeCurve();
      _setupAnimation();
    }
  }

  @override
  void dispose() {
    _disposeCurve();
    super.dispose();
  }

  void _disposeCurve() {
    _primaryPositionCurve?.dispose();
    _secondaryPositionCurve?.dispose();
    _primaryShadowCurve?.dispose();
    _primaryPositionCurve = null;
    _secondaryPositionCurve = null;
    _primaryShadowCurve = null;
  }

  void _setupAnimation() {
    if (!widget.linearTransition) {
      _primaryPositionCurve = CurvedAnimation(
        parent: widget.primaryRouteAnimation,
        curve: Curves.fastEaseInToSlowEaseOut,
        reverseCurve: Curves.fastEaseInToSlowEaseOut.flipped,
      );
      _secondaryPositionCurve = CurvedAnimation(
        parent: widget.secondaryRouteAnimation,
        curve: Curves.linearToEaseOut,
        reverseCurve: Curves.easeInToLinear,
      );
      _primaryShadowCurve = CurvedAnimation(
        parent: widget.primaryRouteAnimation,
        curve: Curves.linearToEaseOut,
      );
    }
    _primaryPositionAnimation = (_primaryPositionCurve ?? widget.primaryRouteAnimation).drive(
      _kRightMiddleTween,
    );
    _secondaryPositionAnimation = (_secondaryPositionCurve ?? widget.secondaryRouteAnimation).drive(
      _kMiddleLeftTween,
    );
    _primaryShadowAnimation = (_primaryShadowCurve ?? widget.primaryRouteAnimation).drive(
      _CupertinoEdgeShadowDecoration.kTween,
    );
  }

  @override
  Widget build(BuildContext context) {
    assert(debugCheckHasDirectionality(context));
    final TextDirection textDirection = Directionality.of(context);
    return SlideTransition(
      position: _secondaryPositionAnimation,
      textDirection: textDirection,
      transformHitTests: false,
      child: SlideTransition(
        position: _primaryPositionAnimation,
        textDirection: textDirection,
        child: DecoratedBoxTransition(decoration: _primaryShadowAnimation, child: widget.child),
      ),
    );
  }
}

/// An iOS-style transition used for summoning fullscreen dialogs.
///
/// For example, used when creating a new calendar event by bringing in the next
/// screen from the bottom.
class CupertinoFullscreenDialogTransition extends StatefulWidget {
  /// Creates an iOS-style transition used for summoning fullscreen dialogs.
  ///
  const CupertinoFullscreenDialogTransition({
    super.key,
    required this.primaryRouteAnimation,
    required this.secondaryRouteAnimation,
    required this.child,
    required this.linearTransition,
  });

  ///  * `primaryRouteAnimation` is a linear route animation from 0.0 to 1.0
  ///    when this screen is being pushed.
  final Animation<double> primaryRouteAnimation;

  ///  * `secondaryRouteAnimation` is a linear route animation from 0.0 to 1.0
  ///    when another screen is being pushed on top of this one.
  final Animation<double> secondaryRouteAnimation;

  ///  * `linearTransition` is whether to perform the transitions linearly.
  ///    Used to precisely track back gesture drags.
  final bool linearTransition;

  /// The widget below this widget in the tree.
  final Widget child;

  @override
  State<CupertinoFullscreenDialogTransition> createState() =>
      _CupertinoFullscreenDialogTransitionState();
}

class _CupertinoFullscreenDialogTransitionState extends State<CupertinoFullscreenDialogTransition> {
  /// When this page is coming in to cover another page.
  late Animation<Offset> _primaryPositionAnimation;

  /// When this page is becoming covered by another page.
  late Animation<Offset> _secondaryPositionAnimation;

  /// Curve of primary page which is coming in to cover another page.
  CurvedAnimation? _primaryPositionCurve;

  /// Curve of secondary page which is becoming covered by another page.
  CurvedAnimation? _secondaryPositionCurve;

  @override
  void initState() {
    super.initState();
    _setupAnimation();
  }

  @override
  void didUpdateWidget(covariant CupertinoFullscreenDialogTransition oldWidget) {
    super.didUpdateWidget(oldWidget);
    if (oldWidget.primaryRouteAnimation != widget.primaryRouteAnimation ||
        oldWidget.secondaryRouteAnimation != widget.secondaryRouteAnimation ||
        oldWidget.linearTransition != widget.linearTransition) {
      _disposeCurve();
      _setupAnimation();
    }
  }

  @override
  void dispose() {
    _disposeCurve();
    super.dispose();
  }

  void _disposeCurve() {
    _primaryPositionCurve?.dispose();
    _secondaryPositionCurve?.dispose();
    _primaryPositionCurve = null;
    _secondaryPositionCurve = null;
  }

  void _setupAnimation() {
    _primaryPositionAnimation = (_primaryPositionCurve = CurvedAnimation(
          parent: widget.primaryRouteAnimation,
          curve: Curves.linearToEaseOut,
          // The curve must be flipped so that the reverse animation doesn't play
          // an ease-in curve, which iOS does not use.
          reverseCurve: Curves.linearToEaseOut.flipped,
        ))
        .drive(_kBottomUpTween);
    _secondaryPositionAnimation = (widget.linearTransition
            ? widget.secondaryRouteAnimation
            : _secondaryPositionCurve = CurvedAnimation(
              parent: widget.secondaryRouteAnimation,
              curve: Curves.linearToEaseOut,
              reverseCurve: Curves.easeInToLinear,
            ))
        .drive(_kMiddleLeftTween);
  }

  @override
  Widget build(BuildContext context) {
    assert(debugCheckHasDirectionality(context));
    final TextDirection textDirection = Directionality.of(context);
    return SlideTransition(
      position: _secondaryPositionAnimation,
      textDirection: textDirection,
      transformHitTests: false,
      child: SlideTransition(position: _primaryPositionAnimation, child: widget.child),
    );
  }
}

/// This is the widget side of [_CupertinoBackGestureController].
///
/// This widget provides a gesture recognizer which, when it determines the
/// route can be closed with a back gesture, creates the controller and
/// feeds it the input from the gesture recognizer.
///
/// The gesture data is converted from absolute coordinates to logical
/// coordinates by this widget.
///
/// The type `T` specifies the return type of the route with which this gesture
/// detector is associated.
class _CupertinoBackGestureDetector<T> extends StatefulWidget {
  const _CupertinoBackGestureDetector({
    super.key,
    required this.enabledCallback,
    required this.onStartPopGesture,
    required this.child,
  });

  final Widget child;

  final ValueGetter<bool> enabledCallback;

  final ValueGetter<_CupertinoBackGestureController<T>> onStartPopGesture;

  @override
  _CupertinoBackGestureDetectorState<T> createState() => _CupertinoBackGestureDetectorState<T>();
}

class _CupertinoBackGestureDetectorState<T> extends State<_CupertinoBackGestureDetector<T>> {
  _CupertinoBackGestureController<T>? _backGestureController;

  late HorizontalDragGestureRecognizer _recognizer;

  @override
  void initState() {
    super.initState();
    _recognizer =
        HorizontalDragGestureRecognizer(debugOwner: this)
          ..onStart = _handleDragStart
          ..onUpdate = _handleDragUpdate
          ..onEnd = _handleDragEnd
          ..onCancel = _handleDragCancel;
  }

  @override
  void dispose() {
    _recognizer.dispose();

    // If this is disposed during a drag, call navigator.didStopUserGesture.
    if (_backGestureController != null) {
      WidgetsBinding.instance.addPostFrameCallback((_) {
        if (_backGestureController?.navigator.mounted ?? false) {
          _backGestureController?.navigator.didStopUserGesture();
        }
        _backGestureController = null;
      });
    }
    super.dispose();
  }

  void _handleDragStart(DragStartDetails details) {
    assert(mounted);
    assert(_backGestureController == null);
    _backGestureController = widget.onStartPopGesture();
  }

  void _handleDragUpdate(DragUpdateDetails details) {
    assert(mounted);
    assert(_backGestureController != null);
    _backGestureController!.dragUpdate(
      _convertToLogical(details.primaryDelta! / context.size!.width),
    );
  }

  void _handleDragEnd(DragEndDetails details) {
    assert(mounted);
    assert(_backGestureController != null);
    _backGestureController!.dragEnd(
      _convertToLogical(details.velocity.pixelsPerSecond.dx / context.size!.width),
    );
    _backGestureController = null;
  }

  void _handleDragCancel() {
    assert(mounted);
    // This can be called even if start is not called, paired with the "down" event
    // that we don't consider here.
    _backGestureController?.dragEnd(0.0);
    _backGestureController = null;
  }

  void _handlePointerDown(PointerDownEvent event) {
    if (widget.enabledCallback()) {
      _recognizer.addPointer(event);
    }
  }

  double _convertToLogical(double value) {
    return switch (Directionality.of(context)) {
      TextDirection.rtl => -value,
      TextDirection.ltr => value,
    };
  }

  @override
  Widget build(BuildContext context) {
    assert(debugCheckHasDirectionality(context));
    // For devices with notches, the drag area needs to be larger on the side
    // that has the notch.
    final double dragAreaWidth = switch (Directionality.of(context)) {
      TextDirection.rtl => MediaQuery.paddingOf(context).right,
      TextDirection.ltr => MediaQuery.paddingOf(context).left,
    };
    return Stack(
      fit: StackFit.passthrough,
      children: <Widget>[
        widget.child,
        PositionedDirectional(
          start: 0.0,
          width: max(dragAreaWidth, _kBackGestureWidth),
          top: 0.0,
          bottom: 0.0,
          child: Listener(onPointerDown: _handlePointerDown, behavior: HitTestBehavior.translucent),
        ),
      ],
    );
  }
}

/// A controller for an iOS-style back gesture.
///
/// This is created by a [CupertinoPageRoute] in response from a gesture caught
/// by a [_CupertinoBackGestureDetector] widget, which then also feeds it input
/// from the gesture. It controls the animation controller owned by the route,
/// based on the input provided by the gesture detector.
///
/// This class works entirely in logical coordinates (0.0 is new page dismissed,
/// 1.0 is new page on top).
///
/// The type `T` specifies the return type of the route with which this gesture
/// detector controller is associated.
class _CupertinoBackGestureController<T> {
  /// Creates a controller for an iOS-style back gesture.
  _CupertinoBackGestureController({
    required this.navigator,
    required this.controller,
    required this.getIsActive,
    required this.getIsCurrent,
  }) {
    navigator.didStartUserGesture();
  }

  final AnimationController controller;
  final NavigatorState navigator;
  final ValueGetter<bool> getIsActive;
  final ValueGetter<bool> getIsCurrent;

  /// The drag gesture has changed by [delta]. The total range of the drag
  /// should be 0.0 to 1.0.
  void dragUpdate(double delta) {
    controller.value -= delta;
  }

  /// The drag gesture has ended with a horizontal motion of [velocity] as a
  /// fraction of screen width per second.
  void dragEnd(double velocity) {
    // Fling in the appropriate direction.
    //
    // This curve has been determined through rigorously eyeballing native iOS
    // animations.
    const Curve animationCurve = Curves.fastEaseInToSlowEaseOut;
    final bool isCurrent = getIsCurrent();
    final bool animateForward;

    if (!isCurrent) {
      // If the page has already been navigated away from, then the animation
      // direction depends on whether or not it's still in the navigation stack,
      // regardless of velocity or drag position. For example, if a route is
      // being slowly dragged back by just a few pixels, but then a programmatic
      // pop occurs, the route should still be animated off the screen.
      // See https://github.com/flutter/flutter/issues/141268.
      animateForward = getIsActive();
    } else if (velocity.abs() >= _kMinFlingVelocity) {
      // If the user releases the page before mid screen with sufficient velocity,
      // or after mid screen, we should animate the page out. Otherwise, the page
      // should be animated back in.
      animateForward = velocity <= 0;
    } else {
      animateForward = controller.value > 0.5;
    }

    if (animateForward) {
      controller.animateTo(
        1.0,
        duration: _kDroppedSwipePageAnimationDuration,
        curve: animationCurve,
      );
    } else {
      if (isCurrent) {
        // This route is destined to pop at this point. Reuse navigator's pop.
        navigator.pop();
      }

      // The popping may have finished inline if already at the target destination.
      if (controller.isAnimating) {
        controller.animateBack(
          0.0,
          duration: _kDroppedSwipePageAnimationDuration,
          curve: animationCurve,
        );
      }
    }

    if (controller.isAnimating) {
      // Keep the userGestureInProgress in true state so we don't change the
      // curve of the page transition mid-flight since CupertinoPageTransition
      // depends on userGestureInProgress.
      late AnimationStatusListener animationStatusCallback;
      animationStatusCallback = (AnimationStatus status) {
        navigator.didStopUserGesture();
        controller.removeStatusListener(animationStatusCallback);
      };
      controller.addStatusListener(animationStatusCallback);
    } else {
      navigator.didStopUserGesture();
    }
  }
}

// A custom [Decoration] used to paint an extra shadow on the start edge of the
// box it's decorating. It's like a [BoxDecoration] with only a gradient except
// it paints on the start side of the box instead of behind the box.
class _CupertinoEdgeShadowDecoration extends Decoration {
  const _CupertinoEdgeShadowDecoration._([this._colors]);

  static DecorationTween kTween = DecorationTween(
    begin: const _CupertinoEdgeShadowDecoration._(), // No decoration initially.
    end: const _CupertinoEdgeShadowDecoration._(
      // Eyeballed gradient used to mimic a drop shadow on the start side only.
      <Color>[Color(0x04000000), CupertinoColors.transparent],
    ),
  );

  // Colors used to paint a gradient at the start edge of the box it is
  // decorating.
  //
  // The first color in the list is used at the start of the gradient, which
  // is located at the start edge of the decorated box.
  //
  // If this is null, no shadow is drawn.
  //
  // The list must have at least two colors in it (otherwise it would not be a
  // gradient).
  final List<Color>? _colors;

  // Linearly interpolate between two edge shadow decorations decorations.
  //
  // The `t` argument represents position on the timeline, with 0.0 meaning
  // that the interpolation has not started, returning `a` (or something
  // equivalent to `a`), 1.0 meaning that the interpolation has finished,
  // returning `b` (or something equivalent to `b`), and values in between
  // meaning that the interpolation is at the relevant point on the timeline
  // between `a` and `b`. The interpolation can be extrapolated beyond 0.0 and
  // 1.0, so negative values and values greater than 1.0 are valid (and can
  // easily be generated by curves such as [Curves.elasticInOut]).
  //
  // Values for `t` are usually obtained from an [Animation<double>], such as
  // an [AnimationController].
  //
  // See also:
  //
  //  * [Decoration.lerp].
  static _CupertinoEdgeShadowDecoration? lerp(
    _CupertinoEdgeShadowDecoration? a,
    _CupertinoEdgeShadowDecoration? b,
    double t,
  ) {
    if (identical(a, b)) {
      return a;
    }
    if (a == null) {
      return b!._colors == null
          ? b
          : _CupertinoEdgeShadowDecoration._(
            b._colors!.map<Color>((Color color) => Color.lerp(null, color, t)!).toList(),
          );
    }
    if (b == null) {
      return a._colors == null
          ? a
          : _CupertinoEdgeShadowDecoration._(
            a._colors.map<Color>((Color color) => Color.lerp(null, color, 1.0 - t)!).toList(),
          );
    }
    assert(b._colors != null || a._colors != null);
    // If it ever becomes necessary, we could allow decorations with different
    // length' here, similarly to how it is handled in [LinearGradient.lerp].
    assert(b._colors == null || a._colors == null || a._colors.length == b._colors.length);
    return _CupertinoEdgeShadowDecoration._(<Color>[
      for (int i = 0; i < b._colors!.length; i += 1) Color.lerp(a._colors?[i], b._colors[i], t)!,
    ]);
  }

  @override
  _CupertinoEdgeShadowDecoration lerpFrom(Decoration? a, double t) {
    if (a is _CupertinoEdgeShadowDecoration) {
      return _CupertinoEdgeShadowDecoration.lerp(a, this, t)!;
    }
    return _CupertinoEdgeShadowDecoration.lerp(null, this, t)!;
  }

  @override
  _CupertinoEdgeShadowDecoration lerpTo(Decoration? b, double t) {
    if (b is _CupertinoEdgeShadowDecoration) {
      return _CupertinoEdgeShadowDecoration.lerp(this, b, t)!;
    }
    return _CupertinoEdgeShadowDecoration.lerp(this, null, t)!;
  }

  @override
  _CupertinoEdgeShadowPainter createBoxPainter([VoidCallback? onChanged]) {
    return _CupertinoEdgeShadowPainter(this, onChanged);
  }

  @override
  bool operator ==(Object other) {
    if (other.runtimeType != runtimeType) {
      return false;
    }
    return other is _CupertinoEdgeShadowDecoration && other._colors == _colors;
  }

  @override
  int get hashCode => _colors.hashCode;

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties.add(IterableProperty<Color>('colors', _colors));
  }
}

/// A [BoxPainter] used to draw the page transition shadow using gradients.
class _CupertinoEdgeShadowPainter extends BoxPainter {
  _CupertinoEdgeShadowPainter(this._decoration, super.onChanged)
    : assert(_decoration._colors == null || _decoration._colors.length > 1);

  final _CupertinoEdgeShadowDecoration _decoration;

  @override
  void paint(Canvas canvas, Offset offset, ImageConfiguration configuration) {
    final List<Color>? colors = _decoration._colors;
    if (colors == null) {
      return;
    }

    // The following code simulates drawing a [LinearGradient] configured as
    // follows:
    //
    // LinearGradient(
    //   begin: AlignmentDirectional(0.90, 0.0), // Spans 5% of the page.
    //   colors: _decoration._colors,
    // )
    //
    // A performance evaluation on Feb 8, 2021 showed, that drawing the gradient
    // manually as implemented below is more performant than relying on
    // [LinearGradient.createShader] because compiling that shader takes a long
    // time. On an iPhone XR, the implementation below reduced the worst frame
    // time for a cupertino page transition of a newly installed app from ~95ms
    // down to ~30ms, mainly because there's no longer a need to compile a
    // shader for the LinearGradient.
    //
    // The implementation below divides the width of the shadow into multiple
    // bands of equal width, one for each color interval defined by
    // `_decoration._colors`. Band x is filled with a gradient going from
    // `_decoration._colors[x]` to `_decoration._colors[x + 1]` by drawing a
    // bunch of 1px wide rects. The rects change their color by lerping between
    // the two colors that define the interval of the band.

    // Shadow spans 5% of the page.
    final double shadowWidth = 0.05 * configuration.size!.width;
    final double shadowHeight = configuration.size!.height;
    final double bandWidth = shadowWidth / (colors.length - 1);

    final TextDirection? textDirection = configuration.textDirection;
    assert(textDirection != null);
    final (double shadowDirection, double start) = switch (textDirection!) {
      TextDirection.rtl => (1, offset.dx + configuration.size!.width),
      TextDirection.ltr => (-1, offset.dx),
    };

    int bandColorIndex = 0;
    for (int dx = 0; dx < shadowWidth; dx += 1) {
      if (dx ~/ bandWidth != bandColorIndex) {
        bandColorIndex += 1;
      }
      final Paint paint =
          Paint()
            ..color =
                Color.lerp(
                  colors[bandColorIndex],
                  colors[bandColorIndex + 1],
                  (dx % bandWidth) / bandWidth,
                )!;
      final double x = start + shadowDirection * dx;
      canvas.drawRect(Rect.fromLTWH(x - 1.0, offset.dy, 1.0, shadowHeight), paint);
    }
  }
}

// The stiffness used by dialogs and action sheets.
//
// The stiffness value is obtained by examining the properties of
// `CASpringAnimation` in Xcode. The damping value is derived similarly, with
// additional precision calculated based on `_kStandardStiffness` to ensure a
// damping ratio of 1 (critically damped): damping = 2 * sqrt(stiffness)
const double _kStandardStiffness = 522.35;
const double _kStandardDamping = 45.7099552;
const SpringDescription _kStandardSpring = SpringDescription(
  mass: 1,
  stiffness: _kStandardStiffness,
  damping: _kStandardDamping,
);
// The iOS spring animation duration is 0.404 seconds, based on the properties
// of `CASpringAnimation` in Xcode. At this point, the spring's position
// `x(0.404)` is approximately 0.9990000, suggesting that iOS uses a position
// tolerance of 1e-3 (matching the default `_epsilonDefault` value).
//
// However, the spring's velocity `dx(0.404)` is about 0.02, indicating that iOS
// may not consider velocity when determining the animation's end condition. To
// account for this, a larger velocity tolerance is applied here for added
// safety.
const Tolerance _kStandardTolerance = Tolerance(velocity: 0.03);

/// A route that shows a modal iOS-style popup that slides up from the
/// bottom of the screen.
///
/// Such a popup is an alternative to a menu or a dialog and prevents the user
/// from interacting with the rest of the app.
///
/// It is used internally by [showCupertinoModalPopup] or can be directly pushed
/// onto the [Navigator] stack to enable state restoration. See
/// [showCupertinoModalPopup] for a state restoration app example.
///
/// The `barrierColor` argument determines the [Color] of the barrier underneath
/// the popup. When unspecified, the barrier color defaults to a light opacity
/// black scrim based on iOS's dialog screens. To correctly have iOS resolve
/// to the appropriate modal colors, pass in
/// `CupertinoDynamicColor.resolve(kCupertinoModalBarrierColor, context)`.
///
/// The `barrierDismissible` argument determines whether clicking outside the
/// popup results in dismissal. It is `true` by default.
///
/// The `semanticsDismissible` argument is used to determine whether the
/// semantics of the modal barrier are included in the semantics tree.
///
/// The `routeSettings` argument is used to provide [RouteSettings] to the
/// created Route.
///
/// {@macro flutter.widgets.RawDialogRoute}
///
/// See also:
///
///  * [DisplayFeatureSubScreen], which documents the specifics of how
///    [DisplayFeature]s can split the screen into sub-screens.
///  * [CupertinoActionSheet], which is the widget usually returned by the
///    `builder` argument.
///  * <https://developer.apple.com/design/human-interface-guidelines/ios/views/action-sheets/>
class CupertinoModalPopupRoute<T> extends PopupRoute<T> {
  /// A route that shows a modal iOS-style popup that slides up from the
  /// bottom of the screen.
  CupertinoModalPopupRoute({
    required this.builder,
    this.barrierLabel = 'Dismiss',
    this.barrierColor = kCupertinoModalBarrierColor,
    bool barrierDismissible = true,
    bool semanticsDismissible = false,
    super.filter,
    super.settings,
    super.requestFocus,
    this.anchorPoint,
  }) : _barrierDismissible = barrierDismissible,
       _semanticsDismissible = semanticsDismissible;

  /// A builder that builds the widget tree for the [CupertinoModalPopupRoute].
  ///
  /// The [builder] argument typically builds a [CupertinoActionSheet] widget.
  ///
  /// Content below the widget is dimmed with a [ModalBarrier]. The widget built
  /// by the [builder] does not share a context with the route it was originally
  /// built from. Use a [StatefulBuilder] or a custom [StatefulWidget] if the
  /// widget needs to update dynamically.
  final WidgetBuilder builder;

  final bool _barrierDismissible;

  final bool _semanticsDismissible;

  @override
  final String barrierLabel;

  @override
  final Color? barrierColor;

  @override
  bool get barrierDismissible => _barrierDismissible;

  @override
  bool get semanticsDismissible => _semanticsDismissible;

  @override
  Duration get transitionDuration => _kModalPopupTransitionDuration;

  /// {@macro flutter.widgets.DisplayFeatureSubScreen.anchorPoint}
  final Offset? anchorPoint;

  @override
  Simulation createSimulation({required bool forward}) {
    assert(!debugTransitionCompleted(), 'Cannot reuse a $runtimeType after disposing it.');
    final double end = forward ? 1.0 : 0.0;
    return SpringSimulation(
      _kStandardSpring,
      controller!.value,
      end,
      0,
      tolerance: _kStandardTolerance,
      snapToEnd: true,
    );
  }

  @override
  Widget buildPage(
    BuildContext context,
    Animation<double> animation,
    Animation<double> secondaryAnimation,
  ) {
    return CupertinoUserInterfaceLevel(
      data: CupertinoUserInterfaceLevelData.elevated,
      child: DisplayFeatureSubScreen(anchorPoint: anchorPoint, child: Builder(builder: builder)),
    );
  }

  @override
  Widget buildTransitions(
    BuildContext context,
    Animation<double> animation,
    Animation<double> secondaryAnimation,
    Widget child,
  ) {
    return Align(
      alignment: Alignment.bottomCenter,
      child: FractionalTranslation(translation: _offsetTween.evaluate(animation), child: child),
    );
  }

  static final Tween<Offset> _offsetTween = Tween<Offset>(
    begin: const Offset(0.0, 1.0),
    end: Offset.zero,
  );
}

/// Shows a modal iOS-style popup that slides up from the bottom of the screen.
///
/// Such a popup is an alternative to a menu or a dialog and prevents the user
/// from interacting with the rest of the app.
///
/// The `context` argument is used to look up the [Navigator] for the popup.
/// It is only used when the method is called. Its corresponding widget can be
/// safely removed from the tree before the popup is closed.
///
/// The `barrierColor` argument determines the [Color] of the barrier underneath
/// the popup. When unspecified, the barrier color defaults to a light opacity
/// black scrim based on iOS's dialog screens.
///
/// The `barrierDismissible` argument determines whether clicking outside the
/// popup results in dismissal. It is `true` by default.
///
/// The `useRootNavigator` argument is used to determine whether to push the
/// popup to the [Navigator] furthest from or nearest to the given `context`. It
/// is `true` by default.
///
/// The `semanticsDismissible` argument is used to determine whether the
/// semantics of the modal barrier are included in the semantics tree.
///
/// The `routeSettings` argument is used to provide [RouteSettings] to the
/// created Route.
///
/// The `builder` argument typically builds a [CupertinoActionSheet] widget.
/// Content below the widget is dimmed with a [ModalBarrier]. The widget built
/// by the `builder` does not share a context with the location that
/// [showCupertinoModalPopup] is originally called from. Use a
/// [StatefulBuilder] or a custom [StatefulWidget] if the widget needs to
/// update dynamically.
///
/// {@macro flutter.widgets.RawDialogRoute}
///
/// Returns a `Future` that resolves to the value that was passed to
/// [Navigator.pop] when the popup was closed.
///
/// ### State Restoration in Modals
///
/// Using this method will not enable state restoration for the modal. In order
/// to enable state restoration for a modal, use [Navigator.restorablePush]
/// or [Navigator.restorablePushNamed] with [CupertinoModalPopupRoute].
///
/// For more information about state restoration, see [RestorationManager].
///
/// {@tool dartpad}
/// This sample demonstrates how to create a restorable Cupertino modal route.
/// This is accomplished by enabling state restoration by specifying
/// [CupertinoApp.restorationScopeId] and using [Navigator.restorablePush] to
/// push [CupertinoModalPopupRoute] when the [CupertinoButton] is tapped.
///
/// {@macro flutter.widgets.RestorationManager}
///
/// ** See code in examples/api/lib/cupertino/route/show_cupertino_modal_popup.0.dart **
/// {@end-tool}
///
/// See also:
///
///  * [DisplayFeatureSubScreen], which documents the specifics of how
///    [DisplayFeature]s can split the screen into sub-screens.
///  * [CupertinoActionSheet], which is the widget usually returned by the
///    `builder` argument to [showCupertinoModalPopup].
///  * <https://developer.apple.com/design/human-interface-guidelines/ios/views/action-sheets/>
Future<T?> showCupertinoModalPopup<T>({
  required BuildContext context,
  required WidgetBuilder builder,
  ImageFilter? filter,
  Color barrierColor = kCupertinoModalBarrierColor,
  bool barrierDismissible = true,
  bool useRootNavigator = true,
  bool semanticsDismissible = false,
  RouteSettings? routeSettings,
  Offset? anchorPoint,
}) {
  return Navigator.of(context, rootNavigator: useRootNavigator).push(
    CupertinoModalPopupRoute<T>(
      builder: builder,
      filter: filter,
      barrierColor: CupertinoDynamicColor.resolve(barrierColor, context),
      barrierDismissible: barrierDismissible,
      semanticsDismissible: semanticsDismissible,
      settings: routeSettings,
      anchorPoint: anchorPoint,
    ),
  );
}

Widget _buildCupertinoDialogTransitions(
  BuildContext context,
  Animation<double> animation,
  Animation<double> secondaryAnimation,
  Widget child,
) {
  return child;
}

/// Displays an iOS-style dialog above the current contents of the app, with
/// iOS-style entrance and exit animations, modal barrier color, and modal
/// barrier behavior (by default, the dialog is not dismissible with a tap on
/// the barrier).
///
/// This function takes a `builder` which typically builds a [CupertinoAlertDialog]
/// widget. Content below the dialog is dimmed with a [ModalBarrier]. The widget
/// returned by the `builder` does not share a context with the location that
/// [showCupertinoDialog] is originally called from. Use a [StatefulBuilder] or
/// a custom [StatefulWidget] if the dialog needs to update dynamically.
///
/// The `context` argument is used to look up the [Navigator] for the dialog.
/// It is only used when the method is called. Its corresponding widget can
/// be safely removed from the tree before the dialog is closed.
///
/// The `useRootNavigator` argument is used to determine whether to push the
/// dialog to the [Navigator] furthest from or nearest to the given `context`.
/// By default, `useRootNavigator` is `true` and the dialog route created by
/// this method is pushed to the root navigator.
///
/// {@macro flutter.widgets.RawDialogRoute}
///
/// If the application has multiple [Navigator] objects, it may be necessary to
/// call `Navigator.of(context, rootNavigator: true).pop(result)` to close the
/// dialog rather than just `Navigator.pop(context, result)`.
///
/// Returns a [Future] that resolves to the value (if any) that was passed to
/// [Navigator.pop] when the dialog was closed.
///
/// ### State Restoration in Dialogs
///
/// Using this method will not enable state restoration for the dialog. In order
/// to enable state restoration for a dialog, use [Navigator.restorablePush]
/// or [Navigator.restorablePushNamed] with [CupertinoDialogRoute].
///
/// For more information about state restoration, see [RestorationManager].
///
/// {@tool dartpad}
/// This sample demonstrates how to create a restorable Cupertino dialog. This is
/// accomplished by enabling state restoration by specifying
/// [CupertinoApp.restorationScopeId] and using [Navigator.restorablePush] to
/// push [CupertinoDialogRoute] when the [CupertinoButton] is tapped.
///
/// {@macro flutter.widgets.RestorationManager}
///
/// ** See code in examples/api/lib/cupertino/route/show_cupertino_dialog.0.dart **
/// {@end-tool}
///
/// See also:
///
///  * [CupertinoAlertDialog], an iOS-style alert dialog.
///  * [showDialog], which displays a Material-style dialog.
///  * [showGeneralDialog], which allows for customization of the dialog popup.
///  * [DisplayFeatureSubScreen], which documents the specifics of how
///    [DisplayFeature]s can split the screen into sub-screens.
///  * <https://developer.apple.com/design/human-interface-guidelines/alerts/>
Future<T?> showCupertinoDialog<T>({
  required BuildContext context,
  required WidgetBuilder builder,
  String? barrierLabel,
  bool useRootNavigator = true,
  bool barrierDismissible = false,
  RouteSettings? routeSettings,
  Offset? anchorPoint,
}) {
  return Navigator.of(context, rootNavigator: useRootNavigator).push<T>(
    CupertinoDialogRoute<T>(
      builder: builder,
      context: context,
      barrierDismissible: barrierDismissible,
      barrierLabel: barrierLabel,
      barrierColor: CupertinoDynamicColor.resolve(kCupertinoModalBarrierColor, context),
      settings: routeSettings,
      anchorPoint: anchorPoint,
    ),
  );
}

/// A dialog route that shows an iOS-style dialog.
///
/// It is used internally by [showCupertinoDialog] or can be directly pushed
/// onto the [Navigator] stack to enable state restoration. See
/// [showCupertinoDialog] for a state restoration app example.
///
/// This function takes a `builder` which typically builds a [Dialog] widget.
/// Content below the dialog is dimmed with a [ModalBarrier]. The widget
/// returned by the `builder` does not share a context with the location that
/// `showDialog` is originally called from. Use a [StatefulBuilder] or a
/// custom [StatefulWidget] if the dialog needs to update dynamically.
///
/// The `context` argument is used to look up
/// [CupertinoLocalizations.modalBarrierDismissLabel], which provides the
/// modal with a localized accessibility label that will be used for the
/// modal's barrier. However, a custom `barrierLabel` can be passed in as well.
///
/// The `barrierDismissible` argument is used to indicate whether tapping on the
/// barrier will dismiss the dialog. It is `true` by default and cannot be `null`.
///
/// The `barrierColor` argument is used to specify the color of the modal
/// barrier that darkens everything below the dialog. If `null`, then
/// [CupertinoDynamicColor.resolve] is used to compute the modal color.
///
/// The `settings` argument define the settings for this route. See
/// [RouteSettings] for details.
///
/// {@macro flutter.widgets.RawDialogRoute}
///
/// See also:
///
///  * [showCupertinoDialog], which is a way to display
///     an iOS-style dialog.
///  * [showGeneralDialog], which allows for customization of the dialog popup.
///  * [showDialog], which displays a Material dialog.
///  * [DisplayFeatureSubScreen], which documents the specifics of how
///    [DisplayFeature]s can split the screen into sub-screens.
class CupertinoDialogRoute<T> extends RawDialogRoute<T> {
  /// A dialog route that shows an iOS-style dialog.
  CupertinoDialogRoute({
    required WidgetBuilder builder,
    required BuildContext context,
    super.barrierDismissible,
    Color? barrierColor,
    String? barrierLabel,
    // This transition duration was eyeballed comparing with iOS
    super.transitionDuration = const Duration(milliseconds: 250),
    this.transitionBuilder,
    super.settings,
    super.requestFocus,
    super.anchorPoint,
  }) : super(
         pageBuilder: (
           BuildContext context,
           Animation<double> animation,
           Animation<double> secondaryAnimation,
         ) {
           return builder(context);
         },
         transitionBuilder: transitionBuilder ?? _buildCupertinoDialogTransitions,
         barrierLabel: barrierLabel ?? CupertinoLocalizations.of(context).modalBarrierDismissLabel,
         barrierColor:
             barrierColor ?? CupertinoDynamicColor.resolve(kCupertinoModalBarrierColor, context),
       );

  /// Custom transition builder
  RouteTransitionsBuilder? transitionBuilder;

  CurvedAnimation? _fadeAnimation;

  @override
  Simulation createSimulation({required bool forward}) {
    assert(!debugTransitionCompleted(), 'Cannot reuse a $runtimeType after disposing it.');
    final double end = forward ? 1.0 : 0.0;
    return SpringSimulation(
      _kStandardSpring,
      controller!.value,
      end,
      0,
      tolerance: _kStandardTolerance,
      snapToEnd: true,
    );
  }

  @override
  Widget buildTransitions(
    BuildContext context,
    Animation<double> animation,
    Animation<double> secondaryAnimation,
    Widget child,
  ) {
    if (transitionBuilder != null) {
      return super.buildTransitions(context, animation, secondaryAnimation, child);
    }

    if (animation.status == AnimationStatus.reverse) {
      return FadeTransition(opacity: animation, child: child);
    }
    return FadeTransition(
      opacity: animation,
      child: ScaleTransition(scale: animation.drive(_dialogScaleTween), child: child),
    );
  }

  @override
  void dispose() {
    _fadeAnimation?.dispose();
    super.dispose();
  }

  // The curve and initial scale values were mostly eyeballed from iOS, however
  // they reuse the same animation curve that was modeled after native page
  // transitions.
  static final Tween<double> _dialogScaleTween = Tween<double>(begin: 1.3, end: 1.0);
}


Instructions for the chapter (Generate content in English unless specified otherwise):
- Start with a clear heading (e.g., `# Chapter 6: CupertinoPageTransition
`). Use the provided concept name.

- If this is not the first chapter, begin with a brief transition from the previous chapter, referencing it with a proper Markdown link using its name.

- Begin with a high-level motivation explaining what problem this abstraction solves. Start with a central use case as a concrete example. The whole chapter should guide the reader to understand how to solve this use case. Make it very minimal and friendly to beginners.

- If the abstraction is complex, break it down into key concepts. Explain each concept one-by-one in a very beginner-friendly way.

- Explain how to use this abstraction to solve the use case. Give example inputs and outputs for code snippets (if the output isn't values, describe at a high level what will happen).

- Each code block should be BELOW 10 lines! If longer code blocks are needed, break them down into smaller pieces and walk through them one-by-one. Aggresively simplify the code to make it minimal. Use comments to skip non-important implementation details. Each code block should have a beginner friendly explanation right after it.

- Describe the internal implementation to help understand what's under the hood. First provide a non-code or code-light walkthrough on what happens step-by-step when the abstraction is called. It's recommended to use a simple sequenceDiagram with a dummy example - keep it minimal with at most 5 participants to ensure clarity. If participant name has space, use: `participant QP as Query Processing`. .

- Then dive deeper into code for the internal implementation with references to files. Provide example code blocks, but make them similarly simple and beginner-friendly. Explain.

- IMPORTANT: When you need to refer to other core abstractions covered in other chapters, ALWAYS use proper Markdown links like this: [Chapter Title](filename.md). Use the Complete Tutorial Structure above to find the correct filename and the chapter title. Translate the surrounding text.

- Use mermaid diagrams to illustrate complex concepts (```mermaid``` format). .

- Heavily use analogies and examples throughout to help beginners understand.

- End the chapter with a brief conclusion that summarizes what was learned and provides a transition to the next chapter. If there is a next chapter, use a proper Markdown link: [Next Chapter Title](next_chapter_filename).

- Ensure the tone is welcoming and easy for a newcomer to understand.

- Output *only* the Markdown content for this chapter.

Now, directly provide a super beginner-friendly Markdown output (DON'T need ```markdown``` tags):

2025-05-21 12:32:52,221 - INFO - RESPONSE: # Chapter 6: CupertinoPageTransition

Welcome back! In [Chapter 5: CupertinoRouteTransitionMixin](05_cupertinoroutetransitionmixin_.md), we learned that `CupertinoRouteTransitionMixin` holds the recipe for creating those distinct iOS-style transition animations, and how `CupertinoPageRoute` uses this mixin. Now, let's focus on one of the key ingredients in that recipe: the `CupertinoPageTransition` widget itself.

### What is CupertinoPageTransition?

Imagine the screen of your iPhone. When you tap on an item in a list and a new screen slides into view from the right, that smooth animation is done by a special widget. In Flutter's Cupertino world, that special widget is `CupertinoPageTransition`.

`CupertinoPageTransition` is a widget that doesn't display its own content directly. Instead, it takes another widget (which is the new screen you want to show) and applies a specific animation and visual effect to it. It's the visual performer of the standard iOS page-to-page transitions.

Here's what it does:

*   It makes the new screen (`child` widget) slide in from the right.
*   It makes the original screen (the one being covered) slightly slide to the left, creating a cool "parallax" effect.
*   It might also add a subtle shadow effect on the edge of the incoming screen.
*   It uses the "animation" objects provided by the `PageRoute` to know how far along the transition is.

It's important to remember that `CupertinoPageTransition` is just the **visual effect** widget. It relies on a `PageRoute` (like `CupertinoPageRoute`) and the `Navigator` to decide *when* to run the animation and *what* pages to animate.

**Motivation:** We want to understand the actual widget that visually creates the distinct iOS sliding and parallax effect during a page transition. That widget is `CupertinoPageTransition`.

### How CupertinoPageTransition Works

You won't typically create a `CupertinoPageTransition` widget yourself directly in your app code for basic navigation. It is created *internally* by the `CupertinoRouteTransitionMixin` (which is used by `CupertinoPageRoute`).

Let's think about the information `CupertinoPageTransition` needs:

1.  **The content to animate:** This is the widget tree of the new screen you are navigating to. `CupertinoPageTransition` needs to wrap this content.
2.  **The animation progress for the incoming page:** An `Animation` object that typically goes from 0.0 (off-screen) to 1.0 (fully on-screen).
3.  **The animation progress for the outgoing page:** An `Animation` object that typically goes from 0.0 (fully on-screen) to 1.0 (off-screen to the left). This is used for the parallax effect.
4.  **Whether the transition is "linear":** This is used internally for tracking user gestures like swiping back, ensuring the animation follows the finger precisely.

The `CupertinoRouteTransitionMixin`'s `buildTransitions` method (which `CupertinoPageRoute` uses) is responsible for creating the `CupertinoPageTransition` widget and giving it these pieces of information.

Here's a simplified look at how `CupertinoPageRoute` (via its mixin) uses `CupertinoPageTransition`:

```dart
// Simplified concept - from CupertinoRouteTransitionMixin's buildTransitions logic
// This code is inside the Flutter framework, not your app!
Widget buildPageTransitions(
  PageRoute<T> route, // The route being built
  BuildContext context,
  Animation<double> primaryAnimation, // Animation for the new page
  Animation<double> secondaryAnimation, // Animation for the old page
  Widget child, // the NewScreen widget
) {
  // Decide if it's a fullscreen dialog or a regular page
  if (route.fullscreenDialog) {
    // Use a different transition for dialogs (more on this later)
    return CupertinoFullscreenDialogTransition(...);
  } else {
    // For regular pages, use CupertinoPageTransition!
    return CupertinoPageTransition(
      primaryRouteAnimation: primaryAnimation, // Pass incoming animation
      secondaryRouteAnimation: secondaryAnimation, // Pass outgoing animation
      linearTransition: route.popGestureInProgress, // Is a swipe back happening?
      child: child, // Wrap the NewScreen widget
    );
  }
}
```

This shows that `CupertinoPageTransition` is instantiated by the *framework* code that the `CupertinoRouteTransitionMixin` provides. It acts as a container for your `child` widget (`NewScreen` in our example) and applies the animations specified by `primaryRouteAnimation` and `secondaryRouteAnimation`.

### The Visual Magic

Inside `CupertinoPageTransition`, the actual visual effect is created using standard Flutter animation widgets, primarily `SlideTransition` and `DecoratedBoxTransition`.

Let's simplify the core `build` method of `CupertinoPageTransition`:

```dart
// Simplified concept - from the build method inside CupertinoPageTransition
@override
Widget build(BuildContext context) {
  // calculate slide for secondary (outgoing) page (parallax)
  // based on secondaryRouteAnimation

  // calculate slide for primary (incoming) page
  // based on primaryRouteAnimation

  // calculate shadow for primary (incoming) page
  // based on primaryRouteAnimation

  return SlideTransition(
    position: _secondaryPositionAnimation, // Moves the outgoing page
    child: SlideTransition(
      position: _primaryPositionAnimation, // Moves the incoming page
      child: DecoratedBoxTransition(
        decoration: _primaryShadowAnimation, // Adds edge shadow
        child: widget.child, // The actual screen content (NewScreen)
      ),
    ),
  );
}
```

This nested structure is key:

1.  The outermost `SlideTransition` uses `_secondaryPositionAnimation` (derived from `secondaryRouteAnimation`) to slightly slide the **outgoing page** (which is the `child` *of the inner* `SlideTransition`) to the left, creating the parallax effect.
2.  The inner `SlideTransition` uses `_primaryPositionAnimation` (derived from `primaryRouteAnimation`) to slide the **incoming page** (`widget.child`) from the right to the center.
3.  The `DecoratedBoxTransition` wraps the `widget.child` and applies a subtle gradient shadow effect on the leading edge as it slides in, using `_primaryShadowAnimation`.

```mermaid
graph TD
    A[Navigator] --> B[CupertinoPageRoute];
    B --> C[CupertinoRouteTransitionMixin]
    C --> D[buildTransitions calls buildPageTransitions]
    D --> E[Creates CupertinoPageTransition]
    E --> F{Build Method of CupertinoPageTransition};
    F --> G[Outer SlideTransition - Secondary Animation (Parallax)];
    G --> H[Inner SlideTransition - Primary Animation (Slide In)];
    H --> I[DecoratedBoxTransition - Edge Shadow];
    I --> J[Your NewScreen Widget];
```

So, `CupertinoPageTransition` stitches together several basic animation widgets (`SlideTransition`, `DecoratedBoxTransition`) using the `Animation` objects it receives to create the complete visual iOS page transition effect.

### You Still Don't Use It Directly (Mostly)

Just like `CupertinoRouteTransitionMixin`, you generally won't hand-craft a `CupertinoPageTransition` widget in your typical navigation code. When you use `CupertinoPageRoute`, the framework automatically creates and manages the `CupertinoPageTransition` for you.

Understanding `CupertinoPageTransition` helps you appreciate how the finished iOS-style transition is composed of multiple visual elements (sliding the new page, sliding the old page, adding a shadow) all orchestrated by the primary and secondary animation objects.

### Conclusion

`CupertinoPageTransition` is the concrete widget that implements the visual aspects of the standard iOS page transition, including sliding, parallax, and shadowing. It receives animation data from a `PageRoute` (like `CupertinoPageRoute` via its mixin) and uses built-in animation widgets to apply these effects to the new screen's content. While you don't usually need to use it directly, knowing it exists clarifies how Flutter achieves that native iOS navigation feel.

In the next chapter, we'll look at `CupertinoFullscreenDialogTransition`, a similar widget but used for the different animation style employed by iOS for fullscreen modal dialogs.

[Next Chapter: CupertinoFullscreenDialogTransition](07_cupertinofullscreendialogtransition_.md)
2025-05-21 12:32:52,233 - INFO - PROMPT: 
Write a very beginner-friendly tutorial chapter (in Markdown format) for the project `flutter` about the concept: "CupertinoFullscreenDialogTransition
". This is Chapter 7.

Concept Details:
- Name: CupertinoFullscreenDialogTransition

- Description:
This is a specialized transition widget specifically for full-screen dialogs in the Cupertino style. Unlike regular pages that slide horizontally, these dialogs typically animate up from the bottom of the screen. This widget handles the visual animation for these specific types of pop-ups.


Complete Tutorial Structure:
1. [PageRoute
](01_pageroute_.md)
2. [MaterialPageRoute
](02_materialpageroute_.md)
3. [MaterialRouteTransitionMixin
](03_materialroutetransitionmixin_.md)
4. [CupertinoPageRoute
](04_cupertinopageroute_.md)
5. [CupertinoRouteTransitionMixin
](05_cupertinoroutetransitionmixin_.md)
6. [CupertinoPageTransition
](06_cupertinopagetransition_.md)
7. [CupertinoFullscreenDialogTransition
](07_cupertinofullscreendialogtransition_.md)
8. [CupertinoModalPopupRoute
](08_cupertinomodalpopuproute_.md)
9. [CupertinoDialogRoute
](09_cupertinodialogroute_.md)

Context from previous chapters:
# Chapter 1: PageRoute

Welcome to the first chapter of our Flutter navigation tutorial! Ever wonder how tapping a button in an app seamlessly takes you to a completely different screen? That's where the magic of navigation comes in! In Flutter, a core concept for managing these screen transitions is the `PageRoute`.

Imagine your Flutter app is like a building with many rooms (screens). When you want to go from one room (the "lobby") to another room (the "settings" screen), you need a plan or a map to get there. A `PageRoute` is exactly that – it's the blueprint, the plan, for a single "page" or screen in your app and how you would transition *to* it.

Think of it as defining:

*   **What the new screen looks like:** What widgets make up this new page?
*   **How the transition happens:** Does it slide from the side, fade in, or something else?
*   **How long the transition takes:** Is it a quick change or a smooth, longer one?
*   **Its behavior:** Can you easily "go back" or dismiss this screen?

The `PageRoute` doesn't *perform* the transition itself; it tells the `Navigator` (Flutter's system for managing screen stacks, like stacking rooms on top of each other) *how* to perform the transition to display its content.

### Our Goal: Showing a Simple New Screen

Throughout this chapter, our goal is to understand enough about `PageRoute` to accomplish a very common task: navigating from one simple screen to another.

Let's start with a basic example. We'll have a main screen with a button. When you tap the button, we want to go to a new, blank screen.

Here's a simplified look at what we might have initially:

```dart
import 'package:flutter/material.dart';

void main() {
  runApp(MyApp());
}

class MyApp extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return MaterialApp(
      home: HomeScreen(),
    );
  }
}

class HomeScreen extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(title: Text('Home Screen')),
      body: Center(
        child: ElevatedButton(
          onPressed: () {
            // We want to go to a new screen here!
          },
          child: Text('Go to New Screen'),
        ),
      ),
    );
  }
}

class NewScreen extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(title: Text('New Screen')),
      body: Center(
        child: Text('Welcome to the new screen!'),
      ),
    );
  }
}
```

In this code, we have `HomeScreen` and `NewScreen`. Our challenge is to connect the button on `HomeScreen` to show `NewScreen`. We need a `PageRoute` for `NewScreen`.

### Understanding PageRoute with PageRouteBuilder

Directly creating a raw `PageRoute` can be a bit advanced for our first step. Flutter provides a helpful class called `PageRouteBuilder` which lets us create a simple `PageRoute` using functions (callbacks). This is perfect for defining basic routes without creating a whole new class.

Let's look at how we can use `PageRouteBuilder` inside the `onPressed` of our `ElevatedButton`:

```dart
// ... inside HomeScreen onPressed ...
onPressed: () {
  Navigator.push(
    context,
    PageRouteBuilder( // Using PageRouteBuilder to define our route
      pageBuilder: (context, animation, secondaryAnimation) {
        // This function builds the actual screen content
        return NewScreen();
      },
      transitionsBuilder: (context, animation, secondaryAnimation, child) {
        // This function defines how the transition looks
        // For now, we'll do a simple fade transition as an example
        return FadeTransition(
          opacity: animation, // Controls the opacity of the new page
          child: child,
        );
      },
      transitionDuration: Duration(milliseconds: 500), // How long the transition takes
    ),
  );
},
// ... rest of HomeScreen ...
```

Let's break down what's happening here:

1.  **`Navigator.push(context, ...)`**: This is how we tell Flutter's navigation system to add a new screen on top of the current one. `context` tells the Navigator where we are in the widget tree.
2.  **`PageRouteBuilder(...)`**: We create an instance of `PageRouteBuilder` to define the characteristics of the new route.
3.  **`pageBuilder: (context, animation, secondaryAnimation) { return NewScreen(); }`**: This is a required function that `PageRouteBuilder` needs. It tells the builder *what* widget tree to display for this page. In our case, it's just our `NewScreen` widget. The `animation` and `secondaryAnimation` parameters are for transition animations, which we'll use in the next part.
4.  **`transitionsBuilder: (context, animation, secondaryAnimation, child) { ... }`**: This optional function defines how the transition *looks*. It takes the context, `animation` (for the incoming page), `secondaryAnimation` (for the outgoing page), and the `child` (which is the widget built by `pageBuilder`). We use a `FadeTransition` here, animating the `opacity` of the incoming page using the `animation` provided.
5.  **`transitionDuration: Duration(milliseconds: 500)`**: This sets how long the transition animation should take.

Now, when you tap the button, the `Navigator` will use this `PageRouteBuilder` to create a `PageRoute`, push it onto the navigation stack, and animate to the `NewScreen` using a 500ms fade effect.

### How it Works Under the Hood (Simplified)

Let's look at a slightly simplified view of what happens when you call `Navigator.push` with a `PageRoute`:

```mermaid
sequenceDiagram
    participant Button as Button Widget
    participant HomeScreen as HomeScreen Widget
    participant Navigator as Navigator
    participant PageRoute as PageRouteBuilder
    participant NewScreen as NewScreen Widget

    Button->HomeScreen: calls onPressed
    HomeScreen->Navigator: calls push(context, PageRoute)
    Navigator->PageRoute: asks for the page content and transitions
    PageRoute->PageRoute: uses pageBuilder to create NewScreen widget
    PageRoute->PageRoute: uses transitionsBuilder to wrap NewScreen with transition widgets
    Navigator->Navigator: Prepares
    Navigator->NewScreen: Builds and animates the transition
```

Essentially, the `Navigator` is like the conductor of an orchestra. You hand it a `PageRoute`, and it orchestrates the process of showing the new screen, including running the transitions defined by the `PageRoute`.

Inside the Flutter framework code for `PageRoute` (like in `packages/flutter/lib/src/widgets/pages.dart`), you'll find methods like `buildPage` and `buildTransitions`. These are the core parts that `PageRouteBuilder` uses its functions (`pageBuilder` and `transitionsBuilder`) to implement:

```dart
// Simplified example from PageRoute (similar to what PageRouteBuilder does internally)
abstract class PageRoute<T> extends ModalRoute<T> {
  // ... other properties ...

  // The PageRoute needs to know how to build the main content
  Widget buildPage(BuildContext context, Animation<double> animation, Animation<double> secondaryAnimation);

  // The PageRoute needs to know how to build the transitions
  Widget buildTransitions(BuildContext context, Animation<double> animation, Animation<double> secondaryAnimation, Widget child);

  // ... more methods for duration, color, etc. ...
}
```

`PageRouteBuilder` fills in these `buildPage` and `buildTransitions` methods using the functions you provide.

### Conclusion

In this chapter, we learned that a `PageRoute` is the fundamental concept in Flutter navigation that defines how a new screen is presented. We saw how to use `PageRouteBuilder` to create a simple `PageRoute` by specifying what the new screen looks like and how the transition should appear.

While `PageRouteBuilder` is great for simple custom transitions, Flutter provides pre-built `PageRoute` implementations for common design patterns, like the Material Design page transitions and the Cupertino (iOS) page transitions. These include standard animations and behaviors.

In the next chapter, we'll dive into one of these standard implementations: [MaterialPageRoute](02_materialpageroute_.md), which provides the familiar animations you see in Android apps.

[Next Chapter: MaterialPageRoute](02_materialpageroute_.md)
---
# Chapter 2: MaterialPageRoute

Welcome back! In [Chapter 1: PageRoute](01_pageroute_.md), we learned that a `PageRoute` is the blueprint for displaying a new screen and defining its transition. We saw how `PageRouteBuilder` let us create custom routes with animations.

Now, let's explore a really common and useful type of `PageRoute` used in Flutter apps that follow Google's Material Design: the `MaterialPageRoute`.

### What is MaterialPageRoute?

If you've ever used an Android phone, you've likely seen specific ways new screens appear when you tap something – often, they fade in and zoom slightly. `MaterialPageRoute` is designed to give you that native Android look and feel for your screen transitions, *automatically*.

Think of it as a pre-made `PageRoute` specifically built for Material Design. Instead of defining the fade/zoom transition yourself with `PageRouteBuilder`, `MaterialPageRoute` handles it for you.

But here's a cool trick: `MaterialPageRoute` is also platform-adaptive! This means that if you run your app on an iOS device, it will automatically use the standard iOS slide-from-the-right transition. You get the right native feel on both Android and iOS with just one `MaterialPageRoute`!

**Motivation:** We want to navigate from our `HomeScreen` to our `NewScreen` using the standard Material Design (Android-style) transitions on Android and the standard Cupertino (iOS-style) transitions on iOS, without manually building the transition animation ourselves.

### Using MaterialPageRoute

Using `MaterialPageRoute` is much simpler than `PageRouteBuilder` for standard transitions. You just need to tell it *what* screen to build.

Let's go back to our
`HomeScreen` button's `onPressed` and replace the `PageRouteBuilder` with a `MaterialPageRoute`:

```dart
// ... inside HomeScreen onPressed ...
onPressed: () {
  Navigator.push(
    context,
    MaterialPageRoute( // Using MaterialPageRoute!
      builder: (context) {
        // Just provide the widget for the new screen
        return NewScreen();
      },
    ),
  );
},
// ... rest of HomeScreen ...
```

That's it! Notice how much simpler it is?

*   We still use `Navigator.push` to initiate the navigation.
*   We create a `MaterialPageRoute` instance.
*   We provide a `builder` function, which is similar to `pageBuilder` in `PageRouteBuilder`. This function simply returns the widget for the new screen (`NewScreen`).
*   We *don't* need to specify a `transitionsBuilder` or `transitionDuration` explicitly. `MaterialPageRoute` uses default ones suitable for Material Design, chosen automatically based on the device's operating system.

Now, when you tap the button:
*   On an Android device, `NewScreen` will fade in and slightly zoom.
*   On an iOS device, `NewScreen` will slide in from the right.

### How it Works Under the Hood (Simplified)

When you use `MaterialPageRoute`, like with any `PageRoute`, you hand it to the `Navigator`.

```mermaid
sequenceDiagram
    participant Button as Button Widget
    participant HomeScreen as HomeScreen Widget
    participant Navigator as Navigator
    participant MaterialPageRoute as MaterialPageRoute
    participant NewScreen as NewScreen Widget
    participant Theme as Theme Data

    Button->HomeScreen: calls onPressed
    HomeScreen->Navigator: calls push(context, MaterialPageRoute)
    Navigator->MaterialPageRoute: asks for page content and transitions
    MaterialPageRoute->MaterialPageRoute: calls builder() to create NewScreen widget
    MaterialPageRoute->Theme: checks current platform (Android/iOS)
    MaterialPageRoute->MaterialPageRoute: selects relevant transition based on platform
    MaterialPageRoute->NewScreen: Builds and wraps with selected transition widgets
    Navigator->Navigator: Prepares
    Navigator->NewScreen: Animates the transition
```

The key difference from using `PageRouteBuilder` with a custom fade is that `MaterialPageRoute` internally checks the theme and the platform to pick the right animation blueprint.

Let's peek into the Flutter framework code for `MaterialPageRoute` in `packages/flutter/lib/src/material/page.dart`.

You'll see the `MaterialPageRoute` class definition inherits from `PageRoute` and also uses something called `MaterialRouteTransitionMixin` (we'll talk about mixins more later, but for now, think of it as sharing helpful code).

```dart
// Simplified from packages/flutter/lib/src/material/page.dart
class MaterialPageRoute<T> extends PageRoute<T> with MaterialRouteTransitionMixin<T> {
  // ... constructor and other properties ...

  /// Builds the primary contents of the route.
  final WidgetBuilder builder; // This holds the function you passed in!

  @override
  Widget buildContent(BuildContext context) => builder(context); // Uses your builder

  // ... other overrides ...
}
```

The `buildContent` method is where your `builder` function is called to create the `NewScreen` widget.

Where does the platform-adaptive transition logic come from? It's mostly handled by the `MaterialRouteTransitionMixin` and interacts with Flutter's `Theme` and `PageTransitionsTheme`.

```dart
// Simplified/conceptual example from MaterialRouteTransitionMixin
mixin MaterialRouteTransitionMixin<T> on PageRoute<T> {
  // ... other properties ...

  @override
  Widget buildTransitions( // This is where the transition is built!
    BuildContext context,
    Animation<double> animation,
    Animation<double> secondaryAnimation,
    Widget child, // This 'child' is the widget from buildContent (your NewScreen)
  ) {
    // Internally looks at Theme.of(context).platform (Android or iOS)
    // Then looks up the correct transition from Theme.of(context).pageTransitionsTheme
    // Returns the correct transition widget (like a FadeTransition for Android,
    // or a SlideTransition for iOS) wrapping the 'child' (your screen).
    final PageTransitionsTheme theme = Theme.of(context).pageTransitionsTheme;
    return theme.buildTransitions<T>(this, context, animation, secondaryAnimation, child);
  }

  // ... other properties like transitionDuration ...
}
```

So, `MaterialPageRoute` uses the `builder` you provide to show the content and relies on the `MaterialRouteTransitionMixin` (and Flutter's theming system) to automatically select and apply the right transition animation based on the device's platform.

### Conclusion

`MaterialPageRoute` is your go-to `PageRoute` when you want standard Material Design page transitions (fade/zoom on Android, slide on iOS) without needing to manually define the animations. It simplifies the process of creating new routes by providing sensible defaults that match platform conventions. It's a foundational component for navigation in many Flutter applications.

In the next chapter, we'll take a brief look at the `MaterialRouteTransitionMixin` itself, which is the piece that provides the magic platform-adaptive transitions for `MaterialPageRoute`.

[Next Chapter: MaterialRouteTransitionMixin](03_materialroutetransitionmixin_.md)
---
# Chapter 3: MaterialRouteTransitionMixin

Welcome back! In [Chapter 2: MaterialPageRoute](02_materialpageroute_.md), we learned how `MaterialPageRoute` gives us those sweet, platform-adaptive screen transitions (fade/zoom on Android, slide on iOS) without us having to code the animations ourselves.

We briefly saw that the code for `MaterialPageRoute` includes something called `with MaterialRouteTransitionMixin`. This chapter is about that `MaterialRouteTransitionMixin`.

### What is MaterialRouteTransitionMixin?

Imagine you have a recipe for delicious cookies. The recipe lists all the ingredients and the steps. A "mixin" in Flutter is like a list of extra ingredients and techniques you can add to your recipe to make it special.

`MaterialRouteTransitionMixin` is not a complete recipe (it's not a full `PageRoute` itself), but it's a collection of "ingredients" and "techniques" specifically for creating **Material Design page transitions** that adapt to the platform.

It provides the core logic for:

1.  **How long** the transition should take (duration).
2.  **How the animation looks** (the transition effect itself, like fading or sliding).
3.  **How this route interacts** with other routes during transitions (can they transition together smoothly?).

Essentially, `MaterialRouteTransitionMixin` is the helper that `MaterialPageRoute` uses to get its standard, platform-adaptive transition behavior. It's what makes `MaterialPageRoute` special!

You won't usually create a `MaterialRouteTransitionMixin` directly. Instead, you'll see other `PageRoute` implementations (like `MaterialPageRoute`) "mix it in" to gain its transition capabilities.

**Motivation:** Our goal is to understand where the automatic, platform-adaptive transition logic in `MaterialPageRoute` comes from. It comes from `MaterialRouteTransitionMixin`.

### How Mixins Work (Simply)

Think of a mixin as a way to share code between different classes without using traditional inheritance (like a child class inheriting from a parent class).

If you have `ClassA` and `MixinB`, `ClassA` can use `MixinB`'s methods and properties by saying `class ClassA with MixinB`. It's like `ClassA` is adding `MixinB`'s features to itself.

In our case, `MaterialPageRoute` is a class, and it uses `MaterialRouteTransitionMixin` like this:

```dart
// Simplified
class MaterialPageRoute<T> extends PageRoute<T> with MaterialRouteTransitionMixin<T> {
  // MaterialPageRoute now has access to the methods inside MaterialRouteTransitionMixin
  // ... rest of MaterialPageRoute code ...
}
```

By using `with MaterialRouteTransitionMixin`, `MaterialPageRoute` automatically gains the `buildTransitions` method and other transition-related logic defined within the mixin.

### How it Connects to Building Transitions

Remember in [Chapter 1: PageRoute](01_pageroute_.md), we saw that a `PageRoute` needs to implement a `buildTransitions` method to define how the animation looks?

`MaterialRouteTransitionMixin` provides the **implementation** for this crucial `buildTransitions` method for Material Design transitions.

When `Navigator.push` is called with a `MaterialPageRoute`, the Navigator asks the `MaterialPageRoute` (which uses `MaterialRouteTransitionMixin`'s logic) to build the transition widget tree.

Here's a look inside the mixin (simplified):

```dart
// Simplified/conceptual example from packages/flutter/lib/src/material/page.dart
mixin MaterialRouteTransitionMixin<T> on PageRoute<T> {
  // ... other properties like transitionDuration ...

  @override
  Widget buildTransitions( // This method is provided by the mixin!
    BuildContext context,
    Animation<double> animation, // Animation for the incoming page
    Animation<double> secondaryAnimation, // Animation for the outgoing page
    Widget child, // The actual content of the page (your NewScreen)
  ) {
    // Inside here, the mixin's code runs.
    // It checks the platform (Android/iOS) using Theme.of(context).platform.
    // It looks up the correct transition animation based on the platform
    // from the PageTransitionsTheme.
    // It returns the chosen animation widget (like FadeTransition or SlideTransition)
    // wrapping the 'child' (your NewScreen widget).

    // This line is the core – it asks the Theme for the right transition!
    final PageTransitionsTheme theme = Theme.of(context).pageTransitionsTheme;
    return theme.buildTransitions<T>(this, context, animation, secondaryAnimation, child);
  }

  // ... other methods ...
}
```

So, `MaterialRouteTransitionMixin` contains the `buildTransitions` method that looks at the current `Theme` (which knows the platform) and asks the `PageTransitionsTheme` within the `Theme` to provide the actual transition widget code.

This design is clever because:
*   `MaterialPageRoute` handles knowing *what* screen to show (`builder`).
*   `MaterialRouteTransitionMixin` handles knowing *how* to transition, querying the `Theme` for the platform-specific implementation.
*   The `PageTransitionsTheme` holds the actual animation builders (like the code for the fade/zoom or the slide animations).

This separation of concerns makes the code more organized and maintainable!

### You Don't Use It Directly (Usually)

As a beginner, you won't typically need to directly use `MaterialRouteTransitionMixin`. Its purpose is to provide the transition logic *to* classes like `MaterialPageRoute`. When you use `MaterialPageRoute`, you are indirectly benefiting from the code in `MaterialRouteTransitionMixin`.

Think of it like buying a car. You use the steering wheel and pedals (`MaterialPageRoute`), and the engine ("mixin") makes it go, but you don't interact directly with the engine parts every time you drive.

### Conclusion

`MaterialRouteTransitionMixin` is a key piece of the puzzle behind `MaterialPageRoute`'s automatic, platform-adaptive transitions. It provides the core logic for determining transition duration and building the correct transition animation based on the device's operating system by interacting with the Flutter `Theme` system. While you won't often use it directly, understanding its role helps clarify how `MaterialPageRoute` works.

In the next chapter, we'll shift our focus to the iOS side of things and introduce `CupertinoPageRoute`, which is the counterpart to `MaterialPageRoute` for Cupertino (iOS) design.

[Next Chapter: CupertinoPageRoute](04_cupertinopageroute_.md)
---
# Chapter 4: CupertinoPageRoute

Welcome back, future Flutter navigators! In [Chapter 3: MaterialRouteTransitionMixin](03_materialroutetransitionmixin_.md), we explored how `MaterialRouteTransitionMixin` is the helper that gives `MaterialPageRoute` its cool, platform-adaptive animations. Now, let's turn our attention to the world of Apple's iOS design with `CupertinoPageRoute`.

### What is CupertinoPageRoute?

If you've ever used an iPhone or iPad, you've seen specific ways new screens slide into view, often from the right side of the screen, and how they slide back out when you go back. `CupertinoPageRoute` is Flutter's way of giving you that exact native iOS look and feel for your screen transitions, automatically!

Just like `MaterialPageRoute` is a pre-made blueprint for Material Design transitions, `CupertinoPageRoute` is a pre-made blueprint specifically built for Cupertino (iOS) design. It handles the characteristic sliding animations and other iOS visual cues when you navigate between pages.

**Motivation:** Our goal is to navigate from our `HomeScreen` to our `NewScreen` using the standard iOS slide-from-the-right transition when running on an iOS device, in a way that is natural and expected for iOS users.

### Using CupertinoPageRoute

Using `CupertinoPageRoute` is very similar to using `MaterialPageRoute`. You simply tell it which widget represents the new screen.

Let's go back to our `HomeScreen` button's `onPressed` and replace the `MaterialPageRoute` with a `CupertinoPageRoute`:

```dart
import 'package:flutter/cupertino.dart'; // Import Cupertino widgets!
import 'package:flutter/material.dart'; // Still need Material for Scaffold, AppBar, etc.

// ... rest of MyApp and HomeScreen classes ...

class HomeScreen extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return Scaffold( // Using Material Scaffold for simplicity in this example
      appBar: AppBar(title: Text('Home Screen')),
      body: Center(
        child: ElevatedButton(
          onPressed: () {
            Navigator.push(
              context,
              CupertinoPageRoute( // Using CupertinoPageRoute!
                builder: (context) {
                  // Just provide the widget for the new screen
                  return NewScreen();
                },
              ),
            );
          },
          child: Text('Go to New Screen'),
        ),
      ),
    );
  }
}

// ... rest of NewScreen class ...
```

See the difference? We changed `MaterialPageRoute` to `CupertinoPageRoute` and made sure to import `flutter/cupertino.dart`.

Now, when you tap the button:

*   On an iOS device, `NewScreen` will smoothly slide in from the right, with the previous screen slightly moving to the left (a parallax effect). When you go back, it slides out to the right.
*   On an Android device, because we're using a `CupertinoPageRoute`, it will *still* try to use the Cupertino (iOS) style transition, even though it's running on Android. This is different from `MaterialPageRoute` which is platform-adaptive. If you want platform-adaptive behavior, `MaterialPageRoute` is often the better choice. `CupertinoPageRoute` is primarily for building apps that *always* have the iOS feel.

### How it Works Under the Hood (Simplified)

When you use `CupertinoPageRoute`, you hand it to the `Navigator` just like any other `PageRoute`.

```mermaid
sequenceDiagram
    participant Button as Button Widget
    participant HomeScreen as HomeScreen Widget
    participant Navigator as Navigator
    participant CupertinoPageRoute as CupertinoPageRoute
    participant NewScreen as NewScreen Widget
    participant iOS Theme as iOS Theme Data (Conceptual)

    Button->HomeScreen: calls onPressed
    HomeScreen->Navigator: calls push(context, CupertinoPageRoute)
    Navigator->CupertinoPageRoute: asks for page content and transitions
    CupertinoPageRoute->CupertinoPageRoute: calls builder() to create NewScreen widget
    CupertinoPageRoute->iOS Theme: Requests iOS-style transition details
    CupertinoPageRoute->CupertinoPageRoute: Uses transition logic from mixin
    CupertinoPageRoute->NewScreen: Builds and wraps with Cupertino transition widgets
    Navigator->Navigator: Prepares
    Navigator->NewScreen: Animates the transition (iOS style)
```

The process is very similar to `MaterialPageRoute`, but instead of checking the general platform to pick between Material and Cupertino, `CupertinoPageRoute` *always* uses the Cupertino style transition logic.

Let's peek into the Flutter framework code for `CupertinoPageRoute` in `packages/flutter/lib/src/cupertino/route.dart`.

You'll find the `CupertinoPageRoute` class definition inherits from `PageRoute` and, just like `MaterialPageRoute` uses a mixin for its transitions, `CupertinoPageRoute` uses something similar: `CupertinoRouteTransitionMixin`.

```dart
// Simplified from packages/flutter/lib/src/cupertino/route.dart
class CupertinoPageRoute<T> extends PageRoute<T> with CupertinoRouteTransitionMixin<T> {
  // ... constructor and other properties ...

  /// Builds the primary contents of the route.
  final WidgetBuilder builder; // This holds the function you passed in!

  @override
  Widget buildContent(BuildContext context) => builder(context); // Uses your builder

  // ... other overrides ...
}
```

Similar to `MaterialPageRoute`, `CupertinoPageRoute` takes your `builder` function and calls its `buildContent` method to create the widget for the new page.

The iOS-style transition magic (the sliding from the right, the parallax effect) comes from the `CupertinoRouteTransitionMixin` that is mixed into `CupertinoPageRoute`. This mixin implements the `buildTransitions` method using specific iOS animations:

```dart
// Simplified/conceptual example from CupertinoRouteTransitionMixin
mixin CupertinoRouteTransitionMixin<T> on PageRoute<T> {
  // ... other properties like transitionDuration ...

  @override
  Widget buildTransitions( // This method is provided by the mixin!
    BuildContext context,
    Animation<double> animation, // Animation for the incoming page
    Animation<double> secondaryAnimation, // Animation for the outgoing page
    Widget child, // The actual content of the page (your NewScreen)
  ) {
    // Inside here, the mixin's code runs.
    // It builds specific iOS transition widgets...
    // For normal pages, it uses CupertinoPageTransition.
    // For fullscreen dialogs, it uses CupertinoFullscreenDialogTransition.
    // It uses the animations (primaryRouteAnimation and secondaryRouteAnimation)
    // and wraps the 'child' (your NewScreen widget) with them.

    // A simplified call to the actual transition builder:
    return buildPageTransitions<T>(this, context, animation, secondaryAnimation, child);
  }

  // ... other methods ...
}
```

When the `Navigator` needs to show `CupertinoPageRoute`, it asks the route to `buildTransitions`. `CupertinoPageRoute` uses the `buildTransitions` method from `CupertinoRouteTransitionMixin`. This mixin then uses dedicated transition widgets like `CupertinoPageTransition` to create the visually distinct iOS sliding effect, using the provided `animation` objects to control the movement. We'll learn more about `CupertinoPageTransition` in a later chapter.

`CupertinoPageRoute` also has support for distinguishing between regular page transitions and fullscreen dialog transitions (like presenting a modal from the bottom on iOS), using different animation styles for each case, which is also handled by the `CupertinoRouteTransitionMixin`.

### Conclusion

`CupertinoPageRoute` is the specialized `PageRoute` for bringing the native iOS page transition experience (sliding from the right, parallax effect) to your Flutter apps, regardless of the actual device platform. It uses the `CupertinoRouteTransitionMixin` to manage the transition logic and apply the appropriate iOS-style animations. While `MaterialPageRoute` is usually preferred for platform-adaptive behavior in a single codebase, `CupertinoPageRoute` is perfect when you want a consistent iOS feel.

In the next chapter, we'll dive deeper into the `CupertinoRouteTransitionMixin` itself, similar to how we looked at its Material counterpart, to see exactly where this iOS transition magic comes from.

[Next Chapter: CupertinoRouteTransitionMixin](05_cupertinoroutetransitionmixin_.md)
---
# Chapter 5: CupertinoRouteTransitionMixin

Welcome back! In [Chapter 4: CupertinoPageRoute](04_cupertinopageroute_.md), we learned how `CupertinoPageRoute` helps us create iOS-style screen transitions automatically, giving our apps that native slide-from-the-right feel. We also briefly saw that `CupertinoPageRoute` uses something called `CupertinoRouteTransitionMixin` to get this behavior.

Now, it's time to shine a spotlight on the `CupertinoRouteTransitionMixin` itself!

### What is CupertinoRouteTransitionMixin?

Just like `MaterialRouteTransitionMixin` is the special recipe additive for Material Design transitions, `CupertinoRouteTransitionMixin` is the recipe additive for **Cupertino (iOS) page transitions**.

It's not a full `PageRoute` on its own, but it contains the vital instructions and ingredients needed to create the signature iOS sliding and fading animations for transitioning between screens.

Think of it as providing the "animation logic" that a `PageRoute` can use. Instead of writing the complex code to make a widget slide from the right and have the old page slightly move left (that parallax effect!), you can "mix in" `CupertinoRouteTransitionMixin` to automatically get that behavior.

It provides the core logic for:

1.  **How long** the transition takes (its duration).
2.  **How the animation fundamentally looks** (the sliding, the fading).
3.  **How it behaves** during interactive gestures, like swiping back from the edge of the screen on iOS.

`CupertinoPageRoute` itself uses `CupertinoRouteTransitionMixin` to implement its `buildTransitions` method, which is the core piece that tells the Navigator how to animate the new screen into view.

**Motivation:** We want to understand where the charming iOS sliding and parallax animations come from when we use `CupertinoPageRoute`. They come from `CupertinoRouteTransitionMixin`.

### How Mixins Work (A Quick Reminder)

As we talked about with `MaterialRouteTransitionMixin`, a mixin is a way to add a set of properties and methods from one class-like structure into another class, without needing traditional inheritance.

When a class `mixes in` a mixin, it gains all the public members of that mixin as if they were defined directly in the class itself.

`CupertinoPageRoute` uses `CupertinoRouteTransitionMixin` like this:

```dart
// Simplified from packages/flutter/lib/src/cupertino/route.dart
class CupertinoPageRoute<T> extends PageRoute<T> with CupertinoRouteTransitionMixin<T> {
  // CupertinoPageRoute now automatically has the buildTransitions method
  // and other properties defined in CupertinoRouteTransitionMixin
  // ... rest of CupertinoPageRoute code ...
}
```

This means `CupertinoPageRoute` doesn't have to write the `buildTransitions` code itself; it gets it "for free" by mixing in `CupertinoRouteTransitionMixin`.

### How it Connects to Building Transitions

The most important part that `CupertinoRouteTransitionMixin` provides is the implementation for the `buildTransitions` method that every `PageRoute` needs.

When you call `Navigator.push` with a `CupertinoPageRoute`, the Navigator needs to know how to animate the new page onto the screen. It calls the `buildTransitions` method of that `PageRoute`. Because `CupertinoPageRoute` mixed in `CupertinoRouteTransitionMixin`, it's actually the mixin's code that runs for `buildTransitions`.

Here's a look inside the mixin's `buildTransitions` method (simplified from the framework code):

```dart
// Simplified from packages/flutter/lib/src/cupertino/route.dart
mixin CupertinoRouteTransitionMixin<T> on PageRoute<T> {
  // ... other properties like transitionDuration ...

  @override
  Widget buildTransitions( // This method is provided by the mixin!
    BuildContext context,
    Animation<double> animation, // Animation for the incoming page
    Animation<double> secondaryAnimation, // Animation for the outgoing page
    Widget child, // The actual content of the page (your NewScreen)
  ) {
    // Inside here, the mixin's code figures out the right animation.
    // It uses specific transition widgets like CupertinoPageTransition
    // (or CupertinoFullscreenDialogTransition for dialogs).
    // It passes the 'child' (your new screen) and the 'animation' objects
    // to these transition widgets.

    // This line is the core – it calls dedicated builders for the transitions!
    return buildPageTransitions<T>(this, context, animation, secondaryAnimation, child);
  }

  // ... other methods ...
}
```

The `buildTransitions` method in `CupertinoRouteTransitionMixin` doesn't build the animation widget tree directly. Instead, it delegates that task to helper functions within the Cupertino library, specifically `buildPageTransitions`.

This `buildPageTransitions` helper method (which is part of the mixin's logic):

1.  Checks if this route is a normal page or a fullscreen dialog.
2.  Based on that, it chooses the correct transition widget.
    *   For normal pages, it picks `CupertinoPageTransition`.
    *   For fullscreen dialogs (like adding an event in the calendar), it picks `CupertinoFullscreenDialogTransition`.
3.  It creates an instance of the chosen transition widget, passing in:
    *   The `animation` for the incoming screen.
    *   The `secondaryAnimation` for the outgoing screen.
    *   Your actual screen widget (`child`).

So, the `CupertinoRouteTransitionMixin` acts as the orchestrator of the transition. It decides which specific animation widget to use and provides it with the necessary animation data.

Let's visualize this flow:

```mermaid
sequenceDiagram
    participant Navigator as Navigator
    participant CupertinoPageRoute as CupertinoPageRoute
    participant CRT_Mixin as CupertinoRouteTransitionMixin
    participant CPTransition as CupertinoPageTransition / CupertinoFullscreenDialogTransition
    participant NewScreen as NewScreen Widget

    Navigator->CupertinoPageRoute: calls buildTransitions(...)
    CupertinoPageRoute->CRT_Mixin: (delegates to mixin's method)
    CRT_Mixin->CRT_Mixin: calls buildPageTransitions(...)
    CRT_Mixin->CPTransition: creates CPTransition(...) with child and animations
    CPTransition->NewScreen: wraps NewScreen
    CRT_Mixin-->Navigator: returns CPTransition(NewScreen)
    Navigator->Navigator: Animates the transition using CPTransition
```

The `CupertinoPageTransition` and `CupertinoFullscreenDialogTransition` widgets are the ones that *actually perform* the visual animation (sliding the child widget using the provided animation values). We'll look at those in more detail in the next chapters!

### You Won't Necessarily Use It Directly

Similar to `MaterialRouteTransitionMixin`, you as a beginner app developer are typically not expected to directly use `CupertinoRouteTransitionMixin`. Its main purpose is to serve as a building block for other `PageRoute` types, most notably `CupertinoPageRoute`.

When you use `CupertinoPageRoute`, you automatically get the benefits of the transition logic contained within `CupertinoRouteTransitionMixin` without having to think about the mixin itself.

### Conclusion

`CupertinoRouteTransitionMixin` is the powerhouse behind `CupertinoPageRoute`'s native iOS transition animations. It provides the `buildTransitions` logic, deciding which specific Cupertino transition widget (`CupertinoPageTransition` or `CupertinoFullscreenDialogTransition`) to use based on the route type and giving it the necessary animation details to perform the visual effect. While you usually interact with `CupertinoPageRoute`, understanding that `CupertinoRouteTransitionMixin` provides the core animation recipe clarifies how these iOS-style transitions are achieved in Flutter.

In the next chapter, we'll focus on `CupertinoPageTransition`, the primary widget used by `CupertinoRouteTransitionMixin` to create the standard iOS page slide animation.

[Next Chapter: CupertinoPageTransition](06_cupertinopagetransition_.md)
---
# Chapter 6: CupertinoPageTransition

Welcome back! In [Chapter 5: CupertinoRouteTransitionMixin](05_cupertinoroutetransitionmixin_.md), we learned that `CupertinoRouteTransitionMixin` holds the recipe for creating those distinct iOS-style transition animations, and how `CupertinoPageRoute` uses this mixin. Now, let's focus on one of the key ingredients in that recipe: the `CupertinoPageTransition` widget itself.

### What is CupertinoPageTransition?

Imagine the screen of your iPhone. When you tap on an item in a list and a new screen slides into view from the right, that smooth animation is done by a special widget. In Flutter's Cupertino world, that special widget is `CupertinoPageTransition`.

`CupertinoPageTransition` is a widget that doesn't display its own content directly. Instead, it takes another widget (which is the new screen you want to show) and applies a specific animation and visual effect to it. It's the visual performer of the standard iOS page-to-page transitions.

Here's what it does:

*   It makes the new screen (`child` widget) slide in from the right.
*   It makes the original screen (the one being covered) slightly slide to the left, creating a cool "parallax" effect.
*   It might also add a subtle shadow effect on the edge of the incoming screen.
*   It uses the "animation" objects provided by the `PageRoute` to know how far along the transition is.

It's important to remember that `CupertinoPageTransition` is just the **visual effect** widget. It relies on a `PageRoute` (like `CupertinoPageRoute`) and the `Navigator` to decide *when* to run the animation and *what* pages to animate.

**Motivation:** We want to understand the actual widget that visually creates the distinct iOS sliding and parallax effect during a page transition. That widget is `CupertinoPageTransition`.

### How CupertinoPageTransition Works

You won't typically create a `CupertinoPageTransition` widget yourself directly in your app code for basic navigation. It is created *internally* by the `CupertinoRouteTransitionMixin` (which is used by `CupertinoPageRoute`).

Let's think about the information `CupertinoPageTransition` needs:

1.  **The content to animate:** This is the widget tree of the new screen you are navigating to. `CupertinoPageTransition` needs to wrap this content.
2.  **The animation progress for the incoming page:** An `Animation` object that typically goes from 0.0 (off-screen) to 1.0 (fully on-screen).
3.  **The animation progress for the outgoing page:** An `Animation` object that typically goes from 0.0 (fully on-screen) to 1.0 (off-screen to the left). This is used for the parallax effect.
4.  **Whether the transition is "linear":** This is used internally for tracking user gestures like swiping back, ensuring the animation follows the finger precisely.

The `CupertinoRouteTransitionMixin`'s `buildTransitions` method (which `CupertinoPageRoute` uses) is responsible for creating the `CupertinoPageTransition` widget and giving it these pieces of information.

Here's a simplified look at how `CupertinoPageRoute` (via its mixin) uses `CupertinoPageTransition`:

```dart
// Simplified concept - from CupertinoRouteTransitionMixin's buildTransitions logic
// This code is inside the Flutter framework, not your app!
Widget buildPageTransitions(
  PageRoute<T> route, // The route being built
  BuildContext context,
  Animation<double> primaryAnimation, // Animation for the new page
  Animation<double> secondaryAnimation, // Animation for the old page
  Widget child, // the NewScreen widget
) {
  // Decide if it's a fullscreen dialog or a regular page
  if (route.fullscreenDialog) {
    // Use a different transition for dialogs (more on this later)
    return CupertinoFullscreenDialogTransition(...);
  } else {
    // For regular pages, use CupertinoPageTransition!
    return CupertinoPageTransition(
      primaryRouteAnimation: primaryAnimation, // Pass incoming animation
      secondaryRouteAnimation: secondaryAnimation, // Pass outgoing animation
      linearTransition: route.popGestureInProgress, // Is a swipe back happening?
      child: child, // Wrap the NewScreen widget
    );
  }
}
```

This shows that `CupertinoPageTransition` is instantiated by the *framework* code that the `CupertinoRouteTransitionMixin` provides. It acts as a container for your `child` widget (`NewScreen` in our example) and applies the animations specified by `primaryRouteAnimation` and `secondaryRouteAnimation`.

### The Visual Magic

Inside `CupertinoPageTransition`, the actual visual effect is created using standard Flutter animation widgets, primarily `SlideTransition` and `DecoratedBoxTransition`.

Let's simplify the core `build` method of `CupertinoPageTransition`:

```dart
// Simplified concept - from the build method inside CupertinoPageTransition
@override
Widget build(BuildContext context) {
  // calculate slide for secondary (outgoing) page (parallax)
  // based on secondaryRouteAnimation

  // calculate slide for primary (incoming) page
  // based on primaryRouteAnimation

  // calculate shadow for primary (incoming) page
  // based on primaryRouteAnimation

  return SlideTransition(
    position: _secondaryPositionAnimation, // Moves the outgoing page
    child: SlideTransition(
      position: _primaryPositionAnimation, // Moves the incoming page
      child: DecoratedBoxTransition(
        decoration: _primaryShadowAnimation, // Adds edge shadow
        child: widget.child, // The actual screen content (NewScreen)
      ),
    ),
  );
}
```

This nested structure is key:

1.  The outermost `SlideTransition` uses `_secondaryPositionAnimation` (derived from `secondaryRouteAnimation`) to slightly slide the **outgoing page** (which is the `child` *of the inner* `SlideTransition`) to the left, creating the parallax effect.
2.  The inner `SlideTransition` uses `_primaryPositionAnimation` (derived from `primaryRouteAnimation`) to slide the **incoming page** (`widget.child`) from the right to the center.
3.  The `DecoratedBoxTransition` wraps the `widget.child` and applies a subtle gradient shadow effect on the leading edge as it slides in, using `_primaryShadowAnimation`.

```mermaid
graph TD
    A[Navigator] --> B[CupertinoPageRoute];
    B --> C[CupertinoRouteTransitionMixin]
    C --> D[buildTransitions calls buildPageTransitions]
    D --> E[Creates CupertinoPageTransition]
    E --> F{Build Method of CupertinoPageTransition};
    F --> G[Outer SlideTransition - Secondary Animation (Parallax)];
    G --> H[Inner SlideTransition - Primary Animation (Slide In)];
    H --> I[DecoratedBoxTransition - Edge Shadow];
    I --> J[Your NewScreen Widget];
```

So, `CupertinoPageTransition` stitches together several basic animation widgets (`SlideTransition`, `DecoratedBoxTransition`) using the `Animation` objects it receives to create the complete visual iOS page transition effect.

### You Still Don't Use It Directly (Mostly)

Just like `CupertinoRouteTransitionMixin`, you generally won't hand-craft a `CupertinoPageTransition` widget in your typical navigation code. When you use `CupertinoPageRoute`, the framework automatically creates and manages the `CupertinoPageTransition` for you.

Understanding `CupertinoPageTransition` helps you appreciate how the finished iOS-style transition is composed of multiple visual elements (sliding the new page, sliding the old page, adding a shadow) all orchestrated by the primary and secondary animation objects.

### Conclusion

`CupertinoPageTransition` is the concrete widget that implements the visual aspects of the standard iOS page transition, including sliding, parallax, and shadowing. It receives animation data from a `PageRoute` (like `CupertinoPageRoute` via its mixin) and uses built-in animation widgets to apply these effects to the new screen's content. While you don't usually need to use it directly, knowing it exists clarifies how Flutter achieves that native iOS navigation feel.

In the next chapter, we'll look at `CupertinoFullscreenDialogTransition`, a similar widget but used for the different animation style employed by iOS for fullscreen modal dialogs.

[Next Chapter: CupertinoFullscreenDialogTransition](07_cupertinofullscreendialogtransition_.md)

Relevant Code Snippets (Code itself remains unchanged):
--- File: packages/flutter/lib/src/cupertino/route.dart ---
// Copyright 2014 The Flutter Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

/// @docImport 'dart:ui';
///
/// @docImport 'package:flutter/material.dart';
/// @docImport 'package:flutter/services.dart';
///
/// @docImport 'app.dart';
/// @docImport 'button.dart';
/// @docImport 'dialog.dart';
/// @docImport 'nav_bar.dart';
/// @docImport 'page_scaffold.dart';
/// @docImport 'tab_scaffold.dart';
library;

import 'dart:math';
import 'dart:ui' show ImageFilter;

import 'package:flutter/foundation.dart';
import 'package:flutter/gestures.dart';
import 'package:flutter/physics.dart';
import 'package:flutter/rendering.dart';
import 'package:flutter/widgets.dart';

import 'colors.dart';
import 'interface_level.dart';
import 'localizations.dart';

const double _kBackGestureWidth = 20.0;
const double _kMinFlingVelocity = 1.0; // Screen widths per second.

// The duration for a page to animate when the user releases it mid-swipe.
const Duration _kDroppedSwipePageAnimationDuration = Duration(milliseconds: 350);

/// Barrier color used for a barrier visible during transitions for Cupertino
/// page routes.
///
/// This barrier color is only used for full-screen page routes with
/// `fullscreenDialog: false`.
///
/// By default, `fullscreenDialog` Cupertino route transitions have no
/// `barrierColor`, and [CupertinoDialogRoute]s and [CupertinoModalPopupRoute]s
/// have a `barrierColor` defined by [kCupertinoModalBarrierColor].
///
/// A relatively rigorous eyeball estimation.
const Color _kCupertinoPageTransitionBarrierColor = Color(0x18000000);

/// Barrier color for a Cupertino modal barrier.
///
/// Extracted from https://developer.apple.com/design/resources/.
const Color kCupertinoModalBarrierColor = CupertinoDynamicColor.withBrightness(
  color: Color(0x33000000),
  darkColor: Color(0x7A000000),
);

// The duration of the transition used when a modal popup is shown.
const Duration _kModalPopupTransitionDuration = Duration(milliseconds: 335);

// Offset from offscreen to the right to fully on screen.
final Animatable<Offset> _kRightMiddleTween = Tween<Offset>(
  begin: const Offset(1.0, 0.0),
  end: Offset.zero,
);

// Offset from fully on screen to 1/3 offscreen to the left.
final Animatable<Offset> _kMiddleLeftTween = Tween<Offset>(
  begin: Offset.zero,
  end: const Offset(-1.0 / 3.0, 0.0),
);

// Offset from offscreen below to fully on screen.
final Animatable<Offset> _kBottomUpTween = Tween<Offset>(
  begin: const Offset(0.0, 1.0),
  end: Offset.zero,
);

/// A mixin that replaces the entire screen with an iOS transition for a
/// [PageRoute].
///
/// {@template flutter.cupertino.cupertinoRouteTransitionMixin}
/// The page slides in from the right and exits in reverse. The page also shifts
/// to the left in parallax when another page enters to cover it.
///
/// The page slides in from the bottom and exits in reverse with no parallax
/// effect for fullscreen dialogs.
/// {@endtemplate}
///
/// See also:
///
///  * [MaterialRouteTransitionMixin], which is a mixin that provides
///    platform-appropriate transitions for a [PageRoute].
///  * [CupertinoPageRoute], which is a [PageRoute] that leverages this mixin.
mixin CupertinoRouteTransitionMixin<T> on PageRoute<T> {
  /// Builds the primary contents of the route.
  @protected
  Widget buildContent(BuildContext context);

  /// {@template flutter.cupertino.CupertinoRouteTransitionMixin.title}
  /// A title string for this route.
  ///
  /// Used to auto-populate [CupertinoNavigationBar] and
  /// [CupertinoSliverNavigationBar]'s `middle`/`largeTitle` widgets when
  /// one is not manually supplied.
  /// {@endtemplate}
  String? get title;

  ValueNotifier<String?>? _previousTitle;

  /// The title string of the previous [CupertinoPageRoute].
  ///
  /// The [ValueListenable]'s value is readable after the route is installed
  /// onto a [Navigator]. The [ValueListenable] will also notify its listeners
  /// if the value changes (such as by replacing the previous route).
  ///
  /// The [ValueListenable] itself will be null before the route is installed.
  /// Its content value will be null if the previous route has no title or
  /// is not a [CupertinoPageRoute].
  ///
  /// See also:
  ///
  ///  * [ValueListenableBuilder], which can be used to listen and rebuild
  ///    widgets based on a ValueListenable.
  ValueListenable<String?> get previousTitle {
    assert(
      _previousTitle != null,
      'Cannot read the previousTitle for a route that has not yet been installed',
    );
    return _previousTitle!;
  }

  @override
  void dispose() {
    _previousTitle?.dispose();
    super.dispose();
  }

  @override
  void didChangePrevious(Route<dynamic>? previousRoute) {
    final String? previousTitleString =
        previousRoute is CupertinoRouteTransitionMixin ? previousRoute.title : null;
    if (_previousTitle == null) {
      _previousTitle = ValueNotifier<String?>(previousTitleString);
    } else {
      _previousTitle!.value = previousTitleString;
    }
    super.didChangePrevious(previousRoute);
  }

  @override
  // A relatively rigorous eyeball estimation.
  Duration get transitionDuration => const Duration(milliseconds: 500);

  @override
  Color? get barrierColor => fullscreenDialog ? null : _kCupertinoPageTransitionBarrierColor;

  @override
  String? get barrierLabel => null;

  @override
  bool canTransitionTo(TransitionRoute<dynamic> nextRoute) {
    // Don't perform outgoing animation if the next route is a fullscreen dialog.
    final bool nextRouteIsNotFullscreen =
        (nextRoute is! PageRoute<T>) || !nextRoute.fullscreenDialog;

    // If the next route has a delegated transition, then this route is able to
    // use that delegated transition to smoothly sync with the next route's
    // transition.
    final bool nextRouteHasDelegatedTransition =
        nextRoute is ModalRoute<T> && nextRoute.delegatedTransition != null;

    // Otherwise if the next route has the same route transition mixin as this
    // one, then this route will already be synced with its transition.
    return nextRouteIsNotFullscreen &&
        ((nextRoute is CupertinoRouteTransitionMixin) || nextRouteHasDelegatedTransition);
  }

  @override
  bool canTransitionFrom(TransitionRoute<dynamic> previousRoute) {
    // Supress previous route from transitioning if this is a fullscreenDialog route.
    return previousRoute is PageRoute && !fullscreenDialog;
  }

  @override
  Widget buildPage(
    BuildContext context,
    Animation<double> animation,
    Animation<double> secondaryAnimation,
  ) {
    final Widget child = buildContent(context);
    return Semantics(scopesRoute: true, explicitChildNodes: true, child: child);
  }

  // Called by _CupertinoBackGestureDetector when a pop ("back") drag start
  // gesture is detected. The returned controller handles all of the subsequent
  // drag events.
  static _CupertinoBackGestureController<T> _startPopGesture<T>(PageRoute<T> route) {
    assert(route.popGestureEnabled);

    return _CupertinoBackGestureController<T>(
      navigator: route.navigator!,
      getIsCurrent: () => route.isCurrent,
      getIsActive: () => route.isActive,
      controller: route.controller!, // protected access
    );
  }

  /// Returns a [CupertinoFullscreenDialogTransition] if [route] is a full
  /// screen dialog, otherwise a [CupertinoPageTransition] is returned.
  ///
  /// Used by [CupertinoPageRoute.buildTransitions].
  ///
  /// This method can be applied to any [PageRoute], not just
  /// [CupertinoPageRoute]. It's typically used to provide a Cupertino style
  /// horizontal transition for material widgets when the target platform
  /// is [TargetPlatform.iOS].
  ///
  /// See also:
  ///
  ///  * [CupertinoPageTransitionsBuilder], which uses this method to define a
  ///    [PageTransitionsBuilder] for the [PageTransitionsTheme].
  static Widget buildPageTransitions<T>(
    PageRoute<T> route,
    BuildContext context,
    Animation<double> animation,
    Animation<double> secondaryAnimation,
    Widget child,
  ) {
    // Check if the route has an animation that's currently participating
    // in a back swipe gesture.
    //
    // In the middle of a back gesture drag, let the transition be linear to
    // match finger motions.
    final bool linearTransition = route.popGestureInProgress;
    if (route.fullscreenDialog) {
      return CupertinoFullscreenDialogTransition(
        primaryRouteAnimation: animation,
        secondaryRouteAnimation: secondaryAnimation,
        linearTransition: linearTransition,
        child: child,
      );
    } else {
      return CupertinoPageTransition(
        primaryRouteAnimation: animation,
        secondaryRouteAnimation: secondaryAnimation,
        linearTransition: linearTransition,
        child: _CupertinoBackGestureDetector<T>(
          enabledCallback: () => route.popGestureEnabled,
          onStartPopGesture: () => _startPopGesture<T>(route),
          child: child,
        ),
      );
    }
  }

  @override
  Widget buildTransitions(
    BuildContext context,
    Animation<double> animation,
    Animation<double> secondaryAnimation,
    Widget child,
  ) {
    return buildPageTransitions<T>(this, context, animation, secondaryAnimation, child);
  }
}

/// A modal route that replaces the entire screen with an iOS transition.
///
/// {@macro flutter.cupertino.cupertinoRouteTransitionMixin}
///
/// By default, when a modal route is replaced by another, the previous route
/// remains in memory. To free all the resources when this is not necessary, set
/// [maintainState] to false.
///
/// The type `T` specifies the return type of the route which can be supplied as
/// the route is popped from the stack via [Navigator.pop] when an optional
/// `result` can be provided.
///
/// If `barrierDismissible` is true, then pressing the escape key on the keyboard
/// will cause the current route to be popped with null as the value.
///
/// See also:
///
///  * [CupertinoRouteTransitionMixin], for a mixin that provides iOS transition
///    for this modal route.
///  * [MaterialPageRoute], for an adaptive [PageRoute] that uses a
///    platform-appropriate transition.
///  * [CupertinoPageScaffold], for applications that have one page with a fixed
///    navigation bar on top.
///  * [CupertinoTabScaffold], for applications that have a tab bar at the
///    bottom with multiple pages.
///  * [CupertinoPage], for a [Page] version of this class.
class CupertinoPageRoute<T> extends PageRoute<T> with CupertinoRouteTransitionMixin<T> {
  /// Creates a page route for use in an iOS designed app.
  ///
  /// The [builder], [maintainState], and [fullscreenDialog] arguments must not
  /// be null.
  CupertinoPageRoute({
    required this.builder,
    this.title,
    super.settings,
    super.requestFocus,
    this.maintainState = true,
    super.fullscreenDialog,
    super.allowSnapshotting = true,
    super.barrierDismissible = false,
  }) {
    assert(opaque);
  }

  @override
  DelegatedTransitionBuilder? get delegatedTransition =>
      CupertinoPageTransition.delegatedTransition;

  /// Builds the primary contents of the route.
  final WidgetBuilder builder;

  @override
  Widget buildContent(BuildContext context) => builder(context);

  @override
  final String? title;

  @override
  final bool maintainState;

  @override
  String get debugLabel => '${super.debugLabel}(${settings.name})';
}

// A page-based version of CupertinoPageRoute.
//
// This route uses the builder from the page to build its content. This ensures
// the content is up to date after page updates.
class _PageBasedCupertinoPageRoute<T> extends PageRoute<T> with CupertinoRouteTransitionMixin<T> {
  _PageBasedCupertinoPageRoute({required CupertinoPage<T> page, super.allowSnapshotting = true})
    : super(settings: page) {
    assert(opaque);
  }

  @override
  DelegatedTransitionBuilder? get delegatedTransition =>
      this.fullscreenDialog ? null : CupertinoPageTransition.delegatedTransition;

  CupertinoPage<T> get _page => settings as CupertinoPage<T>;

  @override
  Widget buildContent(BuildContext context) => _page.child;

  @override
  String? get title => _page.title;

  @override
  bool get maintainState => _page.maintainState;

  @override
  bool get fullscreenDialog => _page.fullscreenDialog;

  @override
  String get debugLabel => '${super.debugLabel}(${_page.name})';
}

/// A page that creates a cupertino style [PageRoute].
///
/// {@macro flutter.cupertino.cupertinoRouteTransitionMixin}
///
/// By default, when a created modal route is replaced by another, the previous
/// route remains in memory. To free all the resources when this is not
/// necessary, set [maintainState] to false.
///
/// The type `T` specifies the return type of the route which can be supplied as
/// the route is popped from the stack via [Navigator.transitionDelegate] by
/// providing the optional `result` argument to the
/// [RouteTransitionRecord.markForPop] in the [TransitionDelegate.resolve].
///
/// See also:
///
///  * [CupertinoPageRoute], for a [PageRoute] version of this class.
class CupertinoPage<T> extends Page<T> {
  /// Creates a cupertino page.
  const CupertinoPage({
    required this.child,
    this.maintainState = true,
    this.title,
    this.fullscreenDialog = false,
    this.allowSnapshotting = true,
    super.canPop,
    super.onPopInvoked,
    super.key,
    super.name,
    super.arguments,
    super.restorationId,
  });

  /// The content to be shown in the [Route] created by this page.
  final Widget child;

  /// {@macro flutter.cupertino.CupertinoRouteTransitionMixin.title}
  final String? title;

  /// {@macro flutter.widgets.ModalRoute.maintainState}
  final bool maintainState;

  /// {@macro flutter.widgets.PageRoute.fullscreenDialog}
  final bool fullscreenDialog;

  /// {@macro flutter.widgets.TransitionRoute.allowSnapshotting}
  final bool allowSnapshotting;

  @override
  Route<T> createRoute(BuildContext context) {
    return _PageBasedCupertinoPageRoute<T>(page: this, allowSnapshotting: allowSnapshotting);
  }
}

/// Provides an iOS-style page transition animation.
///
/// The page slides in from the right and exits in reverse. It also shifts to the left in
/// a parallax motion when another page enters to cover it.
class CupertinoPageTransition extends StatefulWidget {
  /// Creates an iOS-style page transition.
  ///
  const CupertinoPageTransition({
    super.key,
    required this.primaryRouteAnimation,
    required this.secondaryRouteAnimation,
    required this.child,
    required this.linearTransition,
  });

  /// The widget below this widget in the tree.
  final Widget child;

  ///  * `primaryRouteAnimation` is a linear route animation from 0.0 to 1.0
  ///    when this screen is being pushed.
  final Animation<double> primaryRouteAnimation;

  ///  * `secondaryRouteAnimation` is a linear route animation from 0.0 to 1.0
  ///    when another screen is being pushed on top of this one.
  final Animation<double> secondaryRouteAnimation;

  ///  * `linearTransition` is whether to perform the transitions linearly.
  ///    Used to precisely track back gesture drags.
  final bool linearTransition;

  /// The Cupertino styled [DelegatedTransitionBuilder] provided to the previous
  /// route.
  ///
  /// {@macro flutter.widgets.delegatedTransition}
  static Widget? delegatedTransition(
    BuildContext context,
    Animation<double> animation,
    Animation<double> secondaryAnimation,
    bool allowSnapshotting,
    Widget? child,
  ) {
    final CurvedAnimation animation = CurvedAnimation(
      parent: secondaryAnimation,
      curve: Curves.linearToEaseOut,
      reverseCurve: Curves.easeInToLinear,
    );
    final Animation<Offset> delegatedPositionAnimation = animation.drive(_kMiddleLeftTween);
    animation.dispose();

    assert(debugCheckHasDirectionality(context));
    final TextDirection textDirection = Directionality.of(context);
    return SlideTransition(
      position: delegatedPositionAnimation,
      textDirection: textDirection,
      transformHitTests: false,
      child: child,
    );
  }

  @override
  State<CupertinoPageTransition> createState() => _CupertinoPageTransitionState();
}

class _CupertinoPageTransitionState extends State<CupertinoPageTransition> {
  // When this page is coming in to cover another page.
  late Animation<Offset> _primaryPositionAnimation;
  // When this page is becoming covered by another page.
  late Animation<Offset> _secondaryPositionAnimation;
  // Shadow of page which is coming in to cover another page.
  late Animation<Decoration> _primaryShadowAnimation;
  // Curve of primary page which is coming in to cover another page.
  CurvedAnimation? _primaryPositionCurve;
  // Curve of secondary page which is becoming covered by another page.
  CurvedAnimation? _secondaryPositionCurve;
  // Curve of primary page's shadow.
  CurvedAnimation? _primaryShadowCurve;

  @override
  void initState() {
    super.initState();
    _setupAnimation();
  }

  @override
  void didUpdateWidget(covariant CupertinoPageTransition oldWidget) {
    super.didUpdateWidget(oldWidget);
    if (oldWidget.primaryRouteAnimation != widget.primaryRouteAnimation ||
        oldWidget.secondaryRouteAnimation != widget.secondaryRouteAnimation ||
        oldWidget.linearTransition != widget.linearTransition) {
      _disposeCurve();
      _setupAnimation();
    }
  }

  @override
  void dispose() {
    _disposeCurve();
    super.dispose();
  }

  void _disposeCurve() {
    _primaryPositionCurve?.dispose();
    _secondaryPositionCurve?.dispose();
    _primaryShadowCurve?.dispose();
    _primaryPositionCurve = null;
    _secondaryPositionCurve = null;
    _primaryShadowCurve = null;
  }

  void _setupAnimation() {
    if (!widget.linearTransition) {
      _primaryPositionCurve = CurvedAnimation(
        parent: widget.primaryRouteAnimation,
        curve: Curves.fastEaseInToSlowEaseOut,
        reverseCurve: Curves.fastEaseInToSlowEaseOut.flipped,
      );
      _secondaryPositionCurve = CurvedAnimation(
        parent: widget.secondaryRouteAnimation,
        curve: Curves.linearToEaseOut,
        reverseCurve: Curves.easeInToLinear,
      );
      _primaryShadowCurve = CurvedAnimation(
        parent: widget.primaryRouteAnimation,
        curve: Curves.linearToEaseOut,
      );
    }
    _primaryPositionAnimation = (_primaryPositionCurve ?? widget.primaryRouteAnimation).drive(
      _kRightMiddleTween,
    );
    _secondaryPositionAnimation = (_secondaryPositionCurve ?? widget.secondaryRouteAnimation).drive(
      _kMiddleLeftTween,
    );
    _primaryShadowAnimation = (_primaryShadowCurve ?? widget.primaryRouteAnimation).drive(
      _CupertinoEdgeShadowDecoration.kTween,
    );
  }

  @override
  Widget build(BuildContext context) {
    assert(debugCheckHasDirectionality(context));
    final TextDirection textDirection = Directionality.of(context);
    return SlideTransition(
      position: _secondaryPositionAnimation,
      textDirection: textDirection,
      transformHitTests: false,
      child: SlideTransition(
        position: _primaryPositionAnimation,
        textDirection: textDirection,
        child: DecoratedBoxTransition(decoration: _primaryShadowAnimation, child: widget.child),
      ),
    );
  }
}

/// An iOS-style transition used for summoning fullscreen dialogs.
///
/// For example, used when creating a new calendar event by bringing in the next
/// screen from the bottom.
class CupertinoFullscreenDialogTransition extends StatefulWidget {
  /// Creates an iOS-style transition used for summoning fullscreen dialogs.
  ///
  const CupertinoFullscreenDialogTransition({
    super.key,
    required this.primaryRouteAnimation,
    required this.secondaryRouteAnimation,
    required this.child,
    required this.linearTransition,
  });

  ///  * `primaryRouteAnimation` is a linear route animation from 0.0 to 1.0
  ///    when this screen is being pushed.
  final Animation<double> primaryRouteAnimation;

  ///  * `secondaryRouteAnimation` is a linear route animation from 0.0 to 1.0
  ///    when another screen is being pushed on top of this one.
  final Animation<double> secondaryRouteAnimation;

  ///  * `linearTransition` is whether to perform the transitions linearly.
  ///    Used to precisely track back gesture drags.
  final bool linearTransition;

  /// The widget below this widget in the tree.
  final Widget child;

  @override
  State<CupertinoFullscreenDialogTransition> createState() =>
      _CupertinoFullscreenDialogTransitionState();
}

class _CupertinoFullscreenDialogTransitionState extends State<CupertinoFullscreenDialogTransition> {
  /// When this page is coming in to cover another page.
  late Animation<Offset> _primaryPositionAnimation;

  /// When this page is becoming covered by another page.
  late Animation<Offset> _secondaryPositionAnimation;

  /// Curve of primary page which is coming in to cover another page.
  CurvedAnimation? _primaryPositionCurve;

  /// Curve of secondary page which is becoming covered by another page.
  CurvedAnimation? _secondaryPositionCurve;

  @override
  void initState() {
    super.initState();
    _setupAnimation();
  }

  @override
  void didUpdateWidget(covariant CupertinoFullscreenDialogTransition oldWidget) {
    super.didUpdateWidget(oldWidget);
    if (oldWidget.primaryRouteAnimation != widget.primaryRouteAnimation ||
        oldWidget.secondaryRouteAnimation != widget.secondaryRouteAnimation ||
        oldWidget.linearTransition != widget.linearTransition) {
      _disposeCurve();
      _setupAnimation();
    }
  }

  @override
  void dispose() {
    _disposeCurve();
    super.dispose();
  }

  void _disposeCurve() {
    _primaryPositionCurve?.dispose();
    _secondaryPositionCurve?.dispose();
    _primaryPositionCurve = null;
    _secondaryPositionCurve = null;
  }

  void _setupAnimation() {
    _primaryPositionAnimation = (_primaryPositionCurve = CurvedAnimation(
          parent: widget.primaryRouteAnimation,
          curve: Curves.linearToEaseOut,
          // The curve must be flipped so that the reverse animation doesn't play
          // an ease-in curve, which iOS does not use.
          reverseCurve: Curves.linearToEaseOut.flipped,
        ))
        .drive(_kBottomUpTween);
    _secondaryPositionAnimation = (widget.linearTransition
            ? widget.secondaryRouteAnimation
            : _secondaryPositionCurve = CurvedAnimation(
              parent: widget.secondaryRouteAnimation,
              curve: Curves.linearToEaseOut,
              reverseCurve: Curves.easeInToLinear,
            ))
        .drive(_kMiddleLeftTween);
  }

  @override
  Widget build(BuildContext context) {
    assert(debugCheckHasDirectionality(context));
    final TextDirection textDirection = Directionality.of(context);
    return SlideTransition(
      position: _secondaryPositionAnimation,
      textDirection: textDirection,
      transformHitTests: false,
      child: SlideTransition(position: _primaryPositionAnimation, child: widget.child),
    );
  }
}

/// This is the widget side of [_CupertinoBackGestureController].
///
/// This widget provides a gesture recognizer which, when it determines the
/// route can be closed with a back gesture, creates the controller and
/// feeds it the input from the gesture recognizer.
///
/// The gesture data is converted from absolute coordinates to logical
/// coordinates by this widget.
///
/// The type `T` specifies the return type of the route with which this gesture
/// detector is associated.
class _CupertinoBackGestureDetector<T> extends StatefulWidget {
  const _CupertinoBackGestureDetector({
    super.key,
    required this.enabledCallback,
    required this.onStartPopGesture,
    required this.child,
  });

  final Widget child;

  final ValueGetter<bool> enabledCallback;

  final ValueGetter<_CupertinoBackGestureController<T>> onStartPopGesture;

  @override
  _CupertinoBackGestureDetectorState<T> createState() => _CupertinoBackGestureDetectorState<T>();
}

class _CupertinoBackGestureDetectorState<T> extends State<_CupertinoBackGestureDetector<T>> {
  _CupertinoBackGestureController<T>? _backGestureController;

  late HorizontalDragGestureRecognizer _recognizer;

  @override
  void initState() {
    super.initState();
    _recognizer =
        HorizontalDragGestureRecognizer(debugOwner: this)
          ..onStart = _handleDragStart
          ..onUpdate = _handleDragUpdate
          ..onEnd = _handleDragEnd
          ..onCancel = _handleDragCancel;
  }

  @override
  void dispose() {
    _recognizer.dispose();

    // If this is disposed during a drag, call navigator.didStopUserGesture.
    if (_backGestureController != null) {
      WidgetsBinding.instance.addPostFrameCallback((_) {
        if (_backGestureController?.navigator.mounted ?? false) {
          _backGestureController?.navigator.didStopUserGesture();
        }
        _backGestureController = null;
      });
    }
    super.dispose();
  }

  void _handleDragStart(DragStartDetails details) {
    assert(mounted);
    assert(_backGestureController == null);
    _backGestureController = widget.onStartPopGesture();
  }

  void _handleDragUpdate(DragUpdateDetails details) {
    assert(mounted);
    assert(_backGestureController != null);
    _backGestureController!.dragUpdate(
      _convertToLogical(details.primaryDelta! / context.size!.width),
    );
  }

  void _handleDragEnd(DragEndDetails details) {
    assert(mounted);
    assert(_backGestureController != null);
    _backGestureController!.dragEnd(
      _convertToLogical(details.velocity.pixelsPerSecond.dx / context.size!.width),
    );
    _backGestureController = null;
  }

  void _handleDragCancel() {
    assert(mounted);
    // This can be called even if start is not called, paired with the "down" event
    // that we don't consider here.
    _backGestureController?.dragEnd(0.0);
    _backGestureController = null;
  }

  void _handlePointerDown(PointerDownEvent event) {
    if (widget.enabledCallback()) {
      _recognizer.addPointer(event);
    }
  }

  double _convertToLogical(double value) {
    return switch (Directionality.of(context)) {
      TextDirection.rtl => -value,
      TextDirection.ltr => value,
    };
  }

  @override
  Widget build(BuildContext context) {
    assert(debugCheckHasDirectionality(context));
    // For devices with notches, the drag area needs to be larger on the side
    // that has the notch.
    final double dragAreaWidth = switch (Directionality.of(context)) {
      TextDirection.rtl => MediaQuery.paddingOf(context).right,
      TextDirection.ltr => MediaQuery.paddingOf(context).left,
    };
    return Stack(
      fit: StackFit.passthrough,
      children: <Widget>[
        widget.child,
        PositionedDirectional(
          start: 0.0,
          width: max(dragAreaWidth, _kBackGestureWidth),
          top: 0.0,
          bottom: 0.0,
          child: Listener(onPointerDown: _handlePointerDown, behavior: HitTestBehavior.translucent),
        ),
      ],
    );
  }
}

/// A controller for an iOS-style back gesture.
///
/// This is created by a [CupertinoPageRoute] in response from a gesture caught
/// by a [_CupertinoBackGestureDetector] widget, which then also feeds it input
/// from the gesture. It controls the animation controller owned by the route,
/// based on the input provided by the gesture detector.
///
/// This class works entirely in logical coordinates (0.0 is new page dismissed,
/// 1.0 is new page on top).
///
/// The type `T` specifies the return type of the route with which this gesture
/// detector controller is associated.
class _CupertinoBackGestureController<T> {
  /// Creates a controller for an iOS-style back gesture.
  _CupertinoBackGestureController({
    required this.navigator,
    required this.controller,
    required this.getIsActive,
    required this.getIsCurrent,
  }) {
    navigator.didStartUserGesture();
  }

  final AnimationController controller;
  final NavigatorState navigator;
  final ValueGetter<bool> getIsActive;
  final ValueGetter<bool> getIsCurrent;

  /// The drag gesture has changed by [delta]. The total range of the drag
  /// should be 0.0 to 1.0.
  void dragUpdate(double delta) {
    controller.value -= delta;
  }

  /// The drag gesture has ended with a horizontal motion of [velocity] as a
  /// fraction of screen width per second.
  void dragEnd(double velocity) {
    // Fling in the appropriate direction.
    //
    // This curve has been determined through rigorously eyeballing native iOS
    // animations.
    const Curve animationCurve = Curves.fastEaseInToSlowEaseOut;
    final bool isCurrent = getIsCurrent();
    final bool animateForward;

    if (!isCurrent) {
      // If the page has already been navigated away from, then the animation
      // direction depends on whether or not it's still in the navigation stack,
      // regardless of velocity or drag position. For example, if a route is
      // being slowly dragged back by just a few pixels, but then a programmatic
      // pop occurs, the route should still be animated off the screen.
      // See https://github.com/flutter/flutter/issues/141268.
      animateForward = getIsActive();
    } else if (velocity.abs() >= _kMinFlingVelocity) {
      // If the user releases the page before mid screen with sufficient velocity,
      // or after mid screen, we should animate the page out. Otherwise, the page
      // should be animated back in.
      animateForward = velocity <= 0;
    } else {
      animateForward = controller.value > 0.5;
    }

    if (animateForward) {
      controller.animateTo(
        1.0,
        duration: _kDroppedSwipePageAnimationDuration,
        curve: animationCurve,
      );
    } else {
      if (isCurrent) {
        // This route is destined to pop at this point. Reuse navigator's pop.
        navigator.pop();
      }

      // The popping may have finished inline if already at the target destination.
      if (controller.isAnimating) {
        controller.animateBack(
          0.0,
          duration: _kDroppedSwipePageAnimationDuration,
          curve: animationCurve,
        );
      }
    }

    if (controller.isAnimating) {
      // Keep the userGestureInProgress in true state so we don't change the
      // curve of the page transition mid-flight since CupertinoPageTransition
      // depends on userGestureInProgress.
      late AnimationStatusListener animationStatusCallback;
      animationStatusCallback = (AnimationStatus status) {
        navigator.didStopUserGesture();
        controller.removeStatusListener(animationStatusCallback);
      };
      controller.addStatusListener(animationStatusCallback);
    } else {
      navigator.didStopUserGesture();
    }
  }
}

// A custom [Decoration] used to paint an extra shadow on the start edge of the
// box it's decorating. It's like a [BoxDecoration] with only a gradient except
// it paints on the start side of the box instead of behind the box.
class _CupertinoEdgeShadowDecoration extends Decoration {
  const _CupertinoEdgeShadowDecoration._([this._colors]);

  static DecorationTween kTween = DecorationTween(
    begin: const _CupertinoEdgeShadowDecoration._(), // No decoration initially.
    end: const _CupertinoEdgeShadowDecoration._(
      // Eyeballed gradient used to mimic a drop shadow on the start side only.
      <Color>[Color(0x04000000), CupertinoColors.transparent],
    ),
  );

  // Colors used to paint a gradient at the start edge of the box it is
  // decorating.
  //
  // The first color in the list is used at the start of the gradient, which
  // is located at the start edge of the decorated box.
  //
  // If this is null, no shadow is drawn.
  //
  // The list must have at least two colors in it (otherwise it would not be a
  // gradient).
  final List<Color>? _colors;

  // Linearly interpolate between two edge shadow decorations decorations.
  //
  // The `t` argument represents position on the timeline, with 0.0 meaning
  // that the interpolation has not started, returning `a` (or something
  // equivalent to `a`), 1.0 meaning that the interpolation has finished,
  // returning `b` (or something equivalent to `b`), and values in between
  // meaning that the interpolation is at the relevant point on the timeline
  // between `a` and `b`. The interpolation can be extrapolated beyond 0.0 and
  // 1.0, so negative values and values greater than 1.0 are valid (and can
  // easily be generated by curves such as [Curves.elasticInOut]).
  //
  // Values for `t` are usually obtained from an [Animation<double>], such as
  // an [AnimationController].
  //
  // See also:
  //
  //  * [Decoration.lerp].
  static _CupertinoEdgeShadowDecoration? lerp(
    _CupertinoEdgeShadowDecoration? a,
    _CupertinoEdgeShadowDecoration? b,
    double t,
  ) {
    if (identical(a, b)) {
      return a;
    }
    if (a == null) {
      return b!._colors == null
          ? b
          : _CupertinoEdgeShadowDecoration._(
            b._colors!.map<Color>((Color color) => Color.lerp(null, color, t)!).toList(),
          );
    }
    if (b == null) {
      return a._colors == null
          ? a
          : _CupertinoEdgeShadowDecoration._(
            a._colors.map<Color>((Color color) => Color.lerp(null, color, 1.0 - t)!).toList(),
          );
    }
    assert(b._colors != null || a._colors != null);
    // If it ever becomes necessary, we could allow decorations with different
    // length' here, similarly to how it is handled in [LinearGradient.lerp].
    assert(b._colors == null || a._colors == null || a._colors.length == b._colors.length);
    return _CupertinoEdgeShadowDecoration._(<Color>[
      for (int i = 0; i < b._colors!.length; i += 1) Color.lerp(a._colors?[i], b._colors[i], t)!,
    ]);
  }

  @override
  _CupertinoEdgeShadowDecoration lerpFrom(Decoration? a, double t) {
    if (a is _CupertinoEdgeShadowDecoration) {
      return _CupertinoEdgeShadowDecoration.lerp(a, this, t)!;
    }
    return _CupertinoEdgeShadowDecoration.lerp(null, this, t)!;
  }

  @override
  _CupertinoEdgeShadowDecoration lerpTo(Decoration? b, double t) {
    if (b is _CupertinoEdgeShadowDecoration) {
      return _CupertinoEdgeShadowDecoration.lerp(this, b, t)!;
    }
    return _CupertinoEdgeShadowDecoration.lerp(this, null, t)!;
  }

  @override
  _CupertinoEdgeShadowPainter createBoxPainter([VoidCallback? onChanged]) {
    return _CupertinoEdgeShadowPainter(this, onChanged);
  }

  @override
  bool operator ==(Object other) {
    if (other.runtimeType != runtimeType) {
      return false;
    }
    return other is _CupertinoEdgeShadowDecoration && other._colors == _colors;
  }

  @override
  int get hashCode => _colors.hashCode;

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties.add(IterableProperty<Color>('colors', _colors));
  }
}

/// A [BoxPainter] used to draw the page transition shadow using gradients.
class _CupertinoEdgeShadowPainter extends BoxPainter {
  _CupertinoEdgeShadowPainter(this._decoration, super.onChanged)
    : assert(_decoration._colors == null || _decoration._colors.length > 1);

  final _CupertinoEdgeShadowDecoration _decoration;

  @override
  void paint(Canvas canvas, Offset offset, ImageConfiguration configuration) {
    final List<Color>? colors = _decoration._colors;
    if (colors == null) {
      return;
    }

    // The following code simulates drawing a [LinearGradient] configured as
    // follows:
    //
    // LinearGradient(
    //   begin: AlignmentDirectional(0.90, 0.0), // Spans 5% of the page.
    //   colors: _decoration._colors,
    // )
    //
    // A performance evaluation on Feb 8, 2021 showed, that drawing the gradient
    // manually as implemented below is more performant than relying on
    // [LinearGradient.createShader] because compiling that shader takes a long
    // time. On an iPhone XR, the implementation below reduced the worst frame
    // time for a cupertino page transition of a newly installed app from ~95ms
    // down to ~30ms, mainly because there's no longer a need to compile a
    // shader for the LinearGradient.
    //
    // The implementation below divides the width of the shadow into multiple
    // bands of equal width, one for each color interval defined by
    // `_decoration._colors`. Band x is filled with a gradient going from
    // `_decoration._colors[x]` to `_decoration._colors[x + 1]` by drawing a
    // bunch of 1px wide rects. The rects change their color by lerping between
    // the two colors that define the interval of the band.

    // Shadow spans 5% of the page.
    final double shadowWidth = 0.05 * configuration.size!.width;
    final double shadowHeight = configuration.size!.height;
    final double bandWidth = shadowWidth / (colors.length - 1);

    final TextDirection? textDirection = configuration.textDirection;
    assert(textDirection != null);
    final (double shadowDirection, double start) = switch (textDirection!) {
      TextDirection.rtl => (1, offset.dx + configuration.size!.width),
      TextDirection.ltr => (-1, offset.dx),
    };

    int bandColorIndex = 0;
    for (int dx = 0; dx < shadowWidth; dx += 1) {
      if (dx ~/ bandWidth != bandColorIndex) {
        bandColorIndex += 1;
      }
      final Paint paint =
          Paint()
            ..color =
                Color.lerp(
                  colors[bandColorIndex],
                  colors[bandColorIndex + 1],
                  (dx % bandWidth) / bandWidth,
                )!;
      final double x = start + shadowDirection * dx;
      canvas.drawRect(Rect.fromLTWH(x - 1.0, offset.dy, 1.0, shadowHeight), paint);
    }
  }
}

// The stiffness used by dialogs and action sheets.
//
// The stiffness value is obtained by examining the properties of
// `CASpringAnimation` in Xcode. The damping value is derived similarly, with
// additional precision calculated based on `_kStandardStiffness` to ensure a
// damping ratio of 1 (critically damped): damping = 2 * sqrt(stiffness)
const double _kStandardStiffness = 522.35;
const double _kStandardDamping = 45.7099552;
const SpringDescription _kStandardSpring = SpringDescription(
  mass: 1,
  stiffness: _kStandardStiffness,
  damping: _kStandardDamping,
);
// The iOS spring animation duration is 0.404 seconds, based on the properties
// of `CASpringAnimation` in Xcode. At this point, the spring's position
// `x(0.404)` is approximately 0.9990000, suggesting that iOS uses a position
// tolerance of 1e-3 (matching the default `_epsilonDefault` value).
//
// However, the spring's velocity `dx(0.404)` is about 0.02, indicating that iOS
// may not consider velocity when determining the animation's end condition. To
// account for this, a larger velocity tolerance is applied here for added
// safety.
const Tolerance _kStandardTolerance = Tolerance(velocity: 0.03);

/// A route that shows a modal iOS-style popup that slides up from the
/// bottom of the screen.
///
/// Such a popup is an alternative to a menu or a dialog and prevents the user
/// from interacting with the rest of the app.
///
/// It is used internally by [showCupertinoModalPopup] or can be directly pushed
/// onto the [Navigator] stack to enable state restoration. See
/// [showCupertinoModalPopup] for a state restoration app example.
///
/// The `barrierColor` argument determines the [Color] of the barrier underneath
/// the popup. When unspecified, the barrier color defaults to a light opacity
/// black scrim based on iOS's dialog screens. To correctly have iOS resolve
/// to the appropriate modal colors, pass in
/// `CupertinoDynamicColor.resolve(kCupertinoModalBarrierColor, context)`.
///
/// The `barrierDismissible` argument determines whether clicking outside the
/// popup results in dismissal. It is `true` by default.
///
/// The `semanticsDismissible` argument is used to determine whether the
/// semantics of the modal barrier are included in the semantics tree.
///
/// The `routeSettings` argument is used to provide [RouteSettings] to the
/// created Route.
///
/// {@macro flutter.widgets.RawDialogRoute}
///
/// See also:
///
///  * [DisplayFeatureSubScreen], which documents the specifics of how
///    [DisplayFeature]s can split the screen into sub-screens.
///  * [CupertinoActionSheet], which is the widget usually returned by the
///    `builder` argument.
///  * <https://developer.apple.com/design/human-interface-guidelines/ios/views/action-sheets/>
class CupertinoModalPopupRoute<T> extends PopupRoute<T> {
  /// A route that shows a modal iOS-style popup that slides up from the
  /// bottom of the screen.
  CupertinoModalPopupRoute({
    required this.builder,
    this.barrierLabel = 'Dismiss',
    this.barrierColor = kCupertinoModalBarrierColor,
    bool barrierDismissible = true,
    bool semanticsDismissible = false,
    super.filter,
    super.settings,
    super.requestFocus,
    this.anchorPoint,
  }) : _barrierDismissible = barrierDismissible,
       _semanticsDismissible = semanticsDismissible;

  /// A builder that builds the widget tree for the [CupertinoModalPopupRoute].
  ///
  /// The [builder] argument typically builds a [CupertinoActionSheet] widget.
  ///
  /// Content below the widget is dimmed with a [ModalBarrier]. The widget built
  /// by the [builder] does not share a context with the route it was originally
  /// built from. Use a [StatefulBuilder] or a custom [StatefulWidget] if the
  /// widget needs to update dynamically.
  final WidgetBuilder builder;

  final bool _barrierDismissible;

  final bool _semanticsDismissible;

  @override
  final String barrierLabel;

  @override
  final Color? barrierColor;

  @override
  bool get barrierDismissible => _barrierDismissible;

  @override
  bool get semanticsDismissible => _semanticsDismissible;

  @override
  Duration get transitionDuration => _kModalPopupTransitionDuration;

  /// {@macro flutter.widgets.DisplayFeatureSubScreen.anchorPoint}
  final Offset? anchorPoint;

  @override
  Simulation createSimulation({required bool forward}) {
    assert(!debugTransitionCompleted(), 'Cannot reuse a $runtimeType after disposing it.');
    final double end = forward ? 1.0 : 0.0;
    return SpringSimulation(
      _kStandardSpring,
      controller!.value,
      end,
      0,
      tolerance: _kStandardTolerance,
      snapToEnd: true,
    );
  }

  @override
  Widget buildPage(
    BuildContext context,
    Animation<double> animation,
    Animation<double> secondaryAnimation,
  ) {
    return CupertinoUserInterfaceLevel(
      data: CupertinoUserInterfaceLevelData.elevated,
      child: DisplayFeatureSubScreen(anchorPoint: anchorPoint, child: Builder(builder: builder)),
    );
  }

  @override
  Widget buildTransitions(
    BuildContext context,
    Animation<double> animation,
    Animation<double> secondaryAnimation,
    Widget child,
  ) {
    return Align(
      alignment: Alignment.bottomCenter,
      child: FractionalTranslation(translation: _offsetTween.evaluate(animation), child: child),
    );
  }

  static final Tween<Offset> _offsetTween = Tween<Offset>(
    begin: const Offset(0.0, 1.0),
    end: Offset.zero,
  );
}

/// Shows a modal iOS-style popup that slides up from the bottom of the screen.
///
/// Such a popup is an alternative to a menu or a dialog and prevents the user
/// from interacting with the rest of the app.
///
/// The `context` argument is used to look up the [Navigator] for the popup.
/// It is only used when the method is called. Its corresponding widget can be
/// safely removed from the tree before the popup is closed.
///
/// The `barrierColor` argument determines the [Color] of the barrier underneath
/// the popup. When unspecified, the barrier color defaults to a light opacity
/// black scrim based on iOS's dialog screens.
///
/// The `barrierDismissible` argument determines whether clicking outside the
/// popup results in dismissal. It is `true` by default.
///
/// The `useRootNavigator` argument is used to determine whether to push the
/// popup to the [Navigator] furthest from or nearest to the given `context`. It
/// is `true` by default.
///
/// The `semanticsDismissible` argument is used to determine whether the
/// semantics of the modal barrier are included in the semantics tree.
///
/// The `routeSettings` argument is used to provide [RouteSettings] to the
/// created Route.
///
/// The `builder` argument typically builds a [CupertinoActionSheet] widget.
/// Content below the widget is dimmed with a [ModalBarrier]. The widget built
/// by the `builder` does not share a context with the location that
/// [showCupertinoModalPopup] is originally called from. Use a
/// [StatefulBuilder] or a custom [StatefulWidget] if the widget needs to
/// update dynamically.
///
/// {@macro flutter.widgets.RawDialogRoute}
///
/// Returns a `Future` that resolves to the value that was passed to
/// [Navigator.pop] when the popup was closed.
///
/// ### State Restoration in Modals
///
/// Using this method will not enable state restoration for the modal. In order
/// to enable state restoration for a modal, use [Navigator.restorablePush]
/// or [Navigator.restorablePushNamed] with [CupertinoModalPopupRoute].
///
/// For more information about state restoration, see [RestorationManager].
///
/// {@tool dartpad}
/// This sample demonstrates how to create a restorable Cupertino modal route.
/// This is accomplished by enabling state restoration by specifying
/// [CupertinoApp.restorationScopeId] and using [Navigator.restorablePush] to
/// push [CupertinoModalPopupRoute] when the [CupertinoButton] is tapped.
///
/// {@macro flutter.widgets.RestorationManager}
///
/// ** See code in examples/api/lib/cupertino/route/show_cupertino_modal_popup.0.dart **
/// {@end-tool}
///
/// See also:
///
///  * [DisplayFeatureSubScreen], which documents the specifics of how
///    [DisplayFeature]s can split the screen into sub-screens.
///  * [CupertinoActionSheet], which is the widget usually returned by the
///    `builder` argument to [showCupertinoModalPopup].
///  * <https://developer.apple.com/design/human-interface-guidelines/ios/views/action-sheets/>
Future<T?> showCupertinoModalPopup<T>({
  required BuildContext context,
  required WidgetBuilder builder,
  ImageFilter? filter,
  Color barrierColor = kCupertinoModalBarrierColor,
  bool barrierDismissible = true,
  bool useRootNavigator = true,
  bool semanticsDismissible = false,
  RouteSettings? routeSettings,
  Offset? anchorPoint,
}) {
  return Navigator.of(context, rootNavigator: useRootNavigator).push(
    CupertinoModalPopupRoute<T>(
      builder: builder,
      filter: filter,
      barrierColor: CupertinoDynamicColor.resolve(barrierColor, context),
      barrierDismissible: barrierDismissible,
      semanticsDismissible: semanticsDismissible,
      settings: routeSettings,
      anchorPoint: anchorPoint,
    ),
  );
}

Widget _buildCupertinoDialogTransitions(
  BuildContext context,
  Animation<double> animation,
  Animation<double> secondaryAnimation,
  Widget child,
) {
  return child;
}

/// Displays an iOS-style dialog above the current contents of the app, with
/// iOS-style entrance and exit animations, modal barrier color, and modal
/// barrier behavior (by default, the dialog is not dismissible with a tap on
/// the barrier).
///
/// This function takes a `builder` which typically builds a [CupertinoAlertDialog]
/// widget. Content below the dialog is dimmed with a [ModalBarrier]. The widget
/// returned by the `builder` does not share a context with the location that
/// [showCupertinoDialog] is originally called from. Use a [StatefulBuilder] or
/// a custom [StatefulWidget] if the dialog needs to update dynamically.
///
/// The `context` argument is used to look up the [Navigator] for the dialog.
/// It is only used when the method is called. Its corresponding widget can
/// be safely removed from the tree before the dialog is closed.
///
/// The `useRootNavigator` argument is used to determine whether to push the
/// dialog to the [Navigator] furthest from or nearest to the given `context`.
/// By default, `useRootNavigator` is `true` and the dialog route created by
/// this method is pushed to the root navigator.
///
/// {@macro flutter.widgets.RawDialogRoute}
///
/// If the application has multiple [Navigator] objects, it may be necessary to
/// call `Navigator.of(context, rootNavigator: true).pop(result)` to close the
/// dialog rather than just `Navigator.pop(context, result)`.
///
/// Returns a [Future] that resolves to the value (if any) that was passed to
/// [Navigator.pop] when the dialog was closed.
///
/// ### State Restoration in Dialogs
///
/// Using this method will not enable state restoration for the dialog. In order
/// to enable state restoration for a dialog, use [Navigator.restorablePush]
/// or [Navigator.restorablePushNamed] with [CupertinoDialogRoute].
///
/// For more information about state restoration, see [RestorationManager].
///
/// {@tool dartpad}
/// This sample demonstrates how to create a restorable Cupertino dialog. This is
/// accomplished by enabling state restoration by specifying
/// [CupertinoApp.restorationScopeId] and using [Navigator.restorablePush] to
/// push [CupertinoDialogRoute] when the [CupertinoButton] is tapped.
///
/// {@macro flutter.widgets.RestorationManager}
///
/// ** See code in examples/api/lib/cupertino/route/show_cupertino_dialog.0.dart **
/// {@end-tool}
///
/// See also:
///
///  * [CupertinoAlertDialog], an iOS-style alert dialog.
///  * [showDialog], which displays a Material-style dialog.
///  * [showGeneralDialog], which allows for customization of the dialog popup.
///  * [DisplayFeatureSubScreen], which documents the specifics of how
///    [DisplayFeature]s can split the screen into sub-screens.
///  * <https://developer.apple.com/design/human-interface-guidelines/alerts/>
Future<T?> showCupertinoDialog<T>({
  required BuildContext context,
  required WidgetBuilder builder,
  String? barrierLabel,
  bool useRootNavigator = true,
  bool barrierDismissible = false,
  RouteSettings? routeSettings,
  Offset? anchorPoint,
}) {
  return Navigator.of(context, rootNavigator: useRootNavigator).push<T>(
    CupertinoDialogRoute<T>(
      builder: builder,
      context: context,
      barrierDismissible: barrierDismissible,
      barrierLabel: barrierLabel,
      barrierColor: CupertinoDynamicColor.resolve(kCupertinoModalBarrierColor, context),
      settings: routeSettings,
      anchorPoint: anchorPoint,
    ),
  );
}

/// A dialog route that shows an iOS-style dialog.
///
/// It is used internally by [showCupertinoDialog] or can be directly pushed
/// onto the [Navigator] stack to enable state restoration. See
/// [showCupertinoDialog] for a state restoration app example.
///
/// This function takes a `builder` which typically builds a [Dialog] widget.
/// Content below the dialog is dimmed with a [ModalBarrier]. The widget
/// returned by the `builder` does not share a context with the location that
/// `showDialog` is originally called from. Use a [StatefulBuilder] or a
/// custom [StatefulWidget] if the dialog needs to update dynamically.
///
/// The `context` argument is used to look up
/// [CupertinoLocalizations.modalBarrierDismissLabel], which provides the
/// modal with a localized accessibility label that will be used for the
/// modal's barrier. However, a custom `barrierLabel` can be passed in as well.
///
/// The `barrierDismissible` argument is used to indicate whether tapping on the
/// barrier will dismiss the dialog. It is `true` by default and cannot be `null`.
///
/// The `barrierColor` argument is used to specify the color of the modal
/// barrier that darkens everything below the dialog. If `null`, then
/// [CupertinoDynamicColor.resolve] is used to compute the modal color.
///
/// The `settings` argument define the settings for this route. See
/// [RouteSettings] for details.
///
/// {@macro flutter.widgets.RawDialogRoute}
///
/// See also:
///
///  * [showCupertinoDialog], which is a way to display
///     an iOS-style dialog.
///  * [showGeneralDialog], which allows for customization of the dialog popup.
///  * [showDialog], which displays a Material dialog.
///  * [DisplayFeatureSubScreen], which documents the specifics of how
///    [DisplayFeature]s can split the screen into sub-screens.
class CupertinoDialogRoute<T> extends RawDialogRoute<T> {
  /// A dialog route that shows an iOS-style dialog.
  CupertinoDialogRoute({
    required WidgetBuilder builder,
    required BuildContext context,
    super.barrierDismissible,
    Color? barrierColor,
    String? barrierLabel,
    // This transition duration was eyeballed comparing with iOS
    super.transitionDuration = const Duration(milliseconds: 250),
    this.transitionBuilder,
    super.settings,
    super.requestFocus,
    super.anchorPoint,
  }) : super(
         pageBuilder: (
           BuildContext context,
           Animation<double> animation,
           Animation<double> secondaryAnimation,
         ) {
           return builder(context);
         },
         transitionBuilder: transitionBuilder ?? _buildCupertinoDialogTransitions,
         barrierLabel: barrierLabel ?? CupertinoLocalizations.of(context).modalBarrierDismissLabel,
         barrierColor:
             barrierColor ?? CupertinoDynamicColor.resolve(kCupertinoModalBarrierColor, context),
       );

  /// Custom transition builder
  RouteTransitionsBuilder? transitionBuilder;

  CurvedAnimation? _fadeAnimation;

  @override
  Simulation createSimulation({required bool forward}) {
    assert(!debugTransitionCompleted(), 'Cannot reuse a $runtimeType after disposing it.');
    final double end = forward ? 1.0 : 0.0;
    return SpringSimulation(
      _kStandardSpring,
      controller!.value,
      end,
      0,
      tolerance: _kStandardTolerance,
      snapToEnd: true,
    );
  }

  @override
  Widget buildTransitions(
    BuildContext context,
    Animation<double> animation,
    Animation<double> secondaryAnimation,
    Widget child,
  ) {
    if (transitionBuilder != null) {
      return super.buildTransitions(context, animation, secondaryAnimation, child);
    }

    if (animation.status == AnimationStatus.reverse) {
      return FadeTransition(opacity: animation, child: child);
    }
    return FadeTransition(
      opacity: animation,
      child: ScaleTransition(scale: animation.drive(_dialogScaleTween), child: child),
    );
  }

  @override
  void dispose() {
    _fadeAnimation?.dispose();
    super.dispose();
  }

  // The curve and initial scale values were mostly eyeballed from iOS, however
  // they reuse the same animation curve that was modeled after native page
  // transitions.
  static final Tween<double> _dialogScaleTween = Tween<double>(begin: 1.3, end: 1.0);
}


Instructions for the chapter (Generate content in English unless specified otherwise):
- Start with a clear heading (e.g., `# Chapter 7: CupertinoFullscreenDialogTransition
`). Use the provided concept name.

- If this is not the first chapter, begin with a brief transition from the previous chapter, referencing it with a proper Markdown link using its name.

- Begin with a high-level motivation explaining what problem this abstraction solves. Start with a central use case as a concrete example. The whole chapter should guide the reader to understand how to solve this use case. Make it very minimal and friendly to beginners.

- If the abstraction is complex, break it down into key concepts. Explain each concept one-by-one in a very beginner-friendly way.

- Explain how to use this abstraction to solve the use case. Give example inputs and outputs for code snippets (if the output isn't values, describe at a high level what will happen).

- Each code block should be BELOW 10 lines! If longer code blocks are needed, break them down into smaller pieces and walk through them one-by-one. Aggresively simplify the code to make it minimal. Use comments to skip non-important implementation details. Each code block should have a beginner friendly explanation right after it.

- Describe the internal implementation to help understand what's under the hood. First provide a non-code or code-light walkthrough on what happens step-by-step when the abstraction is called. It's recommended to use a simple sequenceDiagram with a dummy example - keep it minimal with at most 5 participants to ensure clarity. If participant name has space, use: `participant QP as Query Processing`. .

- Then dive deeper into code for the internal implementation with references to files. Provide example code blocks, but make them similarly simple and beginner-friendly. Explain.

- IMPORTANT: When you need to refer to other core abstractions covered in other chapters, ALWAYS use proper Markdown links like this: [Chapter Title](filename.md). Use the Complete Tutorial Structure above to find the correct filename and the chapter title. Translate the surrounding text.

- Use mermaid diagrams to illustrate complex concepts (```mermaid``` format). .

- Heavily use analogies and examples throughout to help beginners understand.

- End the chapter with a brief conclusion that summarizes what was learned and provides a transition to the next chapter. If there is a next chapter, use a proper Markdown link: [Next Chapter Title](next_chapter_filename).

- Ensure the tone is welcoming and easy for a newcomer to understand.

- Output *only* the Markdown content for this chapter.

Now, directly provide a super beginner-friendly Markdown output (DON'T need ```markdown``` tags):

2025-05-21 12:33:05,489 - INFO - RESPONSE: # Chapter 7: CupertinoFullscreenDialogTransition

Welcome back, navigators! In [Chapter 6: CupertinoPageTransition](06_cupertinopagetransition_.md), we explored `CupertinoPageTransition`, the widget that creates the standard iOS slide-from-the-right animation for regular pages. But what about different types of screens that pop up?

On iOS, when you add a new event in the Calendar app or compose a new email, a screen often slides up from the *bottom* of the screen, taking over the whole view. This is often called a "fullscreen dialog" or "modal presentation style." This animation is different from the regular horizontal slide.

This is where `CupertinoFullscreenDialogTransition` comes in!

### What is CupertinoFullscreenDialogTransition?

`CupertinoFullscreenDialogTransition` is another special widget, similar to `CupertinoPageTransition`, but specifically designed to create the visual effect for these **fullscreen dialogs that animate up from the bottom** in the Cupertino (iOS) style.

It doesn't show its own content. Instead, it takes the widget for your fullscreen dialog screen and applies that specific bottom-up animation and other potential visual effects like making the previous screen slightly darker.

Here's what it does:

*   It makes the new fullscreen dialog screen (`child` widget) slide in from the bottom of the screen.
*   It makes the previous screen fade out slightly or adds a barrier color behind the new screen.
*   It uses the "animation" objects provided by the `PageRoute` to track the animation progress.

It's the visual performer for that distinct "modal" or "fullscreen dialog" presentation style used in many iOS apps. Like `CupertinoPageTransition`, it relies on a `PageRoute` (specifically one configured as a fullscreen dialog) and the `Navigator` to decide *when* to run the animation.

**Motivation:** We want to understand the specific widget used by Flutter's Cupertino library to create the bottom-up, fullscreen dialog animation seen in iOS apps. That widget is `CupertinoFullscreenDialogTransition`.

### How CupertinoFullscreenDialogTransition Works

Just like `CupertinoPageTransition`, you almost certainly won't build a `CupertinoFullscreenDialogTransition` widget yourself directly. It is created *internally* by the `CupertinoRouteTransitionMixin` (which, as we saw, is used by `CupertinoPageRoute`).

When you create a `CupertinoPageRoute` and set its `fullscreenDialog` property to `true`, you're telling the Navigator (and the Cupertino framework) that this is a special type of route that should use the fullscreen dialog animation.

The `CupertinoRouteTransitionMixin`'s `buildTransitions` method checks the `fullscreenDialog` property of the route it's building transitions for. If it's `true`, it creates a `CupertinoFullscreenDialogTransition` instead of a `CupertinoPageTransition`.

Let's revisit the simplified concept from the `CupertinoRouteTransitionMixin`'s `buildPageTransitions` logic:

```dart
// Simplified concept - from CupertinoRouteTransitionMixin's buildTransitions logic
// This code is inside the Flutter framework!
Widget buildPageTransitions(
  PageRoute<T> route, // The route being built
  BuildContext context,
  Animation<double> primaryAnimation, // Animation for the incoming page
  Animation<double> secondaryAnimation, // Animation for the outgoing page
  Widget child, // the NewScreen widget
) {
  // Decide if it's a fullscreen dialog or a regular page
  if (route.fullscreenDialog) {
    print("Building FULLSCREEN Dialog Transition!"); // Added for emphasis
    return CupertinoFullscreenDialogTransition( // <--- Uses this widget!
      primaryRouteAnimation: primaryAnimation, // Pass incoming animation
      secondaryRouteAnimation: secondaryAnimation, // Pass outgoing animation
      linearTransition: route.popGestureInProgress,
      child: child, // Wrap the NewScreen widget
    );
  } else {
    // For regular pages, use CupertinoPageTransition
    // ... create CupertinoPageTransition ...
  }
}
```

This fragment, part of the code in `packages/flutter/lib/src/cupertino/route.dart`, directly shows the decision point. If the `PageRoute` is a `fullscreenDialog`, the framework creates a `CupertinoFullscreenDialogTransition` widget and passes it the necessary animation objects and your screen's content (`child`).

### The Visual Magic (Sliding Up)

Inside `CupertinoFullscreenDialogTransition`, the actual visual effect is simpler than `CupertinoPageTransition`'s. It primarily uses a `SlideTransition` to make the new screen slide up from the bottom. It also handles the animation of the screen *being covered*, though the effect for fullscreen dialogs isn't the same parallax as a regular page slide.

Here's a simplified look at the core `build` method of `CupertinoFullscreenDialogTransition`:

```dart
// Simplified concept - from the build method inside CupertinoFullscreenDialogTransition
@override
Widget build(BuildContext context) {
  // Calculate slide for primary (incoming) page
  // based on primaryRouteAnimation (animating from bottom up)

  // Calculate slide for secondary (outgoing) page
  // based on secondaryRouteAnimation (it might slightly move or fade)

  return SlideTransition(
    position: _secondaryPositionAnimation, // Slightly moves/affects the outgoing page
    child: SlideTransition(
      position: _primaryPositionAnimation, // Slides the incoming page (your dialog)
      child: widget.child, // The actual screen content (your dialog widget)
    ),
  );
}
```

This structure is similar to `CupertinoPageTransition` but uses different `Tween`s (animations definitions) to control the direction and type of movement:

1.  The outermost `SlideTransition` uses `_secondaryPositionAnimation` (derived from `secondaryRouteAnimation`). For fullscreen dialogs, the effect on the previous page is usually just a subtle dimming or no movement, though the mixin provides the animation for potential use.
2.  The inner `SlideTransition` uses `_primaryPositionAnimation` (derived from `primaryRouteAnimation`) to slide the **incoming page** (`widget.child`) from off-screen *below* to the center of the screen. The `_kBottomUpTween` defined in `packages/flutter/lib/src/cupertino/route.dart` (which goes from `Offset(0.0, 1.0)` meaning bottom-off-screen to `Offset.zero` meaning on-screen) is used here.

```mermaid
graph TD
    A[Navigator] --> B[CupertinoPageRoute (fullscreenDialog: true)];
    B --> C[CupertinoRouteTransitionMixin]
    C --> D[buildTransitions checks fullscreenDialog: true]
    D --> E[Creates CupertinoFullscreenDialogTransition]
    E --> F{Build Method of CupertinoFullscreenDialogTransition};
    F --> G[Outer SlideTransition - Secondary Animation (Previous Page)];
    G --> H[Inner SlideTransition - Primary Animation (Slide Up)];
    H --> I[Your Dialog Widget];
```

So, `CupertinoFullscreenDialogTransition` uses `SlideTransition` (possibly nested) with animation values that cause the `child` widget to move from the bottom to the center of the screen, providing the standard iOS fullscreen dialog effect.

### You Don't Use It Directly

As emphasized before, you won't typically use `CupertinoFullscreenDialogTransition` directly in your application code. Its purpose is to be the visual engine for fullscreen dialogs when you use a `PageRoute` (like `CupertinoPageRoute`) configured with `fullscreenDialog: true`.

Understanding `CupertinoFullscreenDialogTransition` helps you recognize that the fullscreen dialog's bottom-up animation isn't just magic; it's built using standard Flutter animation widgets under the hood, controlled by the transition `Animation` objects.

### Conclusion

`CupertinoFullscreenDialogTransition` is a dedicated widget within the Cupertino library for achieving the distinct iOS fullscreen dialog animation, where the new screen slides up from the bottom. It works in conjunction with `CupertinoRouteTransitionMixin` and `PageRoute` objects configured with `fullscreenDialog: true` to apply this specific visual effect to your screen's content. While you don't use it directly, its existence explains the different animation style for these types of pop-ups in Cupertino-styled apps.

In the next chapter, we'll look at `CupertinoModalPopupRoute`, a specialized route for showing simpler modal popups from the bottom, like action sheets.

[Next Chapter: CupertinoModalPopupRoute](08_cupertinomodalpopuproute_.md)
2025-05-21 12:33:05,503 - INFO - PROMPT: 
Write a very beginner-friendly tutorial chapter (in Markdown format) for the project `flutter` about the concept: "CupertinoModalPopupRoute
". This is Chapter 8.

Concept Details:
- Name: CupertinoModalPopupRoute

- Description:
Imagine a smaller panel that pops up from the bottom of the screen to ask you something or present options, without covering the whole screen. This is what a `CupertinoModalPopupRoute` handles. It defines the behavior and appearance of these non-fullscreen, bottom-sliding pop-ups often used in iOS for action sheets and other temporary interfaces.


Complete Tutorial Structure:
1. [PageRoute
](01_pageroute_.md)
2. [MaterialPageRoute
](02_materialpageroute_.md)
3. [MaterialRouteTransitionMixin
](03_materialroutetransitionmixin_.md)
4. [CupertinoPageRoute
](04_cupertinopageroute_.md)
5. [CupertinoRouteTransitionMixin
](05_cupertinoroutetransitionmixin_.md)
6. [CupertinoPageTransition
](06_cupertinopagetransition_.md)
7. [CupertinoFullscreenDialogTransition
](07_cupertinofullscreendialogtransition_.md)
8. [CupertinoModalPopupRoute
](08_cupertinomodalpopuproute_.md)
9. [CupertinoDialogRoute
](09_cupertinodialogroute_.md)

Context from previous chapters:
# Chapter 1: PageRoute

Welcome to the first chapter of our Flutter navigation tutorial! Ever wonder how tapping a button in an app seamlessly takes you to a completely different screen? That's where the magic of navigation comes in! In Flutter, a core concept for managing these screen transitions is the `PageRoute`.

Imagine your Flutter app is like a building with many rooms (screens). When you want to go from one room (the "lobby") to another room (the "settings" screen), you need a plan or a map to get there. A `PageRoute` is exactly that – it's the blueprint, the plan, for a single "page" or screen in your app and how you would transition *to* it.

Think of it as defining:

*   **What the new screen looks like:** What widgets make up this new page?
*   **How the transition happens:** Does it slide from the side, fade in, or something else?
*   **How long the transition takes:** Is it a quick change or a smooth, longer one?
*   **Its behavior:** Can you easily "go back" or dismiss this screen?

The `PageRoute` doesn't *perform* the transition itself; it tells the `Navigator` (Flutter's system for managing screen stacks, like stacking rooms on top of each other) *how* to perform the transition to display its content.

### Our Goal: Showing a Simple New Screen

Throughout this chapter, our goal is to understand enough about `PageRoute` to accomplish a very common task: navigating from one simple screen to another.

Let's start with a basic example. We'll have a main screen with a button. When you tap the button, we want to go to a new, blank screen.

Here's a simplified look at what we might have initially:

```dart
import 'package:flutter/material.dart';

void main() {
  runApp(MyApp());
}

class MyApp extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return MaterialApp(
      home: HomeScreen(),
    );
  }
}

class HomeScreen extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(title: Text('Home Screen')),
      body: Center(
        child: ElevatedButton(
          onPressed: () {
            // We want to go to a new screen here!
          },
          child: Text('Go to New Screen'),
        ),
      ),
    );
  }
}

class NewScreen extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(title: Text('New Screen')),
      body: Center(
        child: Text('Welcome to the new screen!'),
      ),
    );
  }
}
```

In this code, we have `HomeScreen` and `NewScreen`. Our challenge is to connect the button on `HomeScreen` to show `NewScreen`. We need a `PageRoute` for `NewScreen`.

### Understanding PageRoute with PageRouteBuilder

Directly creating a raw `PageRoute` can be a bit advanced for our first step. Flutter provides a helpful class called `PageRouteBuilder` which lets us create a simple `PageRoute` using functions (callbacks). This is perfect for defining basic routes without creating a whole new class.

Let's look at how we can use `PageRouteBuilder` inside the `onPressed` of our `ElevatedButton`:

```dart
// ... inside HomeScreen onPressed ...
onPressed: () {
  Navigator.push(
    context,
    PageRouteBuilder( // Using PageRouteBuilder to define our route
      pageBuilder: (context, animation, secondaryAnimation) {
        // This function builds the actual screen content
        return NewScreen();
      },
      transitionsBuilder: (context, animation, secondaryAnimation, child) {
        // This function defines how the transition looks
        // For now, we'll do a simple fade transition as an example
        return FadeTransition(
          opacity: animation, // Controls the opacity of the new page
          child: child,
        );
      },
      transitionDuration: Duration(milliseconds: 500), // How long the transition takes
    ),
  );
},
// ... rest of HomeScreen ...
```

Let's break down what's happening here:

1.  **`Navigator.push(context, ...)`**: This is how we tell Flutter's navigation system to add a new screen on top of the current one. `context` tells the Navigator where we are in the widget tree.
2.  **`PageRouteBuilder(...)`**: We create an instance of `PageRouteBuilder` to define the characteristics of the new route.
3.  **`pageBuilder: (context, animation, secondaryAnimation) { return NewScreen(); }`**: This is a required function that `PageRouteBuilder` needs. It tells the builder *what* widget tree to display for this page. In our case, it's just our `NewScreen` widget. The `animation` and `secondaryAnimation` parameters are for transition animations, which we'll use in the next part.
4.  **`transitionsBuilder: (context, animation, secondaryAnimation, child) { ... }`**: This optional function defines how the transition *looks*. It takes the context, `animation` (for the incoming page), `secondaryAnimation` (for the outgoing page), and the `child` (which is the widget built by `pageBuilder`). We use a `FadeTransition` here, animating the `opacity` of the incoming page using the `animation` provided.
5.  **`transitionDuration: Duration(milliseconds: 500)`**: This sets how long the transition animation should take.

Now, when you tap the button, the `Navigator` will use this `PageRouteBuilder` to create a `PageRoute`, push it onto the navigation stack, and animate to the `NewScreen` using a 500ms fade effect.

### How it Works Under the Hood (Simplified)

Let's look at a slightly simplified view of what happens when you call `Navigator.push` with a `PageRoute`:

```mermaid
sequenceDiagram
    participant Button as Button Widget
    participant HomeScreen as HomeScreen Widget
    participant Navigator as Navigator
    participant PageRoute as PageRouteBuilder
    participant NewScreen as NewScreen Widget

    Button->HomeScreen: calls onPressed
    HomeScreen->Navigator: calls push(context, PageRoute)
    Navigator->PageRoute: asks for the page content and transitions
    PageRoute->PageRoute: uses pageBuilder to create NewScreen widget
    PageRoute->PageRoute: uses transitionsBuilder to wrap NewScreen with transition widgets
    Navigator->Navigator: Prepares
    Navigator->NewScreen: Builds and animates the transition
```

Essentially, the `Navigator` is like the conductor of an orchestra. You hand it a `PageRoute`, and it orchestrates the process of showing the new screen, including running the transitions defined by the `PageRoute`.

Inside the Flutter framework code for `PageRoute` (like in `packages/flutter/lib/src/widgets/pages.dart`), you'll find methods like `buildPage` and `buildTransitions`. These are the core parts that `PageRouteBuilder` uses its functions (`pageBuilder` and `transitionsBuilder`) to implement:

```dart
// Simplified example from PageRoute (similar to what PageRouteBuilder does internally)
abstract class PageRoute<T> extends ModalRoute<T> {
  // ... other properties ...

  // The PageRoute needs to know how to build the main content
  Widget buildPage(BuildContext context, Animation<double> animation, Animation<double> secondaryAnimation);

  // The PageRoute needs to know how to build the transitions
  Widget buildTransitions(BuildContext context, Animation<double> animation, Animation<double> secondaryAnimation, Widget child);

  // ... more methods for duration, color, etc. ...
}
```

`PageRouteBuilder` fills in these `buildPage` and `buildTransitions` methods using the functions you provide.

### Conclusion

In this chapter, we learned that a `PageRoute` is the fundamental concept in Flutter navigation that defines how a new screen is presented. We saw how to use `PageRouteBuilder` to create a simple `PageRoute` by specifying what the new screen looks like and how the transition should appear.

While `PageRouteBuilder` is great for simple custom transitions, Flutter provides pre-built `PageRoute` implementations for common design patterns, like the Material Design page transitions and the Cupertino (iOS) page transitions. These include standard animations and behaviors.

In the next chapter, we'll dive into one of these standard implementations: [MaterialPageRoute](02_materialpageroute_.md), which provides the familiar animations you see in Android apps.

[Next Chapter: MaterialPageRoute](02_materialpageroute_.md)
---
# Chapter 2: MaterialPageRoute

Welcome back! In [Chapter 1: PageRoute](01_pageroute_.md), we learned that a `PageRoute` is the blueprint for displaying a new screen and defining its transition. We saw how `PageRouteBuilder` let us create custom routes with animations.

Now, let's explore a really common and useful type of `PageRoute` used in Flutter apps that follow Google's Material Design: the `MaterialPageRoute`.

### What is MaterialPageRoute?

If you've ever used an Android phone, you've likely seen specific ways new screens appear when you tap something – often, they fade in and zoom slightly. `MaterialPageRoute` is designed to give you that native Android look and feel for your screen transitions, *automatically*.

Think of it as a pre-made `PageRoute` specifically built for Material Design. Instead of defining the fade/zoom transition yourself with `PageRouteBuilder`, `MaterialPageRoute` handles it for you.

But here's a cool trick: `MaterialPageRoute` is also platform-adaptive! This means that if you run your app on an iOS device, it will automatically use the standard iOS slide-from-the-right transition. You get the right native feel on both Android and iOS with just one `MaterialPageRoute`!

**Motivation:** We want to navigate from our `HomeScreen` to our `NewScreen` using the standard Material Design (Android-style) transitions on Android and the standard Cupertino (iOS-style) transitions on iOS, without manually building the transition animation ourselves.

### Using MaterialPageRoute

Using `MaterialPageRoute` is much simpler than `PageRouteBuilder` for standard transitions. You just need to tell it *what* screen to build.

Let's go back to our
`HomeScreen` button's `onPressed` and replace the `PageRouteBuilder` with a `MaterialPageRoute`:

```dart
// ... inside HomeScreen onPressed ...
onPressed: () {
  Navigator.push(
    context,
    MaterialPageRoute( // Using MaterialPageRoute!
      builder: (context) {
        // Just provide the widget for the new screen
        return NewScreen();
      },
    ),
  );
},
// ... rest of HomeScreen ...
```

That's it! Notice how much simpler it is?

*   We still use `Navigator.push` to initiate the navigation.
*   We create a `MaterialPageRoute` instance.
*   We provide a `builder` function, which is similar to `pageBuilder` in `PageRouteBuilder`. This function simply returns the widget for the new screen (`NewScreen`).
*   We *don't* need to specify a `transitionsBuilder` or `transitionDuration` explicitly. `MaterialPageRoute` uses default ones suitable for Material Design, chosen automatically based on the device's operating system.

Now, when you tap the button:
*   On an Android device, `NewScreen` will fade in and slightly zoom.
*   On an iOS device, `NewScreen` will slide in from the right.

### How it Works Under the Hood (Simplified)

When you use `MaterialPageRoute`, like with any `PageRoute`, you hand it to the `Navigator`.

```mermaid
sequenceDiagram
    participant Button as Button Widget
    participant HomeScreen as HomeScreen Widget
    participant Navigator as Navigator
    participant MaterialPageRoute as MaterialPageRoute
    participant NewScreen as NewScreen Widget
    participant Theme as Theme Data

    Button->HomeScreen: calls onPressed
    HomeScreen->Navigator: calls push(context, MaterialPageRoute)
    Navigator->MaterialPageRoute: asks for page content and transitions
    MaterialPageRoute->MaterialPageRoute: calls builder() to create NewScreen widget
    MaterialPageRoute->Theme: checks current platform (Android/iOS)
    MaterialPageRoute->MaterialPageRoute: selects relevant transition based on platform
    MaterialPageRoute->NewScreen: Builds and wraps with selected transition widgets
    Navigator->Navigator: Prepares
    Navigator->NewScreen: Animates the transition
```

The key difference from using `PageRouteBuilder` with a custom fade is that `MaterialPageRoute` internally checks the theme and the platform to pick the right animation blueprint.

Let's peek into the Flutter framework code for `MaterialPageRoute` in `packages/flutter/lib/src/material/page.dart`.

You'll see the `MaterialPageRoute` class definition inherits from `PageRoute` and also uses something called `MaterialRouteTransitionMixin` (we'll talk about mixins more later, but for now, think of it as sharing helpful code).

```dart
// Simplified from packages/flutter/lib/src/material/page.dart
class MaterialPageRoute<T> extends PageRoute<T> with MaterialRouteTransitionMixin<T> {
  // ... constructor and other properties ...

  /// Builds the primary contents of the route.
  final WidgetBuilder builder; // This holds the function you passed in!

  @override
  Widget buildContent(BuildContext context) => builder(context); // Uses your builder

  // ... other overrides ...
}
```

The `buildContent` method is where your `builder` function is called to create the `NewScreen` widget.

Where does the platform-adaptive transition logic come from? It's mostly handled by the `MaterialRouteTransitionMixin` and interacts with Flutter's `Theme` and `PageTransitionsTheme`.

```dart
// Simplified/conceptual example from MaterialRouteTransitionMixin
mixin MaterialRouteTransitionMixin<T> on PageRoute<T> {
  // ... other properties ...

  @override
  Widget buildTransitions( // This is where the transition is built!
    BuildContext context,
    Animation<double> animation,
    Animation<double> secondaryAnimation,
    Widget child, // This 'child' is the widget from buildContent (your NewScreen)
  ) {
    // Internally looks at Theme.of(context).platform (Android or iOS)
    // Then looks up the correct transition from Theme.of(context).pageTransitionsTheme
    // Returns the correct transition widget (like a FadeTransition for Android,
    // or a SlideTransition for iOS) wrapping the 'child' (your screen).
    final PageTransitionsTheme theme = Theme.of(context).pageTransitionsTheme;
    return theme.buildTransitions<T>(this, context, animation, secondaryAnimation, child);
  }

  // ... other properties like transitionDuration ...
}
```

So, `MaterialPageRoute` uses the `builder` you provide to show the content and relies on the `MaterialRouteTransitionMixin` (and Flutter's theming system) to automatically select and apply the right transition animation based on the device's platform.

### Conclusion

`MaterialPageRoute` is your go-to `PageRoute` when you want standard Material Design page transitions (fade/zoom on Android, slide on iOS) without needing to manually define the animations. It simplifies the process of creating new routes by providing sensible defaults that match platform conventions. It's a foundational component for navigation in many Flutter applications.

In the next chapter, we'll take a brief look at the `MaterialRouteTransitionMixin` itself, which is the piece that provides the magic platform-adaptive transitions for `MaterialPageRoute`.

[Next Chapter: MaterialRouteTransitionMixin](03_materialroutetransitionmixin_.md)
---
# Chapter 3: MaterialRouteTransitionMixin

Welcome back! In [Chapter 2: MaterialPageRoute](02_materialpageroute_.md), we learned how `MaterialPageRoute` gives us those sweet, platform-adaptive screen transitions (fade/zoom on Android, slide on iOS) without us having to code the animations ourselves.

We briefly saw that the code for `MaterialPageRoute` includes something called `with MaterialRouteTransitionMixin`. This chapter is about that `MaterialRouteTransitionMixin`.

### What is MaterialRouteTransitionMixin?

Imagine you have a recipe for delicious cookies. The recipe lists all the ingredients and the steps. A "mixin" in Flutter is like a list of extra ingredients and techniques you can add to your recipe to make it special.

`MaterialRouteTransitionMixin` is not a complete recipe (it's not a full `PageRoute` itself), but it's a collection of "ingredients" and "techniques" specifically for creating **Material Design page transitions** that adapt to the platform.

It provides the core logic for:

1.  **How long** the transition should take (duration).
2.  **How the animation looks** (the transition effect itself, like fading or sliding).
3.  **How this route interacts** with other routes during transitions (can they transition together smoothly?).

Essentially, `MaterialRouteTransitionMixin` is the helper that `MaterialPageRoute` uses to get its standard, platform-adaptive transition behavior. It's what makes `MaterialPageRoute` special!

You won't usually create a `MaterialRouteTransitionMixin` directly. Instead, you'll see other `PageRoute` implementations (like `MaterialPageRoute`) "mix it in" to gain its transition capabilities.

**Motivation:** Our goal is to understand where the automatic, platform-adaptive transition logic in `MaterialPageRoute` comes from. It comes from `MaterialRouteTransitionMixin`.

### How Mixins Work (Simply)

Think of a mixin as a way to share code between different classes without using traditional inheritance (like a child class inheriting from a parent class).

If you have `ClassA` and `MixinB`, `ClassA` can use `MixinB`'s methods and properties by saying `class ClassA with MixinB`. It's like `ClassA` is adding `MixinB`'s features to itself.

In our case, `MaterialPageRoute` is a class, and it uses `MaterialRouteTransitionMixin` like this:

```dart
// Simplified
class MaterialPageRoute<T> extends PageRoute<T> with MaterialRouteTransitionMixin<T> {
  // MaterialPageRoute now has access to the methods inside MaterialRouteTransitionMixin
  // ... rest of MaterialPageRoute code ...
}
```

By using `with MaterialRouteTransitionMixin`, `MaterialPageRoute` automatically gains the `buildTransitions` method and other transition-related logic defined within the mixin.

### How it Connects to Building Transitions

Remember in [Chapter 1: PageRoute](01_pageroute_.md), we saw that a `PageRoute` needs to implement a `buildTransitions` method to define how the animation looks?

`MaterialRouteTransitionMixin` provides the **implementation** for this crucial `buildTransitions` method for Material Design transitions.

When `Navigator.push` is called with a `MaterialPageRoute`, the Navigator asks the `MaterialPageRoute` (which uses `MaterialRouteTransitionMixin`'s logic) to build the transition widget tree.

Here's a look inside the mixin (simplified):

```dart
// Simplified/conceptual example from packages/flutter/lib/src/material/page.dart
mixin MaterialRouteTransitionMixin<T> on PageRoute<T> {
  // ... other properties like transitionDuration ...

  @override
  Widget buildTransitions( // This method is provided by the mixin!
    BuildContext context,
    Animation<double> animation, // Animation for the incoming page
    Animation<double> secondaryAnimation, // Animation for the outgoing page
    Widget child, // The actual content of the page (your NewScreen)
  ) {
    // Inside here, the mixin's code runs.
    // It checks the platform (Android/iOS) using Theme.of(context).platform.
    // It looks up the correct transition animation based on the platform
    // from the PageTransitionsTheme.
    // It returns the chosen animation widget (like FadeTransition or SlideTransition)
    // wrapping the 'child' (your NewScreen widget).

    // This line is the core – it asks the Theme for the right transition!
    final PageTransitionsTheme theme = Theme.of(context).pageTransitionsTheme;
    return theme.buildTransitions<T>(this, context, animation, secondaryAnimation, child);
  }

  // ... other methods ...
}
```

So, `MaterialRouteTransitionMixin` contains the `buildTransitions` method that looks at the current `Theme` (which knows the platform) and asks the `PageTransitionsTheme` within the `Theme` to provide the actual transition widget code.

This design is clever because:
*   `MaterialPageRoute` handles knowing *what* screen to show (`builder`).
*   `MaterialRouteTransitionMixin` handles knowing *how* to transition, querying the `Theme` for the platform-specific implementation.
*   The `PageTransitionsTheme` holds the actual animation builders (like the code for the fade/zoom or the slide animations).

This separation of concerns makes the code more organized and maintainable!

### You Don't Use It Directly (Usually)

As a beginner, you won't typically need to directly use `MaterialRouteTransitionMixin`. Its purpose is to provide the transition logic *to* classes like `MaterialPageRoute`. When you use `MaterialPageRoute`, you are indirectly benefiting from the code in `MaterialRouteTransitionMixin`.

Think of it like buying a car. You use the steering wheel and pedals (`MaterialPageRoute`), and the engine ("mixin") makes it go, but you don't interact directly with the engine parts every time you drive.

### Conclusion

`MaterialRouteTransitionMixin` is a key piece of the puzzle behind `MaterialPageRoute`'s automatic, platform-adaptive transitions. It provides the core logic for determining transition duration and building the correct transition animation based on the device's operating system by interacting with the Flutter `Theme` system. While you won't often use it directly, understanding its role helps clarify how `MaterialPageRoute` works.

In the next chapter, we'll shift our focus to the iOS side of things and introduce `CupertinoPageRoute`, which is the counterpart to `MaterialPageRoute` for Cupertino (iOS) design.

[Next Chapter: CupertinoPageRoute](04_cupertinopageroute_.md)
---
# Chapter 4: CupertinoPageRoute

Welcome back, future Flutter navigators! In [Chapter 3: MaterialRouteTransitionMixin](03_materialroutetransitionmixin_.md), we explored how `MaterialRouteTransitionMixin` is the helper that gives `MaterialPageRoute` its cool, platform-adaptive animations. Now, let's turn our attention to the world of Apple's iOS design with `CupertinoPageRoute`.

### What is CupertinoPageRoute?

If you've ever used an iPhone or iPad, you've seen specific ways new screens slide into view, often from the right side of the screen, and how they slide back out when you go back. `CupertinoPageRoute` is Flutter's way of giving you that exact native iOS look and feel for your screen transitions, automatically!

Just like `MaterialPageRoute` is a pre-made blueprint for Material Design transitions, `CupertinoPageRoute` is a pre-made blueprint specifically built for Cupertino (iOS) design. It handles the characteristic sliding animations and other iOS visual cues when you navigate between pages.

**Motivation:** Our goal is to navigate from our `HomeScreen` to our `NewScreen` using the standard iOS slide-from-the-right transition when running on an iOS device, in a way that is natural and expected for iOS users.

### Using CupertinoPageRoute

Using `CupertinoPageRoute` is very similar to using `MaterialPageRoute`. You simply tell it which widget represents the new screen.

Let's go back to our `HomeScreen` button's `onPressed` and replace the `MaterialPageRoute` with a `CupertinoPageRoute`:

```dart
import 'package:flutter/cupertino.dart'; // Import Cupertino widgets!
import 'package:flutter/material.dart'; // Still need Material for Scaffold, AppBar, etc.

// ... rest of MyApp and HomeScreen classes ...

class HomeScreen extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return Scaffold( // Using Material Scaffold for simplicity in this example
      appBar: AppBar(title: Text('Home Screen')),
      body: Center(
        child: ElevatedButton(
          onPressed: () {
            Navigator.push(
              context,
              CupertinoPageRoute( // Using CupertinoPageRoute!
                builder: (context) {
                  // Just provide the widget for the new screen
                  return NewScreen();
                },
              ),
            );
          },
          child: Text('Go to New Screen'),
        ),
      ),
    );
  }
}

// ... rest of NewScreen class ...
```

See the difference? We changed `MaterialPageRoute` to `CupertinoPageRoute` and made sure to import `flutter/cupertino.dart`.

Now, when you tap the button:

*   On an iOS device, `NewScreen` will smoothly slide in from the right, with the previous screen slightly moving to the left (a parallax effect). When you go back, it slides out to the right.
*   On an Android device, because we're using a `CupertinoPageRoute`, it will *still* try to use the Cupertino (iOS) style transition, even though it's running on Android. This is different from `MaterialPageRoute` which is platform-adaptive. If you want platform-adaptive behavior, `MaterialPageRoute` is often the better choice. `CupertinoPageRoute` is primarily for building apps that *always* have the iOS feel.

### How it Works Under the Hood (Simplified)

When you use `CupertinoPageRoute`, you hand it to the `Navigator` just like any other `PageRoute`.

```mermaid
sequenceDiagram
    participant Button as Button Widget
    participant HomeScreen as HomeScreen Widget
    participant Navigator as Navigator
    participant CupertinoPageRoute as CupertinoPageRoute
    participant NewScreen as NewScreen Widget
    participant iOS Theme as iOS Theme Data (Conceptual)

    Button->HomeScreen: calls onPressed
    HomeScreen->Navigator: calls push(context, CupertinoPageRoute)
    Navigator->CupertinoPageRoute: asks for page content and transitions
    CupertinoPageRoute->CupertinoPageRoute: calls builder() to create NewScreen widget
    CupertinoPageRoute->iOS Theme: Requests iOS-style transition details
    CupertinoPageRoute->CupertinoPageRoute: Uses transition logic from mixin
    CupertinoPageRoute->NewScreen: Builds and wraps with Cupertino transition widgets
    Navigator->Navigator: Prepares
    Navigator->NewScreen: Animates the transition (iOS style)
```

The process is very similar to `MaterialPageRoute`, but instead of checking the general platform to pick between Material and Cupertino, `CupertinoPageRoute` *always* uses the Cupertino style transition logic.

Let's peek into the Flutter framework code for `CupertinoPageRoute` in `packages/flutter/lib/src/cupertino/route.dart`.

You'll find the `CupertinoPageRoute` class definition inherits from `PageRoute` and, just like `MaterialPageRoute` uses a mixin for its transitions, `CupertinoPageRoute` uses something similar: `CupertinoRouteTransitionMixin`.

```dart
// Simplified from packages/flutter/lib/src/cupertino/route.dart
class CupertinoPageRoute<T> extends PageRoute<T> with CupertinoRouteTransitionMixin<T> {
  // ... constructor and other properties ...

  /// Builds the primary contents of the route.
  final WidgetBuilder builder; // This holds the function you passed in!

  @override
  Widget buildContent(BuildContext context) => builder(context); // Uses your builder

  // ... other overrides ...
}
```

Similar to `MaterialPageRoute`, `CupertinoPageRoute` takes your `builder` function and calls its `buildContent` method to create the widget for the new page.

The iOS-style transition magic (the sliding from the right, the parallax effect) comes from the `CupertinoRouteTransitionMixin` that is mixed into `CupertinoPageRoute`. This mixin implements the `buildTransitions` method using specific iOS animations:

```dart
// Simplified/conceptual example from CupertinoRouteTransitionMixin
mixin CupertinoRouteTransitionMixin<T> on PageRoute<T> {
  // ... other properties like transitionDuration ...

  @override
  Widget buildTransitions( // This method is provided by the mixin!
    BuildContext context,
    Animation<double> animation, // Animation for the incoming page
    Animation<double> secondaryAnimation, // Animation for the outgoing page
    Widget child, // The actual content of the page (your NewScreen)
  ) {
    // Inside here, the mixin's code runs.
    // It builds specific iOS transition widgets...
    // For normal pages, it uses CupertinoPageTransition.
    // For fullscreen dialogs, it uses CupertinoFullscreenDialogTransition.
    // It uses the animations (primaryRouteAnimation and secondaryRouteAnimation)
    // and wraps the 'child' (your NewScreen widget) with them.

    // A simplified call to the actual transition builder:
    return buildPageTransitions<T>(this, context, animation, secondaryAnimation, child);
  }

  // ... other methods ...
}
```

When the `Navigator` needs to show `CupertinoPageRoute`, it asks the route to `buildTransitions`. `CupertinoPageRoute` uses the `buildTransitions` method from `CupertinoRouteTransitionMixin`. This mixin then uses dedicated transition widgets like `CupertinoPageTransition` to create the visually distinct iOS sliding effect, using the provided `animation` objects to control the movement. We'll learn more about `CupertinoPageTransition` in a later chapter.

`CupertinoPageRoute` also has support for distinguishing between regular page transitions and fullscreen dialog transitions (like presenting a modal from the bottom on iOS), using different animation styles for each case, which is also handled by the `CupertinoRouteTransitionMixin`.

### Conclusion

`CupertinoPageRoute` is the specialized `PageRoute` for bringing the native iOS page transition experience (sliding from the right, parallax effect) to your Flutter apps, regardless of the actual device platform. It uses the `CupertinoRouteTransitionMixin` to manage the transition logic and apply the appropriate iOS-style animations. While `MaterialPageRoute` is usually preferred for platform-adaptive behavior in a single codebase, `CupertinoPageRoute` is perfect when you want a consistent iOS feel.

In the next chapter, we'll dive deeper into the `CupertinoRouteTransitionMixin` itself, similar to how we looked at its Material counterpart, to see exactly where this iOS transition magic comes from.

[Next Chapter: CupertinoRouteTransitionMixin](05_cupertinoroutetransitionmixin_.md)
---
# Chapter 5: CupertinoRouteTransitionMixin

Welcome back! In [Chapter 4: CupertinoPageRoute](04_cupertinopageroute_.md), we learned how `CupertinoPageRoute` helps us create iOS-style screen transitions automatically, giving our apps that native slide-from-the-right feel. We also briefly saw that `CupertinoPageRoute` uses something called `CupertinoRouteTransitionMixin` to get this behavior.

Now, it's time to shine a spotlight on the `CupertinoRouteTransitionMixin` itself!

### What is CupertinoRouteTransitionMixin?

Just like `MaterialRouteTransitionMixin` is the special recipe additive for Material Design transitions, `CupertinoRouteTransitionMixin` is the recipe additive for **Cupertino (iOS) page transitions**.

It's not a full `PageRoute` on its own, but it contains the vital instructions and ingredients needed to create the signature iOS sliding and fading animations for transitioning between screens.

Think of it as providing the "animation logic" that a `PageRoute` can use. Instead of writing the complex code to make a widget slide from the right and have the old page slightly move left (that parallax effect!), you can "mix in" `CupertinoRouteTransitionMixin` to automatically get that behavior.

It provides the core logic for:

1.  **How long** the transition takes (its duration).
2.  **How the animation fundamentally looks** (the sliding, the fading).
3.  **How it behaves** during interactive gestures, like swiping back from the edge of the screen on iOS.

`CupertinoPageRoute` itself uses `CupertinoRouteTransitionMixin` to implement its `buildTransitions` method, which is the core piece that tells the Navigator how to animate the new screen into view.

**Motivation:** We want to understand where the charming iOS sliding and parallax animations come from when we use `CupertinoPageRoute`. They come from `CupertinoRouteTransitionMixin`.

### How Mixins Work (A Quick Reminder)

As we talked about with `MaterialRouteTransitionMixin`, a mixin is a way to add a set of properties and methods from one class-like structure into another class, without needing traditional inheritance.

When a class `mixes in` a mixin, it gains all the public members of that mixin as if they were defined directly in the class itself.

`CupertinoPageRoute` uses `CupertinoRouteTransitionMixin` like this:

```dart
// Simplified from packages/flutter/lib/src/cupertino/route.dart
class CupertinoPageRoute<T> extends PageRoute<T> with CupertinoRouteTransitionMixin<T> {
  // CupertinoPageRoute now automatically has the buildTransitions method
  // and other properties defined in CupertinoRouteTransitionMixin
  // ... rest of CupertinoPageRoute code ...
}
```

This means `CupertinoPageRoute` doesn't have to write the `buildTransitions` code itself; it gets it "for free" by mixing in `CupertinoRouteTransitionMixin`.

### How it Connects to Building Transitions

The most important part that `CupertinoRouteTransitionMixin` provides is the implementation for the `buildTransitions` method that every `PageRoute` needs.

When you call `Navigator.push` with a `CupertinoPageRoute`, the Navigator needs to know how to animate the new page onto the screen. It calls the `buildTransitions` method of that `PageRoute`. Because `CupertinoPageRoute` mixed in `CupertinoRouteTransitionMixin`, it's actually the mixin's code that runs for `buildTransitions`.

Here's a look inside the mixin's `buildTransitions` method (simplified from the framework code):

```dart
// Simplified from packages/flutter/lib/src/cupertino/route.dart
mixin CupertinoRouteTransitionMixin<T> on PageRoute<T> {
  // ... other properties like transitionDuration ...

  @override
  Widget buildTransitions( // This method is provided by the mixin!
    BuildContext context,
    Animation<double> animation, // Animation for the incoming page
    Animation<double> secondaryAnimation, // Animation for the outgoing page
    Widget child, // The actual content of the page (your NewScreen)
  ) {
    // Inside here, the mixin's code figures out the right animation.
    // It uses specific transition widgets like CupertinoPageTransition
    // (or CupertinoFullscreenDialogTransition for dialogs).
    // It passes the 'child' (your new screen) and the 'animation' objects
    // to these transition widgets.

    // This line is the core – it calls dedicated builders for the transitions!
    return buildPageTransitions<T>(this, context, animation, secondaryAnimation, child);
  }

  // ... other methods ...
}
```

The `buildTransitions` method in `CupertinoRouteTransitionMixin` doesn't build the animation widget tree directly. Instead, it delegates that task to helper functions within the Cupertino library, specifically `buildPageTransitions`.

This `buildPageTransitions` helper method (which is part of the mixin's logic):

1.  Checks if this route is a normal page or a fullscreen dialog.
2.  Based on that, it chooses the correct transition widget.
    *   For normal pages, it picks `CupertinoPageTransition`.
    *   For fullscreen dialogs (like adding an event in the calendar), it picks `CupertinoFullscreenDialogTransition`.
3.  It creates an instance of the chosen transition widget, passing in:
    *   The `animation` for the incoming screen.
    *   The `secondaryAnimation` for the outgoing screen.
    *   Your actual screen widget (`child`).

So, the `CupertinoRouteTransitionMixin` acts as the orchestrator of the transition. It decides which specific animation widget to use and provides it with the necessary animation data.

Let's visualize this flow:

```mermaid
sequenceDiagram
    participant Navigator as Navigator
    participant CupertinoPageRoute as CupertinoPageRoute
    participant CRT_Mixin as CupertinoRouteTransitionMixin
    participant CPTransition as CupertinoPageTransition / CupertinoFullscreenDialogTransition
    participant NewScreen as NewScreen Widget

    Navigator->CupertinoPageRoute: calls buildTransitions(...)
    CupertinoPageRoute->CRT_Mixin: (delegates to mixin's method)
    CRT_Mixin->CRT_Mixin: calls buildPageTransitions(...)
    CRT_Mixin->CPTransition: creates CPTransition(...) with child and animations
    CPTransition->NewScreen: wraps NewScreen
    CRT_Mixin-->Navigator: returns CPTransition(NewScreen)
    Navigator->Navigator: Animates the transition using CPTransition
```

The `CupertinoPageTransition` and `CupertinoFullscreenDialogTransition` widgets are the ones that *actually perform* the visual animation (sliding the child widget using the provided animation values). We'll look at those in more detail in the next chapters!

### You Won't Necessarily Use It Directly

Similar to `MaterialRouteTransitionMixin`, you as a beginner app developer are typically not expected to directly use `CupertinoRouteTransitionMixin`. Its main purpose is to serve as a building block for other `PageRoute` types, most notably `CupertinoPageRoute`.

When you use `CupertinoPageRoute`, you automatically get the benefits of the transition logic contained within `CupertinoRouteTransitionMixin` without having to think about the mixin itself.

### Conclusion

`CupertinoRouteTransitionMixin` is the powerhouse behind `CupertinoPageRoute`'s native iOS transition animations. It provides the `buildTransitions` logic, deciding which specific Cupertino transition widget (`CupertinoPageTransition` or `CupertinoFullscreenDialogTransition`) to use based on the route type and giving it the necessary animation details to perform the visual effect. While you usually interact with `CupertinoPageRoute`, understanding that `CupertinoRouteTransitionMixin` provides the core animation recipe clarifies how these iOS-style transitions are achieved in Flutter.

In the next chapter, we'll focus on `CupertinoPageTransition`, the primary widget used by `CupertinoRouteTransitionMixin` to create the standard iOS page slide animation.

[Next Chapter: CupertinoPageTransition](06_cupertinopagetransition_.md)
---
# Chapter 6: CupertinoPageTransition

Welcome back! In [Chapter 5: CupertinoRouteTransitionMixin](05_cupertinoroutetransitionmixin_.md), we learned that `CupertinoRouteTransitionMixin` holds the recipe for creating those distinct iOS-style transition animations, and how `CupertinoPageRoute` uses this mixin. Now, let's focus on one of the key ingredients in that recipe: the `CupertinoPageTransition` widget itself.

### What is CupertinoPageTransition?

Imagine the screen of your iPhone. When you tap on an item in a list and a new screen slides into view from the right, that smooth animation is done by a special widget. In Flutter's Cupertino world, that special widget is `CupertinoPageTransition`.

`CupertinoPageTransition` is a widget that doesn't display its own content directly. Instead, it takes another widget (which is the new screen you want to show) and applies a specific animation and visual effect to it. It's the visual performer of the standard iOS page-to-page transitions.

Here's what it does:

*   It makes the new screen (`child` widget) slide in from the right.
*   It makes the original screen (the one being covered) slightly slide to the left, creating a cool "parallax" effect.
*   It might also add a subtle shadow effect on the edge of the incoming screen.
*   It uses the "animation" objects provided by the `PageRoute` to know how far along the transition is.

It's important to remember that `CupertinoPageTransition` is just the **visual effect** widget. It relies on a `PageRoute` (like `CupertinoPageRoute`) and the `Navigator` to decide *when* to run the animation and *what* pages to animate.

**Motivation:** We want to understand the actual widget that visually creates the distinct iOS sliding and parallax effect during a page transition. That widget is `CupertinoPageTransition`.

### How CupertinoPageTransition Works

You won't typically create a `CupertinoPageTransition` widget yourself directly in your app code for basic navigation. It is created *internally* by the `CupertinoRouteTransitionMixin` (which is used by `CupertinoPageRoute`).

Let's think about the information `CupertinoPageTransition` needs:

1.  **The content to animate:** This is the widget tree of the new screen you are navigating to. `CupertinoPageTransition` needs to wrap this content.
2.  **The animation progress for the incoming page:** An `Animation` object that typically goes from 0.0 (off-screen) to 1.0 (fully on-screen).
3.  **The animation progress for the outgoing page:** An `Animation` object that typically goes from 0.0 (fully on-screen) to 1.0 (off-screen to the left). This is used for the parallax effect.
4.  **Whether the transition is "linear":** This is used internally for tracking user gestures like swiping back, ensuring the animation follows the finger precisely.

The `CupertinoRouteTransitionMixin`'s `buildTransitions` method (which `CupertinoPageRoute` uses) is responsible for creating the `CupertinoPageTransition` widget and giving it these pieces of information.

Here's a simplified look at how `CupertinoPageRoute` (via its mixin) uses `CupertinoPageTransition`:

```dart
// Simplified concept - from CupertinoRouteTransitionMixin's buildTransitions logic
// This code is inside the Flutter framework, not your app!
Widget buildPageTransitions(
  PageRoute<T> route, // The route being built
  BuildContext context,
  Animation<double> primaryAnimation, // Animation for the new page
  Animation<double> secondaryAnimation, // Animation for the old page
  Widget child, // the NewScreen widget
) {
  // Decide if it's a fullscreen dialog or a regular page
  if (route.fullscreenDialog) {
    // Use a different transition for dialogs (more on this later)
    return CupertinoFullscreenDialogTransition(...);
  } else {
    // For regular pages, use CupertinoPageTransition!
    return CupertinoPageTransition(
      primaryRouteAnimation: primaryAnimation, // Pass incoming animation
      secondaryRouteAnimation: secondaryAnimation, // Pass outgoing animation
      linearTransition: route.popGestureInProgress, // Is a swipe back happening?
      child: child, // Wrap the NewScreen widget
    );
  }
}
```

This shows that `CupertinoPageTransition` is instantiated by the *framework* code that the `CupertinoRouteTransitionMixin` provides. It acts as a container for your `child` widget (`NewScreen` in our example) and applies the animations specified by `primaryRouteAnimation` and `secondaryRouteAnimation`.

### The Visual Magic

Inside `CupertinoPageTransition`, the actual visual effect is created using standard Flutter animation widgets, primarily `SlideTransition` and `DecoratedBoxTransition`.

Let's simplify the core `build` method of `CupertinoPageTransition`:

```dart
// Simplified concept - from the build method inside CupertinoPageTransition
@override
Widget build(BuildContext context) {
  // calculate slide for secondary (outgoing) page (parallax)
  // based on secondaryRouteAnimation

  // calculate slide for primary (incoming) page
  // based on primaryRouteAnimation

  // calculate shadow for primary (incoming) page
  // based on primaryRouteAnimation

  return SlideTransition(
    position: _secondaryPositionAnimation, // Moves the outgoing page
    child: SlideTransition(
      position: _primaryPositionAnimation, // Moves the incoming page
      child: DecoratedBoxTransition(
        decoration: _primaryShadowAnimation, // Adds edge shadow
        child: widget.child, // The actual screen content (NewScreen)
      ),
    ),
  );
}
```

This nested structure is key:

1.  The outermost `SlideTransition` uses `_secondaryPositionAnimation` (derived from `secondaryRouteAnimation`) to slightly slide the **outgoing page** (which is the `child` *of the inner* `SlideTransition`) to the left, creating the parallax effect.
2.  The inner `SlideTransition` uses `_primaryPositionAnimation` (derived from `primaryRouteAnimation`) to slide the **incoming page** (`widget.child`) from the right to the center.
3.  The `DecoratedBoxTransition` wraps the `widget.child` and applies a subtle gradient shadow effect on the leading edge as it slides in, using `_primaryShadowAnimation`.

```mermaid
graph TD
    A[Navigator] --> B[CupertinoPageRoute];
    B --> C[CupertinoRouteTransitionMixin]
    C --> D[buildTransitions calls buildPageTransitions]
    D --> E[Creates CupertinoPageTransition]
    E --> F{Build Method of CupertinoPageTransition};
    F --> G[Outer SlideTransition - Secondary Animation (Parallax)];
    G --> H[Inner SlideTransition - Primary Animation (Slide In)];
    H --> I[DecoratedBoxTransition - Edge Shadow];
    I --> J[Your NewScreen Widget];
```

So, `CupertinoPageTransition` stitches together several basic animation widgets (`SlideTransition`, `DecoratedBoxTransition`) using the `Animation` objects it receives to create the complete visual iOS page transition effect.

### You Still Don't Use It Directly (Mostly)

Just like `CupertinoRouteTransitionMixin`, you generally won't hand-craft a `CupertinoPageTransition` widget in your typical navigation code. When you use `CupertinoPageRoute`, the framework automatically creates and manages the `CupertinoPageTransition` for you.

Understanding `CupertinoPageTransition` helps you appreciate how the finished iOS-style transition is composed of multiple visual elements (sliding the new page, sliding the old page, adding a shadow) all orchestrated by the primary and secondary animation objects.

### Conclusion

`CupertinoPageTransition` is the concrete widget that implements the visual aspects of the standard iOS page transition, including sliding, parallax, and shadowing. It receives animation data from a `PageRoute` (like `CupertinoPageRoute` via its mixin) and uses built-in animation widgets to apply these effects to the new screen's content. While you don't usually need to use it directly, knowing it exists clarifies how Flutter achieves that native iOS navigation feel.

In the next chapter, we'll look at `CupertinoFullscreenDialogTransition`, a similar widget but used for the different animation style employed by iOS for fullscreen modal dialogs.

[Next Chapter: CupertinoFullscreenDialogTransition](07_cupertinofullscreendialogtransition_.md)
---
# Chapter 7: CupertinoFullscreenDialogTransition

Welcome back, navigators! In [Chapter 6: CupertinoPageTransition](06_cupertinopagetransition_.md), we explored `CupertinoPageTransition`, the widget that creates the standard iOS slide-from-the-right animation for regular pages. But what about different types of screens that pop up?

On iOS, when you add a new event in the Calendar app or compose a new email, a screen often slides up from the *bottom* of the screen, taking over the whole view. This is often called a "fullscreen dialog" or "modal presentation style." This animation is different from the regular horizontal slide.

This is where `CupertinoFullscreenDialogTransition` comes in!

### What is CupertinoFullscreenDialogTransition?

`CupertinoFullscreenDialogTransition` is another special widget, similar to `CupertinoPageTransition`, but specifically designed to create the visual effect for these **fullscreen dialogs that animate up from the bottom** in the Cupertino (iOS) style.

It doesn't show its own content. Instead, it takes the widget for your fullscreen dialog screen and applies that specific bottom-up animation and other potential visual effects like making the previous screen slightly darker.

Here's what it does:

*   It makes the new fullscreen dialog screen (`child` widget) slide in from the bottom of the screen.
*   It makes the previous screen fade out slightly or adds a barrier color behind the new screen.
*   It uses the "animation" objects provided by the `PageRoute` to track the animation progress.

It's the visual performer for that distinct "modal" or "fullscreen dialog" presentation style used in many iOS apps. Like `CupertinoPageTransition`, it relies on a `PageRoute` (specifically one configured as a fullscreen dialog) and the `Navigator` to decide *when* to run the animation.

**Motivation:** We want to understand the specific widget used by Flutter's Cupertino library to create the bottom-up, fullscreen dialog animation seen in iOS apps. That widget is `CupertinoFullscreenDialogTransition`.

### How CupertinoFullscreenDialogTransition Works

Just like `CupertinoPageTransition`, you almost certainly won't build a `CupertinoFullscreenDialogTransition` widget yourself directly. It is created *internally* by the `CupertinoRouteTransitionMixin` (which, as we saw, is used by `CupertinoPageRoute`).

When you create a `CupertinoPageRoute` and set its `fullscreenDialog` property to `true`, you're telling the Navigator (and the Cupertino framework) that this is a special type of route that should use the fullscreen dialog animation.

The `CupertinoRouteTransitionMixin`'s `buildTransitions` method checks the `fullscreenDialog` property of the route it's building transitions for. If it's `true`, it creates a `CupertinoFullscreenDialogTransition` instead of a `CupertinoPageTransition`.

Let's revisit the simplified concept from the `CupertinoRouteTransitionMixin`'s `buildPageTransitions` logic:

```dart
// Simplified concept - from CupertinoRouteTransitionMixin's buildTransitions logic
// This code is inside the Flutter framework!
Widget buildPageTransitions(
  PageRoute<T> route, // The route being built
  BuildContext context,
  Animation<double> primaryAnimation, // Animation for the incoming page
  Animation<double> secondaryAnimation, // Animation for the outgoing page
  Widget child, // the NewScreen widget
) {
  // Decide if it's a fullscreen dialog or a regular page
  if (route.fullscreenDialog) {
    print("Building FULLSCREEN Dialog Transition!"); // Added for emphasis
    return CupertinoFullscreenDialogTransition( // <--- Uses this widget!
      primaryRouteAnimation: primaryAnimation, // Pass incoming animation
      secondaryRouteAnimation: secondaryAnimation, // Pass outgoing animation
      linearTransition: route.popGestureInProgress,
      child: child, // Wrap the NewScreen widget
    );
  } else {
    // For regular pages, use CupertinoPageTransition
    // ... create CupertinoPageTransition ...
  }
}
```

This fragment, part of the code in `packages/flutter/lib/src/cupertino/route.dart`, directly shows the decision point. If the `PageRoute` is a `fullscreenDialog`, the framework creates a `CupertinoFullscreenDialogTransition` widget and passes it the necessary animation objects and your screen's content (`child`).

### The Visual Magic (Sliding Up)

Inside `CupertinoFullscreenDialogTransition`, the actual visual effect is simpler than `CupertinoPageTransition`'s. It primarily uses a `SlideTransition` to make the new screen slide up from the bottom. It also handles the animation of the screen *being covered*, though the effect for fullscreen dialogs isn't the same parallax as a regular page slide.

Here's a simplified look at the core `build` method of `CupertinoFullscreenDialogTransition`:

```dart
// Simplified concept - from the build method inside CupertinoFullscreenDialogTransition
@override
Widget build(BuildContext context) {
  // Calculate slide for primary (incoming) page
  // based on primaryRouteAnimation (animating from bottom up)

  // Calculate slide for secondary (outgoing) page
  // based on secondaryRouteAnimation (it might slightly move or fade)

  return SlideTransition(
    position: _secondaryPositionAnimation, // Slightly moves/affects the outgoing page
    child: SlideTransition(
      position: _primaryPositionAnimation, // Slides the incoming page (your dialog)
      child: widget.child, // The actual screen content (your dialog widget)
    ),
  );
}
```

This structure is similar to `CupertinoPageTransition` but uses different `Tween`s (animations definitions) to control the direction and type of movement:

1.  The outermost `SlideTransition` uses `_secondaryPositionAnimation` (derived from `secondaryRouteAnimation`). For fullscreen dialogs, the effect on the previous page is usually just a subtle dimming or no movement, though the mixin provides the animation for potential use.
2.  The inner `SlideTransition` uses `_primaryPositionAnimation` (derived from `primaryRouteAnimation`) to slide the **incoming page** (`widget.child`) from off-screen *below* to the center of the screen. The `_kBottomUpTween` defined in `packages/flutter/lib/src/cupertino/route.dart` (which goes from `Offset(0.0, 1.0)` meaning bottom-off-screen to `Offset.zero` meaning on-screen) is used here.

```mermaid
graph TD
    A[Navigator] --> B[CupertinoPageRoute (fullscreenDialog: true)];
    B --> C[CupertinoRouteTransitionMixin]
    C --> D[buildTransitions checks fullscreenDialog: true]
    D --> E[Creates CupertinoFullscreenDialogTransition]
    E --> F{Build Method of CupertinoFullscreenDialogTransition};
    F --> G[Outer SlideTransition - Secondary Animation (Previous Page)];
    G --> H[Inner SlideTransition - Primary Animation (Slide Up)];
    H --> I[Your Dialog Widget];
```

So, `CupertinoFullscreenDialogTransition` uses `SlideTransition` (possibly nested) with animation values that cause the `child` widget to move from the bottom to the center of the screen, providing the standard iOS fullscreen dialog effect.

### You Don't Use It Directly

As emphasized before, you won't typically use `CupertinoFullscreenDialogTransition` directly in your application code. Its purpose is to be the visual engine for fullscreen dialogs when you use a `PageRoute` (like `CupertinoPageRoute`) configured with `fullscreenDialog: true`.

Understanding `CupertinoFullscreenDialogTransition` helps you recognize that the fullscreen dialog's bottom-up animation isn't just magic; it's built using standard Flutter animation widgets under the hood, controlled by the transition `Animation` objects.

### Conclusion

`CupertinoFullscreenDialogTransition` is a dedicated widget within the Cupertino library for achieving the distinct iOS fullscreen dialog animation, where the new screen slides up from the bottom. It works in conjunction with `CupertinoRouteTransitionMixin` and `PageRoute` objects configured with `fullscreenDialog: true` to apply this specific visual effect to your screen's content. While you don't use it directly, its existence explains the different animation style for these types of pop-ups in Cupertino-styled apps.

In the next chapter, we'll look at `CupertinoModalPopupRoute`, a specialized route for showing simpler modal popups from the bottom, like action sheets.

[Next Chapter: CupertinoModalPopupRoute](08_cupertinomodalpopuproute_.md)

Relevant Code Snippets (Code itself remains unchanged):
--- File: packages/flutter/lib/src/cupertino/route.dart ---
// Copyright 2014 The Flutter Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

/// @docImport 'dart:ui';
///
/// @docImport 'package:flutter/material.dart';
/// @docImport 'package:flutter/services.dart';
///
/// @docImport 'app.dart';
/// @docImport 'button.dart';
/// @docImport 'dialog.dart';
/// @docImport 'nav_bar.dart';
/// @docImport 'page_scaffold.dart';
/// @docImport 'tab_scaffold.dart';
library;

import 'dart:math';
import 'dart:ui' show ImageFilter;

import 'package:flutter/foundation.dart';
import 'package:flutter/gestures.dart';
import 'package:flutter/physics.dart';
import 'package:flutter/rendering.dart';
import 'package:flutter/widgets.dart';

import 'colors.dart';
import 'interface_level.dart';
import 'localizations.dart';

const double _kBackGestureWidth = 20.0;
const double _kMinFlingVelocity = 1.0; // Screen widths per second.

// The duration for a page to animate when the user releases it mid-swipe.
const Duration _kDroppedSwipePageAnimationDuration = Duration(milliseconds: 350);

/// Barrier color used for a barrier visible during transitions for Cupertino
/// page routes.
///
/// This barrier color is only used for full-screen page routes with
/// `fullscreenDialog: false`.
///
/// By default, `fullscreenDialog` Cupertino route transitions have no
/// `barrierColor`, and [CupertinoDialogRoute]s and [CupertinoModalPopupRoute]s
/// have a `barrierColor` defined by [kCupertinoModalBarrierColor].
///
/// A relatively rigorous eyeball estimation.
const Color _kCupertinoPageTransitionBarrierColor = Color(0x18000000);

/// Barrier color for a Cupertino modal barrier.
///
/// Extracted from https://developer.apple.com/design/resources/.
const Color kCupertinoModalBarrierColor = CupertinoDynamicColor.withBrightness(
  color: Color(0x33000000),
  darkColor: Color(0x7A000000),
);

// The duration of the transition used when a modal popup is shown.
const Duration _kModalPopupTransitionDuration = Duration(milliseconds: 335);

// Offset from offscreen to the right to fully on screen.
final Animatable<Offset> _kRightMiddleTween = Tween<Offset>(
  begin: const Offset(1.0, 0.0),
  end: Offset.zero,
);

// Offset from fully on screen to 1/3 offscreen to the left.
final Animatable<Offset> _kMiddleLeftTween = Tween<Offset>(
  begin: Offset.zero,
  end: const Offset(-1.0 / 3.0, 0.0),
);

// Offset from offscreen below to fully on screen.
final Animatable<Offset> _kBottomUpTween = Tween<Offset>(
  begin: const Offset(0.0, 1.0),
  end: Offset.zero,
);

/// A mixin that replaces the entire screen with an iOS transition for a
/// [PageRoute].
///
/// {@template flutter.cupertino.cupertinoRouteTransitionMixin}
/// The page slides in from the right and exits in reverse. The page also shifts
/// to the left in parallax when another page enters to cover it.
///
/// The page slides in from the bottom and exits in reverse with no parallax
/// effect for fullscreen dialogs.
/// {@endtemplate}
///
/// See also:
///
///  * [MaterialRouteTransitionMixin], which is a mixin that provides
///    platform-appropriate transitions for a [PageRoute].
///  * [CupertinoPageRoute], which is a [PageRoute] that leverages this mixin.
mixin CupertinoRouteTransitionMixin<T> on PageRoute<T> {
  /// Builds the primary contents of the route.
  @protected
  Widget buildContent(BuildContext context);

  /// {@template flutter.cupertino.CupertinoRouteTransitionMixin.title}
  /// A title string for this route.
  ///
  /// Used to auto-populate [CupertinoNavigationBar] and
  /// [CupertinoSliverNavigationBar]'s `middle`/`largeTitle` widgets when
  /// one is not manually supplied.
  /// {@endtemplate}
  String? get title;

  ValueNotifier<String?>? _previousTitle;

  /// The title string of the previous [CupertinoPageRoute].
  ///
  /// The [ValueListenable]'s value is readable after the route is installed
  /// onto a [Navigator]. The [ValueListenable] will also notify its listeners
  /// if the value changes (such as by replacing the previous route).
  ///
  /// The [ValueListenable] itself will be null before the route is installed.
  /// Its content value will be null if the previous route has no title or
  /// is not a [CupertinoPageRoute].
  ///
  /// See also:
  ///
  ///  * [ValueListenableBuilder], which can be used to listen and rebuild
  ///    widgets based on a ValueListenable.
  ValueListenable<String?> get previousTitle {
    assert(
      _previousTitle != null,
      'Cannot read the previousTitle for a route that has not yet been installed',
    );
    return _previousTitle!;
  }

  @override
  void dispose() {
    _previousTitle?.dispose();
    super.dispose();
  }

  @override
  void didChangePrevious(Route<dynamic>? previousRoute) {
    final String? previousTitleString =
        previousRoute is CupertinoRouteTransitionMixin ? previousRoute.title : null;
    if (_previousTitle == null) {
      _previousTitle = ValueNotifier<String?>(previousTitleString);
    } else {
      _previousTitle!.value = previousTitleString;
    }
    super.didChangePrevious(previousRoute);
  }

  @override
  // A relatively rigorous eyeball estimation.
  Duration get transitionDuration => const Duration(milliseconds: 500);

  @override
  Color? get barrierColor => fullscreenDialog ? null : _kCupertinoPageTransitionBarrierColor;

  @override
  String? get barrierLabel => null;

  @override
  bool canTransitionTo(TransitionRoute<dynamic> nextRoute) {
    // Don't perform outgoing animation if the next route is a fullscreen dialog.
    final bool nextRouteIsNotFullscreen =
        (nextRoute is! PageRoute<T>) || !nextRoute.fullscreenDialog;

    // If the next route has a delegated transition, then this route is able to
    // use that delegated transition to smoothly sync with the next route's
    // transition.
    final bool nextRouteHasDelegatedTransition =
        nextRoute is ModalRoute<T> && nextRoute.delegatedTransition != null;

    // Otherwise if the next route has the same route transition mixin as this
    // one, then this route will already be synced with its transition.
    return nextRouteIsNotFullscreen &&
        ((nextRoute is CupertinoRouteTransitionMixin) || nextRouteHasDelegatedTransition);
  }

  @override
  bool canTransitionFrom(TransitionRoute<dynamic> previousRoute) {
    // Supress previous route from transitioning if this is a fullscreenDialog route.
    return previousRoute is PageRoute && !fullscreenDialog;
  }

  @override
  Widget buildPage(
    BuildContext context,
    Animation<double> animation,
    Animation<double> secondaryAnimation,
  ) {
    final Widget child = buildContent(context);
    return Semantics(scopesRoute: true, explicitChildNodes: true, child: child);
  }

  // Called by _CupertinoBackGestureDetector when a pop ("back") drag start
  // gesture is detected. The returned controller handles all of the subsequent
  // drag events.
  static _CupertinoBackGestureController<T> _startPopGesture<T>(PageRoute<T> route) {
    assert(route.popGestureEnabled);

    return _CupertinoBackGestureController<T>(
      navigator: route.navigator!,
      getIsCurrent: () => route.isCurrent,
      getIsActive: () => route.isActive,
      controller: route.controller!, // protected access
    );
  }

  /// Returns a [CupertinoFullscreenDialogTransition] if [route] is a full
  /// screen dialog, otherwise a [CupertinoPageTransition] is returned.
  ///
  /// Used by [CupertinoPageRoute.buildTransitions].
  ///
  /// This method can be applied to any [PageRoute], not just
  /// [CupertinoPageRoute]. It's typically used to provide a Cupertino style
  /// horizontal transition for material widgets when the target platform
  /// is [TargetPlatform.iOS].
  ///
  /// See also:
  ///
  ///  * [CupertinoPageTransitionsBuilder], which uses this method to define a
  ///    [PageTransitionsBuilder] for the [PageTransitionsTheme].
  static Widget buildPageTransitions<T>(
    PageRoute<T> route,
    BuildContext context,
    Animation<double> animation,
    Animation<double> secondaryAnimation,
    Widget child,
  ) {
    // Check if the route has an animation that's currently participating
    // in a back swipe gesture.
    //
    // In the middle of a back gesture drag, let the transition be linear to
    // match finger motions.
    final bool linearTransition = route.popGestureInProgress;
    if (route.fullscreenDialog) {
      return CupertinoFullscreenDialogTransition(
        primaryRouteAnimation: animation,
        secondaryRouteAnimation: secondaryAnimation,
        linearTransition: linearTransition,
        child: child,
      );
    } else {
      return CupertinoPageTransition(
        primaryRouteAnimation: animation,
        secondaryRouteAnimation: secondaryAnimation,
        linearTransition: linearTransition,
        child: _CupertinoBackGestureDetector<T>(
          enabledCallback: () => route.popGestureEnabled,
          onStartPopGesture: () => _startPopGesture<T>(route),
          child: child,
        ),
      );
    }
  }

  @override
  Widget buildTransitions(
    BuildContext context,
    Animation<double> animation,
    Animation<double> secondaryAnimation,
    Widget child,
  ) {
    return buildPageTransitions<T>(this, context, animation, secondaryAnimation, child);
  }
}

/// A modal route that replaces the entire screen with an iOS transition.
///
/// {@macro flutter.cupertino.cupertinoRouteTransitionMixin}
///
/// By default, when a modal route is replaced by another, the previous route
/// remains in memory. To free all the resources when this is not necessary, set
/// [maintainState] to false.
///
/// The type `T` specifies the return type of the route which can be supplied as
/// the route is popped from the stack via [Navigator.pop] when an optional
/// `result` can be provided.
///
/// If `barrierDismissible` is true, then pressing the escape key on the keyboard
/// will cause the current route to be popped with null as the value.
///
/// See also:
///
///  * [CupertinoRouteTransitionMixin], for a mixin that provides iOS transition
///    for this modal route.
///  * [MaterialPageRoute], for an adaptive [PageRoute] that uses a
///    platform-appropriate transition.
///  * [CupertinoPageScaffold], for applications that have one page with a fixed
///    navigation bar on top.
///  * [CupertinoTabScaffold], for applications that have a tab bar at the
///    bottom with multiple pages.
///  * [CupertinoPage], for a [Page] version of this class.
class CupertinoPageRoute<T> extends PageRoute<T> with CupertinoRouteTransitionMixin<T> {
  /// Creates a page route for use in an iOS designed app.
  ///
  /// The [builder], [maintainState], and [fullscreenDialog] arguments must not
  /// be null.
  CupertinoPageRoute({
    required this.builder,
    this.title,
    super.settings,
    super.requestFocus,
    this.maintainState = true,
    super.fullscreenDialog,
    super.allowSnapshotting = true,
    super.barrierDismissible = false,
  }) {
    assert(opaque);
  }

  @override
  DelegatedTransitionBuilder? get delegatedTransition =>
      CupertinoPageTransition.delegatedTransition;

  /// Builds the primary contents of the route.
  final WidgetBuilder builder;

  @override
  Widget buildContent(BuildContext context) => builder(context);

  @override
  final String? title;

  @override
  final bool maintainState;

  @override
  String get debugLabel => '${super.debugLabel}(${settings.name})';
}

// A page-based version of CupertinoPageRoute.
//
// This route uses the builder from the page to build its content. This ensures
// the content is up to date after page updates.
class _PageBasedCupertinoPageRoute<T> extends PageRoute<T> with CupertinoRouteTransitionMixin<T> {
  _PageBasedCupertinoPageRoute({required CupertinoPage<T> page, super.allowSnapshotting = true})
    : super(settings: page) {
    assert(opaque);
  }

  @override
  DelegatedTransitionBuilder? get delegatedTransition =>
      this.fullscreenDialog ? null : CupertinoPageTransition.delegatedTransition;

  CupertinoPage<T> get _page => settings as CupertinoPage<T>;

  @override
  Widget buildContent(BuildContext context) => _page.child;

  @override
  String? get title => _page.title;

  @override
  bool get maintainState => _page.maintainState;

  @override
  bool get fullscreenDialog => _page.fullscreenDialog;

  @override
  String get debugLabel => '${super.debugLabel}(${_page.name})';
}

/// A page that creates a cupertino style [PageRoute].
///
/// {@macro flutter.cupertino.cupertinoRouteTransitionMixin}
///
/// By default, when a created modal route is replaced by another, the previous
/// route remains in memory. To free all the resources when this is not
/// necessary, set [maintainState] to false.
///
/// The type `T` specifies the return type of the route which can be supplied as
/// the route is popped from the stack via [Navigator.transitionDelegate] by
/// providing the optional `result` argument to the
/// [RouteTransitionRecord.markForPop] in the [TransitionDelegate.resolve].
///
/// See also:
///
///  * [CupertinoPageRoute], for a [PageRoute] version of this class.
class CupertinoPage<T> extends Page<T> {
  /// Creates a cupertino page.
  const CupertinoPage({
    required this.child,
    this.maintainState = true,
    this.title,
    this.fullscreenDialog = false,
    this.allowSnapshotting = true,
    super.canPop,
    super.onPopInvoked,
    super.key,
    super.name,
    super.arguments,
    super.restorationId,
  });

  /// The content to be shown in the [Route] created by this page.
  final Widget child;

  /// {@macro flutter.cupertino.CupertinoRouteTransitionMixin.title}
  final String? title;

  /// {@macro flutter.widgets.ModalRoute.maintainState}
  final bool maintainState;

  /// {@macro flutter.widgets.PageRoute.fullscreenDialog}
  final bool fullscreenDialog;

  /// {@macro flutter.widgets.TransitionRoute.allowSnapshotting}
  final bool allowSnapshotting;

  @override
  Route<T> createRoute(BuildContext context) {
    return _PageBasedCupertinoPageRoute<T>(page: this, allowSnapshotting: allowSnapshotting);
  }
}

/// Provides an iOS-style page transition animation.
///
/// The page slides in from the right and exits in reverse. It also shifts to the left in
/// a parallax motion when another page enters to cover it.
class CupertinoPageTransition extends StatefulWidget {
  /// Creates an iOS-style page transition.
  ///
  const CupertinoPageTransition({
    super.key,
    required this.primaryRouteAnimation,
    required this.secondaryRouteAnimation,
    required this.child,
    required this.linearTransition,
  });

  /// The widget below this widget in the tree.
  final Widget child;

  ///  * `primaryRouteAnimation` is a linear route animation from 0.0 to 1.0
  ///    when this screen is being pushed.
  final Animation<double> primaryRouteAnimation;

  ///  * `secondaryRouteAnimation` is a linear route animation from 0.0 to 1.0
  ///    when another screen is being pushed on top of this one.
  final Animation<double> secondaryRouteAnimation;

  ///  * `linearTransition` is whether to perform the transitions linearly.
  ///    Used to precisely track back gesture drags.
  final bool linearTransition;

  /// The Cupertino styled [DelegatedTransitionBuilder] provided to the previous
  /// route.
  ///
  /// {@macro flutter.widgets.delegatedTransition}
  static Widget? delegatedTransition(
    BuildContext context,
    Animation<double> animation,
    Animation<double> secondaryAnimation,
    bool allowSnapshotting,
    Widget? child,
  ) {
    final CurvedAnimation animation = CurvedAnimation(
      parent: secondaryAnimation,
      curve: Curves.linearToEaseOut,
      reverseCurve: Curves.easeInToLinear,
    );
    final Animation<Offset> delegatedPositionAnimation = animation.drive(_kMiddleLeftTween);
    animation.dispose();

    assert(debugCheckHasDirectionality(context));
    final TextDirection textDirection = Directionality.of(context);
    return SlideTransition(
      position: delegatedPositionAnimation,
      textDirection: textDirection,
      transformHitTests: false,
      child: child,
    );
  }

  @override
  State<CupertinoPageTransition> createState() => _CupertinoPageTransitionState();
}

class _CupertinoPageTransitionState extends State<CupertinoPageTransition> {
  // When this page is coming in to cover another page.
  late Animation<Offset> _primaryPositionAnimation;
  // When this page is becoming covered by another page.
  late Animation<Offset> _secondaryPositionAnimation;
  // Shadow of page which is coming in to cover another page.
  late Animation<Decoration> _primaryShadowAnimation;
  // Curve of primary page which is coming in to cover another page.
  CurvedAnimation? _primaryPositionCurve;
  // Curve of secondary page which is becoming covered by another page.
  CurvedAnimation? _secondaryPositionCurve;
  // Curve of primary page's shadow.
  CurvedAnimation? _primaryShadowCurve;

  @override
  void initState() {
    super.initState();
    _setupAnimation();
  }

  @override
  void didUpdateWidget(covariant CupertinoPageTransition oldWidget) {
    super.didUpdateWidget(oldWidget);
    if (oldWidget.primaryRouteAnimation != widget.primaryRouteAnimation ||
        oldWidget.secondaryRouteAnimation != widget.secondaryRouteAnimation ||
        oldWidget.linearTransition != widget.linearTransition) {
      _disposeCurve();
      _setupAnimation();
    }
  }

  @override
  void dispose() {
    _disposeCurve();
    super.dispose();
  }

  void _disposeCurve() {
    _primaryPositionCurve?.dispose();
    _secondaryPositionCurve?.dispose();
    _primaryShadowCurve?.dispose();
    _primaryPositionCurve = null;
    _secondaryPositionCurve = null;
    _primaryShadowCurve = null;
  }

  void _setupAnimation() {
    if (!widget.linearTransition) {
      _primaryPositionCurve = CurvedAnimation(
        parent: widget.primaryRouteAnimation,
        curve: Curves.fastEaseInToSlowEaseOut,
        reverseCurve: Curves.fastEaseInToSlowEaseOut.flipped,
      );
      _secondaryPositionCurve = CurvedAnimation(
        parent: widget.secondaryRouteAnimation,
        curve: Curves.linearToEaseOut,
        reverseCurve: Curves.easeInToLinear,
      );
      _primaryShadowCurve = CurvedAnimation(
        parent: widget.primaryRouteAnimation,
        curve: Curves.linearToEaseOut,
      );
    }
    _primaryPositionAnimation = (_primaryPositionCurve ?? widget.primaryRouteAnimation).drive(
      _kRightMiddleTween,
    );
    _secondaryPositionAnimation = (_secondaryPositionCurve ?? widget.secondaryRouteAnimation).drive(
      _kMiddleLeftTween,
    );
    _primaryShadowAnimation = (_primaryShadowCurve ?? widget.primaryRouteAnimation).drive(
      _CupertinoEdgeShadowDecoration.kTween,
    );
  }

  @override
  Widget build(BuildContext context) {
    assert(debugCheckHasDirectionality(context));
    final TextDirection textDirection = Directionality.of(context);
    return SlideTransition(
      position: _secondaryPositionAnimation,
      textDirection: textDirection,
      transformHitTests: false,
      child: SlideTransition(
        position: _primaryPositionAnimation,
        textDirection: textDirection,
        child: DecoratedBoxTransition(decoration: _primaryShadowAnimation, child: widget.child),
      ),
    );
  }
}

/// An iOS-style transition used for summoning fullscreen dialogs.
///
/// For example, used when creating a new calendar event by bringing in the next
/// screen from the bottom.
class CupertinoFullscreenDialogTransition extends StatefulWidget {
  /// Creates an iOS-style transition used for summoning fullscreen dialogs.
  ///
  const CupertinoFullscreenDialogTransition({
    super.key,
    required this.primaryRouteAnimation,
    required this.secondaryRouteAnimation,
    required this.child,
    required this.linearTransition,
  });

  ///  * `primaryRouteAnimation` is a linear route animation from 0.0 to 1.0
  ///    when this screen is being pushed.
  final Animation<double> primaryRouteAnimation;

  ///  * `secondaryRouteAnimation` is a linear route animation from 0.0 to 1.0
  ///    when another screen is being pushed on top of this one.
  final Animation<double> secondaryRouteAnimation;

  ///  * `linearTransition` is whether to perform the transitions linearly.
  ///    Used to precisely track back gesture drags.
  final bool linearTransition;

  /// The widget below this widget in the tree.
  final Widget child;

  @override
  State<CupertinoFullscreenDialogTransition> createState() =>
      _CupertinoFullscreenDialogTransitionState();
}

class _CupertinoFullscreenDialogTransitionState extends State<CupertinoFullscreenDialogTransition> {
  /// When this page is coming in to cover another page.
  late Animation<Offset> _primaryPositionAnimation;

  /// When this page is becoming covered by another page.
  late Animation<Offset> _secondaryPositionAnimation;

  /// Curve of primary page which is coming in to cover another page.
  CurvedAnimation? _primaryPositionCurve;

  /// Curve of secondary page which is becoming covered by another page.
  CurvedAnimation? _secondaryPositionCurve;

  @override
  void initState() {
    super.initState();
    _setupAnimation();
  }

  @override
  void didUpdateWidget(covariant CupertinoFullscreenDialogTransition oldWidget) {
    super.didUpdateWidget(oldWidget);
    if (oldWidget.primaryRouteAnimation != widget.primaryRouteAnimation ||
        oldWidget.secondaryRouteAnimation != widget.secondaryRouteAnimation ||
        oldWidget.linearTransition != widget.linearTransition) {
      _disposeCurve();
      _setupAnimation();
    }
  }

  @override
  void dispose() {
    _disposeCurve();
    super.dispose();
  }

  void _disposeCurve() {
    _primaryPositionCurve?.dispose();
    _secondaryPositionCurve?.dispose();
    _primaryPositionCurve = null;
    _secondaryPositionCurve = null;
  }

  void _setupAnimation() {
    _primaryPositionAnimation = (_primaryPositionCurve = CurvedAnimation(
          parent: widget.primaryRouteAnimation,
          curve: Curves.linearToEaseOut,
          // The curve must be flipped so that the reverse animation doesn't play
          // an ease-in curve, which iOS does not use.
          reverseCurve: Curves.linearToEaseOut.flipped,
        ))
        .drive(_kBottomUpTween);
    _secondaryPositionAnimation = (widget.linearTransition
            ? widget.secondaryRouteAnimation
            : _secondaryPositionCurve = CurvedAnimation(
              parent: widget.secondaryRouteAnimation,
              curve: Curves.linearToEaseOut,
              reverseCurve: Curves.easeInToLinear,
            ))
        .drive(_kMiddleLeftTween);
  }

  @override
  Widget build(BuildContext context) {
    assert(debugCheckHasDirectionality(context));
    final TextDirection textDirection = Directionality.of(context);
    return SlideTransition(
      position: _secondaryPositionAnimation,
      textDirection: textDirection,
      transformHitTests: false,
      child: SlideTransition(position: _primaryPositionAnimation, child: widget.child),
    );
  }
}

/// This is the widget side of [_CupertinoBackGestureController].
///
/// This widget provides a gesture recognizer which, when it determines the
/// route can be closed with a back gesture, creates the controller and
/// feeds it the input from the gesture recognizer.
///
/// The gesture data is converted from absolute coordinates to logical
/// coordinates by this widget.
///
/// The type `T` specifies the return type of the route with which this gesture
/// detector is associated.
class _CupertinoBackGestureDetector<T> extends StatefulWidget {
  const _CupertinoBackGestureDetector({
    super.key,
    required this.enabledCallback,
    required this.onStartPopGesture,
    required this.child,
  });

  final Widget child;

  final ValueGetter<bool> enabledCallback;

  final ValueGetter<_CupertinoBackGestureController<T>> onStartPopGesture;

  @override
  _CupertinoBackGestureDetectorState<T> createState() => _CupertinoBackGestureDetectorState<T>();
}

class _CupertinoBackGestureDetectorState<T> extends State<_CupertinoBackGestureDetector<T>> {
  _CupertinoBackGestureController<T>? _backGestureController;

  late HorizontalDragGestureRecognizer _recognizer;

  @override
  void initState() {
    super.initState();
    _recognizer =
        HorizontalDragGestureRecognizer(debugOwner: this)
          ..onStart = _handleDragStart
          ..onUpdate = _handleDragUpdate
          ..onEnd = _handleDragEnd
          ..onCancel = _handleDragCancel;
  }

  @override
  void dispose() {
    _recognizer.dispose();

    // If this is disposed during a drag, call navigator.didStopUserGesture.
    if (_backGestureController != null) {
      WidgetsBinding.instance.addPostFrameCallback((_) {
        if (_backGestureController?.navigator.mounted ?? false) {
          _backGestureController?.navigator.didStopUserGesture();
        }
        _backGestureController = null;
      });
    }
    super.dispose();
  }

  void _handleDragStart(DragStartDetails details) {
    assert(mounted);
    assert(_backGestureController == null);
    _backGestureController = widget.onStartPopGesture();
  }

  void _handleDragUpdate(DragUpdateDetails details) {
    assert(mounted);
    assert(_backGestureController != null);
    _backGestureController!.dragUpdate(
      _convertToLogical(details.primaryDelta! / context.size!.width),
    );
  }

  void _handleDragEnd(DragEndDetails details) {
    assert(mounted);
    assert(_backGestureController != null);
    _backGestureController!.dragEnd(
      _convertToLogical(details.velocity.pixelsPerSecond.dx / context.size!.width),
    );
    _backGestureController = null;
  }

  void _handleDragCancel() {
    assert(mounted);
    // This can be called even if start is not called, paired with the "down" event
    // that we don't consider here.
    _backGestureController?.dragEnd(0.0);
    _backGestureController = null;
  }

  void _handlePointerDown(PointerDownEvent event) {
    if (widget.enabledCallback()) {
      _recognizer.addPointer(event);
    }
  }

  double _convertToLogical(double value) {
    return switch (Directionality.of(context)) {
      TextDirection.rtl => -value,
      TextDirection.ltr => value,
    };
  }

  @override
  Widget build(BuildContext context) {
    assert(debugCheckHasDirectionality(context));
    // For devices with notches, the drag area needs to be larger on the side
    // that has the notch.
    final double dragAreaWidth = switch (Directionality.of(context)) {
      TextDirection.rtl => MediaQuery.paddingOf(context).right,
      TextDirection.ltr => MediaQuery.paddingOf(context).left,
    };
    return Stack(
      fit: StackFit.passthrough,
      children: <Widget>[
        widget.child,
        PositionedDirectional(
          start: 0.0,
          width: max(dragAreaWidth, _kBackGestureWidth),
          top: 0.0,
          bottom: 0.0,
          child: Listener(onPointerDown: _handlePointerDown, behavior: HitTestBehavior.translucent),
        ),
      ],
    );
  }
}

/// A controller for an iOS-style back gesture.
///
/// This is created by a [CupertinoPageRoute] in response from a gesture caught
/// by a [_CupertinoBackGestureDetector] widget, which then also feeds it input
/// from the gesture. It controls the animation controller owned by the route,
/// based on the input provided by the gesture detector.
///
/// This class works entirely in logical coordinates (0.0 is new page dismissed,
/// 1.0 is new page on top).
///
/// The type `T` specifies the return type of the route with which this gesture
/// detector controller is associated.
class _CupertinoBackGestureController<T> {
  /// Creates a controller for an iOS-style back gesture.
  _CupertinoBackGestureController({
    required this.navigator,
    required this.controller,
    required this.getIsActive,
    required this.getIsCurrent,
  }) {
    navigator.didStartUserGesture();
  }

  final AnimationController controller;
  final NavigatorState navigator;
  final ValueGetter<bool> getIsActive;
  final ValueGetter<bool> getIsCurrent;

  /// The drag gesture has changed by [delta]. The total range of the drag
  /// should be 0.0 to 1.0.
  void dragUpdate(double delta) {
    controller.value -= delta;
  }

  /// The drag gesture has ended with a horizontal motion of [velocity] as a
  /// fraction of screen width per second.
  void dragEnd(double velocity) {
    // Fling in the appropriate direction.
    //
    // This curve has been determined through rigorously eyeballing native iOS
    // animations.
    const Curve animationCurve = Curves.fastEaseInToSlowEaseOut;
    final bool isCurrent = getIsCurrent();
    final bool animateForward;

    if (!isCurrent) {
      // If the page has already been navigated away from, then the animation
      // direction depends on whether or not it's still in the navigation stack,
      // regardless of velocity or drag position. For example, if a route is
      // being slowly dragged back by just a few pixels, but then a programmatic
      // pop occurs, the route should still be animated off the screen.
      // See https://github.com/flutter/flutter/issues/141268.
      animateForward = getIsActive();
    } else if (velocity.abs() >= _kMinFlingVelocity) {
      // If the user releases the page before mid screen with sufficient velocity,
      // or after mid screen, we should animate the page out. Otherwise, the page
      // should be animated back in.
      animateForward = velocity <= 0;
    } else {
      animateForward = controller.value > 0.5;
    }

    if (animateForward) {
      controller.animateTo(
        1.0,
        duration: _kDroppedSwipePageAnimationDuration,
        curve: animationCurve,
      );
    } else {
      if (isCurrent) {
        // This route is destined to pop at this point. Reuse navigator's pop.
        navigator.pop();
      }

      // The popping may have finished inline if already at the target destination.
      if (controller.isAnimating) {
        controller.animateBack(
          0.0,
          duration: _kDroppedSwipePageAnimationDuration,
          curve: animationCurve,
        );
      }
    }

    if (controller.isAnimating) {
      // Keep the userGestureInProgress in true state so we don't change the
      // curve of the page transition mid-flight since CupertinoPageTransition
      // depends on userGestureInProgress.
      late AnimationStatusListener animationStatusCallback;
      animationStatusCallback = (AnimationStatus status) {
        navigator.didStopUserGesture();
        controller.removeStatusListener(animationStatusCallback);
      };
      controller.addStatusListener(animationStatusCallback);
    } else {
      navigator.didStopUserGesture();
    }
  }
}

// A custom [Decoration] used to paint an extra shadow on the start edge of the
// box it's decorating. It's like a [BoxDecoration] with only a gradient except
// it paints on the start side of the box instead of behind the box.
class _CupertinoEdgeShadowDecoration extends Decoration {
  const _CupertinoEdgeShadowDecoration._([this._colors]);

  static DecorationTween kTween = DecorationTween(
    begin: const _CupertinoEdgeShadowDecoration._(), // No decoration initially.
    end: const _CupertinoEdgeShadowDecoration._(
      // Eyeballed gradient used to mimic a drop shadow on the start side only.
      <Color>[Color(0x04000000), CupertinoColors.transparent],
    ),
  );

  // Colors used to paint a gradient at the start edge of the box it is
  // decorating.
  //
  // The first color in the list is used at the start of the gradient, which
  // is located at the start edge of the decorated box.
  //
  // If this is null, no shadow is drawn.
  //
  // The list must have at least two colors in it (otherwise it would not be a
  // gradient).
  final List<Color>? _colors;

  // Linearly interpolate between two edge shadow decorations decorations.
  //
  // The `t` argument represents position on the timeline, with 0.0 meaning
  // that the interpolation has not started, returning `a` (or something
  // equivalent to `a`), 1.0 meaning that the interpolation has finished,
  // returning `b` (or something equivalent to `b`), and values in between
  // meaning that the interpolation is at the relevant point on the timeline
  // between `a` and `b`. The interpolation can be extrapolated beyond 0.0 and
  // 1.0, so negative values and values greater than 1.0 are valid (and can
  // easily be generated by curves such as [Curves.elasticInOut]).
  //
  // Values for `t` are usually obtained from an [Animation<double>], such as
  // an [AnimationController].
  //
  // See also:
  //
  //  * [Decoration.lerp].
  static _CupertinoEdgeShadowDecoration? lerp(
    _CupertinoEdgeShadowDecoration? a,
    _CupertinoEdgeShadowDecoration? b,
    double t,
  ) {
    if (identical(a, b)) {
      return a;
    }
    if (a == null) {
      return b!._colors == null
          ? b
          : _CupertinoEdgeShadowDecoration._(
            b._colors!.map<Color>((Color color) => Color.lerp(null, color, t)!).toList(),
          );
    }
    if (b == null) {
      return a._colors == null
          ? a
          : _CupertinoEdgeShadowDecoration._(
            a._colors.map<Color>((Color color) => Color.lerp(null, color, 1.0 - t)!).toList(),
          );
    }
    assert(b._colors != null || a._colors != null);
    // If it ever becomes necessary, we could allow decorations with different
    // length' here, similarly to how it is handled in [LinearGradient.lerp].
    assert(b._colors == null || a._colors == null || a._colors.length == b._colors.length);
    return _CupertinoEdgeShadowDecoration._(<Color>[
      for (int i = 0; i < b._colors!.length; i += 1) Color.lerp(a._colors?[i], b._colors[i], t)!,
    ]);
  }

  @override
  _CupertinoEdgeShadowDecoration lerpFrom(Decoration? a, double t) {
    if (a is _CupertinoEdgeShadowDecoration) {
      return _CupertinoEdgeShadowDecoration.lerp(a, this, t)!;
    }
    return _CupertinoEdgeShadowDecoration.lerp(null, this, t)!;
  }

  @override
  _CupertinoEdgeShadowDecoration lerpTo(Decoration? b, double t) {
    if (b is _CupertinoEdgeShadowDecoration) {
      return _CupertinoEdgeShadowDecoration.lerp(this, b, t)!;
    }
    return _CupertinoEdgeShadowDecoration.lerp(this, null, t)!;
  }

  @override
  _CupertinoEdgeShadowPainter createBoxPainter([VoidCallback? onChanged]) {
    return _CupertinoEdgeShadowPainter(this, onChanged);
  }

  @override
  bool operator ==(Object other) {
    if (other.runtimeType != runtimeType) {
      return false;
    }
    return other is _CupertinoEdgeShadowDecoration && other._colors == _colors;
  }

  @override
  int get hashCode => _colors.hashCode;

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties.add(IterableProperty<Color>('colors', _colors));
  }
}

/// A [BoxPainter] used to draw the page transition shadow using gradients.
class _CupertinoEdgeShadowPainter extends BoxPainter {
  _CupertinoEdgeShadowPainter(this._decoration, super.onChanged)
    : assert(_decoration._colors == null || _decoration._colors.length > 1);

  final _CupertinoEdgeShadowDecoration _decoration;

  @override
  void paint(Canvas canvas, Offset offset, ImageConfiguration configuration) {
    final List<Color>? colors = _decoration._colors;
    if (colors == null) {
      return;
    }

    // The following code simulates drawing a [LinearGradient] configured as
    // follows:
    //
    // LinearGradient(
    //   begin: AlignmentDirectional(0.90, 0.0), // Spans 5% of the page.
    //   colors: _decoration._colors,
    // )
    //
    // A performance evaluation on Feb 8, 2021 showed, that drawing the gradient
    // manually as implemented below is more performant than relying on
    // [LinearGradient.createShader] because compiling that shader takes a long
    // time. On an iPhone XR, the implementation below reduced the worst frame
    // time for a cupertino page transition of a newly installed app from ~95ms
    // down to ~30ms, mainly because there's no longer a need to compile a
    // shader for the LinearGradient.
    //
    // The implementation below divides the width of the shadow into multiple
    // bands of equal width, one for each color interval defined by
    // `_decoration._colors`. Band x is filled with a gradient going from
    // `_decoration._colors[x]` to `_decoration._colors[x + 1]` by drawing a
    // bunch of 1px wide rects. The rects change their color by lerping between
    // the two colors that define the interval of the band.

    // Shadow spans 5% of the page.
    final double shadowWidth = 0.05 * configuration.size!.width;
    final double shadowHeight = configuration.size!.height;
    final double bandWidth = shadowWidth / (colors.length - 1);

    final TextDirection? textDirection = configuration.textDirection;
    assert(textDirection != null);
    final (double shadowDirection, double start) = switch (textDirection!) {
      TextDirection.rtl => (1, offset.dx + configuration.size!.width),
      TextDirection.ltr => (-1, offset.dx),
    };

    int bandColorIndex = 0;
    for (int dx = 0; dx < shadowWidth; dx += 1) {
      if (dx ~/ bandWidth != bandColorIndex) {
        bandColorIndex += 1;
      }
      final Paint paint =
          Paint()
            ..color =
                Color.lerp(
                  colors[bandColorIndex],
                  colors[bandColorIndex + 1],
                  (dx % bandWidth) / bandWidth,
                )!;
      final double x = start + shadowDirection * dx;
      canvas.drawRect(Rect.fromLTWH(x - 1.0, offset.dy, 1.0, shadowHeight), paint);
    }
  }
}

// The stiffness used by dialogs and action sheets.
//
// The stiffness value is obtained by examining the properties of
// `CASpringAnimation` in Xcode. The damping value is derived similarly, with
// additional precision calculated based on `_kStandardStiffness` to ensure a
// damping ratio of 1 (critically damped): damping = 2 * sqrt(stiffness)
const double _kStandardStiffness = 522.35;
const double _kStandardDamping = 45.7099552;
const SpringDescription _kStandardSpring = SpringDescription(
  mass: 1,
  stiffness: _kStandardStiffness,
  damping: _kStandardDamping,
);
// The iOS spring animation duration is 0.404 seconds, based on the properties
// of `CASpringAnimation` in Xcode. At this point, the spring's position
// `x(0.404)` is approximately 0.9990000, suggesting that iOS uses a position
// tolerance of 1e-3 (matching the default `_epsilonDefault` value).
//
// However, the spring's velocity `dx(0.404)` is about 0.02, indicating that iOS
// may not consider velocity when determining the animation's end condition. To
// account for this, a larger velocity tolerance is applied here for added
// safety.
const Tolerance _kStandardTolerance = Tolerance(velocity: 0.03);

/// A route that shows a modal iOS-style popup that slides up from the
/// bottom of the screen.
///
/// Such a popup is an alternative to a menu or a dialog and prevents the user
/// from interacting with the rest of the app.
///
/// It is used internally by [showCupertinoModalPopup] or can be directly pushed
/// onto the [Navigator] stack to enable state restoration. See
/// [showCupertinoModalPopup] for a state restoration app example.
///
/// The `barrierColor` argument determines the [Color] of the barrier underneath
/// the popup. When unspecified, the barrier color defaults to a light opacity
/// black scrim based on iOS's dialog screens. To correctly have iOS resolve
/// to the appropriate modal colors, pass in
/// `CupertinoDynamicColor.resolve(kCupertinoModalBarrierColor, context)`.
///
/// The `barrierDismissible` argument determines whether clicking outside the
/// popup results in dismissal. It is `true` by default.
///
/// The `semanticsDismissible` argument is used to determine whether the
/// semantics of the modal barrier are included in the semantics tree.
///
/// The `routeSettings` argument is used to provide [RouteSettings] to the
/// created Route.
///
/// {@macro flutter.widgets.RawDialogRoute}
///
/// See also:
///
///  * [DisplayFeatureSubScreen], which documents the specifics of how
///    [DisplayFeature]s can split the screen into sub-screens.
///  * [CupertinoActionSheet], which is the widget usually returned by the
///    `builder` argument.
///  * <https://developer.apple.com/design/human-interface-guidelines/ios/views/action-sheets/>
class CupertinoModalPopupRoute<T> extends PopupRoute<T> {
  /// A route that shows a modal iOS-style popup that slides up from the
  /// bottom of the screen.
  CupertinoModalPopupRoute({
    required this.builder,
    this.barrierLabel = 'Dismiss',
    this.barrierColor = kCupertinoModalBarrierColor,
    bool barrierDismissible = true,
    bool semanticsDismissible = false,
    super.filter,
    super.settings,
    super.requestFocus,
    this.anchorPoint,
  }) : _barrierDismissible = barrierDismissible,
       _semanticsDismissible = semanticsDismissible;

  /// A builder that builds the widget tree for the [CupertinoModalPopupRoute].
  ///
  /// The [builder] argument typically builds a [CupertinoActionSheet] widget.
  ///
  /// Content below the widget is dimmed with a [ModalBarrier]. The widget built
  /// by the [builder] does not share a context with the route it was originally
  /// built from. Use a [StatefulBuilder] or a custom [StatefulWidget] if the
  /// widget needs to update dynamically.
  final WidgetBuilder builder;

  final bool _barrierDismissible;

  final bool _semanticsDismissible;

  @override
  final String barrierLabel;

  @override
  final Color? barrierColor;

  @override
  bool get barrierDismissible => _barrierDismissible;

  @override
  bool get semanticsDismissible => _semanticsDismissible;

  @override
  Duration get transitionDuration => _kModalPopupTransitionDuration;

  /// {@macro flutter.widgets.DisplayFeatureSubScreen.anchorPoint}
  final Offset? anchorPoint;

  @override
  Simulation createSimulation({required bool forward}) {
    assert(!debugTransitionCompleted(), 'Cannot reuse a $runtimeType after disposing it.');
    final double end = forward ? 1.0 : 0.0;
    return SpringSimulation(
      _kStandardSpring,
      controller!.value,
      end,
      0,
      tolerance: _kStandardTolerance,
      snapToEnd: true,
    );
  }

  @override
  Widget buildPage(
    BuildContext context,
    Animation<double> animation,
    Animation<double> secondaryAnimation,
  ) {
    return CupertinoUserInterfaceLevel(
      data: CupertinoUserInterfaceLevelData.elevated,
      child: DisplayFeatureSubScreen(anchorPoint: anchorPoint, child: Builder(builder: builder)),
    );
  }

  @override
  Widget buildTransitions(
    BuildContext context,
    Animation<double> animation,
    Animation<double> secondaryAnimation,
    Widget child,
  ) {
    return Align(
      alignment: Alignment.bottomCenter,
      child: FractionalTranslation(translation: _offsetTween.evaluate(animation), child: child),
    );
  }

  static final Tween<Offset> _offsetTween = Tween<Offset>(
    begin: const Offset(0.0, 1.0),
    end: Offset.zero,
  );
}

/// Shows a modal iOS-style popup that slides up from the bottom of the screen.
///
/// Such a popup is an alternative to a menu or a dialog and prevents the user
/// from interacting with the rest of the app.
///
/// The `context` argument is used to look up the [Navigator] for the popup.
/// It is only used when the method is called. Its corresponding widget can be
/// safely removed from the tree before the popup is closed.
///
/// The `barrierColor` argument determines the [Color] of the barrier underneath
/// the popup. When unspecified, the barrier color defaults to a light opacity
/// black scrim based on iOS's dialog screens.
///
/// The `barrierDismissible` argument determines whether clicking outside the
/// popup results in dismissal. It is `true` by default.
///
/// The `useRootNavigator` argument is used to determine whether to push the
/// popup to the [Navigator] furthest from or nearest to the given `context`. It
/// is `true` by default.
///
/// The `semanticsDismissible` argument is used to determine whether the
/// semantics of the modal barrier are included in the semantics tree.
///
/// The `routeSettings` argument is used to provide [RouteSettings] to the
/// created Route.
///
/// The `builder` argument typically builds a [CupertinoActionSheet] widget.
/// Content below the widget is dimmed with a [ModalBarrier]. The widget built
/// by the `builder` does not share a context with the location that
/// [showCupertinoModalPopup] is originally called from. Use a
/// [StatefulBuilder] or a custom [StatefulWidget] if the widget needs to
/// update dynamically.
///
/// {@macro flutter.widgets.RawDialogRoute}
///
/// Returns a `Future` that resolves to the value that was passed to
/// [Navigator.pop] when the popup was closed.
///
/// ### State Restoration in Modals
///
/// Using this method will not enable state restoration for the modal. In order
/// to enable state restoration for a modal, use [Navigator.restorablePush]
/// or [Navigator.restorablePushNamed] with [CupertinoModalPopupRoute].
///
/// For more information about state restoration, see [RestorationManager].
///
/// {@tool dartpad}
/// This sample demonstrates how to create a restorable Cupertino modal route.
/// This is accomplished by enabling state restoration by specifying
/// [CupertinoApp.restorationScopeId] and using [Navigator.restorablePush] to
/// push [CupertinoModalPopupRoute] when the [CupertinoButton] is tapped.
///
/// {@macro flutter.widgets.RestorationManager}
///
/// ** See code in examples/api/lib/cupertino/route/show_cupertino_modal_popup.0.dart **
/// {@end-tool}
///
/// See also:
///
///  * [DisplayFeatureSubScreen], which documents the specifics of how
///    [DisplayFeature]s can split the screen into sub-screens.
///  * [CupertinoActionSheet], which is the widget usually returned by the
///    `builder` argument to [showCupertinoModalPopup].
///  * <https://developer.apple.com/design/human-interface-guidelines/ios/views/action-sheets/>
Future<T?> showCupertinoModalPopup<T>({
  required BuildContext context,
  required WidgetBuilder builder,
  ImageFilter? filter,
  Color barrierColor = kCupertinoModalBarrierColor,
  bool barrierDismissible = true,
  bool useRootNavigator = true,
  bool semanticsDismissible = false,
  RouteSettings? routeSettings,
  Offset? anchorPoint,
}) {
  return Navigator.of(context, rootNavigator: useRootNavigator).push(
    CupertinoModalPopupRoute<T>(
      builder: builder,
      filter: filter,
      barrierColor: CupertinoDynamicColor.resolve(barrierColor, context),
      barrierDismissible: barrierDismissible,
      semanticsDismissible: semanticsDismissible,
      settings: routeSettings,
      anchorPoint: anchorPoint,
    ),
  );
}

Widget _buildCupertinoDialogTransitions(
  BuildContext context,
  Animation<double> animation,
  Animation<double> secondaryAnimation,
  Widget child,
) {
  return child;
}

/// Displays an iOS-style dialog above the current contents of the app, with
/// iOS-style entrance and exit animations, modal barrier color, and modal
/// barrier behavior (by default, the dialog is not dismissible with a tap on
/// the barrier).
///
/// This function takes a `builder` which typically builds a [CupertinoAlertDialog]
/// widget. Content below the dialog is dimmed with a [ModalBarrier]. The widget
/// returned by the `builder` does not share a context with the location that
/// [showCupertinoDialog] is originally called from. Use a [StatefulBuilder] or
/// a custom [StatefulWidget] if the dialog needs to update dynamically.
///
/// The `context` argument is used to look up the [Navigator] for the dialog.
/// It is only used when the method is called. Its corresponding widget can
/// be safely removed from the tree before the dialog is closed.
///
/// The `useRootNavigator` argument is used to determine whether to push the
/// dialog to the [Navigator] furthest from or nearest to the given `context`.
/// By default, `useRootNavigator` is `true` and the dialog route created by
/// this method is pushed to the root navigator.
///
/// {@macro flutter.widgets.RawDialogRoute}
///
/// If the application has multiple [Navigator] objects, it may be necessary to
/// call `Navigator.of(context, rootNavigator: true).pop(result)` to close the
/// dialog rather than just `Navigator.pop(context, result)`.
///
/// Returns a [Future] that resolves to the value (if any) that was passed to
/// [Navigator.pop] when the dialog was closed.
///
/// ### State Restoration in Dialogs
///
/// Using this method will not enable state restoration for the dialog. In order
/// to enable state restoration for a dialog, use [Navigator.restorablePush]
/// or [Navigator.restorablePushNamed] with [CupertinoDialogRoute].
///
/// For more information about state restoration, see [RestorationManager].
///
/// {@tool dartpad}
/// This sample demonstrates how to create a restorable Cupertino dialog. This is
/// accomplished by enabling state restoration by specifying
/// [CupertinoApp.restorationScopeId] and using [Navigator.restorablePush] to
/// push [CupertinoDialogRoute] when the [CupertinoButton] is tapped.
///
/// {@macro flutter.widgets.RestorationManager}
///
/// ** See code in examples/api/lib/cupertino/route/show_cupertino_dialog.0.dart **
/// {@end-tool}
///
/// See also:
///
///  * [CupertinoAlertDialog], an iOS-style alert dialog.
///  * [showDialog], which displays a Material-style dialog.
///  * [showGeneralDialog], which allows for customization of the dialog popup.
///  * [DisplayFeatureSubScreen], which documents the specifics of how
///    [DisplayFeature]s can split the screen into sub-screens.
///  * <https://developer.apple.com/design/human-interface-guidelines/alerts/>
Future<T?> showCupertinoDialog<T>({
  required BuildContext context,
  required WidgetBuilder builder,
  String? barrierLabel,
  bool useRootNavigator = true,
  bool barrierDismissible = false,
  RouteSettings? routeSettings,
  Offset? anchorPoint,
}) {
  return Navigator.of(context, rootNavigator: useRootNavigator).push<T>(
    CupertinoDialogRoute<T>(
      builder: builder,
      context: context,
      barrierDismissible: barrierDismissible,
      barrierLabel: barrierLabel,
      barrierColor: CupertinoDynamicColor.resolve(kCupertinoModalBarrierColor, context),
      settings: routeSettings,
      anchorPoint: anchorPoint,
    ),
  );
}

/// A dialog route that shows an iOS-style dialog.
///
/// It is used internally by [showCupertinoDialog] or can be directly pushed
/// onto the [Navigator] stack to enable state restoration. See
/// [showCupertinoDialog] for a state restoration app example.
///
/// This function takes a `builder` which typically builds a [Dialog] widget.
/// Content below the dialog is dimmed with a [ModalBarrier]. The widget
/// returned by the `builder` does not share a context with the location that
/// `showDialog` is originally called from. Use a [StatefulBuilder] or a
/// custom [StatefulWidget] if the dialog needs to update dynamically.
///
/// The `context` argument is used to look up
/// [CupertinoLocalizations.modalBarrierDismissLabel], which provides the
/// modal with a localized accessibility label that will be used for the
/// modal's barrier. However, a custom `barrierLabel` can be passed in as well.
///
/// The `barrierDismissible` argument is used to indicate whether tapping on the
/// barrier will dismiss the dialog. It is `true` by default and cannot be `null`.
///
/// The `barrierColor` argument is used to specify the color of the modal
/// barrier that darkens everything below the dialog. If `null`, then
/// [CupertinoDynamicColor.resolve] is used to compute the modal color.
///
/// The `settings` argument define the settings for this route. See
/// [RouteSettings] for details.
///
/// {@macro flutter.widgets.RawDialogRoute}
///
/// See also:
///
///  * [showCupertinoDialog], which is a way to display
///     an iOS-style dialog.
///  * [showGeneralDialog], which allows for customization of the dialog popup.
///  * [showDialog], which displays a Material dialog.
///  * [DisplayFeatureSubScreen], which documents the specifics of how
///    [DisplayFeature]s can split the screen into sub-screens.
class CupertinoDialogRoute<T> extends RawDialogRoute<T> {
  /// A dialog route that shows an iOS-style dialog.
  CupertinoDialogRoute({
    required WidgetBuilder builder,
    required BuildContext context,
    super.barrierDismissible,
    Color? barrierColor,
    String? barrierLabel,
    // This transition duration was eyeballed comparing with iOS
    super.transitionDuration = const Duration(milliseconds: 250),
    this.transitionBuilder,
    super.settings,
    super.requestFocus,
    super.anchorPoint,
  }) : super(
         pageBuilder: (
           BuildContext context,
           Animation<double> animation,
           Animation<double> secondaryAnimation,
         ) {
           return builder(context);
         },
         transitionBuilder: transitionBuilder ?? _buildCupertinoDialogTransitions,
         barrierLabel: barrierLabel ?? CupertinoLocalizations.of(context).modalBarrierDismissLabel,
         barrierColor:
             barrierColor ?? CupertinoDynamicColor.resolve(kCupertinoModalBarrierColor, context),
       );

  /// Custom transition builder
  RouteTransitionsBuilder? transitionBuilder;

  CurvedAnimation? _fadeAnimation;

  @override
  Simulation createSimulation({required bool forward}) {
    assert(!debugTransitionCompleted(), 'Cannot reuse a $runtimeType after disposing it.');
    final double end = forward ? 1.0 : 0.0;
    return SpringSimulation(
      _kStandardSpring,
      controller!.value,
      end,
      0,
      tolerance: _kStandardTolerance,
      snapToEnd: true,
    );
  }

  @override
  Widget buildTransitions(
    BuildContext context,
    Animation<double> animation,
    Animation<double> secondaryAnimation,
    Widget child,
  ) {
    if (transitionBuilder != null) {
      return super.buildTransitions(context, animation, secondaryAnimation, child);
    }

    if (animation.status == AnimationStatus.reverse) {
      return FadeTransition(opacity: animation, child: child);
    }
    return FadeTransition(
      opacity: animation,
      child: ScaleTransition(scale: animation.drive(_dialogScaleTween), child: child),
    );
  }

  @override
  void dispose() {
    _fadeAnimation?.dispose();
    super.dispose();
  }

  // The curve and initial scale values were mostly eyeballed from iOS, however
  // they reuse the same animation curve that was modeled after native page
  // transitions.
  static final Tween<double> _dialogScaleTween = Tween<double>(begin: 1.3, end: 1.0);
}


Instructions for the chapter (Generate content in English unless specified otherwise):
- Start with a clear heading (e.g., `# Chapter 8: CupertinoModalPopupRoute
`). Use the provided concept name.

- If this is not the first chapter, begin with a brief transition from the previous chapter, referencing it with a proper Markdown link using its name.

- Begin with a high-level motivation explaining what problem this abstraction solves. Start with a central use case as a concrete example. The whole chapter should guide the reader to understand how to solve this use case. Make it very minimal and friendly to beginners.

- If the abstraction is complex, break it down into key concepts. Explain each concept one-by-one in a very beginner-friendly way.

- Explain how to use this abstraction to solve the use case. Give example inputs and outputs for code snippets (if the output isn't values, describe at a high level what will happen).

- Each code block should be BELOW 10 lines! If longer code blocks are needed, break them down into smaller pieces and walk through them one-by-one. Aggresively simplify the code to make it minimal. Use comments to skip non-important implementation details. Each code block should have a beginner friendly explanation right after it.

- Describe the internal implementation to help understand what's under the hood. First provide a non-code or code-light walkthrough on what happens step-by-step when the abstraction is called. It's recommended to use a simple sequenceDiagram with a dummy example - keep it minimal with at most 5 participants to ensure clarity. If participant name has space, use: `participant QP as Query Processing`. .

- Then dive deeper into code for the internal implementation with references to files. Provide example code blocks, but make them similarly simple and beginner-friendly. Explain.

- IMPORTANT: When you need to refer to other core abstractions covered in other chapters, ALWAYS use proper Markdown links like this: [Chapter Title](filename.md). Use the Complete Tutorial Structure above to find the correct filename and the chapter title. Translate the surrounding text.

- Use mermaid diagrams to illustrate complex concepts (```mermaid``` format). .

- Heavily use analogies and examples throughout to help beginners understand.

- End the chapter with a brief conclusion that summarizes what was learned and provides a transition to the next chapter. If there is a next chapter, use a proper Markdown link: [Next Chapter Title](next_chapter_filename).

- Ensure the tone is welcoming and easy for a newcomer to understand.

- Output *only* the Markdown content for this chapter.

Now, directly provide a super beginner-friendly Markdown output (DON'T need ```markdown``` tags):

2025-05-21 12:33:24,763 - INFO - RESPONSE: # Chapter 8: CupertinoModalPopupRoute

Welcome back, brave Flutter adventurers! In [Chapter 7: CupertinoFullscreenDialogTransition](07_cupertinofullscreendialogtransition_.md), we looked at the specific widget that provides the bottom-up animation for fullscreen iOS-style modal dialogs. Now, let's shift our gaze to a slightly different kind of pop-up from the bottom: the kind used for action sheets and simpler modal panels. This is where `CupertinoModalPopupRoute` comes in.

### What is CupertinoModalPopupRoute?

Imagine you tap a button on your phone (especially on iOS), and instead of a full screen sliding in, a smaller panel appears from the bottom, covering only part of the screen. This panel might ask you to choose an option (like "Edit," "Delete," "Cancel") or present a short form without obscuring the content behind it completely.

<br>

<p align="center">
  <img src="https://docs.flutter.dev/assets/images/flutter-for-web/modal-dialogs/cupertino-action-sheet.gif" alt="Example of a Cupertino Action Sheet" style="width: 300px;">
  <br>
  <em>Think of this kind of panel popping up from the bottom.</em>
</p>

<br>

`CupertinoModalPopupRoute` is Flutter's `PageRoute` specifically designed for creating and managing these types of non-fullscreen, bottom-sliding modal pop-ups in the iOS style. It defines how they appear, how they animate onto the screen, and how they behave (like whether tapping outside dismisses them).

It's different from a regular `CupertinoPageRoute` because:

1.  It typically only covers *part* of the screen, not the whole thing.
2.  It animates up from the *bottom*, not sliding horizontally from the side.
3.  It's often used for transient interfaces like action sheets or simple choices, where the user quickly interacts and the panel is dismissed.

**Motivation:** We want to show a simple panel sliding up from the bottom of the screen to present a choice or action, using the native iOS style for such pop-ups. We don't want a fullscreen transition like with `CupertinoPageRoute`.

### Using CupertinoModalPopupRoute

You won't usually create a `CupertinoModalPopupRoute` directly using `Navigator.push`. Instead, Flutter provides a helper function, `showCupertinoModalPopup`, which is specifically designed to show these types of pop-ups and internally creates a `CupertinoModalPopupRoute` for you. This is the easiest and most common way to use this concept.

Let's create a simple example where tapping a button shows a small panel with some text popping up from the bottom. We'll use `showCupertinoModalPopup`.

First, make sure you have the Cupertino design package imported:

```dart
import 'package:flutter/cupertino.dart';
import 'package:flutter/material.dart'; // Still useful for things like Scaffold and Button in examples

// ... rest of MyApp, HomeScreen, NewScreen classes ...
```

Now, let's modify our `HomeScreen`'s button `onPressed`:

```dart
// ... inside HomeScreen onPressed ...
onPressed: () {
  showCupertinoModalPopup<void>( // Use the helper function!
    context: context,
    builder: (BuildContext context) {
      return CupertinoAlertDialog( // Example widget for the popup content
        title: const Text('Popup Title'),
        content: const Text('This panel popped up from the bottom!'),
        actions: <CupertinoDialogAction>[
          CupertinoDialogAction(
            child: const Text('OK'),
            onPressed: () {
              Navigator.pop(context); // Dismiss the popup
            },
          ),
        ],
      );
    },
  );
},
// ... rest of HomeScreen ...
```

Let's break this down:

1.  **`showCupertinoModalPopup<void>(...)`**: This is the function provided by Flutter for showing these modal pop-ups. The `<void>` indicates that this popup doesn't return a specific result value when dismissed (like a dialog might).
2.  **`context: context`**: We pass the current `BuildContext` so the function knows where in the widget tree to show the popup.
3.  **`builder: (BuildContext context) { ... }`**: Similar to other route builders, this function is responsible for creating the widget that will be displayed inside the modal popup.
4.  **`return CupertinoAlertDialog(...)`**: Inside the builder, we return the widget that will be the content of our bottom popup. Here, we're using a `CupertinoAlertDialog` as a simple example, but you could return a `CupertinoActionSheet` (a very common use case for this route) or any other widget you want to appear in that modal panel.
5.  **`Navigator.pop(context)`**: This is how you dismiss the modal popup. Tapping the 'OK' button calls `Navigator.pop`, which removes the `CupertinoModalPopupRoute` from the navigation stack and animates it back down.

Now, when you tap "Go to New Screen" (or whatever your button says), a `CupertinoAlertDialog` (which is configured to be presented in an iOS modal style by `CupertinoModalPopupRoute`) will slide up from the bottom of the screen!

Other common properties you might pass to `showCupertinoModalPopup`:

*   `barrierDismissible: true` (default): Allows tapping the dark area outside the popup to dismiss it. Set to `false` to require an action within the popup to close it.
*   `barrierColor`: Sets the color of the dark overlay behind the popup.

### How it Works Under the Hood (Simplified)

When you call `showCupertinoModalPopup`, here's a simplified idea of what happens, leading to the creation of a `CupertinoModalPopupRoute`:

```mermaid
sequenceDiagram
    participant Button as Button Widget
    participant Screen as Your Screen Widget
    participant showCupertinoModalPopup as showCupertinoModalPopup Function
    participant Navigator as Navigator
    participant CMP_Route as CupertinoModalPopupRoute
    participant PopupWidget as Your Popup Widget (e.g., CupertinoAlertDialog)

    Button->Screen: calls onPressed
    Screen->showCupertinoModalPopup: calls showCupertinoModalPopup(...)
    showCupertinoModalPopup->CMP_Route: creates new CupertinoModalPopupRoute(...)
    showCupertinoModalPopup->Navigator: calls Navigator.push(context, CMP_Route)
    Navigator->CMP_Route: asks to build page content and transitions
    CMP_Route->CMP_Route: calls builder() to create PopupWidget
    CMP_Route->CMP_Route: applies transition logic (slide up from bottom)
    Navigator->Navigator: Prepares and orchestrates
    Navigator->PopupWidget: Builds and animates PopupWidget into view
```

The `showCupertinoModalPopup` function is a convenient wrapper. Its main job is to create a `CupertinoModalPopupRoute` and push it onto the Navigator's stack.

Let's look at the `CupertinoModalPopupRoute` definition in `packages/flutter/lib/src/cupertino/route.dart`:

```dart
// Simplified structure of CupertinoModalPopupRoute

class CupertinoModalPopupRoute<T> extends PopupRoute<T> {
  // ... constructor ...

  final WidgetBuilder builder; // Your builder function goes here

  @override
  Duration get transitionDuration => _kModalPopupTransitionDuration; // Defines animation speed

  @override
  Widget buildPage( // Builds the content of the popup
    BuildContext context,
    Animation<double> animation,
    Animation<double> secondaryAnimation,
  ) {
    // Calls your builder to get the widget for the popup content
    return CupertinoUserInterfaceLevel( // Often adds an elevation effect
      data: CupertinoUserInterfaceLevelData.elevated,
      child: Builder(builder: builder), // Runs your builder function
    );
  }

  @override
  Widget buildTransitions( // Defines how the popup animates
    BuildContext context,
    Animation<double> animation, // Animation from 0.0 to 1.0
    Animation<double> secondaryAnimation,
    Widget child, // The widget built by buildPage (your popup content)
  ) {
    // This wraps the child with a translation effect based on the animation
    return Align( // Centers the child horizontally at the bottom
      alignment: Alignment.bottomCenter,
      child: FractionalTranslation( // Moves the child based on animation
        translation: _offsetTween.evaluate(animation), // Uses a Tween to slide up
        child: child, // Your popup widget
      ),
    );
  }

  static final Tween<Offset> _offsetTween = Tween<Offset>(
    begin: const Offset(0.0, 1.0), // Start off-screen below (0% from left, 100% from top)
    end: Offset.zero, // End on-screen (0% from left, 0% from top relative to Align)
  );

  // ... other properties like barrierColor, barrierDismissible ...
}
```

Here's the key internal logic:

1.  `CupertinoModalPopupRoute` extends `PopupRoute` (a base class for routes that overlay the current content, like dialogs and menus).
2.  Your `builder` function is stored and called inside `buildPage` to create the content of the modal popup (`PopupWidget` in our diagram).
3.  The `buildTransitions` method is where the visual magic happens. It wraps the `child` (your popup widget) with an `Align` widget to horizontally center it at the bottom of the screen.
4.  It then uses a `FractionalTranslation` and our `_offsetTween`. This `_offsetTween` is defined to go from `Offset(0.0, 1.0)` (meaning 0% horizontally and 100% vertically *relative to the bottom-aligned position*) to `Offset.zero` (meaning 0% horizontal and 0% vertical translation).
5.  As the `animation` goes from 0.0 to 1.0, `_offsetTween.evaluate(animation)` calculates the intermediate offset. When the animation is 0.0, the offset is `(0.0, 1.0)`, placing the widget off-screen below. When the animation reaches 1.0, the offset is `(0.0, 0.0)`, placing the widget at the bottom-center, fully visible. This creates the smooth slide-up effect.

Unlike regular `CupertinoPageRoute` which uses mixins and dedicated transition widgets like `CupertinoPageTransition`, `CupertinoModalPopupRoute` implements its specific bottom-up transition directly within its `buildTransitions` method using simpler animation widgets like `FractionalTranslation`.

### Conclusion

`CupertinoModalPopupRoute` is a specialized `PageRoute` for implementing the signature iOS-style modal panels that slide up from the bottom, such as action sheets. While you typically interact with it via the helper function `showCupertinoModalPopup`, understanding the route itself shows how it uses its `builder` for content and defines a non-fullscreen, bottom-up animation within its `buildTransitions` method using basic animation widgets to achieve its effect.

In the next chapter, we'll look at `CupertinoDialogRoute`, which is specifically for showing iOS-style alert dialogs that appear in the center of the screen.

[Next Chapter: CupertinoDialogRoute](09_cupertinodialogroute_.md)
2025-05-21 12:33:24,777 - INFO - PROMPT: 
Write a very beginner-friendly tutorial chapter (in Markdown format) for the project `flutter` about the concept: "CupertinoDialogRoute
". This is Chapter 9.

Concept Details:
- Name: CupertinoDialogRoute

- Description:
This is the route for showing those classic iOS-style alert boxes that appear in the center of the screen asking for confirmation or providing important information. It manages the subtle fade-in and scaling animation for these dialogs and handles things like the dimmed background behind the dialog.


Complete Tutorial Structure:
1. [PageRoute
](01_pageroute_.md)
2. [MaterialPageRoute
](02_materialpageroute_.md)
3. [MaterialRouteTransitionMixin
](03_materialroutetransitionmixin_.md)
4. [CupertinoPageRoute
](04_cupertinopageroute_.md)
5. [CupertinoRouteTransitionMixin
](05_cupertinoroutetransitionmixin_.md)
6. [CupertinoPageTransition
](06_cupertinopagetransition_.md)
7. [CupertinoFullscreenDialogTransition
](07_cupertinofullscreendialogtransition_.md)
8. [CupertinoModalPopupRoute
](08_cupertinomodalpopuproute_.md)
9. [CupertinoDialogRoute
](09_cupertinodialogroute_.md)

Context from previous chapters:
# Chapter 1: PageRoute

Welcome to the first chapter of our Flutter navigation tutorial! Ever wonder how tapping a button in an app seamlessly takes you to a completely different screen? That's where the magic of navigation comes in! In Flutter, a core concept for managing these screen transitions is the `PageRoute`.

Imagine your Flutter app is like a building with many rooms (screens). When you want to go from one room (the "lobby") to another room (the "settings" screen), you need a plan or a map to get there. A `PageRoute` is exactly that – it's the blueprint, the plan, for a single "page" or screen in your app and how you would transition *to* it.

Think of it as defining:

*   **What the new screen looks like:** What widgets make up this new page?
*   **How the transition happens:** Does it slide from the side, fade in, or something else?
*   **How long the transition takes:** Is it a quick change or a smooth, longer one?
*   **Its behavior:** Can you easily "go back" or dismiss this screen?

The `PageRoute` doesn't *perform* the transition itself; it tells the `Navigator` (Flutter's system for managing screen stacks, like stacking rooms on top of each other) *how* to perform the transition to display its content.

### Our Goal: Showing a Simple New Screen

Throughout this chapter, our goal is to understand enough about `PageRoute` to accomplish a very common task: navigating from one simple screen to another.

Let's start with a basic example. We'll have a main screen with a button. When you tap the button, we want to go to a new, blank screen.

Here's a simplified look at what we might have initially:

```dart
import 'package:flutter/material.dart';

void main() {
  runApp(MyApp());
}

class MyApp extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return MaterialApp(
      home: HomeScreen(),
    );
  }
}

class HomeScreen extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(title: Text('Home Screen')),
      body: Center(
        child: ElevatedButton(
          onPressed: () {
            // We want to go to a new screen here!
          },
          child: Text('Go to New Screen'),
        ),
      ),
    );
  }
}

class NewScreen extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(title: Text('New Screen')),
      body: Center(
        child: Text('Welcome to the new screen!'),
      ),
    );
  }
}
```

In this code, we have `HomeScreen` and `NewScreen`. Our challenge is to connect the button on `HomeScreen` to show `NewScreen`. We need a `PageRoute` for `NewScreen`.

### Understanding PageRoute with PageRouteBuilder

Directly creating a raw `PageRoute` can be a bit advanced for our first step. Flutter provides a helpful class called `PageRouteBuilder` which lets us create a simple `PageRoute` using functions (callbacks). This is perfect for defining basic routes without creating a whole new class.

Let's look at how we can use `PageRouteBuilder` inside the `onPressed` of our `ElevatedButton`:

```dart
// ... inside HomeScreen onPressed ...
onPressed: () {
  Navigator.push(
    context,
    PageRouteBuilder( // Using PageRouteBuilder to define our route
      pageBuilder: (context, animation, secondaryAnimation) {
        // This function builds the actual screen content
        return NewScreen();
      },
      transitionsBuilder: (context, animation, secondaryAnimation, child) {
        // This function defines how the transition looks
        // For now, we'll do a simple fade transition as an example
        return FadeTransition(
          opacity: animation, // Controls the opacity of the new page
          child: child,
        );
      },
      transitionDuration: Duration(milliseconds: 500), // How long the transition takes
    ),
  );
},
// ... rest of HomeScreen ...
```

Let's break down what's happening here:

1.  **`Navigator.push(context, ...)`**: This is how we tell Flutter's navigation system to add a new screen on top of the current one. `context` tells the Navigator where we are in the widget tree.
2.  **`PageRouteBuilder(...)`**: We create an instance of `PageRouteBuilder` to define the characteristics of the new route.
3.  **`pageBuilder: (context, animation, secondaryAnimation) { return NewScreen(); }`**: This is a required function that `PageRouteBuilder` needs. It tells the builder *what* widget tree to display for this page. In our case, it's just our `NewScreen` widget. The `animation` and `secondaryAnimation` parameters are for transition animations, which we'll use in the next part.
4.  **`transitionsBuilder: (context, animation, secondaryAnimation, child) { ... }`**: This optional function defines how the transition *looks*. It takes the context, `animation` (for the incoming page), `secondaryAnimation` (for the outgoing page), and the `child` (which is the widget built by `pageBuilder`). We use a `FadeTransition` here, animating the `opacity` of the incoming page using the `animation` provided.
5.  **`transitionDuration: Duration(milliseconds: 500)`**: This sets how long the transition animation should take.

Now, when you tap the button, the `Navigator` will use this `PageRouteBuilder` to create a `PageRoute`, push it onto the navigation stack, and animate to the `NewScreen` using a 500ms fade effect.

### How it Works Under the Hood (Simplified)

Let's look at a slightly simplified view of what happens when you call `Navigator.push` with a `PageRoute`:

```mermaid
sequenceDiagram
    participant Button as Button Widget
    participant HomeScreen as HomeScreen Widget
    participant Navigator as Navigator
    participant PageRoute as PageRouteBuilder
    participant NewScreen as NewScreen Widget

    Button->HomeScreen: calls onPressed
    HomeScreen->Navigator: calls push(context, PageRoute)
    Navigator->PageRoute: asks for the page content and transitions
    PageRoute->PageRoute: uses pageBuilder to create NewScreen widget
    PageRoute->PageRoute: uses transitionsBuilder to wrap NewScreen with transition widgets
    Navigator->Navigator: Prepares
    Navigator->NewScreen: Builds and animates the transition
```

Essentially, the `Navigator` is like the conductor of an orchestra. You hand it a `PageRoute`, and it orchestrates the process of showing the new screen, including running the transitions defined by the `PageRoute`.

Inside the Flutter framework code for `PageRoute` (like in `packages/flutter/lib/src/widgets/pages.dart`), you'll find methods like `buildPage` and `buildTransitions`. These are the core parts that `PageRouteBuilder` uses its functions (`pageBuilder` and `transitionsBuilder`) to implement:

```dart
// Simplified example from PageRoute (similar to what PageRouteBuilder does internally)
abstract class PageRoute<T> extends ModalRoute<T> {
  // ... other properties ...

  // The PageRoute needs to know how to build the main content
  Widget buildPage(BuildContext context, Animation<double> animation, Animation<double> secondaryAnimation);

  // The PageRoute needs to know how to build the transitions
  Widget buildTransitions(BuildContext context, Animation<double> animation, Animation<double> secondaryAnimation, Widget child);

  // ... more methods for duration, color, etc. ...
}
```

`PageRouteBuilder` fills in these `buildPage` and `buildTransitions` methods using the functions you provide.

### Conclusion

In this chapter, we learned that a `PageRoute` is the fundamental concept in Flutter navigation that defines how a new screen is presented. We saw how to use `PageRouteBuilder` to create a simple `PageRoute` by specifying what the new screen looks like and how the transition should appear.

While `PageRouteBuilder` is great for simple custom transitions, Flutter provides pre-built `PageRoute` implementations for common design patterns, like the Material Design page transitions and the Cupertino (iOS) page transitions. These include standard animations and behaviors.

In the next chapter, we'll dive into one of these standard implementations: [MaterialPageRoute](02_materialpageroute_.md), which provides the familiar animations you see in Android apps.

[Next Chapter: MaterialPageRoute](02_materialpageroute_.md)
---
# Chapter 2: MaterialPageRoute

Welcome back! In [Chapter 1: PageRoute](01_pageroute_.md), we learned that a `PageRoute` is the blueprint for displaying a new screen and defining its transition. We saw how `PageRouteBuilder` let us create custom routes with animations.

Now, let's explore a really common and useful type of `PageRoute` used in Flutter apps that follow Google's Material Design: the `MaterialPageRoute`.

### What is MaterialPageRoute?

If you've ever used an Android phone, you've likely seen specific ways new screens appear when you tap something – often, they fade in and zoom slightly. `MaterialPageRoute` is designed to give you that native Android look and feel for your screen transitions, *automatically*.

Think of it as a pre-made `PageRoute` specifically built for Material Design. Instead of defining the fade/zoom transition yourself with `PageRouteBuilder`, `MaterialPageRoute` handles it for you.

But here's a cool trick: `MaterialPageRoute` is also platform-adaptive! This means that if you run your app on an iOS device, it will automatically use the standard iOS slide-from-the-right transition. You get the right native feel on both Android and iOS with just one `MaterialPageRoute`!

**Motivation:** We want to navigate from our `HomeScreen` to our `NewScreen` using the standard Material Design (Android-style) transitions on Android and the standard Cupertino (iOS-style) transitions on iOS, without manually building the transition animation ourselves.

### Using MaterialPageRoute

Using `MaterialPageRoute` is much simpler than `PageRouteBuilder` for standard transitions. You just need to tell it *what* screen to build.

Let's go back to our
`HomeScreen` button's `onPressed` and replace the `PageRouteBuilder` with a `MaterialPageRoute`:

```dart
// ... inside HomeScreen onPressed ...
onPressed: () {
  Navigator.push(
    context,
    MaterialPageRoute( // Using MaterialPageRoute!
      builder: (context) {
        // Just provide the widget for the new screen
        return NewScreen();
      },
    ),
  );
},
// ... rest of HomeScreen ...
```

That's it! Notice how much simpler it is?

*   We still use `Navigator.push` to initiate the navigation.
*   We create a `MaterialPageRoute` instance.
*   We provide a `builder` function, which is similar to `pageBuilder` in `PageRouteBuilder`. This function simply returns the widget for the new screen (`NewScreen`).
*   We *don't* need to specify a `transitionsBuilder` or `transitionDuration` explicitly. `MaterialPageRoute` uses default ones suitable for Material Design, chosen automatically based on the device's operating system.

Now, when you tap the button:
*   On an Android device, `NewScreen` will fade in and slightly zoom.
*   On an iOS device, `NewScreen` will slide in from the right.

### How it Works Under the Hood (Simplified)

When you use `MaterialPageRoute`, like with any `PageRoute`, you hand it to the `Navigator`.

```mermaid
sequenceDiagram
    participant Button as Button Widget
    participant HomeScreen as HomeScreen Widget
    participant Navigator as Navigator
    participant MaterialPageRoute as MaterialPageRoute
    participant NewScreen as NewScreen Widget
    participant Theme as Theme Data

    Button->HomeScreen: calls onPressed
    HomeScreen->Navigator: calls push(context, MaterialPageRoute)
    Navigator->MaterialPageRoute: asks for page content and transitions
    MaterialPageRoute->MaterialPageRoute: calls builder() to create NewScreen widget
    MaterialPageRoute->Theme: checks current platform (Android/iOS)
    MaterialPageRoute->MaterialPageRoute: selects relevant transition based on platform
    MaterialPageRoute->NewScreen: Builds and wraps with selected transition widgets
    Navigator->Navigator: Prepares
    Navigator->NewScreen: Animates the transition
```

The key difference from using `PageRouteBuilder` with a custom fade is that `MaterialPageRoute` internally checks the theme and the platform to pick the right animation blueprint.

Let's peek into the Flutter framework code for `MaterialPageRoute` in `packages/flutter/lib/src/material/page.dart`.

You'll see the `MaterialPageRoute` class definition inherits from `PageRoute` and also uses something called `MaterialRouteTransitionMixin` (we'll talk about mixins more later, but for now, think of it as sharing helpful code).

```dart
// Simplified from packages/flutter/lib/src/material/page.dart
class MaterialPageRoute<T> extends PageRoute<T> with MaterialRouteTransitionMixin<T> {
  // ... constructor and other properties ...

  /// Builds the primary contents of the route.
  final WidgetBuilder builder; // This holds the function you passed in!

  @override
  Widget buildContent(BuildContext context) => builder(context); // Uses your builder

  // ... other overrides ...
}
```

The `buildContent` method is where your `builder` function is called to create the `NewScreen` widget.

Where does the platform-adaptive transition logic come from? It's mostly handled by the `MaterialRouteTransitionMixin` and interacts with Flutter's `Theme` and `PageTransitionsTheme`.

```dart
// Simplified/conceptual example from MaterialRouteTransitionMixin
mixin MaterialRouteTransitionMixin<T> on PageRoute<T> {
  // ... other properties ...

  @override
  Widget buildTransitions( // This is where the transition is built!
    BuildContext context,
    Animation<double> animation,
    Animation<double> secondaryAnimation,
    Widget child, // This 'child' is the widget from buildContent (your NewScreen)
  ) {
    // Internally looks at Theme.of(context).platform (Android or iOS)
    // Then looks up the correct transition from Theme.of(context).pageTransitionsTheme
    // Returns the correct transition widget (like a FadeTransition for Android,
    // or a SlideTransition for iOS) wrapping the 'child' (your screen).
    final PageTransitionsTheme theme = Theme.of(context).pageTransitionsTheme;
    return theme.buildTransitions<T>(this, context, animation, secondaryAnimation, child);
  }

  // ... other properties like transitionDuration ...
}
```

So, `MaterialPageRoute` uses the `builder` you provide to show the content and relies on the `MaterialRouteTransitionMixin` (and Flutter's theming system) to automatically select and apply the right transition animation based on the device's platform.

### Conclusion

`MaterialPageRoute` is your go-to `PageRoute` when you want standard Material Design page transitions (fade/zoom on Android, slide on iOS) without needing to manually define the animations. It simplifies the process of creating new routes by providing sensible defaults that match platform conventions. It's a foundational component for navigation in many Flutter applications.

In the next chapter, we'll take a brief look at the `MaterialRouteTransitionMixin` itself, which is the piece that provides the magic platform-adaptive transitions for `MaterialPageRoute`.

[Next Chapter: MaterialRouteTransitionMixin](03_materialroutetransitionmixin_.md)
---
# Chapter 3: MaterialRouteTransitionMixin

Welcome back! In [Chapter 2: MaterialPageRoute](02_materialpageroute_.md), we learned how `MaterialPageRoute` gives us those sweet, platform-adaptive screen transitions (fade/zoom on Android, slide on iOS) without us having to code the animations ourselves.

We briefly saw that the code for `MaterialPageRoute` includes something called `with MaterialRouteTransitionMixin`. This chapter is about that `MaterialRouteTransitionMixin`.

### What is MaterialRouteTransitionMixin?

Imagine you have a recipe for delicious cookies. The recipe lists all the ingredients and the steps. A "mixin" in Flutter is like a list of extra ingredients and techniques you can add to your recipe to make it special.

`MaterialRouteTransitionMixin` is not a complete recipe (it's not a full `PageRoute` itself), but it's a collection of "ingredients" and "techniques" specifically for creating **Material Design page transitions** that adapt to the platform.

It provides the core logic for:

1.  **How long** the transition should take (duration).
2.  **How the animation looks** (the transition effect itself, like fading or sliding).
3.  **How this route interacts** with other routes during transitions (can they transition together smoothly?).

Essentially, `MaterialRouteTransitionMixin` is the helper that `MaterialPageRoute` uses to get its standard, platform-adaptive transition behavior. It's what makes `MaterialPageRoute` special!

You won't usually create a `MaterialRouteTransitionMixin` directly. Instead, you'll see other `PageRoute` implementations (like `MaterialPageRoute`) "mix it in" to gain its transition capabilities.

**Motivation:** Our goal is to understand where the automatic, platform-adaptive transition logic in `MaterialPageRoute` comes from. It comes from `MaterialRouteTransitionMixin`.

### How Mixins Work (Simply)

Think of a mixin as a way to share code between different classes without using traditional inheritance (like a child class inheriting from a parent class).

If you have `ClassA` and `MixinB`, `ClassA` can use `MixinB`'s methods and properties by saying `class ClassA with MixinB`. It's like `ClassA` is adding `MixinB`'s features to itself.

In our case, `MaterialPageRoute` is a class, and it uses `MaterialRouteTransitionMixin` like this:

```dart
// Simplified
class MaterialPageRoute<T> extends PageRoute<T> with MaterialRouteTransitionMixin<T> {
  // MaterialPageRoute now has access to the methods inside MaterialRouteTransitionMixin
  // ... rest of MaterialPageRoute code ...
}
```

By using `with MaterialRouteTransitionMixin`, `MaterialPageRoute` automatically gains the `buildTransitions` method and other transition-related logic defined within the mixin.

### How it Connects to Building Transitions

Remember in [Chapter 1: PageRoute](01_pageroute_.md), we saw that a `PageRoute` needs to implement a `buildTransitions` method to define how the animation looks?

`MaterialRouteTransitionMixin` provides the **implementation** for this crucial `buildTransitions` method for Material Design transitions.

When `Navigator.push` is called with a `MaterialPageRoute`, the Navigator asks the `MaterialPageRoute` (which uses `MaterialRouteTransitionMixin`'s logic) to build the transition widget tree.

Here's a look inside the mixin (simplified):

```dart
// Simplified/conceptual example from packages/flutter/lib/src/material/page.dart
mixin MaterialRouteTransitionMixin<T> on PageRoute<T> {
  // ... other properties like transitionDuration ...

  @override
  Widget buildTransitions( // This method is provided by the mixin!
    BuildContext context,
    Animation<double> animation, // Animation for the incoming page
    Animation<double> secondaryAnimation, // Animation for the outgoing page
    Widget child, // The actual content of the page (your NewScreen)
  ) {
    // Inside here, the mixin's code runs.
    // It checks the platform (Android/iOS) using Theme.of(context).platform.
    // It looks up the correct transition animation based on the platform
    // from the PageTransitionsTheme.
    // It returns the chosen animation widget (like FadeTransition or SlideTransition)
    // wrapping the 'child' (your NewScreen widget).

    // This line is the core – it asks the Theme for the right transition!
    final PageTransitionsTheme theme = Theme.of(context).pageTransitionsTheme;
    return theme.buildTransitions<T>(this, context, animation, secondaryAnimation, child);
  }

  // ... other methods ...
}
```

So, `MaterialRouteTransitionMixin` contains the `buildTransitions` method that looks at the current `Theme` (which knows the platform) and asks the `PageTransitionsTheme` within the `Theme` to provide the actual transition widget code.

This design is clever because:
*   `MaterialPageRoute` handles knowing *what* screen to show (`builder`).
*   `MaterialRouteTransitionMixin` handles knowing *how* to transition, querying the `Theme` for the platform-specific implementation.
*   The `PageTransitionsTheme` holds the actual animation builders (like the code for the fade/zoom or the slide animations).

This separation of concerns makes the code more organized and maintainable!

### You Don't Use It Directly (Usually)

As a beginner, you won't typically need to directly use `MaterialRouteTransitionMixin`. Its purpose is to provide the transition logic *to* classes like `MaterialPageRoute`. When you use `MaterialPageRoute`, you are indirectly benefiting from the code in `MaterialRouteTransitionMixin`.

Think of it like buying a car. You use the steering wheel and pedals (`MaterialPageRoute`), and the engine ("mixin") makes it go, but you don't interact directly with the engine parts every time you drive.

### Conclusion

`MaterialRouteTransitionMixin` is a key piece of the puzzle behind `MaterialPageRoute`'s automatic, platform-adaptive transitions. It provides the core logic for determining transition duration and building the correct transition animation based on the device's operating system by interacting with the Flutter `Theme` system. While you won't often use it directly, understanding its role helps clarify how `MaterialPageRoute` works.

In the next chapter, we'll shift our focus to the iOS side of things and introduce `CupertinoPageRoute`, which is the counterpart to `MaterialPageRoute` for Cupertino (iOS) design.

[Next Chapter: CupertinoPageRoute](04_cupertinopageroute_.md)
---
# Chapter 4: CupertinoPageRoute

Welcome back, future Flutter navigators! In [Chapter 3: MaterialRouteTransitionMixin](03_materialroutetransitionmixin_.md), we explored how `MaterialRouteTransitionMixin` is the helper that gives `MaterialPageRoute` its cool, platform-adaptive animations. Now, let's turn our attention to the world of Apple's iOS design with `CupertinoPageRoute`.

### What is CupertinoPageRoute?

If you've ever used an iPhone or iPad, you've seen specific ways new screens slide into view, often from the right side of the screen, and how they slide back out when you go back. `CupertinoPageRoute` is Flutter's way of giving you that exact native iOS look and feel for your screen transitions, automatically!

Just like `MaterialPageRoute` is a pre-made blueprint for Material Design transitions, `CupertinoPageRoute` is a pre-made blueprint specifically built for Cupertino (iOS) design. It handles the characteristic sliding animations and other iOS visual cues when you navigate between pages.

**Motivation:** Our goal is to navigate from our `HomeScreen` to our `NewScreen` using the standard iOS slide-from-the-right transition when running on an iOS device, in a way that is natural and expected for iOS users.

### Using CupertinoPageRoute

Using `CupertinoPageRoute` is very similar to using `MaterialPageRoute`. You simply tell it which widget represents the new screen.

Let's go back to our `HomeScreen` button's `onPressed` and replace the `MaterialPageRoute` with a `CupertinoPageRoute`:

```dart
import 'package:flutter/cupertino.dart'; // Import Cupertino widgets!
import 'package:flutter/material.dart'; // Still need Material for Scaffold, AppBar, etc.

// ... rest of MyApp and HomeScreen classes ...

class HomeScreen extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return Scaffold( // Using Material Scaffold for simplicity in this example
      appBar: AppBar(title: Text('Home Screen')),
      body: Center(
        child: ElevatedButton(
          onPressed: () {
            Navigator.push(
              context,
              CupertinoPageRoute( // Using CupertinoPageRoute!
                builder: (context) {
                  // Just provide the widget for the new screen
                  return NewScreen();
                },
              ),
            );
          },
          child: Text('Go to New Screen'),
        ),
      ),
    );
  }
}

// ... rest of NewScreen class ...
```

See the difference? We changed `MaterialPageRoute` to `CupertinoPageRoute` and made sure to import `flutter/cupertino.dart`.

Now, when you tap the button:

*   On an iOS device, `NewScreen` will smoothly slide in from the right, with the previous screen slightly moving to the left (a parallax effect). When you go back, it slides out to the right.
*   On an Android device, because we're using a `CupertinoPageRoute`, it will *still* try to use the Cupertino (iOS) style transition, even though it's running on Android. This is different from `MaterialPageRoute` which is platform-adaptive. If you want platform-adaptive behavior, `MaterialPageRoute` is often the better choice. `CupertinoPageRoute` is primarily for building apps that *always* have the iOS feel.

### How it Works Under the Hood (Simplified)

When you use `CupertinoPageRoute`, you hand it to the `Navigator` just like any other `PageRoute`.

```mermaid
sequenceDiagram
    participant Button as Button Widget
    participant HomeScreen as HomeScreen Widget
    participant Navigator as Navigator
    participant CupertinoPageRoute as CupertinoPageRoute
    participant NewScreen as NewScreen Widget
    participant iOS Theme as iOS Theme Data (Conceptual)

    Button->HomeScreen: calls onPressed
    HomeScreen->Navigator: calls push(context, CupertinoPageRoute)
    Navigator->CupertinoPageRoute: asks for page content and transitions
    CupertinoPageRoute->CupertinoPageRoute: calls builder() to create NewScreen widget
    CupertinoPageRoute->iOS Theme: Requests iOS-style transition details
    CupertinoPageRoute->CupertinoPageRoute: Uses transition logic from mixin
    CupertinoPageRoute->NewScreen: Builds and wraps with Cupertino transition widgets
    Navigator->Navigator: Prepares
    Navigator->NewScreen: Animates the transition (iOS style)
```

The process is very similar to `MaterialPageRoute`, but instead of checking the general platform to pick between Material and Cupertino, `CupertinoPageRoute` *always* uses the Cupertino style transition logic.

Let's peek into the Flutter framework code for `CupertinoPageRoute` in `packages/flutter/lib/src/cupertino/route.dart`.

You'll find the `CupertinoPageRoute` class definition inherits from `PageRoute` and, just like `MaterialPageRoute` uses a mixin for its transitions, `CupertinoPageRoute` uses something similar: `CupertinoRouteTransitionMixin`.

```dart
// Simplified from packages/flutter/lib/src/cupertino/route.dart
class CupertinoPageRoute<T> extends PageRoute<T> with CupertinoRouteTransitionMixin<T> {
  // ... constructor and other properties ...

  /// Builds the primary contents of the route.
  final WidgetBuilder builder; // This holds the function you passed in!

  @override
  Widget buildContent(BuildContext context) => builder(context); // Uses your builder

  // ... other overrides ...
}
```

Similar to `MaterialPageRoute`, `CupertinoPageRoute` takes your `builder` function and calls its `buildContent` method to create the widget for the new page.

The iOS-style transition magic (the sliding from the right, the parallax effect) comes from the `CupertinoRouteTransitionMixin` that is mixed into `CupertinoPageRoute`. This mixin implements the `buildTransitions` method using specific iOS animations:

```dart
// Simplified/conceptual example from CupertinoRouteTransitionMixin
mixin CupertinoRouteTransitionMixin<T> on PageRoute<T> {
  // ... other properties like transitionDuration ...

  @override
  Widget buildTransitions( // This method is provided by the mixin!
    BuildContext context,
    Animation<double> animation, // Animation for the incoming page
    Animation<double> secondaryAnimation, // Animation for the outgoing page
    Widget child, // The actual content of the page (your NewScreen)
  ) {
    // Inside here, the mixin's code runs.
    // It builds specific iOS transition widgets...
    // For normal pages, it uses CupertinoPageTransition.
    // For fullscreen dialogs, it uses CupertinoFullscreenDialogTransition.
    // It uses the animations (primaryRouteAnimation and secondaryRouteAnimation)
    // and wraps the 'child' (your NewScreen widget) with them.

    // A simplified call to the actual transition builder:
    return buildPageTransitions<T>(this, context, animation, secondaryAnimation, child);
  }

  // ... other methods ...
}
```

When the `Navigator` needs to show `CupertinoPageRoute`, it asks the route to `buildTransitions`. `CupertinoPageRoute` uses the `buildTransitions` method from `CupertinoRouteTransitionMixin`. This mixin then uses dedicated transition widgets like `CupertinoPageTransition` to create the visually distinct iOS sliding effect, using the provided `animation` objects to control the movement. We'll learn more about `CupertinoPageTransition` in a later chapter.

`CupertinoPageRoute` also has support for distinguishing between regular page transitions and fullscreen dialog transitions (like presenting a modal from the bottom on iOS), using different animation styles for each case, which is also handled by the `CupertinoRouteTransitionMixin`.

### Conclusion

`CupertinoPageRoute` is the specialized `PageRoute` for bringing the native iOS page transition experience (sliding from the right, parallax effect) to your Flutter apps, regardless of the actual device platform. It uses the `CupertinoRouteTransitionMixin` to manage the transition logic and apply the appropriate iOS-style animations. While `MaterialPageRoute` is usually preferred for platform-adaptive behavior in a single codebase, `CupertinoPageRoute` is perfect when you want a consistent iOS feel.

In the next chapter, we'll dive deeper into the `CupertinoRouteTransitionMixin` itself, similar to how we looked at its Material counterpart, to see exactly where this iOS transition magic comes from.

[Next Chapter: CupertinoRouteTransitionMixin](05_cupertinoroutetransitionmixin_.md)
---
# Chapter 5: CupertinoRouteTransitionMixin

Welcome back! In [Chapter 4: CupertinoPageRoute](04_cupertinopageroute_.md), we learned how `CupertinoPageRoute` helps us create iOS-style screen transitions automatically, giving our apps that native slide-from-the-right feel. We also briefly saw that `CupertinoPageRoute` uses something called `CupertinoRouteTransitionMixin` to get this behavior.

Now, it's time to shine a spotlight on the `CupertinoRouteTransitionMixin` itself!

### What is CupertinoRouteTransitionMixin?

Just like `MaterialRouteTransitionMixin` is the special recipe additive for Material Design transitions, `CupertinoRouteTransitionMixin` is the recipe additive for **Cupertino (iOS) page transitions**.

It's not a full `PageRoute` on its own, but it contains the vital instructions and ingredients needed to create the signature iOS sliding and fading animations for transitioning between screens.

Think of it as providing the "animation logic" that a `PageRoute` can use. Instead of writing the complex code to make a widget slide from the right and have the old page slightly move left (that parallax effect!), you can "mix in" `CupertinoRouteTransitionMixin` to automatically get that behavior.

It provides the core logic for:

1.  **How long** the transition takes (its duration).
2.  **How the animation fundamentally looks** (the sliding, the fading).
3.  **How it behaves** during interactive gestures, like swiping back from the edge of the screen on iOS.

`CupertinoPageRoute` itself uses `CupertinoRouteTransitionMixin` to implement its `buildTransitions` method, which is the core piece that tells the Navigator how to animate the new screen into view.

**Motivation:** We want to understand where the charming iOS sliding and parallax animations come from when we use `CupertinoPageRoute`. They come from `CupertinoRouteTransitionMixin`.

### How Mixins Work (A Quick Reminder)

As we talked about with `MaterialRouteTransitionMixin`, a mixin is a way to add a set of properties and methods from one class-like structure into another class, without needing traditional inheritance.

When a class `mixes in` a mixin, it gains all the public members of that mixin as if they were defined directly in the class itself.

`CupertinoPageRoute` uses `CupertinoRouteTransitionMixin` like this:

```dart
// Simplified from packages/flutter/lib/src/cupertino/route.dart
class CupertinoPageRoute<T> extends PageRoute<T> with CupertinoRouteTransitionMixin<T> {
  // CupertinoPageRoute now automatically has the buildTransitions method
  // and other properties defined in CupertinoRouteTransitionMixin
  // ... rest of CupertinoPageRoute code ...
}
```

This means `CupertinoPageRoute` doesn't have to write the `buildTransitions` code itself; it gets it "for free" by mixing in `CupertinoRouteTransitionMixin`.

### How it Connects to Building Transitions

The most important part that `CupertinoRouteTransitionMixin` provides is the implementation for the `buildTransitions` method that every `PageRoute` needs.

When you call `Navigator.push` with a `CupertinoPageRoute`, the Navigator needs to know how to animate the new page onto the screen. It calls the `buildTransitions` method of that `PageRoute`. Because `CupertinoPageRoute` mixed in `CupertinoRouteTransitionMixin`, it's actually the mixin's code that runs for `buildTransitions`.

Here's a look inside the mixin's `buildTransitions` method (simplified from the framework code):

```dart
// Simplified from packages/flutter/lib/src/cupertino/route.dart
mixin CupertinoRouteTransitionMixin<T> on PageRoute<T> {
  // ... other properties like transitionDuration ...

  @override
  Widget buildTransitions( // This method is provided by the mixin!
    BuildContext context,
    Animation<double> animation, // Animation for the incoming page
    Animation<double> secondaryAnimation, // Animation for the outgoing page
    Widget child, // The actual content of the page (your NewScreen)
  ) {
    // Inside here, the mixin's code figures out the right animation.
    // It uses specific transition widgets like CupertinoPageTransition
    // (or CupertinoFullscreenDialogTransition for dialogs).
    // It passes the 'child' (your new screen) and the 'animation' objects
    // to these transition widgets.

    // This line is the core – it calls dedicated builders for the transitions!
    return buildPageTransitions<T>(this, context, animation, secondaryAnimation, child);
  }

  // ... other methods ...
}
```

The `buildTransitions` method in `CupertinoRouteTransitionMixin` doesn't build the animation widget tree directly. Instead, it delegates that task to helper functions within the Cupertino library, specifically `buildPageTransitions`.

This `buildPageTransitions` helper method (which is part of the mixin's logic):

1.  Checks if this route is a normal page or a fullscreen dialog.
2.  Based on that, it chooses the correct transition widget.
    *   For normal pages, it picks `CupertinoPageTransition`.
    *   For fullscreen dialogs (like adding an event in the calendar), it picks `CupertinoFullscreenDialogTransition`.
3.  It creates an instance of the chosen transition widget, passing in:
    *   The `animation` for the incoming screen.
    *   The `secondaryAnimation` for the outgoing screen.
    *   Your actual screen widget (`child`).

So, the `CupertinoRouteTransitionMixin` acts as the orchestrator of the transition. It decides which specific animation widget to use and provides it with the necessary animation data.

Let's visualize this flow:

```mermaid
sequenceDiagram
    participant Navigator as Navigator
    participant CupertinoPageRoute as CupertinoPageRoute
    participant CRT_Mixin as CupertinoRouteTransitionMixin
    participant CPTransition as CupertinoPageTransition / CupertinoFullscreenDialogTransition
    participant NewScreen as NewScreen Widget

    Navigator->CupertinoPageRoute: calls buildTransitions(...)
    CupertinoPageRoute->CRT_Mixin: (delegates to mixin's method)
    CRT_Mixin->CRT_Mixin: calls buildPageTransitions(...)
    CRT_Mixin->CPTransition: creates CPTransition(...) with child and animations
    CPTransition->NewScreen: wraps NewScreen
    CRT_Mixin-->Navigator: returns CPTransition(NewScreen)
    Navigator->Navigator: Animates the transition using CPTransition
```

The `CupertinoPageTransition` and `CupertinoFullscreenDialogTransition` widgets are the ones that *actually perform* the visual animation (sliding the child widget using the provided animation values). We'll look at those in more detail in the next chapters!

### You Won't Necessarily Use It Directly

Similar to `MaterialRouteTransitionMixin`, you as a beginner app developer are typically not expected to directly use `CupertinoRouteTransitionMixin`. Its main purpose is to serve as a building block for other `PageRoute` types, most notably `CupertinoPageRoute`.

When you use `CupertinoPageRoute`, you automatically get the benefits of the transition logic contained within `CupertinoRouteTransitionMixin` without having to think about the mixin itself.

### Conclusion

`CupertinoRouteTransitionMixin` is the powerhouse behind `CupertinoPageRoute`'s native iOS transition animations. It provides the `buildTransitions` logic, deciding which specific Cupertino transition widget (`CupertinoPageTransition` or `CupertinoFullscreenDialogTransition`) to use based on the route type and giving it the necessary animation details to perform the visual effect. While you usually interact with `CupertinoPageRoute`, understanding that `CupertinoRouteTransitionMixin` provides the core animation recipe clarifies how these iOS-style transitions are achieved in Flutter.

In the next chapter, we'll focus on `CupertinoPageTransition`, the primary widget used by `CupertinoRouteTransitionMixin` to create the standard iOS page slide animation.

[Next Chapter: CupertinoPageTransition](06_cupertinopagetransition_.md)
---
# Chapter 6: CupertinoPageTransition

Welcome back! In [Chapter 5: CupertinoRouteTransitionMixin](05_cupertinoroutetransitionmixin_.md), we learned that `CupertinoRouteTransitionMixin` holds the recipe for creating those distinct iOS-style transition animations, and how `CupertinoPageRoute` uses this mixin. Now, let's focus on one of the key ingredients in that recipe: the `CupertinoPageTransition` widget itself.

### What is CupertinoPageTransition?

Imagine the screen of your iPhone. When you tap on an item in a list and a new screen slides into view from the right, that smooth animation is done by a special widget. In Flutter's Cupertino world, that special widget is `CupertinoPageTransition`.

`CupertinoPageTransition` is a widget that doesn't display its own content directly. Instead, it takes another widget (which is the new screen you want to show) and applies a specific animation and visual effect to it. It's the visual performer of the standard iOS page-to-page transitions.

Here's what it does:

*   It makes the new screen (`child` widget) slide in from the right.
*   It makes the original screen (the one being covered) slightly slide to the left, creating a cool "parallax" effect.
*   It might also add a subtle shadow effect on the edge of the incoming screen.
*   It uses the "animation" objects provided by the `PageRoute` to know how far along the transition is.

It's important to remember that `CupertinoPageTransition` is just the **visual effect** widget. It relies on a `PageRoute` (like `CupertinoPageRoute`) and the `Navigator` to decide *when* to run the animation and *what* pages to animate.

**Motivation:** We want to understand the actual widget that visually creates the distinct iOS sliding and parallax effect during a page transition. That widget is `CupertinoPageTransition`.

### How CupertinoPageTransition Works

You won't typically create a `CupertinoPageTransition` widget yourself directly in your app code for basic navigation. It is created *internally* by the `CupertinoRouteTransitionMixin` (which is used by `CupertinoPageRoute`).

Let's think about the information `CupertinoPageTransition` needs:

1.  **The content to animate:** This is the widget tree of the new screen you are navigating to. `CupertinoPageTransition` needs to wrap this content.
2.  **The animation progress for the incoming page:** An `Animation` object that typically goes from 0.0 (off-screen) to 1.0 (fully on-screen).
3.  **The animation progress for the outgoing page:** An `Animation` object that typically goes from 0.0 (fully on-screen) to 1.0 (off-screen to the left). This is used for the parallax effect.
4.  **Whether the transition is "linear":** This is used internally for tracking user gestures like swiping back, ensuring the animation follows the finger precisely.

The `CupertinoRouteTransitionMixin`'s `buildTransitions` method (which `CupertinoPageRoute` uses) is responsible for creating the `CupertinoPageTransition` widget and giving it these pieces of information.

Here's a simplified look at how `CupertinoPageRoute` (via its mixin) uses `CupertinoPageTransition`:

```dart
// Simplified concept - from CupertinoRouteTransitionMixin's buildTransitions logic
// This code is inside the Flutter framework, not your app!
Widget buildPageTransitions(
  PageRoute<T> route, // The route being built
  BuildContext context,
  Animation<double> primaryAnimation, // Animation for the new page
  Animation<double> secondaryAnimation, // Animation for the old page
  Widget child, // the NewScreen widget
) {
  // Decide if it's a fullscreen dialog or a regular page
  if (route.fullscreenDialog) {
    // Use a different transition for dialogs (more on this later)
    return CupertinoFullscreenDialogTransition(...);
  } else {
    // For regular pages, use CupertinoPageTransition!
    return CupertinoPageTransition(
      primaryRouteAnimation: primaryAnimation, // Pass incoming animation
      secondaryRouteAnimation: secondaryAnimation, // Pass outgoing animation
      linearTransition: route.popGestureInProgress, // Is a swipe back happening?
      child: child, // Wrap the NewScreen widget
    );
  }
}
```

This shows that `CupertinoPageTransition` is instantiated by the *framework* code that the `CupertinoRouteTransitionMixin` provides. It acts as a container for your `child` widget (`NewScreen` in our example) and applies the animations specified by `primaryRouteAnimation` and `secondaryRouteAnimation`.

### The Visual Magic

Inside `CupertinoPageTransition`, the actual visual effect is created using standard Flutter animation widgets, primarily `SlideTransition` and `DecoratedBoxTransition`.

Let's simplify the core `build` method of `CupertinoPageTransition`:

```dart
// Simplified concept - from the build method inside CupertinoPageTransition
@override
Widget build(BuildContext context) {
  // calculate slide for secondary (outgoing) page (parallax)
  // based on secondaryRouteAnimation

  // calculate slide for primary (incoming) page
  // based on primaryRouteAnimation

  // calculate shadow for primary (incoming) page
  // based on primaryRouteAnimation

  return SlideTransition(
    position: _secondaryPositionAnimation, // Moves the outgoing page
    child: SlideTransition(
      position: _primaryPositionAnimation, // Moves the incoming page
      child: DecoratedBoxTransition(
        decoration: _primaryShadowAnimation, // Adds edge shadow
        child: widget.child, // The actual screen content (NewScreen)
      ),
    ),
  );
}
```

This nested structure is key:

1.  The outermost `SlideTransition` uses `_secondaryPositionAnimation` (derived from `secondaryRouteAnimation`) to slightly slide the **outgoing page** (which is the `child` *of the inner* `SlideTransition`) to the left, creating the parallax effect.
2.  The inner `SlideTransition` uses `_primaryPositionAnimation` (derived from `primaryRouteAnimation`) to slide the **incoming page** (`widget.child`) from the right to the center.
3.  The `DecoratedBoxTransition` wraps the `widget.child` and applies a subtle gradient shadow effect on the leading edge as it slides in, using `_primaryShadowAnimation`.

```mermaid
graph TD
    A[Navigator] --> B[CupertinoPageRoute];
    B --> C[CupertinoRouteTransitionMixin]
    C --> D[buildTransitions calls buildPageTransitions]
    D --> E[Creates CupertinoPageTransition]
    E --> F{Build Method of CupertinoPageTransition};
    F --> G[Outer SlideTransition - Secondary Animation (Parallax)];
    G --> H[Inner SlideTransition - Primary Animation (Slide In)];
    H --> I[DecoratedBoxTransition - Edge Shadow];
    I --> J[Your NewScreen Widget];
```

So, `CupertinoPageTransition` stitches together several basic animation widgets (`SlideTransition`, `DecoratedBoxTransition`) using the `Animation` objects it receives to create the complete visual iOS page transition effect.

### You Still Don't Use It Directly (Mostly)

Just like `CupertinoRouteTransitionMixin`, you generally won't hand-craft a `CupertinoPageTransition` widget in your typical navigation code. When you use `CupertinoPageRoute`, the framework automatically creates and manages the `CupertinoPageTransition` for you.

Understanding `CupertinoPageTransition` helps you appreciate how the finished iOS-style transition is composed of multiple visual elements (sliding the new page, sliding the old page, adding a shadow) all orchestrated by the primary and secondary animation objects.

### Conclusion

`CupertinoPageTransition` is the concrete widget that implements the visual aspects of the standard iOS page transition, including sliding, parallax, and shadowing. It receives animation data from a `PageRoute` (like `CupertinoPageRoute` via its mixin) and uses built-in animation widgets to apply these effects to the new screen's content. While you don't usually need to use it directly, knowing it exists clarifies how Flutter achieves that native iOS navigation feel.

In the next chapter, we'll look at `CupertinoFullscreenDialogTransition`, a similar widget but used for the different animation style employed by iOS for fullscreen modal dialogs.

[Next Chapter: CupertinoFullscreenDialogTransition](07_cupertinofullscreendialogtransition_.md)
---
# Chapter 7: CupertinoFullscreenDialogTransition

Welcome back, navigators! In [Chapter 6: CupertinoPageTransition](06_cupertinopagetransition_.md), we explored `CupertinoPageTransition`, the widget that creates the standard iOS slide-from-the-right animation for regular pages. But what about different types of screens that pop up?

On iOS, when you add a new event in the Calendar app or compose a new email, a screen often slides up from the *bottom* of the screen, taking over the whole view. This is often called a "fullscreen dialog" or "modal presentation style." This animation is different from the regular horizontal slide.

This is where `CupertinoFullscreenDialogTransition` comes in!

### What is CupertinoFullscreenDialogTransition?

`CupertinoFullscreenDialogTransition` is another special widget, similar to `CupertinoPageTransition`, but specifically designed to create the visual effect for these **fullscreen dialogs that animate up from the bottom** in the Cupertino (iOS) style.

It doesn't show its own content. Instead, it takes the widget for your fullscreen dialog screen and applies that specific bottom-up animation and other potential visual effects like making the previous screen slightly darker.

Here's what it does:

*   It makes the new fullscreen dialog screen (`child` widget) slide in from the bottom of the screen.
*   It makes the previous screen fade out slightly or adds a barrier color behind the new screen.
*   It uses the "animation" objects provided by the `PageRoute` to track the animation progress.

It's the visual performer for that distinct "modal" or "fullscreen dialog" presentation style used in many iOS apps. Like `CupertinoPageTransition`, it relies on a `PageRoute` (specifically one configured as a fullscreen dialog) and the `Navigator` to decide *when* to run the animation.

**Motivation:** We want to understand the specific widget used by Flutter's Cupertino library to create the bottom-up, fullscreen dialog animation seen in iOS apps. That widget is `CupertinoFullscreenDialogTransition`.

### How CupertinoFullscreenDialogTransition Works

Just like `CupertinoPageTransition`, you almost certainly won't build a `CupertinoFullscreenDialogTransition` widget yourself directly. It is created *internally* by the `CupertinoRouteTransitionMixin` (which, as we saw, is used by `CupertinoPageRoute`).

When you create a `CupertinoPageRoute` and set its `fullscreenDialog` property to `true`, you're telling the Navigator (and the Cupertino framework) that this is a special type of route that should use the fullscreen dialog animation.

The `CupertinoRouteTransitionMixin`'s `buildTransitions` method checks the `fullscreenDialog` property of the route it's building transitions for. If it's `true`, it creates a `CupertinoFullscreenDialogTransition` instead of a `CupertinoPageTransition`.

Let's revisit the simplified concept from the `CupertinoRouteTransitionMixin`'s `buildPageTransitions` logic:

```dart
// Simplified concept - from CupertinoRouteTransitionMixin's buildTransitions logic
// This code is inside the Flutter framework!
Widget buildPageTransitions(
  PageRoute<T> route, // The route being built
  BuildContext context,
  Animation<double> primaryAnimation, // Animation for the incoming page
  Animation<double> secondaryAnimation, // Animation for the outgoing page
  Widget child, // the NewScreen widget
) {
  // Decide if it's a fullscreen dialog or a regular page
  if (route.fullscreenDialog) {
    print("Building FULLSCREEN Dialog Transition!"); // Added for emphasis
    return CupertinoFullscreenDialogTransition( // <--- Uses this widget!
      primaryRouteAnimation: primaryAnimation, // Pass incoming animation
      secondaryRouteAnimation: secondaryAnimation, // Pass outgoing animation
      linearTransition: route.popGestureInProgress,
      child: child, // Wrap the NewScreen widget
    );
  } else {
    // For regular pages, use CupertinoPageTransition
    // ... create CupertinoPageTransition ...
  }
}
```

This fragment, part of the code in `packages/flutter/lib/src/cupertino/route.dart`, directly shows the decision point. If the `PageRoute` is a `fullscreenDialog`, the framework creates a `CupertinoFullscreenDialogTransition` widget and passes it the necessary animation objects and your screen's content (`child`).

### The Visual Magic (Sliding Up)

Inside `CupertinoFullscreenDialogTransition`, the actual visual effect is simpler than `CupertinoPageTransition`'s. It primarily uses a `SlideTransition` to make the new screen slide up from the bottom. It also handles the animation of the screen *being covered*, though the effect for fullscreen dialogs isn't the same parallax as a regular page slide.

Here's a simplified look at the core `build` method of `CupertinoFullscreenDialogTransition`:

```dart
// Simplified concept - from the build method inside CupertinoFullscreenDialogTransition
@override
Widget build(BuildContext context) {
  // Calculate slide for primary (incoming) page
  // based on primaryRouteAnimation (animating from bottom up)

  // Calculate slide for secondary (outgoing) page
  // based on secondaryRouteAnimation (it might slightly move or fade)

  return SlideTransition(
    position: _secondaryPositionAnimation, // Slightly moves/affects the outgoing page
    child: SlideTransition(
      position: _primaryPositionAnimation, // Slides the incoming page (your dialog)
      child: widget.child, // The actual screen content (your dialog widget)
    ),
  );
}
```

This structure is similar to `CupertinoPageTransition` but uses different `Tween`s (animations definitions) to control the direction and type of movement:

1.  The outermost `SlideTransition` uses `_secondaryPositionAnimation` (derived from `secondaryRouteAnimation`). For fullscreen dialogs, the effect on the previous page is usually just a subtle dimming or no movement, though the mixin provides the animation for potential use.
2.  The inner `SlideTransition` uses `_primaryPositionAnimation` (derived from `primaryRouteAnimation`) to slide the **incoming page** (`widget.child`) from off-screen *below* to the center of the screen. The `_kBottomUpTween` defined in `packages/flutter/lib/src/cupertino/route.dart` (which goes from `Offset(0.0, 1.0)` meaning bottom-off-screen to `Offset.zero` meaning on-screen) is used here.

```mermaid
graph TD
    A[Navigator] --> B[CupertinoPageRoute (fullscreenDialog: true)];
    B --> C[CupertinoRouteTransitionMixin]
    C --> D[buildTransitions checks fullscreenDialog: true]
    D --> E[Creates CupertinoFullscreenDialogTransition]
    E --> F{Build Method of CupertinoFullscreenDialogTransition};
    F --> G[Outer SlideTransition - Secondary Animation (Previous Page)];
    G --> H[Inner SlideTransition - Primary Animation (Slide Up)];
    H --> I[Your Dialog Widget];
```

So, `CupertinoFullscreenDialogTransition` uses `SlideTransition` (possibly nested) with animation values that cause the `child` widget to move from the bottom to the center of the screen, providing the standard iOS fullscreen dialog effect.

### You Don't Use It Directly

As emphasized before, you won't typically use `CupertinoFullscreenDialogTransition` directly in your application code. Its purpose is to be the visual engine for fullscreen dialogs when you use a `PageRoute` (like `CupertinoPageRoute`) configured with `fullscreenDialog: true`.

Understanding `CupertinoFullscreenDialogTransition` helps you recognize that the fullscreen dialog's bottom-up animation isn't just magic; it's built using standard Flutter animation widgets under the hood, controlled by the transition `Animation` objects.

### Conclusion

`CupertinoFullscreenDialogTransition` is a dedicated widget within the Cupertino library for achieving the distinct iOS fullscreen dialog animation, where the new screen slides up from the bottom. It works in conjunction with `CupertinoRouteTransitionMixin` and `PageRoute` objects configured with `fullscreenDialog: true` to apply this specific visual effect to your screen's content. While you don't use it directly, its existence explains the different animation style for these types of pop-ups in Cupertino-styled apps.

In the next chapter, we'll look at `CupertinoModalPopupRoute`, a specialized route for showing simpler modal popups from the bottom, like action sheets.

[Next Chapter: CupertinoModalPopupRoute](08_cupertinomodalpopuproute_.md)
---
# Chapter 8: CupertinoModalPopupRoute

Welcome back, brave Flutter adventurers! In [Chapter 7: CupertinoFullscreenDialogTransition](07_cupertinofullscreendialogtransition_.md), we looked at the specific widget that provides the bottom-up animation for fullscreen iOS-style modal dialogs. Now, let's shift our gaze to a slightly different kind of pop-up from the bottom: the kind used for action sheets and simpler modal panels. This is where `CupertinoModalPopupRoute` comes in.

### What is CupertinoModalPopupRoute?

Imagine you tap a button on your phone (especially on iOS), and instead of a full screen sliding in, a smaller panel appears from the bottom, covering only part of the screen. This panel might ask you to choose an option (like "Edit," "Delete," "Cancel") or present a short form without obscuring the content behind it completely.

<br>

<p align="center">
  <img src="https://docs.flutter.dev/assets/images/flutter-for-web/modal-dialogs/cupertino-action-sheet.gif" alt="Example of a Cupertino Action Sheet" style="width: 300px;">
  <br>
  <em>Think of this kind of panel popping up from the bottom.</em>
</p>

<br>

`CupertinoModalPopupRoute` is Flutter's `PageRoute` specifically designed for creating and managing these types of non-fullscreen, bottom-sliding modal pop-ups in the iOS style. It defines how they appear, how they animate onto the screen, and how they behave (like whether tapping outside dismisses them).

It's different from a regular `CupertinoPageRoute` because:

1.  It typically only covers *part* of the screen, not the whole thing.
2.  It animates up from the *bottom*, not sliding horizontally from the side.
3.  It's often used for transient interfaces like action sheets or simple choices, where the user quickly interacts and the panel is dismissed.

**Motivation:** We want to show a simple panel sliding up from the bottom of the screen to present a choice or action, using the native iOS style for such pop-ups. We don't want a fullscreen transition like with `CupertinoPageRoute`.

### Using CupertinoModalPopupRoute

You won't usually create a `CupertinoModalPopupRoute` directly using `Navigator.push`. Instead, Flutter provides a helper function, `showCupertinoModalPopup`, which is specifically designed to show these types of pop-ups and internally creates a `CupertinoModalPopupRoute` for you. This is the easiest and most common way to use this concept.

Let's create a simple example where tapping a button shows a small panel with some text popping up from the bottom. We'll use `showCupertinoModalPopup`.

First, make sure you have the Cupertino design package imported:

```dart
import 'package:flutter/cupertino.dart';
import 'package:flutter/material.dart'; // Still useful for things like Scaffold and Button in examples

// ... rest of MyApp, HomeScreen, NewScreen classes ...
```

Now, let's modify our `HomeScreen`'s button `onPressed`:

```dart
// ... inside HomeScreen onPressed ...
onPressed: () {
  showCupertinoModalPopup<void>( // Use the helper function!
    context: context,
    builder: (BuildContext context) {
      return CupertinoAlertDialog( // Example widget for the popup content
        title: const Text('Popup Title'),
        content: const Text('This panel popped up from the bottom!'),
        actions: <CupertinoDialogAction>[
          CupertinoDialogAction(
            child: const Text('OK'),
            onPressed: () {
              Navigator.pop(context); // Dismiss the popup
            },
          ),
        ],
      );
    },
  );
},
// ... rest of HomeScreen ...
```

Let's break this down:

1.  **`showCupertinoModalPopup<void>(...)`**: This is the function provided by Flutter for showing these modal pop-ups. The `<void>` indicates that this popup doesn't return a specific result value when dismissed (like a dialog might).
2.  **`context: context`**: We pass the current `BuildContext` so the function knows where in the widget tree to show the popup.
3.  **`builder: (BuildContext context) { ... }`**: Similar to other route builders, this function is responsible for creating the widget that will be displayed inside the modal popup.
4.  **`return CupertinoAlertDialog(...)`**: Inside the builder, we return the widget that will be the content of our bottom popup. Here, we're using a `CupertinoAlertDialog` as a simple example, but you could return a `CupertinoActionSheet` (a very common use case for this route) or any other widget you want to appear in that modal panel.
5.  **`Navigator.pop(context)`**: This is how you dismiss the modal popup. Tapping the 'OK' button calls `Navigator.pop`, which removes the `CupertinoModalPopupRoute` from the navigation stack and animates it back down.

Now, when you tap "Go to New Screen" (or whatever your button says), a `CupertinoAlertDialog` (which is configured to be presented in an iOS modal style by `CupertinoModalPopupRoute`) will slide up from the bottom of the screen!

Other common properties you might pass to `showCupertinoModalPopup`:

*   `barrierDismissible: true` (default): Allows tapping the dark area outside the popup to dismiss it. Set to `false` to require an action within the popup to close it.
*   `barrierColor`: Sets the color of the dark overlay behind the popup.

### How it Works Under the Hood (Simplified)

When you call `showCupertinoModalPopup`, here's a simplified idea of what happens, leading to the creation of a `CupertinoModalPopupRoute`:

```mermaid
sequenceDiagram
    participant Button as Button Widget
    participant Screen as Your Screen Widget
    participant showCupertinoModalPopup as showCupertinoModalPopup Function
    participant Navigator as Navigator
    participant CMP_Route as CupertinoModalPopupRoute
    participant PopupWidget as Your Popup Widget (e.g., CupertinoAlertDialog)

    Button->Screen: calls onPressed
    Screen->showCupertinoModalPopup: calls showCupertinoModalPopup(...)
    showCupertinoModalPopup->CMP_Route: creates new CupertinoModalPopupRoute(...)
    showCupertinoModalPopup->Navigator: calls Navigator.push(context, CMP_Route)
    Navigator->CMP_Route: asks to build page content and transitions
    CMP_Route->CMP_Route: calls builder() to create PopupWidget
    CMP_Route->CMP_Route: applies transition logic (slide up from bottom)
    Navigator->Navigator: Prepares and orchestrates
    Navigator->PopupWidget: Builds and animates PopupWidget into view
```

The `showCupertinoModalPopup` function is a convenient wrapper. Its main job is to create a `CupertinoModalPopupRoute` and push it onto the Navigator's stack.

Let's look at the `CupertinoModalPopupRoute` definition in `packages/flutter/lib/src/cupertino/route.dart`:

```dart
// Simplified structure of CupertinoModalPopupRoute

class CupertinoModalPopupRoute<T> extends PopupRoute<T> {
  // ... constructor ...

  final WidgetBuilder builder; // Your builder function goes here

  @override
  Duration get transitionDuration => _kModalPopupTransitionDuration; // Defines animation speed

  @override
  Widget buildPage( // Builds the content of the popup
    BuildContext context,
    Animation<double> animation,
    Animation<double> secondaryAnimation,
  ) {
    // Calls your builder to get the widget for the popup content
    return CupertinoUserInterfaceLevel( // Often adds an elevation effect
      data: CupertinoUserInterfaceLevelData.elevated,
      child: Builder(builder: builder), // Runs your builder function
    );
  }

  @override
  Widget buildTransitions( // Defines how the popup animates
    BuildContext context,
    Animation<double> animation, // Animation from 0.0 to 1.0
    Animation<double> secondaryAnimation,
    Widget child, // The widget built by buildPage (your popup content)
  ) {
    // This wraps the child with a translation effect based on the animation
    return Align( // Centers the child horizontally at the bottom
      alignment: Alignment.bottomCenter,
      child: FractionalTranslation( // Moves the child based on animation
        translation: _offsetTween.evaluate(animation), // Uses a Tween to slide up
        child: child, // Your popup widget
      ),
    );
  }

  static final Tween<Offset> _offsetTween = Tween<Offset>(
    begin: const Offset(0.0, 1.0), // Start off-screen below (0% from left, 100% from top)
    end: Offset.zero, // End on-screen (0% from left, 0% from top relative to Align)
  );

  // ... other properties like barrierColor, barrierDismissible ...
}
```

Here's the key internal logic:

1.  `CupertinoModalPopupRoute` extends `PopupRoute` (a base class for routes that overlay the current content, like dialogs and menus).
2.  Your `builder` function is stored and called inside `buildPage` to create the content of the modal popup (`PopupWidget` in our diagram).
3.  The `buildTransitions` method is where the visual magic happens. It wraps the `child` (your popup widget) with an `Align` widget to horizontally center it at the bottom of the screen.
4.  It then uses a `FractionalTranslation` and our `_offsetTween`. This `_offsetTween` is defined to go from `Offset(0.0, 1.0)` (meaning 0% horizontally and 100% vertically *relative to the bottom-aligned position*) to `Offset.zero` (meaning 0% horizontal and 0% vertical translation).
5.  As the `animation` goes from 0.0 to 1.0, `_offsetTween.evaluate(animation)` calculates the intermediate offset. When the animation is 0.0, the offset is `(0.0, 1.0)`, placing the widget off-screen below. When the animation reaches 1.0, the offset is `(0.0, 0.0)`, placing the widget at the bottom-center, fully visible. This creates the smooth slide-up effect.

Unlike regular `CupertinoPageRoute` which uses mixins and dedicated transition widgets like `CupertinoPageTransition`, `CupertinoModalPopupRoute` implements its specific bottom-up transition directly within its `buildTransitions` method using simpler animation widgets like `FractionalTranslation`.

### Conclusion

`CupertinoModalPopupRoute` is a specialized `PageRoute` for implementing the signature iOS-style modal panels that slide up from the bottom, such as action sheets. While you typically interact with it via the helper function `showCupertinoModalPopup`, understanding the route itself shows how it uses its `builder` for content and defines a non-fullscreen, bottom-up animation within its `buildTransitions` method using basic animation widgets to achieve its effect.

In the next chapter, we'll look at `CupertinoDialogRoute`, which is specifically for showing iOS-style alert dialogs that appear in the center of the screen.

[Next Chapter: CupertinoDialogRoute](09_cupertinodialogroute_.md)

Relevant Code Snippets (Code itself remains unchanged):
--- File: packages/flutter/lib/src/cupertino/route.dart ---
// Copyright 2014 The Flutter Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

/// @docImport 'dart:ui';
///
/// @docImport 'package:flutter/material.dart';
/// @docImport 'package:flutter/services.dart';
///
/// @docImport 'app.dart';
/// @docImport 'button.dart';
/// @docImport 'dialog.dart';
/// @docImport 'nav_bar.dart';
/// @docImport 'page_scaffold.dart';
/// @docImport 'tab_scaffold.dart';
library;

import 'dart:math';
import 'dart:ui' show ImageFilter;

import 'package:flutter/foundation.dart';
import 'package:flutter/gestures.dart';
import 'package:flutter/physics.dart';
import 'package:flutter/rendering.dart';
import 'package:flutter/widgets.dart';

import 'colors.dart';
import 'interface_level.dart';
import 'localizations.dart';

const double _kBackGestureWidth = 20.0;
const double _kMinFlingVelocity = 1.0; // Screen widths per second.

// The duration for a page to animate when the user releases it mid-swipe.
const Duration _kDroppedSwipePageAnimationDuration = Duration(milliseconds: 350);

/// Barrier color used for a barrier visible during transitions for Cupertino
/// page routes.
///
/// This barrier color is only used for full-screen page routes with
/// `fullscreenDialog: false`.
///
/// By default, `fullscreenDialog` Cupertino route transitions have no
/// `barrierColor`, and [CupertinoDialogRoute]s and [CupertinoModalPopupRoute]s
/// have a `barrierColor` defined by [kCupertinoModalBarrierColor].
///
/// A relatively rigorous eyeball estimation.
const Color _kCupertinoPageTransitionBarrierColor = Color(0x18000000);

/// Barrier color for a Cupertino modal barrier.
///
/// Extracted from https://developer.apple.com/design/resources/.
const Color kCupertinoModalBarrierColor = CupertinoDynamicColor.withBrightness(
  color: Color(0x33000000),
  darkColor: Color(0x7A000000),
);

// The duration of the transition used when a modal popup is shown.
const Duration _kModalPopupTransitionDuration = Duration(milliseconds: 335);

// Offset from offscreen to the right to fully on screen.
final Animatable<Offset> _kRightMiddleTween = Tween<Offset>(
  begin: const Offset(1.0, 0.0),
  end: Offset.zero,
);

// Offset from fully on screen to 1/3 offscreen to the left.
final Animatable<Offset> _kMiddleLeftTween = Tween<Offset>(
  begin: Offset.zero,
  end: const Offset(-1.0 / 3.0, 0.0),
);

// Offset from offscreen below to fully on screen.
final Animatable<Offset> _kBottomUpTween = Tween<Offset>(
  begin: const Offset(0.0, 1.0),
  end: Offset.zero,
);

/// A mixin that replaces the entire screen with an iOS transition for a
/// [PageRoute].
///
/// {@template flutter.cupertino.cupertinoRouteTransitionMixin}
/// The page slides in from the right and exits in reverse. The page also shifts
/// to the left in parallax when another page enters to cover it.
///
/// The page slides in from the bottom and exits in reverse with no parallax
/// effect for fullscreen dialogs.
/// {@endtemplate}
///
/// See also:
///
///  * [MaterialRouteTransitionMixin], which is a mixin that provides
///    platform-appropriate transitions for a [PageRoute].
///  * [CupertinoPageRoute], which is a [PageRoute] that leverages this mixin.
mixin CupertinoRouteTransitionMixin<T> on PageRoute<T> {
  /// Builds the primary contents of the route.
  @protected
  Widget buildContent(BuildContext context);

  /// {@template flutter.cupertino.CupertinoRouteTransitionMixin.title}
  /// A title string for this route.
  ///
  /// Used to auto-populate [CupertinoNavigationBar] and
  /// [CupertinoSliverNavigationBar]'s `middle`/`largeTitle` widgets when
  /// one is not manually supplied.
  /// {@endtemplate}
  String? get title;

  ValueNotifier<String?>? _previousTitle;

  /// The title string of the previous [CupertinoPageRoute].
  ///
  /// The [ValueListenable]'s value is readable after the route is installed
  /// onto a [Navigator]. The [ValueListenable] will also notify its listeners
  /// if the value changes (such as by replacing the previous route).
  ///
  /// The [ValueListenable] itself will be null before the route is installed.
  /// Its content value will be null if the previous route has no title or
  /// is not a [CupertinoPageRoute].
  ///
  /// See also:
  ///
  ///  * [ValueListenableBuilder], which can be used to listen and rebuild
  ///    widgets based on a ValueListenable.
  ValueListenable<String?> get previousTitle {
    assert(
      _previousTitle != null,
      'Cannot read the previousTitle for a route that has not yet been installed',
    );
    return _previousTitle!;
  }

  @override
  void dispose() {
    _previousTitle?.dispose();
    super.dispose();
  }

  @override
  void didChangePrevious(Route<dynamic>? previousRoute) {
    final String? previousTitleString =
        previousRoute is CupertinoRouteTransitionMixin ? previousRoute.title : null;
    if (_previousTitle == null) {
      _previousTitle = ValueNotifier<String?>(previousTitleString);
    } else {
      _previousTitle!.value = previousTitleString;
    }
    super.didChangePrevious(previousRoute);
  }

  @override
  // A relatively rigorous eyeball estimation.
  Duration get transitionDuration => const Duration(milliseconds: 500);

  @override
  Color? get barrierColor => fullscreenDialog ? null : _kCupertinoPageTransitionBarrierColor;

  @override
  String? get barrierLabel => null;

  @override
  bool canTransitionTo(TransitionRoute<dynamic> nextRoute) {
    // Don't perform outgoing animation if the next route is a fullscreen dialog.
    final bool nextRouteIsNotFullscreen =
        (nextRoute is! PageRoute<T>) || !nextRoute.fullscreenDialog;

    // If the next route has a delegated transition, then this route is able to
    // use that delegated transition to smoothly sync with the next route's
    // transition.
    final bool nextRouteHasDelegatedTransition =
        nextRoute is ModalRoute<T> && nextRoute.delegatedTransition != null;

    // Otherwise if the next route has the same route transition mixin as this
    // one, then this route will already be synced with its transition.
    return nextRouteIsNotFullscreen &&
        ((nextRoute is CupertinoRouteTransitionMixin) || nextRouteHasDelegatedTransition);
  }

  @override
  bool canTransitionFrom(TransitionRoute<dynamic> previousRoute) {
    // Supress previous route from transitioning if this is a fullscreenDialog route.
    return previousRoute is PageRoute && !fullscreenDialog;
  }

  @override
  Widget buildPage(
    BuildContext context,
    Animation<double> animation,
    Animation<double> secondaryAnimation,
  ) {
    final Widget child = buildContent(context);
    return Semantics(scopesRoute: true, explicitChildNodes: true, child: child);
  }

  // Called by _CupertinoBackGestureDetector when a pop ("back") drag start
  // gesture is detected. The returned controller handles all of the subsequent
  // drag events.
  static _CupertinoBackGestureController<T> _startPopGesture<T>(PageRoute<T> route) {
    assert(route.popGestureEnabled);

    return _CupertinoBackGestureController<T>(
      navigator: route.navigator!,
      getIsCurrent: () => route.isCurrent,
      getIsActive: () => route.isActive,
      controller: route.controller!, // protected access
    );
  }

  /// Returns a [CupertinoFullscreenDialogTransition] if [route] is a full
  /// screen dialog, otherwise a [CupertinoPageTransition] is returned.
  ///
  /// Used by [CupertinoPageRoute.buildTransitions].
  ///
  /// This method can be applied to any [PageRoute], not just
  /// [CupertinoPageRoute]. It's typically used to provide a Cupertino style
  /// horizontal transition for material widgets when the target platform
  /// is [TargetPlatform.iOS].
  ///
  /// See also:
  ///
  ///  * [CupertinoPageTransitionsBuilder], which uses this method to define a
  ///    [PageTransitionsBuilder] for the [PageTransitionsTheme].
  static Widget buildPageTransitions<T>(
    PageRoute<T> route,
    BuildContext context,
    Animation<double> animation,
    Animation<double> secondaryAnimation,
    Widget child,
  ) {
    // Check if the route has an animation that's currently participating
    // in a back swipe gesture.
    //
    // In the middle of a back gesture drag, let the transition be linear to
    // match finger motions.
    final bool linearTransition = route.popGestureInProgress;
    if (route.fullscreenDialog) {
      return CupertinoFullscreenDialogTransition(
        primaryRouteAnimation: animation,
        secondaryRouteAnimation: secondaryAnimation,
        linearTransition: linearTransition,
        child: child,
      );
    } else {
      return CupertinoPageTransition(
        primaryRouteAnimation: animation,
        secondaryRouteAnimation: secondaryAnimation,
        linearTransition: linearTransition,
        child: _CupertinoBackGestureDetector<T>(
          enabledCallback: () => route.popGestureEnabled,
          onStartPopGesture: () => _startPopGesture<T>(route),
          child: child,
        ),
      );
    }
  }

  @override
  Widget buildTransitions(
    BuildContext context,
    Animation<double> animation,
    Animation<double> secondaryAnimation,
    Widget child,
  ) {
    return buildPageTransitions<T>(this, context, animation, secondaryAnimation, child);
  }
}

/// A modal route that replaces the entire screen with an iOS transition.
///
/// {@macro flutter.cupertino.cupertinoRouteTransitionMixin}
///
/// By default, when a modal route is replaced by another, the previous route
/// remains in memory. To free all the resources when this is not necessary, set
/// [maintainState] to false.
///
/// The type `T` specifies the return type of the route which can be supplied as
/// the route is popped from the stack via [Navigator.pop] when an optional
/// `result` can be provided.
///
/// If `barrierDismissible` is true, then pressing the escape key on the keyboard
/// will cause the current route to be popped with null as the value.
///
/// See also:
///
///  * [CupertinoRouteTransitionMixin], for a mixin that provides iOS transition
///    for this modal route.
///  * [MaterialPageRoute], for an adaptive [PageRoute] that uses a
///    platform-appropriate transition.
///  * [CupertinoPageScaffold], for applications that have one page with a fixed
///    navigation bar on top.
///  * [CupertinoTabScaffold], for applications that have a tab bar at the
///    bottom with multiple pages.
///  * [CupertinoPage], for a [Page] version of this class.
class CupertinoPageRoute<T> extends PageRoute<T> with CupertinoRouteTransitionMixin<T> {
  /// Creates a page route for use in an iOS designed app.
  ///
  /// The [builder], [maintainState], and [fullscreenDialog] arguments must not
  /// be null.
  CupertinoPageRoute({
    required this.builder,
    this.title,
    super.settings,
    super.requestFocus,
    this.maintainState = true,
    super.fullscreenDialog,
    super.allowSnapshotting = true,
    super.barrierDismissible = false,
  }) {
    assert(opaque);
  }

  @override
  DelegatedTransitionBuilder? get delegatedTransition =>
      CupertinoPageTransition.delegatedTransition;

  /// Builds the primary contents of the route.
  final WidgetBuilder builder;

  @override
  Widget buildContent(BuildContext context) => builder(context);

  @override
  final String? title;

  @override
  final bool maintainState;

  @override
  String get debugLabel => '${super.debugLabel}(${settings.name})';
}

// A page-based version of CupertinoPageRoute.
//
// This route uses the builder from the page to build its content. This ensures
// the content is up to date after page updates.
class _PageBasedCupertinoPageRoute<T> extends PageRoute<T> with CupertinoRouteTransitionMixin<T> {
  _PageBasedCupertinoPageRoute({required CupertinoPage<T> page, super.allowSnapshotting = true})
    : super(settings: page) {
    assert(opaque);
  }

  @override
  DelegatedTransitionBuilder? get delegatedTransition =>
      this.fullscreenDialog ? null : CupertinoPageTransition.delegatedTransition;

  CupertinoPage<T> get _page => settings as CupertinoPage<T>;

  @override
  Widget buildContent(BuildContext context) => _page.child;

  @override
  String? get title => _page.title;

  @override
  bool get maintainState => _page.maintainState;

  @override
  bool get fullscreenDialog => _page.fullscreenDialog;

  @override
  String get debugLabel => '${super.debugLabel}(${_page.name})';
}

/// A page that creates a cupertino style [PageRoute].
///
/// {@macro flutter.cupertino.cupertinoRouteTransitionMixin}
///
/// By default, when a created modal route is replaced by another, the previous
/// route remains in memory. To free all the resources when this is not
/// necessary, set [maintainState] to false.
///
/// The type `T` specifies the return type of the route which can be supplied as
/// the route is popped from the stack via [Navigator.transitionDelegate] by
/// providing the optional `result` argument to the
/// [RouteTransitionRecord.markForPop] in the [TransitionDelegate.resolve].
///
/// See also:
///
///  * [CupertinoPageRoute], for a [PageRoute] version of this class.
class CupertinoPage<T> extends Page<T> {
  /// Creates a cupertino page.
  const CupertinoPage({
    required this.child,
    this.maintainState = true,
    this.title,
    this.fullscreenDialog = false,
    this.allowSnapshotting = true,
    super.canPop,
    super.onPopInvoked,
    super.key,
    super.name,
    super.arguments,
    super.restorationId,
  });

  /// The content to be shown in the [Route] created by this page.
  final Widget child;

  /// {@macro flutter.cupertino.CupertinoRouteTransitionMixin.title}
  final String? title;

  /// {@macro flutter.widgets.ModalRoute.maintainState}
  final bool maintainState;

  /// {@macro flutter.widgets.PageRoute.fullscreenDialog}
  final bool fullscreenDialog;

  /// {@macro flutter.widgets.TransitionRoute.allowSnapshotting}
  final bool allowSnapshotting;

  @override
  Route<T> createRoute(BuildContext context) {
    return _PageBasedCupertinoPageRoute<T>(page: this, allowSnapshotting: allowSnapshotting);
  }
}

/// Provides an iOS-style page transition animation.
///
/// The page slides in from the right and exits in reverse. It also shifts to the left in
/// a parallax motion when another page enters to cover it.
class CupertinoPageTransition extends StatefulWidget {
  /// Creates an iOS-style page transition.
  ///
  const CupertinoPageTransition({
    super.key,
    required this.primaryRouteAnimation,
    required this.secondaryRouteAnimation,
    required this.child,
    required this.linearTransition,
  });

  /// The widget below this widget in the tree.
  final Widget child;

  ///  * `primaryRouteAnimation` is a linear route animation from 0.0 to 1.0
  ///    when this screen is being pushed.
  final Animation<double> primaryRouteAnimation;

  ///  * `secondaryRouteAnimation` is a linear route animation from 0.0 to 1.0
  ///    when another screen is being pushed on top of this one.
  final Animation<double> secondaryRouteAnimation;

  ///  * `linearTransition` is whether to perform the transitions linearly.
  ///    Used to precisely track back gesture drags.
  final bool linearTransition;

  /// The Cupertino styled [DelegatedTransitionBuilder] provided to the previous
  /// route.
  ///
  /// {@macro flutter.widgets.delegatedTransition}
  static Widget? delegatedTransition(
    BuildContext context,
    Animation<double> animation,
    Animation<double> secondaryAnimation,
    bool allowSnapshotting,
    Widget? child,
  ) {
    final CurvedAnimation animation = CurvedAnimation(
      parent: secondaryAnimation,
      curve: Curves.linearToEaseOut,
      reverseCurve: Curves.easeInToLinear,
    );
    final Animation<Offset> delegatedPositionAnimation = animation.drive(_kMiddleLeftTween);
    animation.dispose();

    assert(debugCheckHasDirectionality(context));
    final TextDirection textDirection = Directionality.of(context);
    return SlideTransition(
      position: delegatedPositionAnimation,
      textDirection: textDirection,
      transformHitTests: false,
      child: child,
    );
  }

  @override
  State<CupertinoPageTransition> createState() => _CupertinoPageTransitionState();
}

class _CupertinoPageTransitionState extends State<CupertinoPageTransition> {
  // When this page is coming in to cover another page.
  late Animation<Offset> _primaryPositionAnimation;
  // When this page is becoming covered by another page.
  late Animation<Offset> _secondaryPositionAnimation;
  // Shadow of page which is coming in to cover another page.
  late Animation<Decoration> _primaryShadowAnimation;
  // Curve of primary page which is coming in to cover another page.
  CurvedAnimation? _primaryPositionCurve;
  // Curve of secondary page which is becoming covered by another page.
  CurvedAnimation? _secondaryPositionCurve;
  // Curve of primary page's shadow.
  CurvedAnimation? _primaryShadowCurve;

  @override
  void initState() {
    super.initState();
    _setupAnimation();
  }

  @override
  void didUpdateWidget(covariant CupertinoPageTransition oldWidget) {
    super.didUpdateWidget(oldWidget);
    if (oldWidget.primaryRouteAnimation != widget.primaryRouteAnimation ||
        oldWidget.secondaryRouteAnimation != widget.secondaryRouteAnimation ||
        oldWidget.linearTransition != widget.linearTransition) {
      _disposeCurve();
      _setupAnimation();
    }
  }

  @override
  void dispose() {
    _disposeCurve();
    super.dispose();
  }

  void _disposeCurve() {
    _primaryPositionCurve?.dispose();
    _secondaryPositionCurve?.dispose();
    _primaryShadowCurve?.dispose();
    _primaryPositionCurve = null;
    _secondaryPositionCurve = null;
    _primaryShadowCurve = null;
  }

  void _setupAnimation() {
    if (!widget.linearTransition) {
      _primaryPositionCurve = CurvedAnimation(
        parent: widget.primaryRouteAnimation,
        curve: Curves.fastEaseInToSlowEaseOut,
        reverseCurve: Curves.fastEaseInToSlowEaseOut.flipped,
      );
      _secondaryPositionCurve = CurvedAnimation(
        parent: widget.secondaryRouteAnimation,
        curve: Curves.linearToEaseOut,
        reverseCurve: Curves.easeInToLinear,
      );
      _primaryShadowCurve = CurvedAnimation(
        parent: widget.primaryRouteAnimation,
        curve: Curves.linearToEaseOut,
      );
    }
    _primaryPositionAnimation = (_primaryPositionCurve ?? widget.primaryRouteAnimation).drive(
      _kRightMiddleTween,
    );
    _secondaryPositionAnimation = (_secondaryPositionCurve ?? widget.secondaryRouteAnimation).drive(
      _kMiddleLeftTween,
    );
    _primaryShadowAnimation = (_primaryShadowCurve ?? widget.primaryRouteAnimation).drive(
      _CupertinoEdgeShadowDecoration.kTween,
    );
  }

  @override
  Widget build(BuildContext context) {
    assert(debugCheckHasDirectionality(context));
    final TextDirection textDirection = Directionality.of(context);
    return SlideTransition(
      position: _secondaryPositionAnimation,
      textDirection: textDirection,
      transformHitTests: false,
      child: SlideTransition(
        position: _primaryPositionAnimation,
        textDirection: textDirection,
        child: DecoratedBoxTransition(decoration: _primaryShadowAnimation, child: widget.child),
      ),
    );
  }
}

/// An iOS-style transition used for summoning fullscreen dialogs.
///
/// For example, used when creating a new calendar event by bringing in the next
/// screen from the bottom.
class CupertinoFullscreenDialogTransition extends StatefulWidget {
  /// Creates an iOS-style transition used for summoning fullscreen dialogs.
  ///
  const CupertinoFullscreenDialogTransition({
    super.key,
    required this.primaryRouteAnimation,
    required this.secondaryRouteAnimation,
    required this.child,
    required this.linearTransition,
  });

  ///  * `primaryRouteAnimation` is a linear route animation from 0.0 to 1.0
  ///    when this screen is being pushed.
  final Animation<double> primaryRouteAnimation;

  ///  * `secondaryRouteAnimation` is a linear route animation from 0.0 to 1.0
  ///    when another screen is being pushed on top of this one.
  final Animation<double> secondaryRouteAnimation;

  ///  * `linearTransition` is whether to perform the transitions linearly.
  ///    Used to precisely track back gesture drags.
  final bool linearTransition;

  /// The widget below this widget in the tree.
  final Widget child;

  @override
  State<CupertinoFullscreenDialogTransition> createState() =>
      _CupertinoFullscreenDialogTransitionState();
}

class _CupertinoFullscreenDialogTransitionState extends State<CupertinoFullscreenDialogTransition> {
  /// When this page is coming in to cover another page.
  late Animation<Offset> _primaryPositionAnimation;

  /// When this page is becoming covered by another page.
  late Animation<Offset> _secondaryPositionAnimation;

  /// Curve of primary page which is coming in to cover another page.
  CurvedAnimation? _primaryPositionCurve;

  /// Curve of secondary page which is becoming covered by another page.
  CurvedAnimation? _secondaryPositionCurve;

  @override
  void initState() {
    super.initState();
    _setupAnimation();
  }

  @override
  void didUpdateWidget(covariant CupertinoFullscreenDialogTransition oldWidget) {
    super.didUpdateWidget(oldWidget);
    if (oldWidget.primaryRouteAnimation != widget.primaryRouteAnimation ||
        oldWidget.secondaryRouteAnimation != widget.secondaryRouteAnimation ||
        oldWidget.linearTransition != widget.linearTransition) {
      _disposeCurve();
      _setupAnimation();
    }
  }

  @override
  void dispose() {
    _disposeCurve();
    super.dispose();
  }

  void _disposeCurve() {
    _primaryPositionCurve?.dispose();
    _secondaryPositionCurve?.dispose();
    _primaryPositionCurve = null;
    _secondaryPositionCurve = null;
  }

  void _setupAnimation() {
    _primaryPositionAnimation = (_primaryPositionCurve = CurvedAnimation(
          parent: widget.primaryRouteAnimation,
          curve: Curves.linearToEaseOut,
          // The curve must be flipped so that the reverse animation doesn't play
          // an ease-in curve, which iOS does not use.
          reverseCurve: Curves.linearToEaseOut.flipped,
        ))
        .drive(_kBottomUpTween);
    _secondaryPositionAnimation = (widget.linearTransition
            ? widget.secondaryRouteAnimation
            : _secondaryPositionCurve = CurvedAnimation(
              parent: widget.secondaryRouteAnimation,
              curve: Curves.linearToEaseOut,
              reverseCurve: Curves.easeInToLinear,
            ))
        .drive(_kMiddleLeftTween);
  }

  @override
  Widget build(BuildContext context) {
    assert(debugCheckHasDirectionality(context));
    final TextDirection textDirection = Directionality.of(context);
    return SlideTransition(
      position: _secondaryPositionAnimation,
      textDirection: textDirection,
      transformHitTests: false,
      child: SlideTransition(position: _primaryPositionAnimation, child: widget.child),
    );
  }
}

/// This is the widget side of [_CupertinoBackGestureController].
///
/// This widget provides a gesture recognizer which, when it determines the
/// route can be closed with a back gesture, creates the controller and
/// feeds it the input from the gesture recognizer.
///
/// The gesture data is converted from absolute coordinates to logical
/// coordinates by this widget.
///
/// The type `T` specifies the return type of the route with which this gesture
/// detector is associated.
class _CupertinoBackGestureDetector<T> extends StatefulWidget {
  const _CupertinoBackGestureDetector({
    super.key,
    required this.enabledCallback,
    required this.onStartPopGesture,
    required this.child,
  });

  final Widget child;

  final ValueGetter<bool> enabledCallback;

  final ValueGetter<_CupertinoBackGestureController<T>> onStartPopGesture;

  @override
  _CupertinoBackGestureDetectorState<T> createState() => _CupertinoBackGestureDetectorState<T>();
}

class _CupertinoBackGestureDetectorState<T> extends State<_CupertinoBackGestureDetector<T>> {
  _CupertinoBackGestureController<T>? _backGestureController;

  late HorizontalDragGestureRecognizer _recognizer;

  @override
  void initState() {
    super.initState();
    _recognizer =
        HorizontalDragGestureRecognizer(debugOwner: this)
          ..onStart = _handleDragStart
          ..onUpdate = _handleDragUpdate
          ..onEnd = _handleDragEnd
          ..onCancel = _handleDragCancel;
  }

  @override
  void dispose() {
    _recognizer.dispose();

    // If this is disposed during a drag, call navigator.didStopUserGesture.
    if (_backGestureController != null) {
      WidgetsBinding.instance.addPostFrameCallback((_) {
        if (_backGestureController?.navigator.mounted ?? false) {
          _backGestureController?.navigator.didStopUserGesture();
        }
        _backGestureController = null;
      });
    }
    super.dispose();
  }

  void _handleDragStart(DragStartDetails details) {
    assert(mounted);
    assert(_backGestureController == null);
    _backGestureController = widget.onStartPopGesture();
  }

  void _handleDragUpdate(DragUpdateDetails details) {
    assert(mounted);
    assert(_backGestureController != null);
    _backGestureController!.dragUpdate(
      _convertToLogical(details.primaryDelta! / context.size!.width),
    );
  }

  void _handleDragEnd(DragEndDetails details) {
    assert(mounted);
    assert(_backGestureController != null);
    _backGestureController!.dragEnd(
      _convertToLogical(details.velocity.pixelsPerSecond.dx / context.size!.width),
    );
    _backGestureController = null;
  }

  void _handleDragCancel() {
    assert(mounted);
    // This can be called even if start is not called, paired with the "down" event
    // that we don't consider here.
    _backGestureController?.dragEnd(0.0);
    _backGestureController = null;
  }

  void _handlePointerDown(PointerDownEvent event) {
    if (widget.enabledCallback()) {
      _recognizer.addPointer(event);
    }
  }

  double _convertToLogical(double value) {
    return switch (Directionality.of(context)) {
      TextDirection.rtl => -value,
      TextDirection.ltr => value,
    };
  }

  @override
  Widget build(BuildContext context) {
    assert(debugCheckHasDirectionality(context));
    // For devices with notches, the drag area needs to be larger on the side
    // that has the notch.
    final double dragAreaWidth = switch (Directionality.of(context)) {
      TextDirection.rtl => MediaQuery.paddingOf(context).right,
      TextDirection.ltr => MediaQuery.paddingOf(context).left,
    };
    return Stack(
      fit: StackFit.passthrough,
      children: <Widget>[
        widget.child,
        PositionedDirectional(
          start: 0.0,
          width: max(dragAreaWidth, _kBackGestureWidth),
          top: 0.0,
          bottom: 0.0,
          child: Listener(onPointerDown: _handlePointerDown, behavior: HitTestBehavior.translucent),
        ),
      ],
    );
  }
}

/// A controller for an iOS-style back gesture.
///
/// This is created by a [CupertinoPageRoute] in response from a gesture caught
/// by a [_CupertinoBackGestureDetector] widget, which then also feeds it input
/// from the gesture. It controls the animation controller owned by the route,
/// based on the input provided by the gesture detector.
///
/// This class works entirely in logical coordinates (0.0 is new page dismissed,
/// 1.0 is new page on top).
///
/// The type `T` specifies the return type of the route with which this gesture
/// detector controller is associated.
class _CupertinoBackGestureController<T> {
  /// Creates a controller for an iOS-style back gesture.
  _CupertinoBackGestureController({
    required this.navigator,
    required this.controller,
    required this.getIsActive,
    required this.getIsCurrent,
  }) {
    navigator.didStartUserGesture();
  }

  final AnimationController controller;
  final NavigatorState navigator;
  final ValueGetter<bool> getIsActive;
  final ValueGetter<bool> getIsCurrent;

  /// The drag gesture has changed by [delta]. The total range of the drag
  /// should be 0.0 to 1.0.
  void dragUpdate(double delta) {
    controller.value -= delta;
  }

  /// The drag gesture has ended with a horizontal motion of [velocity] as a
  /// fraction of screen width per second.
  void dragEnd(double velocity) {
    // Fling in the appropriate direction.
    //
    // This curve has been determined through rigorously eyeballing native iOS
    // animations.
    const Curve animationCurve = Curves.fastEaseInToSlowEaseOut;
    final bool isCurrent = getIsCurrent();
    final bool animateForward;

    if (!isCurrent) {
      // If the page has already been navigated away from, then the animation
      // direction depends on whether or not it's still in the navigation stack,
      // regardless of velocity or drag position. For example, if a route is
      // being slowly dragged back by just a few pixels, but then a programmatic
      // pop occurs, the route should still be animated off the screen.
      // See https://github.com/flutter/flutter/issues/141268.
      animateForward = getIsActive();
    } else if (velocity.abs() >= _kMinFlingVelocity) {
      // If the user releases the page before mid screen with sufficient velocity,
      // or after mid screen, we should animate the page out. Otherwise, the page
      // should be animated back in.
      animateForward = velocity <= 0;
    } else {
      animateForward = controller.value > 0.5;
    }

    if (animateForward) {
      controller.animateTo(
        1.0,
        duration: _kDroppedSwipePageAnimationDuration,
        curve: animationCurve,
      );
    } else {
      if (isCurrent) {
        // This route is destined to pop at this point. Reuse navigator's pop.
        navigator.pop();
      }

      // The popping may have finished inline if already at the target destination.
      if (controller.isAnimating) {
        controller.animateBack(
          0.0,
          duration: _kDroppedSwipePageAnimationDuration,
          curve: animationCurve,
        );
      }
    }

    if (controller.isAnimating) {
      // Keep the userGestureInProgress in true state so we don't change the
      // curve of the page transition mid-flight since CupertinoPageTransition
      // depends on userGestureInProgress.
      late AnimationStatusListener animationStatusCallback;
      animationStatusCallback = (AnimationStatus status) {
        navigator.didStopUserGesture();
        controller.removeStatusListener(animationStatusCallback);
      };
      controller.addStatusListener(animationStatusCallback);
    } else {
      navigator.didStopUserGesture();
    }
  }
}

// A custom [Decoration] used to paint an extra shadow on the start edge of the
// box it's decorating. It's like a [BoxDecoration] with only a gradient except
// it paints on the start side of the box instead of behind the box.
class _CupertinoEdgeShadowDecoration extends Decoration {
  const _CupertinoEdgeShadowDecoration._([this._colors]);

  static DecorationTween kTween = DecorationTween(
    begin: const _CupertinoEdgeShadowDecoration._(), // No decoration initially.
    end: const _CupertinoEdgeShadowDecoration._(
      // Eyeballed gradient used to mimic a drop shadow on the start side only.
      <Color>[Color(0x04000000), CupertinoColors.transparent],
    ),
  );

  // Colors used to paint a gradient at the start edge of the box it is
  // decorating.
  //
  // The first color in the list is used at the start of the gradient, which
  // is located at the start edge of the decorated box.
  //
  // If this is null, no shadow is drawn.
  //
  // The list must have at least two colors in it (otherwise it would not be a
  // gradient).
  final List<Color>? _colors;

  // Linearly interpolate between two edge shadow decorations decorations.
  //
  // The `t` argument represents position on the timeline, with 0.0 meaning
  // that the interpolation has not started, returning `a` (or something
  // equivalent to `a`), 1.0 meaning that the interpolation has finished,
  // returning `b` (or something equivalent to `b`), and values in between
  // meaning that the interpolation is at the relevant point on the timeline
  // between `a` and `b`. The interpolation can be extrapolated beyond 0.0 and
  // 1.0, so negative values and values greater than 1.0 are valid (and can
  // easily be generated by curves such as [Curves.elasticInOut]).
  //
  // Values for `t` are usually obtained from an [Animation<double>], such as
  // an [AnimationController].
  //
  // See also:
  //
  //  * [Decoration.lerp].
  static _CupertinoEdgeShadowDecoration? lerp(
    _CupertinoEdgeShadowDecoration? a,
    _CupertinoEdgeShadowDecoration? b,
    double t,
  ) {
    if (identical(a, b)) {
      return a;
    }
    if (a == null) {
      return b!._colors == null
          ? b
          : _CupertinoEdgeShadowDecoration._(
            b._colors!.map<Color>((Color color) => Color.lerp(null, color, t)!).toList(),
          );
    }
    if (b == null) {
      return a._colors == null
          ? a
          : _CupertinoEdgeShadowDecoration._(
            a._colors.map<Color>((Color color) => Color.lerp(null, color, 1.0 - t)!).toList(),
          );
    }
    assert(b._colors != null || a._colors != null);
    // If it ever becomes necessary, we could allow decorations with different
    // length' here, similarly to how it is handled in [LinearGradient.lerp].
    assert(b._colors == null || a._colors == null || a._colors.length == b._colors.length);
    return _CupertinoEdgeShadowDecoration._(<Color>[
      for (int i = 0; i < b._colors!.length; i += 1) Color.lerp(a._colors?[i], b._colors[i], t)!,
    ]);
  }

  @override
  _CupertinoEdgeShadowDecoration lerpFrom(Decoration? a, double t) {
    if (a is _CupertinoEdgeShadowDecoration) {
      return _CupertinoEdgeShadowDecoration.lerp(a, this, t)!;
    }
    return _CupertinoEdgeShadowDecoration.lerp(null, this, t)!;
  }

  @override
  _CupertinoEdgeShadowDecoration lerpTo(Decoration? b, double t) {
    if (b is _CupertinoEdgeShadowDecoration) {
      return _CupertinoEdgeShadowDecoration.lerp(this, b, t)!;
    }
    return _CupertinoEdgeShadowDecoration.lerp(this, null, t)!;
  }

  @override
  _CupertinoEdgeShadowPainter createBoxPainter([VoidCallback? onChanged]) {
    return _CupertinoEdgeShadowPainter(this, onChanged);
  }

  @override
  bool operator ==(Object other) {
    if (other.runtimeType != runtimeType) {
      return false;
    }
    return other is _CupertinoEdgeShadowDecoration && other._colors == _colors;
  }

  @override
  int get hashCode => _colors.hashCode;

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties.add(IterableProperty<Color>('colors', _colors));
  }
}

/// A [BoxPainter] used to draw the page transition shadow using gradients.
class _CupertinoEdgeShadowPainter extends BoxPainter {
  _CupertinoEdgeShadowPainter(this._decoration, super.onChanged)
    : assert(_decoration._colors == null || _decoration._colors.length > 1);

  final _CupertinoEdgeShadowDecoration _decoration;

  @override
  void paint(Canvas canvas, Offset offset, ImageConfiguration configuration) {
    final List<Color>? colors = _decoration._colors;
    if (colors == null) {
      return;
    }

    // The following code simulates drawing a [LinearGradient] configured as
    // follows:
    //
    // LinearGradient(
    //   begin: AlignmentDirectional(0.90, 0.0), // Spans 5% of the page.
    //   colors: _decoration._colors,
    // )
    //
    // A performance evaluation on Feb 8, 2021 showed, that drawing the gradient
    // manually as implemented below is more performant than relying on
    // [LinearGradient.createShader] because compiling that shader takes a long
    // time. On an iPhone XR, the implementation below reduced the worst frame
    // time for a cupertino page transition of a newly installed app from ~95ms
    // down to ~30ms, mainly because there's no longer a need to compile a
    // shader for the LinearGradient.
    //
    // The implementation below divides the width of the shadow into multiple
    // bands of equal width, one for each color interval defined by
    // `_decoration._colors`. Band x is filled with a gradient going from
    // `_decoration._colors[x]` to `_decoration._colors[x + 1]` by drawing a
    // bunch of 1px wide rects. The rects change their color by lerping between
    // the two colors that define the interval of the band.

    // Shadow spans 5% of the page.
    final double shadowWidth = 0.05 * configuration.size!.width;
    final double shadowHeight = configuration.size!.height;
    final double bandWidth = shadowWidth / (colors.length - 1);

    final TextDirection? textDirection = configuration.textDirection;
    assert(textDirection != null);
    final (double shadowDirection, double start) = switch (textDirection!) {
      TextDirection.rtl => (1, offset.dx + configuration.size!.width),
      TextDirection.ltr => (-1, offset.dx),
    };

    int bandColorIndex = 0;
    for (int dx = 0; dx < shadowWidth; dx += 1) {
      if (dx ~/ bandWidth != bandColorIndex) {
        bandColorIndex += 1;
      }
      final Paint paint =
          Paint()
            ..color =
                Color.lerp(
                  colors[bandColorIndex],
                  colors[bandColorIndex + 1],
                  (dx % bandWidth) / bandWidth,
                )!;
      final double x = start + shadowDirection * dx;
      canvas.drawRect(Rect.fromLTWH(x - 1.0, offset.dy, 1.0, shadowHeight), paint);
    }
  }
}

// The stiffness used by dialogs and action sheets.
//
// The stiffness value is obtained by examining the properties of
// `CASpringAnimation` in Xcode. The damping value is derived similarly, with
// additional precision calculated based on `_kStandardStiffness` to ensure a
// damping ratio of 1 (critically damped): damping = 2 * sqrt(stiffness)
const double _kStandardStiffness = 522.35;
const double _kStandardDamping = 45.7099552;
const SpringDescription _kStandardSpring = SpringDescription(
  mass: 1,
  stiffness: _kStandardStiffness,
  damping: _kStandardDamping,
);
// The iOS spring animation duration is 0.404 seconds, based on the properties
// of `CASpringAnimation` in Xcode. At this point, the spring's position
// `x(0.404)` is approximately 0.9990000, suggesting that iOS uses a position
// tolerance of 1e-3 (matching the default `_epsilonDefault` value).
//
// However, the spring's velocity `dx(0.404)` is about 0.02, indicating that iOS
// may not consider velocity when determining the animation's end condition. To
// account for this, a larger velocity tolerance is applied here for added
// safety.
const Tolerance _kStandardTolerance = Tolerance(velocity: 0.03);

/// A route that shows a modal iOS-style popup that slides up from the
/// bottom of the screen.
///
/// Such a popup is an alternative to a menu or a dialog and prevents the user
/// from interacting with the rest of the app.
///
/// It is used internally by [showCupertinoModalPopup] or can be directly pushed
/// onto the [Navigator] stack to enable state restoration. See
/// [showCupertinoModalPopup] for a state restoration app example.
///
/// The `barrierColor` argument determines the [Color] of the barrier underneath
/// the popup. When unspecified, the barrier color defaults to a light opacity
/// black scrim based on iOS's dialog screens. To correctly have iOS resolve
/// to the appropriate modal colors, pass in
/// `CupertinoDynamicColor.resolve(kCupertinoModalBarrierColor, context)`.
///
/// The `barrierDismissible` argument determines whether clicking outside the
/// popup results in dismissal. It is `true` by default.
///
/// The `semanticsDismissible` argument is used to determine whether the
/// semantics of the modal barrier are included in the semantics tree.
///
/// The `routeSettings` argument is used to provide [RouteSettings] to the
/// created Route.
///
/// {@macro flutter.widgets.RawDialogRoute}
///
/// See also:
///
///  * [DisplayFeatureSubScreen], which documents the specifics of how
///    [DisplayFeature]s can split the screen into sub-screens.
///  * [CupertinoActionSheet], which is the widget usually returned by the
///    `builder` argument.
///  * <https://developer.apple.com/design/human-interface-guidelines/ios/views/action-sheets/>
class CupertinoModalPopupRoute<T> extends PopupRoute<T> {
  /// A route that shows a modal iOS-style popup that slides up from the
  /// bottom of the screen.
  CupertinoModalPopupRoute({
    required this.builder,
    this.barrierLabel = 'Dismiss',
    this.barrierColor = kCupertinoModalBarrierColor,
    bool barrierDismissible = true,
    bool semanticsDismissible = false,
    super.filter,
    super.settings,
    super.requestFocus,
    this.anchorPoint,
  }) : _barrierDismissible = barrierDismissible,
       _semanticsDismissible = semanticsDismissible;

  /// A builder that builds the widget tree for the [CupertinoModalPopupRoute].
  ///
  /// The [builder] argument typically builds a [CupertinoActionSheet] widget.
  ///
  /// Content below the widget is dimmed with a [ModalBarrier]. The widget built
  /// by the [builder] does not share a context with the route it was originally
  /// built from. Use a [StatefulBuilder] or a custom [StatefulWidget] if the
  /// widget needs to update dynamically.
  final WidgetBuilder builder;

  final bool _barrierDismissible;

  final bool _semanticsDismissible;

  @override
  final String barrierLabel;

  @override
  final Color? barrierColor;

  @override
  bool get barrierDismissible => _barrierDismissible;

  @override
  bool get semanticsDismissible => _semanticsDismissible;

  @override
  Duration get transitionDuration => _kModalPopupTransitionDuration;

  /// {@macro flutter.widgets.DisplayFeatureSubScreen.anchorPoint}
  final Offset? anchorPoint;

  @override
  Simulation createSimulation({required bool forward}) {
    assert(!debugTransitionCompleted(), 'Cannot reuse a $runtimeType after disposing it.');
    final double end = forward ? 1.0 : 0.0;
    return SpringSimulation(
      _kStandardSpring,
      controller!.value,
      end,
      0,
      tolerance: _kStandardTolerance,
      snapToEnd: true,
    );
  }

  @override
  Widget buildPage(
    BuildContext context,
    Animation<double> animation,
    Animation<double> secondaryAnimation,
  ) {
    return CupertinoUserInterfaceLevel(
      data: CupertinoUserInterfaceLevelData.elevated,
      child: DisplayFeatureSubScreen(anchorPoint: anchorPoint, child: Builder(builder: builder)),
    );
  }

  @override
  Widget buildTransitions(
    BuildContext context,
    Animation<double> animation,
    Animation<double> secondaryAnimation,
    Widget child,
  ) {
    return Align(
      alignment: Alignment.bottomCenter,
      child: FractionalTranslation(translation: _offsetTween.evaluate(animation), child: child),
    );
  }

  static final Tween<Offset> _offsetTween = Tween<Offset>(
    begin: const Offset(0.0, 1.0),
    end: Offset.zero,
  );
}

/// Shows a modal iOS-style popup that slides up from the bottom of the screen.
///
/// Such a popup is an alternative to a menu or a dialog and prevents the user
/// from interacting with the rest of the app.
///
/// The `context` argument is used to look up the [Navigator] for the popup.
/// It is only used when the method is called. Its corresponding widget can be
/// safely removed from the tree before the popup is closed.
///
/// The `barrierColor` argument determines the [Color] of the barrier underneath
/// the popup. When unspecified, the barrier color defaults to a light opacity
/// black scrim based on iOS's dialog screens.
///
/// The `barrierDismissible` argument determines whether clicking outside the
/// popup results in dismissal. It is `true` by default.
///
/// The `useRootNavigator` argument is used to determine whether to push the
/// popup to the [Navigator] furthest from or nearest to the given `context`. It
/// is `true` by default.
///
/// The `semanticsDismissible` argument is used to determine whether the
/// semantics of the modal barrier are included in the semantics tree.
///
/// The `routeSettings` argument is used to provide [RouteSettings] to the
/// created Route.
///
/// The `builder` argument typically builds a [CupertinoActionSheet] widget.
/// Content below the widget is dimmed with a [ModalBarrier]. The widget built
/// by the `builder` does not share a context with the location that
/// [showCupertinoModalPopup] is originally called from. Use a
/// [StatefulBuilder] or a custom [StatefulWidget] if the widget needs to
/// update dynamically.
///
/// {@macro flutter.widgets.RawDialogRoute}
///
/// Returns a `Future` that resolves to the value that was passed to
/// [Navigator.pop] when the popup was closed.
///
/// ### State Restoration in Modals
///
/// Using this method will not enable state restoration for the modal. In order
/// to enable state restoration for a modal, use [Navigator.restorablePush]
/// or [Navigator.restorablePushNamed] with [CupertinoModalPopupRoute].
///
/// For more information about state restoration, see [RestorationManager].
///
/// {@tool dartpad}
/// This sample demonstrates how to create a restorable Cupertino modal route.
/// This is accomplished by enabling state restoration by specifying
/// [CupertinoApp.restorationScopeId] and using [Navigator.restorablePush] to
/// push [CupertinoModalPopupRoute] when the [CupertinoButton] is tapped.
///
/// {@macro flutter.widgets.RestorationManager}
///
/// ** See code in examples/api/lib/cupertino/route/show_cupertino_modal_popup.0.dart **
/// {@end-tool}
///
/// See also:
///
///  * [DisplayFeatureSubScreen], which documents the specifics of how
///    [DisplayFeature]s can split the screen into sub-screens.
///  * [CupertinoActionSheet], which is the widget usually returned by the
///    `builder` argument to [showCupertinoModalPopup].
///  * <https://developer.apple.com/design/human-interface-guidelines/ios/views/action-sheets/>
Future<T?> showCupertinoModalPopup<T>({
  required BuildContext context,
  required WidgetBuilder builder,
  ImageFilter? filter,
  Color barrierColor = kCupertinoModalBarrierColor,
  bool barrierDismissible = true,
  bool useRootNavigator = true,
  bool semanticsDismissible = false,
  RouteSettings? routeSettings,
  Offset? anchorPoint,
}) {
  return Navigator.of(context, rootNavigator: useRootNavigator).push(
    CupertinoModalPopupRoute<T>(
      builder: builder,
      filter: filter,
      barrierColor: CupertinoDynamicColor.resolve(barrierColor, context),
      barrierDismissible: barrierDismissible,
      semanticsDismissible: semanticsDismissible,
      settings: routeSettings,
      anchorPoint: anchorPoint,
    ),
  );
}

Widget _buildCupertinoDialogTransitions(
  BuildContext context,
  Animation<double> animation,
  Animation<double> secondaryAnimation,
  Widget child,
) {
  return child;
}

/// Displays an iOS-style dialog above the current contents of the app, with
/// iOS-style entrance and exit animations, modal barrier color, and modal
/// barrier behavior (by default, the dialog is not dismissible with a tap on
/// the barrier).
///
/// This function takes a `builder` which typically builds a [CupertinoAlertDialog]
/// widget. Content below the dialog is dimmed with a [ModalBarrier]. The widget
/// returned by the `builder` does not share a context with the location that
/// [showCupertinoDialog] is originally called from. Use a [StatefulBuilder] or
/// a custom [StatefulWidget] if the dialog needs to update dynamically.
///
/// The `context` argument is used to look up the [Navigator] for the dialog.
/// It is only used when the method is called. Its corresponding widget can
/// be safely removed from the tree before the dialog is closed.
///
/// The `useRootNavigator` argument is used to determine whether to push the
/// dialog to the [Navigator] furthest from or nearest to the given `context`.
/// By default, `useRootNavigator` is `true` and the dialog route created by
/// this method is pushed to the root navigator.
///
/// {@macro flutter.widgets.RawDialogRoute}
///
/// If the application has multiple [Navigator] objects, it may be necessary to
/// call `Navigator.of(context, rootNavigator: true).pop(result)` to close the
/// dialog rather than just `Navigator.pop(context, result)`.
///
/// Returns a [Future] that resolves to the value (if any) that was passed to
/// [Navigator.pop] when the dialog was closed.
///
/// ### State Restoration in Dialogs
///
/// Using this method will not enable state restoration for the dialog. In order
/// to enable state restoration for a dialog, use [Navigator.restorablePush]
/// or [Navigator.restorablePushNamed] with [CupertinoDialogRoute].
///
/// For more information about state restoration, see [RestorationManager].
///
/// {@tool dartpad}
/// This sample demonstrates how to create a restorable Cupertino dialog. This is
/// accomplished by enabling state restoration by specifying
/// [CupertinoApp.restorationScopeId] and using [Navigator.restorablePush] to
/// push [CupertinoDialogRoute] when the [CupertinoButton] is tapped.
///
/// {@macro flutter.widgets.RestorationManager}
///
/// ** See code in examples/api/lib/cupertino/route/show_cupertino_dialog.0.dart **
/// {@end-tool}
///
/// See also:
///
///  * [CupertinoAlertDialog], an iOS-style alert dialog.
///  * [showDialog], which displays a Material-style dialog.
///  * [showGeneralDialog], which allows for customization of the dialog popup.
///  * [DisplayFeatureSubScreen], which documents the specifics of how
///    [DisplayFeature]s can split the screen into sub-screens.
///  * <https://developer.apple.com/design/human-interface-guidelines/alerts/>
Future<T?> showCupertinoDialog<T>({
  required BuildContext context,
  required WidgetBuilder builder,
  String? barrierLabel,
  bool useRootNavigator = true,
  bool barrierDismissible = false,
  RouteSettings? routeSettings,
  Offset? anchorPoint,
}) {
  return Navigator.of(context, rootNavigator: useRootNavigator).push<T>(
    CupertinoDialogRoute<T>(
      builder: builder,
      context: context,
      barrierDismissible: barrierDismissible,
      barrierLabel: barrierLabel,
      barrierColor: CupertinoDynamicColor.resolve(kCupertinoModalBarrierColor, context),
      settings: routeSettings,
      anchorPoint: anchorPoint,
    ),
  );
}

/// A dialog route that shows an iOS-style dialog.
///
/// It is used internally by [showCupertinoDialog] or can be directly pushed
/// onto the [Navigator] stack to enable state restoration. See
/// [showCupertinoDialog] for a state restoration app example.
///
/// This function takes a `builder` which typically builds a [Dialog] widget.
/// Content below the dialog is dimmed with a [ModalBarrier]. The widget
/// returned by the `builder` does not share a context with the location that
/// `showDialog` is originally called from. Use a [StatefulBuilder] or a
/// custom [StatefulWidget] if the dialog needs to update dynamically.
///
/// The `context` argument is used to look up
/// [CupertinoLocalizations.modalBarrierDismissLabel], which provides the
/// modal with a localized accessibility label that will be used for the
/// modal's barrier. However, a custom `barrierLabel` can be passed in as well.
///
/// The `barrierDismissible` argument is used to indicate whether tapping on the
/// barrier will dismiss the dialog. It is `true` by default and cannot be `null`.
///
/// The `barrierColor` argument is used to specify the color of the modal
/// barrier that darkens everything below the dialog. If `null`, then
/// [CupertinoDynamicColor.resolve] is used to compute the modal color.
///
/// The `settings` argument define the settings for this route. See
/// [RouteSettings] for details.
///
/// {@macro flutter.widgets.RawDialogRoute}
///
/// See also:
///
///  * [showCupertinoDialog], which is a way to display
///     an iOS-style dialog.
///  * [showGeneralDialog], which allows for customization of the dialog popup.
///  * [showDialog], which displays a Material dialog.
///  * [DisplayFeatureSubScreen], which documents the specifics of how
///    [DisplayFeature]s can split the screen into sub-screens.
class CupertinoDialogRoute<T> extends RawDialogRoute<T> {
  /// A dialog route that shows an iOS-style dialog.
  CupertinoDialogRoute({
    required WidgetBuilder builder,
    required BuildContext context,
    super.barrierDismissible,
    Color? barrierColor,
    String? barrierLabel,
    // This transition duration was eyeballed comparing with iOS
    super.transitionDuration = const Duration(milliseconds: 250),
    this.transitionBuilder,
    super.settings,
    super.requestFocus,
    super.anchorPoint,
  }) : super(
         pageBuilder: (
           BuildContext context,
           Animation<double> animation,
           Animation<double> secondaryAnimation,
         ) {
           return builder(context);
         },
         transitionBuilder: transitionBuilder ?? _buildCupertinoDialogTransitions,
         barrierLabel: barrierLabel ?? CupertinoLocalizations.of(context).modalBarrierDismissLabel,
         barrierColor:
             barrierColor ?? CupertinoDynamicColor.resolve(kCupertinoModalBarrierColor, context),
       );

  /// Custom transition builder
  RouteTransitionsBuilder? transitionBuilder;

  CurvedAnimation? _fadeAnimation;

  @override
  Simulation createSimulation({required bool forward}) {
    assert(!debugTransitionCompleted(), 'Cannot reuse a $runtimeType after disposing it.');
    final double end = forward ? 1.0 : 0.0;
    return SpringSimulation(
      _kStandardSpring,
      controller!.value,
      end,
      0,
      tolerance: _kStandardTolerance,
      snapToEnd: true,
    );
  }

  @override
  Widget buildTransitions(
    BuildContext context,
    Animation<double> animation,
    Animation<double> secondaryAnimation,
    Widget child,
  ) {
    if (transitionBuilder != null) {
      return super.buildTransitions(context, animation, secondaryAnimation, child);
    }

    if (animation.status == AnimationStatus.reverse) {
      return FadeTransition(opacity: animation, child: child);
    }
    return FadeTransition(
      opacity: animation,
      child: ScaleTransition(scale: animation.drive(_dialogScaleTween), child: child),
    );
  }

  @override
  void dispose() {
    _fadeAnimation?.dispose();
    super.dispose();
  }

  // The curve and initial scale values were mostly eyeballed from iOS, however
  // they reuse the same animation curve that was modeled after native page
  // transitions.
  static final Tween<double> _dialogScaleTween = Tween<double>(begin: 1.3, end: 1.0);
}


Instructions for the chapter (Generate content in English unless specified otherwise):
- Start with a clear heading (e.g., `# Chapter 9: CupertinoDialogRoute
`). Use the provided concept name.

- If this is not the first chapter, begin with a brief transition from the previous chapter, referencing it with a proper Markdown link using its name.

- Begin with a high-level motivation explaining what problem this abstraction solves. Start with a central use case as a concrete example. The whole chapter should guide the reader to understand how to solve this use case. Make it very minimal and friendly to beginners.

- If the abstraction is complex, break it down into key concepts. Explain each concept one-by-one in a very beginner-friendly way.

- Explain how to use this abstraction to solve the use case. Give example inputs and outputs for code snippets (if the output isn't values, describe at a high level what will happen).

- Each code block should be BELOW 10 lines! If longer code blocks are needed, break them down into smaller pieces and walk through them one-by-one. Aggresively simplify the code to make it minimal. Use comments to skip non-important implementation details. Each code block should have a beginner friendly explanation right after it.

- Describe the internal implementation to help understand what's under the hood. First provide a non-code or code-light walkthrough on what happens step-by-step when the abstraction is called. It's recommended to use a simple sequenceDiagram with a dummy example - keep it minimal with at most 5 participants to ensure clarity. If participant name has space, use: `participant QP as Query Processing`. .

- Then dive deeper into code for the internal implementation with references to files. Provide example code blocks, but make them similarly simple and beginner-friendly. Explain.

- IMPORTANT: When you need to refer to other core abstractions covered in other chapters, ALWAYS use proper Markdown links like this: [Chapter Title](filename.md). Use the Complete Tutorial Structure above to find the correct filename and the chapter title. Translate the surrounding text.

- Use mermaid diagrams to illustrate complex concepts (```mermaid``` format). .

- Heavily use analogies and examples throughout to help beginners understand.

- End the chapter with a brief conclusion that summarizes what was learned and provides a transition to the next chapter. If there is a next chapter, use a proper Markdown link: [Next Chapter Title](next_chapter_filename).

- Ensure the tone is welcoming and easy for a newcomer to understand.

- Output *only* the Markdown content for this chapter.

Now, directly provide a super beginner-friendly Markdown output (DON'T need ```markdown``` tags):

2025-05-21 12:33:41,716 - INFO - RESPONSE: # Chapter 9: CupertinoDialogRoute

Welcome back, Future Flutter navigators! In [Chapter 8: CupertinoModalPopupRoute](08_cupertinomodalpopuproute_.md), we learned about showing panels that slide up from the bottom of the screen, often used for action sheets. Now, let's explore a different kind of pop-up, one that appears in the middle of the screen with a simple title and message, asking for user confirmation or providing important information. This is the classic alert box style, and in the Cupertino (iOS) world, it's handled by `CupertinoDialogRoute`.

### What is CupertinoDialogRoute?

Have you ever seen an app where suddenly a small box pops up in the very center of the screen, dimming everything behind it, and asking you to confirm if you want to delete something or informing you about something important? That's an alert dialog!

<br>

<p align="center">
  <img src="https://docs.flutter.dev/assets/images/flutter-for-web/modal-dialogs/cupertino-alert.gif" alt="Example of a Cupertino Alert Dialog" style="width: 300px;">
  <br>
  <em>Think of this kind of alert box appearing in the center.</em>
</p>

<br>

`CupertinoDialogRoute` is Flutter's `PageRoute` specifically designed for creating and managing these iOS-style alert boxes that appear in the center. It defines:

1.  **Where** the dialog appears (centered on the screen).
2.  **How** it animates in and out (a subtle fade coupled with a small scaling effect).
3.  **How** the background behind the dialog looks (it's automatically dimmed).
4.  **Its behavior** (by default, you can't tap outside to dismiss it, forcing the user to make a choice within the dialog).

It's different from other routes because:

*   It doesn't take over the full screen.
*   It appears in the center, not sliding from the side or bottom.
*   It's typically used for simple, focused interactions like confirming actions or displaying alerts.

**Motivation:** We want to show a standard iOS-style alert dialog box in the center of the screen to ask for a confirmation or display a simple message, using the native iOS animation and behavior.

### Using CupertinoDialogRoute

Similar to `CupertinoModalPopupRoute`, you commonly show a `CupertinoDialogRoute` using a helper function provided by Flutter, called `showCupertinoDialog`. This function simplifies the process of creating the route and pushing it onto the Navigator.

Let's create an example where tapping a button shows a standard iOS alert dialog asking "Are you sure?".

First, make sure to import the necessary Cupertino and Material packages:

```dart
import 'package:flutter/cupertino.dart';
import 'package:flutter/material.dart'; // Still using Material widgets for layout

// ... rest of MyApp, HomeScreen, NewScreen classes ...
```

Now, let's modify our `HomeScreen`'s button `onPressed` to show a dialog:

```dart
// ... inside HomeScreen onPressed ...
onPressed: () {
  showCupertinoDialog<void>( // Use the helper function!
    context: context,
    builder: (BuildContext context) {
      return CupertinoAlertDialog( // This widget provides the look of the dialog
        title: const Text('Confirmation'),
        content: const Text('Are you sure you want to do this?'),
        actions: <CupertinoDialogAction>[
          CupertinoDialogAction(
            child: const Text('Cancel'),
            onPressed: () {
              Navigator.pop(context); // Dismiss the dialog
            },
          ),
          CupertinoDialogAction(
            isDestructiveAction: true, // Gives it a red color on iOS
            child: const Text('Yes'),
            onPressed: () {
              // Perform the action, then dismiss
              print('User confirmed!'); // Replace with actual action
              Navigator.pop(context);
            },
          ),
        ],
      );
    },
  );
},
// ... rest of HomeScreen ...
```

Let's break down what's happening:

1.  **`showCupertinoDialog<void>(...)`**: This is the helper function from the Cupertino library specifically for showing alert dialogs. The `<void>` means the dialog doesn't return a specific result value when closed.
2.  **`context: context`**: We pass the current build context.
3.  **`builder: (BuildContext context) { ... }`**: This function's job is to build the *content* of the dialog.
4.  **`return CupertinoAlertDialog(...)`**: Inside the builder, we return the `CupertinoAlertDialog` widget. This is the widget that gives the dialog its visual structure (title, content area, action buttons). It's the widget that `CupertinoDialogRoute` will display.
5.  **`actions: <CupertinoDialogAction>[ ... ]`**: `CupertinoAlertDialog` takes a list of `CupertinoDialogAction` widgets for the buttons at the bottom.
6.  **`Navigator.pop(context)`**: Tapping one of the action buttons usually calls `Navigator.pop(context)` to close the dialog, which removes the `CupertinoDialogRoute` from the navigation stack.

When you tap the button now, a `CupertinoAlertDialog` will appear in the center of your screen, nicely styled and with a dimmed background, thanks to the `CupertinoDialogRoute` created by `showCupertinoDialog`.

Notice that we used `CupertinoAlertDialog` inside the builder. `CupertinoDialogRoute` itself doesn't provide the visual appearance (title, content, buttons); it provides the *route* and the *transition*. You put the actual visual structure inside the route using the `builder`.

`showCupertinoDialog` also has optional arguments like:

*   `barrierDismissible: false` (default): If `false`, tapping outside the dialog won't close it. You must tap one of the buttons. Set to `true` if you want it dismissable by tapping outside.
*   `barrierLabel`: An accessibility label for the non-interactive area behind the dialog.

### How it Works Under the Hood (Simplified)

When you call `showCupertinoDialog`, the main job of that helper function is to create a `CupertinoDialogRoute` instance and push it onto the Navigator.

Here's a simplified interaction diagram:

```mermaid
sequenceDiagram
    participant Button as Button Widget
    participant Screen as Your Screen Widget
    participant showCupertinoDialog as showCupertinoDialog Function
    participant Navigator as Navigator
    participant CD_Route as CupertinoDialogRoute
    participant AlertDialog as CupertinoAlertDialog

    Button->Screen: calls onPressed
    Screen->showCupertinoDialog: calls showCupertinoDialog(...)
    showCupertinoDialog->CD_Route: creates new CupertinoDialogRoute(...)
    showCupertinoDialog->Navigator: calls Navigator.push(context, CD_Route)
    Navigator->CD_Route: asks to build page content and transitions
    CD_Route->CD_Route: calls pageBuilder to create AlertDialog
    CD_Route->CD_Route: applies transition logic (fade/scale)
    Navigator->Navigator: Prepares and orchestrates
    Navigator->AlertDialog: Builds and animates AlertDialog into view
```

Let's look at the `CupertinoDialogRoute` definition in `packages/flutter/lib/src/cupertino/route.dart`:

```dart
// Simplified structure of CupertinoDialogRoute

class CupertinoDialogRoute<T> extends RawDialogRoute<T> {
  // ... constructor ...

  // Your builder function (passed to showCupertinoDialog) is used here
  // by the pageBuilder parameter in the super constructor (RawDialogRoute)
  // super( pageBuilder: (context, animation, secondaryAnimation) { return builder(context); }, ...)

  // Transition duration is set here, usually short for dialogs
  // super.transitionDuration = const Duration(milliseconds: 250);

  // Override buildTransitions to define the animation
  @override
  Widget buildTransitions(
    BuildContext context,
    Animation<double> animation, // Animation from 0.0 to 1.0
    Animation<double> secondaryAnimation,
    Widget child, // The widget built by pageBuilder (your AlertDialog)
  ) {
    // Check animation status to handle forward and reverse transitions
    if (animation.status == AnimationStatus.reverse) {
      // Fade out when dismissing
      return FadeTransition(opacity: animation, child: child);
    }
    // Fade in and scale up when showing
    return FadeTransition(
      opacity: animation,
      child: ScaleTransition(
        scale: animation.drive(_dialogScaleTween), // Scale animation using a Tween
        child: child, // Your AlertDialog widget
      ),
    );
  }

  // Defines the scaling animation (starts larger, scales down to normal size)
  static final Tween<double> _dialogScaleTween = Tween<double>(begin: 1.3, end: 1.0);

  // ... other properties like barrierColor, barrierDismissible, barrierLabel ...
}
```

Key points about `CupertinoDialogRoute`:

1.  It extends `RawDialogRoute`, a base class for routes that display dialogs or pop-ups.
2.  It takes your `builder` function (passed via the `pageBuilder` parameter in its constructor) to build the actual content of the dialog (e.g., the `CupertinoAlertDialog`).
3.  Crucially, it overrides the `buildTransitions` method. This method defines the animation.
4.  Inside `buildTransitions`, it uses a `FadeTransition` for opacity and a `ScaleTransition` for size, both driven by the incoming `animation`.
5.  A `_dialogScaleTween` is defined to make the scaling happen. It starts at a scale of `1.3` (slightly larger than normal) and animates to `1.0` (normal size). This, combined with the fade, creates the subtle pop-in effect characteristic of iOS alerts.
6.  For the reverse animation (when the dialog is dismissed), it just uses a `FadeTransition` to fade out.

So, `CupertinoDialogRoute` manages the centered positioning, the dimming barrier (inherited from `RawDialogRoute`), and specifically implements the subtle fade and scale transition within its `buildTransitions` method, applying these effects to the `child` widget (your `CupertinoAlertDialog`).

### Putting it All Together

You don't need to use `CupertinoDialogRoute` directly in most cases. The `showCupertinoDialog` helper function is the standard way to display these alerts, and it handles creating and managing the route for you.

Understanding `CupertinoDialogRoute` reveals how Flutter creates that specific iOS alert pop-up effect by combining a fade and scale animation applied to the dialog's content.

### Conclusion

`CupertinoDialogRoute` is the specialized `PageRoute` used in Flutter to implement the classic iOS-style alert dialogs that appear centered on the screen. While you commonly interact with it via the `showCupertinoDialog` helper function, the route itself provides the necessary transition logic (a subtle fade and scale animation) and manages the dimmed background. It's the final piece in our look at Cupertino-specific routes for different kinds of screen transitions and overlays!

This concludes our exploration of various `PageRoute` implementations within Flutter's Material and Cupertino libraries. You now have a strong foundation in how different screen transitions and overlays are handled!
