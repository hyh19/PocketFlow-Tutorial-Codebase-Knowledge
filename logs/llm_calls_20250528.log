2025-05-28 16:23:33,454 - INFO - PROMPT: Hello, how are you?
2025-05-28 16:23:35,450 - INFO - RESPONSE: I'm doing great, thank you! Ready to help in any way I can. How about you?
2025-05-28 16:25:38,408 - INFO - PROMPT: Hello, how are you?
2025-05-28 16:25:40,419 - INFO - RESPONSE: I'm doing well, thank you for asking! I'm here and ready to help in any way I can. How about you? How are you doing today?
2025-05-28 16:29:32,404 - INFO - PROMPT: 
For the project `flutter`:

Codebase Context:
--- File Index 0: color_scheme.0.dart ---
// Copyright 2014 The Flutter Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

import 'package:flutter/material.dart';

/// Flutter code sample for [ColorScheme].

const Widget divider = SizedBox(height: 10);

void main() => runApp(const ColorSchemeExample());

class ColorSchemeExample extends StatefulWidget {
  const ColorSchemeExample({super.key});

  @override
  State<ColorSchemeExample> createState() => _ColorSchemeExampleState();
}

class _ColorSchemeExampleState extends State<ColorSchemeExample> {
  Color selectedColor = ColorSeed.baseColor.color;
  Brightness selectedBrightness = Brightness.light;
  double selectedContrast = 0.0;
  static const List<DynamicSchemeVariant> schemeVariants = DynamicSchemeVariant.values;

  void updateTheme(Brightness brightness, Color color, double contrastLevel) {
    setState(() {
      selectedBrightness = brightness;
      selectedColor = color;
      selectedContrast = contrastLevel;
    });
  }

  @override
  Widget build(BuildContext context) {
    return MaterialApp(
      debugShowCheckedModeBanner: false,
      theme: ThemeData(
        colorScheme: ColorScheme.fromSeed(
          seedColor: selectedColor,
          brightness: selectedBrightness,
          contrastLevel: selectedContrast,
        ),
      ),
      home: Scaffold(
        appBar: AppBar(
          title: const Text('ColorScheme'),
          actions: <Widget>[
            SettingsButton(
              selectedColor: selectedColor,
              selectedBrightness: selectedBrightness,
              selectedContrast: selectedContrast,
              updateTheme: updateTheme,
            ),
          ],
        ),
        body: SingleChildScrollView(
          child: Padding(
            padding: const EdgeInsets.only(top: 5),
            child: Column(
              crossAxisAlignment: CrossAxisAlignment.start,
              children: <Widget>[
                SingleChildScrollView(
                  scrollDirection: Axis.horizontal,
                  child: Row(
                    children:
                        List<Widget>.generate(schemeVariants.length, (int index) {
                          return ColorSchemeVariantColumn(
                            selectedColor: selectedColor,
                            brightness: selectedBrightness,
                            schemeVariant: schemeVariants[index],
                            contrastLevel: selectedContrast,
                          );
                        }).toList(),
                  ),
                ),
              ],
            ),
          ),
        ),
      ),
    );
  }
}

class Settings extends StatefulWidget {
  const Settings({
    super.key,
    required this.updateTheme,
    required this.selectedBrightness,
    required this.selectedContrast,
    required this.selectedColor,
  });

  final Brightness selectedBrightness;
  final double selectedContrast;
  final Color selectedColor;

  final void Function(Brightness, Color, double) updateTheme;

  @override
  State<Settings> createState() => _SettingsState();
}

class _SettingsState extends State<Settings> {
  late Brightness selectedBrightness = widget.selectedBrightness;
  late Color selectedColor = widget.selectedColor;
  late double selectedContrast = widget.selectedContrast;

  @override
  Widget build(BuildContext context) {
    return Theme(
      data: Theme.of(context).copyWith(
        colorScheme: ColorScheme.fromSeed(
          seedColor: selectedColor,
          contrastLevel: selectedContrast,
          brightness: selectedBrightness,
        ),
      ),
      child: ConstrainedBox(
        constraints: const BoxConstraints(maxHeight: 200),
        child: Padding(
          padding: const EdgeInsets.all(20.0),
          child: ListView(
            children: <Widget>[
              Center(child: Text('Settings', style: Theme.of(context).textTheme.titleLarge)),
              Row(
                children: <Widget>[
                  const Text('Brightness: '),
                  Switch(
                    value: selectedBrightness == Brightness.light,
                    onChanged: (bool value) {
                      setState(() {
                        selectedBrightness = value ? Brightness.light : Brightness.dark;
                      });
                      widget.updateTheme(selectedBrightness, selectedColor, selectedContrast);
                    },
                  ),
                ],
              ),
              Wrap(
                crossAxisAlignment: WrapCrossAlignment.center,
                children: <Widget>[
                  const Text('Seed color: '),
                  ...List<Widget>.generate(ColorSeed.values.length, (int index) {
                    final Color itemColor = ColorSeed.values[index].color;
                    return IconButton(
                      icon:
                          selectedColor == ColorSeed.values[index].color
                              ? Icon(Icons.circle, color: itemColor)
                              : Icon(Icons.circle_outlined, color: itemColor),
                      onPressed: () {
                        setState(() {
                          selectedColor = itemColor;
                        });
                        widget.updateTheme(selectedBrightness, selectedColor, selectedContrast);
                      },
                    );
                  }),
                ],
              ),
              Row(
                children: <Widget>[
                  const Text('Contrast level: '),
                  Expanded(
                    child: Slider(
                      divisions: 4,
                      label: selectedContrast.toString(),
                      min: -1,
                      value: selectedContrast,
                      onChanged: (double value) {
                        setState(() {
                          selectedContrast = value;
                        });
                        widget.updateTheme(selectedBrightness, selectedColor, selectedContrast);
                      },
                    ),
                  ),
                ],
              ),
            ],
          ),
        ),
      ),
    );
  }
}

class ColorSchemeVariantColumn extends StatelessWidget {
  const ColorSchemeVariantColumn({
    super.key,
    this.schemeVariant = DynamicSchemeVariant.tonalSpot,
    this.brightness = Brightness.light,
    this.contrastLevel = 0.0,
    required this.selectedColor,
  });

  final DynamicSchemeVariant schemeVariant;
  final Brightness brightness;
  final double contrastLevel;
  final Color selectedColor;

  @override
  Widget build(BuildContext context) {
    return ConstrainedBox(
      constraints: const BoxConstraints.tightFor(width: 250),
      child: Column(
        children: <Widget>[
          Padding(
            padding: const EdgeInsets.symmetric(vertical: 15),
            child: Text(
              schemeVariant.name == 'tonalSpot'
                  ? '${schemeVariant.name} (Default)'
                  : schemeVariant.name,
              style: const TextStyle(fontWeight: FontWeight.bold),
            ),
          ),
          Padding(
            padding: const EdgeInsets.symmetric(horizontal: 15),
            child: ColorSchemeView(
              colorScheme: ColorScheme.fromSeed(
                seedColor: selectedColor,
                brightness: brightness,
                contrastLevel: contrastLevel,
                dynamicSchemeVariant: schemeVariant,
              ),
            ),
          ),
        ],
      ),
    );
  }
}

class ColorSchemeView extends StatelessWidget {
  const ColorSchemeView({super.key, required this.colorScheme});

  final ColorScheme colorScheme;

  @override
  Widget build(BuildContext context) {
    return Column(
      children: <Widget>[
        ColorGroup(
          children: <ColorChip>[
            ColorChip('primary', colorScheme.primary, colorScheme.onPrimary),
            ColorChip('onPrimary', colorScheme.onPrimary, colorScheme.primary),
            ColorChip(
              'primaryContainer',
              colorScheme.primaryContainer,
              colorScheme.onPrimaryContainer,
            ),
            ColorChip(
              'onPrimaryContainer',
              colorScheme.onPrimaryContainer,
              colorScheme.primaryContainer,
            ),
          ],
        ),
        divider,
        ColorGroup(
          children: <ColorChip>[
            ColorChip('primaryFixed', colorScheme.primaryFixed, colorScheme.onPrimaryFixed),
            ColorChip('onPrimaryFixed', colorScheme.onPrimaryFixed, colorScheme.primaryFixed),
            ColorChip(
              'primaryFixedDim',
              colorScheme.primaryFixedDim,
              colorScheme.onPrimaryFixedVariant,
            ),
            ColorChip(
              'onPrimaryFixedVariant',
              colorScheme.onPrimaryFixedVariant,
              colorScheme.primaryFixedDim,
            ),
          ],
        ),
        divider,
        ColorGroup(
          children: <ColorChip>[
            ColorChip('secondary', colorScheme.secondary, colorScheme.onSecondary),
            ColorChip('onSecondary', colorScheme.onSecondary, colorScheme.secondary),
            ColorChip(
              'secondaryContainer',
              colorScheme.secondaryContainer,
              colorScheme.onSecondaryContainer,
            ),
            ColorChip(
              'onSecondaryContainer',
              colorScheme.onSecondaryContainer,
              colorScheme.secondaryContainer,
            ),
          ],
        ),
        divider,
        ColorGroup(
          children: <ColorChip>[
            ColorChip('secondaryFixed', colorScheme.secondaryFixed, colorScheme.onSecondaryFixed),
            ColorChip('onSecondaryFixed', colorScheme.onSecondaryFixed, colorScheme.secondaryFixed),
            ColorChip(
              'secondaryFixedDim',
              colorScheme.secondaryFixedDim,
              colorScheme.onSecondaryFixedVariant,
            ),
            ColorChip(
              'onSecondaryFixedVariant',
              colorScheme.onSecondaryFixedVariant,
              colorScheme.secondaryFixedDim,
            ),
          ],
        ),
        divider,
        ColorGroup(
          children: <ColorChip>[
            ColorChip('tertiary', colorScheme.tertiary, colorScheme.onTertiary),
            ColorChip('onTertiary', colorScheme.onTertiary, colorScheme.tertiary),
            ColorChip(
              'tertiaryContainer',
              colorScheme.tertiaryContainer,
              colorScheme.onTertiaryContainer,
            ),
            ColorChip(
              'onTertiaryContainer',
              colorScheme.onTertiaryContainer,
              colorScheme.tertiaryContainer,
            ),
          ],
        ),
        divider,
        ColorGroup(
          children: <ColorChip>[
            ColorChip('tertiaryFixed', colorScheme.tertiaryFixed, colorScheme.onTertiaryFixed),
            ColorChip('onTertiaryFixed', colorScheme.onTertiaryFixed, colorScheme.tertiaryFixed),
            ColorChip(
              'tertiaryFixedDim',
              colorScheme.tertiaryFixedDim,
              colorScheme.onTertiaryFixedVariant,
            ),
            ColorChip(
              'onTertiaryFixedVariant',
              colorScheme.onTertiaryFixedVariant,
              colorScheme.tertiaryFixedDim,
            ),
          ],
        ),
        divider,
        ColorGroup(
          children: <ColorChip>[
            ColorChip('error', colorScheme.error, colorScheme.onError),
            ColorChip('onError', colorScheme.onError, colorScheme.error),
            ColorChip('errorContainer', colorScheme.errorContainer, colorScheme.onErrorContainer),
            ColorChip('onErrorContainer', colorScheme.onErrorContainer, colorScheme.errorContainer),
          ],
        ),
        divider,
        ColorGroup(
          children: <ColorChip>[
            ColorChip('surfaceDim', colorScheme.surfaceDim, colorScheme.onSurface),
            ColorChip('surface', colorScheme.surface, colorScheme.onSurface),
            ColorChip('surfaceBright', colorScheme.surfaceBright, colorScheme.onSurface),
            ColorChip(
              'surfaceContainerLowest',
              colorScheme.surfaceContainerLowest,
              colorScheme.onSurface,
            ),
            ColorChip(
              'surfaceContainerLow',
              colorScheme.surfaceContainerLow,
              colorScheme.onSurface,
            ),
            ColorChip('surfaceContainer', colorScheme.surfaceContainer, colorScheme.onSurface),
            ColorChip(
              'surfaceContainerHigh',
              colorScheme.surfaceContainerHigh,
              colorScheme.onSurface,
            ),
            ColorChip(
              'surfaceContainerHighest',
              colorScheme.surfaceContainerHighest,
              colorScheme.onSurface,
            ),
            ColorChip('onSurface', colorScheme.onSurface, colorScheme.surface),
            ColorChip(
              'onSurfaceVariant',
              colorScheme.onSurfaceVariant,
              colorScheme.surfaceContainerHighest,
            ),
          ],
        ),
        divider,
        ColorGroup(
          children: <ColorChip>[
            ColorChip('outline', colorScheme.outline, null),
            ColorChip('shadow', colorScheme.shadow, null),
            ColorChip('inverseSurface', colorScheme.inverseSurface, colorScheme.onInverseSurface),
            ColorChip('onInverseSurface', colorScheme.onInverseSurface, colorScheme.inverseSurface),
            ColorChip('inversePrimary', colorScheme.inversePrimary, colorScheme.primary),
          ],
        ),
      ],
    );
  }
}

class ColorGroup extends StatelessWidget {
  const ColorGroup({super.key, required this.children});

  final List<Widget> children;

  @override
  Widget build(BuildContext context) {
    return RepaintBoundary(
      child: Card(clipBehavior: Clip.antiAlias, child: Column(children: children)),
    );
  }
}

class ColorChip extends StatelessWidget {
  const ColorChip(this.label, this.color, this.onColor, {super.key});

  final Color color;
  final Color? onColor;
  final String label;

  static Color contrastColor(Color color) {
    final Brightness brightness = ThemeData.estimateBrightnessForColor(color);
    return brightness == Brightness.dark ? Colors.white : Colors.black;
  }

  @override
  Widget build(BuildContext context) {
    final Color labelColor = onColor ?? contrastColor(color);
    return ColoredBox(
      color: color,
      child: Padding(
        padding: const EdgeInsets.all(16),
        child: Row(
          children: <Expanded>[Expanded(child: Text(label, style: TextStyle(color: labelColor)))],
        ),
      ),
    );
  }
}

enum ColorSeed {
  baseColor('M3 Baseline', Color(0xff6750a4)),
  indigo('Indigo', Colors.indigo),
  blue('Blue', Colors.blue),
  teal('Teal', Colors.teal),
  green('Green', Colors.green),
  yellow('Yellow', Colors.yellow),
  orange('Orange', Colors.orange),
  deepOrange('Deep Orange', Colors.deepOrange),
  pink('Pink', Colors.pink),
  brightBlue('Bright Blue', Color(0xFF0000FF)),
  brightGreen('Bright Green', Color(0xFF00FF00)),
  brightRed('Bright Red', Color(0xFFFF0000));

  const ColorSeed(this.label, this.color);
  final String label;
  final Color color;
}

class SettingsButton extends StatelessWidget {
  const SettingsButton({
    super.key,
    required this.updateTheme,
    required this.selectedBrightness,
    required this.selectedContrast,
    required this.selectedColor,
  });

  final Brightness selectedBrightness;
  final double selectedContrast;
  final Color selectedColor;

  final void Function(Brightness, Color, double) updateTheme;

  @override
  Widget build(BuildContext context) {
    return IconButton(
      icon: const Icon(Icons.settings),
      onPressed: () {
        showModalBottomSheet<void>(
          barrierColor: Colors.transparent,
          context: context,
          builder: (BuildContext context) {
            return Settings(
              selectedColor: selectedColor,
              selectedBrightness: selectedBrightness,
              selectedContrast: selectedContrast,
              updateTheme: updateTheme,
            );
          },
        );
      },
    );
  }
}




Analyze the codebase context.
Identify the top 5-10 core most important abstractions to help those new to the codebase.

For each abstraction, provide:
1. A concise `name`.
2. A beginner-friendly `description` explaining what it is with a simple analogy, in around 100 words.
3. A list of relevant `file_indices` (integers) using the format `idx # path/comment`.

List of file indices and paths present in the context:
- 0 # color_scheme.0.dart

Format the output as a YAML list of dictionaries:

```yaml
- name: |
    Query Processing
  description: |
    Explains what the abstraction does.
    It's like a central dispatcher routing requests.
  file_indices:
    - 0 # path/to/file1.py
    - 3 # path/to/related.py
- name: |
    Query Optimization
  description: |
    Another core concept, similar to a blueprint for objects.
  file_indices:
    - 5 # path/to/another.js
# ... up to 10 abstractions
```
2025-05-28 16:29:40,068 - INFO - RESPONSE: ```yaml
- name: |
    ColorSchemeExample
  description: |
    This is the main application widget that demonstrates how to use and customize a ColorScheme.
    Think of it as the conductor of an orchestra, managing the different parts (brightness, color, contrast) to create the overall theme of the app. It holds the current theme settings and rebuilds the app when they change.
  file_indices:
    - 0 # color_scheme.0.dart
- name: |
    Settings
  description: |
    This widget provides the user interface for changing the theme settings like brightness, seed color, and contrast level.
    Imagine it as a control panel with knobs and switches that allow you to adjust the look and feel of the application's colors. It communicates your desired settings back to the main app. (ColorSchemeExample).
  file_indices:
    - 0 # color_scheme.0.dart
- name: |
    SettingsButton
  description: |
    This is the button located in the app bar that, when pressed, opens the `Settings` panel.
    It's like a door handle that grants you access to the control panel where you can customize the theme.
  file_indices:
    - 0 # color_scheme.0.dart
- name: |
    ColorSchemeVariantColumn
  description: |
    This widget displays a specific variant of a `ColorScheme` based on the selected settings.
    Consider it a display case for different color palettes. Each column shows you how the app would look with a particular color scheme variation applied, using the currently selected seed color, brightness, and contrast.
  file_indices:
    - 0 # color_scheme.0.dart
- name: |
    ColorSchemeView
  description: |
    This widget is responsible for presenting all the individual colors within a given `ColorScheme`.
    It's like a color chart that lays out all the different swatches (primary, secondary, surface, etc.) that make up a complete color scheme, showing you the whole palette at a glance.
  file_indices:
    - 0 # color_scheme.0.dart
- name: |
    ColorChip
  description: |
    A small, visual representation of a single color within a `ColorScheme`, along with its name and a contrasting color for text.
    Think of it as a paint chip sample from a hardware store, showing you a specific color with its label so you know what it represents in the overall scheme.
  file_indices:
    - 0 # color_scheme.0.dart
- name: |
    ColorSeed
  description: |
    An enumeration that defines a set of predefined colors that can be used as the starting point (seed) for generating a `ColorScheme`.
    These are like popular starter colors you can pick from a catalog to base your entire color scheme on.
  file_indices:
    - 0 # color_scheme.0.dart
- name: |
    ColorGroup
  description: |
    A simple container to group together multiple `ColorChip` widgets for better organization and visual presentation.
    It's like a frame or a box used to neatly display a set of related paint chip samples together.
  file_indices:
    - 0 # color_scheme.0.dart
```
2025-05-28 16:29:40,078 - INFO - PROMPT: 
Based on the following abstractions and relevant code snippets from the project `flutter`:

List of Abstraction Indices and Names:
0 # ColorSchemeExample

1 # Settings

2 # SettingsButton

3 # ColorSchemeVariantColumn

4 # ColorSchemeView

5 # ColorChip

6 # ColorSeed

7 # ColorGroup


Context (Abstractions, Descriptions, Code):
Identified Abstractions:\n- Index 0: ColorSchemeExample
 (Relevant file indices: [0])\n  Description: This is the main application widget that demonstrates how to use and customize a ColorScheme.
Think of it as the conductor of an orchestra, managing the different parts (brightness, color, contrast) to create the overall theme of the app. It holds the current theme settings and rebuilds the app when they change.
\n- Index 1: Settings
 (Relevant file indices: [0])\n  Description: This widget provides the user interface for changing the theme settings like brightness, seed color, and contrast level.
Imagine it as a control panel with knobs and switches that allow you to adjust the look and feel of the application's colors. It communicates your desired settings back to the main app. (ColorSchemeExample).
\n- Index 2: SettingsButton
 (Relevant file indices: [0])\n  Description: This is the button located in the app bar that, when pressed, opens the `Settings` panel.
It's like a door handle that grants you access to the control panel where you can customize the theme.
\n- Index 3: ColorSchemeVariantColumn
 (Relevant file indices: [0])\n  Description: This widget displays a specific variant of a `ColorScheme` based on the selected settings.
Consider it a display case for different color palettes. Each column shows you how the app would look with a particular color scheme variation applied, using the currently selected seed color, brightness, and contrast.
\n- Index 4: ColorSchemeView
 (Relevant file indices: [0])\n  Description: This widget is responsible for presenting all the individual colors within a given `ColorScheme`.
It's like a color chart that lays out all the different swatches (primary, secondary, surface, etc.) that make up a complete color scheme, showing you the whole palette at a glance.
\n- Index 5: ColorChip
 (Relevant file indices: [0])\n  Description: A small, visual representation of a single color within a `ColorScheme`, along with its name and a contrasting color for text.
Think of it as a paint chip sample from a hardware store, showing you a specific color with its label so you know what it represents in the overall scheme.
\n- Index 6: ColorSeed
 (Relevant file indices: [0])\n  Description: An enumeration that defines a set of predefined colors that can be used as the starting point (seed) for generating a `ColorScheme`.
These are like popular starter colors you can pick from a catalog to base your entire color scheme on.
\n- Index 7: ColorGroup
 (Relevant file indices: [0])\n  Description: A simple container to group together multiple `ColorChip` widgets for better organization and visual presentation.
It's like a frame or a box used to neatly display a set of related paint chip samples together.
\n\nRelevant File Snippets (Referenced by Index and Path):\n--- File: 0 # color_scheme.0.dart ---\n// Copyright 2014 The Flutter Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

import 'package:flutter/material.dart';

/// Flutter code sample for [ColorScheme].

const Widget divider = SizedBox(height: 10);

void main() => runApp(const ColorSchemeExample());

class ColorSchemeExample extends StatefulWidget {
  const ColorSchemeExample({super.key});

  @override
  State<ColorSchemeExample> createState() => _ColorSchemeExampleState();
}

class _ColorSchemeExampleState extends State<ColorSchemeExample> {
  Color selectedColor = ColorSeed.baseColor.color;
  Brightness selectedBrightness = Brightness.light;
  double selectedContrast = 0.0;
  static const List<DynamicSchemeVariant> schemeVariants = DynamicSchemeVariant.values;

  void updateTheme(Brightness brightness, Color color, double contrastLevel) {
    setState(() {
      selectedBrightness = brightness;
      selectedColor = color;
      selectedContrast = contrastLevel;
    });
  }

  @override
  Widget build(BuildContext context) {
    return MaterialApp(
      debugShowCheckedModeBanner: false,
      theme: ThemeData(
        colorScheme: ColorScheme.fromSeed(
          seedColor: selectedColor,
          brightness: selectedBrightness,
          contrastLevel: selectedContrast,
        ),
      ),
      home: Scaffold(
        appBar: AppBar(
          title: const Text('ColorScheme'),
          actions: <Widget>[
            SettingsButton(
              selectedColor: selectedColor,
              selectedBrightness: selectedBrightness,
              selectedContrast: selectedContrast,
              updateTheme: updateTheme,
            ),
          ],
        ),
        body: SingleChildScrollView(
          child: Padding(
            padding: const EdgeInsets.only(top: 5),
            child: Column(
              crossAxisAlignment: CrossAxisAlignment.start,
              children: <Widget>[
                SingleChildScrollView(
                  scrollDirection: Axis.horizontal,
                  child: Row(
                    children:
                        List<Widget>.generate(schemeVariants.length, (int index) {
                          return ColorSchemeVariantColumn(
                            selectedColor: selectedColor,
                            brightness: selectedBrightness,
                            schemeVariant: schemeVariants[index],
                            contrastLevel: selectedContrast,
                          );
                        }).toList(),
                  ),
                ),
              ],
            ),
          ),
        ),
      ),
    );
  }
}

class Settings extends StatefulWidget {
  const Settings({
    super.key,
    required this.updateTheme,
    required this.selectedBrightness,
    required this.selectedContrast,
    required this.selectedColor,
  });

  final Brightness selectedBrightness;
  final double selectedContrast;
  final Color selectedColor;

  final void Function(Brightness, Color, double) updateTheme;

  @override
  State<Settings> createState() => _SettingsState();
}

class _SettingsState extends State<Settings> {
  late Brightness selectedBrightness = widget.selectedBrightness;
  late Color selectedColor = widget.selectedColor;
  late double selectedContrast = widget.selectedContrast;

  @override
  Widget build(BuildContext context) {
    return Theme(
      data: Theme.of(context).copyWith(
        colorScheme: ColorScheme.fromSeed(
          seedColor: selectedColor,
          contrastLevel: selectedContrast,
          brightness: selectedBrightness,
        ),
      ),
      child: ConstrainedBox(
        constraints: const BoxConstraints(maxHeight: 200),
        child: Padding(
          padding: const EdgeInsets.all(20.0),
          child: ListView(
            children: <Widget>[
              Center(child: Text('Settings', style: Theme.of(context).textTheme.titleLarge)),
              Row(
                children: <Widget>[
                  const Text('Brightness: '),
                  Switch(
                    value: selectedBrightness == Brightness.light,
                    onChanged: (bool value) {
                      setState(() {
                        selectedBrightness = value ? Brightness.light : Brightness.dark;
                      });
                      widget.updateTheme(selectedBrightness, selectedColor, selectedContrast);
                    },
                  ),
                ],
              ),
              Wrap(
                crossAxisAlignment: WrapCrossAlignment.center,
                children: <Widget>[
                  const Text('Seed color: '),
                  ...List<Widget>.generate(ColorSeed.values.length, (int index) {
                    final Color itemColor = ColorSeed.values[index].color;
                    return IconButton(
                      icon:
                          selectedColor == ColorSeed.values[index].color
                              ? Icon(Icons.circle, color: itemColor)
                              : Icon(Icons.circle_outlined, color: itemColor),
                      onPressed: () {
                        setState(() {
                          selectedColor = itemColor;
                        });
                        widget.updateTheme(selectedBrightness, selectedColor, selectedContrast);
                      },
                    );
                  }),
                ],
              ),
              Row(
                children: <Widget>[
                  const Text('Contrast level: '),
                  Expanded(
                    child: Slider(
                      divisions: 4,
                      label: selectedContrast.toString(),
                      min: -1,
                      value: selectedContrast,
                      onChanged: (double value) {
                        setState(() {
                          selectedContrast = value;
                        });
                        widget.updateTheme(selectedBrightness, selectedColor, selectedContrast);
                      },
                    ),
                  ),
                ],
              ),
            ],
          ),
        ),
      ),
    );
  }
}

class ColorSchemeVariantColumn extends StatelessWidget {
  const ColorSchemeVariantColumn({
    super.key,
    this.schemeVariant = DynamicSchemeVariant.tonalSpot,
    this.brightness = Brightness.light,
    this.contrastLevel = 0.0,
    required this.selectedColor,
  });

  final DynamicSchemeVariant schemeVariant;
  final Brightness brightness;
  final double contrastLevel;
  final Color selectedColor;

  @override
  Widget build(BuildContext context) {
    return ConstrainedBox(
      constraints: const BoxConstraints.tightFor(width: 250),
      child: Column(
        children: <Widget>[
          Padding(
            padding: const EdgeInsets.symmetric(vertical: 15),
            child: Text(
              schemeVariant.name == 'tonalSpot'
                  ? '${schemeVariant.name} (Default)'
                  : schemeVariant.name,
              style: const TextStyle(fontWeight: FontWeight.bold),
            ),
          ),
          Padding(
            padding: const EdgeInsets.symmetric(horizontal: 15),
            child: ColorSchemeView(
              colorScheme: ColorScheme.fromSeed(
                seedColor: selectedColor,
                brightness: brightness,
                contrastLevel: contrastLevel,
                dynamicSchemeVariant: schemeVariant,
              ),
            ),
          ),
        ],
      ),
    );
  }
}

class ColorSchemeView extends StatelessWidget {
  const ColorSchemeView({super.key, required this.colorScheme});

  final ColorScheme colorScheme;

  @override
  Widget build(BuildContext context) {
    return Column(
      children: <Widget>[
        ColorGroup(
          children: <ColorChip>[
            ColorChip('primary', colorScheme.primary, colorScheme.onPrimary),
            ColorChip('onPrimary', colorScheme.onPrimary, colorScheme.primary),
            ColorChip(
              'primaryContainer',
              colorScheme.primaryContainer,
              colorScheme.onPrimaryContainer,
            ),
            ColorChip(
              'onPrimaryContainer',
              colorScheme.onPrimaryContainer,
              colorScheme.primaryContainer,
            ),
          ],
        ),
        divider,
        ColorGroup(
          children: <ColorChip>[
            ColorChip('primaryFixed', colorScheme.primaryFixed, colorScheme.onPrimaryFixed),
            ColorChip('onPrimaryFixed', colorScheme.onPrimaryFixed, colorScheme.primaryFixed),
            ColorChip(
              'primaryFixedDim',
              colorScheme.primaryFixedDim,
              colorScheme.onPrimaryFixedVariant,
            ),
            ColorChip(
              'onPrimaryFixedVariant',
              colorScheme.onPrimaryFixedVariant,
              colorScheme.primaryFixedDim,
            ),
          ],
        ),
        divider,
        ColorGroup(
          children: <ColorChip>[
            ColorChip('secondary', colorScheme.secondary, colorScheme.onSecondary),
            ColorChip('onSecondary', colorScheme.onSecondary, colorScheme.secondary),
            ColorChip(
              'secondaryContainer',
              colorScheme.secondaryContainer,
              colorScheme.onSecondaryContainer,
            ),
            ColorChip(
              'onSecondaryContainer',
              colorScheme.onSecondaryContainer,
              colorScheme.secondaryContainer,
            ),
          ],
        ),
        divider,
        ColorGroup(
          children: <ColorChip>[
            ColorChip('secondaryFixed', colorScheme.secondaryFixed, colorScheme.onSecondaryFixed),
            ColorChip('onSecondaryFixed', colorScheme.onSecondaryFixed, colorScheme.secondaryFixed),
            ColorChip(
              'secondaryFixedDim',
              colorScheme.secondaryFixedDim,
              colorScheme.onSecondaryFixedVariant,
            ),
            ColorChip(
              'onSecondaryFixedVariant',
              colorScheme.onSecondaryFixedVariant,
              colorScheme.secondaryFixedDim,
            ),
          ],
        ),
        divider,
        ColorGroup(
          children: <ColorChip>[
            ColorChip('tertiary', colorScheme.tertiary, colorScheme.onTertiary),
            ColorChip('onTertiary', colorScheme.onTertiary, colorScheme.tertiary),
            ColorChip(
              'tertiaryContainer',
              colorScheme.tertiaryContainer,
              colorScheme.onTertiaryContainer,
            ),
            ColorChip(
              'onTertiaryContainer',
              colorScheme.onTertiaryContainer,
              colorScheme.tertiaryContainer,
            ),
          ],
        ),
        divider,
        ColorGroup(
          children: <ColorChip>[
            ColorChip('tertiaryFixed', colorScheme.tertiaryFixed, colorScheme.onTertiaryFixed),
            ColorChip('onTertiaryFixed', colorScheme.onTertiaryFixed, colorScheme.tertiaryFixed),
            ColorChip(
              'tertiaryFixedDim',
              colorScheme.tertiaryFixedDim,
              colorScheme.onTertiaryFixedVariant,
            ),
            ColorChip(
              'onTertiaryFixedVariant',
              colorScheme.onTertiaryFixedVariant,
              colorScheme.tertiaryFixedDim,
            ),
          ],
        ),
        divider,
        ColorGroup(
          children: <ColorChip>[
            ColorChip('error', colorScheme.error, colorScheme.onError),
            ColorChip('onError', colorScheme.onError, colorScheme.error),
            ColorChip('errorContainer', colorScheme.errorContainer, colorScheme.onErrorContainer),
            ColorChip('onErrorContainer', colorScheme.onErrorContainer, colorScheme.errorContainer),
          ],
        ),
        divider,
        ColorGroup(
          children: <ColorChip>[
            ColorChip('surfaceDim', colorScheme.surfaceDim, colorScheme.onSurface),
            ColorChip('surface', colorScheme.surface, colorScheme.onSurface),
            ColorChip('surfaceBright', colorScheme.surfaceBright, colorScheme.onSurface),
            ColorChip(
              'surfaceContainerLowest',
              colorScheme.surfaceContainerLowest,
              colorScheme.onSurface,
            ),
            ColorChip(
              'surfaceContainerLow',
              colorScheme.surfaceContainerLow,
              colorScheme.onSurface,
            ),
            ColorChip('surfaceContainer', colorScheme.surfaceContainer, colorScheme.onSurface),
            ColorChip(
              'surfaceContainerHigh',
              colorScheme.surfaceContainerHigh,
              colorScheme.onSurface,
            ),
            ColorChip(
              'surfaceContainerHighest',
              colorScheme.surfaceContainerHighest,
              colorScheme.onSurface,
            ),
            ColorChip('onSurface', colorScheme.onSurface, colorScheme.surface),
            ColorChip(
              'onSurfaceVariant',
              colorScheme.onSurfaceVariant,
              colorScheme.surfaceContainerHighest,
            ),
          ],
        ),
        divider,
        ColorGroup(
          children: <ColorChip>[
            ColorChip('outline', colorScheme.outline, null),
            ColorChip('shadow', colorScheme.shadow, null),
            ColorChip('inverseSurface', colorScheme.inverseSurface, colorScheme.onInverseSurface),
            ColorChip('onInverseSurface', colorScheme.onInverseSurface, colorScheme.inverseSurface),
            ColorChip('inversePrimary', colorScheme.inversePrimary, colorScheme.primary),
          ],
        ),
      ],
    );
  }
}

class ColorGroup extends StatelessWidget {
  const ColorGroup({super.key, required this.children});

  final List<Widget> children;

  @override
  Widget build(BuildContext context) {
    return RepaintBoundary(
      child: Card(clipBehavior: Clip.antiAlias, child: Column(children: children)),
    );
  }
}

class ColorChip extends StatelessWidget {
  const ColorChip(this.label, this.color, this.onColor, {super.key});

  final Color color;
  final Color? onColor;
  final String label;

  static Color contrastColor(Color color) {
    final Brightness brightness = ThemeData.estimateBrightnessForColor(color);
    return brightness == Brightness.dark ? Colors.white : Colors.black;
  }

  @override
  Widget build(BuildContext context) {
    final Color labelColor = onColor ?? contrastColor(color);
    return ColoredBox(
      color: color,
      child: Padding(
        padding: const EdgeInsets.all(16),
        child: Row(
          children: <Expanded>[Expanded(child: Text(label, style: TextStyle(color: labelColor)))],
        ),
      ),
    );
  }
}

enum ColorSeed {
  baseColor('M3 Baseline', Color(0xff6750a4)),
  indigo('Indigo', Colors.indigo),
  blue('Blue', Colors.blue),
  teal('Teal', Colors.teal),
  green('Green', Colors.green),
  yellow('Yellow', Colors.yellow),
  orange('Orange', Colors.orange),
  deepOrange('Deep Orange', Colors.deepOrange),
  pink('Pink', Colors.pink),
  brightBlue('Bright Blue', Color(0xFF0000FF)),
  brightGreen('Bright Green', Color(0xFF00FF00)),
  brightRed('Bright Red', Color(0xFFFF0000));

  const ColorSeed(this.label, this.color);
  final String label;
  final Color color;
}

class SettingsButton extends StatelessWidget {
  const SettingsButton({
    super.key,
    required this.updateTheme,
    required this.selectedBrightness,
    required this.selectedContrast,
    required this.selectedColor,
  });

  final Brightness selectedBrightness;
  final double selectedContrast;
  final Color selectedColor;

  final void Function(Brightness, Color, double) updateTheme;

  @override
  Widget build(BuildContext context) {
    return IconButton(
      icon: const Icon(Icons.settings),
      onPressed: () {
        showModalBottomSheet<void>(
          barrierColor: Colors.transparent,
          context: context,
          builder: (BuildContext context) {
            return Settings(
              selectedColor: selectedColor,
              selectedBrightness: selectedBrightness,
              selectedContrast: selectedContrast,
              updateTheme: updateTheme,
            );
          },
        );
      },
    );
  }
}


Please provide:
1. A high-level `summary` of the project's main purpose and functionality in a few beginner-friendly sentences. Use markdown formatting with **bold** and *italic* text to highlight important concepts.
2. A list (`relationships`) describing the key interactions between these abstractions. For each relationship, specify:
    - `from_abstraction`: Index of the source abstraction (e.g., `0 # AbstractionName1`)
    - `to_abstraction`: Index of the target abstraction (e.g., `1 # AbstractionName2`)
    - `label`: A brief label for the interaction **in just a few words** (e.g., "Manages", "Inherits", "Uses").
    Ideally the relationship should be backed by one abstraction calling or passing parameters to another.
    Simplify the relationship and exclude those non-important ones.

IMPORTANT: Make sure EVERY abstraction is involved in at least ONE relationship (either as source or target). Each abstraction index must appear at least once across all relationships.

Format the output as YAML:

```yaml
summary: |
  A brief, simple explanation of the project.
  Can span multiple lines with **bold** and *italic* for emphasis.
relationships:
  - from_abstraction: 0 # AbstractionName1
    to_abstraction: 1 # AbstractionName2
    label: "Manages"
  - from_abstraction: 2 # AbstractionName3
    to_abstraction: 0 # AbstractionName1
    label: "Provides config"
  # ... other relationships
```

Now, provide the YAML output:

2025-05-28 16:29:43,839 - INFO - RESPONSE: ```yaml
summary: |
  This project is a visual demo of how to customize a Flutter app's **color scheme**
  using different *seed colors*, *brightness* levels, and *contrast*. You can use the
  settings to see how these changes affect the overall look and feel of the application.
relationships:
  - from_abstraction: 0 # ColorSchemeExample
    to_abstraction: 2 # SettingsButton
    label: "Contains"
  - from_abstraction: 0 # ColorSchemeExample
    to_abstraction: 3 # ColorSchemeVariantColumn
    label: "Displays various"
  - from_abstraction: 2 # SettingsButton
    to_abstraction: 1 # Settings
    label: "Opens"
  - from_abstraction: 1 # Settings
    to_abstraction: 0 # ColorSchemeExample
    label: "Updates theme in"
  - from_abstraction: 1 # Settings
    to_abstraction: 6 # ColorSeed
    label: "Allows selecting"
  - from_abstraction: 3 # ColorSchemeVariantColumn
    to_abstraction: 4 # ColorSchemeView
    label: "Shows details of"
  - from_abstraction: 4 # ColorSchemeView
    to_abstraction: 7 # ColorGroup
    label: "Organizes"
  - from_abstraction: 7 # ColorGroup
    to_abstraction: 5 # ColorChip
    label: "Contains"
```
2025-05-28 16:29:43,848 - INFO - PROMPT: 
Given the following project abstractions and their relationships for the project ```` flutter ````:

Abstractions (Index # Name):
- 0 # ColorSchemeExample

- 1 # Settings

- 2 # SettingsButton

- 3 # ColorSchemeVariantColumn

- 4 # ColorSchemeView

- 5 # ColorChip

- 6 # ColorSeed

- 7 # ColorGroup


Context about relationships and project summary:
Project Summary:
This project is a visual demo of how to customize a Flutter app's **color scheme**
using different *seed colors*, *brightness* levels, and *contrast*. You can use the
settings to see how these changes affect the overall look and feel of the application.


Relationships (Indices refer to abstractions above):
- From 0 (ColorSchemeExample
) to 2 (SettingsButton
): Contains
- From 0 (ColorSchemeExample
) to 3 (ColorSchemeVariantColumn
): Displays various
- From 2 (SettingsButton
) to 1 (Settings
): Opens
- From 1 (Settings
) to 0 (ColorSchemeExample
): Updates theme in
- From 1 (Settings
) to 6 (ColorSeed
): Allows selecting
- From 3 (ColorSchemeVariantColumn
) to 4 (ColorSchemeView
): Shows details of
- From 4 (ColorSchemeView
) to 7 (ColorGroup
): Organizes
- From 7 (ColorGroup
) to 5 (ColorChip
): Contains


If you are going to make a tutorial for ```` flutter ````, what is the best order to explain these abstractions, from first to last?
Ideally, first explain those that are the most important or foundational, perhaps user-facing concepts or entry points. Then move to more detailed, lower-level implementation details or supporting concepts.

Output the ordered list of abstraction indices, including the name in a comment for clarity. Use the format `idx # AbstractionName`.

```yaml
- 2 # FoundationalConcept
- 0 # CoreClassA
- 1 # CoreClassB (uses CoreClassA)
- ...
```

Now, provide the YAML output:

2025-05-28 16:29:45,898 - INFO - RESPONSE: ```yaml
- 0 # ColorSchemeExample
- 2 # SettingsButton
- 1 # Settings
- 3 # ColorSchemeVariantColumn
- 4 # ColorSchemeView
- 7 # ColorGroup
- 5 # ColorChip
- 6 # ColorSeed
```
2025-05-28 16:29:45,903 - INFO - PROMPT: 
Write a very beginner-friendly tutorial chapter (in Markdown format) for the project `flutter` about the concept: "ColorSchemeExample
". This is Chapter 1.

Concept Details:
- Name: ColorSchemeExample

- Description:
This is the main application widget that demonstrates how to use and customize a ColorScheme.
Think of it as the conductor of an orchestra, managing the different parts (brightness, color, contrast) to create the overall theme of the app. It holds the current theme settings and rebuilds the app when they change.


Complete Tutorial Structure:
1. [ColorSchemeExample
](01_colorschemeexample_.md)
2. [SettingsButton
](02_settingsbutton_.md)
3. [Settings
](03_settings_.md)
4. [ColorSchemeVariantColumn
](04_colorschemevariantcolumn_.md)
5. [ColorSchemeView
](05_colorschemeview_.md)
6. [ColorGroup
](06_colorgroup_.md)
7. [ColorChip
](07_colorchip_.md)
8. [ColorSeed
](08_colorseed_.md)

Context from previous chapters:
This is the first chapter.

Relevant Code Snippets (Code itself remains unchanged):
--- File: color_scheme.0.dart ---
// Copyright 2014 The Flutter Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

import 'package:flutter/material.dart';

/// Flutter code sample for [ColorScheme].

const Widget divider = SizedBox(height: 10);

void main() => runApp(const ColorSchemeExample());

class ColorSchemeExample extends StatefulWidget {
  const ColorSchemeExample({super.key});

  @override
  State<ColorSchemeExample> createState() => _ColorSchemeExampleState();
}

class _ColorSchemeExampleState extends State<ColorSchemeExample> {
  Color selectedColor = ColorSeed.baseColor.color;
  Brightness selectedBrightness = Brightness.light;
  double selectedContrast = 0.0;
  static const List<DynamicSchemeVariant> schemeVariants = DynamicSchemeVariant.values;

  void updateTheme(Brightness brightness, Color color, double contrastLevel) {
    setState(() {
      selectedBrightness = brightness;
      selectedColor = color;
      selectedContrast = contrastLevel;
    });
  }

  @override
  Widget build(BuildContext context) {
    return MaterialApp(
      debugShowCheckedModeBanner: false,
      theme: ThemeData(
        colorScheme: ColorScheme.fromSeed(
          seedColor: selectedColor,
          brightness: selectedBrightness,
          contrastLevel: selectedContrast,
        ),
      ),
      home: Scaffold(
        appBar: AppBar(
          title: const Text('ColorScheme'),
          actions: <Widget>[
            SettingsButton(
              selectedColor: selectedColor,
              selectedBrightness: selectedBrightness,
              selectedContrast: selectedContrast,
              updateTheme: updateTheme,
            ),
          ],
        ),
        body: SingleChildScrollView(
          child: Padding(
            padding: const EdgeInsets.only(top: 5),
            child: Column(
              crossAxisAlignment: CrossAxisAlignment.start,
              children: <Widget>[
                SingleChildScrollView(
                  scrollDirection: Axis.horizontal,
                  child: Row(
                    children:
                        List<Widget>.generate(schemeVariants.length, (int index) {
                          return ColorSchemeVariantColumn(
                            selectedColor: selectedColor,
                            brightness: selectedBrightness,
                            schemeVariant: schemeVariants[index],
                            contrastLevel: selectedContrast,
                          );
                        }).toList(),
                  ),
                ),
              ],
            ),
          ),
        ),
      ),
    );
  }
}

class Settings extends StatefulWidget {
  const Settings({
    super.key,
    required this.updateTheme,
    required this.selectedBrightness,
    required this.selectedContrast,
    required this.selectedColor,
  });

  final Brightness selectedBrightness;
  final double selectedContrast;
  final Color selectedColor;

  final void Function(Brightness, Color, double) updateTheme;

  @override
  State<Settings> createState() => _SettingsState();
}

class _SettingsState extends State<Settings> {
  late Brightness selectedBrightness = widget.selectedBrightness;
  late Color selectedColor = widget.selectedColor;
  late double selectedContrast = widget.selectedContrast;

  @override
  Widget build(BuildContext context) {
    return Theme(
      data: Theme.of(context).copyWith(
        colorScheme: ColorScheme.fromSeed(
          seedColor: selectedColor,
          contrastLevel: selectedContrast,
          brightness: selectedBrightness,
        ),
      ),
      child: ConstrainedBox(
        constraints: const BoxConstraints(maxHeight: 200),
        child: Padding(
          padding: const EdgeInsets.all(20.0),
          child: ListView(
            children: <Widget>[
              Center(child: Text('Settings', style: Theme.of(context).textTheme.titleLarge)),
              Row(
                children: <Widget>[
                  const Text('Brightness: '),
                  Switch(
                    value: selectedBrightness == Brightness.light,
                    onChanged: (bool value) {
                      setState(() {
                        selectedBrightness = value ? Brightness.light : Brightness.dark;
                      });
                      widget.updateTheme(selectedBrightness, selectedColor, selectedContrast);
                    },
                  ),
                ],
              ),
              Wrap(
                crossAxisAlignment: WrapCrossAlignment.center,
                children: <Widget>[
                  const Text('Seed color: '),
                  ...List<Widget>.generate(ColorSeed.values.length, (int index) {
                    final Color itemColor = ColorSeed.values[index].color;
                    return IconButton(
                      icon:
                          selectedColor == ColorSeed.values[index].color
                              ? Icon(Icons.circle, color: itemColor)
                              : Icon(Icons.circle_outlined, color: itemColor),
                      onPressed: () {
                        setState(() {
                          selectedColor = itemColor;
                        });
                        widget.updateTheme(selectedBrightness, selectedColor, selectedContrast);
                      },
                    );
                  }),
                ],
              ),
              Row(
                children: <Widget>[
                  const Text('Contrast level: '),
                  Expanded(
                    child: Slider(
                      divisions: 4,
                      label: selectedContrast.toString(),
                      min: -1,
                      value: selectedContrast,
                      onChanged: (double value) {
                        setState(() {
                          selectedContrast = value;
                        });
                        widget.updateTheme(selectedBrightness, selectedColor, selectedContrast);
                      },
                    ),
                  ),
                ],
              ),
            ],
          ),
        ),
      ),
    );
  }
}

class ColorSchemeVariantColumn extends StatelessWidget {
  const ColorSchemeVariantColumn({
    super.key,
    this.schemeVariant = DynamicSchemeVariant.tonalSpot,
    this.brightness = Brightness.light,
    this.contrastLevel = 0.0,
    required this.selectedColor,
  });

  final DynamicSchemeVariant schemeVariant;
  final Brightness brightness;
  final double contrastLevel;
  final Color selectedColor;

  @override
  Widget build(BuildContext context) {
    return ConstrainedBox(
      constraints: const BoxConstraints.tightFor(width: 250),
      child: Column(
        children: <Widget>[
          Padding(
            padding: const EdgeInsets.symmetric(vertical: 15),
            child: Text(
              schemeVariant.name == 'tonalSpot'
                  ? '${schemeVariant.name} (Default)'
                  : schemeVariant.name,
              style: const TextStyle(fontWeight: FontWeight.bold),
            ),
          ),
          Padding(
            padding: const EdgeInsets.symmetric(horizontal: 15),
            child: ColorSchemeView(
              colorScheme: ColorScheme.fromSeed(
                seedColor: selectedColor,
                brightness: brightness,
                contrastLevel: contrastLevel,
                dynamicSchemeVariant: schemeVariant,
              ),
            ),
          ),
        ],
      ),
    );
  }
}

class ColorSchemeView extends StatelessWidget {
  const ColorSchemeView({super.key, required this.colorScheme});

  final ColorScheme colorScheme;

  @override
  Widget build(BuildContext context) {
    return Column(
      children: <Widget>[
        ColorGroup(
          children: <ColorChip>[
            ColorChip('primary', colorScheme.primary, colorScheme.onPrimary),
            ColorChip('onPrimary', colorScheme.onPrimary, colorScheme.primary),
            ColorChip(
              'primaryContainer',
              colorScheme.primaryContainer,
              colorScheme.onPrimaryContainer,
            ),
            ColorChip(
              'onPrimaryContainer',
              colorScheme.onPrimaryContainer,
              colorScheme.primaryContainer,
            ),
          ],
        ),
        divider,
        ColorGroup(
          children: <ColorChip>[
            ColorChip('primaryFixed', colorScheme.primaryFixed, colorScheme.onPrimaryFixed),
            ColorChip('onPrimaryFixed', colorScheme.onPrimaryFixed, colorScheme.primaryFixed),
            ColorChip(
              'primaryFixedDim',
              colorScheme.primaryFixedDim,
              colorScheme.onPrimaryFixedVariant,
            ),
            ColorChip(
              'onPrimaryFixedVariant',
              colorScheme.onPrimaryFixedVariant,
              colorScheme.primaryFixedDim,
            ),
          ],
        ),
        divider,
        ColorGroup(
          children: <ColorChip>[
            ColorChip('secondary', colorScheme.secondary, colorScheme.onSecondary),
            ColorChip('onSecondary', colorScheme.onSecondary, colorScheme.secondary),
            ColorChip(
              'secondaryContainer',
              colorScheme.secondaryContainer,
              colorScheme.onSecondaryContainer,
            ),
            ColorChip(
              'onSecondaryContainer',
              colorScheme.onSecondaryContainer,
              colorScheme.secondaryContainer,
            ),
          ],
        ),
        divider,
        ColorGroup(
          children: <ColorChip>[
            ColorChip('secondaryFixed', colorScheme.secondaryFixed, colorScheme.onSecondaryFixed),
            ColorChip('onSecondaryFixed', colorScheme.onSecondaryFixed, colorScheme.secondaryFixed),
            ColorChip(
              'secondaryFixedDim',
              colorScheme.secondaryFixedDim,
              colorScheme.onSecondaryFixedVariant,
            ),
            ColorChip(
              'onSecondaryFixedVariant',
              colorScheme.onSecondaryFixedVariant,
              colorScheme.secondaryFixedDim,
            ),
          ],
        ),
        divider,
        ColorGroup(
          children: <ColorChip>[
            ColorChip('tertiary', colorScheme.tertiary, colorScheme.onTertiary),
            ColorChip('onTertiary', colorScheme.onTertiary, colorScheme.tertiary),
            ColorChip(
              'tertiaryContainer',
              colorScheme.tertiaryContainer,
              colorScheme.onTertiaryContainer,
            ),
            ColorChip(
              'onTertiaryContainer',
              colorScheme.onTertiaryContainer,
              colorScheme.tertiaryContainer,
            ),
          ],
        ),
        divider,
        ColorGroup(
          children: <ColorChip>[
            ColorChip('tertiaryFixed', colorScheme.tertiaryFixed, colorScheme.onTertiaryFixed),
            ColorChip('onTertiaryFixed', colorScheme.onTertiaryFixed, colorScheme.tertiaryFixed),
            ColorChip(
              'tertiaryFixedDim',
              colorScheme.tertiaryFixedDim,
              colorScheme.onTertiaryFixedVariant,
            ),
            ColorChip(
              'onTertiaryFixedVariant',
              colorScheme.onTertiaryFixedVariant,
              colorScheme.tertiaryFixedDim,
            ),
          ],
        ),
        divider,
        ColorGroup(
          children: <ColorChip>[
            ColorChip('error', colorScheme.error, colorScheme.onError),
            ColorChip('onError', colorScheme.onError, colorScheme.error),
            ColorChip('errorContainer', colorScheme.errorContainer, colorScheme.onErrorContainer),
            ColorChip('onErrorContainer', colorScheme.onErrorContainer, colorScheme.errorContainer),
          ],
        ),
        divider,
        ColorGroup(
          children: <ColorChip>[
            ColorChip('surfaceDim', colorScheme.surfaceDim, colorScheme.onSurface),
            ColorChip('surface', colorScheme.surface, colorScheme.onSurface),
            ColorChip('surfaceBright', colorScheme.surfaceBright, colorScheme.onSurface),
            ColorChip(
              'surfaceContainerLowest',
              colorScheme.surfaceContainerLowest,
              colorScheme.onSurface,
            ),
            ColorChip(
              'surfaceContainerLow',
              colorScheme.surfaceContainerLow,
              colorScheme.onSurface,
            ),
            ColorChip('surfaceContainer', colorScheme.surfaceContainer, colorScheme.onSurface),
            ColorChip(
              'surfaceContainerHigh',
              colorScheme.surfaceContainerHigh,
              colorScheme.onSurface,
            ),
            ColorChip(
              'surfaceContainerHighest',
              colorScheme.surfaceContainerHighest,
              colorScheme.onSurface,
            ),
            ColorChip('onSurface', colorScheme.onSurface, colorScheme.surface),
            ColorChip(
              'onSurfaceVariant',
              colorScheme.onSurfaceVariant,
              colorScheme.surfaceContainerHighest,
            ),
          ],
        ),
        divider,
        ColorGroup(
          children: <ColorChip>[
            ColorChip('outline', colorScheme.outline, null),
            ColorChip('shadow', colorScheme.shadow, null),
            ColorChip('inverseSurface', colorScheme.inverseSurface, colorScheme.onInverseSurface),
            ColorChip('onInverseSurface', colorScheme.onInverseSurface, colorScheme.inverseSurface),
            ColorChip('inversePrimary', colorScheme.inversePrimary, colorScheme.primary),
          ],
        ),
      ],
    );
  }
}

class ColorGroup extends StatelessWidget {
  const ColorGroup({super.key, required this.children});

  final List<Widget> children;

  @override
  Widget build(BuildContext context) {
    return RepaintBoundary(
      child: Card(clipBehavior: Clip.antiAlias, child: Column(children: children)),
    );
  }
}

class ColorChip extends StatelessWidget {
  const ColorChip(this.label, this.color, this.onColor, {super.key});

  final Color color;
  final Color? onColor;
  final String label;

  static Color contrastColor(Color color) {
    final Brightness brightness = ThemeData.estimateBrightnessForColor(color);
    return brightness == Brightness.dark ? Colors.white : Colors.black;
  }

  @override
  Widget build(BuildContext context) {
    final Color labelColor = onColor ?? contrastColor(color);
    return ColoredBox(
      color: color,
      child: Padding(
        padding: const EdgeInsets.all(16),
        child: Row(
          children: <Expanded>[Expanded(child: Text(label, style: TextStyle(color: labelColor)))],
        ),
      ),
    );
  }
}

enum ColorSeed {
  baseColor('M3 Baseline', Color(0xff6750a4)),
  indigo('Indigo', Colors.indigo),
  blue('Blue', Colors.blue),
  teal('Teal', Colors.teal),
  green('Green', Colors.green),
  yellow('Yellow', Colors.yellow),
  orange('Orange', Colors.orange),
  deepOrange('Deep Orange', Colors.deepOrange),
  pink('Pink', Colors.pink),
  brightBlue('Bright Blue', Color(0xFF0000FF)),
  brightGreen('Bright Green', Color(0xFF00FF00)),
  brightRed('Bright Red', Color(0xFFFF0000));

  const ColorSeed(this.label, this.color);
  final String label;
  final Color color;
}

class SettingsButton extends StatelessWidget {
  const SettingsButton({
    super.key,
    required this.updateTheme,
    required this.selectedBrightness,
    required this.selectedContrast,
    required this.selectedColor,
  });

  final Brightness selectedBrightness;
  final double selectedContrast;
  final Color selectedColor;

  final void Function(Brightness, Color, double) updateTheme;

  @override
  Widget build(BuildContext context) {
    return IconButton(
      icon: const Icon(Icons.settings),
      onPressed: () {
        showModalBottomSheet<void>(
          barrierColor: Colors.transparent,
          context: context,
          builder: (BuildContext context) {
            return Settings(
              selectedColor: selectedColor,
              selectedBrightness: selectedBrightness,
              selectedContrast: selectedContrast,
              updateTheme: updateTheme,
            );
          },
        );
      },
    );
  }
}


Instructions for the chapter (Generate content in English unless specified otherwise):
- Start with a clear heading (e.g., `# Chapter 1: ColorSchemeExample
`). Use the provided concept name.

- If this is not the first chapter, begin with a brief transition from the previous chapter, referencing it with a proper Markdown link using its name.

- Begin with a high-level motivation explaining what problem this abstraction solves. Start with a central use case as a concrete example. The whole chapter should guide the reader to understand how to solve this use case. Make it very minimal and friendly to beginners.

- If the abstraction is complex, break it down into key concepts. Explain each concept one-by-one in a very beginner-friendly way.

- Explain how to use this abstraction to solve the use case. Give example inputs and outputs for code snippets (if the output isn't values, describe at a high level what will happen).

- Each code block should be BELOW 10 lines! If longer code blocks are needed, break them down into smaller pieces and walk through them one-by-one. Aggresively simplify the code to make it minimal. Use comments to skip non-important implementation details. Each code block should have a beginner friendly explanation right after it.

- Describe the internal implementation to help understand what's under the hood. First provide a non-code or code-light walkthrough on what happens step-by-step when the abstraction is called. It's recommended to use a simple sequenceDiagram with a dummy example - keep it minimal with at most 5 participants to ensure clarity. If participant name has space, use: `participant QP as Query Processing`. .

- Then dive deeper into code for the internal implementation with references to files. Provide example code blocks, but make them similarly simple and beginner-friendly. Explain.

- IMPORTANT: When you need to refer to other core abstractions covered in other chapters, ALWAYS use proper Markdown links like this: [Chapter Title](filename.md). Use the Complete Tutorial Structure above to find the correct filename and the chapter title. Translate the surrounding text.

- Use mermaid diagrams to illustrate complex concepts (```mermaid``` format). .

- Heavily use analogies and examples throughout to help beginners understand.

- End the chapter with a brief conclusion that summarizes what was learned and provides a transition to the next chapter. If there is a next chapter, use a proper Markdown link: [Next Chapter Title](next_chapter_filename).

- Ensure the tone is welcoming and easy for a newcomer to understand.

- Output *only* the Markdown content for this chapter.

Now, directly provide a super beginner-friendly Markdown output (DON'T need ```markdown``` tags):

2025-05-28 16:29:57,146 - INFO - RESPONSE: # Chapter 1: ColorSchemeExample

Welcome, aspiring Flutter developer! In this chapter, we're going to meet the main conductor of our app's visual symphony: `ColorSchemeExample`. Think of this like the main boss or the central hub of our application. It's the widget that gets everything started and keeps track of the overall look and feel, specifically the colors!

## What is ColorSchemeExample?

Imagine you're building a house, and you want to decide on the paint colors, the brightness of the rooms, and how much contrast you want between different elements. The `ColorSchemeExample` is like the architect who holds the master plan for all these color decisions. It decides things like:

*   **What are the main colors of the app?**
*   **Should the app be light or dark?** (Brightness)
*   **How much difference should there be between colors and text?** (Contrast)

And the best part? If you change any of these decisions (like choosing a different main color), the `ColorSchemeExample` knows and makes sure the *whole* house (your app) updates to the new plan.

Our specific use case for this chapter is to see how `ColorSchemeExample` manages the initial color settings of our app.

## How does ColorSchemeExample work?

Let's take a look at the main part of the `ColorSchemeExample` code. Don't worry about understanding every single line right away. We'll break it down.

```dart
void main() => runApp(const ColorSchemeExample());

class ColorSchemeExample extends StatefulWidget {
  const ColorSchemeExample({super.key});

  @override
  State<ColorSchemeExample> createState() => _ColorSchemeExampleState();
}

class _ColorSchemeExampleState extends State<ColorSchemeExample> {
  Color selectedColor = ColorSeed.baseColor.color;
  Brightness selectedBrightness = Brightness.light;
  double selectedContrast = 0.0;
  // ... other code
}
```

This code shows us a couple of key things:

1.  `void main() => runApp(const ColorSchemeExample());`: This is where our app starts! It tells Flutter to run the `ColorSchemeExample` widget.
2.  `ColorSchemeExample extends StatefulWidget`: This means our `ColorSchemeExample` can change over time. If you change the color settings, the widget can rebuild itself to show the new colors.
3.  `_ColorSchemeExampleState`: This is where the `ColorSchemeExample` keeps track of its state, or its current settings. Notice `selectedColor`, `selectedBrightness`, and `selectedContrast`. These are the main color-related decisions it's currently holding.

So, when the app first starts, `ColorSchemeExample` sets up its initial color decisions (like the default primary color, brightness, and contrast).

## Setting up the Theme

The `ColorSchemeExample` also uses these color decisions to set the overall theme of the app. Let's look at the `build` method:

```dart
@override
Widget build(BuildContext context) {
  return MaterialApp(
    debugShowCheckedModeBanner: false,
    theme: ThemeData(
      colorScheme: ColorScheme.fromSeed(
        seedColor: selectedColor,
        brightness: selectedBrightness,
        contrastLevel: selectedContrast,
      ),
    ),
    // ... rest of the build method
  );
}
```

Here's what's happening:

*   `return MaterialApp(...)`: This is the basic structure for a Flutter app. It provides important things like navigation and theming.
*   `theme: ThemeData(...)`: This is where we define the visual theme for our app.
*   `colorScheme: ColorScheme.fromSeed(...)`: This is a super helpful way to create a whole set of colors for your app based on just one "seed" color. `ColorSchemeExample` uses its `selectedColor`, `selectedBrightness`, and `selectedContrast` to generate a complete `ColorScheme`. This `ColorScheme` contains many different color definitions (like primary, secondary, surface, etc.) that are all related to the seed color and brightness.

Essentially, `ColorSchemeExample` takes some basic color decisions and uses them to create a full `ColorScheme` that the rest of the app can use.

## How Changes Happen (Behind the Scenes)

We said `ColorSchemeExample` is like the conductor. When you make a change (like picking a new color from a settings menu, which we'll see in later chapters), here's a simplified look at what happens:

```mermaid
sequenceDiagram
    participant User
    participant CS as ColorSchemeExample
    participant State as _ColorSchemeExampleState
    participant App as MaterialApp

    User->CS: Wants to change color
    CS->State: Calls updateTheme()
    State->State: Updates selectedColor
    State->CS: Signals state changed (setState)
    CS->App: Rebuilds with new theme data
    App-->User: App shows with new colors
```

1.  The user interacts with something (like a button) to change a setting (like the color).
2.  This interaction tells the `ColorSchemeExample` to update.
3.  The `_ColorSchemeExampleState` inside `ColorSchemeExample` updates its stored color settings (`selectedColor`, `selectedBrightness`, etc.).
4.  It then tells Flutter that its state has changed using `setState()`.
5.  Because the state changed, the `ColorSchemeExample` widget (specifically its `build` method) runs again.
6.  In the `build` method, it creates a *new* `ThemeData` with a *new* `ColorScheme.fromSeed` based on the updated settings.
7.  The `MaterialApp` uses this new theme, and the entire app visually updates to reflect the changes.

This is the fundamental way `ColorSchemeExample` manages and updates the color theme of the application. It holds the core settings, uses them to generate a `ColorScheme`, and rebuilds the app when those settings change.

## Conclusion

In this chapter, we introduced `ColorSchemeExample`, the central widget responsible for managing our app's color theme. We saw how it holds the key color settings (seed color, brightness, contrast) and uses them to create a `ColorScheme` that defines the visual look of the application. We also got a glimpse of how it reacts to changes and updates the entire app's appearance.

Now that we understand the main conductor, let's look at how we can interact with it to change those settings. In the next chapter, we'll explore the [SettingsButton](02_settingsbutton_.md), which is how a user can open the options to customize the theme.

Ready to see how we actually change these colors? Let's move on!

[Chapter 2: SettingsButton](02_settingsbutton_.md)
2025-05-28 16:29:57,149 - INFO - PROMPT: 
Write a very beginner-friendly tutorial chapter (in Markdown format) for the project `flutter` about the concept: "SettingsButton
". This is Chapter 2.

Concept Details:
- Name: SettingsButton

- Description:
This is the button located in the app bar that, when pressed, opens the `Settings` panel.
It's like a door handle that grants you access to the control panel where you can customize the theme.


Complete Tutorial Structure:
1. [ColorSchemeExample
](01_colorschemeexample_.md)
2. [SettingsButton
](02_settingsbutton_.md)
3. [Settings
](03_settings_.md)
4. [ColorSchemeVariantColumn
](04_colorschemevariantcolumn_.md)
5. [ColorSchemeView
](05_colorschemeview_.md)
6. [ColorGroup
](06_colorgroup_.md)
7. [ColorChip
](07_colorchip_.md)
8. [ColorSeed
](08_colorseed_.md)

Context from previous chapters:
# Chapter 1: ColorSchemeExample

Welcome, aspiring Flutter developer! In this chapter, we're going to meet the main conductor of our app's visual symphony: `ColorSchemeExample`. Think of this like the main boss or the central hub of our application. It's the widget that gets everything started and keeps track of the overall look and feel, specifically the colors!

## What is ColorSchemeExample?

Imagine you're building a house, and you want to decide on the paint colors, the brightness of the rooms, and how much contrast you want between different elements. The `ColorSchemeExample` is like the architect who holds the master plan for all these color decisions. It decides things like:

*   **What are the main colors of the app?**
*   **Should the app be light or dark?** (Brightness)
*   **How much difference should there be between colors and text?** (Contrast)

And the best part? If you change any of these decisions (like choosing a different main color), the `ColorSchemeExample` knows and makes sure the *whole* house (your app) updates to the new plan.

Our specific use case for this chapter is to see how `ColorSchemeExample` manages the initial color settings of our app.

## How does ColorSchemeExample work?

Let's take a look at the main part of the `ColorSchemeExample` code. Don't worry about understanding every single line right away. We'll break it down.

```dart
void main() => runApp(const ColorSchemeExample());

class ColorSchemeExample extends StatefulWidget {
  const ColorSchemeExample({super.key});

  @override
  State<ColorSchemeExample> createState() => _ColorSchemeExampleState();
}

class _ColorSchemeExampleState extends State<ColorSchemeExample> {
  Color selectedColor = ColorSeed.baseColor.color;
  Brightness selectedBrightness = Brightness.light;
  double selectedContrast = 0.0;
  // ... other code
}
```

This code shows us a couple of key things:

1.  `void main() => runApp(const ColorSchemeExample());`: This is where our app starts! It tells Flutter to run the `ColorSchemeExample` widget.
2.  `ColorSchemeExample extends StatefulWidget`: This means our `ColorSchemeExample` can change over time. If you change the color settings, the widget can rebuild itself to show the new colors.
3.  `_ColorSchemeExampleState`: This is where the `ColorSchemeExample` keeps track of its state, or its current settings. Notice `selectedColor`, `selectedBrightness`, and `selectedContrast`. These are the main color-related decisions it's currently holding.

So, when the app first starts, `ColorSchemeExample` sets up its initial color decisions (like the default primary color, brightness, and contrast).

## Setting up the Theme

The `ColorSchemeExample` also uses these color decisions to set the overall theme of the app. Let's look at the `build` method:

```dart
@override
Widget build(BuildContext context) {
  return MaterialApp(
    debugShowCheckedModeBanner: false,
    theme: ThemeData(
      colorScheme: ColorScheme.fromSeed(
        seedColor: selectedColor,
        brightness: selectedBrightness,
        contrastLevel: selectedContrast,
      ),
    ),
    // ... rest of the build method
  );
}
```

Here's what's happening:

*   `return MaterialApp(...)`: This is the basic structure for a Flutter app. It provides important things like navigation and theming.
*   `theme: ThemeData(...)`: This is where we define the visual theme for our app.
*   `colorScheme: ColorScheme.fromSeed(...)`: This is a super helpful way to create a whole set of colors for your app based on just one "seed" color. `ColorSchemeExample` uses its `selectedColor`, `selectedBrightness`, and `selectedContrast` to generate a complete `ColorScheme`. This `ColorScheme` contains many different color definitions (like primary, secondary, surface, etc.) that are all related to the seed color and brightness.

Essentially, `ColorSchemeExample` takes some basic color decisions and uses them to create a full `ColorScheme` that the rest of the app can use.

## How Changes Happen (Behind the Scenes)

We said `ColorSchemeExample` is like the conductor. When you make a change (like picking a new color from a settings menu, which we'll see in later chapters), here's a simplified look at what happens:

```mermaid
sequenceDiagram
    participant User
    participant CS as ColorSchemeExample
    participant State as _ColorSchemeExampleState
    participant App as MaterialApp

    User->CS: Wants to change color
    CS->State: Calls updateTheme()
    State->State: Updates selectedColor
    State->CS: Signals state changed (setState)
    CS->App: Rebuilds with new theme data
    App-->User: App shows with new colors
```

1.  The user interacts with something (like a button) to change a setting (like the color).
2.  This interaction tells the `ColorSchemeExample` to update.
3.  The `_ColorSchemeExampleState` inside `ColorSchemeExample` updates its stored color settings (`selectedColor`, `selectedBrightness`, etc.).
4.  It then tells Flutter that its state has changed using `setState()`.
5.  Because the state changed, the `ColorSchemeExample` widget (specifically its `build` method) runs again.
6.  In the `build` method, it creates a *new* `ThemeData` with a *new* `ColorScheme.fromSeed` based on the updated settings.
7.  The `MaterialApp` uses this new theme, and the entire app visually updates to reflect the changes.

This is the fundamental way `ColorSchemeExample` manages and updates the color theme of the application. It holds the core settings, uses them to generate a `ColorScheme`, and rebuilds the app when those settings change.

## Conclusion

In this chapter, we introduced `ColorSchemeExample`, the central widget responsible for managing our app's color theme. We saw how it holds the key color settings (seed color, brightness, contrast) and uses them to create a `ColorScheme` that defines the visual look of the application. We also got a glimpse of how it reacts to changes and updates the entire app's appearance.

Now that we understand the main conductor, let's look at how we can interact with it to change those settings. In the next chapter, we'll explore the [SettingsButton](02_settingsbutton_.md), which is how a user can open the options to customize the theme.

Ready to see how we actually change these colors? Let's move on!

[Chapter 2: SettingsButton](02_settingsbutton_.md)

Relevant Code Snippets (Code itself remains unchanged):
--- File: color_scheme.0.dart ---
// Copyright 2014 The Flutter Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

import 'package:flutter/material.dart';

/// Flutter code sample for [ColorScheme].

const Widget divider = SizedBox(height: 10);

void main() => runApp(const ColorSchemeExample());

class ColorSchemeExample extends StatefulWidget {
  const ColorSchemeExample({super.key});

  @override
  State<ColorSchemeExample> createState() => _ColorSchemeExampleState();
}

class _ColorSchemeExampleState extends State<ColorSchemeExample> {
  Color selectedColor = ColorSeed.baseColor.color;
  Brightness selectedBrightness = Brightness.light;
  double selectedContrast = 0.0;
  static const List<DynamicSchemeVariant> schemeVariants = DynamicSchemeVariant.values;

  void updateTheme(Brightness brightness, Color color, double contrastLevel) {
    setState(() {
      selectedBrightness = brightness;
      selectedColor = color;
      selectedContrast = contrastLevel;
    });
  }

  @override
  Widget build(BuildContext context) {
    return MaterialApp(
      debugShowCheckedModeBanner: false,
      theme: ThemeData(
        colorScheme: ColorScheme.fromSeed(
          seedColor: selectedColor,
          brightness: selectedBrightness,
          contrastLevel: selectedContrast,
        ),
      ),
      home: Scaffold(
        appBar: AppBar(
          title: const Text('ColorScheme'),
          actions: <Widget>[
            SettingsButton(
              selectedColor: selectedColor,
              selectedBrightness: selectedBrightness,
              selectedContrast: selectedContrast,
              updateTheme: updateTheme,
            ),
          ],
        ),
        body: SingleChildScrollView(
          child: Padding(
            padding: const EdgeInsets.only(top: 5),
            child: Column(
              crossAxisAlignment: CrossAxisAlignment.start,
              children: <Widget>[
                SingleChildScrollView(
                  scrollDirection: Axis.horizontal,
                  child: Row(
                    children:
                        List<Widget>.generate(schemeVariants.length, (int index) {
                          return ColorSchemeVariantColumn(
                            selectedColor: selectedColor,
                            brightness: selectedBrightness,
                            schemeVariant: schemeVariants[index],
                            contrastLevel: selectedContrast,
                          );
                        }).toList(),
                  ),
                ),
              ],
            ),
          ),
        ),
      ),
    );
  }
}

class Settings extends StatefulWidget {
  const Settings({
    super.key,
    required this.updateTheme,
    required this.selectedBrightness,
    required this.selectedContrast,
    required this.selectedColor,
  });

  final Brightness selectedBrightness;
  final double selectedContrast;
  final Color selectedColor;

  final void Function(Brightness, Color, double) updateTheme;

  @override
  State<Settings> createState() => _SettingsState();
}

class _SettingsState extends State<Settings> {
  late Brightness selectedBrightness = widget.selectedBrightness;
  late Color selectedColor = widget.selectedColor;
  late double selectedContrast = widget.selectedContrast;

  @override
  Widget build(BuildContext context) {
    return Theme(
      data: Theme.of(context).copyWith(
        colorScheme: ColorScheme.fromSeed(
          seedColor: selectedColor,
          contrastLevel: selectedContrast,
          brightness: selectedBrightness,
        ),
      ),
      child: ConstrainedBox(
        constraints: const BoxConstraints(maxHeight: 200),
        child: Padding(
          padding: const EdgeInsets.all(20.0),
          child: ListView(
            children: <Widget>[
              Center(child: Text('Settings', style: Theme.of(context).textTheme.titleLarge)),
              Row(
                children: <Widget>[
                  const Text('Brightness: '),
                  Switch(
                    value: selectedBrightness == Brightness.light,
                    onChanged: (bool value) {
                      setState(() {
                        selectedBrightness = value ? Brightness.light : Brightness.dark;
                      });
                      widget.updateTheme(selectedBrightness, selectedColor, selectedContrast);
                    },
                  ),
                ],
              ),
              Wrap(
                crossAxisAlignment: WrapCrossAlignment.center,
                children: <Widget>[
                  const Text('Seed color: '),
                  ...List<Widget>.generate(ColorSeed.values.length, (int index) {
                    final Color itemColor = ColorSeed.values[index].color;
                    return IconButton(
                      icon:
                          selectedColor == ColorSeed.values[index].color
                              ? Icon(Icons.circle, color: itemColor)
                              : Icon(Icons.circle_outlined, color: itemColor),
                      onPressed: () {
                        setState(() {
                          selectedColor = itemColor;
                        });
                        widget.updateTheme(selectedBrightness, selectedColor, selectedContrast);
                      },
                    );
                  }),
                ],
              ),
              Row(
                children: <Widget>[
                  const Text('Contrast level: '),
                  Expanded(
                    child: Slider(
                      divisions: 4,
                      label: selectedContrast.toString(),
                      min: -1,
                      value: selectedContrast,
                      onChanged: (double value) {
                        setState(() {
                          selectedContrast = value;
                        });
                        widget.updateTheme(selectedBrightness, selectedColor, selectedContrast);
                      },
                    ),
                  ),
                ],
              ),
            ],
          ),
        ),
      ),
    );
  }
}

class ColorSchemeVariantColumn extends StatelessWidget {
  const ColorSchemeVariantColumn({
    super.key,
    this.schemeVariant = DynamicSchemeVariant.tonalSpot,
    this.brightness = Brightness.light,
    this.contrastLevel = 0.0,
    required this.selectedColor,
  });

  final DynamicSchemeVariant schemeVariant;
  final Brightness brightness;
  final double contrastLevel;
  final Color selectedColor;

  @override
  Widget build(BuildContext context) {
    return ConstrainedBox(
      constraints: const BoxConstraints.tightFor(width: 250),
      child: Column(
        children: <Widget>[
          Padding(
            padding: const EdgeInsets.symmetric(vertical: 15),
            child: Text(
              schemeVariant.name == 'tonalSpot'
                  ? '${schemeVariant.name} (Default)'
                  : schemeVariant.name,
              style: const TextStyle(fontWeight: FontWeight.bold),
            ),
          ),
          Padding(
            padding: const EdgeInsets.symmetric(horizontal: 15),
            child: ColorSchemeView(
              colorScheme: ColorScheme.fromSeed(
                seedColor: selectedColor,
                brightness: brightness,
                contrastLevel: contrastLevel,
                dynamicSchemeVariant: schemeVariant,
              ),
            ),
          ),
        ],
      ),
    );
  }
}

class ColorSchemeView extends StatelessWidget {
  const ColorSchemeView({super.key, required this.colorScheme});

  final ColorScheme colorScheme;

  @override
  Widget build(BuildContext context) {
    return Column(
      children: <Widget>[
        ColorGroup(
          children: <ColorChip>[
            ColorChip('primary', colorScheme.primary, colorScheme.onPrimary),
            ColorChip('onPrimary', colorScheme.onPrimary, colorScheme.primary),
            ColorChip(
              'primaryContainer',
              colorScheme.primaryContainer,
              colorScheme.onPrimaryContainer,
            ),
            ColorChip(
              'onPrimaryContainer',
              colorScheme.onPrimaryContainer,
              colorScheme.primaryContainer,
            ),
          ],
        ),
        divider,
        ColorGroup(
          children: <ColorChip>[
            ColorChip('primaryFixed', colorScheme.primaryFixed, colorScheme.onPrimaryFixed),
            ColorChip('onPrimaryFixed', colorScheme.onPrimaryFixed, colorScheme.primaryFixed),
            ColorChip(
              'primaryFixedDim',
              colorScheme.primaryFixedDim,
              colorScheme.onPrimaryFixedVariant,
            ),
            ColorChip(
              'onPrimaryFixedVariant',
              colorScheme.onPrimaryFixedVariant,
              colorScheme.primaryFixedDim,
            ),
          ],
        ),
        divider,
        ColorGroup(
          children: <ColorChip>[
            ColorChip('secondary', colorScheme.secondary, colorScheme.onSecondary),
            ColorChip('onSecondary', colorScheme.onSecondary, colorScheme.secondary),
            ColorChip(
              'secondaryContainer',
              colorScheme.secondaryContainer,
              colorScheme.onSecondaryContainer,
            ),
            ColorChip(
              'onSecondaryContainer',
              colorScheme.onSecondaryContainer,
              colorScheme.secondaryContainer,
            ),
          ],
        ),
        divider,
        ColorGroup(
          children: <ColorChip>[
            ColorChip('secondaryFixed', colorScheme.secondaryFixed, colorScheme.onSecondaryFixed),
            ColorChip('onSecondaryFixed', colorScheme.onSecondaryFixed, colorScheme.secondaryFixed),
            ColorChip(
              'secondaryFixedDim',
              colorScheme.secondaryFixedDim,
              colorScheme.onSecondaryFixedVariant,
            ),
            ColorChip(
              'onSecondaryFixedVariant',
              colorScheme.onSecondaryFixedVariant,
              colorScheme.secondaryFixedDim,
            ),
          ],
        ),
        divider,
        ColorGroup(
          children: <ColorChip>[
            ColorChip('tertiary', colorScheme.tertiary, colorScheme.onTertiary),
            ColorChip('onTertiary', colorScheme.onTertiary, colorScheme.tertiary),
            ColorChip(
              'tertiaryContainer',
              colorScheme.tertiaryContainer,
              colorScheme.onTertiaryContainer,
            ),
            ColorChip(
              'onTertiaryContainer',
              colorScheme.onTertiaryContainer,
              colorScheme.tertiaryContainer,
            ),
          ],
        ),
        divider,
        ColorGroup(
          children: <ColorChip>[
            ColorChip('tertiaryFixed', colorScheme.tertiaryFixed, colorScheme.onTertiaryFixed),
            ColorChip('onTertiaryFixed', colorScheme.onTertiaryFixed, colorScheme.tertiaryFixed),
            ColorChip(
              'tertiaryFixedDim',
              colorScheme.tertiaryFixedDim,
              colorScheme.onTertiaryFixedVariant,
            ),
            ColorChip(
              'onTertiaryFixedVariant',
              colorScheme.onTertiaryFixedVariant,
              colorScheme.tertiaryFixedDim,
            ),
          ],
        ),
        divider,
        ColorGroup(
          children: <ColorChip>[
            ColorChip('error', colorScheme.error, colorScheme.onError),
            ColorChip('onError', colorScheme.onError, colorScheme.error),
            ColorChip('errorContainer', colorScheme.errorContainer, colorScheme.onErrorContainer),
            ColorChip('onErrorContainer', colorScheme.onErrorContainer, colorScheme.errorContainer),
          ],
        ),
        divider,
        ColorGroup(
          children: <ColorChip>[
            ColorChip('surfaceDim', colorScheme.surfaceDim, colorScheme.onSurface),
            ColorChip('surface', colorScheme.surface, colorScheme.onSurface),
            ColorChip('surfaceBright', colorScheme.surfaceBright, colorScheme.onSurface),
            ColorChip(
              'surfaceContainerLowest',
              colorScheme.surfaceContainerLowest,
              colorScheme.onSurface,
            ),
            ColorChip(
              'surfaceContainerLow',
              colorScheme.surfaceContainerLow,
              colorScheme.onSurface,
            ),
            ColorChip('surfaceContainer', colorScheme.surfaceContainer, colorScheme.onSurface),
            ColorChip(
              'surfaceContainerHigh',
              colorScheme.surfaceContainerHigh,
              colorScheme.onSurface,
            ),
            ColorChip(
              'surfaceContainerHighest',
              colorScheme.surfaceContainerHighest,
              colorScheme.onSurface,
            ),
            ColorChip('onSurface', colorScheme.onSurface, colorScheme.surface),
            ColorChip(
              'onSurfaceVariant',
              colorScheme.onSurfaceVariant,
              colorScheme.surfaceContainerHighest,
            ),
          ],
        ),
        divider,
        ColorGroup(
          children: <ColorChip>[
            ColorChip('outline', colorScheme.outline, null),
            ColorChip('shadow', colorScheme.shadow, null),
            ColorChip('inverseSurface', colorScheme.inverseSurface, colorScheme.onInverseSurface),
            ColorChip('onInverseSurface', colorScheme.onInverseSurface, colorScheme.inverseSurface),
            ColorChip('inversePrimary', colorScheme.inversePrimary, colorScheme.primary),
          ],
        ),
      ],
    );
  }
}

class ColorGroup extends StatelessWidget {
  const ColorGroup({super.key, required this.children});

  final List<Widget> children;

  @override
  Widget build(BuildContext context) {
    return RepaintBoundary(
      child: Card(clipBehavior: Clip.antiAlias, child: Column(children: children)),
    );
  }
}

class ColorChip extends StatelessWidget {
  const ColorChip(this.label, this.color, this.onColor, {super.key});

  final Color color;
  final Color? onColor;
  final String label;

  static Color contrastColor(Color color) {
    final Brightness brightness = ThemeData.estimateBrightnessForColor(color);
    return brightness == Brightness.dark ? Colors.white : Colors.black;
  }

  @override
  Widget build(BuildContext context) {
    final Color labelColor = onColor ?? contrastColor(color);
    return ColoredBox(
      color: color,
      child: Padding(
        padding: const EdgeInsets.all(16),
        child: Row(
          children: <Expanded>[Expanded(child: Text(label, style: TextStyle(color: labelColor)))],
        ),
      ),
    );
  }
}

enum ColorSeed {
  baseColor('M3 Baseline', Color(0xff6750a4)),
  indigo('Indigo', Colors.indigo),
  blue('Blue', Colors.blue),
  teal('Teal', Colors.teal),
  green('Green', Colors.green),
  yellow('Yellow', Colors.yellow),
  orange('Orange', Colors.orange),
  deepOrange('Deep Orange', Colors.deepOrange),
  pink('Pink', Colors.pink),
  brightBlue('Bright Blue', Color(0xFF0000FF)),
  brightGreen('Bright Green', Color(0xFF00FF00)),
  brightRed('Bright Red', Color(0xFFFF0000));

  const ColorSeed(this.label, this.color);
  final String label;
  final Color color;
}

class SettingsButton extends StatelessWidget {
  const SettingsButton({
    super.key,
    required this.updateTheme,
    required this.selectedBrightness,
    required this.selectedContrast,
    required this.selectedColor,
  });

  final Brightness selectedBrightness;
  final double selectedContrast;
  final Color selectedColor;

  final void Function(Brightness, Color, double) updateTheme;

  @override
  Widget build(BuildContext context) {
    return IconButton(
      icon: const Icon(Icons.settings),
      onPressed: () {
        showModalBottomSheet<void>(
          barrierColor: Colors.transparent,
          context: context,
          builder: (BuildContext context) {
            return Settings(
              selectedColor: selectedColor,
              selectedBrightness: selectedBrightness,
              selectedContrast: selectedContrast,
              updateTheme: updateTheme,
            );
          },
        );
      },
    );
  }
}


Instructions for the chapter (Generate content in English unless specified otherwise):
- Start with a clear heading (e.g., `# Chapter 2: SettingsButton
`). Use the provided concept name.

- If this is not the first chapter, begin with a brief transition from the previous chapter, referencing it with a proper Markdown link using its name.

- Begin with a high-level motivation explaining what problem this abstraction solves. Start with a central use case as a concrete example. The whole chapter should guide the reader to understand how to solve this use case. Make it very minimal and friendly to beginners.

- If the abstraction is complex, break it down into key concepts. Explain each concept one-by-one in a very beginner-friendly way.

- Explain how to use this abstraction to solve the use case. Give example inputs and outputs for code snippets (if the output isn't values, describe at a high level what will happen).

- Each code block should be BELOW 10 lines! If longer code blocks are needed, break them down into smaller pieces and walk through them one-by-one. Aggresively simplify the code to make it minimal. Use comments to skip non-important implementation details. Each code block should have a beginner friendly explanation right after it.

- Describe the internal implementation to help understand what's under the hood. First provide a non-code or code-light walkthrough on what happens step-by-step when the abstraction is called. It's recommended to use a simple sequenceDiagram with a dummy example - keep it minimal with at most 5 participants to ensure clarity. If participant name has space, use: `participant QP as Query Processing`. .

- Then dive deeper into code for the internal implementation with references to files. Provide example code blocks, but make them similarly simple and beginner-friendly. Explain.

- IMPORTANT: When you need to refer to other core abstractions covered in other chapters, ALWAYS use proper Markdown links like this: [Chapter Title](filename.md). Use the Complete Tutorial Structure above to find the correct filename and the chapter title. Translate the surrounding text.

- Use mermaid diagrams to illustrate complex concepts (```mermaid``` format). .

- Heavily use analogies and examples throughout to help beginners understand.

- End the chapter with a brief conclusion that summarizes what was learned and provides a transition to the next chapter. If there is a next chapter, use a proper Markdown link: [Next Chapter Title](next_chapter_filename).

- Ensure the tone is welcoming and easy for a newcomer to understand.

- Output *only* the Markdown content for this chapter.

Now, directly provide a super beginner-friendly Markdown output (DON'T need ```markdown``` tags):

2025-05-28 16:30:09,238 - INFO - RESPONSE: # Chapter 2: SettingsButton

Welcome back! In the last chapter, [ColorSchemeExample](01_colorschemeexample_.md), we learned about the main conductor of our app's colors. It's the widget that holds the plan for our app's look and feel. But how do we actually tell that conductor we want to change the plan? That's where the `SettingsButton` comes in!

Imagine our app as a house with the color plan managed by the architect ([ColorSchemeExample](01_colorschemeexample_.md)). The `SettingsButton` is like a special door handle on the app bar that lets us into the room where we can talk to the architect and ask for changes!

## What is SettingsButton?

The `SettingsButton` is simply a button that sits usually at the top right corner of your app screen, in the "app bar". When you tap it, it doesn't change anything visually itself. Its job is to make something *else* appear – in our case, a panel where we can change the color settings.

Think of it as a gateway. Tapping the `SettingsButton` opens the door to the settings area.

Our specific use case is simple: we want a button in our app bar that, when pressed, shows a temporary panel where we can change the color theme.

## How does SettingsButton work?

Let's look at the code for the `SettingsButton`.

```dart
class SettingsButton extends StatelessWidget {
  const SettingsButton({
    super.key,
    required this.updateTheme,
    // ... other required parameters
  });

  final void Function(Brightness, Color, double) updateTheme;

  @override
  Widget build(BuildContext context) {
    return IconButton(
      icon: const Icon(Icons.settings),
      onPressed: () {
        // This is where the magic happens!
        // It shows a small panel at the bottom.
        showModalBottomSheet<void>(
          barrierColor: Colors.transparent,
          context: context,
          builder: (BuildContext context) {
            // We'll talk about this 'Settings' widget in the next chapter!
            return Settings(
              // Pass the current settings and the way to update the theme
              selectedColor: selectedColor,
              selectedBrightness: selectedBrightness,
              selectedContrast: selectedContrast,
              updateTheme: updateTheme,
            );
          },
        );
      },
    );
  }
}
```

Let's break down the important parts:

1.  `class SettingsButton extends StatelessWidget`: This tells us that the `SettingsButton` itself doesn't change its appearance based on internal data. It's a static button, though what happens when you press it can change things elsewhere!
2.  `required this.updateTheme`: Remember how in [ColorSchemeExample](01_colorschemeexample_.md) we talked about the `updateTheme` function that actually changes the color settings? The `SettingsButton` needs to *know* about this function so it can pass it along to the settings panel.
3.  `@override Widget build(BuildContext context)`: This is where the `SettingsButton` creates its appearance.
4.  `return IconButton(...)`: This is a common Flutter widget for a button that's just an icon. It's perfect for our settings icon!
5.  `icon: const Icon(Icons.settings)`: This gives the `IconButton` the familiar gear icon used for settings.
6.  `onPressed: () { ... }`: This is the crucial part! This defines what happens *when the button is tapped*.
7.  `showModalBottomSheet<void>(...)`: This is a Flutter function that displays a temporary panel that slides up from the bottom of the screen. This is exactly what we want for our settings panel!
8.  `builder: (BuildContext context) { ... return Settings(...) }`: This part tells `showModalBottomSheet` *what* to show inside the panel. It's showing a widget called `Settings`. We'll dive deeper into this `Settings` widget in the next chapter, [Settings](03_settings_.md).

So, when you tap the `SettingsButton`, it calls `showModalBottomSheet`, which then builds and displays the `Settings` widget at the bottom of the screen. The `SettingsButton` also passes the `updateTheme` function and the *current* theme settings to the `Settings` widget so it knows what the theme is now and how to change it.

## Where does the SettingsButton live?

The `SettingsButton` is placed within the app bar of our main screen ([ColorSchemeExample](01_colorschemeexample_.md)). Look at this small snippet from the `ColorSchemeExample`'s `build` method:

```dart
  @override
  Widget build(BuildContext context) {
    return MaterialApp(
      // ... theme setup ...
      home: Scaffold(
        appBar: AppBar(
          title: const Text('ColorScheme'),
          actions: <Widget>[
            // Here it is!
            SettingsButton(
              selectedColor: selectedColor,
              selectedBrightness: selectedBrightness,
              selectedContrast: selectedContrast,
              updateTheme: updateTheme, // Passing the update function
            ),
          ],
        ),
        // ... rest of the body ...
      ),
    );
  }
```

The `AppBar` widget has an `actions` parameter, which is a list of widgets that appear at the end of the app bar (usually on the right). We simply include our `SettingsButton` in this list, and boom! It appears in the app bar. Notice how we pass the current theme settings (`selectedColor`, `selectedBrightness`, `selectedContrast`) and the `updateTheme` function to the `SettingsButton`. This allows the `SettingsButton` to then pass these along to the `Settings` panel.

## Behind the Scenes

When you tap the `SettingsButton`, here's a simplified sequence of events:

```mermaid
sequenceDiagram
    participant User
    participant SB as SettingsButton
    participant Flutter as Flutter Framework
    participant SettingsPanel as Settings (Widget)

    User->SB: Tap the button!
    SB->Flutter: Call showModalBottomSheet()
    Flutter->SettingsPanel: Build and show the Settings widget
    SettingsPanel-->User: Settings panel appears
```

1.  The user taps the icon button in the app bar.
2.  The `onPressed` function inside the `SettingsButton` is executed.
3.  This function calls `showModalBottomSheet`.
4.  `showModalBottomSheet` in the Flutter framework takes the `builder` function provided by `SettingsButton`.
5.  The `builder` function creates and returns the `Settings` widget.
6.  Flutter displays the `Settings` widget as a sliding panel from the bottom of the screen.

The `SettingsButton`'s only job here is to be the trigger that shows the settings panel. It doesn't manage the settings itself; it just opens the door for the user to interact with a different widget ([Settings](03_settings_.md)) that *does* manage the interaction.

## Conclusion

In this chapter, we explored the `SettingsButton`, the simple button in the app bar that acts as a gateway to the settings panel. We saw how it uses `showModalBottomSheet` to display another widget ([Settings](03_settings_.md)) when tapped and how it receives and passes along the necessary information to update the theme.

We now know how to open the door to change our theme settings. In the next chapter, we'll step through that door and explore the [Settings](03_settings_.md) widget itself to understand how it allows users to change the color theme.

Ready to customize? Let's move on!

[Chapter 3: Settings](03_settings_.md)
2025-05-28 16:30:09,243 - INFO - PROMPT: 
Write a very beginner-friendly tutorial chapter (in Markdown format) for the project `flutter` about the concept: "Settings
". This is Chapter 3.

Concept Details:
- Name: Settings

- Description:
This widget provides the user interface for changing the theme settings like brightness, seed color, and contrast level.
Imagine it as a control panel with knobs and switches that allow you to adjust the look and feel of the application's colors. It communicates your desired settings back to the main app. (ColorSchemeExample).


Complete Tutorial Structure:
1. [ColorSchemeExample
](01_colorschemeexample_.md)
2. [SettingsButton
](02_settingsbutton_.md)
3. [Settings
](03_settings_.md)
4. [ColorSchemeVariantColumn
](04_colorschemevariantcolumn_.md)
5. [ColorSchemeView
](05_colorschemeview_.md)
6. [ColorGroup
](06_colorgroup_.md)
7. [ColorChip
](07_colorchip_.md)
8. [ColorSeed
](08_colorseed_.md)

Context from previous chapters:
# Chapter 1: ColorSchemeExample

Welcome, aspiring Flutter developer! In this chapter, we're going to meet the main conductor of our app's visual symphony: `ColorSchemeExample`. Think of this like the main boss or the central hub of our application. It's the widget that gets everything started and keeps track of the overall look and feel, specifically the colors!

## What is ColorSchemeExample?

Imagine you're building a house, and you want to decide on the paint colors, the brightness of the rooms, and how much contrast you want between different elements. The `ColorSchemeExample` is like the architect who holds the master plan for all these color decisions. It decides things like:

*   **What are the main colors of the app?**
*   **Should the app be light or dark?** (Brightness)
*   **How much difference should there be between colors and text?** (Contrast)

And the best part? If you change any of these decisions (like choosing a different main color), the `ColorSchemeExample` knows and makes sure the *whole* house (your app) updates to the new plan.

Our specific use case for this chapter is to see how `ColorSchemeExample` manages the initial color settings of our app.

## How does ColorSchemeExample work?

Let's take a look at the main part of the `ColorSchemeExample` code. Don't worry about understanding every single line right away. We'll break it down.

```dart
void main() => runApp(const ColorSchemeExample());

class ColorSchemeExample extends StatefulWidget {
  const ColorSchemeExample({super.key});

  @override
  State<ColorSchemeExample> createState() => _ColorSchemeExampleState();
}

class _ColorSchemeExampleState extends State<ColorSchemeExample> {
  Color selectedColor = ColorSeed.baseColor.color;
  Brightness selectedBrightness = Brightness.light;
  double selectedContrast = 0.0;
  // ... other code
}
```

This code shows us a couple of key things:

1.  `void main() => runApp(const ColorSchemeExample());`: This is where our app starts! It tells Flutter to run the `ColorSchemeExample` widget.
2.  `ColorSchemeExample extends StatefulWidget`: This means our `ColorSchemeExample` can change over time. If you change the color settings, the widget can rebuild itself to show the new colors.
3.  `_ColorSchemeExampleState`: This is where the `ColorSchemeExample` keeps track of its state, or its current settings. Notice `selectedColor`, `selectedBrightness`, and `selectedContrast`. These are the main color-related decisions it's currently holding.

So, when the app first starts, `ColorSchemeExample` sets up its initial color decisions (like the default primary color, brightness, and contrast).

## Setting up the Theme

The `ColorSchemeExample` also uses these color decisions to set the overall theme of the app. Let's look at the `build` method:

```dart
@override
Widget build(BuildContext context) {
  return MaterialApp(
    debugShowCheckedModeBanner: false,
    theme: ThemeData(
      colorScheme: ColorScheme.fromSeed(
        seedColor: selectedColor,
        brightness: selectedBrightness,
        contrastLevel: selectedContrast,
      ),
    ),
    // ... rest of the build method
  );
}
```

Here's what's happening:

*   `return MaterialApp(...)`: This is the basic structure for a Flutter app. It provides important things like navigation and theming.
*   `theme: ThemeData(...)`: This is where we define the visual theme for our app.
*   `colorScheme: ColorScheme.fromSeed(...)`: This is a super helpful way to create a whole set of colors for your app based on just one "seed" color. `ColorSchemeExample` uses its `selectedColor`, `selectedBrightness`, and `selectedContrast` to generate a complete `ColorScheme`. This `ColorScheme` contains many different color definitions (like primary, secondary, surface, etc.) that are all related to the seed color and brightness.

Essentially, `ColorSchemeExample` takes some basic color decisions and uses them to create a full `ColorScheme` that the rest of the app can use.

## How Changes Happen (Behind the Scenes)

We said `ColorSchemeExample` is like the conductor. When you make a change (like picking a new color from a settings menu, which we'll see in later chapters), here's a simplified look at what happens:

```mermaid
sequenceDiagram
    participant User
    participant CS as ColorSchemeExample
    participant State as _ColorSchemeExampleState
    participant App as MaterialApp

    User->CS: Wants to change color
    CS->State: Calls updateTheme()
    State->State: Updates selectedColor
    State->CS: Signals state changed (setState)
    CS->App: Rebuilds with new theme data
    App-->User: App shows with new colors
```

1.  The user interacts with something (like a button) to change a setting (like the color).
2.  This interaction tells the `ColorSchemeExample` to update.
3.  The `_ColorSchemeExampleState` inside `ColorSchemeExample` updates its stored color settings (`selectedColor`, `selectedBrightness`, etc.).
4.  It then tells Flutter that its state has changed using `setState()`.
5.  Because the state changed, the `ColorSchemeExample` widget (specifically its `build` method) runs again.
6.  In the `build` method, it creates a *new* `ThemeData` with a *new* `ColorScheme.fromSeed` based on the updated settings.
7.  The `MaterialApp` uses this new theme, and the entire app visually updates to reflect the changes.

This is the fundamental way `ColorSchemeExample` manages and updates the color theme of the application. It holds the core settings, uses them to generate a `ColorScheme`, and rebuilds the app when those settings change.

## Conclusion

In this chapter, we introduced `ColorSchemeExample`, the central widget responsible for managing our app's color theme. We saw how it holds the key color settings (seed color, brightness, contrast) and uses them to create a `ColorScheme` that defines the visual look of the application. We also got a glimpse of how it reacts to changes and updates the entire app's appearance.

Now that we understand the main conductor, let's look at how we can interact with it to change those settings. In the next chapter, we'll explore the [SettingsButton](02_settingsbutton_.md), which is how a user can open the options to customize the theme.

Ready to see how we actually change these colors? Let's move on!

[Chapter 2: SettingsButton](02_settingsbutton_.md)
---
# Chapter 2: SettingsButton

Welcome back! In the last chapter, [ColorSchemeExample](01_colorschemeexample_.md), we learned about the main conductor of our app's colors. It's the widget that holds the plan for our app's look and feel. But how do we actually tell that conductor we want to change the plan? That's where the `SettingsButton` comes in!

Imagine our app as a house with the color plan managed by the architect ([ColorSchemeExample](01_colorschemeexample_.md)). The `SettingsButton` is like a special door handle on the app bar that lets us into the room where we can talk to the architect and ask for changes!

## What is SettingsButton?

The `SettingsButton` is simply a button that sits usually at the top right corner of your app screen, in the "app bar". When you tap it, it doesn't change anything visually itself. Its job is to make something *else* appear – in our case, a panel where we can change the color settings.

Think of it as a gateway. Tapping the `SettingsButton` opens the door to the settings area.

Our specific use case is simple: we want a button in our app bar that, when pressed, shows a temporary panel where we can change the color theme.

## How does SettingsButton work?

Let's look at the code for the `SettingsButton`.

```dart
class SettingsButton extends StatelessWidget {
  const SettingsButton({
    super.key,
    required this.updateTheme,
    // ... other required parameters
  });

  final void Function(Brightness, Color, double) updateTheme;

  @override
  Widget build(BuildContext context) {
    return IconButton(
      icon: const Icon(Icons.settings),
      onPressed: () {
        // This is where the magic happens!
        // It shows a small panel at the bottom.
        showModalBottomSheet<void>(
          barrierColor: Colors.transparent,
          context: context,
          builder: (BuildContext context) {
            // We'll talk about this 'Settings' widget in the next chapter!
            return Settings(
              // Pass the current settings and the way to update the theme
              selectedColor: selectedColor,
              selectedBrightness: selectedBrightness,
              selectedContrast: selectedContrast,
              updateTheme: updateTheme,
            );
          },
        );
      },
    );
  }
}
```

Let's break down the important parts:

1.  `class SettingsButton extends StatelessWidget`: This tells us that the `SettingsButton` itself doesn't change its appearance based on internal data. It's a static button, though what happens when you press it can change things elsewhere!
2.  `required this.updateTheme`: Remember how in [ColorSchemeExample](01_colorschemeexample_.md) we talked about the `updateTheme` function that actually changes the color settings? The `SettingsButton` needs to *know* about this function so it can pass it along to the settings panel.
3.  `@override Widget build(BuildContext context)`: This is where the `SettingsButton` creates its appearance.
4.  `return IconButton(...)`: This is a common Flutter widget for a button that's just an icon. It's perfect for our settings icon!
5.  `icon: const Icon(Icons.settings)`: This gives the `IconButton` the familiar gear icon used for settings.
6.  `onPressed: () { ... }`: This is the crucial part! This defines what happens *when the button is tapped*.
7.  `showModalBottomSheet<void>(...)`: This is a Flutter function that displays a temporary panel that slides up from the bottom of the screen. This is exactly what we want for our settings panel!
8.  `builder: (BuildContext context) { ... return Settings(...) }`: This part tells `showModalBottomSheet` *what* to show inside the panel. It's showing a widget called `Settings`. We'll dive deeper into this `Settings` widget in the next chapter, [Settings](03_settings_.md).

So, when you tap the `SettingsButton`, it calls `showModalBottomSheet`, which then builds and displays the `Settings` widget at the bottom of the screen. The `SettingsButton` also passes the `updateTheme` function and the *current* theme settings to the `Settings` widget so it knows what the theme is now and how to change it.

## Where does the SettingsButton live?

The `SettingsButton` is placed within the app bar of our main screen ([ColorSchemeExample](01_colorschemeexample_.md)). Look at this small snippet from the `ColorSchemeExample`'s `build` method:

```dart
  @override
  Widget build(BuildContext context) {
    return MaterialApp(
      // ... theme setup ...
      home: Scaffold(
        appBar: AppBar(
          title: const Text('ColorScheme'),
          actions: <Widget>[
            // Here it is!
            SettingsButton(
              selectedColor: selectedColor,
              selectedBrightness: selectedBrightness,
              selectedContrast: selectedContrast,
              updateTheme: updateTheme, // Passing the update function
            ),
          ],
        ),
        // ... rest of the body ...
      ),
    );
  }
```

The `AppBar` widget has an `actions` parameter, which is a list of widgets that appear at the end of the app bar (usually on the right). We simply include our `SettingsButton` in this list, and boom! It appears in the app bar. Notice how we pass the current theme settings (`selectedColor`, `selectedBrightness`, `selectedContrast`) and the `updateTheme` function to the `SettingsButton`. This allows the `SettingsButton` to then pass these along to the `Settings` panel.

## Behind the Scenes

When you tap the `SettingsButton`, here's a simplified sequence of events:

```mermaid
sequenceDiagram
    participant User
    participant SB as SettingsButton
    participant Flutter as Flutter Framework
    participant SettingsPanel as Settings (Widget)

    User->SB: Tap the button!
    SB->Flutter: Call showModalBottomSheet()
    Flutter->SettingsPanel: Build and show the Settings widget
    SettingsPanel-->User: Settings panel appears
```

1.  The user taps the icon button in the app bar.
2.  The `onPressed` function inside the `SettingsButton` is executed.
3.  This function calls `showModalBottomSheet`.
4.  `showModalBottomSheet` in the Flutter framework takes the `builder` function provided by `SettingsButton`.
5.  The `builder` function creates and returns the `Settings` widget.
6.  Flutter displays the `Settings` widget as a sliding panel from the bottom of the screen.

The `SettingsButton`'s only job here is to be the trigger that shows the settings panel. It doesn't manage the settings itself; it just opens the door for the user to interact with a different widget ([Settings](03_settings_.md)) that *does* manage the interaction.

## Conclusion

In this chapter, we explored the `SettingsButton`, the simple button in the app bar that acts as a gateway to the settings panel. We saw how it uses `showModalBottomSheet` to display another widget ([Settings](03_settings_.md)) when tapped and how it receives and passes along the necessary information to update the theme.

We now know how to open the door to change our theme settings. In the next chapter, we'll step through that door and explore the [Settings](03_settings_.md) widget itself to understand how it allows users to change the color theme.

Ready to customize? Let's move on!

[Chapter 3: Settings](03_settings_.md)

Relevant Code Snippets (Code itself remains unchanged):
--- File: color_scheme.0.dart ---
// Copyright 2014 The Flutter Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

import 'package:flutter/material.dart';

/// Flutter code sample for [ColorScheme].

const Widget divider = SizedBox(height: 10);

void main() => runApp(const ColorSchemeExample());

class ColorSchemeExample extends StatefulWidget {
  const ColorSchemeExample({super.key});

  @override
  State<ColorSchemeExample> createState() => _ColorSchemeExampleState();
}

class _ColorSchemeExampleState extends State<ColorSchemeExample> {
  Color selectedColor = ColorSeed.baseColor.color;
  Brightness selectedBrightness = Brightness.light;
  double selectedContrast = 0.0;
  static const List<DynamicSchemeVariant> schemeVariants = DynamicSchemeVariant.values;

  void updateTheme(Brightness brightness, Color color, double contrastLevel) {
    setState(() {
      selectedBrightness = brightness;
      selectedColor = color;
      selectedContrast = contrastLevel;
    });
  }

  @override
  Widget build(BuildContext context) {
    return MaterialApp(
      debugShowCheckedModeBanner: false,
      theme: ThemeData(
        colorScheme: ColorScheme.fromSeed(
          seedColor: selectedColor,
          brightness: selectedBrightness,
          contrastLevel: selectedContrast,
        ),
      ),
      home: Scaffold(
        appBar: AppBar(
          title: const Text('ColorScheme'),
          actions: <Widget>[
            SettingsButton(
              selectedColor: selectedColor,
              selectedBrightness: selectedBrightness,
              selectedContrast: selectedContrast,
              updateTheme: updateTheme,
            ),
          ],
        ),
        body: SingleChildScrollView(
          child: Padding(
            padding: const EdgeInsets.only(top: 5),
            child: Column(
              crossAxisAlignment: CrossAxisAlignment.start,
              children: <Widget>[
                SingleChildScrollView(
                  scrollDirection: Axis.horizontal,
                  child: Row(
                    children:
                        List<Widget>.generate(schemeVariants.length, (int index) {
                          return ColorSchemeVariantColumn(
                            selectedColor: selectedColor,
                            brightness: selectedBrightness,
                            schemeVariant: schemeVariants[index],
                            contrastLevel: selectedContrast,
                          );
                        }).toList(),
                  ),
                ),
              ],
            ),
          ),
        ),
      ),
    );
  }
}

class Settings extends StatefulWidget {
  const Settings({
    super.key,
    required this.updateTheme,
    required this.selectedBrightness,
    required this.selectedContrast,
    required this.selectedColor,
  });

  final Brightness selectedBrightness;
  final double selectedContrast;
  final Color selectedColor;

  final void Function(Brightness, Color, double) updateTheme;

  @override
  State<Settings> createState() => _SettingsState();
}

class _SettingsState extends State<Settings> {
  late Brightness selectedBrightness = widget.selectedBrightness;
  late Color selectedColor = widget.selectedColor;
  late double selectedContrast = widget.selectedContrast;

  @override
  Widget build(BuildContext context) {
    return Theme(
      data: Theme.of(context).copyWith(
        colorScheme: ColorScheme.fromSeed(
          seedColor: selectedColor,
          contrastLevel: selectedContrast,
          brightness: selectedBrightness,
        ),
      ),
      child: ConstrainedBox(
        constraints: const BoxConstraints(maxHeight: 200),
        child: Padding(
          padding: const EdgeInsets.all(20.0),
          child: ListView(
            children: <Widget>[
              Center(child: Text('Settings', style: Theme.of(context).textTheme.titleLarge)),
              Row(
                children: <Widget>[
                  const Text('Brightness: '),
                  Switch(
                    value: selectedBrightness == Brightness.light,
                    onChanged: (bool value) {
                      setState(() {
                        selectedBrightness = value ? Brightness.light : Brightness.dark;
                      });
                      widget.updateTheme(selectedBrightness, selectedColor, selectedContrast);
                    },
                  ),
                ],
              ),
              Wrap(
                crossAxisAlignment: WrapCrossAlignment.center,
                children: <Widget>[
                  const Text('Seed color: '),
                  ...List<Widget>.generate(ColorSeed.values.length, (int index) {
                    final Color itemColor = ColorSeed.values[index].color;
                    return IconButton(
                      icon:
                          selectedColor == ColorSeed.values[index].color
                              ? Icon(Icons.circle, color: itemColor)
                              : Icon(Icons.circle_outlined, color: itemColor),
                      onPressed: () {
                        setState(() {
                          selectedColor = itemColor;
                        });
                        widget.updateTheme(selectedBrightness, selectedColor, selectedContrast);
                      },
                    );
                  }),
                ],
              ),
              Row(
                children: <Widget>[
                  const Text('Contrast level: '),
                  Expanded(
                    child: Slider(
                      divisions: 4,
                      label: selectedContrast.toString(),
                      min: -1,
                      value: selectedContrast,
                      onChanged: (double value) {
                        setState(() {
                          selectedContrast = value;
                        });
                        widget.updateTheme(selectedBrightness, selectedColor, selectedContrast);
                      },
                    ),
                  ),
                ],
              ),
            ],
          ),
        ),
      ),
    );
  }
}

class ColorSchemeVariantColumn extends StatelessWidget {
  const ColorSchemeVariantColumn({
    super.key,
    this.schemeVariant = DynamicSchemeVariant.tonalSpot,
    this.brightness = Brightness.light,
    this.contrastLevel = 0.0,
    required this.selectedColor,
  });

  final DynamicSchemeVariant schemeVariant;
  final Brightness brightness;
  final double contrastLevel;
  final Color selectedColor;

  @override
  Widget build(BuildContext context) {
    return ConstrainedBox(
      constraints: const BoxConstraints.tightFor(width: 250),
      child: Column(
        children: <Widget>[
          Padding(
            padding: const EdgeInsets.symmetric(vertical: 15),
            child: Text(
              schemeVariant.name == 'tonalSpot'
                  ? '${schemeVariant.name} (Default)'
                  : schemeVariant.name,
              style: const TextStyle(fontWeight: FontWeight.bold),
            ),
          ),
          Padding(
            padding: const EdgeInsets.symmetric(horizontal: 15),
            child: ColorSchemeView(
              colorScheme: ColorScheme.fromSeed(
                seedColor: selectedColor,
                brightness: brightness,
                contrastLevel: contrastLevel,
                dynamicSchemeVariant: schemeVariant,
              ),
            ),
          ),
        ],
      ),
    );
  }
}

class ColorSchemeView extends StatelessWidget {
  const ColorSchemeView({super.key, required this.colorScheme});

  final ColorScheme colorScheme;

  @override
  Widget build(BuildContext context) {
    return Column(
      children: <Widget>[
        ColorGroup(
          children: <ColorChip>[
            ColorChip('primary', colorScheme.primary, colorScheme.onPrimary),
            ColorChip('onPrimary', colorScheme.onPrimary, colorScheme.primary),
            ColorChip(
              'primaryContainer',
              colorScheme.primaryContainer,
              colorScheme.onPrimaryContainer,
            ),
            ColorChip(
              'onPrimaryContainer',
              colorScheme.onPrimaryContainer,
              colorScheme.primaryContainer,
            ),
          ],
        ),
        divider,
        ColorGroup(
          children: <ColorChip>[
            ColorChip('primaryFixed', colorScheme.primaryFixed, colorScheme.onPrimaryFixed),
            ColorChip('onPrimaryFixed', colorScheme.onPrimaryFixed, colorScheme.primaryFixed),
            ColorChip(
              'primaryFixedDim',
              colorScheme.primaryFixedDim,
              colorScheme.onPrimaryFixedVariant,
            ),
            ColorChip(
              'onPrimaryFixedVariant',
              colorScheme.onPrimaryFixedVariant,
              colorScheme.primaryFixedDim,
            ),
          ],
        ),
        divider,
        ColorGroup(
          children: <ColorChip>[
            ColorChip('secondary', colorScheme.secondary, colorScheme.onSecondary),
            ColorChip('onSecondary', colorScheme.onSecondary, colorScheme.secondary),
            ColorChip(
              'secondaryContainer',
              colorScheme.secondaryContainer,
              colorScheme.onSecondaryContainer,
            ),
            ColorChip(
              'onSecondaryContainer',
              colorScheme.onSecondaryContainer,
              colorScheme.secondaryContainer,
            ),
          ],
        ),
        divider,
        ColorGroup(
          children: <ColorChip>[
            ColorChip('secondaryFixed', colorScheme.secondaryFixed, colorScheme.onSecondaryFixed),
            ColorChip('onSecondaryFixed', colorScheme.onSecondaryFixed, colorScheme.secondaryFixed),
            ColorChip(
              'secondaryFixedDim',
              colorScheme.secondaryFixedDim,
              colorScheme.onSecondaryFixedVariant,
            ),
            ColorChip(
              'onSecondaryFixedVariant',
              colorScheme.onSecondaryFixedVariant,
              colorScheme.secondaryFixedDim,
            ),
          ],
        ),
        divider,
        ColorGroup(
          children: <ColorChip>[
            ColorChip('tertiary', colorScheme.tertiary, colorScheme.onTertiary),
            ColorChip('onTertiary', colorScheme.onTertiary, colorScheme.tertiary),
            ColorChip(
              'tertiaryContainer',
              colorScheme.tertiaryContainer,
              colorScheme.onTertiaryContainer,
            ),
            ColorChip(
              'onTertiaryContainer',
              colorScheme.onTertiaryContainer,
              colorScheme.tertiaryContainer,
            ),
          ],
        ),
        divider,
        ColorGroup(
          children: <ColorChip>[
            ColorChip('tertiaryFixed', colorScheme.tertiaryFixed, colorScheme.onTertiaryFixed),
            ColorChip('onTertiaryFixed', colorScheme.onTertiaryFixed, colorScheme.tertiaryFixed),
            ColorChip(
              'tertiaryFixedDim',
              colorScheme.tertiaryFixedDim,
              colorScheme.onTertiaryFixedVariant,
            ),
            ColorChip(
              'onTertiaryFixedVariant',
              colorScheme.onTertiaryFixedVariant,
              colorScheme.tertiaryFixedDim,
            ),
          ],
        ),
        divider,
        ColorGroup(
          children: <ColorChip>[
            ColorChip('error', colorScheme.error, colorScheme.onError),
            ColorChip('onError', colorScheme.onError, colorScheme.error),
            ColorChip('errorContainer', colorScheme.errorContainer, colorScheme.onErrorContainer),
            ColorChip('onErrorContainer', colorScheme.onErrorContainer, colorScheme.errorContainer),
          ],
        ),
        divider,
        ColorGroup(
          children: <ColorChip>[
            ColorChip('surfaceDim', colorScheme.surfaceDim, colorScheme.onSurface),
            ColorChip('surface', colorScheme.surface, colorScheme.onSurface),
            ColorChip('surfaceBright', colorScheme.surfaceBright, colorScheme.onSurface),
            ColorChip(
              'surfaceContainerLowest',
              colorScheme.surfaceContainerLowest,
              colorScheme.onSurface,
            ),
            ColorChip(
              'surfaceContainerLow',
              colorScheme.surfaceContainerLow,
              colorScheme.onSurface,
            ),
            ColorChip('surfaceContainer', colorScheme.surfaceContainer, colorScheme.onSurface),
            ColorChip(
              'surfaceContainerHigh',
              colorScheme.surfaceContainerHigh,
              colorScheme.onSurface,
            ),
            ColorChip(
              'surfaceContainerHighest',
              colorScheme.surfaceContainerHighest,
              colorScheme.onSurface,
            ),
            ColorChip('onSurface', colorScheme.onSurface, colorScheme.surface),
            ColorChip(
              'onSurfaceVariant',
              colorScheme.onSurfaceVariant,
              colorScheme.surfaceContainerHighest,
            ),
          ],
        ),
        divider,
        ColorGroup(
          children: <ColorChip>[
            ColorChip('outline', colorScheme.outline, null),
            ColorChip('shadow', colorScheme.shadow, null),
            ColorChip('inverseSurface', colorScheme.inverseSurface, colorScheme.onInverseSurface),
            ColorChip('onInverseSurface', colorScheme.onInverseSurface, colorScheme.inverseSurface),
            ColorChip('inversePrimary', colorScheme.inversePrimary, colorScheme.primary),
          ],
        ),
      ],
    );
  }
}

class ColorGroup extends StatelessWidget {
  const ColorGroup({super.key, required this.children});

  final List<Widget> children;

  @override
  Widget build(BuildContext context) {
    return RepaintBoundary(
      child: Card(clipBehavior: Clip.antiAlias, child: Column(children: children)),
    );
  }
}

class ColorChip extends StatelessWidget {
  const ColorChip(this.label, this.color, this.onColor, {super.key});

  final Color color;
  final Color? onColor;
  final String label;

  static Color contrastColor(Color color) {
    final Brightness brightness = ThemeData.estimateBrightnessForColor(color);
    return brightness == Brightness.dark ? Colors.white : Colors.black;
  }

  @override
  Widget build(BuildContext context) {
    final Color labelColor = onColor ?? contrastColor(color);
    return ColoredBox(
      color: color,
      child: Padding(
        padding: const EdgeInsets.all(16),
        child: Row(
          children: <Expanded>[Expanded(child: Text(label, style: TextStyle(color: labelColor)))],
        ),
      ),
    );
  }
}

enum ColorSeed {
  baseColor('M3 Baseline', Color(0xff6750a4)),
  indigo('Indigo', Colors.indigo),
  blue('Blue', Colors.blue),
  teal('Teal', Colors.teal),
  green('Green', Colors.green),
  yellow('Yellow', Colors.yellow),
  orange('Orange', Colors.orange),
  deepOrange('Deep Orange', Colors.deepOrange),
  pink('Pink', Colors.pink),
  brightBlue('Bright Blue', Color(0xFF0000FF)),
  brightGreen('Bright Green', Color(0xFF00FF00)),
  brightRed('Bright Red', Color(0xFFFF0000));

  const ColorSeed(this.label, this.color);
  final String label;
  final Color color;
}

class SettingsButton extends StatelessWidget {
  const SettingsButton({
    super.key,
    required this.updateTheme,
    required this.selectedBrightness,
    required this.selectedContrast,
    required this.selectedColor,
  });

  final Brightness selectedBrightness;
  final double selectedContrast;
  final Color selectedColor;

  final void Function(Brightness, Color, double) updateTheme;

  @override
  Widget build(BuildContext context) {
    return IconButton(
      icon: const Icon(Icons.settings),
      onPressed: () {
        showModalBottomSheet<void>(
          barrierColor: Colors.transparent,
          context: context,
          builder: (BuildContext context) {
            return Settings(
              selectedColor: selectedColor,
              selectedBrightness: selectedBrightness,
              selectedContrast: selectedContrast,
              updateTheme: updateTheme,
            );
          },
        );
      },
    );
  }
}


Instructions for the chapter (Generate content in English unless specified otherwise):
- Start with a clear heading (e.g., `# Chapter 3: Settings
`). Use the provided concept name.

- If this is not the first chapter, begin with a brief transition from the previous chapter, referencing it with a proper Markdown link using its name.

- Begin with a high-level motivation explaining what problem this abstraction solves. Start with a central use case as a concrete example. The whole chapter should guide the reader to understand how to solve this use case. Make it very minimal and friendly to beginners.

- If the abstraction is complex, break it down into key concepts. Explain each concept one-by-one in a very beginner-friendly way.

- Explain how to use this abstraction to solve the use case. Give example inputs and outputs for code snippets (if the output isn't values, describe at a high level what will happen).

- Each code block should be BELOW 10 lines! If longer code blocks are needed, break them down into smaller pieces and walk through them one-by-one. Aggresively simplify the code to make it minimal. Use comments to skip non-important implementation details. Each code block should have a beginner friendly explanation right after it.

- Describe the internal implementation to help understand what's under the hood. First provide a non-code or code-light walkthrough on what happens step-by-step when the abstraction is called. It's recommended to use a simple sequenceDiagram with a dummy example - keep it minimal with at most 5 participants to ensure clarity. If participant name has space, use: `participant QP as Query Processing`. .

- Then dive deeper into code for the internal implementation with references to files. Provide example code blocks, but make them similarly simple and beginner-friendly. Explain.

- IMPORTANT: When you need to refer to other core abstractions covered in other chapters, ALWAYS use proper Markdown links like this: [Chapter Title](filename.md). Use the Complete Tutorial Structure above to find the correct filename and the chapter title. Translate the surrounding text.

- Use mermaid diagrams to illustrate complex concepts (```mermaid``` format). .

- Heavily use analogies and examples throughout to help beginners understand.

- End the chapter with a brief conclusion that summarizes what was learned and provides a transition to the next chapter. If there is a next chapter, use a proper Markdown link: [Next Chapter Title](next_chapter_filename).

- Ensure the tone is welcoming and easy for a newcomer to understand.

- Output *only* the Markdown content for this chapter.

Now, directly provide a super beginner-friendly Markdown output (DON'T need ```markdown``` tags):

2025-05-28 16:30:26,195 - INFO - RESPONSE: # Chapter 3: Settings

Welcome back, future Flutter expert! In our last chapter, [SettingsButton](02_settingsbutton_.md), we learned how to add a special button to our app's app bar. This button acts like a secret door, and when we tap it, it opens up a place where we can fine-tune the look of our app. Today, we're going to step through that door and meet the widget that lives there: the `Settings` widget!

## What is the Settings Widget?

Imagine you're sitting in the control room of a spaceship, and you have different dials and switches to adjust the lighting, the view out the window, and other cool things. The `Settings` widget is like that control panel for our app's color theme!

Its main job is to provide a user interface – a bunch of visual controls – that let you change:

*   **Brightness:** Do you want the app to be light or dark?
*   **Seed Color:** What primary color should all other colors in the app be based on?
*   **Contrast Level:** How much difference should there be between colors and text?

And the most important part? When you adjust one of these controls, the `Settings` widget talks back to the main part of our app ([ColorSchemeExample](01_colorschemeexample_.md)) and tells it, "Hey, the user wants to change the theme! Here are the new settings!"

Our specific use case is to build a panel that shows options for brightness, seed color, and contrast, and allows the user to interact with these options to change the app's theme.

## How does the Settings Widget work?

The `Settings` widget is the brain behind the settings panel that slides up from the bottom. It needs to:

1.  **Show the current settings:** When you open the panel, it should show what the current brightness, seed color, and contrast are.
2.  **Allow the user to change settings:** Provide controls (like switches, buttons, and sliders) to change the values.
3.  **Tell the main app about changes:** When a user changes a setting, it needs to communicate these changes back to [ColorSchemeExample](01_colorschemeexample_.md).

Let's look at the code for the `Settings` widget and see how it does this (from `color_scheme.0.dart`):

```dart
class Settings extends StatefulWidget {
  const Settings({
    super.key,
    required this.updateTheme,
    required this.selectedBrightness,
    required this.selectedContrast,
    required this.selectedColor,
  });

  final Brightness selectedBrightness;
  final double selectedContrast;
  final Color selectedColor;

  final void Function(Brightness, Color, double) updateTheme;

  @override
  State<Settings> createState() => _SettingsState();
}
```

*   `class Settings extends StatefulWidget`: Like [ColorSchemeExample](01_colorschemeexample_.md), `Settings` is also a `StatefulWidget`. This is because the settings panel itself needs to *remember* the values you've selected *while the panel is open*. For example, if you flip the light/dark switch, the switch itself needs to visually change its state.
*   `required this.updateTheme`, `selectedBrightness`, `selectedContrast`, `selectedColor`: These are the things that the `SettingsButton` *passes* into the `Settings` widget. Remember how the `SettingsButton` knew the current theme settings and the function to update the theme? It gives all that information to `Settings` when it opens the panel. `updateTheme` is a special function that the `Settings` widget will call to tell [ColorSchemeExample](01_colorschemeexample_.md) about the changes.

Now let's peek inside the `_SettingsState` where the actual controls are built:

```dart
class _SettingsState extends State<Settings> {
  late Brightness selectedBrightness = widget.selectedBrightness;
  late Color selectedColor = widget.selectedColor;
  late double selectedContrast = widget.selectedContrast;

  @override
  Widget build(BuildContext context) {
    return Theme(
      data: Theme.of(context).copyWith(
        // This briefly changes the theme *for the settings panel itself*
        colorScheme: ColorScheme.fromSeed(
          seedColor: selectedColor,
          contrastLevel: selectedContrast,
          brightness: selectedBrightness,
        ),
      ),
      child: ConstrainedBox(
        // ... more layout code ...
        child: Padding(
          // ... padding code ...
          child: ListView(
            children: <Widget>[
              // ... Title ...
              Row(
                children: <Widget>[
                  const Text('Brightness: '),
                  Switch(
                    value: selectedBrightness == Brightness.light,
                    onChanged: (bool value) {
                      setState(() {
                        selectedBrightness = value ? Brightness.light : Brightness.dark;
                      });
                      widget.updateTheme(selectedBrightness, selectedColor, selectedContrast); // <-- Tell the main app!
                    },
                  ),
                ],
              ),
              // ... More controls for ColorSeed and ContrastLevel ...
            ],
          ),
        ),
      ),
    );
  }
}
```

*   `late Brightness selectedBrightness = widget.selectedBrightness;`: When the `Settings` widget is created, it takes the initial brightness, color, and contrast that were passed from the `SettingsButton` and stores them in its own internal state variables. These are the values that the controls on the panel will show and modify *locally*.
*   `return Theme(...)`: This is a neat trick! It temporarily applies a theme *only* to the widgets inside this `Theme` widget. This means the settings panel itself will use the color scheme based on the *currently selected* settings, which is helpful for previewing colors within the panel.
*   `ListView`: We use a `ListView` to arrange our controls vertically. If there are many settings, this allows the user to scroll.
*   `Row(...)`: Each row in the `ListView` holds one setting control (like Brightness, Seed color, or Contrast).
*   `Switch(...)`: For the brightness setting, we use a `Switch`. When you flip the switch, the `onChanged` function is called.
*   `setState(() { ... });`: Inside `onChanged`, we first use `setState`. This updates the `selectedBrightness` variable within the `_SettingsState`. Because we used `setState`, Flutter knows that the UI for this widget needs to be re-drawn. This is why the switch visually flips!
*   `widget.updateTheme(...)`: **This is the most important line!** After updating its own internal state (`selectedBrightness`), the `Settings` widget calls the `updateTheme` function that was passed to it. It sends the *new* values for brightness, color, and contrast to this function. This function lives back in [ColorSchemeExample](01_colorschemeexample_.md), and calling it tells the main app, "Okay, the user made a change, update the whole app's theme!"

The code for the `ColorSeed` selection uses `Wrap` and `IconButton` instead of a `Switch`, and the `Contrast Level` uses a `Row` and a `Slider`, but they all follow the same pattern:

1.  Listen for a change in the control (`onPressed` for buttons, `onChanged` for slider/switch).
2.  Update the local state variable (`selectedColor` or `selectedContrast`) using `setState`.
3.  Call `widget.updateTheme` with the *latest* values of `selectedBrightness`, `selectedColor`, and `selectedContrast` to update the main app theme.

## How Changes Flow

Let's visualize the journey of a change when you interact with the `Settings` widget:

```mermaid
sequenceDiagram
    participant User
    participant SP as Settings Panel (Settings Widget)
    participant SettingsState as _SettingsState
    participant CS as ColorSchemeExample

    User->SP: Flips Brightness Switch
    SP->SettingsState: Calls onChanged
    SettingsState->SettingsState: Updates local selectedBrightness
    SettingsState->SettingsState: Calls setState() (Panel redraws)
    SettingsState->CS: Calls widget.updateTheme(new settings)
    CS->CS: Calls updateTheme()
    CS->CS: Updates internal theme settings
    CS->CS: Calls setState() (Main app redraws)
    CS-->User: Main app shows with new brightness
```

1.  The user flips the switch, taps a color circle, or moves the slider on the `Settings` panel.
2.  The corresponding `onChanged` or `onPressed` function is triggered inside the `_SettingsState`.
3.  The local state variable (like `selectedBrightness`) is updated within the `_SettingsState`.
4.  `setState()` is called, causing the `Settings` widget itself to rebuild and show the visual change (like the switch flipping or the color icon changing).
5.  Critically, `widget.updateTheme()` is called, passing the new settings values to the `updateTheme` function that [ColorSchemeExample](01_colorschemeexample_.md) provided.
6.  The `updateTheme` function inside [ColorSchemeExample](01_colorschemeexample_.md) is executed.
7.  [ColorSchemeExample](01_colorschemeexample_.md) updates its own internal theme settings (`selectedBrightness`, `selectedColor`, `selectedContrast`).
8.  [ColorSchemeExample](01_colorschemeexample_.md) calls its *own* `setState()`.
9.  Because [ColorSchemeExample](01_colorschemeexample_.md) is the main widget controlling the app's theme, the entire app rebuilds using the new `ThemeData` and `ColorScheme`.
10. The user sees the app's theme instantly change!

The `Settings` widget is like a temporary control panel. It manages the user's interaction and then passes the final desired settings back to the main `ColorSchemeExample` to apply the changes everywhere.

## Conclusion

In this chapter, we explored the `Settings` widget, the interactive panel that lets users customize the app's color theme. We saw how it takes the current settings and the `updateTheme` function from the [SettingsButton](02_settingsbutton_.md), provides controls like switches, icon buttons, and a slider, and uses `setState` to manage its own appearance while calling `widget.updateTheme` to communicate changes back to [ColorSchemeExample](01_colorschemeexample_.md).

We now understand how to open the settings and interact with them to request changes. In the next chapter, [ColorSchemeVariantColumn](04_colorschemevariantcolumn_.md), we'll start looking at how those chosen settings translate into the actual different colors that make up our theme and how they are displayed in columns on the main screen.

Ready to see the colors generated? Let's move on!

[Chapter 4: ColorSchemeVariantColumn](04_colorschemevariantcolumn_.md)
2025-05-28 16:30:26,199 - INFO - PROMPT: 
Write a very beginner-friendly tutorial chapter (in Markdown format) for the project `flutter` about the concept: "ColorSchemeVariantColumn
". This is Chapter 4.

Concept Details:
- Name: ColorSchemeVariantColumn

- Description:
This widget displays a specific variant of a `ColorScheme` based on the selected settings.
Consider it a display case for different color palettes. Each column shows you how the app would look with a particular color scheme variation applied, using the currently selected seed color, brightness, and contrast.


Complete Tutorial Structure:
1. [ColorSchemeExample
](01_colorschemeexample_.md)
2. [SettingsButton
](02_settingsbutton_.md)
3. [Settings
](03_settings_.md)
4. [ColorSchemeVariantColumn
](04_colorschemevariantcolumn_.md)
5. [ColorSchemeView
](05_colorschemeview_.md)
6. [ColorGroup
](06_colorgroup_.md)
7. [ColorChip
](07_colorchip_.md)
8. [ColorSeed
](08_colorseed_.md)

Context from previous chapters:
# Chapter 1: ColorSchemeExample

Welcome, aspiring Flutter developer! In this chapter, we're going to meet the main conductor of our app's visual symphony: `ColorSchemeExample`. Think of this like the main boss or the central hub of our application. It's the widget that gets everything started and keeps track of the overall look and feel, specifically the colors!

## What is ColorSchemeExample?

Imagine you're building a house, and you want to decide on the paint colors, the brightness of the rooms, and how much contrast you want between different elements. The `ColorSchemeExample` is like the architect who holds the master plan for all these color decisions. It decides things like:

*   **What are the main colors of the app?**
*   **Should the app be light or dark?** (Brightness)
*   **How much difference should there be between colors and text?** (Contrast)

And the best part? If you change any of these decisions (like choosing a different main color), the `ColorSchemeExample` knows and makes sure the *whole* house (your app) updates to the new plan.

Our specific use case for this chapter is to see how `ColorSchemeExample` manages the initial color settings of our app.

## How does ColorSchemeExample work?

Let's take a look at the main part of the `ColorSchemeExample` code. Don't worry about understanding every single line right away. We'll break it down.

```dart
void main() => runApp(const ColorSchemeExample());

class ColorSchemeExample extends StatefulWidget {
  const ColorSchemeExample({super.key});

  @override
  State<ColorSchemeExample> createState() => _ColorSchemeExampleState();
}

class _ColorSchemeExampleState extends State<ColorSchemeExample> {
  Color selectedColor = ColorSeed.baseColor.color;
  Brightness selectedBrightness = Brightness.light;
  double selectedContrast = 0.0;
  // ... other code
}
```

This code shows us a couple of key things:

1.  `void main() => runApp(const ColorSchemeExample());`: This is where our app starts! It tells Flutter to run the `ColorSchemeExample` widget.
2.  `ColorSchemeExample extends StatefulWidget`: This means our `ColorSchemeExample` can change over time. If you change the color settings, the widget can rebuild itself to show the new colors.
3.  `_ColorSchemeExampleState`: This is where the `ColorSchemeExample` keeps track of its state, or its current settings. Notice `selectedColor`, `selectedBrightness`, and `selectedContrast`. These are the main color-related decisions it's currently holding.

So, when the app first starts, `ColorSchemeExample` sets up its initial color decisions (like the default primary color, brightness, and contrast).

## Setting up the Theme

The `ColorSchemeExample` also uses these color decisions to set the overall theme of the app. Let's look at the `build` method:

```dart
@override
Widget build(BuildContext context) {
  return MaterialApp(
    debugShowCheckedModeBanner: false,
    theme: ThemeData(
      colorScheme: ColorScheme.fromSeed(
        seedColor: selectedColor,
        brightness: selectedBrightness,
        contrastLevel: selectedContrast,
      ),
    ),
    // ... rest of the build method
  );
}
```

Here's what's happening:

*   `return MaterialApp(...)`: This is the basic structure for a Flutter app. It provides important things like navigation and theming.
*   `theme: ThemeData(...)`: This is where we define the visual theme for our app.
*   `colorScheme: ColorScheme.fromSeed(...)`: This is a super helpful way to create a whole set of colors for your app based on just one "seed" color. `ColorSchemeExample` uses its `selectedColor`, `selectedBrightness`, and `selectedContrast` to generate a complete `ColorScheme`. This `ColorScheme` contains many different color definitions (like primary, secondary, surface, etc.) that are all related to the seed color and brightness.

Essentially, `ColorSchemeExample` takes some basic color decisions and uses them to create a full `ColorScheme` that the rest of the app can use.

## How Changes Happen (Behind the Scenes)

We said `ColorSchemeExample` is like the conductor. When you make a change (like picking a new color from a settings menu, which we'll see in later chapters), here's a simplified look at what happens:

```mermaid
sequenceDiagram
    participant User
    participant CS as ColorSchemeExample
    participant State as _ColorSchemeExampleState
    participant App as MaterialApp

    User->CS: Wants to change color
    CS->State: Calls updateTheme()
    State->State: Updates selectedColor
    State->CS: Signals state changed (setState)
    CS->App: Rebuilds with new theme data
    App-->User: App shows with new colors
```

1.  The user interacts with something (like a button) to change a setting (like the color).
2.  This interaction tells the `ColorSchemeExample` to update.
3.  The `_ColorSchemeExampleState` inside `ColorSchemeExample` updates its stored color settings (`selectedColor`, `selectedBrightness`, etc.).
4.  It then tells Flutter that its state has changed using `setState()`.
5.  Because the state changed, the `ColorSchemeExample` widget (specifically its `build` method) runs again.
6.  In the `build` method, it creates a *new* `ThemeData` with a *new* `ColorScheme.fromSeed` based on the updated settings.
7.  The `MaterialApp` uses this new theme, and the entire app visually updates to reflect the changes.

This is the fundamental way `ColorSchemeExample` manages and updates the color theme of the application. It holds the core settings, uses them to generate a `ColorScheme`, and rebuilds the app when those settings change.

## Conclusion

In this chapter, we introduced `ColorSchemeExample`, the central widget responsible for managing our app's color theme. We saw how it holds the key color settings (seed color, brightness, contrast) and uses them to create a `ColorScheme` that defines the visual look of the application. We also got a glimpse of how it reacts to changes and updates the entire app's appearance.

Now that we understand the main conductor, let's look at how we can interact with it to change those settings. In the next chapter, we'll explore the [SettingsButton](02_settingsbutton_.md), which is how a user can open the options to customize the theme.

Ready to see how we actually change these colors? Let's move on!

[Chapter 2: SettingsButton](02_settingsbutton_.md)
---
# Chapter 2: SettingsButton

Welcome back! In the last chapter, [ColorSchemeExample](01_colorschemeexample_.md), we learned about the main conductor of our app's colors. It's the widget that holds the plan for our app's look and feel. But how do we actually tell that conductor we want to change the plan? That's where the `SettingsButton` comes in!

Imagine our app as a house with the color plan managed by the architect ([ColorSchemeExample](01_colorschemeexample_.md)). The `SettingsButton` is like a special door handle on the app bar that lets us into the room where we can talk to the architect and ask for changes!

## What is SettingsButton?

The `SettingsButton` is simply a button that sits usually at the top right corner of your app screen, in the "app bar". When you tap it, it doesn't change anything visually itself. Its job is to make something *else* appear – in our case, a panel where we can change the color settings.

Think of it as a gateway. Tapping the `SettingsButton` opens the door to the settings area.

Our specific use case is simple: we want a button in our app bar that, when pressed, shows a temporary panel where we can change the color theme.

## How does SettingsButton work?

Let's look at the code for the `SettingsButton`.

```dart
class SettingsButton extends StatelessWidget {
  const SettingsButton({
    super.key,
    required this.updateTheme,
    // ... other required parameters
  });

  final void Function(Brightness, Color, double) updateTheme;

  @override
  Widget build(BuildContext context) {
    return IconButton(
      icon: const Icon(Icons.settings),
      onPressed: () {
        // This is where the magic happens!
        // It shows a small panel at the bottom.
        showModalBottomSheet<void>(
          barrierColor: Colors.transparent,
          context: context,
          builder: (BuildContext context) {
            // We'll talk about this 'Settings' widget in the next chapter!
            return Settings(
              // Pass the current settings and the way to update the theme
              selectedColor: selectedColor,
              selectedBrightness: selectedBrightness,
              selectedContrast: selectedContrast,
              updateTheme: updateTheme,
            );
          },
        );
      },
    );
  }
}
```

Let's break down the important parts:

1.  `class SettingsButton extends StatelessWidget`: This tells us that the `SettingsButton` itself doesn't change its appearance based on internal data. It's a static button, though what happens when you press it can change things elsewhere!
2.  `required this.updateTheme`: Remember how in [ColorSchemeExample](01_colorschemeexample_.md) we talked about the `updateTheme` function that actually changes the color settings? The `SettingsButton` needs to *know* about this function so it can pass it along to the settings panel.
3.  `@override Widget build(BuildContext context)`: This is where the `SettingsButton` creates its appearance.
4.  `return IconButton(...)`: This is a common Flutter widget for a button that's just an icon. It's perfect for our settings icon!
5.  `icon: const Icon(Icons.settings)`: This gives the `IconButton` the familiar gear icon used for settings.
6.  `onPressed: () { ... }`: This is the crucial part! This defines what happens *when the button is tapped*.
7.  `showModalBottomSheet<void>(...)`: This is a Flutter function that displays a temporary panel that slides up from the bottom of the screen. This is exactly what we want for our settings panel!
8.  `builder: (BuildContext context) { ... return Settings(...) }`: This part tells `showModalBottomSheet` *what* to show inside the panel. It's showing a widget called `Settings`. We'll dive deeper into this `Settings` widget in the next chapter, [Settings](03_settings_.md).

So, when you tap the `SettingsButton`, it calls `showModalBottomSheet`, which then builds and displays the `Settings` widget at the bottom of the screen. The `SettingsButton` also passes the `updateTheme` function and the *current* theme settings to the `Settings` widget so it knows what the theme is now and how to change it.

## Where does the SettingsButton live?

The `SettingsButton` is placed within the app bar of our main screen ([ColorSchemeExample](01_colorschemeexample_.md)). Look at this small snippet from the `ColorSchemeExample`'s `build` method:

```dart
  @override
  Widget build(BuildContext context) {
    return MaterialApp(
      // ... theme setup ...
      home: Scaffold(
        appBar: AppBar(
          title: const Text('ColorScheme'),
          actions: <Widget>[
            // Here it is!
            SettingsButton(
              selectedColor: selectedColor,
              selectedBrightness: selectedBrightness,
              selectedContrast: selectedContrast,
              updateTheme: updateTheme, // Passing the update function
            ),
          ],
        ),
        // ... rest of the body ...
      ),
    );
  }
```

The `AppBar` widget has an `actions` parameter, which is a list of widgets that appear at the end of the app bar (usually on the right). We simply include our `SettingsButton` in this list, and boom! It appears in the app bar. Notice how we pass the current theme settings (`selectedColor`, `selectedBrightness`, `selectedContrast`) and the `updateTheme` function to the `SettingsButton`. This allows the `SettingsButton` to then pass these along to the `Settings` panel.

## Behind the Scenes

When you tap the `SettingsButton`, here's a simplified sequence of events:

```mermaid
sequenceDiagram
    participant User
    participant SB as SettingsButton
    participant Flutter as Flutter Framework
    participant SettingsPanel as Settings (Widget)

    User->SB: Tap the button!
    SB->Flutter: Call showModalBottomSheet()
    Flutter->SettingsPanel: Build and show the Settings widget
    SettingsPanel-->User: Settings panel appears
```

1.  The user taps the icon button in the app bar.
2.  The `onPressed` function inside the `SettingsButton` is executed.
3.  This function calls `showModalBottomSheet`.
4.  `showModalBottomSheet` in the Flutter framework takes the `builder` function provided by `SettingsButton`.
5.  The `builder` function creates and returns the `Settings` widget.
6.  Flutter displays the `Settings` widget as a sliding panel from the bottom of the screen.

The `SettingsButton`'s only job here is to be the trigger that shows the settings panel. It doesn't manage the settings itself; it just opens the door for the user to interact with a different widget ([Settings](03_settings_.md)) that *does* manage the interaction.

## Conclusion

In this chapter, we explored the `SettingsButton`, the simple button in the app bar that acts as a gateway to the settings panel. We saw how it uses `showModalBottomSheet` to display another widget ([Settings](03_settings_.md)) when tapped and how it receives and passes along the necessary information to update the theme.

We now know how to open the door to change our theme settings. In the next chapter, we'll step through that door and explore the [Settings](03_settings_.md) widget itself to understand how it allows users to change the color theme.

Ready to customize? Let's move on!

[Chapter 3: Settings](03_settings_.md)
---
# Chapter 3: Settings

Welcome back, future Flutter expert! In our last chapter, [SettingsButton](02_settingsbutton_.md), we learned how to add a special button to our app's app bar. This button acts like a secret door, and when we tap it, it opens up a place where we can fine-tune the look of our app. Today, we're going to step through that door and meet the widget that lives there: the `Settings` widget!

## What is the Settings Widget?

Imagine you're sitting in the control room of a spaceship, and you have different dials and switches to adjust the lighting, the view out the window, and other cool things. The `Settings` widget is like that control panel for our app's color theme!

Its main job is to provide a user interface – a bunch of visual controls – that let you change:

*   **Brightness:** Do you want the app to be light or dark?
*   **Seed Color:** What primary color should all other colors in the app be based on?
*   **Contrast Level:** How much difference should there be between colors and text?

And the most important part? When you adjust one of these controls, the `Settings` widget talks back to the main part of our app ([ColorSchemeExample](01_colorschemeexample_.md)) and tells it, "Hey, the user wants to change the theme! Here are the new settings!"

Our specific use case is to build a panel that shows options for brightness, seed color, and contrast, and allows the user to interact with these options to change the app's theme.

## How does the Settings Widget work?

The `Settings` widget is the brain behind the settings panel that slides up from the bottom. It needs to:

1.  **Show the current settings:** When you open the panel, it should show what the current brightness, seed color, and contrast are.
2.  **Allow the user to change settings:** Provide controls (like switches, buttons, and sliders) to change the values.
3.  **Tell the main app about changes:** When a user changes a setting, it needs to communicate these changes back to [ColorSchemeExample](01_colorschemeexample_.md).

Let's look at the code for the `Settings` widget and see how it does this (from `color_scheme.0.dart`):

```dart
class Settings extends StatefulWidget {
  const Settings({
    super.key,
    required this.updateTheme,
    required this.selectedBrightness,
    required this.selectedContrast,
    required this.selectedColor,
  });

  final Brightness selectedBrightness;
  final double selectedContrast;
  final Color selectedColor;

  final void Function(Brightness, Color, double) updateTheme;

  @override
  State<Settings> createState() => _SettingsState();
}
```

*   `class Settings extends StatefulWidget`: Like [ColorSchemeExample](01_colorschemeexample_.md), `Settings` is also a `StatefulWidget`. This is because the settings panel itself needs to *remember* the values you've selected *while the panel is open*. For example, if you flip the light/dark switch, the switch itself needs to visually change its state.
*   `required this.updateTheme`, `selectedBrightness`, `selectedContrast`, `selectedColor`: These are the things that the `SettingsButton` *passes* into the `Settings` widget. Remember how the `SettingsButton` knew the current theme settings and the function to update the theme? It gives all that information to `Settings` when it opens the panel. `updateTheme` is a special function that the `Settings` widget will call to tell [ColorSchemeExample](01_colorschemeexample_.md) about the changes.

Now let's peek inside the `_SettingsState` where the actual controls are built:

```dart
class _SettingsState extends State<Settings> {
  late Brightness selectedBrightness = widget.selectedBrightness;
  late Color selectedColor = widget.selectedColor;
  late double selectedContrast = widget.selectedContrast;

  @override
  Widget build(BuildContext context) {
    return Theme(
      data: Theme.of(context).copyWith(
        // This briefly changes the theme *for the settings panel itself*
        colorScheme: ColorScheme.fromSeed(
          seedColor: selectedColor,
          contrastLevel: selectedContrast,
          brightness: selectedBrightness,
        ),
      ),
      child: ConstrainedBox(
        // ... more layout code ...
        child: Padding(
          // ... padding code ...
          child: ListView(
            children: <Widget>[
              // ... Title ...
              Row(
                children: <Widget>[
                  const Text('Brightness: '),
                  Switch(
                    value: selectedBrightness == Brightness.light,
                    onChanged: (bool value) {
                      setState(() {
                        selectedBrightness = value ? Brightness.light : Brightness.dark;
                      });
                      widget.updateTheme(selectedBrightness, selectedColor, selectedContrast); // <-- Tell the main app!
                    },
                  ),
                ],
              ),
              // ... More controls for ColorSeed and ContrastLevel ...
            ],
          ),
        ),
      ),
    );
  }
}
```

*   `late Brightness selectedBrightness = widget.selectedBrightness;`: When the `Settings` widget is created, it takes the initial brightness, color, and contrast that were passed from the `SettingsButton` and stores them in its own internal state variables. These are the values that the controls on the panel will show and modify *locally*.
*   `return Theme(...)`: This is a neat trick! It temporarily applies a theme *only* to the widgets inside this `Theme` widget. This means the settings panel itself will use the color scheme based on the *currently selected* settings, which is helpful for previewing colors within the panel.
*   `ListView`: We use a `ListView` to arrange our controls vertically. If there are many settings, this allows the user to scroll.
*   `Row(...)`: Each row in the `ListView` holds one setting control (like Brightness, Seed color, or Contrast).
*   `Switch(...)`: For the brightness setting, we use a `Switch`. When you flip the switch, the `onChanged` function is called.
*   `setState(() { ... });`: Inside `onChanged`, we first use `setState`. This updates the `selectedBrightness` variable within the `_SettingsState`. Because we used `setState`, Flutter knows that the UI for this widget needs to be re-drawn. This is why the switch visually flips!
*   `widget.updateTheme(...)`: **This is the most important line!** After updating its own internal state (`selectedBrightness`), the `Settings` widget calls the `updateTheme` function that was passed to it. It sends the *new* values for brightness, color, and contrast to this function. This function lives back in [ColorSchemeExample](01_colorschemeexample_.md), and calling it tells the main app, "Okay, the user made a change, update the whole app's theme!"

The code for the `ColorSeed` selection uses `Wrap` and `IconButton` instead of a `Switch`, and the `Contrast Level` uses a `Row` and a `Slider`, but they all follow the same pattern:

1.  Listen for a change in the control (`onPressed` for buttons, `onChanged` for slider/switch).
2.  Update the local state variable (`selectedColor` or `selectedContrast`) using `setState`.
3.  Call `widget.updateTheme` with the *latest* values of `selectedBrightness`, `selectedColor`, and `selectedContrast` to update the main app theme.

## How Changes Flow

Let's visualize the journey of a change when you interact with the `Settings` widget:

```mermaid
sequenceDiagram
    participant User
    participant SP as Settings Panel (Settings Widget)
    participant SettingsState as _SettingsState
    participant CS as ColorSchemeExample

    User->SP: Flips Brightness Switch
    SP->SettingsState: Calls onChanged
    SettingsState->SettingsState: Updates local selectedBrightness
    SettingsState->SettingsState: Calls setState() (Panel redraws)
    SettingsState->CS: Calls widget.updateTheme(new settings)
    CS->CS: Calls updateTheme()
    CS->CS: Updates internal theme settings
    CS->CS: Calls setState() (Main app redraws)
    CS-->User: Main app shows with new brightness
```

1.  The user flips the switch, taps a color circle, or moves the slider on the `Settings` panel.
2.  The corresponding `onChanged` or `onPressed` function is triggered inside the `_SettingsState`.
3.  The local state variable (like `selectedBrightness`) is updated within the `_SettingsState`.
4.  `setState()` is called, causing the `Settings` widget itself to rebuild and show the visual change (like the switch flipping or the color icon changing).
5.  Critically, `widget.updateTheme()` is called, passing the new settings values to the `updateTheme` function that [ColorSchemeExample](01_colorschemeexample_.md) provided.
6.  The `updateTheme` function inside [ColorSchemeExample](01_colorschemeexample_.md) is executed.
7.  [ColorSchemeExample](01_colorschemeexample_.md) updates its own internal theme settings (`selectedBrightness`, `selectedColor`, `selectedContrast`).
8.  [ColorSchemeExample](01_colorschemeexample_.md) calls its *own* `setState()`.
9.  Because [ColorSchemeExample](01_colorschemeexample_.md) is the main widget controlling the app's theme, the entire app rebuilds using the new `ThemeData` and `ColorScheme`.
10. The user sees the app's theme instantly change!

The `Settings` widget is like a temporary control panel. It manages the user's interaction and then passes the final desired settings back to the main `ColorSchemeExample` to apply the changes everywhere.

## Conclusion

In this chapter, we explored the `Settings` widget, the interactive panel that lets users customize the app's color theme. We saw how it takes the current settings and the `updateTheme` function from the [SettingsButton](02_settingsbutton_.md), provides controls like switches, icon buttons, and a slider, and uses `setState` to manage its own appearance while calling `widget.updateTheme` to communicate changes back to [ColorSchemeExample](01_colorschemeexample_.md).

We now understand how to open the settings and interact with them to request changes. In the next chapter, [ColorSchemeVariantColumn](04_colorschemevariantcolumn_.md), we'll start looking at how those chosen settings translate into the actual different colors that make up our theme and how they are displayed in columns on the main screen.

Ready to see the colors generated? Let's move on!

[Chapter 4: ColorSchemeVariantColumn](04_colorschemevariantcolumn_.md)

Relevant Code Snippets (Code itself remains unchanged):
--- File: color_scheme.0.dart ---
// Copyright 2014 The Flutter Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

import 'package:flutter/material.dart';

/// Flutter code sample for [ColorScheme].

const Widget divider = SizedBox(height: 10);

void main() => runApp(const ColorSchemeExample());

class ColorSchemeExample extends StatefulWidget {
  const ColorSchemeExample({super.key});

  @override
  State<ColorSchemeExample> createState() => _ColorSchemeExampleState();
}

class _ColorSchemeExampleState extends State<ColorSchemeExample> {
  Color selectedColor = ColorSeed.baseColor.color;
  Brightness selectedBrightness = Brightness.light;
  double selectedContrast = 0.0;
  static const List<DynamicSchemeVariant> schemeVariants = DynamicSchemeVariant.values;

  void updateTheme(Brightness brightness, Color color, double contrastLevel) {
    setState(() {
      selectedBrightness = brightness;
      selectedColor = color;
      selectedContrast = contrastLevel;
    });
  }

  @override
  Widget build(BuildContext context) {
    return MaterialApp(
      debugShowCheckedModeBanner: false,
      theme: ThemeData(
        colorScheme: ColorScheme.fromSeed(
          seedColor: selectedColor,
          brightness: selectedBrightness,
          contrastLevel: selectedContrast,
        ),
      ),
      home: Scaffold(
        appBar: AppBar(
          title: const Text('ColorScheme'),
          actions: <Widget>[
            SettingsButton(
              selectedColor: selectedColor,
              selectedBrightness: selectedBrightness,
              selectedContrast: selectedContrast,
              updateTheme: updateTheme,
            ),
          ],
        ),
        body: SingleChildScrollView(
          child: Padding(
            padding: const EdgeInsets.only(top: 5),
            child: Column(
              crossAxisAlignment: CrossAxisAlignment.start,
              children: <Widget>[
                SingleChildScrollView(
                  scrollDirection: Axis.horizontal,
                  child: Row(
                    children:
                        List<Widget>.generate(schemeVariants.length, (int index) {
                          return ColorSchemeVariantColumn(
                            selectedColor: selectedColor,
                            brightness: selectedBrightness,
                            schemeVariant: schemeVariants[index],
                            contrastLevel: selectedContrast,
                          );
                        }).toList(),
                  ),
                ),
              ],
            ),
          ),
        ),
      ),
    );
  }
}

class Settings extends StatefulWidget {
  const Settings({
    super.key,
    required this.updateTheme,
    required this.selectedBrightness,
    required this.selectedContrast,
    required this.selectedColor,
  });

  final Brightness selectedBrightness;
  final double selectedContrast;
  final Color selectedColor;

  final void Function(Brightness, Color, double) updateTheme;

  @override
  State<Settings> createState() => _SettingsState();
}

class _SettingsState extends State<Settings> {
  late Brightness selectedBrightness = widget.selectedBrightness;
  late Color selectedColor = widget.selectedColor;
  late double selectedContrast = widget.selectedContrast;

  @override
  Widget build(BuildContext context) {
    return Theme(
      data: Theme.of(context).copyWith(
        colorScheme: ColorScheme.fromSeed(
          seedColor: selectedColor,
          contrastLevel: selectedContrast,
          brightness: selectedBrightness,
        ),
      ),
      child: ConstrainedBox(
        constraints: const BoxConstraints(maxHeight: 200),
        child: Padding(
          padding: const EdgeInsets.all(20.0),
          child: ListView(
            children: <Widget>[
              Center(child: Text('Settings', style: Theme.of(context).textTheme.titleLarge)),
              Row(
                children: <Widget>[
                  const Text('Brightness: '),
                  Switch(
                    value: selectedBrightness == Brightness.light,
                    onChanged: (bool value) {
                      setState(() {
                        selectedBrightness = value ? Brightness.light : Brightness.dark;
                      });
                      widget.updateTheme(selectedBrightness, selectedColor, selectedContrast);
                    },
                  ),
                ],
              ),
              Wrap(
                crossAxisAlignment: WrapCrossAlignment.center,
                children: <Widget>[
                  const Text('Seed color: '),
                  ...List<Widget>.generate(ColorSeed.values.length, (int index) {
                    final Color itemColor = ColorSeed.values[index].color;
                    return IconButton(
                      icon:
                          selectedColor == ColorSeed.values[index].color
                              ? Icon(Icons.circle, color: itemColor)
                              : Icon(Icons.circle_outlined, color: itemColor),
                      onPressed: () {
                        setState(() {
                          selectedColor = itemColor;
                        });
                        widget.updateTheme(selectedBrightness, selectedColor, selectedContrast);
                      },
                    );
                  }),
                ],
              ),
              Row(
                children: <Widget>[
                  const Text('Contrast level: '),
                  Expanded(
                    child: Slider(
                      divisions: 4,
                      label: selectedContrast.toString(),
                      min: -1,
                      value: selectedContrast,
                      onChanged: (double value) {
                        setState(() {
                          selectedContrast = value;
                        });
                        widget.updateTheme(selectedBrightness, selectedColor, selectedContrast);
                      },
                    ),
                  ),
                ],
              ),
            ],
          ),
        ),
      ),
    );
  }
}

class ColorSchemeVariantColumn extends StatelessWidget {
  const ColorSchemeVariantColumn({
    super.key,
    this.schemeVariant = DynamicSchemeVariant.tonalSpot,
    this.brightness = Brightness.light,
    this.contrastLevel = 0.0,
    required this.selectedColor,
  });

  final DynamicSchemeVariant schemeVariant;
  final Brightness brightness;
  final double contrastLevel;
  final Color selectedColor;

  @override
  Widget build(BuildContext context) {
    return ConstrainedBox(
      constraints: const BoxConstraints.tightFor(width: 250),
      child: Column(
        children: <Widget>[
          Padding(
            padding: const EdgeInsets.symmetric(vertical: 15),
            child: Text(
              schemeVariant.name == 'tonalSpot'
                  ? '${schemeVariant.name} (Default)'
                  : schemeVariant.name,
              style: const TextStyle(fontWeight: FontWeight.bold),
            ),
          ),
          Padding(
            padding: const EdgeInsets.symmetric(horizontal: 15),
            child: ColorSchemeView(
              colorScheme: ColorScheme.fromSeed(
                seedColor: selectedColor,
                brightness: brightness,
                contrastLevel: contrastLevel,
                dynamicSchemeVariant: schemeVariant,
              ),
            ),
          ),
        ],
      ),
    );
  }
}

class ColorSchemeView extends StatelessWidget {
  const ColorSchemeView({super.key, required this.colorScheme});

  final ColorScheme colorScheme;

  @override
  Widget build(BuildContext context) {
    return Column(
      children: <Widget>[
        ColorGroup(
          children: <ColorChip>[
            ColorChip('primary', colorScheme.primary, colorScheme.onPrimary),
            ColorChip('onPrimary', colorScheme.onPrimary, colorScheme.primary),
            ColorChip(
              'primaryContainer',
              colorScheme.primaryContainer,
              colorScheme.onPrimaryContainer,
            ),
            ColorChip(
              'onPrimaryContainer',
              colorScheme.onPrimaryContainer,
              colorScheme.primaryContainer,
            ),
          ],
        ),
        divider,
        ColorGroup(
          children: <ColorChip>[
            ColorChip('primaryFixed', colorScheme.primaryFixed, colorScheme.onPrimaryFixed),
            ColorChip('onPrimaryFixed', colorScheme.onPrimaryFixed, colorScheme.primaryFixed),
            ColorChip(
              'primaryFixedDim',
              colorScheme.primaryFixedDim,
              colorScheme.onPrimaryFixedVariant,
            ),
            ColorChip(
              'onPrimaryFixedVariant',
              colorScheme.onPrimaryFixedVariant,
              colorScheme.primaryFixedDim,
            ),
          ],
        ),
        divider,
        ColorGroup(
          children: <ColorChip>[
            ColorChip('secondary', colorScheme.secondary, colorScheme.onSecondary),
            ColorChip('onSecondary', colorScheme.onSecondary, colorScheme.secondary),
            ColorChip(
              'secondaryContainer',
              colorScheme.secondaryContainer,
              colorScheme.onSecondaryContainer,
            ),
            ColorChip(
              'onSecondaryContainer',
              colorScheme.onSecondaryContainer,
              colorScheme.secondaryContainer,
            ),
          ],
        ),
        divider,
        ColorGroup(
          children: <ColorChip>[
            ColorChip('secondaryFixed', colorScheme.secondaryFixed, colorScheme.onSecondaryFixed),
            ColorChip('onSecondaryFixed', colorScheme.onSecondaryFixed, colorScheme.secondaryFixed),
            ColorChip(
              'secondaryFixedDim',
              colorScheme.secondaryFixedDim,
              colorScheme.onSecondaryFixedVariant,
            ),
            ColorChip(
              'onSecondaryFixedVariant',
              colorScheme.onSecondaryFixedVariant,
              colorScheme.secondaryFixedDim,
            ),
          ],
        ),
        divider,
        ColorGroup(
          children: <ColorChip>[
            ColorChip('tertiary', colorScheme.tertiary, colorScheme.onTertiary),
            ColorChip('onTertiary', colorScheme.onTertiary, colorScheme.tertiary),
            ColorChip(
              'tertiaryContainer',
              colorScheme.tertiaryContainer,
              colorScheme.onTertiaryContainer,
            ),
            ColorChip(
              'onTertiaryContainer',
              colorScheme.onTertiaryContainer,
              colorScheme.tertiaryContainer,
            ),
          ],
        ),
        divider,
        ColorGroup(
          children: <ColorChip>[
            ColorChip('tertiaryFixed', colorScheme.tertiaryFixed, colorScheme.onTertiaryFixed),
            ColorChip('onTertiaryFixed', colorScheme.onTertiaryFixed, colorScheme.tertiaryFixed),
            ColorChip(
              'tertiaryFixedDim',
              colorScheme.tertiaryFixedDim,
              colorScheme.onTertiaryFixedVariant,
            ),
            ColorChip(
              'onTertiaryFixedVariant',
              colorScheme.onTertiaryFixedVariant,
              colorScheme.tertiaryFixedDim,
            ),
          ],
        ),
        divider,
        ColorGroup(
          children: <ColorChip>[
            ColorChip('error', colorScheme.error, colorScheme.onError),
            ColorChip('onError', colorScheme.onError, colorScheme.error),
            ColorChip('errorContainer', colorScheme.errorContainer, colorScheme.onErrorContainer),
            ColorChip('onErrorContainer', colorScheme.onErrorContainer, colorScheme.errorContainer),
          ],
        ),
        divider,
        ColorGroup(
          children: <ColorChip>[
            ColorChip('surfaceDim', colorScheme.surfaceDim, colorScheme.onSurface),
            ColorChip('surface', colorScheme.surface, colorScheme.onSurface),
            ColorChip('surfaceBright', colorScheme.surfaceBright, colorScheme.onSurface),
            ColorChip(
              'surfaceContainerLowest',
              colorScheme.surfaceContainerLowest,
              colorScheme.onSurface,
            ),
            ColorChip(
              'surfaceContainerLow',
              colorScheme.surfaceContainerLow,
              colorScheme.onSurface,
            ),
            ColorChip('surfaceContainer', colorScheme.surfaceContainer, colorScheme.onSurface),
            ColorChip(
              'surfaceContainerHigh',
              colorScheme.surfaceContainerHigh,
              colorScheme.onSurface,
            ),
            ColorChip(
              'surfaceContainerHighest',
              colorScheme.surfaceContainerHighest,
              colorScheme.onSurface,
            ),
            ColorChip('onSurface', colorScheme.onSurface, colorScheme.surface),
            ColorChip(
              'onSurfaceVariant',
              colorScheme.onSurfaceVariant,
              colorScheme.surfaceContainerHighest,
            ),
          ],
        ),
        divider,
        ColorGroup(
          children: <ColorChip>[
            ColorChip('outline', colorScheme.outline, null),
            ColorChip('shadow', colorScheme.shadow, null),
            ColorChip('inverseSurface', colorScheme.inverseSurface, colorScheme.onInverseSurface),
            ColorChip('onInverseSurface', colorScheme.onInverseSurface, colorScheme.inverseSurface),
            ColorChip('inversePrimary', colorScheme.inversePrimary, colorScheme.primary),
          ],
        ),
      ],
    );
  }
}

class ColorGroup extends StatelessWidget {
  const ColorGroup({super.key, required this.children});

  final List<Widget> children;

  @override
  Widget build(BuildContext context) {
    return RepaintBoundary(
      child: Card(clipBehavior: Clip.antiAlias, child: Column(children: children)),
    );
  }
}

class ColorChip extends StatelessWidget {
  const ColorChip(this.label, this.color, this.onColor, {super.key});

  final Color color;
  final Color? onColor;
  final String label;

  static Color contrastColor(Color color) {
    final Brightness brightness = ThemeData.estimateBrightnessForColor(color);
    return brightness == Brightness.dark ? Colors.white : Colors.black;
  }

  @override
  Widget build(BuildContext context) {
    final Color labelColor = onColor ?? contrastColor(color);
    return ColoredBox(
      color: color,
      child: Padding(
        padding: const EdgeInsets.all(16),
        child: Row(
          children: <Expanded>[Expanded(child: Text(label, style: TextStyle(color: labelColor)))],
        ),
      ),
    );
  }
}

enum ColorSeed {
  baseColor('M3 Baseline', Color(0xff6750a4)),
  indigo('Indigo', Colors.indigo),
  blue('Blue', Colors.blue),
  teal('Teal', Colors.teal),
  green('Green', Colors.green),
  yellow('Yellow', Colors.yellow),
  orange('Orange', Colors.orange),
  deepOrange('Deep Orange', Colors.deepOrange),
  pink('Pink', Colors.pink),
  brightBlue('Bright Blue', Color(0xFF0000FF)),
  brightGreen('Bright Green', Color(0xFF00FF00)),
  brightRed('Bright Red', Color(0xFFFF0000));

  const ColorSeed(this.label, this.color);
  final String label;
  final Color color;
}

class SettingsButton extends StatelessWidget {
  const SettingsButton({
    super.key,
    required this.updateTheme,
    required this.selectedBrightness,
    required this.selectedContrast,
    required this.selectedColor,
  });

  final Brightness selectedBrightness;
  final double selectedContrast;
  final Color selectedColor;

  final void Function(Brightness, Color, double) updateTheme;

  @override
  Widget build(BuildContext context) {
    return IconButton(
      icon: const Icon(Icons.settings),
      onPressed: () {
        showModalBottomSheet<void>(
          barrierColor: Colors.transparent,
          context: context,
          builder: (BuildContext context) {
            return Settings(
              selectedColor: selectedColor,
              selectedBrightness: selectedBrightness,
              selectedContrast: selectedContrast,
              updateTheme: updateTheme,
            );
          },
        );
      },
    );
  }
}


Instructions for the chapter (Generate content in English unless specified otherwise):
- Start with a clear heading (e.g., `# Chapter 4: ColorSchemeVariantColumn
`). Use the provided concept name.

- If this is not the first chapter, begin with a brief transition from the previous chapter, referencing it with a proper Markdown link using its name.

- Begin with a high-level motivation explaining what problem this abstraction solves. Start with a central use case as a concrete example. The whole chapter should guide the reader to understand how to solve this use case. Make it very minimal and friendly to beginners.

- If the abstraction is complex, break it down into key concepts. Explain each concept one-by-one in a very beginner-friendly way.

- Explain how to use this abstraction to solve the use case. Give example inputs and outputs for code snippets (if the output isn't values, describe at a high level what will happen).

- Each code block should be BELOW 10 lines! If longer code blocks are needed, break them down into smaller pieces and walk through them one-by-one. Aggresively simplify the code to make it minimal. Use comments to skip non-important implementation details. Each code block should have a beginner friendly explanation right after it.

- Describe the internal implementation to help understand what's under the hood. First provide a non-code or code-light walkthrough on what happens step-by-step when the abstraction is called. It's recommended to use a simple sequenceDiagram with a dummy example - keep it minimal with at most 5 participants to ensure clarity. If participant name has space, use: `participant QP as Query Processing`. .

- Then dive deeper into code for the internal implementation with references to files. Provide example code blocks, but make them similarly simple and beginner-friendly. Explain.

- IMPORTANT: When you need to refer to other core abstractions covered in other chapters, ALWAYS use proper Markdown links like this: [Chapter Title](filename.md). Use the Complete Tutorial Structure above to find the correct filename and the chapter title. Translate the surrounding text.

- Use mermaid diagrams to illustrate complex concepts (```mermaid``` format). .

- Heavily use analogies and examples throughout to help beginners understand.

- End the chapter with a brief conclusion that summarizes what was learned and provides a transition to the next chapter. If there is a next chapter, use a proper Markdown link: [Next Chapter Title](next_chapter_filename).

- Ensure the tone is welcoming and easy for a newcomer to understand.

- Output *only* the Markdown content for this chapter.

Now, directly provide a super beginner-friendly Markdown output (DON'T need ```markdown``` tags):

2025-05-28 16:30:43,920 - INFO - RESPONSE: # Chapter 4: ColorSchemeVariantColumn

Welcome back, color explorer! In the last chapter, [Settings](03_settings_.md), we learned how to open the settings panel and use its controls to pick our desired seed color, brightness, and contrast. Now that we've made our choices, how do we actually *see* how those choices affect the *various ways* our app's colors can be generated? That's where the `ColorSchemeVariantColumn` comes in!

## What is ColorSchemeVariantColumn?

Imagine you've picked a beautiful paint color for your house ([selectedColor] in our previous terms). But paint comes in different finishes: matte, semi-gloss, high-gloss, maybe even a textured finish! Each finish uses the *same* base color but applies it in a slightly different way, creating a distinct look.

In Flutter, the `ColorScheme` can also be generated with different "finishes" or *variants*. These variants use your chosen seed color, brightness, and contrast, but they apply mathematical formulas to create the final set of colors (like primary, secondary, surface, etc.) in unique ways. Some might emphasize certain tones, others might use more neutral shades.

The `ColorSchemeVariantColumn` widget is like a display stand for one of these color variants. Its job is simple: it takes your selected color settings and a specific color scheme variant, generates the full `ColorScheme` for that variant, and then displays all the generated colors in a vertical column so you can see what that particular "finish" looks like.

Our specific use case for this chapter is to display multiple columns on the main screen, with each column showing the generated color scheme for a different variant, using the currently selected seed color, brightness, and contrast.

## How does ColorSchemeVariantColumn work?

The `ColorSchemeVariantColumn` is a pretty straightforward widget. It needs the raw ingredients (the settings you picked) and the specific "recipe" (the variant) to show you the resulting colors.

Let's look at its code from `color_scheme.0.dart`:

```dart
class ColorSchemeVariantColumn extends StatelessWidget {
  const ColorSchemeVariantColumn({
    super.key,
    this.schemeVariant = DynamicSchemeVariant.tonalSpot, // Default variant
    this.brightness = Brightness.light,
    this.contrastLevel = 0.0,
    required this.selectedColor,
  });

  final DynamicSchemeVariant schemeVariant; // The specific variant for THIS column
  final Brightness brightness;
  final double contrastLevel;
  final Color selectedColor; // The seed color you chose

  @override
  Widget build(BuildContext context) {
    // ... rest of the build method
    return Padding( // Simplified for this explanation
      padding: const EdgeInsets.symmetric(horizontal: 15),
      child: ColorSchemeView( // This widget actually displays the colors
        colorScheme: ColorScheme.fromSeed( // Generating the ColorScheme!
          seedColor: selectedColor,
          brightness: brightness,
          contrastLevel: contrastLevel,
          dynamicSchemeVariant: schemeVariant, // Using THIS column's variant
        ),
      ),
    );
  }
}
```

Here's what's happening:

1.  `class ColorSchemeVariantColumn extends StatelessWidget`: This tells us that once the settings and variant are given to it, the `ColorSchemeVariantColumn` itself doesn't change. It just displays something based on the inputs it receives.
2.  `final DynamicSchemeVariant schemeVariant;`: This is the key! Each `ColorSchemeVariantColumn` receives a different `DynamicSchemeVariant`. This tells *this specific column* which color generation rule to use.
3.  `final Brightness brightness;`, `final double contrastLevel;`, `final Color selectedColor;`: These are the global settings that are passed down from [ColorSchemeExample](01_colorschemeexample_.md). Every `ColorSchemeVariantColumn` uses the *same* currently selected settings for these.
4.  `ColorScheme.fromSeed(...)`: This is the powerful part we first saw in [ColorSchemeExample](01_colorschemeexample_.md). It takes the seed color, brightness, and contrast.
5.  `dynamicSchemeVariant: schemeVariant,`: **This is where the variant is applied!** Instead of using the default variant, *this specific column* uses the `schemeVariant` that was passed to it. This tells `ColorScheme.fromSeed` *HOW* to generate the full set of colors using the provided inputs.
6.  `ColorSchemeView(...)`: The `ColorScheme.fromSeed` function spits out a complete `ColorScheme` object (a big list of all the primary, secondary, surface colors, etc.). The `ColorSchemeVariantColumn` then passes this generated `ColorScheme` to the `ColorSchemeView` widget, which is responsible for actually drawing all those color blocks and labels on the screen. (We'll look at `ColorSchemeView` in the next chapter!)

So, each `ColorSchemeVariantColumn` is essentially instructed to: "Take these global settings (seed color, brightness, contrast) and this specific generation rule (variant), create the set of colors, and show them."

## Where does ColorSchemeVariantColumn live?

The `ColorSchemeExample` widget (our main controller) is responsible for creating multiple instances of `ColorSchemeVariantColumn`, one for each available variant.

Look at this snippet inside the `_ColorSchemeExampleState`'s `build` method (from `color_scheme.0.dart`):

```dart
  @override
  Widget build(BuildContext context) {
    return MaterialApp(
      // ... theme setup ...
      home: Scaffold(
        // ... app bar ...
        body: SingleChildScrollView( // Allows scrolling horizontally
          child: Padding(
            // ... padding ...
            child: Column(
              // ... other widgets ...
              children: <Widget>[
                SingleChildScrollView(
                  scrollDirection: Axis.horizontal,
                  child: Row( // Arranges children horizontally
                    children:
                        List<Widget>.generate(schemeVariants.length, (int index) {
                          // Create a ColorSchemeVariantColumn for EACH variant
                          return ColorSchemeVariantColumn(
                            selectedColor: selectedColor, // Pass global settings
                            brightness: selectedBrightness,
                            schemeVariant: schemeVariants[index], // Pass THIS variant
                            contrastLevel: selectedContrast,
                          );
                        }).toList(),
                  ),
                ),
              ],
            ),
          ),
        ),
      ),
    );
  }
}
```

*   `SingleChildScrollView(scrollDirection: Axis.horizontal)`: This allows us to scroll the columns left and right if there are too many to fit on the screen at once.
*   `Row(...)`: The `Row` widget places its children next to each other horizontally.
*   `List<Widget>.generate(schemeVariants.length, (int index) { ... })`: This is a neat way to automatically create a list of widgets. `schemeVariants` is a list of all the available `DynamicSchemeVariant` options. This code generates one `ColorSchemeVariantColumn` for *each* variant in that list.
*   `return ColorSchemeVariantColumn(...)`: Inside the `generate` function, we create a `ColorSchemeVariantColumn`. We pass the global settings (`selectedColor`, `selectedBrightness`, `selectedContrast`) that the `_ColorSchemeExampleState` is currently holding. Crucially, we pass a *different* `schemeVariant` (`schemeVariants[index]`) to each column we create.

This means if there are 5 different color scheme variants, the `ColorSchemeExample` creates 5 `ColorSchemeVariantColumn` widgets. Each column gets the *same* seed color, brightness, and contrast, but a *different* variant instruction. They then each generate their own `ColorScheme` according to their variant and display it.

## Behind the Scenes

When [Settings](03_settings_.md) calls `widget.updateTheme` in [ColorSchemeExample](01_colorschemeexample_.md), here's what happens related to the `ColorSchemeVariantColumn`s:

```mermaid
sequenceDiagram
    participant User
    participant Settings as Settings Panel
    participant CS as ColorSchemeExample
    participant Col as ColorSchemeVariantColumn
    participant View as ColorSchemeView
    participant CSFS as ColorScheme.fromSeed

    User->Settings: Changes Seed Color
    Settings->CS: Calls updateTheme(new color)
    CS->CS: Updates selectedColor state
    CS->CS: Calls setState() (CS redraws)
    CS->Row: Rebuilds Row of Columns
    Row->Col: Creates new ColorSchemeVariantColumn instances
    Col->CSFS: Calls ColorScheme.fromSeed with new color and its variant
    CSFS-->Col: Returns new ColorScheme
    Col->View: Passes new ColorScheme to ColorSchemeView
    View-->User: Columns update with new colors based on their variants
```

1.  The user changes a setting (e.g., the seed color) in the [Settings](03_settings_.md) panel.
2.  [Settings](03_settings_.md) calls `updateTheme` on the `ColorSchemeExample`.
3.  `ColorSchemeExample` updates its internal state (`selectedColor`, etc.) and calls its own `setState()`.
4.  `ColorSchemeExample` rebuilds its `build` method, which includes rebuilding the `Row` that holds the `ColorSchemeVariantColumn`s.
5.  The `Row` tells Flutter to create new `ColorSchemeVariantColumn` widgets (or update existing ones if optimized).
6.  Each `ColorSchemeVariantColumn` widget receives the *new* `selectedColor` (and other settings) *plus* its specific `schemeVariant`.
7.  Inside each `ColorSchemeVariantColumn`, `ColorScheme.fromSeed` is called using the new color and the column's specific variant.
8.  `ColorScheme.fromSeed` calculates and returns a complete `ColorScheme` based on these inputs.
9.  Each `ColorSchemeVariantColumn` passes its newly generated `ColorScheme` to its child `ColorSchemeView`.
10. The `ColorSchemeView` for each column updates, drawing the color blocks for that specific variant using the newly generated `ColorScheme`.
11. The user sees all the columns instantly update to show the different variants of the color scheme generated from their new seed color!

This shows how the `ColorSchemeVariantColumn` acts as an intermediate step, taking the global settings and a specific variant, calculating the related `ColorScheme`, and then passing it along to be displayed.

## Conclusion

In this chapter, we introduced the `ColorSchemeVariantColumn`, a widget responsible for displaying the colors generated by a *specific* color scheme variant. We saw how it receives the global color settings (seed color, brightness, contrast) from [ColorSchemeExample](01_colorschemeexample_.md) along with its own unique `DynamicSchemeVariant`. It uses these inputs to generate a complete `ColorScheme` for that variant using `ColorScheme.fromSeed` and then passes this generated scheme to a `ColorSchemeView` to be displayed. [ColorSchemeExample](01_colorschemeexample_.md) creates multiple instances of `ColorSchemeVariantColumn` to show you side-by-side comparisons of how different variants look with your chosen settings.

We now understand how individual columns are responsible for a single variant. In the next chapter, [ColorSchemeView](05_colorschemeview_.md), we'll dive into the widget that `ColorSchemeVariantColumn` uses to actually *display* all those different colors within each column.

Ready to see how the colors are put on display? Let's move on!

[Chapter 5: ColorSchemeView](05_colorschemeview_.md)
2025-05-28 16:30:43,925 - INFO - PROMPT: 
Write a very beginner-friendly tutorial chapter (in Markdown format) for the project `flutter` about the concept: "ColorSchemeView
". This is Chapter 5.

Concept Details:
- Name: ColorSchemeView

- Description:
This widget is responsible for presenting all the individual colors within a given `ColorScheme`.
It's like a color chart that lays out all the different swatches (primary, secondary, surface, etc.) that make up a complete color scheme, showing you the whole palette at a glance.


Complete Tutorial Structure:
1. [ColorSchemeExample
](01_colorschemeexample_.md)
2. [SettingsButton
](02_settingsbutton_.md)
3. [Settings
](03_settings_.md)
4. [ColorSchemeVariantColumn
](04_colorschemevariantcolumn_.md)
5. [ColorSchemeView
](05_colorschemeview_.md)
6. [ColorGroup
](06_colorgroup_.md)
7. [ColorChip
](07_colorchip_.md)
8. [ColorSeed
](08_colorseed_.md)

Context from previous chapters:
# Chapter 1: ColorSchemeExample

Welcome, aspiring Flutter developer! In this chapter, we're going to meet the main conductor of our app's visual symphony: `ColorSchemeExample`. Think of this like the main boss or the central hub of our application. It's the widget that gets everything started and keeps track of the overall look and feel, specifically the colors!

## What is ColorSchemeExample?

Imagine you're building a house, and you want to decide on the paint colors, the brightness of the rooms, and how much contrast you want between different elements. The `ColorSchemeExample` is like the architect who holds the master plan for all these color decisions. It decides things like:

*   **What are the main colors of the app?**
*   **Should the app be light or dark?** (Brightness)
*   **How much difference should there be between colors and text?** (Contrast)

And the best part? If you change any of these decisions (like choosing a different main color), the `ColorSchemeExample` knows and makes sure the *whole* house (your app) updates to the new plan.

Our specific use case for this chapter is to see how `ColorSchemeExample` manages the initial color settings of our app.

## How does ColorSchemeExample work?

Let's take a look at the main part of the `ColorSchemeExample` code. Don't worry about understanding every single line right away. We'll break it down.

```dart
void main() => runApp(const ColorSchemeExample());

class ColorSchemeExample extends StatefulWidget {
  const ColorSchemeExample({super.key});

  @override
  State<ColorSchemeExample> createState() => _ColorSchemeExampleState();
}

class _ColorSchemeExampleState extends State<ColorSchemeExample> {
  Color selectedColor = ColorSeed.baseColor.color;
  Brightness selectedBrightness = Brightness.light;
  double selectedContrast = 0.0;
  // ... other code
}
```

This code shows us a couple of key things:

1.  `void main() => runApp(const ColorSchemeExample());`: This is where our app starts! It tells Flutter to run the `ColorSchemeExample` widget.
2.  `ColorSchemeExample extends StatefulWidget`: This means our `ColorSchemeExample` can change over time. If you change the color settings, the widget can rebuild itself to show the new colors.
3.  `_ColorSchemeExampleState`: This is where the `ColorSchemeExample` keeps track of its state, or its current settings. Notice `selectedColor`, `selectedBrightness`, and `selectedContrast`. These are the main color-related decisions it's currently holding.

So, when the app first starts, `ColorSchemeExample` sets up its initial color decisions (like the default primary color, brightness, and contrast).

## Setting up the Theme

The `ColorSchemeExample` also uses these color decisions to set the overall theme of the app. Let's look at the `build` method:

```dart
@override
Widget build(BuildContext context) {
  return MaterialApp(
    debugShowCheckedModeBanner: false,
    theme: ThemeData(
      colorScheme: ColorScheme.fromSeed(
        seedColor: selectedColor,
        brightness: selectedBrightness,
        contrastLevel: selectedContrast,
      ),
    ),
    // ... rest of the build method
  );
}
```

Here's what's happening:

*   `return MaterialApp(...)`: This is the basic structure for a Flutter app. It provides important things like navigation and theming.
*   `theme: ThemeData(...)`: This is where we define the visual theme for our app.
*   `colorScheme: ColorScheme.fromSeed(...)`: This is a super helpful way to create a whole set of colors for your app based on just one "seed" color. `ColorSchemeExample` uses its `selectedColor`, `selectedBrightness`, and `selectedContrast` to generate a complete `ColorScheme`. This `ColorScheme` contains many different color definitions (like primary, secondary, surface, etc.) that are all related to the seed color and brightness.

Essentially, `ColorSchemeExample` takes some basic color decisions and uses them to create a full `ColorScheme` that the rest of the app can use.

## How Changes Happen (Behind the Scenes)

We said `ColorSchemeExample` is like the conductor. When you make a change (like picking a new color from a settings menu, which we'll see in later chapters), here's a simplified look at what happens:

```mermaid
sequenceDiagram
    participant User
    participant CS as ColorSchemeExample
    participant State as _ColorSchemeExampleState
    participant App as MaterialApp

    User->CS: Wants to change color
    CS->State: Calls updateTheme()
    State->State: Updates selectedColor
    State->CS: Signals state changed (setState)
    CS->App: Rebuilds with new theme data
    App-->User: App shows with new colors
```

1.  The user interacts with something (like a button) to change a setting (like the color).
2.  This interaction tells the `ColorSchemeExample` to update.
3.  The `_ColorSchemeExampleState` inside `ColorSchemeExample` updates its stored color settings (`selectedColor`, `selectedBrightness`, etc.).
4.  It then tells Flutter that its state has changed using `setState()`.
5.  Because the state changed, the `ColorSchemeExample` widget (specifically its `build` method) runs again.
6.  In the `build` method, it creates a *new* `ThemeData` with a *new* `ColorScheme.fromSeed` based on the updated settings.
7.  The `MaterialApp` uses this new theme, and the entire app visually updates to reflect the changes.

This is the fundamental way `ColorSchemeExample` manages and updates the color theme of the application. It holds the core settings, uses them to generate a `ColorScheme`, and rebuilds the app when those settings change.

## Conclusion

In this chapter, we introduced `ColorSchemeExample`, the central widget responsible for managing our app's color theme. We saw how it holds the key color settings (seed color, brightness, contrast) and uses them to create a `ColorScheme` that defines the visual look of the application. We also got a glimpse of how it reacts to changes and updates the entire app's appearance.

Now that we understand the main conductor, let's look at how we can interact with it to change those settings. In the next chapter, we'll explore the [SettingsButton](02_settingsbutton_.md), which is how a user can open the options to customize the theme.

Ready to see how we actually change these colors? Let's move on!

[Chapter 2: SettingsButton](02_settingsbutton_.md)
---
# Chapter 2: SettingsButton

Welcome back! In the last chapter, [ColorSchemeExample](01_colorschemeexample_.md), we learned about the main conductor of our app's colors. It's the widget that holds the plan for our app's look and feel. But how do we actually tell that conductor we want to change the plan? That's where the `SettingsButton` comes in!

Imagine our app as a house with the color plan managed by the architect ([ColorSchemeExample](01_colorschemeexample_.md)). The `SettingsButton` is like a special door handle on the app bar that lets us into the room where we can talk to the architect and ask for changes!

## What is SettingsButton?

The `SettingsButton` is simply a button that sits usually at the top right corner of your app screen, in the "app bar". When you tap it, it doesn't change anything visually itself. Its job is to make something *else* appear – in our case, a panel where we can change the color settings.

Think of it as a gateway. Tapping the `SettingsButton` opens the door to the settings area.

Our specific use case is simple: we want a button in our app bar that, when pressed, shows a temporary panel where we can change the color theme.

## How does SettingsButton work?

Let's look at the code for the `SettingsButton`.

```dart
class SettingsButton extends StatelessWidget {
  const SettingsButton({
    super.key,
    required this.updateTheme,
    // ... other required parameters
  });

  final void Function(Brightness, Color, double) updateTheme;

  @override
  Widget build(BuildContext context) {
    return IconButton(
      icon: const Icon(Icons.settings),
      onPressed: () {
        // This is where the magic happens!
        // It shows a small panel at the bottom.
        showModalBottomSheet<void>(
          barrierColor: Colors.transparent,
          context: context,
          builder: (BuildContext context) {
            // We'll talk about this 'Settings' widget in the next chapter!
            return Settings(
              // Pass the current settings and the way to update the theme
              selectedColor: selectedColor,
              selectedBrightness: selectedBrightness,
              selectedContrast: selectedContrast,
              updateTheme: updateTheme,
            );
          },
        );
      },
    );
  }
}
```

Let's break down the important parts:

1.  `class SettingsButton extends StatelessWidget`: This tells us that the `SettingsButton` itself doesn't change its appearance based on internal data. It's a static button, though what happens when you press it can change things elsewhere!
2.  `required this.updateTheme`: Remember how in [ColorSchemeExample](01_colorschemeexample_.md) we talked about the `updateTheme` function that actually changes the color settings? The `SettingsButton` needs to *know* about this function so it can pass it along to the settings panel.
3.  `@override Widget build(BuildContext context)`: This is where the `SettingsButton` creates its appearance.
4.  `return IconButton(...)`: This is a common Flutter widget for a button that's just an icon. It's perfect for our settings icon!
5.  `icon: const Icon(Icons.settings)`: This gives the `IconButton` the familiar gear icon used for settings.
6.  `onPressed: () { ... }`: This is the crucial part! This defines what happens *when the button is tapped*.
7.  `showModalBottomSheet<void>(...)`: This is a Flutter function that displays a temporary panel that slides up from the bottom of the screen. This is exactly what we want for our settings panel!
8.  `builder: (BuildContext context) { ... return Settings(...) }`: This part tells `showModalBottomSheet` *what* to show inside the panel. It's showing a widget called `Settings`. We'll dive deeper into this `Settings` widget in the next chapter, [Settings](03_settings_.md).

So, when you tap the `SettingsButton`, it calls `showModalBottomSheet`, which then builds and displays the `Settings` widget at the bottom of the screen. The `SettingsButton` also passes the `updateTheme` function and the *current* theme settings to the `Settings` widget so it knows what the theme is now and how to change it.

## Where does the SettingsButton live?

The `SettingsButton` is placed within the app bar of our main screen ([ColorSchemeExample](01_colorschemeexample_.md)). Look at this small snippet from the `ColorSchemeExample`'s `build` method:

```dart
  @override
  Widget build(BuildContext context) {
    return MaterialApp(
      // ... theme setup ...
      home: Scaffold(
        appBar: AppBar(
          title: const Text('ColorScheme'),
          actions: <Widget>[
            // Here it is!
            SettingsButton(
              selectedColor: selectedColor,
              selectedBrightness: selectedBrightness,
              selectedContrast: selectedContrast,
              updateTheme: updateTheme, // Passing the update function
            ),
          ],
        ),
        // ... rest of the body ...
      ),
    );
  }
```

The `AppBar` widget has an `actions` parameter, which is a list of widgets that appear at the end of the app bar (usually on the right). We simply include our `SettingsButton` in this list, and boom! It appears in the app bar. Notice how we pass the current theme settings (`selectedColor`, `selectedBrightness`, `selectedContrast`) and the `updateTheme` function to the `SettingsButton`. This allows the `SettingsButton` to then pass these along to the `Settings` panel.

## Behind the Scenes

When you tap the `SettingsButton`, here's a simplified sequence of events:

```mermaid
sequenceDiagram
    participant User
    participant SB as SettingsButton
    participant Flutter as Flutter Framework
    participant SettingsPanel as Settings (Widget)

    User->SB: Tap the button!
    SB->Flutter: Call showModalBottomSheet()
    Flutter->SettingsPanel: Build and show the Settings widget
    SettingsPanel-->User: Settings panel appears
```

1.  The user taps the icon button in the app bar.
2.  The `onPressed` function inside the `SettingsButton` is executed.
3.  This function calls `showModalBottomSheet`.
4.  `showModalBottomSheet` in the Flutter framework takes the `builder` function provided by `SettingsButton`.
5.  The `builder` function creates and returns the `Settings` widget.
6.  Flutter displays the `Settings` widget as a sliding panel from the bottom of the screen.

The `SettingsButton`'s only job here is to be the trigger that shows the settings panel. It doesn't manage the settings itself; it just opens the door for the user to interact with a different widget ([Settings](03_settings_.md)) that *does* manage the interaction.

## Conclusion

In this chapter, we explored the `SettingsButton`, the simple button in the app bar that acts as a gateway to the settings panel. We saw how it uses `showModalBottomSheet` to display another widget ([Settings](03_settings_.md)) when tapped and how it receives and passes along the necessary information to update the theme.

We now know how to open the door to change our theme settings. In the next chapter, we'll step through that door and explore the [Settings](03_settings_.md) widget itself to understand how it allows users to change the color theme.

Ready to customize? Let's move on!

[Chapter 3: Settings](03_settings_.md)
---
# Chapter 3: Settings

Welcome back, future Flutter expert! In our last chapter, [SettingsButton](02_settingsbutton_.md), we learned how to add a special button to our app's app bar. This button acts like a secret door, and when we tap it, it opens up a place where we can fine-tune the look of our app. Today, we're going to step through that door and meet the widget that lives there: the `Settings` widget!

## What is the Settings Widget?

Imagine you're sitting in the control room of a spaceship, and you have different dials and switches to adjust the lighting, the view out the window, and other cool things. The `Settings` widget is like that control panel for our app's color theme!

Its main job is to provide a user interface – a bunch of visual controls – that let you change:

*   **Brightness:** Do you want the app to be light or dark?
*   **Seed Color:** What primary color should all other colors in the app be based on?
*   **Contrast Level:** How much difference should there be between colors and text?

And the most important part? When you adjust one of these controls, the `Settings` widget talks back to the main part of our app ([ColorSchemeExample](01_colorschemeexample_.md)) and tells it, "Hey, the user wants to change the theme! Here are the new settings!"

Our specific use case is to build a panel that shows options for brightness, seed color, and contrast, and allows the user to interact with these options to change the app's theme.

## How does the Settings Widget work?

The `Settings` widget is the brain behind the settings panel that slides up from the bottom. It needs to:

1.  **Show the current settings:** When you open the panel, it should show what the current brightness, seed color, and contrast are.
2.  **Allow the user to change settings:** Provide controls (like switches, buttons, and sliders) to change the values.
3.  **Tell the main app about changes:** When a user changes a setting, it needs to communicate these changes back to [ColorSchemeExample](01_colorschemeexample_.md).

Let's look at the code for the `Settings` widget and see how it does this (from `color_scheme.0.dart`):

```dart
class Settings extends StatefulWidget {
  const Settings({
    super.key,
    required this.updateTheme,
    required this.selectedBrightness,
    required this.selectedContrast,
    required this.selectedColor,
  });

  final Brightness selectedBrightness;
  final double selectedContrast;
  final Color selectedColor;

  final void Function(Brightness, Color, double) updateTheme;

  @override
  State<Settings> createState() => _SettingsState();
}
```

*   `class Settings extends StatefulWidget`: Like [ColorSchemeExample](01_colorschemeexample_.md), `Settings` is also a `StatefulWidget`. This is because the settings panel itself needs to *remember* the values you've selected *while the panel is open*. For example, if you flip the light/dark switch, the switch itself needs to visually change its state.
*   `required this.updateTheme`, `selectedBrightness`, `selectedContrast`, `selectedColor`: These are the things that the `SettingsButton` *passes* into the `Settings` widget. Remember how the `SettingsButton` knew the current theme settings and the function to update the theme? It gives all that information to `Settings` when it opens the panel. `updateTheme` is a special function that the `Settings` widget will call to tell [ColorSchemeExample](01_colorschemeexample_.md) about the changes.

Now let's peek inside the `_SettingsState` where the actual controls are built:

```dart
class _SettingsState extends State<Settings> {
  late Brightness selectedBrightness = widget.selectedBrightness;
  late Color selectedColor = widget.selectedColor;
  late double selectedContrast = widget.selectedContrast;

  @override
  Widget build(BuildContext context) {
    return Theme(
      data: Theme.of(context).copyWith(
        // This briefly changes the theme *for the settings panel itself*
        colorScheme: ColorScheme.fromSeed(
          seedColor: selectedColor,
          contrastLevel: selectedContrast,
          brightness: selectedBrightness,
        ),
      ),
      child: ConstrainedBox(
        // ... more layout code ...
        child: Padding(
          // ... padding code ...
          child: ListView(
            children: <Widget>[
              // ... Title ...
              Row(
                children: <Widget>[
                  const Text('Brightness: '),
                  Switch(
                    value: selectedBrightness == Brightness.light,
                    onChanged: (bool value) {
                      setState(() {
                        selectedBrightness = value ? Brightness.light : Brightness.dark;
                      });
                      widget.updateTheme(selectedBrightness, selectedColor, selectedContrast); // <-- Tell the main app!
                    },
                  ),
                ],
              ),
              // ... More controls for ColorSeed and ContrastLevel ...
            ],
          ),
        ),
      ),
    );
  }
}
```

*   `late Brightness selectedBrightness = widget.selectedBrightness;`: When the `Settings` widget is created, it takes the initial brightness, color, and contrast that were passed from the `SettingsButton` and stores them in its own internal state variables. These are the values that the controls on the panel will show and modify *locally*.
*   `return Theme(...)`: This is a neat trick! It temporarily applies a theme *only* to the widgets inside this `Theme` widget. This means the settings panel itself will use the color scheme based on the *currently selected* settings, which is helpful for previewing colors within the panel.
*   `ListView`: We use a `ListView` to arrange our controls vertically. If there are many settings, this allows the user to scroll.
*   `Row(...)`: Each row in the `ListView` holds one setting control (like Brightness, Seed color, or Contrast).
*   `Switch(...)`: For the brightness setting, we use a `Switch`. When you flip the switch, the `onChanged` function is called.
*   `setState(() { ... });`: Inside `onChanged`, we first use `setState`. This updates the `selectedBrightness` variable within the `_SettingsState`. Because we used `setState`, Flutter knows that the UI for this widget needs to be re-drawn. This is why the switch visually flips!
*   `widget.updateTheme(...)`: **This is the most important line!** After updating its own internal state (`selectedBrightness`), the `Settings` widget calls the `updateTheme` function that was passed to it. It sends the *new* values for brightness, color, and contrast to this function. This function lives back in [ColorSchemeExample](01_colorschemeexample_.md), and calling it tells the main app, "Okay, the user made a change, update the whole app's theme!"

The code for the `ColorSeed` selection uses `Wrap` and `IconButton` instead of a `Switch`, and the `Contrast Level` uses a `Row` and a `Slider`, but they all follow the same pattern:

1.  Listen for a change in the control (`onPressed` for buttons, `onChanged` for slider/switch).
2.  Update the local state variable (`selectedColor` or `selectedContrast`) using `setState`.
3.  Call `widget.updateTheme` with the *latest* values of `selectedBrightness`, `selectedColor`, and `selectedContrast` to update the main app theme.

## How Changes Flow

Let's visualize the journey of a change when you interact with the `Settings` widget:

```mermaid
sequenceDiagram
    participant User
    participant SP as Settings Panel (Settings Widget)
    participant SettingsState as _SettingsState
    participant CS as ColorSchemeExample

    User->SP: Flips Brightness Switch
    SP->SettingsState: Calls onChanged
    SettingsState->SettingsState: Updates local selectedBrightness
    SettingsState->SettingsState: Calls setState() (Panel redraws)
    SettingsState->CS: Calls widget.updateTheme(new settings)
    CS->CS: Calls updateTheme()
    CS->CS: Updates internal theme settings
    CS->CS: Calls setState() (Main app redraws)
    CS-->User: Main app shows with new brightness
```

1.  The user flips the switch, taps a color circle, or moves the slider on the `Settings` panel.
2.  The corresponding `onChanged` or `onPressed` function is triggered inside the `_SettingsState`.
3.  The local state variable (like `selectedBrightness`) is updated within the `_SettingsState`.
4.  `setState()` is called, causing the `Settings` widget itself to rebuild and show the visual change (like the switch flipping or the color icon changing).
5.  Critically, `widget.updateTheme()` is called, passing the new settings values to the `updateTheme` function that [ColorSchemeExample](01_colorschemeexample_.md) provided.
6.  The `updateTheme` function inside [ColorSchemeExample](01_colorschemeexample_.md) is executed.
7.  [ColorSchemeExample](01_colorschemeexample_.md) updates its own internal theme settings (`selectedBrightness`, `selectedColor`, `selectedContrast`).
8.  [ColorSchemeExample](01_colorschemeexample_.md) calls its *own* `setState()`.
9.  Because [ColorSchemeExample](01_colorschemeexample_.md) is the main widget controlling the app's theme, the entire app rebuilds using the new `ThemeData` and `ColorScheme`.
10. The user sees the app's theme instantly change!

The `Settings` widget is like a temporary control panel. It manages the user's interaction and then passes the final desired settings back to the main `ColorSchemeExample` to apply the changes everywhere.

## Conclusion

In this chapter, we explored the `Settings` widget, the interactive panel that lets users customize the app's color theme. We saw how it takes the current settings and the `updateTheme` function from the [SettingsButton](02_settingsbutton_.md), provides controls like switches, icon buttons, and a slider, and uses `setState` to manage its own appearance while calling `widget.updateTheme` to communicate changes back to [ColorSchemeExample](01_colorschemeexample_.md).

We now understand how to open the settings and interact with them to request changes. In the next chapter, [ColorSchemeVariantColumn](04_colorschemevariantcolumn_.md), we'll start looking at how those chosen settings translate into the actual different colors that make up our theme and how they are displayed in columns on the main screen.

Ready to see the colors generated? Let's move on!

[Chapter 4: ColorSchemeVariantColumn](04_colorschemevariantcolumn_.md)
---
# Chapter 4: ColorSchemeVariantColumn

Welcome back, color explorer! In the last chapter, [Settings](03_settings_.md), we learned how to open the settings panel and use its controls to pick our desired seed color, brightness, and contrast. Now that we've made our choices, how do we actually *see* how those choices affect the *various ways* our app's colors can be generated? That's where the `ColorSchemeVariantColumn` comes in!

## What is ColorSchemeVariantColumn?

Imagine you've picked a beautiful paint color for your house ([selectedColor] in our previous terms). But paint comes in different finishes: matte, semi-gloss, high-gloss, maybe even a textured finish! Each finish uses the *same* base color but applies it in a slightly different way, creating a distinct look.

In Flutter, the `ColorScheme` can also be generated with different "finishes" or *variants*. These variants use your chosen seed color, brightness, and contrast, but they apply mathematical formulas to create the final set of colors (like primary, secondary, surface, etc.) in unique ways. Some might emphasize certain tones, others might use more neutral shades.

The `ColorSchemeVariantColumn` widget is like a display stand for one of these color variants. Its job is simple: it takes your selected color settings and a specific color scheme variant, generates the full `ColorScheme` for that variant, and then displays all the generated colors in a vertical column so you can see what that particular "finish" looks like.

Our specific use case for this chapter is to display multiple columns on the main screen, with each column showing the generated color scheme for a different variant, using the currently selected seed color, brightness, and contrast.

## How does ColorSchemeVariantColumn work?

The `ColorSchemeVariantColumn` is a pretty straightforward widget. It needs the raw ingredients (the settings you picked) and the specific "recipe" (the variant) to show you the resulting colors.

Let's look at its code from `color_scheme.0.dart`:

```dart
class ColorSchemeVariantColumn extends StatelessWidget {
  const ColorSchemeVariantColumn({
    super.key,
    this.schemeVariant = DynamicSchemeVariant.tonalSpot, // Default variant
    this.brightness = Brightness.light,
    this.contrastLevel = 0.0,
    required this.selectedColor,
  });

  final DynamicSchemeVariant schemeVariant; // The specific variant for THIS column
  final Brightness brightness;
  final double contrastLevel;
  final Color selectedColor; // The seed color you chose

  @override
  Widget build(BuildContext context) {
    // ... rest of the build method
    return Padding( // Simplified for this explanation
      padding: const EdgeInsets.symmetric(horizontal: 15),
      child: ColorSchemeView( // This widget actually displays the colors
        colorScheme: ColorScheme.fromSeed( // Generating the ColorScheme!
          seedColor: selectedColor,
          brightness: brightness,
          contrastLevel: contrastLevel,
          dynamicSchemeVariant: schemeVariant, // Using THIS column's variant
        ),
      ),
    );
  }
}
```

Here's what's happening:

1.  `class ColorSchemeVariantColumn extends StatelessWidget`: This tells us that once the settings and variant are given to it, the `ColorSchemeVariantColumn` itself doesn't change. It just displays something based on the inputs it receives.
2.  `final DynamicSchemeVariant schemeVariant;`: This is the key! Each `ColorSchemeVariantColumn` receives a different `DynamicSchemeVariant`. This tells *this specific column* which color generation rule to use.
3.  `final Brightness brightness;`, `final double contrastLevel;`, `final Color selectedColor;`: These are the global settings that are passed down from [ColorSchemeExample](01_colorschemeexample_.md). Every `ColorSchemeVariantColumn` uses the *same* currently selected settings for these.
4.  `ColorScheme.fromSeed(...)`: This is the powerful part we first saw in [ColorSchemeExample](01_colorschemeexample_.md). It takes the seed color, brightness, and contrast.
5.  `dynamicSchemeVariant: schemeVariant,`: **This is where the variant is applied!** Instead of using the default variant, *this specific column* uses the `schemeVariant` that was passed to it. This tells `ColorScheme.fromSeed` *HOW* to generate the full set of colors using the provided inputs.
6.  `ColorSchemeView(...)`: The `ColorScheme.fromSeed` function spits out a complete `ColorScheme` object (a big list of all the primary, secondary, surface colors, etc.). The `ColorSchemeVariantColumn` then passes this generated `ColorScheme` to the `ColorSchemeView` widget, which is responsible for actually drawing all those color blocks and labels on the screen. (We'll look at `ColorSchemeView` in the next chapter!)

So, each `ColorSchemeVariantColumn` is essentially instructed to: "Take these global settings (seed color, brightness, contrast) and this specific generation rule (variant), create the set of colors, and show them."

## Where does ColorSchemeVariantColumn live?

The `ColorSchemeExample` widget (our main controller) is responsible for creating multiple instances of `ColorSchemeVariantColumn`, one for each available variant.

Look at this snippet inside the `_ColorSchemeExampleState`'s `build` method (from `color_scheme.0.dart`):

```dart
  @override
  Widget build(BuildContext context) {
    return MaterialApp(
      // ... theme setup ...
      home: Scaffold(
        // ... app bar ...
        body: SingleChildScrollView( // Allows scrolling horizontally
          child: Padding(
            // ... padding ...
            child: Column(
              // ... other widgets ...
              children: <Widget>[
                SingleChildScrollView(
                  scrollDirection: Axis.horizontal,
                  child: Row( // Arranges children horizontally
                    children:
                        List<Widget>.generate(schemeVariants.length, (int index) {
                          // Create a ColorSchemeVariantColumn for EACH variant
                          return ColorSchemeVariantColumn(
                            selectedColor: selectedColor, // Pass global settings
                            brightness: selectedBrightness,
                            schemeVariant: schemeVariants[index], // Pass THIS variant
                            contrastLevel: selectedContrast,
                          );
                        }).toList(),
                  ),
                ),
              ],
            ),
          ),
        ),
      ),
    );
  }
}
```

*   `SingleChildScrollView(scrollDirection: Axis.horizontal)`: This allows us to scroll the columns left and right if there are too many to fit on the screen at once.
*   `Row(...)`: The `Row` widget places its children next to each other horizontally.
*   `List<Widget>.generate(schemeVariants.length, (int index) { ... })`: This is a neat way to automatically create a list of widgets. `schemeVariants` is a list of all the available `DynamicSchemeVariant` options. This code generates one `ColorSchemeVariantColumn` for *each* variant in that list.
*   `return ColorSchemeVariantColumn(...)`: Inside the `generate` function, we create a `ColorSchemeVariantColumn`. We pass the global settings (`selectedColor`, `selectedBrightness`, `selectedContrast`) that the `_ColorSchemeExampleState` is currently holding. Crucially, we pass a *different* `schemeVariant` (`schemeVariants[index]`) to each column we create.

This means if there are 5 different color scheme variants, the `ColorSchemeExample` creates 5 `ColorSchemeVariantColumn` widgets. Each column gets the *same* seed color, brightness, and contrast, but a *different* variant instruction. They then each generate their own `ColorScheme` according to their variant and display it.

## Behind the Scenes

When [Settings](03_settings_.md) calls `widget.updateTheme` in [ColorSchemeExample](01_colorschemeexample_.md), here's what happens related to the `ColorSchemeVariantColumn`s:

```mermaid
sequenceDiagram
    participant User
    participant Settings as Settings Panel
    participant CS as ColorSchemeExample
    participant Col as ColorSchemeVariantColumn
    participant View as ColorSchemeView
    participant CSFS as ColorScheme.fromSeed

    User->Settings: Changes Seed Color
    Settings->CS: Calls updateTheme(new color)
    CS->CS: Updates selectedColor state
    CS->CS: Calls setState() (CS redraws)
    CS->Row: Rebuilds Row of Columns
    Row->Col: Creates new ColorSchemeVariantColumn instances
    Col->CSFS: Calls ColorScheme.fromSeed with new color and its variant
    CSFS-->Col: Returns new ColorScheme
    Col->View: Passes new ColorScheme to ColorSchemeView
    View-->User: Columns update with new colors based on their variants
```

1.  The user changes a setting (e.g., the seed color) in the [Settings](03_settings_.md) panel.
2.  [Settings](03_settings_.md) calls `updateTheme` on the `ColorSchemeExample`.
3.  `ColorSchemeExample` updates its internal state (`selectedColor`, etc.) and calls its own `setState()`.
4.  `ColorSchemeExample` rebuilds its `build` method, which includes rebuilding the `Row` that holds the `ColorSchemeVariantColumn`s.
5.  The `Row` tells Flutter to create new `ColorSchemeVariantColumn` widgets (or update existing ones if optimized).
6.  Each `ColorSchemeVariantColumn` widget receives the *new* `selectedColor` (and other settings) *plus* its specific `schemeVariant`.
7.  Inside each `ColorSchemeVariantColumn`, `ColorScheme.fromSeed` is called using the new color and the column's specific variant.
8.  `ColorScheme.fromSeed` calculates and returns a complete `ColorScheme` based on these inputs.
9.  Each `ColorSchemeVariantColumn` passes its newly generated `ColorScheme` to its child `ColorSchemeView`.
10. The `ColorSchemeView` for each column updates, drawing the color blocks for that specific variant using the newly generated `ColorScheme`.
11. The user sees all the columns instantly update to show the different variants of the color scheme generated from their new seed color!

This shows how the `ColorSchemeVariantColumn` acts as an intermediate step, taking the global settings and a specific variant, calculating the related `ColorScheme`, and then passing it along to be displayed.

## Conclusion

In this chapter, we introduced the `ColorSchemeVariantColumn`, a widget responsible for displaying the colors generated by a *specific* color scheme variant. We saw how it receives the global color settings (seed color, brightness, contrast) from [ColorSchemeExample](01_colorschemeexample_.md) along with its own unique `DynamicSchemeVariant`. It uses these inputs to generate a complete `ColorScheme` for that variant using `ColorScheme.fromSeed` and then passes this generated scheme to a `ColorSchemeView` to be displayed. [ColorSchemeExample](01_colorschemeexample_.md) creates multiple instances of `ColorSchemeVariantColumn` to show you side-by-side comparisons of how different variants look with your chosen settings.

We now understand how individual columns are responsible for a single variant. In the next chapter, [ColorSchemeView](05_colorschemeview_.md), we'll dive into the widget that `ColorSchemeVariantColumn` uses to actually *display* all those different colors within each column.

Ready to see how the colors are put on display? Let's move on!

[Chapter 5: ColorSchemeView](05_colorschemeview_.md)

Relevant Code Snippets (Code itself remains unchanged):
--- File: color_scheme.0.dart ---
// Copyright 2014 The Flutter Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

import 'package:flutter/material.dart';

/// Flutter code sample for [ColorScheme].

const Widget divider = SizedBox(height: 10);

void main() => runApp(const ColorSchemeExample());

class ColorSchemeExample extends StatefulWidget {
  const ColorSchemeExample({super.key});

  @override
  State<ColorSchemeExample> createState() => _ColorSchemeExampleState();
}

class _ColorSchemeExampleState extends State<ColorSchemeExample> {
  Color selectedColor = ColorSeed.baseColor.color;
  Brightness selectedBrightness = Brightness.light;
  double selectedContrast = 0.0;
  static const List<DynamicSchemeVariant> schemeVariants = DynamicSchemeVariant.values;

  void updateTheme(Brightness brightness, Color color, double contrastLevel) {
    setState(() {
      selectedBrightness = brightness;
      selectedColor = color;
      selectedContrast = contrastLevel;
    });
  }

  @override
  Widget build(BuildContext context) {
    return MaterialApp(
      debugShowCheckedModeBanner: false,
      theme: ThemeData(
        colorScheme: ColorScheme.fromSeed(
          seedColor: selectedColor,
          brightness: selectedBrightness,
          contrastLevel: selectedContrast,
        ),
      ),
      home: Scaffold(
        appBar: AppBar(
          title: const Text('ColorScheme'),
          actions: <Widget>[
            SettingsButton(
              selectedColor: selectedColor,
              selectedBrightness: selectedBrightness,
              selectedContrast: selectedContrast,
              updateTheme: updateTheme,
            ),
          ],
        ),
        body: SingleChildScrollView(
          child: Padding(
            padding: const EdgeInsets.only(top: 5),
            child: Column(
              crossAxisAlignment: CrossAxisAlignment.start,
              children: <Widget>[
                SingleChildScrollView(
                  scrollDirection: Axis.horizontal,
                  child: Row(
                    children:
                        List<Widget>.generate(schemeVariants.length, (int index) {
                          return ColorSchemeVariantColumn(
                            selectedColor: selectedColor,
                            brightness: selectedBrightness,
                            schemeVariant: schemeVariants[index],
                            contrastLevel: selectedContrast,
                          );
                        }).toList(),
                  ),
                ),
              ],
            ),
          ),
        ),
      ),
    );
  }
}

class Settings extends StatefulWidget {
  const Settings({
    super.key,
    required this.updateTheme,
    required this.selectedBrightness,
    required this.selectedContrast,
    required this.selectedColor,
  });

  final Brightness selectedBrightness;
  final double selectedContrast;
  final Color selectedColor;

  final void Function(Brightness, Color, double) updateTheme;

  @override
  State<Settings> createState() => _SettingsState();
}

class _SettingsState extends State<Settings> {
  late Brightness selectedBrightness = widget.selectedBrightness;
  late Color selectedColor = widget.selectedColor;
  late double selectedContrast = widget.selectedContrast;

  @override
  Widget build(BuildContext context) {
    return Theme(
      data: Theme.of(context).copyWith(
        colorScheme: ColorScheme.fromSeed(
          seedColor: selectedColor,
          contrastLevel: selectedContrast,
          brightness: selectedBrightness,
        ),
      ),
      child: ConstrainedBox(
        constraints: const BoxConstraints(maxHeight: 200),
        child: Padding(
          padding: const EdgeInsets.all(20.0),
          child: ListView(
            children: <Widget>[
              Center(child: Text('Settings', style: Theme.of(context).textTheme.titleLarge)),
              Row(
                children: <Widget>[
                  const Text('Brightness: '),
                  Switch(
                    value: selectedBrightness == Brightness.light,
                    onChanged: (bool value) {
                      setState(() {
                        selectedBrightness = value ? Brightness.light : Brightness.dark;
                      });
                      widget.updateTheme(selectedBrightness, selectedColor, selectedContrast);
                    },
                  ),
                ],
              ),
              Wrap(
                crossAxisAlignment: WrapCrossAlignment.center,
                children: <Widget>[
                  const Text('Seed color: '),
                  ...List<Widget>.generate(ColorSeed.values.length, (int index) {
                    final Color itemColor = ColorSeed.values[index].color;
                    return IconButton(
                      icon:
                          selectedColor == ColorSeed.values[index].color
                              ? Icon(Icons.circle, color: itemColor)
                              : Icon(Icons.circle_outlined, color: itemColor),
                      onPressed: () {
                        setState(() {
                          selectedColor = itemColor;
                        });
                        widget.updateTheme(selectedBrightness, selectedColor, selectedContrast);
                      },
                    );
                  }),
                ],
              ),
              Row(
                children: <Widget>[
                  const Text('Contrast level: '),
                  Expanded(
                    child: Slider(
                      divisions: 4,
                      label: selectedContrast.toString(),
                      min: -1,
                      value: selectedContrast,
                      onChanged: (double value) {
                        setState(() {
                          selectedContrast = value;
                        });
                        widget.updateTheme(selectedBrightness, selectedColor, selectedContrast);
                      },
                    ),
                  ),
                ],
              ),
            ],
          ),
        ),
      ),
    );
  }
}

class ColorSchemeVariantColumn extends StatelessWidget {
  const ColorSchemeVariantColumn({
    super.key,
    this.schemeVariant = DynamicSchemeVariant.tonalSpot,
    this.brightness = Brightness.light,
    this.contrastLevel = 0.0,
    required this.selectedColor,
  });

  final DynamicSchemeVariant schemeVariant;
  final Brightness brightness;
  final double contrastLevel;
  final Color selectedColor;

  @override
  Widget build(BuildContext context) {
    return ConstrainedBox(
      constraints: const BoxConstraints.tightFor(width: 250),
      child: Column(
        children: <Widget>[
          Padding(
            padding: const EdgeInsets.symmetric(vertical: 15),
            child: Text(
              schemeVariant.name == 'tonalSpot'
                  ? '${schemeVariant.name} (Default)'
                  : schemeVariant.name,
              style: const TextStyle(fontWeight: FontWeight.bold),
            ),
          ),
          Padding(
            padding: const EdgeInsets.symmetric(horizontal: 15),
            child: ColorSchemeView(
              colorScheme: ColorScheme.fromSeed(
                seedColor: selectedColor,
                brightness: brightness,
                contrastLevel: contrastLevel,
                dynamicSchemeVariant: schemeVariant,
              ),
            ),
          ),
        ],
      ),
    );
  }
}

class ColorSchemeView extends StatelessWidget {
  const ColorSchemeView({super.key, required this.colorScheme});

  final ColorScheme colorScheme;

  @override
  Widget build(BuildContext context) {
    return Column(
      children: <Widget>[
        ColorGroup(
          children: <ColorChip>[
            ColorChip('primary', colorScheme.primary, colorScheme.onPrimary),
            ColorChip('onPrimary', colorScheme.onPrimary, colorScheme.primary),
            ColorChip(
              'primaryContainer',
              colorScheme.primaryContainer,
              colorScheme.onPrimaryContainer,
            ),
            ColorChip(
              'onPrimaryContainer',
              colorScheme.onPrimaryContainer,
              colorScheme.primaryContainer,
            ),
          ],
        ),
        divider,
        ColorGroup(
          children: <ColorChip>[
            ColorChip('primaryFixed', colorScheme.primaryFixed, colorScheme.onPrimaryFixed),
            ColorChip('onPrimaryFixed', colorScheme.onPrimaryFixed, colorScheme.primaryFixed),
            ColorChip(
              'primaryFixedDim',
              colorScheme.primaryFixedDim,
              colorScheme.onPrimaryFixedVariant,
            ),
            ColorChip(
              'onPrimaryFixedVariant',
              colorScheme.onPrimaryFixedVariant,
              colorScheme.primaryFixedDim,
            ),
          ],
        ),
        divider,
        ColorGroup(
          children: <ColorChip>[
            ColorChip('secondary', colorScheme.secondary, colorScheme.onSecondary),
            ColorChip('onSecondary', colorScheme.onSecondary, colorScheme.secondary),
            ColorChip(
              'secondaryContainer',
              colorScheme.secondaryContainer,
              colorScheme.onSecondaryContainer,
            ),
            ColorChip(
              'onSecondaryContainer',
              colorScheme.onSecondaryContainer,
              colorScheme.secondaryContainer,
            ),
          ],
        ),
        divider,
        ColorGroup(
          children: <ColorChip>[
            ColorChip('secondaryFixed', colorScheme.secondaryFixed, colorScheme.onSecondaryFixed),
            ColorChip('onSecondaryFixed', colorScheme.onSecondaryFixed, colorScheme.secondaryFixed),
            ColorChip(
              'secondaryFixedDim',
              colorScheme.secondaryFixedDim,
              colorScheme.onSecondaryFixedVariant,
            ),
            ColorChip(
              'onSecondaryFixedVariant',
              colorScheme.onSecondaryFixedVariant,
              colorScheme.secondaryFixedDim,
            ),
          ],
        ),
        divider,
        ColorGroup(
          children: <ColorChip>[
            ColorChip('tertiary', colorScheme.tertiary, colorScheme.onTertiary),
            ColorChip('onTertiary', colorScheme.onTertiary, colorScheme.tertiary),
            ColorChip(
              'tertiaryContainer',
              colorScheme.tertiaryContainer,
              colorScheme.onTertiaryContainer,
            ),
            ColorChip(
              'onTertiaryContainer',
              colorScheme.onTertiaryContainer,
              colorScheme.tertiaryContainer,
            ),
          ],
        ),
        divider,
        ColorGroup(
          children: <ColorChip>[
            ColorChip('tertiaryFixed', colorScheme.tertiaryFixed, colorScheme.onTertiaryFixed),
            ColorChip('onTertiaryFixed', colorScheme.onTertiaryFixed, colorScheme.tertiaryFixed),
            ColorChip(
              'tertiaryFixedDim',
              colorScheme.tertiaryFixedDim,
              colorScheme.onTertiaryFixedVariant,
            ),
            ColorChip(
              'onTertiaryFixedVariant',
              colorScheme.onTertiaryFixedVariant,
              colorScheme.tertiaryFixedDim,
            ),
          ],
        ),
        divider,
        ColorGroup(
          children: <ColorChip>[
            ColorChip('error', colorScheme.error, colorScheme.onError),
            ColorChip('onError', colorScheme.onError, colorScheme.error),
            ColorChip('errorContainer', colorScheme.errorContainer, colorScheme.onErrorContainer),
            ColorChip('onErrorContainer', colorScheme.onErrorContainer, colorScheme.errorContainer),
          ],
        ),
        divider,
        ColorGroup(
          children: <ColorChip>[
            ColorChip('surfaceDim', colorScheme.surfaceDim, colorScheme.onSurface),
            ColorChip('surface', colorScheme.surface, colorScheme.onSurface),
            ColorChip('surfaceBright', colorScheme.surfaceBright, colorScheme.onSurface),
            ColorChip(
              'surfaceContainerLowest',
              colorScheme.surfaceContainerLowest,
              colorScheme.onSurface,
            ),
            ColorChip(
              'surfaceContainerLow',
              colorScheme.surfaceContainerLow,
              colorScheme.onSurface,
            ),
            ColorChip('surfaceContainer', colorScheme.surfaceContainer, colorScheme.onSurface),
            ColorChip(
              'surfaceContainerHigh',
              colorScheme.surfaceContainerHigh,
              colorScheme.onSurface,
            ),
            ColorChip(
              'surfaceContainerHighest',
              colorScheme.surfaceContainerHighest,
              colorScheme.onSurface,
            ),
            ColorChip('onSurface', colorScheme.onSurface, colorScheme.surface),
            ColorChip(
              'onSurfaceVariant',
              colorScheme.onSurfaceVariant,
              colorScheme.surfaceContainerHighest,
            ),
          ],
        ),
        divider,
        ColorGroup(
          children: <ColorChip>[
            ColorChip('outline', colorScheme.outline, null),
            ColorChip('shadow', colorScheme.shadow, null),
            ColorChip('inverseSurface', colorScheme.inverseSurface, colorScheme.onInverseSurface),
            ColorChip('onInverseSurface', colorScheme.onInverseSurface, colorScheme.inverseSurface),
            ColorChip('inversePrimary', colorScheme.inversePrimary, colorScheme.primary),
          ],
        ),
      ],
    );
  }
}

class ColorGroup extends StatelessWidget {
  const ColorGroup({super.key, required this.children});

  final List<Widget> children;

  @override
  Widget build(BuildContext context) {
    return RepaintBoundary(
      child: Card(clipBehavior: Clip.antiAlias, child: Column(children: children)),
    );
  }
}

class ColorChip extends StatelessWidget {
  const ColorChip(this.label, this.color, this.onColor, {super.key});

  final Color color;
  final Color? onColor;
  final String label;

  static Color contrastColor(Color color) {
    final Brightness brightness = ThemeData.estimateBrightnessForColor(color);
    return brightness == Brightness.dark ? Colors.white : Colors.black;
  }

  @override
  Widget build(BuildContext context) {
    final Color labelColor = onColor ?? contrastColor(color);
    return ColoredBox(
      color: color,
      child: Padding(
        padding: const EdgeInsets.all(16),
        child: Row(
          children: <Expanded>[Expanded(child: Text(label, style: TextStyle(color: labelColor)))],
        ),
      ),
    );
  }
}

enum ColorSeed {
  baseColor('M3 Baseline', Color(0xff6750a4)),
  indigo('Indigo', Colors.indigo),
  blue('Blue', Colors.blue),
  teal('Teal', Colors.teal),
  green('Green', Colors.green),
  yellow('Yellow', Colors.yellow),
  orange('Orange', Colors.orange),
  deepOrange('Deep Orange', Colors.deepOrange),
  pink('Pink', Colors.pink),
  brightBlue('Bright Blue', Color(0xFF0000FF)),
  brightGreen('Bright Green', Color(0xFF00FF00)),
  brightRed('Bright Red', Color(0xFFFF0000));

  const ColorSeed(this.label, this.color);
  final String label;
  final Color color;
}

class SettingsButton extends StatelessWidget {
  const SettingsButton({
    super.key,
    required this.updateTheme,
    required this.selectedBrightness,
    required this.selectedContrast,
    required this.selectedColor,
  });

  final Brightness selectedBrightness;
  final double selectedContrast;
  final Color selectedColor;

  final void Function(Brightness, Color, double) updateTheme;

  @override
  Widget build(BuildContext context) {
    return IconButton(
      icon: const Icon(Icons.settings),
      onPressed: () {
        showModalBottomSheet<void>(
          barrierColor: Colors.transparent,
          context: context,
          builder: (BuildContext context) {
            return Settings(
              selectedColor: selectedColor,
              selectedBrightness: selectedBrightness,
              selectedContrast: selectedContrast,
              updateTheme: updateTheme,
            );
          },
        );
      },
    );
  }
}


Instructions for the chapter (Generate content in English unless specified otherwise):
- Start with a clear heading (e.g., `# Chapter 5: ColorSchemeView
`). Use the provided concept name.

- If this is not the first chapter, begin with a brief transition from the previous chapter, referencing it with a proper Markdown link using its name.

- Begin with a high-level motivation explaining what problem this abstraction solves. Start with a central use case as a concrete example. The whole chapter should guide the reader to understand how to solve this use case. Make it very minimal and friendly to beginners.

- If the abstraction is complex, break it down into key concepts. Explain each concept one-by-one in a very beginner-friendly way.

- Explain how to use this abstraction to solve the use case. Give example inputs and outputs for code snippets (if the output isn't values, describe at a high level what will happen).

- Each code block should be BELOW 10 lines! If longer code blocks are needed, break them down into smaller pieces and walk through them one-by-one. Aggresively simplify the code to make it minimal. Use comments to skip non-important implementation details. Each code block should have a beginner friendly explanation right after it.

- Describe the internal implementation to help understand what's under the hood. First provide a non-code or code-light walkthrough on what happens step-by-step when the abstraction is called. It's recommended to use a simple sequenceDiagram with a dummy example - keep it minimal with at most 5 participants to ensure clarity. If participant name has space, use: `participant QP as Query Processing`. .

- Then dive deeper into code for the internal implementation with references to files. Provide example code blocks, but make them similarly simple and beginner-friendly. Explain.

- IMPORTANT: When you need to refer to other core abstractions covered in other chapters, ALWAYS use proper Markdown links like this: [Chapter Title](filename.md). Use the Complete Tutorial Structure above to find the correct filename and the chapter title. Translate the surrounding text.

- Use mermaid diagrams to illustrate complex concepts (```mermaid``` format). .

- Heavily use analogies and examples throughout to help beginners understand.

- End the chapter with a brief conclusion that summarizes what was learned and provides a transition to the next chapter. If there is a next chapter, use a proper Markdown link: [Next Chapter Title](next_chapter_filename).

- Ensure the tone is welcoming and easy for a newcomer to understand.

- Output *only* the Markdown content for this chapter.

Now, directly provide a super beginner-friendly Markdown output (DON'T need ```markdown``` tags):

2025-05-28 16:30:58,123 - INFO - RESPONSE: # Chapter 5: ColorSchemeView

Welcome back, color connoisseur! In our previous chapter, [ColorSchemeVariantColumn](04_colorschemevariantcolumn_.md), we saw how each column on our screen represents a different *way* of generating a set of colors from our chosen settings. Each column is like a unique paint sample board for a specific "finish" of our color scheme. But how do we actually *see* all the individual colors *within* that generated scheme on that board? That's the job of the `ColorSchemeView`!

## What is ColorSchemeView?

Imagine you open up a comprehensive paint color chart. It doesn't just show you the main color; it shows you all the related shades – the light ones, the dark ones, the accent colors that go with it, maybe even the color for the trim.

The `ColorSchemeView` widget is exactly like that color chart for a `ColorScheme`. It takes a complete `ColorScheme` (the full set of colors generated by [ColorSchemeVariantColumn](04_colorschemevariantcolumn_.md)) and lays out *all* of its individual color properties one by one. It shows you the swatch for `primary`, the swatch for `secondary`, the swatch for `surface`, and so on, along with their names. It's the widget that visually presents the *entire palette* generated by a particular variant.

Our specific use case is to display all the colors within a given `ColorScheme` in a clear, organized list within each variant column on our screen.

## How does ColorSchemeView work?

The `ColorSchemeView` is quite simple at its core. Its main requirement is the `ColorScheme` object itself. It doesn't generate colors; it just displays the colors that have already been generated.

Let's peek at the `ColorSchemeView` code (from `color_scheme.0.dart`):

```dart
class ColorSchemeView extends StatelessWidget {
  const ColorSchemeView({super.key, required this.colorScheme});

  final ColorScheme colorScheme; // It only needs the full ColorScheme!

  @override
  Widget build(BuildContext context) {
    return Column( // Arranges its children vertically
      children: <Widget>[
        // Displaying groups of related colors...
        ColorGroup( // We'll look at ColorGroup later
          children: <ColorChip>[ // We'll look at ColorChip later
            ColorChip('primary', colorScheme.primary, colorScheme.onPrimary),
            ColorChip('onPrimary', colorScheme.onPrimary, colorScheme.primary),
            // ... more ColorChip widgets for primaryContainer, onPrimaryContainer
          ],
        ),
        divider, // Just a small space
        ColorGroup(
          children: <ColorChip>[
            ColorChip('secondary', colorScheme.secondary, colorScheme.onSecondary),
            // ... more secondary colors
          ],
        ),
        divider,
        // ... ColorGroups for tertiary, error, surface, outline, etc.
      ],
    );
  }
}
```

Here's the breakdown:

1.  `class ColorSchemeView extends StatelessWidget`: Just like [ColorSchemeVariantColumn](04_colorschemevariantcolumn_.md), `ColorSchemeView` displays information given to it. It doesn't change its appearance based on internal state.
2.  `required this.colorScheme`: This confirms that the `ColorSchemeView` needs one thing: a complete `ColorScheme` object. This is the object created by `ColorScheme.fromSeed` inside the [ColorSchemeVariantColumn](04_colorschemevariantcolumn_.md).
3.  `return Column(...)`: The main layout for the `ColorSchemeView` is a `Column`, because we want to list all the color swatches vertically.
4.  `ColorGroup(...)`: Notice that the colors aren't listed individually right inside the `Column`. They are grouped together using a widget called `ColorGroup`. This helps organize the display, putting related colors (like primary and its variations) together. We'll explore `ColorGroup` in a future chapter, [ColorGroup](06_colorgroup_.md).
5.  `ColorChip(...)`: Inside each `ColorGroup`, we see many instances of the `ColorChip` widget. Each `ColorChip` is responsible for displaying a *single* color swatch with its name. For example, `ColorChip('primary', colorScheme.primary, colorScheme.onPrimary)` tells a `ColorChip` to label itself 'primary', show the color defined by `colorScheme.primary`, and use `colorScheme.onPrimary` for the text color on that swatch. We'll learn more about `ColorChip` in chapter [ColorChip](07_colorchip_.md).

So, the `ColorSchemeView` takes the full `ColorScheme`, uses `ColorGroup` to organize it, and uses `ColorChip` to display each individual color and its name.

## How is ColorSchemeView Used?

As we saw in the previous chapter, [ColorSchemeVariantColumn](04_colorschemevariantcolumn_.md) creates the `ColorScheme` based on the selected settings and its specific variant. It then passes this generated `ColorScheme` to a `ColorSchemeView`.

Look at the relevant part of the [ColorSchemeVariantColumn](04_colorschemevariantcolumn_.md) build method again:

```dart
class ColorSchemeVariantColumn extends StatelessWidget {
  // ... fields and constructor ...

  @override
  Widget build(BuildContext context) {
    return ConstrainedBox(
      // ... layout constraints ...
      child: Column(
        children: <Widget>[
          // ... Variant name text ...
          Padding(
            padding: const EdgeInsets.symmetric(horizontal: 15),
            child: ColorSchemeView( // Here's where it's used!
              colorScheme: ColorScheme.fromSeed( // The generated scheme
                seedColor: selectedColor,
                brightness: brightness,
                contrastLevel: contrastLevel,
                dynamicSchemeVariant: schemeVariant,
              ),
            ),
          ),
        ],
      ),
    );
  }
}
```

The `ColorSchemeVariantColumn` is the one that says: "Okay, I figured out what all the colors are for *my* variant based on the seed color and brightness. Now, `ColorSchemeView`, please show these colors!" And it passes the result of `ColorScheme.fromSeed` directly into the `colorScheme` property of the `ColorSchemeView`.

## Behind the Scenes

When a setting changes and a new `ColorScheme` is generated by a [ColorSchemeVariantColumn](04_colorschemevariantcolumn_.md), here's what happens concerning the `ColorSchemeView`:

```mermaid
sequenceDiagram
    participant CSVC as ColorSchemeVariantColumn
    participant CSFS as ColorScheme.fromSeed
    participant CSV as ColorSchemeView
    participant CG as ColorGroup
    participant CC as ColorChip

    CSVC->CSFS: Call ColorScheme.fromSeed (with new settings/variant)
    CSFS-->CSVC: Return new ColorScheme object
    CSVC->CSV: Create new ColorSchemeView instance (passing the new ColorScheme)
    CSV->CSV: Build its Column structure
    CSV->CG: Create ColorGroup widgets (passing parts of the ColorScheme implicitely)
    CG->CC: Create ColorChip widgets (passing individual colors and names)
    CC-->User: Displays the color swatch and name
```

1.  The `ColorSchemeVariantColumn` for a specific variant and the updated settings calls `ColorScheme.fromSeed`.
2.  `ColorScheme.fromSeed` calculates and returns a new `ColorScheme` object containing all the specific colors for that variant and those settings.
3.  The `ColorSchemeVariantColumn` creates a new `ColorSchemeView` widget and gives it this brand new `ColorScheme` object.
4.  The `ColorSchemeView` starts building its layout (the `Column`).
5.  As it builds, it creates `ColorGroup` widgets for different categories of colors.
6.  Each `ColorGroup` then creates multiple `ColorChip` widgets. It passes the specific color property (like `colorScheme.primary`, `colorScheme.secondaryContainer`, etc.) to each `ColorChip`.
7.  Each `ColorChip` then draws its small colored box and the corresponding text label.
8.  The user sees the entire list of colors within that variant column update immediately to show the new generated palette.

The `ColorSchemeView` acts as the presentation layer. It takes the complex data structure that is the `ColorScheme` and organizes and visualizes it using smaller building block widgets (`ColorGroup` and `ColorChip`).

## Conclusion

In this chapter, we focused on the `ColorSchemeView`, the widget responsible for visually displaying all the individual colors contained within a `ColorScheme`. We saw how it receives a complete `ColorScheme` object (generated by [ColorSchemeVariantColumn](04_colorschemevariantcolumn_.md)) and uses helper widgets like `ColorGroup` and `ColorChip` to present a clear, itemized list of every color swatch along with its name. It's the key to seeing the full palette of a generated theme variant.

We now know how the different color palettes are generated and displayed. In the next chapter, [ColorGroup](06_colorgroup_.md), we'll zoom in on one of the helpers that `ColorSchemeView` uses to organize the display of these colors.

Ready to learn about organizing colors? Let's move on!

[Chapter 6: ColorGroup](06_colorgroup_.md)
2025-05-28 16:30:58,126 - INFO - PROMPT: 
Write a very beginner-friendly tutorial chapter (in Markdown format) for the project `flutter` about the concept: "ColorGroup
". This is Chapter 6.

Concept Details:
- Name: ColorGroup

- Description:
A simple container to group together multiple `ColorChip` widgets for better organization and visual presentation.
It's like a frame or a box used to neatly display a set of related paint chip samples together.


Complete Tutorial Structure:
1. [ColorSchemeExample
](01_colorschemeexample_.md)
2. [SettingsButton
](02_settingsbutton_.md)
3. [Settings
](03_settings_.md)
4. [ColorSchemeVariantColumn
](04_colorschemevariantcolumn_.md)
5. [ColorSchemeView
](05_colorschemeview_.md)
6. [ColorGroup
](06_colorgroup_.md)
7. [ColorChip
](07_colorchip_.md)
8. [ColorSeed
](08_colorseed_.md)

Context from previous chapters:
# Chapter 1: ColorSchemeExample

Welcome, aspiring Flutter developer! In this chapter, we're going to meet the main conductor of our app's visual symphony: `ColorSchemeExample`. Think of this like the main boss or the central hub of our application. It's the widget that gets everything started and keeps track of the overall look and feel, specifically the colors!

## What is ColorSchemeExample?

Imagine you're building a house, and you want to decide on the paint colors, the brightness of the rooms, and how much contrast you want between different elements. The `ColorSchemeExample` is like the architect who holds the master plan for all these color decisions. It decides things like:

*   **What are the main colors of the app?**
*   **Should the app be light or dark?** (Brightness)
*   **How much difference should there be between colors and text?** (Contrast)

And the best part? If you change any of these decisions (like choosing a different main color), the `ColorSchemeExample` knows and makes sure the *whole* house (your app) updates to the new plan.

Our specific use case for this chapter is to see how `ColorSchemeExample` manages the initial color settings of our app.

## How does ColorSchemeExample work?

Let's take a look at the main part of the `ColorSchemeExample` code. Don't worry about understanding every single line right away. We'll break it down.

```dart
void main() => runApp(const ColorSchemeExample());

class ColorSchemeExample extends StatefulWidget {
  const ColorSchemeExample({super.key});

  @override
  State<ColorSchemeExample> createState() => _ColorSchemeExampleState();
}

class _ColorSchemeExampleState extends State<ColorSchemeExample> {
  Color selectedColor = ColorSeed.baseColor.color;
  Brightness selectedBrightness = Brightness.light;
  double selectedContrast = 0.0;
  // ... other code
}
```

This code shows us a couple of key things:

1.  `void main() => runApp(const ColorSchemeExample());`: This is where our app starts! It tells Flutter to run the `ColorSchemeExample` widget.
2.  `ColorSchemeExample extends StatefulWidget`: This means our `ColorSchemeExample` can change over time. If you change the color settings, the widget can rebuild itself to show the new colors.
3.  `_ColorSchemeExampleState`: This is where the `ColorSchemeExample` keeps track of its state, or its current settings. Notice `selectedColor`, `selectedBrightness`, and `selectedContrast`. These are the main color-related decisions it's currently holding.

So, when the app first starts, `ColorSchemeExample` sets up its initial color decisions (like the default primary color, brightness, and contrast).

## Setting up the Theme

The `ColorSchemeExample` also uses these color decisions to set the overall theme of the app. Let's look at the `build` method:

```dart
@override
Widget build(BuildContext context) {
  return MaterialApp(
    debugShowCheckedModeBanner: false,
    theme: ThemeData(
      colorScheme: ColorScheme.fromSeed(
        seedColor: selectedColor,
        brightness: selectedBrightness,
        contrastLevel: selectedContrast,
      ),
    ),
    // ... rest of the build method
  );
}
```

Here's what's happening:

*   `return MaterialApp(...)`: This is the basic structure for a Flutter app. It provides important things like navigation and theming.
*   `theme: ThemeData(...)`: This is where we define the visual theme for our app.
*   `colorScheme: ColorScheme.fromSeed(...)`: This is a super helpful way to create a whole set of colors for your app based on just one "seed" color. `ColorSchemeExample` uses its `selectedColor`, `selectedBrightness`, and `selectedContrast` to generate a complete `ColorScheme`. This `ColorScheme` contains many different color definitions (like primary, secondary, surface, etc.) that are all related to the seed color and brightness.

Essentially, `ColorSchemeExample` takes some basic color decisions and uses them to create a full `ColorScheme` that the rest of the app can use.

## How Changes Happen (Behind the Scenes)

We said `ColorSchemeExample` is like the conductor. When you make a change (like picking a new color from a settings menu, which we'll see in later chapters), here's a simplified look at what happens:

```mermaid
sequenceDiagram
    participant User
    participant CS as ColorSchemeExample
    participant State as _ColorSchemeExampleState
    participant App as MaterialApp

    User->CS: Wants to change color
    CS->State: Calls updateTheme()
    State->State: Updates selectedColor
    State->CS: Signals state changed (setState)
    CS->App: Rebuilds with new theme data
    App-->User: App shows with new colors
```

1.  The user interacts with something (like a button) to change a setting (like the color).
2.  This interaction tells the `ColorSchemeExample` to update.
3.  The `_ColorSchemeExampleState` inside `ColorSchemeExample` updates its stored color settings (`selectedColor`, `selectedBrightness`, etc.).
4.  It then tells Flutter that its state has changed using `setState()`.
5.  Because the state changed, the `ColorSchemeExample` widget (specifically its `build` method) runs again.
6.  In the `build` method, it creates a *new* `ThemeData` with a *new* `ColorScheme.fromSeed` based on the updated settings.
7.  The `MaterialApp` uses this new theme, and the entire app visually updates to reflect the changes.

This is the fundamental way `ColorSchemeExample` manages and updates the color theme of the application. It holds the core settings, uses them to generate a `ColorScheme`, and rebuilds the app when those settings change.

## Conclusion

In this chapter, we introduced `ColorSchemeExample`, the central widget responsible for managing our app's color theme. We saw how it holds the key color settings (seed color, brightness, contrast) and uses them to create a `ColorScheme` that defines the visual look of the application. We also got a glimpse of how it reacts to changes and updates the entire app's appearance.

Now that we understand the main conductor, let's look at how we can interact with it to change those settings. In the next chapter, we'll explore the [SettingsButton](02_settingsbutton_.md), which is how a user can open the options to customize the theme.

Ready to see how we actually change these colors? Let's move on!

[Chapter 2: SettingsButton](02_settingsbutton_.md)
---
# Chapter 2: SettingsButton

Welcome back! In the last chapter, [ColorSchemeExample](01_colorschemeexample_.md), we learned about the main conductor of our app's colors. It's the widget that holds the plan for our app's look and feel. But how do we actually tell that conductor we want to change the plan? That's where the `SettingsButton` comes in!

Imagine our app as a house with the color plan managed by the architect ([ColorSchemeExample](01_colorschemeexample_.md)). The `SettingsButton` is like a special door handle on the app bar that lets us into the room where we can talk to the architect and ask for changes!

## What is SettingsButton?

The `SettingsButton` is simply a button that sits usually at the top right corner of your app screen, in the "app bar". When you tap it, it doesn't change anything visually itself. Its job is to make something *else* appear – in our case, a panel where we can change the color settings.

Think of it as a gateway. Tapping the `SettingsButton` opens the door to the settings area.

Our specific use case is simple: we want a button in our app bar that, when pressed, shows a temporary panel where we can change the color theme.

## How does SettingsButton work?

Let's look at the code for the `SettingsButton`.

```dart
class SettingsButton extends StatelessWidget {
  const SettingsButton({
    super.key,
    required this.updateTheme,
    // ... other required parameters
  });

  final void Function(Brightness, Color, double) updateTheme;

  @override
  Widget build(BuildContext context) {
    return IconButton(
      icon: const Icon(Icons.settings),
      onPressed: () {
        // This is where the magic happens!
        // It shows a small panel at the bottom.
        showModalBottomSheet<void>(
          barrierColor: Colors.transparent,
          context: context,
          builder: (BuildContext context) {
            // We'll talk about this 'Settings' widget in the next chapter!
            return Settings(
              // Pass the current settings and the way to update the theme
              selectedColor: selectedColor,
              selectedBrightness: selectedBrightness,
              selectedContrast: selectedContrast,
              updateTheme: updateTheme,
            );
          },
        );
      },
    );
  }
}
```

Let's break down the important parts:

1.  `class SettingsButton extends StatelessWidget`: This tells us that the `SettingsButton` itself doesn't change its appearance based on internal data. It's a static button, though what happens when you press it can change things elsewhere!
2.  `required this.updateTheme`: Remember how in [ColorSchemeExample](01_colorschemeexample_.md) we talked about the `updateTheme` function that actually changes the color settings? The `SettingsButton` needs to *know* about this function so it can pass it along to the settings panel.
3.  `@override Widget build(BuildContext context)`: This is where the `SettingsButton` creates its appearance.
4.  `return IconButton(...)`: This is a common Flutter widget for a button that's just an icon. It's perfect for our settings icon!
5.  `icon: const Icon(Icons.settings)`: This gives the `IconButton` the familiar gear icon used for settings.
6.  `onPressed: () { ... }`: This is the crucial part! This defines what happens *when the button is tapped*.
7.  `showModalBottomSheet<void>(...)`: This is a Flutter function that displays a temporary panel that slides up from the bottom of the screen. This is exactly what we want for our settings panel!
8.  `builder: (BuildContext context) { ... return Settings(...) }`: This part tells `showModalBottomSheet` *what* to show inside the panel. It's showing a widget called `Settings`. We'll dive deeper into this `Settings` widget in the next chapter, [Settings](03_settings_.md).

So, when you tap the `SettingsButton`, it calls `showModalBottomSheet`, which then builds and displays the `Settings` widget at the bottom of the screen. The `SettingsButton` also passes the `updateTheme` function and the *current* theme settings to the `Settings` widget so it knows what the theme is now and how to change it.

## Where does the SettingsButton live?

The `SettingsButton` is placed within the app bar of our main screen ([ColorSchemeExample](01_colorschemeexample_.md)). Look at this small snippet from the `ColorSchemeExample`'s `build` method:

```dart
  @override
  Widget build(BuildContext context) {
    return MaterialApp(
      // ... theme setup ...
      home: Scaffold(
        appBar: AppBar(
          title: const Text('ColorScheme'),
          actions: <Widget>[
            // Here it is!
            SettingsButton(
              selectedColor: selectedColor,
              selectedBrightness: selectedBrightness,
              selectedContrast: selectedContrast,
              updateTheme: updateTheme, // Passing the update function
            ),
          ],
        ),
        // ... rest of the body ...
      ),
    );
  }
```

The `AppBar` widget has an `actions` parameter, which is a list of widgets that appear at the end of the app bar (usually on the right). We simply include our `SettingsButton` in this list, and boom! It appears in the app bar. Notice how we pass the current theme settings (`selectedColor`, `selectedBrightness`, `selectedContrast`) and the `updateTheme` function to the `SettingsButton`. This allows the `SettingsButton` to then pass these along to the `Settings` panel.

## Behind the Scenes

When you tap the `SettingsButton`, here's a simplified sequence of events:

```mermaid
sequenceDiagram
    participant User
    participant SB as SettingsButton
    participant Flutter as Flutter Framework
    participant SettingsPanel as Settings (Widget)

    User->SB: Tap the button!
    SB->Flutter: Call showModalBottomSheet()
    Flutter->SettingsPanel: Build and show the Settings widget
    SettingsPanel-->User: Settings panel appears
```

1.  The user taps the icon button in the app bar.
2.  The `onPressed` function inside the `SettingsButton` is executed.
3.  This function calls `showModalBottomSheet`.
4.  `showModalBottomSheet` in the Flutter framework takes the `builder` function provided by `SettingsButton`.
5.  The `builder` function creates and returns the `Settings` widget.
6.  Flutter displays the `Settings` widget as a sliding panel from the bottom of the screen.

The `SettingsButton`'s only job here is to be the trigger that shows the settings panel. It doesn't manage the settings itself; it just opens the door for the user to interact with a different widget ([Settings](03_settings_.md)) that *does* manage the interaction.

## Conclusion

In this chapter, we explored the `SettingsButton`, the simple button in the app bar that acts as a gateway to the settings panel. We saw how it uses `showModalBottomSheet` to display another widget ([Settings](03_settings_.md)) when tapped and how it receives and passes along the necessary information to update the theme.

We now know how to open the door to change our theme settings. In the next chapter, we'll step through that door and explore the [Settings](03_settings_.md) widget itself to understand how it allows users to change the color theme.

Ready to customize? Let's move on!

[Chapter 3: Settings](03_settings_.md)
---
# Chapter 3: Settings

Welcome back, future Flutter expert! In our last chapter, [SettingsButton](02_settingsbutton_.md), we learned how to add a special button to our app's app bar. This button acts like a secret door, and when we tap it, it opens up a place where we can fine-tune the look of our app. Today, we're going to step through that door and meet the widget that lives there: the `Settings` widget!

## What is the Settings Widget?

Imagine you're sitting in the control room of a spaceship, and you have different dials and switches to adjust the lighting, the view out the window, and other cool things. The `Settings` widget is like that control panel for our app's color theme!

Its main job is to provide a user interface – a bunch of visual controls – that let you change:

*   **Brightness:** Do you want the app to be light or dark?
*   **Seed Color:** What primary color should all other colors in the app be based on?
*   **Contrast Level:** How much difference should there be between colors and text?

And the most important part? When you adjust one of these controls, the `Settings` widget talks back to the main part of our app ([ColorSchemeExample](01_colorschemeexample_.md)) and tells it, "Hey, the user wants to change the theme! Here are the new settings!"

Our specific use case is to build a panel that shows options for brightness, seed color, and contrast, and allows the user to interact with these options to change the app's theme.

## How does the Settings Widget work?

The `Settings` widget is the brain behind the settings panel that slides up from the bottom. It needs to:

1.  **Show the current settings:** When you open the panel, it should show what the current brightness, seed color, and contrast are.
2.  **Allow the user to change settings:** Provide controls (like switches, buttons, and sliders) to change the values.
3.  **Tell the main app about changes:** When a user changes a setting, it needs to communicate these changes back to [ColorSchemeExample](01_colorschemeexample_.md).

Let's look at the code for the `Settings` widget and see how it does this (from `color_scheme.0.dart`):

```dart
class Settings extends StatefulWidget {
  const Settings({
    super.key,
    required this.updateTheme,
    required this.selectedBrightness,
    required this.selectedContrast,
    required this.selectedColor,
  });

  final Brightness selectedBrightness;
  final double selectedContrast;
  final Color selectedColor;

  final void Function(Brightness, Color, double) updateTheme;

  @override
  State<Settings> createState() => _SettingsState();
}
```

*   `class Settings extends StatefulWidget`: Like [ColorSchemeExample](01_colorschemeexample_.md), `Settings` is also a `StatefulWidget`. This is because the settings panel itself needs to *remember* the values you've selected *while the panel is open*. For example, if you flip the light/dark switch, the switch itself needs to visually change its state.
*   `required this.updateTheme`, `selectedBrightness`, `selectedContrast`, `selectedColor`: These are the things that the `SettingsButton` *passes* into the `Settings` widget. Remember how the `SettingsButton` knew the current theme settings and the function to update the theme? It gives all that information to `Settings` when it opens the panel. `updateTheme` is a special function that the `Settings` widget will call to tell [ColorSchemeExample](01_colorschemeexample_.md) about the changes.

Now let's peek inside the `_SettingsState` where the actual controls are built:

```dart
class _SettingsState extends State<Settings> {
  late Brightness selectedBrightness = widget.selectedBrightness;
  late Color selectedColor = widget.selectedColor;
  late double selectedContrast = widget.selectedContrast;

  @override
  Widget build(BuildContext context) {
    return Theme(
      data: Theme.of(context).copyWith(
        // This briefly changes the theme *for the settings panel itself*
        colorScheme: ColorScheme.fromSeed(
          seedColor: selectedColor,
          contrastLevel: selectedContrast,
          brightness: selectedBrightness,
        ),
      ),
      child: ConstrainedBox(
        // ... more layout code ...
        child: Padding(
          // ... padding code ...
          child: ListView(
            children: <Widget>[
              // ... Title ...
              Row(
                children: <Widget>[
                  const Text('Brightness: '),
                  Switch(
                    value: selectedBrightness == Brightness.light,
                    onChanged: (bool value) {
                      setState(() {
                        selectedBrightness = value ? Brightness.light : Brightness.dark;
                      });
                      widget.updateTheme(selectedBrightness, selectedColor, selectedContrast); // <-- Tell the main app!
                    },
                  ),
                ],
              ),
              // ... More controls for ColorSeed and ContrastLevel ...
            ],
          ),
        ),
      ),
    );
  }
}
```

*   `late Brightness selectedBrightness = widget.selectedBrightness;`: When the `Settings` widget is created, it takes the initial brightness, color, and contrast that were passed from the `SettingsButton` and stores them in its own internal state variables. These are the values that the controls on the panel will show and modify *locally*.
*   `return Theme(...)`: This is a neat trick! It temporarily applies a theme *only* to the widgets inside this `Theme` widget. This means the settings panel itself will use the color scheme based on the *currently selected* settings, which is helpful for previewing colors within the panel.
*   `ListView`: We use a `ListView` to arrange our controls vertically. If there are many settings, this allows the user to scroll.
*   `Row(...)`: Each row in the `ListView` holds one setting control (like Brightness, Seed color, or Contrast).
*   `Switch(...)`: For the brightness setting, we use a `Switch`. When you flip the switch, the `onChanged` function is called.
*   `setState(() { ... });`: Inside `onChanged`, we first use `setState`. This updates the `selectedBrightness` variable within the `_SettingsState`. Because we used `setState`, Flutter knows that the UI for this widget needs to be re-drawn. This is why the switch visually flips!
*   `widget.updateTheme(...)`: **This is the most important line!** After updating its own internal state (`selectedBrightness`), the `Settings` widget calls the `updateTheme` function that was passed to it. It sends the *new* values for brightness, color, and contrast to this function. This function lives back in [ColorSchemeExample](01_colorschemeexample_.md), and calling it tells the main app, "Okay, the user made a change, update the whole app's theme!"

The code for the `ColorSeed` selection uses `Wrap` and `IconButton` instead of a `Switch`, and the `Contrast Level` uses a `Row` and a `Slider`, but they all follow the same pattern:

1.  Listen for a change in the control (`onPressed` for buttons, `onChanged` for slider/switch).
2.  Update the local state variable (`selectedColor` or `selectedContrast`) using `setState`.
3.  Call `widget.updateTheme` with the *latest* values of `selectedBrightness`, `selectedColor`, and `selectedContrast` to update the main app theme.

## How Changes Flow

Let's visualize the journey of a change when you interact with the `Settings` widget:

```mermaid
sequenceDiagram
    participant User
    participant SP as Settings Panel (Settings Widget)
    participant SettingsState as _SettingsState
    participant CS as ColorSchemeExample

    User->SP: Flips Brightness Switch
    SP->SettingsState: Calls onChanged
    SettingsState->SettingsState: Updates local selectedBrightness
    SettingsState->SettingsState: Calls setState() (Panel redraws)
    SettingsState->CS: Calls widget.updateTheme(new settings)
    CS->CS: Calls updateTheme()
    CS->CS: Updates internal theme settings
    CS->CS: Calls setState() (Main app redraws)
    CS-->User: Main app shows with new brightness
```

1.  The user flips the switch, taps a color circle, or moves the slider on the `Settings` panel.
2.  The corresponding `onChanged` or `onPressed` function is triggered inside the `_SettingsState`.
3.  The local state variable (like `selectedBrightness`) is updated within the `_SettingsState`.
4.  `setState()` is called, causing the `Settings` widget itself to rebuild and show the visual change (like the switch flipping or the color icon changing).
5.  Critically, `widget.updateTheme()` is called, passing the new settings values to the `updateTheme` function that [ColorSchemeExample](01_colorschemeexample_.md) provided.
6.  The `updateTheme` function inside [ColorSchemeExample](01_colorschemeexample_.md) is executed.
7.  [ColorSchemeExample](01_colorschemeexample_.md) updates its own internal theme settings (`selectedBrightness`, `selectedColor`, `selectedContrast`).
8.  [ColorSchemeExample](01_colorschemeexample_.md) calls its *own* `setState()`.
9.  Because [ColorSchemeExample](01_colorschemeexample_.md) is the main widget controlling the app's theme, the entire app rebuilds using the new `ThemeData` and `ColorScheme`.
10. The user sees the app's theme instantly change!

The `Settings` widget is like a temporary control panel. It manages the user's interaction and then passes the final desired settings back to the main `ColorSchemeExample` to apply the changes everywhere.

## Conclusion

In this chapter, we explored the `Settings` widget, the interactive panel that lets users customize the app's color theme. We saw how it takes the current settings and the `updateTheme` function from the [SettingsButton](02_settingsbutton_.md), provides controls like switches, icon buttons, and a slider, and uses `setState` to manage its own appearance while calling `widget.updateTheme` to communicate changes back to [ColorSchemeExample](01_colorschemeexample_.md).

We now understand how to open the settings and interact with them to request changes. In the next chapter, [ColorSchemeVariantColumn](04_colorschemevariantcolumn_.md), we'll start looking at how those chosen settings translate into the actual different colors that make up our theme and how they are displayed in columns on the main screen.

Ready to see the colors generated? Let's move on!

[Chapter 4: ColorSchemeVariantColumn](04_colorschemevariantcolumn_.md)
---
# Chapter 4: ColorSchemeVariantColumn

Welcome back, color explorer! In the last chapter, [Settings](03_settings_.md), we learned how to open the settings panel and use its controls to pick our desired seed color, brightness, and contrast. Now that we've made our choices, how do we actually *see* how those choices affect the *various ways* our app's colors can be generated? That's where the `ColorSchemeVariantColumn` comes in!

## What is ColorSchemeVariantColumn?

Imagine you've picked a beautiful paint color for your house ([selectedColor] in our previous terms). But paint comes in different finishes: matte, semi-gloss, high-gloss, maybe even a textured finish! Each finish uses the *same* base color but applies it in a slightly different way, creating a distinct look.

In Flutter, the `ColorScheme` can also be generated with different "finishes" or *variants*. These variants use your chosen seed color, brightness, and contrast, but they apply mathematical formulas to create the final set of colors (like primary, secondary, surface, etc.) in unique ways. Some might emphasize certain tones, others might use more neutral shades.

The `ColorSchemeVariantColumn` widget is like a display stand for one of these color variants. Its job is simple: it takes your selected color settings and a specific color scheme variant, generates the full `ColorScheme` for that variant, and then displays all the generated colors in a vertical column so you can see what that particular "finish" looks like.

Our specific use case for this chapter is to display multiple columns on the main screen, with each column showing the generated color scheme for a different variant, using the currently selected seed color, brightness, and contrast.

## How does ColorSchemeVariantColumn work?

The `ColorSchemeVariantColumn` is a pretty straightforward widget. It needs the raw ingredients (the settings you picked) and the specific "recipe" (the variant) to show you the resulting colors.

Let's look at its code from `color_scheme.0.dart`:

```dart
class ColorSchemeVariantColumn extends StatelessWidget {
  const ColorSchemeVariantColumn({
    super.key,
    this.schemeVariant = DynamicSchemeVariant.tonalSpot, // Default variant
    this.brightness = Brightness.light,
    this.contrastLevel = 0.0,
    required this.selectedColor,
  });

  final DynamicSchemeVariant schemeVariant; // The specific variant for THIS column
  final Brightness brightness;
  final double contrastLevel;
  final Color selectedColor; // The seed color you chose

  @override
  Widget build(BuildContext context) {
    // ... rest of the build method
    return Padding( // Simplified for this explanation
      padding: const EdgeInsets.symmetric(horizontal: 15),
      child: ColorSchemeView( // This widget actually displays the colors
        colorScheme: ColorScheme.fromSeed( // Generating the ColorScheme!
          seedColor: selectedColor,
          brightness: brightness,
          contrastLevel: contrastLevel,
          dynamicSchemeVariant: schemeVariant, // Using THIS column's variant
        ),
      ),
    );
  }
}
```

Here's what's happening:

1.  `class ColorSchemeVariantColumn extends StatelessWidget`: This tells us that once the settings and variant are given to it, the `ColorSchemeVariantColumn` itself doesn't change. It just displays something based on the inputs it receives.
2.  `final DynamicSchemeVariant schemeVariant;`: This is the key! Each `ColorSchemeVariantColumn` receives a different `DynamicSchemeVariant`. This tells *this specific column* which color generation rule to use.
3.  `final Brightness brightness;`, `final double contrastLevel;`, `final Color selectedColor;`: These are the global settings that are passed down from [ColorSchemeExample](01_colorschemeexample_.md). Every `ColorSchemeVariantColumn` uses the *same* currently selected settings for these.
4.  `ColorScheme.fromSeed(...)`: This is the powerful part we first saw in [ColorSchemeExample](01_colorschemeexample_.md). It takes the seed color, brightness, and contrast.
5.  `dynamicSchemeVariant: schemeVariant,`: **This is where the variant is applied!** Instead of using the default variant, *this specific column* uses the `schemeVariant` that was passed to it. This tells `ColorScheme.fromSeed` *HOW* to generate the full set of colors using the provided inputs.
6.  `ColorSchemeView(...)`: The `ColorScheme.fromSeed` function spits out a complete `ColorScheme` object (a big list of all the primary, secondary, surface colors, etc.). The `ColorSchemeVariantColumn` then passes this generated `ColorScheme` to the `ColorSchemeView` widget, which is responsible for actually drawing all those color blocks and labels on the screen. (We'll look at `ColorSchemeView` in the next chapter!)

So, each `ColorSchemeVariantColumn` is essentially instructed to: "Take these global settings (seed color, brightness, contrast) and this specific generation rule (variant), create the set of colors, and show them."

## Where does ColorSchemeVariantColumn live?

The `ColorSchemeExample` widget (our main controller) is responsible for creating multiple instances of `ColorSchemeVariantColumn`, one for each available variant.

Look at this snippet inside the `_ColorSchemeExampleState`'s `build` method (from `color_scheme.0.dart`):

```dart
  @override
  Widget build(BuildContext context) {
    return MaterialApp(
      // ... theme setup ...
      home: Scaffold(
        // ... app bar ...
        body: SingleChildScrollView( // Allows scrolling horizontally
          child: Padding(
            // ... padding ...
            child: Column(
              // ... other widgets ...
              children: <Widget>[
                SingleChildScrollView(
                  scrollDirection: Axis.horizontal,
                  child: Row( // Arranges children horizontally
                    children:
                        List<Widget>.generate(schemeVariants.length, (int index) {
                          // Create a ColorSchemeVariantColumn for EACH variant
                          return ColorSchemeVariantColumn(
                            selectedColor: selectedColor, // Pass global settings
                            brightness: selectedBrightness,
                            schemeVariant: schemeVariants[index], // Pass THIS variant
                            contrastLevel: selectedContrast,
                          );
                        }).toList(),
                  ),
                ),
              ],
            ),
          ),
        ),
      ),
    );
  }
}
```

*   `SingleChildScrollView(scrollDirection: Axis.horizontal)`: This allows us to scroll the columns left and right if there are too many to fit on the screen at once.
*   `Row(...)`: The `Row` widget places its children next to each other horizontally.
*   `List<Widget>.generate(schemeVariants.length, (int index) { ... })`: This is a neat way to automatically create a list of widgets. `schemeVariants` is a list of all the available `DynamicSchemeVariant` options. This code generates one `ColorSchemeVariantColumn` for *each* variant in that list.
*   `return ColorSchemeVariantColumn(...)`: Inside the `generate` function, we create a `ColorSchemeVariantColumn`. We pass the global settings (`selectedColor`, `selectedBrightness`, `selectedContrast`) that the `_ColorSchemeExampleState` is currently holding. Crucially, we pass a *different* `schemeVariant` (`schemeVariants[index]`) to each column we create.

This means if there are 5 different color scheme variants, the `ColorSchemeExample` creates 5 `ColorSchemeVariantColumn` widgets. Each column gets the *same* seed color, brightness, and contrast, but a *different* variant instruction. They then each generate their own `ColorScheme` according to their variant and display it.

## Behind the Scenes

When [Settings](03_settings_.md) calls `widget.updateTheme` in [ColorSchemeExample](01_colorschemeexample_.md), here's what happens related to the `ColorSchemeVariantColumn`s:

```mermaid
sequenceDiagram
    participant User
    participant Settings as Settings Panel
    participant CS as ColorSchemeExample
    participant Col as ColorSchemeVariantColumn
    participant View as ColorSchemeView
    participant CSFS as ColorScheme.fromSeed

    User->Settings: Changes Seed Color
    Settings->CS: Calls updateTheme(new color)
    CS->CS: Updates selectedColor state
    CS->CS: Calls setState() (CS redraws)
    CS->Row: Rebuilds Row of Columns
    Row->Col: Creates new ColorSchemeVariantColumn instances
    Col->CSFS: Calls ColorScheme.fromSeed with new color and its variant
    CSFS-->Col: Returns new ColorScheme
    Col->View: Passes new ColorScheme to ColorSchemeView
    View-->User: Columns update with new colors based on their variants
```

1.  The user changes a setting (e.g., the seed color) in the [Settings](03_settings_.md) panel.
2.  [Settings](03_settings_.md) calls `updateTheme` on the `ColorSchemeExample`.
3.  `ColorSchemeExample` updates its internal state (`selectedColor`, etc.) and calls its own `setState()`.
4.  `ColorSchemeExample` rebuilds its `build` method, which includes rebuilding the `Row` that holds the `ColorSchemeVariantColumn`s.
5.  The `Row` tells Flutter to create new `ColorSchemeVariantColumn` widgets (or update existing ones if optimized).
6.  Each `ColorSchemeVariantColumn` widget receives the *new* `selectedColor` (and other settings) *plus* its specific `schemeVariant`.
7.  Inside each `ColorSchemeVariantColumn`, `ColorScheme.fromSeed` is called using the new color and the column's specific variant.
8.  `ColorScheme.fromSeed` calculates and returns a complete `ColorScheme` based on these inputs.
9.  Each `ColorSchemeVariantColumn` passes its newly generated `ColorScheme` to its child `ColorSchemeView`.
10. The `ColorSchemeView` for each column updates, drawing the color blocks for that specific variant using the newly generated `ColorScheme`.
11. The user sees all the columns instantly update to show the different variants of the color scheme generated from their new seed color!

This shows how the `ColorSchemeVariantColumn` acts as an intermediate step, taking the global settings and a specific variant, calculating the related `ColorScheme`, and then passing it along to be displayed.

## Conclusion

In this chapter, we introduced the `ColorSchemeVariantColumn`, a widget responsible for displaying the colors generated by a *specific* color scheme variant. We saw how it receives the global color settings (seed color, brightness, contrast) from [ColorSchemeExample](01_colorschemeexample_.md) along with its own unique `DynamicSchemeVariant`. It uses these inputs to generate a complete `ColorScheme` for that variant using `ColorScheme.fromSeed` and then passes this generated scheme to a `ColorSchemeView` to be displayed. [ColorSchemeExample](01_colorschemeexample_.md) creates multiple instances of `ColorSchemeVariantColumn` to show you side-by-side comparisons of how different variants look with your chosen settings.

We now understand how individual columns are responsible for a single variant. In the next chapter, [ColorSchemeView](05_colorschemeview_.md), we'll dive into the widget that `ColorSchemeVariantColumn` uses to actually *display* all those different colors within each column.

Ready to see how the colors are put on display? Let's move on!

[Chapter 5: ColorSchemeView](05_colorschemeview_.md)
---
# Chapter 5: ColorSchemeView

Welcome back, color connoisseur! In our previous chapter, [ColorSchemeVariantColumn](04_colorschemevariantcolumn_.md), we saw how each column on our screen represents a different *way* of generating a set of colors from our chosen settings. Each column is like a unique paint sample board for a specific "finish" of our color scheme. But how do we actually *see* all the individual colors *within* that generated scheme on that board? That's the job of the `ColorSchemeView`!

## What is ColorSchemeView?

Imagine you open up a comprehensive paint color chart. It doesn't just show you the main color; it shows you all the related shades – the light ones, the dark ones, the accent colors that go with it, maybe even the color for the trim.

The `ColorSchemeView` widget is exactly like that color chart for a `ColorScheme`. It takes a complete `ColorScheme` (the full set of colors generated by [ColorSchemeVariantColumn](04_colorschemevariantcolumn_.md)) and lays out *all* of its individual color properties one by one. It shows you the swatch for `primary`, the swatch for `secondary`, the swatch for `surface`, and so on, along with their names. It's the widget that visually presents the *entire palette* generated by a particular variant.

Our specific use case is to display all the colors within a given `ColorScheme` in a clear, organized list within each variant column on our screen.

## How does ColorSchemeView work?

The `ColorSchemeView` is quite simple at its core. Its main requirement is the `ColorScheme` object itself. It doesn't generate colors; it just displays the colors that have already been generated.

Let's peek at the `ColorSchemeView` code (from `color_scheme.0.dart`):

```dart
class ColorSchemeView extends StatelessWidget {
  const ColorSchemeView({super.key, required this.colorScheme});

  final ColorScheme colorScheme; // It only needs the full ColorScheme!

  @override
  Widget build(BuildContext context) {
    return Column( // Arranges its children vertically
      children: <Widget>[
        // Displaying groups of related colors...
        ColorGroup( // We'll look at ColorGroup later
          children: <ColorChip>[ // We'll look at ColorChip later
            ColorChip('primary', colorScheme.primary, colorScheme.onPrimary),
            ColorChip('onPrimary', colorScheme.onPrimary, colorScheme.primary),
            // ... more ColorChip widgets for primaryContainer, onPrimaryContainer
          ],
        ),
        divider, // Just a small space
        ColorGroup(
          children: <ColorChip>[
            ColorChip('secondary', colorScheme.secondary, colorScheme.onSecondary),
            // ... more secondary colors
          ],
        ),
        divider,
        // ... ColorGroups for tertiary, error, surface, outline, etc.
      ],
    );
  }
}
```

Here's the breakdown:

1.  `class ColorSchemeView extends StatelessWidget`: Just like [ColorSchemeVariantColumn](04_colorschemevariantcolumn_.md), `ColorSchemeView` displays information given to it. It doesn't change its appearance based on internal state.
2.  `required this.colorScheme`: This confirms that the `ColorSchemeView` needs one thing: a complete `ColorScheme` object. This is the object created by `ColorScheme.fromSeed` inside the [ColorSchemeVariantColumn](04_colorschemevariantcolumn_.md).
3.  `return Column(...)`: The main layout for the `ColorSchemeView` is a `Column`, because we want to list all the color swatches vertically.
4.  `ColorGroup(...)`: Notice that the colors aren't listed individually right inside the `Column`. They are grouped together using a widget called `ColorGroup`. This helps organize the display, putting related colors (like primary and its variations) together. We'll explore `ColorGroup` in a future chapter, [ColorGroup](06_colorgroup_.md).
5.  `ColorChip(...)`: Inside each `ColorGroup`, we see many instances of the `ColorChip` widget. Each `ColorChip` is responsible for displaying a *single* color swatch with its name. For example, `ColorChip('primary', colorScheme.primary, colorScheme.onPrimary)` tells a `ColorChip` to label itself 'primary', show the color defined by `colorScheme.primary`, and use `colorScheme.onPrimary` for the text color on that swatch. We'll learn more about `ColorChip` in chapter [ColorChip](07_colorchip_.md).

So, the `ColorSchemeView` takes the full `ColorScheme`, uses `ColorGroup` to organize it, and uses `ColorChip` to display each individual color and its name.

## How is ColorSchemeView Used?

As we saw in the previous chapter, [ColorSchemeVariantColumn](04_colorschemevariantcolumn_.md) creates the `ColorScheme` based on the selected settings and its specific variant. It then passes this generated `ColorScheme` to a `ColorSchemeView`.

Look at the relevant part of the [ColorSchemeVariantColumn](04_colorschemevariantcolumn_.md) build method again:

```dart
class ColorSchemeVariantColumn extends StatelessWidget {
  // ... fields and constructor ...

  @override
  Widget build(BuildContext context) {
    return ConstrainedBox(
      // ... layout constraints ...
      child: Column(
        children: <Widget>[
          // ... Variant name text ...
          Padding(
            padding: const EdgeInsets.symmetric(horizontal: 15),
            child: ColorSchemeView( // Here's where it's used!
              colorScheme: ColorScheme.fromSeed( // The generated scheme
                seedColor: selectedColor,
                brightness: brightness,
                contrastLevel: contrastLevel,
                dynamicSchemeVariant: schemeVariant,
              ),
            ),
          ),
        ],
      ),
    );
  }
}
```

The `ColorSchemeVariantColumn` is the one that says: "Okay, I figured out what all the colors are for *my* variant based on the seed color and brightness. Now, `ColorSchemeView`, please show these colors!" And it passes the result of `ColorScheme.fromSeed` directly into the `colorScheme` property of the `ColorSchemeView`.

## Behind the Scenes

When a setting changes and a new `ColorScheme` is generated by a [ColorSchemeVariantColumn](04_colorschemevariantcolumn_.md), here's what happens concerning the `ColorSchemeView`:

```mermaid
sequenceDiagram
    participant CSVC as ColorSchemeVariantColumn
    participant CSFS as ColorScheme.fromSeed
    participant CSV as ColorSchemeView
    participant CG as ColorGroup
    participant CC as ColorChip

    CSVC->CSFS: Call ColorScheme.fromSeed (with new settings/variant)
    CSFS-->CSVC: Return new ColorScheme object
    CSVC->CSV: Create new ColorSchemeView instance (passing the new ColorScheme)
    CSV->CSV: Build its Column structure
    CSV->CG: Create ColorGroup widgets (passing parts of the ColorScheme implicitely)
    CG->CC: Create ColorChip widgets (passing individual colors and names)
    CC-->User: Displays the color swatch and name
```

1.  The `ColorSchemeVariantColumn` for a specific variant and the updated settings calls `ColorScheme.fromSeed`.
2.  `ColorScheme.fromSeed` calculates and returns a new `ColorScheme` object containing all the specific colors for that variant and those settings.
3.  The `ColorSchemeVariantColumn` creates a new `ColorSchemeView` widget and gives it this brand new `ColorScheme` object.
4.  The `ColorSchemeView` starts building its layout (the `Column`).
5.  As it builds, it creates `ColorGroup` widgets for different categories of colors.
6.  Each `ColorGroup` then creates multiple `ColorChip` widgets. It passes the specific color property (like `colorScheme.primary`, `colorScheme.secondaryContainer`, etc.) to each `ColorChip`.
7.  Each `ColorChip` then draws its small colored box and the corresponding text label.
8.  The user sees the entire list of colors within that variant column update immediately to show the new generated palette.

The `ColorSchemeView` acts as the presentation layer. It takes the complex data structure that is the `ColorScheme` and organizes and visualizes it using smaller building block widgets (`ColorGroup` and `ColorChip`).

## Conclusion

In this chapter, we focused on the `ColorSchemeView`, the widget responsible for visually displaying all the individual colors contained within a `ColorScheme`. We saw how it receives a complete `ColorScheme` object (generated by [ColorSchemeVariantColumn](04_colorschemevariantcolumn_.md)) and uses helper widgets like `ColorGroup` and `ColorChip` to present a clear, itemized list of every color swatch along with its name. It's the key to seeing the full palette of a generated theme variant.

We now know how the different color palettes are generated and displayed. In the next chapter, [ColorGroup](06_colorgroup_.md), we'll zoom in on one of the helpers that `ColorSchemeView` uses to organize the display of these colors.

Ready to learn about organizing colors? Let's move on!

[Chapter 6: ColorGroup](06_colorgroup_.md)

Relevant Code Snippets (Code itself remains unchanged):
--- File: color_scheme.0.dart ---
// Copyright 2014 The Flutter Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

import 'package:flutter/material.dart';

/// Flutter code sample for [ColorScheme].

const Widget divider = SizedBox(height: 10);

void main() => runApp(const ColorSchemeExample());

class ColorSchemeExample extends StatefulWidget {
  const ColorSchemeExample({super.key});

  @override
  State<ColorSchemeExample> createState() => _ColorSchemeExampleState();
}

class _ColorSchemeExampleState extends State<ColorSchemeExample> {
  Color selectedColor = ColorSeed.baseColor.color;
  Brightness selectedBrightness = Brightness.light;
  double selectedContrast = 0.0;
  static const List<DynamicSchemeVariant> schemeVariants = DynamicSchemeVariant.values;

  void updateTheme(Brightness brightness, Color color, double contrastLevel) {
    setState(() {
      selectedBrightness = brightness;
      selectedColor = color;
      selectedContrast = contrastLevel;
    });
  }

  @override
  Widget build(BuildContext context) {
    return MaterialApp(
      debugShowCheckedModeBanner: false,
      theme: ThemeData(
        colorScheme: ColorScheme.fromSeed(
          seedColor: selectedColor,
          brightness: selectedBrightness,
          contrastLevel: selectedContrast,
        ),
      ),
      home: Scaffold(
        appBar: AppBar(
          title: const Text('ColorScheme'),
          actions: <Widget>[
            SettingsButton(
              selectedColor: selectedColor,
              selectedBrightness: selectedBrightness,
              selectedContrast: selectedContrast,
              updateTheme: updateTheme,
            ),
          ],
        ),
        body: SingleChildScrollView(
          child: Padding(
            padding: const EdgeInsets.only(top: 5),
            child: Column(
              crossAxisAlignment: CrossAxisAlignment.start,
              children: <Widget>[
                SingleChildScrollView(
                  scrollDirection: Axis.horizontal,
                  child: Row(
                    children:
                        List<Widget>.generate(schemeVariants.length, (int index) {
                          return ColorSchemeVariantColumn(
                            selectedColor: selectedColor,
                            brightness: selectedBrightness,
                            schemeVariant: schemeVariants[index],
                            contrastLevel: selectedContrast,
                          );
                        }).toList(),
                  ),
                ),
              ],
            ),
          ),
        ),
      ),
    );
  }
}

class Settings extends StatefulWidget {
  const Settings({
    super.key,
    required this.updateTheme,
    required this.selectedBrightness,
    required this.selectedContrast,
    required this.selectedColor,
  });

  final Brightness selectedBrightness;
  final double selectedContrast;
  final Color selectedColor;

  final void Function(Brightness, Color, double) updateTheme;

  @override
  State<Settings> createState() => _SettingsState();
}

class _SettingsState extends State<Settings> {
  late Brightness selectedBrightness = widget.selectedBrightness;
  late Color selectedColor = widget.selectedColor;
  late double selectedContrast = widget.selectedContrast;

  @override
  Widget build(BuildContext context) {
    return Theme(
      data: Theme.of(context).copyWith(
        colorScheme: ColorScheme.fromSeed(
          seedColor: selectedColor,
          contrastLevel: selectedContrast,
          brightness: selectedBrightness,
        ),
      ),
      child: ConstrainedBox(
        constraints: const BoxConstraints(maxHeight: 200),
        child: Padding(
          padding: const EdgeInsets.all(20.0),
          child: ListView(
            children: <Widget>[
              Center(child: Text('Settings', style: Theme.of(context).textTheme.titleLarge)),
              Row(
                children: <Widget>[
                  const Text('Brightness: '),
                  Switch(
                    value: selectedBrightness == Brightness.light,
                    onChanged: (bool value) {
                      setState(() {
                        selectedBrightness = value ? Brightness.light : Brightness.dark;
                      });
                      widget.updateTheme(selectedBrightness, selectedColor, selectedContrast);
                    },
                  ),
                ],
              ),
              Wrap(
                crossAxisAlignment: WrapCrossAlignment.center,
                children: <Widget>[
                  const Text('Seed color: '),
                  ...List<Widget>.generate(ColorSeed.values.length, (int index) {
                    final Color itemColor = ColorSeed.values[index].color;
                    return IconButton(
                      icon:
                          selectedColor == ColorSeed.values[index].color
                              ? Icon(Icons.circle, color: itemColor)
                              : Icon(Icons.circle_outlined, color: itemColor),
                      onPressed: () {
                        setState(() {
                          selectedColor = itemColor;
                        });
                        widget.updateTheme(selectedBrightness, selectedColor, selectedContrast);
                      },
                    );
                  }),
                ],
              ),
              Row(
                children: <Widget>[
                  const Text('Contrast level: '),
                  Expanded(
                    child: Slider(
                      divisions: 4,
                      label: selectedContrast.toString(),
                      min: -1,
                      value: selectedContrast,
                      onChanged: (double value) {
                        setState(() {
                          selectedContrast = value;
                        });
                        widget.updateTheme(selectedBrightness, selectedColor, selectedContrast);
                      },
                    ),
                  ),
                ],
              ),
            ],
          ),
        ),
      ),
    );
  }
}

class ColorSchemeVariantColumn extends StatelessWidget {
  const ColorSchemeVariantColumn({
    super.key,
    this.schemeVariant = DynamicSchemeVariant.tonalSpot,
    this.brightness = Brightness.light,
    this.contrastLevel = 0.0,
    required this.selectedColor,
  });

  final DynamicSchemeVariant schemeVariant;
  final Brightness brightness;
  final double contrastLevel;
  final Color selectedColor;

  @override
  Widget build(BuildContext context) {
    return ConstrainedBox(
      constraints: const BoxConstraints.tightFor(width: 250),
      child: Column(
        children: <Widget>[
          Padding(
            padding: const EdgeInsets.symmetric(vertical: 15),
            child: Text(
              schemeVariant.name == 'tonalSpot'
                  ? '${schemeVariant.name} (Default)'
                  : schemeVariant.name,
              style: const TextStyle(fontWeight: FontWeight.bold),
            ),
          ),
          Padding(
            padding: const EdgeInsets.symmetric(horizontal: 15),
            child: ColorSchemeView(
              colorScheme: ColorScheme.fromSeed(
                seedColor: selectedColor,
                brightness: brightness,
                contrastLevel: contrastLevel,
                dynamicSchemeVariant: schemeVariant,
              ),
            ),
          ),
        ],
      ),
    );
  }
}

class ColorSchemeView extends StatelessWidget {
  const ColorSchemeView({super.key, required this.colorScheme});

  final ColorScheme colorScheme;

  @override
  Widget build(BuildContext context) {
    return Column(
      children: <Widget>[
        ColorGroup(
          children: <ColorChip>[
            ColorChip('primary', colorScheme.primary, colorScheme.onPrimary),
            ColorChip('onPrimary', colorScheme.onPrimary, colorScheme.primary),
            ColorChip(
              'primaryContainer',
              colorScheme.primaryContainer,
              colorScheme.onPrimaryContainer,
            ),
            ColorChip(
              'onPrimaryContainer',
              colorScheme.onPrimaryContainer,
              colorScheme.primaryContainer,
            ),
          ],
        ),
        divider,
        ColorGroup(
          children: <ColorChip>[
            ColorChip('primaryFixed', colorScheme.primaryFixed, colorScheme.onPrimaryFixed),
            ColorChip('onPrimaryFixed', colorScheme.onPrimaryFixed, colorScheme.primaryFixed),
            ColorChip(
              'primaryFixedDim',
              colorScheme.primaryFixedDim,
              colorScheme.onPrimaryFixedVariant,
            ),
            ColorChip(
              'onPrimaryFixedVariant',
              colorScheme.onPrimaryFixedVariant,
              colorScheme.primaryFixedDim,
            ),
          ],
        ),
        divider,
        ColorGroup(
          children: <ColorChip>[
            ColorChip('secondary', colorScheme.secondary, colorScheme.onSecondary),
            ColorChip('onSecondary', colorScheme.onSecondary, colorScheme.secondary),
            ColorChip(
              'secondaryContainer',
              colorScheme.secondaryContainer,
              colorScheme.onSecondaryContainer,
            ),
            ColorChip(
              'onSecondaryContainer',
              colorScheme.onSecondaryContainer,
              colorScheme.secondaryContainer,
            ),
          ],
        ),
        divider,
        ColorGroup(
          children: <ColorChip>[
            ColorChip('secondaryFixed', colorScheme.secondaryFixed, colorScheme.onSecondaryFixed),
            ColorChip('onSecondaryFixed', colorScheme.onSecondaryFixed, colorScheme.secondaryFixed),
            ColorChip(
              'secondaryFixedDim',
              colorScheme.secondaryFixedDim,
              colorScheme.onSecondaryFixedVariant,
            ),
            ColorChip(
              'onSecondaryFixedVariant',
              colorScheme.onSecondaryFixedVariant,
              colorScheme.secondaryFixedDim,
            ),
          ],
        ),
        divider,
        ColorGroup(
          children: <ColorChip>[
            ColorChip('tertiary', colorScheme.tertiary, colorScheme.onTertiary),
            ColorChip('onTertiary', colorScheme.onTertiary, colorScheme.tertiary),
            ColorChip(
              'tertiaryContainer',
              colorScheme.tertiaryContainer,
              colorScheme.onTertiaryContainer,
            ),
            ColorChip(
              'onTertiaryContainer',
              colorScheme.onTertiaryContainer,
              colorScheme.tertiaryContainer,
            ),
          ],
        ),
        divider,
        ColorGroup(
          children: <ColorChip>[
            ColorChip('tertiaryFixed', colorScheme.tertiaryFixed, colorScheme.onTertiaryFixed),
            ColorChip('onTertiaryFixed', colorScheme.onTertiaryFixed, colorScheme.tertiaryFixed),
            ColorChip(
              'tertiaryFixedDim',
              colorScheme.tertiaryFixedDim,
              colorScheme.onTertiaryFixedVariant,
            ),
            ColorChip(
              'onTertiaryFixedVariant',
              colorScheme.onTertiaryFixedVariant,
              colorScheme.tertiaryFixedDim,
            ),
          ],
        ),
        divider,
        ColorGroup(
          children: <ColorChip>[
            ColorChip('error', colorScheme.error, colorScheme.onError),
            ColorChip('onError', colorScheme.onError, colorScheme.error),
            ColorChip('errorContainer', colorScheme.errorContainer, colorScheme.onErrorContainer),
            ColorChip('onErrorContainer', colorScheme.onErrorContainer, colorScheme.errorContainer),
          ],
        ),
        divider,
        ColorGroup(
          children: <ColorChip>[
            ColorChip('surfaceDim', colorScheme.surfaceDim, colorScheme.onSurface),
            ColorChip('surface', colorScheme.surface, colorScheme.onSurface),
            ColorChip('surfaceBright', colorScheme.surfaceBright, colorScheme.onSurface),
            ColorChip(
              'surfaceContainerLowest',
              colorScheme.surfaceContainerLowest,
              colorScheme.onSurface,
            ),
            ColorChip(
              'surfaceContainerLow',
              colorScheme.surfaceContainerLow,
              colorScheme.onSurface,
            ),
            ColorChip('surfaceContainer', colorScheme.surfaceContainer, colorScheme.onSurface),
            ColorChip(
              'surfaceContainerHigh',
              colorScheme.surfaceContainerHigh,
              colorScheme.onSurface,
            ),
            ColorChip(
              'surfaceContainerHighest',
              colorScheme.surfaceContainerHighest,
              colorScheme.onSurface,
            ),
            ColorChip('onSurface', colorScheme.onSurface, colorScheme.surface),
            ColorChip(
              'onSurfaceVariant',
              colorScheme.onSurfaceVariant,
              colorScheme.surfaceContainerHighest,
            ),
          ],
        ),
        divider,
        ColorGroup(
          children: <ColorChip>[
            ColorChip('outline', colorScheme.outline, null),
            ColorChip('shadow', colorScheme.shadow, null),
            ColorChip('inverseSurface', colorScheme.inverseSurface, colorScheme.onInverseSurface),
            ColorChip('onInverseSurface', colorScheme.onInverseSurface, colorScheme.inverseSurface),
            ColorChip('inversePrimary', colorScheme.inversePrimary, colorScheme.primary),
          ],
        ),
      ],
    );
  }
}

class ColorGroup extends StatelessWidget {
  const ColorGroup({super.key, required this.children});

  final List<Widget> children;

  @override
  Widget build(BuildContext context) {
    return RepaintBoundary(
      child: Card(clipBehavior: Clip.antiAlias, child: Column(children: children)),
    );
  }
}

class ColorChip extends StatelessWidget {
  const ColorChip(this.label, this.color, this.onColor, {super.key});

  final Color color;
  final Color? onColor;
  final String label;

  static Color contrastColor(Color color) {
    final Brightness brightness = ThemeData.estimateBrightnessForColor(color);
    return brightness == Brightness.dark ? Colors.white : Colors.black;
  }

  @override
  Widget build(BuildContext context) {
    final Color labelColor = onColor ?? contrastColor(color);
    return ColoredBox(
      color: color,
      child: Padding(
        padding: const EdgeInsets.all(16),
        child: Row(
          children: <Expanded>[Expanded(child: Text(label, style: TextStyle(color: labelColor)))],
        ),
      ),
    );
  }
}

enum ColorSeed {
  baseColor('M3 Baseline', Color(0xff6750a4)),
  indigo('Indigo', Colors.indigo),
  blue('Blue', Colors.blue),
  teal('Teal', Colors.teal),
  green('Green', Colors.green),
  yellow('Yellow', Colors.yellow),
  orange('Orange', Colors.orange),
  deepOrange('Deep Orange', Colors.deepOrange),
  pink('Pink', Colors.pink),
  brightBlue('Bright Blue', Color(0xFF0000FF)),
  brightGreen('Bright Green', Color(0xFF00FF00)),
  brightRed('Bright Red', Color(0xFFFF0000));

  const ColorSeed(this.label, this.color);
  final String label;
  final Color color;
}

class SettingsButton extends StatelessWidget {
  const SettingsButton({
    super.key,
    required this.updateTheme,
    required this.selectedBrightness,
    required this.selectedContrast,
    required this.selectedColor,
  });

  final Brightness selectedBrightness;
  final double selectedContrast;
  final Color selectedColor;

  final void Function(Brightness, Color, double) updateTheme;

  @override
  Widget build(BuildContext context) {
    return IconButton(
      icon: const Icon(Icons.settings),
      onPressed: () {
        showModalBottomSheet<void>(
          barrierColor: Colors.transparent,
          context: context,
          builder: (BuildContext context) {
            return Settings(
              selectedColor: selectedColor,
              selectedBrightness: selectedBrightness,
              selectedContrast: selectedContrast,
              updateTheme: updateTheme,
            );
          },
        );
      },
    );
  }
}


Instructions for the chapter (Generate content in English unless specified otherwise):
- Start with a clear heading (e.g., `# Chapter 6: ColorGroup
`). Use the provided concept name.

- If this is not the first chapter, begin with a brief transition from the previous chapter, referencing it with a proper Markdown link using its name.

- Begin with a high-level motivation explaining what problem this abstraction solves. Start with a central use case as a concrete example. The whole chapter should guide the reader to understand how to solve this use case. Make it very minimal and friendly to beginners.

- If the abstraction is complex, break it down into key concepts. Explain each concept one-by-one in a very beginner-friendly way.

- Explain how to use this abstraction to solve the use case. Give example inputs and outputs for code snippets (if the output isn't values, describe at a high level what will happen).

- Each code block should be BELOW 10 lines! If longer code blocks are needed, break them down into smaller pieces and walk through them one-by-one. Aggresively simplify the code to make it minimal. Use comments to skip non-important implementation details. Each code block should have a beginner friendly explanation right after it.

- Describe the internal implementation to help understand what's under the hood. First provide a non-code or code-light walkthrough on what happens step-by-step when the abstraction is called. It's recommended to use a simple sequenceDiagram with a dummy example - keep it minimal with at most 5 participants to ensure clarity. If participant name has space, use: `participant QP as Query Processing`. .

- Then dive deeper into code for the internal implementation with references to files. Provide example code blocks, but make them similarly simple and beginner-friendly. Explain.

- IMPORTANT: When you need to refer to other core abstractions covered in other chapters, ALWAYS use proper Markdown links like this: [Chapter Title](filename.md). Use the Complete Tutorial Structure above to find the correct filename and the chapter title. Translate the surrounding text.

- Use mermaid diagrams to illustrate complex concepts (```mermaid``` format). .

- Heavily use analogies and examples throughout to help beginners understand.

- End the chapter with a brief conclusion that summarizes what was learned and provides a transition to the next chapter. If there is a next chapter, use a proper Markdown link: [Next Chapter Title](next_chapter_filename).

- Ensure the tone is welcoming and easy for a newcomer to understand.

- Output *only* the Markdown content for this chapter.

Now, directly provide a super beginner-friendly Markdown output (DON'T need ```markdown``` tags):

2025-05-28 16:31:13,427 - INFO - RESPONSE: # Chapter 6: ColorGroup

Welcome back, organized designer! In our last chapter, [ColorSchemeView](05_colorschemeview_.md), we saw how that widget is responsible for displaying all the different colors that make up a `ColorScheme` for a specific variant. We noticed that it doesn't just display them all in one long, messy list. It groups related colors together! How does it do that? With the help of the `ColorGroup` widget!

## What is ColorGroup?

Imagine you have a bunch of small paint chip samples. You wouldn't just randomly scatter them on a table. You'd probably group them – maybe all the blues together, all the reds together, etc., perhaps putting each group in a little box or frame to keep them tidy.

The `ColorGroup` widget is like that box or frame for a set of color swatches. It's a simple container whose main job is to hold several `ColorChip` widgets (the individual paint chip samples) and display them together, visually separated from other groups of colors.

Its purpose is purely organizational and visual. It takes a list of `ColorChip` widgets and arranges them, usually within a subtle frame or card, to make the long list of colors in a `ColorSchemeView` easier to understand and browse.

Our specific use case for this chapter is to use `ColorGroup` to bundle related `ColorChip`s together within the `ColorSchemeView`, providing visual structure to the displayed color palette.

## How does ColorGroup work?

The `ColorGroup` widget is designed to be very simple. It doesn't know anything about colors or color schemes itself. It just knows how to take a bunch of other widgets (specifically, `ColorChip`s in our case) and display them neatly together.

Let's look at the code for `ColorGroup` (from `color_scheme.0.dart`):

```dart
class ColorGroup extends StatelessWidget {
  const ColorGroup({super.key, required this.children});

  final List<Widget> children; // It just holds a list of widgets!

  @override
  Widget build(BuildContext context) {
    return RepaintBoundary( // Useful for performance, not essential to understand grouping
      child: Card( // The 'box' or 'frame'
        clipBehavior: Clip.antiAlias,
        child: Column(children: children)), // Lay out the children vertically
    );
  }
}
```

Here's what's happening:

1.  `class ColorGroup extends StatelessWidget`: `ColorGroup` is another widget that doesn't manage its own changing data. It just displays what you give it.
2.  `required this.children`: This is the key property. The `ColorGroup` needs a `List<Widget>` as its `children`. You give it the list of widgets you want it to group together. In our app, these widgets are `ColorChip`s.
3.  `return RepaintBoundary(...)`: This is a performance optimization and not central to the grouping concept itself. We can ignore it for now.
4.  `child: Card(...)`: This is where the visual grouping happens! The `Card` widget is a common Material Design container that provides padding, elevation (a subtle shadow), and rounded corners, making its contents look like they are inside a distinct frame or box.
5.  `child: Column(children: children)`: Inside the `Card`, a `Column` is used to arrange the `children` (the list of widgets you passed in) one above the other, vertically. This is how the `ColorChip`s appear stacked within the `Card`.

Essentially, `ColorGroup` takes a list of widgets, wraps them in a `Card` for visual separation, and arranges them within that `Card` using a `Column`.

## How is ColorGroup Used?

As we saw briefly in the [ColorSchemeView](05_colorschemeview_.md) chapter, the `ColorSchemeView` is the one that creates and uses multiple `ColorGroup` widgets to display the various parts of a `ColorScheme`.

Look at the relevant part of the `ColorSchemeView` build method again:

```dart
class ColorSchemeView extends StatelessWidget {
  const ColorSchemeView({super.key, required this.colorScheme});

  final ColorScheme colorScheme;

  @override
  Widget build(BuildContext context) {
    return Column(
      children: <Widget>[
        ColorGroup( // First group!
          children: <ColorChip>[
            ColorChip('primary', colorScheme.primary, colorScheme.onPrimary),
            ColorChip('onPrimary', colorScheme.onPrimary, colorScheme.primary),
            // ... more primary-related ColorChip widgets ...
          ],
        ),
        divider, // A simple space between groups
        ColorGroup( // Second group!
          children: <ColorChip>[
            ColorChip('secondary', colorScheme.secondary, colorScheme.onSecondary),
            // ... more secondary-related ColorChip widgets ...
          ],
        ),
        divider,
        // ... Many more ColorGroup widgets for tertiary, error, surface, etc.
      ],
    );
  }
}
```

The `ColorSchemeView` doesn't just pass the entire `ColorScheme` to a single `ColorGroup`. Instead, it actively creates *multiple* `ColorGroup` widgets. For each `ColorGroup`, it specifically lists the `ColorChip` widgets that correspond to a related set of colors (like primary, secondary, error, surface, etc.) and passes *that specific list* to the `children` property of that `ColorGroup`.

This is where the organization happens. The developer building the `ColorSchemeView` decides which colors belong in which group (e.g., all `primary` related colors, all `error` related colors) and manually creates a `ColorGroup` for each category, filling its `children` list with the appropriate `ColorChip`s.

## Behind the Scenes

When a `ColorSchemeView` is built or rebuilt (because the settings changed and a new `ColorScheme` was generated), here's what happens with the `ColorGroup` widgets:

```mermaid
sequenceDiagram
    participant CSV as ColorSchemeView
    participant CG as ColorGroup
    participant Card as Flutter Card Widget
    participant Column as Flutter Column Widget
    participant CC as ColorChip

    CSV->CSV: Build its main Column
    CSV->CG: Create a ColorGroup (e.g., for "primary" colors)
    CSV->CG: Pass a list of relevant ColorChip widgets to its children
    CG->Card: Build a Card widget
    Card->Column: Build a Column widget inside the Card
    Column->CC: Arrange and display the ColorChip widgets passed to the ColorGroup
    CC-->User: Show the individual color swatches inside the Card
    CSV->CSV: Create another ColorGroup (e.g., for "secondary" colors)
    CSV->CG: Repeat the process for the next group...
    CG-->User: Another Card display appears with the next group of colors
```

1.  The `ColorSchemeView` widget is built, creating its main vertical `Column`.
2.  It starts creating the first `ColorGroup` (e.g., the one for primary colors).
3.  It creates a list containing only the `ColorChip` widgets for `primary`, `onPrimary`, `primaryContainer`, etc., and passes this list to the `children` of the `ColorGroup`.
4.  The `ColorGroup` widget receives this list and starts building *its* content.
5.  It creates a `Card` widget.
6.  Inside the `Card`, it creates a `Column` widget.
7.  It tells the internal `Column` to display the list of `ColorChip` widgets it received as its `children`.
8.  Each `ColorChip` in that list then draws itself (a colored box with text).
9.  These drawn `ColorChip`s appear stacked vertically inside the `Card`.
10. The `ColorSchemeView` then continues creating the next `ColorGroup` for the next set of colors (secondary, tertiary, etc.), repeating the process.
11. The user sees a series of distinct "cards" or "boxes" stacked vertically inside each variant column, with each card containing a logically grouped set of color swatches.

The `ColorGroup` doesn't decide *which* colors go together; the developer using `ColorSchemeView` decides that by creating multiple `ColorGroup`s and putting the appropriate `ColorChip`s into each one's `children` list. The `ColorGroup` just provides the visual structure (the "box") for whatever list of widgets it's given.

## Conclusion

In this chapter, we explored the `ColorGroup` widget, a simple but effective container used within `ColorSchemeView` to organize the display of color swatches. We saw how it takes a list of child widgets (typically `ColorChip`s) and presents them neatly within a `Card` and a `Column`, helping to break down the large list of colors into understandable groups. It's a basic building block for structuring the visual output of the generated color schemes.

We now understand how different colors within a generated `ColorScheme` are grouped together for clarity. In the next chapter, [ColorChip](07_colorchip_.md), we'll zoom in even further and explore the smallest unit of display: the individual color swatch itself.

Ready to look at the individual color samples? Let's move on!

[Chapter 7: ColorChip](07_colorchip_.md)
2025-05-28 16:31:13,437 - INFO - PROMPT: 
Write a very beginner-friendly tutorial chapter (in Markdown format) for the project `flutter` about the concept: "ColorChip
". This is Chapter 7.

Concept Details:
- Name: ColorChip

- Description:
A small, visual representation of a single color within a `ColorScheme`, along with its name and a contrasting color for text.
Think of it as a paint chip sample from a hardware store, showing you a specific color with its label so you know what it represents in the overall scheme.


Complete Tutorial Structure:
1. [ColorSchemeExample
](01_colorschemeexample_.md)
2. [SettingsButton
](02_settingsbutton_.md)
3. [Settings
](03_settings_.md)
4. [ColorSchemeVariantColumn
](04_colorschemevariantcolumn_.md)
5. [ColorSchemeView
](05_colorschemeview_.md)
6. [ColorGroup
](06_colorgroup_.md)
7. [ColorChip
](07_colorchip_.md)
8. [ColorSeed
](08_colorseed_.md)

Context from previous chapters:
# Chapter 1: ColorSchemeExample

Welcome, aspiring Flutter developer! In this chapter, we're going to meet the main conductor of our app's visual symphony: `ColorSchemeExample`. Think of this like the main boss or the central hub of our application. It's the widget that gets everything started and keeps track of the overall look and feel, specifically the colors!

## What is ColorSchemeExample?

Imagine you're building a house, and you want to decide on the paint colors, the brightness of the rooms, and how much contrast you want between different elements. The `ColorSchemeExample` is like the architect who holds the master plan for all these color decisions. It decides things like:

*   **What are the main colors of the app?**
*   **Should the app be light or dark?** (Brightness)
*   **How much difference should there be between colors and text?** (Contrast)

And the best part? If you change any of these decisions (like choosing a different main color), the `ColorSchemeExample` knows and makes sure the *whole* house (your app) updates to the new plan.

Our specific use case for this chapter is to see how `ColorSchemeExample` manages the initial color settings of our app.

## How does ColorSchemeExample work?

Let's take a look at the main part of the `ColorSchemeExample` code. Don't worry about understanding every single line right away. We'll break it down.

```dart
void main() => runApp(const ColorSchemeExample());

class ColorSchemeExample extends StatefulWidget {
  const ColorSchemeExample({super.key});

  @override
  State<ColorSchemeExample> createState() => _ColorSchemeExampleState();
}

class _ColorSchemeExampleState extends State<ColorSchemeExample> {
  Color selectedColor = ColorSeed.baseColor.color;
  Brightness selectedBrightness = Brightness.light;
  double selectedContrast = 0.0;
  // ... other code
}
```

This code shows us a couple of key things:

1.  `void main() => runApp(const ColorSchemeExample());`: This is where our app starts! It tells Flutter to run the `ColorSchemeExample` widget.
2.  `ColorSchemeExample extends StatefulWidget`: This means our `ColorSchemeExample` can change over time. If you change the color settings, the widget can rebuild itself to show the new colors.
3.  `_ColorSchemeExampleState`: This is where the `ColorSchemeExample` keeps track of its state, or its current settings. Notice `selectedColor`, `selectedBrightness`, and `selectedContrast`. These are the main color-related decisions it's currently holding.

So, when the app first starts, `ColorSchemeExample` sets up its initial color decisions (like the default primary color, brightness, and contrast).

## Setting up the Theme

The `ColorSchemeExample` also uses these color decisions to set the overall theme of the app. Let's look at the `build` method:

```dart
@override
Widget build(BuildContext context) {
  return MaterialApp(
    debugShowCheckedModeBanner: false,
    theme: ThemeData(
      colorScheme: ColorScheme.fromSeed(
        seedColor: selectedColor,
        brightness: selectedBrightness,
        contrastLevel: selectedContrast,
      ),
    ),
    // ... rest of the build method
  );
}
```

Here's what's happening:

*   `return MaterialApp(...)`: This is the basic structure for a Flutter app. It provides important things like navigation and theming.
*   `theme: ThemeData(...)`: This is where we define the visual theme for our app.
*   `colorScheme: ColorScheme.fromSeed(...)`: This is a super helpful way to create a whole set of colors for your app based on just one "seed" color. `ColorSchemeExample` uses its `selectedColor`, `selectedBrightness`, and `selectedContrast` to generate a complete `ColorScheme`. This `ColorScheme` contains many different color definitions (like primary, secondary, surface, etc.) that are all related to the seed color and brightness.

Essentially, `ColorSchemeExample` takes some basic color decisions and uses them to create a full `ColorScheme` that the rest of the app can use.

## How Changes Happen (Behind the Scenes)

We said `ColorSchemeExample` is like the conductor. When you make a change (like picking a new color from a settings menu, which we'll see in later chapters), here's a simplified look at what happens:

```mermaid
sequenceDiagram
    participant User
    participant CS as ColorSchemeExample
    participant State as _ColorSchemeExampleState
    participant App as MaterialApp

    User->CS: Wants to change color
    CS->State: Calls updateTheme()
    State->State: Updates selectedColor
    State->CS: Signals state changed (setState)
    CS->App: Rebuilds with new theme data
    App-->User: App shows with new colors
```

1.  The user interacts with something (like a button) to change a setting (like the color).
2.  This interaction tells the `ColorSchemeExample` to update.
3.  The `_ColorSchemeExampleState` inside `ColorSchemeExample` updates its stored color settings (`selectedColor`, `selectedBrightness`, etc.).
4.  It then tells Flutter that its state has changed using `setState()`.
5.  Because the state changed, the `ColorSchemeExample` widget (specifically its `build` method) runs again.
6.  In the `build` method, it creates a *new* `ThemeData` with a *new* `ColorScheme.fromSeed` based on the updated settings.
7.  The `MaterialApp` uses this new theme, and the entire app visually updates to reflect the changes.

This is the fundamental way `ColorSchemeExample` manages and updates the color theme of the application. It holds the core settings, uses them to generate a `ColorScheme`, and rebuilds the app when those settings change.

## Conclusion

In this chapter, we introduced `ColorSchemeExample`, the central widget responsible for managing our app's color theme. We saw how it holds the key color settings (seed color, brightness, contrast) and uses them to create a `ColorScheme` that defines the visual look of the application. We also got a glimpse of how it reacts to changes and updates the entire app's appearance.

Now that we understand the main conductor, let's look at how we can interact with it to change those settings. In the next chapter, we'll explore the [SettingsButton](02_settingsbutton_.md), which is how a user can open the options to customize the theme.

Ready to see how we actually change these colors? Let's move on!

[Chapter 2: SettingsButton](02_settingsbutton_.md)
---
# Chapter 2: SettingsButton

Welcome back! In the last chapter, [ColorSchemeExample](01_colorschemeexample_.md), we learned about the main conductor of our app's colors. It's the widget that holds the plan for our app's look and feel. But how do we actually tell that conductor we want to change the plan? That's where the `SettingsButton` comes in!

Imagine our app as a house with the color plan managed by the architect ([ColorSchemeExample](01_colorschemeexample_.md)). The `SettingsButton` is like a special door handle on the app bar that lets us into the room where we can talk to the architect and ask for changes!

## What is SettingsButton?

The `SettingsButton` is simply a button that sits usually at the top right corner of your app screen, in the "app bar". When you tap it, it doesn't change anything visually itself. Its job is to make something *else* appear – in our case, a panel where we can change the color settings.

Think of it as a gateway. Tapping the `SettingsButton` opens the door to the settings area.

Our specific use case is simple: we want a button in our app bar that, when pressed, shows a temporary panel where we can change the color theme.

## How does SettingsButton work?

Let's look at the code for the `SettingsButton`.

```dart
class SettingsButton extends StatelessWidget {
  const SettingsButton({
    super.key,
    required this.updateTheme,
    // ... other required parameters
  });

  final void Function(Brightness, Color, double) updateTheme;

  @override
  Widget build(BuildContext context) {
    return IconButton(
      icon: const Icon(Icons.settings),
      onPressed: () {
        // This is where the magic happens!
        // It shows a small panel at the bottom.
        showModalBottomSheet<void>(
          barrierColor: Colors.transparent,
          context: context,
          builder: (BuildContext context) {
            // We'll talk about this 'Settings' widget in the next chapter!
            return Settings(
              // Pass the current settings and the way to update the theme
              selectedColor: selectedColor,
              selectedBrightness: selectedBrightness,
              selectedContrast: selectedContrast,
              updateTheme: updateTheme,
            );
          },
        );
      },
    );
  }
}
```

Let's break down the important parts:

1.  `class SettingsButton extends StatelessWidget`: This tells us that the `SettingsButton` itself doesn't change its appearance based on internal data. It's a static button, though what happens when you press it can change things elsewhere!
2.  `required this.updateTheme`: Remember how in [ColorSchemeExample](01_colorschemeexample_.md) we talked about the `updateTheme` function that actually changes the color settings? The `SettingsButton` needs to *know* about this function so it can pass it along to the settings panel.
3.  `@override Widget build(BuildContext context)`: This is where the `SettingsButton` creates its appearance.
4.  `return IconButton(...)`: This is a common Flutter widget for a button that's just an icon. It's perfect for our settings icon!
5.  `icon: const Icon(Icons.settings)`: This gives the `IconButton` the familiar gear icon used for settings.
6.  `onPressed: () { ... }`: This is the crucial part! This defines what happens *when the button is tapped*.
7.  `showModalBottomSheet<void>(...)`: This is a Flutter function that displays a temporary panel that slides up from the bottom of the screen. This is exactly what we want for our settings panel!
8.  `builder: (BuildContext context) { ... return Settings(...) }`: This part tells `showModalBottomSheet` *what* to show inside the panel. It's showing a widget called `Settings`. We'll dive deeper into this `Settings` widget in the next chapter, [Settings](03_settings_.md).

So, when you tap the `SettingsButton`, it calls `showModalBottomSheet`, which then builds and displays the `Settings` widget at the bottom of the screen. The `SettingsButton` also passes the `updateTheme` function and the *current* theme settings to the `Settings` widget so it knows what the theme is now and how to change it.

## Where does the SettingsButton live?

The `SettingsButton` is placed within the app bar of our main screen ([ColorSchemeExample](01_colorschemeexample_.md)). Look at this small snippet from the `ColorSchemeExample`'s `build` method:

```dart
  @override
  Widget build(BuildContext context) {
    return MaterialApp(
      // ... theme setup ...
      home: Scaffold(
        appBar: AppBar(
          title: const Text('ColorScheme'),
          actions: <Widget>[
            // Here it is!
            SettingsButton(
              selectedColor: selectedColor,
              selectedBrightness: selectedBrightness,
              selectedContrast: selectedContrast,
              updateTheme: updateTheme, // Passing the update function
            ),
          ],
        ),
        // ... rest of the body ...
      ),
    );
  }
```

The `AppBar` widget has an `actions` parameter, which is a list of widgets that appear at the end of the app bar (usually on the right). We simply include our `SettingsButton` in this list, and boom! It appears in the app bar. Notice how we pass the current theme settings (`selectedColor`, `selectedBrightness`, `selectedContrast`) and the `updateTheme` function to the `SettingsButton`. This allows the `SettingsButton` to then pass these along to the `Settings` panel.

## Behind the Scenes

When you tap the `SettingsButton`, here's a simplified sequence of events:

```mermaid
sequenceDiagram
    participant User
    participant SB as SettingsButton
    participant Flutter as Flutter Framework
    participant SettingsPanel as Settings (Widget)

    User->SB: Tap the button!
    SB->Flutter: Call showModalBottomSheet()
    Flutter->SettingsPanel: Build and show the Settings widget
    SettingsPanel-->User: Settings panel appears
```

1.  The user taps the icon button in the app bar.
2.  The `onPressed` function inside the `SettingsButton` is executed.
3.  This function calls `showModalBottomSheet`.
4.  `showModalBottomSheet` in the Flutter framework takes the `builder` function provided by `SettingsButton`.
5.  The `builder` function creates and returns the `Settings` widget.
6.  Flutter displays the `Settings` widget as a sliding panel from the bottom of the screen.

The `SettingsButton`'s only job here is to be the trigger that shows the settings panel. It doesn't manage the settings itself; it just opens the door for the user to interact with a different widget ([Settings](03_settings_.md)) that *does* manage the interaction.

## Conclusion

In this chapter, we explored the `SettingsButton`, the simple button in the app bar that acts as a gateway to the settings panel. We saw how it uses `showModalBottomSheet` to display another widget ([Settings](03_settings_.md)) when tapped and how it receives and passes along the necessary information to update the theme.

We now know how to open the door to change our theme settings. In the next chapter, we'll step through that door and explore the [Settings](03_settings_.md) widget itself to understand how it allows users to change the color theme.

Ready to customize? Let's move on!

[Chapter 3: Settings](03_settings_.md)
---
# Chapter 3: Settings

Welcome back, future Flutter expert! In our last chapter, [SettingsButton](02_settingsbutton_.md), we learned how to add a special button to our app's app bar. This button acts like a secret door, and when we tap it, it opens up a place where we can fine-tune the look of our app. Today, we're going to step through that door and meet the widget that lives there: the `Settings` widget!

## What is the Settings Widget?

Imagine you're sitting in the control room of a spaceship, and you have different dials and switches to adjust the lighting, the view out the window, and other cool things. The `Settings` widget is like that control panel for our app's color theme!

Its main job is to provide a user interface – a bunch of visual controls – that let you change:

*   **Brightness:** Do you want the app to be light or dark?
*   **Seed Color:** What primary color should all other colors in the app be based on?
*   **Contrast Level:** How much difference should there be between colors and text?

And the most important part? When you adjust one of these controls, the `Settings` widget talks back to the main part of our app ([ColorSchemeExample](01_colorschemeexample_.md)) and tells it, "Hey, the user wants to change the theme! Here are the new settings!"

Our specific use case is to build a panel that shows options for brightness, seed color, and contrast, and allows the user to interact with these options to change the app's theme.

## How does the Settings Widget work?

The `Settings` widget is the brain behind the settings panel that slides up from the bottom. It needs to:

1.  **Show the current settings:** When you open the panel, it should show what the current brightness, seed color, and contrast are.
2.  **Allow the user to change settings:** Provide controls (like switches, buttons, and sliders) to change the values.
3.  **Tell the main app about changes:** When a user changes a setting, it needs to communicate these changes back to [ColorSchemeExample](01_colorschemeexample_.md).

Let's look at the code for the `Settings` widget and see how it does this (from `color_scheme.0.dart`):

```dart
class Settings extends StatefulWidget {
  const Settings({
    super.key,
    required this.updateTheme,
    required this.selectedBrightness,
    required this.selectedContrast,
    required this.selectedColor,
  });

  final Brightness selectedBrightness;
  final double selectedContrast;
  final Color selectedColor;

  final void Function(Brightness, Color, double) updateTheme;

  @override
  State<Settings> createState() => _SettingsState();
}
```

*   `class Settings extends StatefulWidget`: Like [ColorSchemeExample](01_colorschemeexample_.md), `Settings` is also a `StatefulWidget`. This is because the settings panel itself needs to *remember* the values you've selected *while the panel is open*. For example, if you flip the light/dark switch, the switch itself needs to visually change its state.
*   `required this.updateTheme`, `selectedBrightness`, `selectedContrast`, `selectedColor`: These are the things that the `SettingsButton` *passes* into the `Settings` widget. Remember how the `SettingsButton` knew the current theme settings and the function to update the theme? It gives all that information to `Settings` when it opens the panel. `updateTheme` is a special function that the `Settings` widget will call to tell [ColorSchemeExample](01_colorschemeexample_.md) about the changes.

Now let's peek inside the `_SettingsState` where the actual controls are built:

```dart
class _SettingsState extends State<Settings> {
  late Brightness selectedBrightness = widget.selectedBrightness;
  late Color selectedColor = widget.selectedColor;
  late double selectedContrast = widget.selectedContrast;

  @override
  Widget build(BuildContext context) {
    return Theme(
      data: Theme.of(context).copyWith(
        // This briefly changes the theme *for the settings panel itself*
        colorScheme: ColorScheme.fromSeed(
          seedColor: selectedColor,
          contrastLevel: selectedContrast,
          brightness: selectedBrightness,
        ),
      ),
      child: ConstrainedBox(
        // ... more layout code ...
        child: Padding(
          // ... padding code ...
          child: ListView(
            children: <Widget>[
              // ... Title ...
              Row(
                children: <Widget>[
                  const Text('Brightness: '),
                  Switch(
                    value: selectedBrightness == Brightness.light,
                    onChanged: (bool value) {
                      setState(() {
                        selectedBrightness = value ? Brightness.light : Brightness.dark;
                      });
                      widget.updateTheme(selectedBrightness, selectedColor, selectedContrast); // <-- Tell the main app!
                    },
                  ),
                ],
              ),
              // ... More controls for ColorSeed and ContrastLevel ...
            ],
          ),
        ),
      ),
    );
  }
}
```

*   `late Brightness selectedBrightness = widget.selectedBrightness;`: When the `Settings` widget is created, it takes the initial brightness, color, and contrast that were passed from the `SettingsButton` and stores them in its own internal state variables. These are the values that the controls on the panel will show and modify *locally*.
*   `return Theme(...)`: This is a neat trick! It temporarily applies a theme *only* to the widgets inside this `Theme` widget. This means the settings panel itself will use the color scheme based on the *currently selected* settings, which is helpful for previewing colors within the panel.
*   `ListView`: We use a `ListView` to arrange our controls vertically. If there are many settings, this allows the user to scroll.
*   `Row(...)`: Each row in the `ListView` holds one setting control (like Brightness, Seed color, or Contrast).
*   `Switch(...)`: For the brightness setting, we use a `Switch`. When you flip the switch, the `onChanged` function is called.
*   `setState(() { ... });`: Inside `onChanged`, we first use `setState`. This updates the `selectedBrightness` variable within the `_SettingsState`. Because we used `setState`, Flutter knows that the UI for this widget needs to be re-drawn. This is why the switch visually flips!
*   `widget.updateTheme(...)`: **This is the most important line!** After updating its own internal state (`selectedBrightness`), the `Settings` widget calls the `updateTheme` function that was passed to it. It sends the *new* values for brightness, color, and contrast to this function. This function lives back in [ColorSchemeExample](01_colorschemeexample_.md), and calling it tells the main app, "Okay, the user made a change, update the whole app's theme!"

The code for the `ColorSeed` selection uses `Wrap` and `IconButton` instead of a `Switch`, and the `Contrast Level` uses a `Row` and a `Slider`, but they all follow the same pattern:

1.  Listen for a change in the control (`onPressed` for buttons, `onChanged` for slider/switch).
2.  Update the local state variable (`selectedColor` or `selectedContrast`) using `setState`.
3.  Call `widget.updateTheme` with the *latest* values of `selectedBrightness`, `selectedColor`, and `selectedContrast` to update the main app theme.

## How Changes Flow

Let's visualize the journey of a change when you interact with the `Settings` widget:

```mermaid
sequenceDiagram
    participant User
    participant SP as Settings Panel (Settings Widget)
    participant SettingsState as _SettingsState
    participant CS as ColorSchemeExample

    User->SP: Flips Brightness Switch
    SP->SettingsState: Calls onChanged
    SettingsState->SettingsState: Updates local selectedBrightness
    SettingsState->SettingsState: Calls setState() (Panel redraws)
    SettingsState->CS: Calls widget.updateTheme(new settings)
    CS->CS: Calls updateTheme()
    CS->CS: Updates internal theme settings
    CS->CS: Calls setState() (Main app redraws)
    CS-->User: Main app shows with new brightness
```

1.  The user flips the switch, taps a color circle, or moves the slider on the `Settings` panel.
2.  The corresponding `onChanged` or `onPressed` function is triggered inside the `_SettingsState`.
3.  The local state variable (like `selectedBrightness`) is updated within the `_SettingsState`.
4.  `setState()` is called, causing the `Settings` widget itself to rebuild and show the visual change (like the switch flipping or the color icon changing).
5.  Critically, `widget.updateTheme()` is called, passing the new settings values to the `updateTheme` function that [ColorSchemeExample](01_colorschemeexample_.md) provided.
6.  The `updateTheme` function inside [ColorSchemeExample](01_colorschemeexample_.md) is executed.
7.  [ColorSchemeExample](01_colorschemeexample_.md) updates its own internal theme settings (`selectedBrightness`, `selectedColor`, `selectedContrast`).
8.  [ColorSchemeExample](01_colorschemeexample_.md) calls its *own* `setState()`.
9.  Because [ColorSchemeExample](01_colorschemeexample_.md) is the main widget controlling the app's theme, the entire app rebuilds using the new `ThemeData` and `ColorScheme`.
10. The user sees the app's theme instantly change!

The `Settings` widget is like a temporary control panel. It manages the user's interaction and then passes the final desired settings back to the main `ColorSchemeExample` to apply the changes everywhere.

## Conclusion

In this chapter, we explored the `Settings` widget, the interactive panel that lets users customize the app's color theme. We saw how it takes the current settings and the `updateTheme` function from the [SettingsButton](02_settingsbutton_.md), provides controls like switches, icon buttons, and a slider, and uses `setState` to manage its own appearance while calling `widget.updateTheme` to communicate changes back to [ColorSchemeExample](01_colorschemeexample_.md).

We now understand how to open the settings and interact with them to request changes. In the next chapter, [ColorSchemeVariantColumn](04_colorschemevariantcolumn_.md), we'll start looking at how those chosen settings translate into the actual different colors that make up our theme and how they are displayed in columns on the main screen.

Ready to see the colors generated? Let's move on!

[Chapter 4: ColorSchemeVariantColumn](04_colorschemevariantcolumn_.md)
---
# Chapter 4: ColorSchemeVariantColumn

Welcome back, color explorer! In the last chapter, [Settings](03_settings_.md), we learned how to open the settings panel and use its controls to pick our desired seed color, brightness, and contrast. Now that we've made our choices, how do we actually *see* how those choices affect the *various ways* our app's colors can be generated? That's where the `ColorSchemeVariantColumn` comes in!

## What is ColorSchemeVariantColumn?

Imagine you've picked a beautiful paint color for your house ([selectedColor] in our previous terms). But paint comes in different finishes: matte, semi-gloss, high-gloss, maybe even a textured finish! Each finish uses the *same* base color but applies it in a slightly different way, creating a distinct look.

In Flutter, the `ColorScheme` can also be generated with different "finishes" or *variants*. These variants use your chosen seed color, brightness, and contrast, but they apply mathematical formulas to create the final set of colors (like primary, secondary, surface, etc.) in unique ways. Some might emphasize certain tones, others might use more neutral shades.

The `ColorSchemeVariantColumn` widget is like a display stand for one of these color variants. Its job is simple: it takes your selected color settings and a specific color scheme variant, generates the full `ColorScheme` for that variant, and then displays all the generated colors in a vertical column so you can see what that particular "finish" looks like.

Our specific use case for this chapter is to display multiple columns on the main screen, with each column showing the generated color scheme for a different variant, using the currently selected seed color, brightness, and contrast.

## How does ColorSchemeVariantColumn work?

The `ColorSchemeVariantColumn` is a pretty straightforward widget. It needs the raw ingredients (the settings you picked) and the specific "recipe" (the variant) to show you the resulting colors.

Let's look at its code from `color_scheme.0.dart`:

```dart
class ColorSchemeVariantColumn extends StatelessWidget {
  const ColorSchemeVariantColumn({
    super.key,
    this.schemeVariant = DynamicSchemeVariant.tonalSpot, // Default variant
    this.brightness = Brightness.light,
    this.contrastLevel = 0.0,
    required this.selectedColor,
  });

  final DynamicSchemeVariant schemeVariant; // The specific variant for THIS column
  final Brightness brightness;
  final double contrastLevel;
  final Color selectedColor; // The seed color you chose

  @override
  Widget build(BuildContext context) {
    // ... rest of the build method
    return Padding( // Simplified for this explanation
      padding: const EdgeInsets.symmetric(horizontal: 15),
      child: ColorSchemeView( // This widget actually displays the colors
        colorScheme: ColorScheme.fromSeed( // Generating the ColorScheme!
          seedColor: selectedColor,
          brightness: brightness,
          contrastLevel: contrastLevel,
          dynamicSchemeVariant: schemeVariant, // Using THIS column's variant
        ),
      ),
    );
  }
}
```

Here's what's happening:

1.  `class ColorSchemeVariantColumn extends StatelessWidget`: This tells us that once the settings and variant are given to it, the `ColorSchemeVariantColumn` itself doesn't change. It just displays something based on the inputs it receives.
2.  `final DynamicSchemeVariant schemeVariant;`: This is the key! Each `ColorSchemeVariantColumn` receives a different `DynamicSchemeVariant`. This tells *this specific column* which color generation rule to use.
3.  `final Brightness brightness;`, `final double contrastLevel;`, `final Color selectedColor;`: These are the global settings that are passed down from [ColorSchemeExample](01_colorschemeexample_.md). Every `ColorSchemeVariantColumn` uses the *same* currently selected settings for these.
4.  `ColorScheme.fromSeed(...)`: This is the powerful part we first saw in [ColorSchemeExample](01_colorschemeexample_.md). It takes the seed color, brightness, and contrast.
5.  `dynamicSchemeVariant: schemeVariant,`: **This is where the variant is applied!** Instead of using the default variant, *this specific column* uses the `schemeVariant` that was passed to it. This tells `ColorScheme.fromSeed` *HOW* to generate the full set of colors using the provided inputs.
6.  `ColorSchemeView(...)`: The `ColorScheme.fromSeed` function spits out a complete `ColorScheme` object (a big list of all the primary, secondary, surface colors, etc.). The `ColorSchemeVariantColumn` then passes this generated `ColorScheme` to the `ColorSchemeView` widget, which is responsible for actually drawing all those color blocks and labels on the screen. (We'll look at `ColorSchemeView` in the next chapter!)

So, each `ColorSchemeVariantColumn` is essentially instructed to: "Take these global settings (seed color, brightness, contrast) and this specific generation rule (variant), create the set of colors, and show them."

## Where does ColorSchemeVariantColumn live?

The `ColorSchemeExample` widget (our main controller) is responsible for creating multiple instances of `ColorSchemeVariantColumn`, one for each available variant.

Look at this snippet inside the `_ColorSchemeExampleState`'s `build` method (from `color_scheme.0.dart`):

```dart
  @override
  Widget build(BuildContext context) {
    return MaterialApp(
      // ... theme setup ...
      home: Scaffold(
        // ... app bar ...
        body: SingleChildScrollView( // Allows scrolling horizontally
          child: Padding(
            // ... padding ...
            child: Column(
              // ... other widgets ...
              children: <Widget>[
                SingleChildScrollView(
                  scrollDirection: Axis.horizontal,
                  child: Row( // Arranges children horizontally
                    children:
                        List<Widget>.generate(schemeVariants.length, (int index) {
                          // Create a ColorSchemeVariantColumn for EACH variant
                          return ColorSchemeVariantColumn(
                            selectedColor: selectedColor, // Pass global settings
                            brightness: selectedBrightness,
                            schemeVariant: schemeVariants[index], // Pass THIS variant
                            contrastLevel: selectedContrast,
                          );
                        }).toList(),
                  ),
                ),
              ],
            ),
          ),
        ),
      ),
    );
  }
}
```

*   `SingleChildScrollView(scrollDirection: Axis.horizontal)`: This allows us to scroll the columns left and right if there are too many to fit on the screen at once.
*   `Row(...)`: The `Row` widget places its children next to each other horizontally.
*   `List<Widget>.generate(schemeVariants.length, (int index) { ... })`: This is a neat way to automatically create a list of widgets. `schemeVariants` is a list of all the available `DynamicSchemeVariant` options. This code generates one `ColorSchemeVariantColumn` for *each* variant in that list.
*   `return ColorSchemeVariantColumn(...)`: Inside the `generate` function, we create a `ColorSchemeVariantColumn`. We pass the global settings (`selectedColor`, `selectedBrightness`, `selectedContrast`) that the `_ColorSchemeExampleState` is currently holding. Crucially, we pass a *different* `schemeVariant` (`schemeVariants[index]`) to each column we create.

This means if there are 5 different color scheme variants, the `ColorSchemeExample` creates 5 `ColorSchemeVariantColumn` widgets. Each column gets the *same* seed color, brightness, and contrast, but a *different* variant instruction. They then each generate their own `ColorScheme` according to their variant and display it.

## Behind the Scenes

When [Settings](03_settings_.md) calls `widget.updateTheme` in [ColorSchemeExample](01_colorschemeexample_.md), here's what happens related to the `ColorSchemeVariantColumn`s:

```mermaid
sequenceDiagram
    participant User
    participant Settings as Settings Panel
    participant CS as ColorSchemeExample
    participant Col as ColorSchemeVariantColumn
    participant View as ColorSchemeView
    participant CSFS as ColorScheme.fromSeed

    User->Settings: Changes Seed Color
    Settings->CS: Calls updateTheme(new color)
    CS->CS: Updates selectedColor state
    CS->CS: Calls setState() (CS redraws)
    CS->Row: Rebuilds Row of Columns
    Row->Col: Creates new ColorSchemeVariantColumn instances
    Col->CSFS: Calls ColorScheme.fromSeed with new color and its variant
    CSFS-->Col: Returns new ColorScheme
    Col->View: Passes new ColorScheme to ColorSchemeView
    View-->User: Columns update with new colors based on their variants
```

1.  The user changes a setting (e.g., the seed color) in the [Settings](03_settings_.md) panel.
2.  [Settings](03_settings_.md) calls `updateTheme` on the `ColorSchemeExample`.
3.  `ColorSchemeExample` updates its internal state (`selectedColor`, etc.) and calls its own `setState()`.
4.  `ColorSchemeExample` rebuilds its `build` method, which includes rebuilding the `Row` that holds the `ColorSchemeVariantColumn`s.
5.  The `Row` tells Flutter to create new `ColorSchemeVariantColumn` widgets (or update existing ones if optimized).
6.  Each `ColorSchemeVariantColumn` widget receives the *new* `selectedColor` (and other settings) *plus* its specific `schemeVariant`.
7.  Inside each `ColorSchemeVariantColumn`, `ColorScheme.fromSeed` is called using the new color and the column's specific variant.
8.  `ColorScheme.fromSeed` calculates and returns a complete `ColorScheme` based on these inputs.
9.  Each `ColorSchemeVariantColumn` passes its newly generated `ColorScheme` to its child `ColorSchemeView`.
10. The `ColorSchemeView` for each column updates, drawing the color blocks for that specific variant using the newly generated `ColorScheme`.
11. The user sees all the columns instantly update to show the different variants of the color scheme generated from their new seed color!

This shows how the `ColorSchemeVariantColumn` acts as an intermediate step, taking the global settings and a specific variant, calculating the related `ColorScheme`, and then passing it along to be displayed.

## Conclusion

In this chapter, we introduced the `ColorSchemeVariantColumn`, a widget responsible for displaying the colors generated by a *specific* color scheme variant. We saw how it receives the global color settings (seed color, brightness, contrast) from [ColorSchemeExample](01_colorschemeexample_.md) along with its own unique `DynamicSchemeVariant`. It uses these inputs to generate a complete `ColorScheme` for that variant using `ColorScheme.fromSeed` and then passes this generated scheme to a `ColorSchemeView` to be displayed. [ColorSchemeExample](01_colorschemeexample_.md) creates multiple instances of `ColorSchemeVariantColumn` to show you side-by-side comparisons of how different variants look with your chosen settings.

We now understand how individual columns are responsible for a single variant. In the next chapter, [ColorSchemeView](05_colorschemeview_.md), we'll dive into the widget that `ColorSchemeVariantColumn` uses to actually *display* all those different colors within each column.

Ready to see how the colors are put on display? Let's move on!

[Chapter 5: ColorSchemeView](05_colorschemeview_.md)
---
# Chapter 5: ColorSchemeView

Welcome back, color connoisseur! In our previous chapter, [ColorSchemeVariantColumn](04_colorschemevariantcolumn_.md), we saw how each column on our screen represents a different *way* of generating a set of colors from our chosen settings. Each column is like a unique paint sample board for a specific "finish" of our color scheme. But how do we actually *see* all the individual colors *within* that generated scheme on that board? That's the job of the `ColorSchemeView`!

## What is ColorSchemeView?

Imagine you open up a comprehensive paint color chart. It doesn't just show you the main color; it shows you all the related shades – the light ones, the dark ones, the accent colors that go with it, maybe even the color for the trim.

The `ColorSchemeView` widget is exactly like that color chart for a `ColorScheme`. It takes a complete `ColorScheme` (the full set of colors generated by [ColorSchemeVariantColumn](04_colorschemevariantcolumn_.md)) and lays out *all* of its individual color properties one by one. It shows you the swatch for `primary`, the swatch for `secondary`, the swatch for `surface`, and so on, along with their names. It's the widget that visually presents the *entire palette* generated by a particular variant.

Our specific use case is to display all the colors within a given `ColorScheme` in a clear, organized list within each variant column on our screen.

## How does ColorSchemeView work?

The `ColorSchemeView` is quite simple at its core. Its main requirement is the `ColorScheme` object itself. It doesn't generate colors; it just displays the colors that have already been generated.

Let's peek at the `ColorSchemeView` code (from `color_scheme.0.dart`):

```dart
class ColorSchemeView extends StatelessWidget {
  const ColorSchemeView({super.key, required this.colorScheme});

  final ColorScheme colorScheme; // It only needs the full ColorScheme!

  @override
  Widget build(BuildContext context) {
    return Column( // Arranges its children vertically
      children: <Widget>[
        // Displaying groups of related colors...
        ColorGroup( // We'll look at ColorGroup later
          children: <ColorChip>[ // We'll look at ColorChip later
            ColorChip('primary', colorScheme.primary, colorScheme.onPrimary),
            ColorChip('onPrimary', colorScheme.onPrimary, colorScheme.primary),
            // ... more ColorChip widgets for primaryContainer, onPrimaryContainer
          ],
        ),
        divider, // Just a small space
        ColorGroup(
          children: <ColorChip>[
            ColorChip('secondary', colorScheme.secondary, colorScheme.onSecondary),
            // ... more secondary colors
          ],
        ),
        divider,
        // ... ColorGroups for tertiary, error, surface, outline, etc.
      ],
    );
  }
}
```

Here's the breakdown:

1.  `class ColorSchemeView extends StatelessWidget`: Just like [ColorSchemeVariantColumn](04_colorschemevariantcolumn_.md), `ColorSchemeView` displays information given to it. It doesn't change its appearance based on internal state.
2.  `required this.colorScheme`: This confirms that the `ColorSchemeView` needs one thing: a complete `ColorScheme` object. This is the object created by `ColorScheme.fromSeed` inside the [ColorSchemeVariantColumn](04_colorschemevariantcolumn_.md).
3.  `return Column(...)`: The main layout for the `ColorSchemeView` is a `Column`, because we want to list all the color swatches vertically.
4.  `ColorGroup(...)`: Notice that the colors aren't listed individually right inside the `Column`. They are grouped together using a widget called `ColorGroup`. This helps organize the display, putting related colors (like primary and its variations) together. We'll explore `ColorGroup` in a future chapter, [ColorGroup](06_colorgroup_.md).
5.  `ColorChip(...)`: Inside each `ColorGroup`, we see many instances of the `ColorChip` widget. Each `ColorChip` is responsible for displaying a *single* color swatch with its name. For example, `ColorChip('primary', colorScheme.primary, colorScheme.onPrimary)` tells a `ColorChip` to label itself 'primary', show the color defined by `colorScheme.primary`, and use `colorScheme.onPrimary` for the text color on that swatch. We'll learn more about `ColorChip` in chapter [ColorChip](07_colorchip_.md).

So, the `ColorSchemeView` takes the full `ColorScheme`, uses `ColorGroup` to organize it, and uses `ColorChip` to display each individual color and its name.

## How is ColorSchemeView Used?

As we saw in the previous chapter, [ColorSchemeVariantColumn](04_colorschemevariantcolumn_.md) creates the `ColorScheme` based on the selected settings and its specific variant. It then passes this generated `ColorScheme` to a `ColorSchemeView`.

Look at the relevant part of the [ColorSchemeVariantColumn](04_colorschemevariantcolumn_.md) build method again:

```dart
class ColorSchemeVariantColumn extends StatelessWidget {
  // ... fields and constructor ...

  @override
  Widget build(BuildContext context) {
    return ConstrainedBox(
      // ... layout constraints ...
      child: Column(
        children: <Widget>[
          // ... Variant name text ...
          Padding(
            padding: const EdgeInsets.symmetric(horizontal: 15),
            child: ColorSchemeView( // Here's where it's used!
              colorScheme: ColorScheme.fromSeed( // The generated scheme
                seedColor: selectedColor,
                brightness: brightness,
                contrastLevel: contrastLevel,
                dynamicSchemeVariant: schemeVariant,
              ),
            ),
          ),
        ],
      ),
    );
  }
}
```

The `ColorSchemeVariantColumn` is the one that says: "Okay, I figured out what all the colors are for *my* variant based on the seed color and brightness. Now, `ColorSchemeView`, please show these colors!" And it passes the result of `ColorScheme.fromSeed` directly into the `colorScheme` property of the `ColorSchemeView`.

## Behind the Scenes

When a setting changes and a new `ColorScheme` is generated by a [ColorSchemeVariantColumn](04_colorschemevariantcolumn_.md), here's what happens concerning the `ColorSchemeView`:

```mermaid
sequenceDiagram
    participant CSVC as ColorSchemeVariantColumn
    participant CSFS as ColorScheme.fromSeed
    participant CSV as ColorSchemeView
    participant CG as ColorGroup
    participant CC as ColorChip

    CSVC->CSFS: Call ColorScheme.fromSeed (with new settings/variant)
    CSFS-->CSVC: Return new ColorScheme object
    CSVC->CSV: Create new ColorSchemeView instance (passing the new ColorScheme)
    CSV->CSV: Build its Column structure
    CSV->CG: Create ColorGroup widgets (passing parts of the ColorScheme implicitely)
    CG->CC: Create ColorChip widgets (passing individual colors and names)
    CC-->User: Displays the color swatch and name
```

1.  The `ColorSchemeVariantColumn` for a specific variant and the updated settings calls `ColorScheme.fromSeed`.
2.  `ColorScheme.fromSeed` calculates and returns a new `ColorScheme` object containing all the specific colors for that variant and those settings.
3.  The `ColorSchemeVariantColumn` creates a new `ColorSchemeView` widget and gives it this brand new `ColorScheme` object.
4.  The `ColorSchemeView` starts building its layout (the `Column`).
5.  As it builds, it creates `ColorGroup` widgets for different categories of colors.
6.  Each `ColorGroup` then creates multiple `ColorChip` widgets. It passes the specific color property (like `colorScheme.primary`, `colorScheme.secondaryContainer`, etc.) to each `ColorChip`.
7.  Each `ColorChip` then draws its small colored box and the corresponding text label.
8.  The user sees the entire list of colors within that variant column update immediately to show the new generated palette.

The `ColorSchemeView` acts as the presentation layer. It takes the complex data structure that is the `ColorScheme` and organizes and visualizes it using smaller building block widgets (`ColorGroup` and `ColorChip`).

## Conclusion

In this chapter, we focused on the `ColorSchemeView`, the widget responsible for visually displaying all the individual colors contained within a `ColorScheme`. We saw how it receives a complete `ColorScheme` object (generated by [ColorSchemeVariantColumn](04_colorschemevariantcolumn_.md)) and uses helper widgets like `ColorGroup` and `ColorChip` to present a clear, itemized list of every color swatch along with its name. It's the key to seeing the full palette of a generated theme variant.

We now know how the different color palettes are generated and displayed. In the next chapter, [ColorGroup](06_colorgroup_.md), we'll zoom in on one of the helpers that `ColorSchemeView` uses to organize the display of these colors.

Ready to learn about organizing colors? Let's move on!

[Chapter 6: ColorGroup](06_colorgroup_.md)
---
# Chapter 6: ColorGroup

Welcome back, organized designer! In our last chapter, [ColorSchemeView](05_colorschemeview_.md), we saw how that widget is responsible for displaying all the different colors that make up a `ColorScheme` for a specific variant. We noticed that it doesn't just display them all in one long, messy list. It groups related colors together! How does it do that? With the help of the `ColorGroup` widget!

## What is ColorGroup?

Imagine you have a bunch of small paint chip samples. You wouldn't just randomly scatter them on a table. You'd probably group them – maybe all the blues together, all the reds together, etc., perhaps putting each group in a little box or frame to keep them tidy.

The `ColorGroup` widget is like that box or frame for a set of color swatches. It's a simple container whose main job is to hold several `ColorChip` widgets (the individual paint chip samples) and display them together, visually separated from other groups of colors.

Its purpose is purely organizational and visual. It takes a list of `ColorChip` widgets and arranges them, usually within a subtle frame or card, to make the long list of colors in a `ColorSchemeView` easier to understand and browse.

Our specific use case for this chapter is to use `ColorGroup` to bundle related `ColorChip`s together within the `ColorSchemeView`, providing visual structure to the displayed color palette.

## How does ColorGroup work?

The `ColorGroup` widget is designed to be very simple. It doesn't know anything about colors or color schemes itself. It just knows how to take a bunch of other widgets (specifically, `ColorChip`s in our case) and display them neatly together.

Let's look at the code for `ColorGroup` (from `color_scheme.0.dart`):

```dart
class ColorGroup extends StatelessWidget {
  const ColorGroup({super.key, required this.children});

  final List<Widget> children; // It just holds a list of widgets!

  @override
  Widget build(BuildContext context) {
    return RepaintBoundary( // Useful for performance, not essential to understand grouping
      child: Card( // The 'box' or 'frame'
        clipBehavior: Clip.antiAlias,
        child: Column(children: children)), // Lay out the children vertically
    );
  }
}
```

Here's what's happening:

1.  `class ColorGroup extends StatelessWidget`: `ColorGroup` is another widget that doesn't manage its own changing data. It just displays what you give it.
2.  `required this.children`: This is the key property. The `ColorGroup` needs a `List<Widget>` as its `children`. You give it the list of widgets you want it to group together. In our app, these widgets are `ColorChip`s.
3.  `return RepaintBoundary(...)`: This is a performance optimization and not central to the grouping concept itself. We can ignore it for now.
4.  `child: Card(...)`: This is where the visual grouping happens! The `Card` widget is a common Material Design container that provides padding, elevation (a subtle shadow), and rounded corners, making its contents look like they are inside a distinct frame or box.
5.  `child: Column(children: children)`: Inside the `Card`, a `Column` is used to arrange the `children` (the list of widgets you passed in) one above the other, vertically. This is how the `ColorChip`s appear stacked within the `Card`.

Essentially, `ColorGroup` takes a list of widgets, wraps them in a `Card` for visual separation, and arranges them within that `Card` using a `Column`.

## How is ColorGroup Used?

As we saw briefly in the [ColorSchemeView](05_colorschemeview_.md) chapter, the `ColorSchemeView` is the one that creates and uses multiple `ColorGroup` widgets to display the various parts of a `ColorScheme`.

Look at the relevant part of the `ColorSchemeView` build method again:

```dart
class ColorSchemeView extends StatelessWidget {
  const ColorSchemeView({super.key, required this.colorScheme});

  final ColorScheme colorScheme;

  @override
  Widget build(BuildContext context) {
    return Column(
      children: <Widget>[
        ColorGroup( // First group!
          children: <ColorChip>[
            ColorChip('primary', colorScheme.primary, colorScheme.onPrimary),
            ColorChip('onPrimary', colorScheme.onPrimary, colorScheme.primary),
            // ... more primary-related ColorChip widgets ...
          ],
        ),
        divider, // A simple space between groups
        ColorGroup( // Second group!
          children: <ColorChip>[
            ColorChip('secondary', colorScheme.secondary, colorScheme.onSecondary),
            // ... more secondary-related ColorChip widgets ...
          ],
        ),
        divider,
        // ... Many more ColorGroup widgets for tertiary, error, surface, etc.
      ],
    );
  }
}
```

The `ColorSchemeView` doesn't just pass the entire `ColorScheme` to a single `ColorGroup`. Instead, it actively creates *multiple* `ColorGroup` widgets. For each `ColorGroup`, it specifically lists the `ColorChip` widgets that correspond to a related set of colors (like primary, secondary, error, surface, etc.) and passes *that specific list* to the `children` property of that `ColorGroup`.

This is where the organization happens. The developer building the `ColorSchemeView` decides which colors belong in which group (e.g., all `primary` related colors, all `error` related colors) and manually creates a `ColorGroup` for each category, filling its `children` list with the appropriate `ColorChip`s.

## Behind the Scenes

When a `ColorSchemeView` is built or rebuilt (because the settings changed and a new `ColorScheme` was generated), here's what happens with the `ColorGroup` widgets:

```mermaid
sequenceDiagram
    participant CSV as ColorSchemeView
    participant CG as ColorGroup
    participant Card as Flutter Card Widget
    participant Column as Flutter Column Widget
    participant CC as ColorChip

    CSV->CSV: Build its main Column
    CSV->CG: Create a ColorGroup (e.g., for "primary" colors)
    CSV->CG: Pass a list of relevant ColorChip widgets to its children
    CG->Card: Build a Card widget
    Card->Column: Build a Column widget inside the Card
    Column->CC: Arrange and display the ColorChip widgets passed to the ColorGroup
    CC-->User: Show the individual color swatches inside the Card
    CSV->CSV: Create another ColorGroup (e.g., for "secondary" colors)
    CSV->CG: Repeat the process for the next group...
    CG-->User: Another Card display appears with the next group of colors
```

1.  The `ColorSchemeView` widget is built, creating its main vertical `Column`.
2.  It starts creating the first `ColorGroup` (e.g., the one for primary colors).
3.  It creates a list containing only the `ColorChip` widgets for `primary`, `onPrimary`, `primaryContainer`, etc., and passes this list to the `children` of the `ColorGroup`.
4.  The `ColorGroup` widget receives this list and starts building *its* content.
5.  It creates a `Card` widget.
6.  Inside the `Card`, it creates a `Column` widget.
7.  It tells the internal `Column` to display the list of `ColorChip` widgets it received as its `children`.
8.  Each `ColorChip` in that list then draws itself (a colored box with text).
9.  These drawn `ColorChip`s appear stacked vertically inside the `Card`.
10. The `ColorSchemeView` then continues creating the next `ColorGroup` for the next set of colors (secondary, tertiary, etc.), repeating the process.
11. The user sees a series of distinct "cards" or "boxes" stacked vertically inside each variant column, with each card containing a logically grouped set of color swatches.

The `ColorGroup` doesn't decide *which* colors go together; the developer using `ColorSchemeView` decides that by creating multiple `ColorGroup`s and putting the appropriate `ColorChip`s into each one's `children` list. The `ColorGroup` just provides the visual structure (the "box") for whatever list of widgets it's given.

## Conclusion

In this chapter, we explored the `ColorGroup` widget, a simple but effective container used within `ColorSchemeView` to organize the display of color swatches. We saw how it takes a list of child widgets (typically `ColorChip`s) and presents them neatly within a `Card` and a `Column`, helping to break down the large list of colors into understandable groups. It's a basic building block for structuring the visual output of the generated color schemes.

We now understand how different colors within a generated `ColorScheme` are grouped together for clarity. In the next chapter, [ColorChip](07_colorchip_.md), we'll zoom in even further and explore the smallest unit of display: the individual color swatch itself.

Ready to look at the individual color samples? Let's move on!

[Chapter 7: ColorChip](07_colorchip_.md)

Relevant Code Snippets (Code itself remains unchanged):
--- File: color_scheme.0.dart ---
// Copyright 2014 The Flutter Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

import 'package:flutter/material.dart';

/// Flutter code sample for [ColorScheme].

const Widget divider = SizedBox(height: 10);

void main() => runApp(const ColorSchemeExample());

class ColorSchemeExample extends StatefulWidget {
  const ColorSchemeExample({super.key});

  @override
  State<ColorSchemeExample> createState() => _ColorSchemeExampleState();
}

class _ColorSchemeExampleState extends State<ColorSchemeExample> {
  Color selectedColor = ColorSeed.baseColor.color;
  Brightness selectedBrightness = Brightness.light;
  double selectedContrast = 0.0;
  static const List<DynamicSchemeVariant> schemeVariants = DynamicSchemeVariant.values;

  void updateTheme(Brightness brightness, Color color, double contrastLevel) {
    setState(() {
      selectedBrightness = brightness;
      selectedColor = color;
      selectedContrast = contrastLevel;
    });
  }

  @override
  Widget build(BuildContext context) {
    return MaterialApp(
      debugShowCheckedModeBanner: false,
      theme: ThemeData(
        colorScheme: ColorScheme.fromSeed(
          seedColor: selectedColor,
          brightness: selectedBrightness,
          contrastLevel: selectedContrast,
        ),
      ),
      home: Scaffold(
        appBar: AppBar(
          title: const Text('ColorScheme'),
          actions: <Widget>[
            SettingsButton(
              selectedColor: selectedColor,
              selectedBrightness: selectedBrightness,
              selectedContrast: selectedContrast,
              updateTheme: updateTheme,
            ),
          ],
        ),
        body: SingleChildScrollView(
          child: Padding(
            padding: const EdgeInsets.only(top: 5),
            child: Column(
              crossAxisAlignment: CrossAxisAlignment.start,
              children: <Widget>[
                SingleChildScrollView(
                  scrollDirection: Axis.horizontal,
                  child: Row(
                    children:
                        List<Widget>.generate(schemeVariants.length, (int index) {
                          return ColorSchemeVariantColumn(
                            selectedColor: selectedColor,
                            brightness: selectedBrightness,
                            schemeVariant: schemeVariants[index],
                            contrastLevel: selectedContrast,
                          );
                        }).toList(),
                  ),
                ),
              ],
            ),
          ),
        ),
      ),
    );
  }
}

class Settings extends StatefulWidget {
  const Settings({
    super.key,
    required this.updateTheme,
    required this.selectedBrightness,
    required this.selectedContrast,
    required this.selectedColor,
  });

  final Brightness selectedBrightness;
  final double selectedContrast;
  final Color selectedColor;

  final void Function(Brightness, Color, double) updateTheme;

  @override
  State<Settings> createState() => _SettingsState();
}

class _SettingsState extends State<Settings> {
  late Brightness selectedBrightness = widget.selectedBrightness;
  late Color selectedColor = widget.selectedColor;
  late double selectedContrast = widget.selectedContrast;

  @override
  Widget build(BuildContext context) {
    return Theme(
      data: Theme.of(context).copyWith(
        colorScheme: ColorScheme.fromSeed(
          seedColor: selectedColor,
          contrastLevel: selectedContrast,
          brightness: selectedBrightness,
        ),
      ),
      child: ConstrainedBox(
        constraints: const BoxConstraints(maxHeight: 200),
        child: Padding(
          padding: const EdgeInsets.all(20.0),
          child: ListView(
            children: <Widget>[
              Center(child: Text('Settings', style: Theme.of(context).textTheme.titleLarge)),
              Row(
                children: <Widget>[
                  const Text('Brightness: '),
                  Switch(
                    value: selectedBrightness == Brightness.light,
                    onChanged: (bool value) {
                      setState(() {
                        selectedBrightness = value ? Brightness.light : Brightness.dark;
                      });
                      widget.updateTheme(selectedBrightness, selectedColor, selectedContrast);
                    },
                  ),
                ],
              ),
              Wrap(
                crossAxisAlignment: WrapCrossAlignment.center,
                children: <Widget>[
                  const Text('Seed color: '),
                  ...List<Widget>.generate(ColorSeed.values.length, (int index) {
                    final Color itemColor = ColorSeed.values[index].color;
                    return IconButton(
                      icon:
                          selectedColor == ColorSeed.values[index].color
                              ? Icon(Icons.circle, color: itemColor)
                              : Icon(Icons.circle_outlined, color: itemColor),
                      onPressed: () {
                        setState(() {
                          selectedColor = itemColor;
                        });
                        widget.updateTheme(selectedBrightness, selectedColor, selectedContrast);
                      },
                    );
                  }),
                ],
              ),
              Row(
                children: <Widget>[
                  const Text('Contrast level: '),
                  Expanded(
                    child: Slider(
                      divisions: 4,
                      label: selectedContrast.toString(),
                      min: -1,
                      value: selectedContrast,
                      onChanged: (double value) {
                        setState(() {
                          selectedContrast = value;
                        });
                        widget.updateTheme(selectedBrightness, selectedColor, selectedContrast);
                      },
                    ),
                  ),
                ],
              ),
            ],
          ),
        ),
      ),
    );
  }
}

class ColorSchemeVariantColumn extends StatelessWidget {
  const ColorSchemeVariantColumn({
    super.key,
    this.schemeVariant = DynamicSchemeVariant.tonalSpot,
    this.brightness = Brightness.light,
    this.contrastLevel = 0.0,
    required this.selectedColor,
  });

  final DynamicSchemeVariant schemeVariant;
  final Brightness brightness;
  final double contrastLevel;
  final Color selectedColor;

  @override
  Widget build(BuildContext context) {
    return ConstrainedBox(
      constraints: const BoxConstraints.tightFor(width: 250),
      child: Column(
        children: <Widget>[
          Padding(
            padding: const EdgeInsets.symmetric(vertical: 15),
            child: Text(
              schemeVariant.name == 'tonalSpot'
                  ? '${schemeVariant.name} (Default)'
                  : schemeVariant.name,
              style: const TextStyle(fontWeight: FontWeight.bold),
            ),
          ),
          Padding(
            padding: const EdgeInsets.symmetric(horizontal: 15),
            child: ColorSchemeView(
              colorScheme: ColorScheme.fromSeed(
                seedColor: selectedColor,
                brightness: brightness,
                contrastLevel: contrastLevel,
                dynamicSchemeVariant: schemeVariant,
              ),
            ),
          ),
        ],
      ),
    );
  }
}

class ColorSchemeView extends StatelessWidget {
  const ColorSchemeView({super.key, required this.colorScheme});

  final ColorScheme colorScheme;

  @override
  Widget build(BuildContext context) {
    return Column(
      children: <Widget>[
        ColorGroup(
          children: <ColorChip>[
            ColorChip('primary', colorScheme.primary, colorScheme.onPrimary),
            ColorChip('onPrimary', colorScheme.onPrimary, colorScheme.primary),
            ColorChip(
              'primaryContainer',
              colorScheme.primaryContainer,
              colorScheme.onPrimaryContainer,
            ),
            ColorChip(
              'onPrimaryContainer',
              colorScheme.onPrimaryContainer,
              colorScheme.primaryContainer,
            ),
          ],
        ),
        divider,
        ColorGroup(
          children: <ColorChip>[
            ColorChip('primaryFixed', colorScheme.primaryFixed, colorScheme.onPrimaryFixed),
            ColorChip('onPrimaryFixed', colorScheme.onPrimaryFixed, colorScheme.primaryFixed),
            ColorChip(
              'primaryFixedDim',
              colorScheme.primaryFixedDim,
              colorScheme.onPrimaryFixedVariant,
            ),
            ColorChip(
              'onPrimaryFixedVariant',
              colorScheme.onPrimaryFixedVariant,
              colorScheme.primaryFixedDim,
            ),
          ],
        ),
        divider,
        ColorGroup(
          children: <ColorChip>[
            ColorChip('secondary', colorScheme.secondary, colorScheme.onSecondary),
            ColorChip('onSecondary', colorScheme.onSecondary, colorScheme.secondary),
            ColorChip(
              'secondaryContainer',
              colorScheme.secondaryContainer,
              colorScheme.onSecondaryContainer,
            ),
            ColorChip(
              'onSecondaryContainer',
              colorScheme.onSecondaryContainer,
              colorScheme.secondaryContainer,
            ),
          ],
        ),
        divider,
        ColorGroup(
          children: <ColorChip>[
            ColorChip('secondaryFixed', colorScheme.secondaryFixed, colorScheme.onSecondaryFixed),
            ColorChip('onSecondaryFixed', colorScheme.onSecondaryFixed, colorScheme.secondaryFixed),
            ColorChip(
              'secondaryFixedDim',
              colorScheme.secondaryFixedDim,
              colorScheme.onSecondaryFixedVariant,
            ),
            ColorChip(
              'onSecondaryFixedVariant',
              colorScheme.onSecondaryFixedVariant,
              colorScheme.secondaryFixedDim,
            ),
          ],
        ),
        divider,
        ColorGroup(
          children: <ColorChip>[
            ColorChip('tertiary', colorScheme.tertiary, colorScheme.onTertiary),
            ColorChip('onTertiary', colorScheme.onTertiary, colorScheme.tertiary),
            ColorChip(
              'tertiaryContainer',
              colorScheme.tertiaryContainer,
              colorScheme.onTertiaryContainer,
            ),
            ColorChip(
              'onTertiaryContainer',
              colorScheme.onTertiaryContainer,
              colorScheme.tertiaryContainer,
            ),
          ],
        ),
        divider,
        ColorGroup(
          children: <ColorChip>[
            ColorChip('tertiaryFixed', colorScheme.tertiaryFixed, colorScheme.onTertiaryFixed),
            ColorChip('onTertiaryFixed', colorScheme.onTertiaryFixed, colorScheme.tertiaryFixed),
            ColorChip(
              'tertiaryFixedDim',
              colorScheme.tertiaryFixedDim,
              colorScheme.onTertiaryFixedVariant,
            ),
            ColorChip(
              'onTertiaryFixedVariant',
              colorScheme.onTertiaryFixedVariant,
              colorScheme.tertiaryFixedDim,
            ),
          ],
        ),
        divider,
        ColorGroup(
          children: <ColorChip>[
            ColorChip('error', colorScheme.error, colorScheme.onError),
            ColorChip('onError', colorScheme.onError, colorScheme.error),
            ColorChip('errorContainer', colorScheme.errorContainer, colorScheme.onErrorContainer),
            ColorChip('onErrorContainer', colorScheme.onErrorContainer, colorScheme.errorContainer),
          ],
        ),
        divider,
        ColorGroup(
          children: <ColorChip>[
            ColorChip('surfaceDim', colorScheme.surfaceDim, colorScheme.onSurface),
            ColorChip('surface', colorScheme.surface, colorScheme.onSurface),
            ColorChip('surfaceBright', colorScheme.surfaceBright, colorScheme.onSurface),
            ColorChip(
              'surfaceContainerLowest',
              colorScheme.surfaceContainerLowest,
              colorScheme.onSurface,
            ),
            ColorChip(
              'surfaceContainerLow',
              colorScheme.surfaceContainerLow,
              colorScheme.onSurface,
            ),
            ColorChip('surfaceContainer', colorScheme.surfaceContainer, colorScheme.onSurface),
            ColorChip(
              'surfaceContainerHigh',
              colorScheme.surfaceContainerHigh,
              colorScheme.onSurface,
            ),
            ColorChip(
              'surfaceContainerHighest',
              colorScheme.surfaceContainerHighest,
              colorScheme.onSurface,
            ),
            ColorChip('onSurface', colorScheme.onSurface, colorScheme.surface),
            ColorChip(
              'onSurfaceVariant',
              colorScheme.onSurfaceVariant,
              colorScheme.surfaceContainerHighest,
            ),
          ],
        ),
        divider,
        ColorGroup(
          children: <ColorChip>[
            ColorChip('outline', colorScheme.outline, null),
            ColorChip('shadow', colorScheme.shadow, null),
            ColorChip('inverseSurface', colorScheme.inverseSurface, colorScheme.onInverseSurface),
            ColorChip('onInverseSurface', colorScheme.onInverseSurface, colorScheme.inverseSurface),
            ColorChip('inversePrimary', colorScheme.inversePrimary, colorScheme.primary),
          ],
        ),
      ],
    );
  }
}

class ColorGroup extends StatelessWidget {
  const ColorGroup({super.key, required this.children});

  final List<Widget> children;

  @override
  Widget build(BuildContext context) {
    return RepaintBoundary(
      child: Card(clipBehavior: Clip.antiAlias, child: Column(children: children)),
    );
  }
}

class ColorChip extends StatelessWidget {
  const ColorChip(this.label, this.color, this.onColor, {super.key});

  final Color color;
  final Color? onColor;
  final String label;

  static Color contrastColor(Color color) {
    final Brightness brightness = ThemeData.estimateBrightnessForColor(color);
    return brightness == Brightness.dark ? Colors.white : Colors.black;
  }

  @override
  Widget build(BuildContext context) {
    final Color labelColor = onColor ?? contrastColor(color);
    return ColoredBox(
      color: color,
      child: Padding(
        padding: const EdgeInsets.all(16),
        child: Row(
          children: <Expanded>[Expanded(child: Text(label, style: TextStyle(color: labelColor)))],
        ),
      ),
    );
  }
}

enum ColorSeed {
  baseColor('M3 Baseline', Color(0xff6750a4)),
  indigo('Indigo', Colors.indigo),
  blue('Blue', Colors.blue),
  teal('Teal', Colors.teal),
  green('Green', Colors.green),
  yellow('Yellow', Colors.yellow),
  orange('Orange', Colors.orange),
  deepOrange('Deep Orange', Colors.deepOrange),
  pink('Pink', Colors.pink),
  brightBlue('Bright Blue', Color(0xFF0000FF)),
  brightGreen('Bright Green', Color(0xFF00FF00)),
  brightRed('Bright Red', Color(0xFFFF0000));

  const ColorSeed(this.label, this.color);
  final String label;
  final Color color;
}

class SettingsButton extends StatelessWidget {
  const SettingsButton({
    super.key,
    required this.updateTheme,
    required this.selectedBrightness,
    required this.selectedContrast,
    required this.selectedColor,
  });

  final Brightness selectedBrightness;
  final double selectedContrast;
  final Color selectedColor;

  final void Function(Brightness, Color, double) updateTheme;

  @override
  Widget build(BuildContext context) {
    return IconButton(
      icon: const Icon(Icons.settings),
      onPressed: () {
        showModalBottomSheet<void>(
          barrierColor: Colors.transparent,
          context: context,
          builder: (BuildContext context) {
            return Settings(
              selectedColor: selectedColor,
              selectedBrightness: selectedBrightness,
              selectedContrast: selectedContrast,
              updateTheme: updateTheme,
            );
          },
        );
      },
    );
  }
}


Instructions for the chapter (Generate content in English unless specified otherwise):
- Start with a clear heading (e.g., `# Chapter 7: ColorChip
`). Use the provided concept name.

- If this is not the first chapter, begin with a brief transition from the previous chapter, referencing it with a proper Markdown link using its name.

- Begin with a high-level motivation explaining what problem this abstraction solves. Start with a central use case as a concrete example. The whole chapter should guide the reader to understand how to solve this use case. Make it very minimal and friendly to beginners.

- If the abstraction is complex, break it down into key concepts. Explain each concept one-by-one in a very beginner-friendly way.

- Explain how to use this abstraction to solve the use case. Give example inputs and outputs for code snippets (if the output isn't values, describe at a high level what will happen).

- Each code block should be BELOW 10 lines! If longer code blocks are needed, break them down into smaller pieces and walk through them one-by-one. Aggresively simplify the code to make it minimal. Use comments to skip non-important implementation details. Each code block should have a beginner friendly explanation right after it.

- Describe the internal implementation to help understand what's under the hood. First provide a non-code or code-light walkthrough on what happens step-by-step when the abstraction is called. It's recommended to use a simple sequenceDiagram with a dummy example - keep it minimal with at most 5 participants to ensure clarity. If participant name has space, use: `participant QP as Query Processing`. .

- Then dive deeper into code for the internal implementation with references to files. Provide example code blocks, but make them similarly simple and beginner-friendly. Explain.

- IMPORTANT: When you need to refer to other core abstractions covered in other chapters, ALWAYS use proper Markdown links like this: [Chapter Title](filename.md). Use the Complete Tutorial Structure above to find the correct filename and the chapter title. Translate the surrounding text.

- Use mermaid diagrams to illustrate complex concepts (```mermaid``` format). .

- Heavily use analogies and examples throughout to help beginners understand.

- End the chapter with a brief conclusion that summarizes what was learned and provides a transition to the next chapter. If there is a next chapter, use a proper Markdown link: [Next Chapter Title](next_chapter_filename).

- Ensure the tone is welcoming and easy for a newcomer to understand.

- Output *only* the Markdown content for this chapter.

Now, directly provide a super beginner-friendly Markdown output (DON'T need ```markdown``` tags):

2025-05-28 16:31:31,756 - INFO - RESPONSE: # Chapter 7: ColorChip

Welcome back, color sampler! In our last chapter, [ColorGroup](06_colorgroup_.md), we learned how to use `ColorGroup` containers to keep related color swatches together, making our `ColorSchemeView` display more organized. But what about the individual color swatches themselves? The little boxes that show a specific color? That's the job of the `ColorChip`!

## What is ColorChip?

Imagine you're at the paint store, and you pick up one of those small cards that shows a specific paint color. It shows the color itself, maybe the color's name, and sometimes even a little square showing what text would look like *on* that color.

The `ColorChip` widget is exactly that little paint sample card for a single color in our app. Its purpose is solely to visually represent *one* specific color from our `ColorScheme`, show its name, and optionally show what text would look good on top of it.

It's the smallest building block in our color visualization! [ColorSchemeView](05_colorschemeview_.md) uses [ColorGroup](06_colorgroup_.md) to group them, and [ColorGroup](06_colorgroup_.md) then displays these individual `ColorChip`s.

Our specific use case for this chapter is to display a single color swatch, its name, and a contrasting text color within the `ColorSchemeView`, inside a [ColorGroup](06_colorgroup_.md).

## How does ColorChip work?

The `ColorChip` widget is designed to be very focused. It needs three pieces of information:

1.  **The name of the color:** What is this color called? (e.g., 'primary', 'surface', 'error')
2.  **The color itself:** The actual `Color` value.
3.  **A contrasting color for text:** What color text should be shown on this color so it's easy to read?

Let's look at the code for `ColorChip` (from `color_scheme.0.dart`):

```dart
class ColorChip extends StatelessWidget {
  const ColorChip(this.label, this.color, this.onColor, {super.key});

  final Color color; // The background color of the chip
  final Color? onColor; // The suggested text color on top
  final String label; // The color's name

  static Color contrastColor(Color color) {
    // Helper function to figure out black or white text for contrast
    final Brightness brightness = ThemeData.estimateBrightnessForColor(color);
    return brightness == Brightness.dark ? Colors.white : Colors.black;
  }

  @override
  Widget build(BuildContext context) {
    // Determine the text color based on 'onColor' or calculated contrast
    final Color labelColor = onColor ?? contrastColor(color);
    return ColoredBox( // Widget that simply paints a box with a color
      color: color, // Use the color provided for the background
      child: Padding( // Add some space inside the box
        padding: const EdgeInsets.all(16),
        child: Row( // Arrange content horizontally
          children: <Expanded>[
            Expanded(
              child: Text(
                label, // Display the color's name
                style: TextStyle(color: labelColor) // Use the determined text color
              )
            )
          ],
        ),
      ),
    );
  }
}
```

Here's the breakdown:

1.  `class ColorChip extends StatelessWidget`: Like its parent [ColorGroup](06_colorgroup_.md) and ancestor [ColorSchemeView](05_colorschemeview_.md), `ColorChip` is static. It just displays the information it receives.
2.  `const ColorChip(this.label, this.color, this.onColor, {super.key});`: This is a constructor that takes the three key pieces of information: the `label` (String name), the `color` (the `Color` object), and the `onColor` (an optional suggested color for text on top).
3.  `final Color color;`, `final Color? onColor;`, `final String label;`: These store the information passed into the constructor. `onColor` is marked with `?` meaning it could be null (not provided).
4.  `static Color contrastColor(Color color)`: This is a helper function. If no `onColor` is provided, this function checks if the background `color` is light or dark and suggests either black or white for good contrast.
5.  `final Color labelColor = onColor ?? contrastColor(color);`: This line decides the color of the text label. It first checks if `onColor` was provided (`onColor ?? ...`). If it was (not null), it uses *that* color. If `onColor` is null, it calls `contrastColor(color)` to get a contrasting color (black or white).
6.  `return ColoredBox(...)`: This widget is used to draw a rectangular box filled with a single color.
7.  `color: color,`: This tells the `ColoredBox` to use the `color` property (the background color passed to the `ColorChip`).
8.  `child: Padding(...)`: Adds some space *inside* the `ColoredBox` so the text isn't right up against the edges.
9.  `child: Row(...)`: Arranges the content inside the padding horizontally. In this case, it holds the text label.
10. `Expanded(child: Text(...))`: The `Expanded` widget makes the `Text` widget take up the available horizontal space within the `Row`.
11. `Text(label, style: TextStyle(color: labelColor))`: This creates the text label itself. It displays the `label` string (the color's name) and sets its text color to `labelColor` (which we determined in step 5).

So, `ColorChip` paints a box with the given color, adds some padding, and places the color's name inside the padding using a text color that provides good contrast.

## How is ColorChip Used?

As we saw in the [ColorSchemeView](05_colorschemeview_.md) chapter, `ColorChip` widgets are created directly inside `ColorSchemeView` and then passed as children to `ColorGroup` widgets.

Look at a snippet from the `ColorSchemeView` build method again:

```dart
class ColorSchemeView extends StatelessWidget {
  const ColorSchemeView({super.key, required this.colorScheme});

  final ColorScheme colorScheme;

  @override
  Widget build(BuildContext context) {
    return Column(
      children: <Widget>[
        ColorGroup(
          children: <ColorChip>[ // List of ColorChip widgets
            ColorChip('primary', colorScheme.primary, colorScheme.onPrimary), // A ColorChip!
            ColorChip('onPrimary', colorScheme.onPrimary, colorScheme.primary), // Another ColorChip!
            // ... more ColorChip widgets ...
          ],
        ),
        // ... other ColorGroup widgets ...
      ],
    );
  }
}
```

The `ColorSchemeView` is responsible for knowing *which* color properties exist in a `ColorScheme` and creating a specific `ColorChip` for each one it wants to display.

For example, `ColorSchemeView` knows about the `primary` color property in the `colorScheme` object. It also knows about the standard related color meant for text *on* the primary color, which is `onPrimary`. So, it creates a `ColorChip` like this:

`ColorChip('primary', colorScheme.primary, colorScheme.onPrimary)`

*   The label is `'primary'`, which is the name of the color property.
*   The background color is `colorScheme.primary`, which is the actual `Color` value.
*   The suggested text color is `colorScheme.onPrimary`.

It does this for `secondary`, `surface`, `error`, and many other color properties within the `ColorScheme`, creating a multitude of `ColorChip` widgets, and then groups them using [ColorGroup](06_colorgroup_.md).

## Behind the Scenes

When a `ColorSchemeView` is built and it creates `ColorChip` widgets, here's the simple process for each `ColorChip`:

```mermaid
sequenceDiagram
    participant CSV as ColorSchemeView
    participant CG as ColorGroup
    participant CC as ColorChip
    participant ColoredBox as Flutter ColoredBox
    participant Text as Flutter Text

    CSV->CG: Creates ColorGroup (eg. primary)
    CG->CG: Receives list of ColorChips
    CG->CC: Builds each ColorChip in its list
    CC->CC: Determines labelColor
    CC->ColoredBox: Builds a ColoredBox with its color
    ColoredBox->Padding: Builds Padding inside itself
    Padding->Row: Builds Row inside itself
    Row->Text: Builds Text widget with label and labelColor
    Text-->User: Displays the colored box with text
```

1.  The `ColorSchemeView` decides to create a `ColorChip` for a specific color property (e.g., `primary`).
2.  It creates the `ColorChip` instance, passing the label ('primary'), the color (`colorScheme.primary`), and the suggested text color (`colorScheme.onPrimary`).
3.  The `ColorChip` starts building its internal widgets.
4.  It determines the best text color (`labelColor`), using `onColor` if available, otherwise using `contrastColor`.
5.  It creates a `ColoredBox` and gives it the background `color`.
6.  Inside the `ColoredBox`, it creates `Padding`.
7.  Inside the `Padding`, it creates a `Row`.
8.  Inside the `Row`, it creates an `Expanded` widget containing a `Text` widget.
9.  The `Text` widget is given the `label` string and the calculated `labelColor`.
10. Flutter draws the `ColoredBox` with the background color and places the text label on top, showing the color sample to the user.

Each `ColorChip` is an independent unit that knows how to draw *one* color sample based on the color and label it receives.

## Conclusion

In this chapter, we got up close and personal with the `ColorChip`, the smallest visual component in our app's color display. We learned how it takes a specific color value, its name (label), and an optional contrasting text color. We saw how it uses `ColoredBox` to draw the color and `Text` to display the label, ensuring good contrast using its internal logic or a provided `onColor`. `ColorChip` is the fundamental piece that, when organized by [ColorGroup](06_colorgroup_.md) and displayed by [ColorSchemeView](05_colorschemeview_.md) within a [ColorSchemeVariantColumn](04_colorschemevariantcolumn_.md), allows us to see the generated color schemes based on settings from [Settings](03_settings_.md), opened by the [SettingsButton](02_settingsbutton_.md), all managed by [ColorSchemeExample](01_colorschemeexample_.md)!

We've now explored how all the individual generated colors are displayed. In the next and final chapter, [ColorSeed](08_colorseed_.md), we'll look at where the initial suggestion for our primary color comes from, the very "seed" that starts the whole color generation process.

Ready to discover the origin of our colors? Let's move on!

[Chapter 8: ColorSeed](08_colorseed_.md)
2025-05-28 16:31:31,764 - INFO - PROMPT: 
Write a very beginner-friendly tutorial chapter (in Markdown format) for the project `flutter` about the concept: "ColorSeed
". This is Chapter 8.

Concept Details:
- Name: ColorSeed

- Description:
An enumeration that defines a set of predefined colors that can be used as the starting point (seed) for generating a `ColorScheme`.
These are like popular starter colors you can pick from a catalog to base your entire color scheme on.


Complete Tutorial Structure:
1. [ColorSchemeExample
](01_colorschemeexample_.md)
2. [SettingsButton
](02_settingsbutton_.md)
3. [Settings
](03_settings_.md)
4. [ColorSchemeVariantColumn
](04_colorschemevariantcolumn_.md)
5. [ColorSchemeView
](05_colorschemeview_.md)
6. [ColorGroup
](06_colorgroup_.md)
7. [ColorChip
](07_colorchip_.md)
8. [ColorSeed
](08_colorseed_.md)

Context from previous chapters:
# Chapter 1: ColorSchemeExample

Welcome, aspiring Flutter developer! In this chapter, we're going to meet the main conductor of our app's visual symphony: `ColorSchemeExample`. Think of this like the main boss or the central hub of our application. It's the widget that gets everything started and keeps track of the overall look and feel, specifically the colors!

## What is ColorSchemeExample?

Imagine you're building a house, and you want to decide on the paint colors, the brightness of the rooms, and how much contrast you want between different elements. The `ColorSchemeExample` is like the architect who holds the master plan for all these color decisions. It decides things like:

*   **What are the main colors of the app?**
*   **Should the app be light or dark?** (Brightness)
*   **How much difference should there be between colors and text?** (Contrast)

And the best part? If you change any of these decisions (like choosing a different main color), the `ColorSchemeExample` knows and makes sure the *whole* house (your app) updates to the new plan.

Our specific use case for this chapter is to see how `ColorSchemeExample` manages the initial color settings of our app.

## How does ColorSchemeExample work?

Let's take a look at the main part of the `ColorSchemeExample` code. Don't worry about understanding every single line right away. We'll break it down.

```dart
void main() => runApp(const ColorSchemeExample());

class ColorSchemeExample extends StatefulWidget {
  const ColorSchemeExample({super.key});

  @override
  State<ColorSchemeExample> createState() => _ColorSchemeExampleState();
}

class _ColorSchemeExampleState extends State<ColorSchemeExample> {
  Color selectedColor = ColorSeed.baseColor.color;
  Brightness selectedBrightness = Brightness.light;
  double selectedContrast = 0.0;
  // ... other code
}
```

This code shows us a couple of key things:

1.  `void main() => runApp(const ColorSchemeExample());`: This is where our app starts! It tells Flutter to run the `ColorSchemeExample` widget.
2.  `ColorSchemeExample extends StatefulWidget`: This means our `ColorSchemeExample` can change over time. If you change the color settings, the widget can rebuild itself to show the new colors.
3.  `_ColorSchemeExampleState`: This is where the `ColorSchemeExample` keeps track of its state, or its current settings. Notice `selectedColor`, `selectedBrightness`, and `selectedContrast`. These are the main color-related decisions it's currently holding.

So, when the app first starts, `ColorSchemeExample` sets up its initial color decisions (like the default primary color, brightness, and contrast).

## Setting up the Theme

The `ColorSchemeExample` also uses these color decisions to set the overall theme of the app. Let's look at the `build` method:

```dart
@override
Widget build(BuildContext context) {
  return MaterialApp(
    debugShowCheckedModeBanner: false,
    theme: ThemeData(
      colorScheme: ColorScheme.fromSeed(
        seedColor: selectedColor,
        brightness: selectedBrightness,
        contrastLevel: selectedContrast,
      ),
    ),
    // ... rest of the build method
  );
}
```

Here's what's happening:

*   `return MaterialApp(...)`: This is the basic structure for a Flutter app. It provides important things like navigation and theming.
*   `theme: ThemeData(...)`: This is where we define the visual theme for our app.
*   `colorScheme: ColorScheme.fromSeed(...)`: This is a super helpful way to create a whole set of colors for your app based on just one "seed" color. `ColorSchemeExample` uses its `selectedColor`, `selectedBrightness`, and `selectedContrast` to generate a complete `ColorScheme`. This `ColorScheme` contains many different color definitions (like primary, secondary, surface, etc.) that are all related to the seed color and brightness.

Essentially, `ColorSchemeExample` takes some basic color decisions and uses them to create a full `ColorScheme` that the rest of the app can use.

## How Changes Happen (Behind the Scenes)

We said `ColorSchemeExample` is like the conductor. When you make a change (like picking a new color from a settings menu, which we'll see in later chapters), here's a simplified look at what happens:

```mermaid
sequenceDiagram
    participant User
    participant CS as ColorSchemeExample
    participant State as _ColorSchemeExampleState
    participant App as MaterialApp

    User->CS: Wants to change color
    CS->State: Calls updateTheme()
    State->State: Updates selectedColor
    State->CS: Signals state changed (setState)
    CS->App: Rebuilds with new theme data
    App-->User: App shows with new colors
```

1.  The user interacts with something (like a button) to change a setting (like the color).
2.  This interaction tells the `ColorSchemeExample` to update.
3.  The `_ColorSchemeExampleState` inside `ColorSchemeExample` updates its stored color settings (`selectedColor`, `selectedBrightness`, etc.).
4.  It then tells Flutter that its state has changed using `setState()`.
5.  Because the state changed, the `ColorSchemeExample` widget (specifically its `build` method) runs again.
6.  In the `build` method, it creates a *new* `ThemeData` with a *new* `ColorScheme.fromSeed` based on the updated settings.
7.  The `MaterialApp` uses this new theme, and the entire app visually updates to reflect the changes.

This is the fundamental way `ColorSchemeExample` manages and updates the color theme of the application. It holds the core settings, uses them to generate a `ColorScheme`, and rebuilds the app when those settings change.

## Conclusion

In this chapter, we introduced `ColorSchemeExample`, the central widget responsible for managing our app's color theme. We saw how it holds the key color settings (seed color, brightness, contrast) and uses them to create a `ColorScheme` that defines the visual look of the application. We also got a glimpse of how it reacts to changes and updates the entire app's appearance.

Now that we understand the main conductor, let's look at how we can interact with it to change those settings. In the next chapter, we'll explore the [SettingsButton](02_settingsbutton_.md), which is how a user can open the options to customize the theme.

Ready to see how we actually change these colors? Let's move on!

[Chapter 2: SettingsButton](02_settingsbutton_.md)
---
# Chapter 2: SettingsButton

Welcome back! In the last chapter, [ColorSchemeExample](01_colorschemeexample_.md), we learned about the main conductor of our app's colors. It's the widget that holds the plan for our app's look and feel. But how do we actually tell that conductor we want to change the plan? That's where the `SettingsButton` comes in!

Imagine our app as a house with the color plan managed by the architect ([ColorSchemeExample](01_colorschemeexample_.md)). The `SettingsButton` is like a special door handle on the app bar that lets us into the room where we can talk to the architect and ask for changes!

## What is SettingsButton?

The `SettingsButton` is simply a button that sits usually at the top right corner of your app screen, in the "app bar". When you tap it, it doesn't change anything visually itself. Its job is to make something *else* appear – in our case, a panel where we can change the color settings.

Think of it as a gateway. Tapping the `SettingsButton` opens the door to the settings area.

Our specific use case is simple: we want a button in our app bar that, when pressed, shows a temporary panel where we can change the color theme.

## How does SettingsButton work?

Let's look at the code for the `SettingsButton`.

```dart
class SettingsButton extends StatelessWidget {
  const SettingsButton({
    super.key,
    required this.updateTheme,
    // ... other required parameters
  });

  final void Function(Brightness, Color, double) updateTheme;

  @override
  Widget build(BuildContext context) {
    return IconButton(
      icon: const Icon(Icons.settings),
      onPressed: () {
        // This is where the magic happens!
        // It shows a small panel at the bottom.
        showModalBottomSheet<void>(
          barrierColor: Colors.transparent,
          context: context,
          builder: (BuildContext context) {
            // We'll talk about this 'Settings' widget in the next chapter!
            return Settings(
              // Pass the current settings and the way to update the theme
              selectedColor: selectedColor,
              selectedBrightness: selectedBrightness,
              selectedContrast: selectedContrast,
              updateTheme: updateTheme,
            );
          },
        );
      },
    );
  }
}
```

Let's break down the important parts:

1.  `class SettingsButton extends StatelessWidget`: This tells us that the `SettingsButton` itself doesn't change its appearance based on internal data. It's a static button, though what happens when you press it can change things elsewhere!
2.  `required this.updateTheme`: Remember how in [ColorSchemeExample](01_colorschemeexample_.md) we talked about the `updateTheme` function that actually changes the color settings? The `SettingsButton` needs to *know* about this function so it can pass it along to the settings panel.
3.  `@override Widget build(BuildContext context)`: This is where the `SettingsButton` creates its appearance.
4.  `return IconButton(...)`: This is a common Flutter widget for a button that's just an icon. It's perfect for our settings icon!
5.  `icon: const Icon(Icons.settings)`: This gives the `IconButton` the familiar gear icon used for settings.
6.  `onPressed: () { ... }`: This is the crucial part! This defines what happens *when the button is tapped*.
7.  `showModalBottomSheet<void>(...)`: This is a Flutter function that displays a temporary panel that slides up from the bottom of the screen. This is exactly what we want for our settings panel!
8.  `builder: (BuildContext context) { ... return Settings(...) }`: This part tells `showModalBottomSheet` *what* to show inside the panel. It's showing a widget called `Settings`. We'll dive deeper into this `Settings` widget in the next chapter, [Settings](03_settings_.md).

So, when you tap the `SettingsButton`, it calls `showModalBottomSheet`, which then builds and displays the `Settings` widget at the bottom of the screen. The `SettingsButton` also passes the `updateTheme` function and the *current* theme settings to the `Settings` widget so it knows what the theme is now and how to change it.

## Where does the SettingsButton live?

The `SettingsButton` is placed within the app bar of our main screen ([ColorSchemeExample](01_colorschemeexample_.md)). Look at this small snippet from the `ColorSchemeExample`'s `build` method:

```dart
  @override
  Widget build(BuildContext context) {
    return MaterialApp(
      // ... theme setup ...
      home: Scaffold(
        appBar: AppBar(
          title: const Text('ColorScheme'),
          actions: <Widget>[
            // Here it is!
            SettingsButton(
              selectedColor: selectedColor,
              selectedBrightness: selectedBrightness,
              selectedContrast: selectedContrast,
              updateTheme: updateTheme, // Passing the update function
            ),
          ],
        ),
        // ... rest of the body ...
      ),
    );
  }
```

The `AppBar` widget has an `actions` parameter, which is a list of widgets that appear at the end of the app bar (usually on the right). We simply include our `SettingsButton` in this list, and boom! It appears in the app bar. Notice how we pass the current theme settings (`selectedColor`, `selectedBrightness`, `selectedContrast`) and the `updateTheme` function to the `SettingsButton`. This allows the `SettingsButton` to then pass these along to the `Settings` panel.

## Behind the Scenes

When you tap the `SettingsButton`, here's a simplified sequence of events:

```mermaid
sequenceDiagram
    participant User
    participant SB as SettingsButton
    participant Flutter as Flutter Framework
    participant SettingsPanel as Settings (Widget)

    User->SB: Tap the button!
    SB->Flutter: Call showModalBottomSheet()
    Flutter->SettingsPanel: Build and show the Settings widget
    SettingsPanel-->User: Settings panel appears
```

1.  The user taps the icon button in the app bar.
2.  The `onPressed` function inside the `SettingsButton` is executed.
3.  This function calls `showModalBottomSheet`.
4.  `showModalBottomSheet` in the Flutter framework takes the `builder` function provided by `SettingsButton`.
5.  The `builder` function creates and returns the `Settings` widget.
6.  Flutter displays the `Settings` widget as a sliding panel from the bottom of the screen.

The `SettingsButton`'s only job here is to be the trigger that shows the settings panel. It doesn't manage the settings itself; it just opens the door for the user to interact with a different widget ([Settings](03_settings_.md)) that *does* manage the interaction.

## Conclusion

In this chapter, we explored the `SettingsButton`, the simple button in the app bar that acts as a gateway to the settings panel. We saw how it uses `showModalBottomSheet` to display another widget ([Settings](03_settings_.md)) when tapped and how it receives and passes along the necessary information to update the theme.

We now know how to open the door to change our theme settings. In the next chapter, we'll step through that door and explore the [Settings](03_settings_.md) widget itself to understand how it allows users to change the color theme.

Ready to customize? Let's move on!

[Chapter 3: Settings](03_settings_.md)
---
# Chapter 3: Settings

Welcome back, future Flutter expert! In our last chapter, [SettingsButton](02_settingsbutton_.md), we learned how to add a special button to our app's app bar. This button acts like a secret door, and when we tap it, it opens up a place where we can fine-tune the look of our app. Today, we're going to step through that door and meet the widget that lives there: the `Settings` widget!

## What is the Settings Widget?

Imagine you're sitting in the control room of a spaceship, and you have different dials and switches to adjust the lighting, the view out the window, and other cool things. The `Settings` widget is like that control panel for our app's color theme!

Its main job is to provide a user interface – a bunch of visual controls – that let you change:

*   **Brightness:** Do you want the app to be light or dark?
*   **Seed Color:** What primary color should all other colors in the app be based on?
*   **Contrast Level:** How much difference should there be between colors and text?

And the most important part? When you adjust one of these controls, the `Settings` widget talks back to the main part of our app ([ColorSchemeExample](01_colorschemeexample_.md)) and tells it, "Hey, the user wants to change the theme! Here are the new settings!"

Our specific use case is to build a panel that shows options for brightness, seed color, and contrast, and allows the user to interact with these options to change the app's theme.

## How does the Settings Widget work?

The `Settings` widget is the brain behind the settings panel that slides up from the bottom. It needs to:

1.  **Show the current settings:** When you open the panel, it should show what the current brightness, seed color, and contrast are.
2.  **Allow the user to change settings:** Provide controls (like switches, buttons, and sliders) to change the values.
3.  **Tell the main app about changes:** When a user changes a setting, it needs to communicate these changes back to [ColorSchemeExample](01_colorschemeexample_.md).

Let's look at the code for the `Settings` widget and see how it does this (from `color_scheme.0.dart`):

```dart
class Settings extends StatefulWidget {
  const Settings({
    super.key,
    required this.updateTheme,
    required this.selectedBrightness,
    required this.selectedContrast,
    required this.selectedColor,
  });

  final Brightness selectedBrightness;
  final double selectedContrast;
  final Color selectedColor;

  final void Function(Brightness, Color, double) updateTheme;

  @override
  State<Settings> createState() => _SettingsState();
}
```

*   `class Settings extends StatefulWidget`: Like [ColorSchemeExample](01_colorschemeexample_.md), `Settings` is also a `StatefulWidget`. This is because the settings panel itself needs to *remember* the values you've selected *while the panel is open*. For example, if you flip the light/dark switch, the switch itself needs to visually change its state.
*   `required this.updateTheme`, `selectedBrightness`, `selectedContrast`, `selectedColor`: These are the things that the `SettingsButton` *passes* into the `Settings` widget. Remember how the `SettingsButton` knew the current theme settings and the function to update the theme? It gives all that information to `Settings` when it opens the panel. `updateTheme` is a special function that the `Settings` widget will call to tell [ColorSchemeExample](01_colorschemeexample_.md) about the changes.

Now let's peek inside the `_SettingsState` where the actual controls are built:

```dart
class _SettingsState extends State<Settings> {
  late Brightness selectedBrightness = widget.selectedBrightness;
  late Color selectedColor = widget.selectedColor;
  late double selectedContrast = widget.selectedContrast;

  @override
  Widget build(BuildContext context) {
    return Theme(
      data: Theme.of(context).copyWith(
        // This briefly changes the theme *for the settings panel itself*
        colorScheme: ColorScheme.fromSeed(
          seedColor: selectedColor,
          contrastLevel: selectedContrast,
          brightness: selectedBrightness,
        ),
      ),
      child: ConstrainedBox(
        // ... more layout code ...
        child: Padding(
          // ... padding code ...
          child: ListView(
            children: <Widget>[
              // ... Title ...
              Row(
                children: <Widget>[
                  const Text('Brightness: '),
                  Switch(
                    value: selectedBrightness == Brightness.light,
                    onChanged: (bool value) {
                      setState(() {
                        selectedBrightness = value ? Brightness.light : Brightness.dark;
                      });
                      widget.updateTheme(selectedBrightness, selectedColor, selectedContrast); // <-- Tell the main app!
                    },
                  ),
                ],
              ),
              // ... More controls for ColorSeed and ContrastLevel ...
            ],
          ),
        ),
      ),
    );
  }
}
```

*   `late Brightness selectedBrightness = widget.selectedBrightness;`: When the `Settings` widget is created, it takes the initial brightness, color, and contrast that were passed from the `SettingsButton` and stores them in its own internal state variables. These are the values that the controls on the panel will show and modify *locally*.
*   `return Theme(...)`: This is a neat trick! It temporarily applies a theme *only* to the widgets inside this `Theme` widget. This means the settings panel itself will use the color scheme based on the *currently selected* settings, which is helpful for previewing colors within the panel.
*   `ListView`: We use a `ListView` to arrange our controls vertically. If there are many settings, this allows the user to scroll.
*   `Row(...)`: Each row in the `ListView` holds one setting control (like Brightness, Seed color, or Contrast).
*   `Switch(...)`: For the brightness setting, we use a `Switch`. When you flip the switch, the `onChanged` function is called.
*   `setState(() { ... });`: Inside `onChanged`, we first use `setState`. This updates the `selectedBrightness` variable within the `_SettingsState`. Because we used `setState`, Flutter knows that the UI for this widget needs to be re-drawn. This is why the switch visually flips!
*   `widget.updateTheme(...)`: **This is the most important line!** After updating its own internal state (`selectedBrightness`), the `Settings` widget calls the `updateTheme` function that was passed to it. It sends the *new* values for brightness, color, and contrast to this function. This function lives back in [ColorSchemeExample](01_colorschemeexample_.md), and calling it tells the main app, "Okay, the user made a change, update the whole app's theme!"

The code for the `ColorSeed` selection uses `Wrap` and `IconButton` instead of a `Switch`, and the `Contrast Level` uses a `Row` and a `Slider`, but they all follow the same pattern:

1.  Listen for a change in the control (`onPressed` for buttons, `onChanged` for slider/switch).
2.  Update the local state variable (`selectedColor` or `selectedContrast`) using `setState`.
3.  Call `widget.updateTheme` with the *latest* values of `selectedBrightness`, `selectedColor`, and `selectedContrast` to update the main app theme.

## How Changes Flow

Let's visualize the journey of a change when you interact with the `Settings` widget:

```mermaid
sequenceDiagram
    participant User
    participant SP as Settings Panel (Settings Widget)
    participant SettingsState as _SettingsState
    participant CS as ColorSchemeExample

    User->SP: Flips Brightness Switch
    SP->SettingsState: Calls onChanged
    SettingsState->SettingsState: Updates local selectedBrightness
    SettingsState->SettingsState: Calls setState() (Panel redraws)
    SettingsState->CS: Calls widget.updateTheme(new settings)
    CS->CS: Calls updateTheme()
    CS->CS: Updates internal theme settings
    CS->CS: Calls setState() (Main app redraws)
    CS-->User: Main app shows with new brightness
```

1.  The user flips the switch, taps a color circle, or moves the slider on the `Settings` panel.
2.  The corresponding `onChanged` or `onPressed` function is triggered inside the `_SettingsState`.
3.  The local state variable (like `selectedBrightness`) is updated within the `_SettingsState`.
4.  `setState()` is called, causing the `Settings` widget itself to rebuild and show the visual change (like the switch flipping or the color icon changing).
5.  Critically, `widget.updateTheme()` is called, passing the new settings values to the `updateTheme` function that [ColorSchemeExample](01_colorschemeexample_.md) provided.
6.  The `updateTheme` function inside [ColorSchemeExample](01_colorschemeexample_.md) is executed.
7.  [ColorSchemeExample](01_colorschemeexample_.md) updates its own internal theme settings (`selectedBrightness`, `selectedColor`, `selectedContrast`).
8.  [ColorSchemeExample](01_colorschemeexample_.md) calls its *own* `setState()`.
9.  Because [ColorSchemeExample](01_colorschemeexample_.md) is the main widget controlling the app's theme, the entire app rebuilds using the new `ThemeData` and `ColorScheme`.
10. The user sees the app's theme instantly change!

The `Settings` widget is like a temporary control panel. It manages the user's interaction and then passes the final desired settings back to the main `ColorSchemeExample` to apply the changes everywhere.

## Conclusion

In this chapter, we explored the `Settings` widget, the interactive panel that lets users customize the app's color theme. We saw how it takes the current settings and the `updateTheme` function from the [SettingsButton](02_settingsbutton_.md), provides controls like switches, icon buttons, and a slider, and uses `setState` to manage its own appearance while calling `widget.updateTheme` to communicate changes back to [ColorSchemeExample](01_colorschemeexample_.md).

We now understand how to open the settings and interact with them to request changes. In the next chapter, [ColorSchemeVariantColumn](04_colorschemevariantcolumn_.md), we'll start looking at how those chosen settings translate into the actual different colors that make up our theme and how they are displayed in columns on the main screen.

Ready to see the colors generated? Let's move on!

[Chapter 4: ColorSchemeVariantColumn](04_colorschemevariantcolumn_.md)
---
# Chapter 4: ColorSchemeVariantColumn

Welcome back, color explorer! In the last chapter, [Settings](03_settings_.md), we learned how to open the settings panel and use its controls to pick our desired seed color, brightness, and contrast. Now that we've made our choices, how do we actually *see* how those choices affect the *various ways* our app's colors can be generated? That's where the `ColorSchemeVariantColumn` comes in!

## What is ColorSchemeVariantColumn?

Imagine you've picked a beautiful paint color for your house ([selectedColor] in our previous terms). But paint comes in different finishes: matte, semi-gloss, high-gloss, maybe even a textured finish! Each finish uses the *same* base color but applies it in a slightly different way, creating a distinct look.

In Flutter, the `ColorScheme` can also be generated with different "finishes" or *variants*. These variants use your chosen seed color, brightness, and contrast, but they apply mathematical formulas to create the final set of colors (like primary, secondary, surface, etc.) in unique ways. Some might emphasize certain tones, others might use more neutral shades.

The `ColorSchemeVariantColumn` widget is like a display stand for one of these color variants. Its job is simple: it takes your selected color settings and a specific color scheme variant, generates the full `ColorScheme` for that variant, and then displays all the generated colors in a vertical column so you can see what that particular "finish" looks like.

Our specific use case for this chapter is to display multiple columns on the main screen, with each column showing the generated color scheme for a different variant, using the currently selected seed color, brightness, and contrast.

## How does ColorSchemeVariantColumn work?

The `ColorSchemeVariantColumn` is a pretty straightforward widget. It needs the raw ingredients (the settings you picked) and the specific "recipe" (the variant) to show you the resulting colors.

Let's look at its code from `color_scheme.0.dart`:

```dart
class ColorSchemeVariantColumn extends StatelessWidget {
  const ColorSchemeVariantColumn({
    super.key,
    this.schemeVariant = DynamicSchemeVariant.tonalSpot, // Default variant
    this.brightness = Brightness.light,
    this.contrastLevel = 0.0,
    required this.selectedColor,
  });

  final DynamicSchemeVariant schemeVariant; // The specific variant for THIS column
  final Brightness brightness;
  final double contrastLevel;
  final Color selectedColor; // The seed color you chose

  @override
  Widget build(BuildContext context) {
    // ... rest of the build method
    return Padding( // Simplified for this explanation
      padding: const EdgeInsets.symmetric(horizontal: 15),
      child: ColorSchemeView( // This widget actually displays the colors
        colorScheme: ColorScheme.fromSeed( // Generating the ColorScheme!
          seedColor: selectedColor,
          brightness: brightness,
          contrastLevel: contrastLevel,
          dynamicSchemeVariant: schemeVariant, // Using THIS column's variant
        ),
      ),
    );
  }
}
```

Here's what's happening:

1.  `class ColorSchemeVariantColumn extends StatelessWidget`: This tells us that once the settings and variant are given to it, the `ColorSchemeVariantColumn` itself doesn't change. It just displays something based on the inputs it receives.
2.  `final DynamicSchemeVariant schemeVariant;`: This is the key! Each `ColorSchemeVariantColumn` receives a different `DynamicSchemeVariant`. This tells *this specific column* which color generation rule to use.
3.  `final Brightness brightness;`, `final double contrastLevel;`, `final Color selectedColor;`: These are the global settings that are passed down from [ColorSchemeExample](01_colorschemeexample_.md). Every `ColorSchemeVariantColumn` uses the *same* currently selected settings for these.
4.  `ColorScheme.fromSeed(...)`: This is the powerful part we first saw in [ColorSchemeExample](01_colorschemeexample_.md). It takes the seed color, brightness, and contrast.
5.  `dynamicSchemeVariant: schemeVariant,`: **This is where the variant is applied!** Instead of using the default variant, *this specific column* uses the `schemeVariant` that was passed to it. This tells `ColorScheme.fromSeed` *HOW* to generate the full set of colors using the provided inputs.
6.  `ColorSchemeView(...)`: The `ColorScheme.fromSeed` function spits out a complete `ColorScheme` object (a big list of all the primary, secondary, surface colors, etc.). The `ColorSchemeVariantColumn` then passes this generated `ColorScheme` to the `ColorSchemeView` widget, which is responsible for actually drawing all those color blocks and labels on the screen. (We'll look at `ColorSchemeView` in the next chapter!)

So, each `ColorSchemeVariantColumn` is essentially instructed to: "Take these global settings (seed color, brightness, contrast) and this specific generation rule (variant), create the set of colors, and show them."

## Where does ColorSchemeVariantColumn live?

The `ColorSchemeExample` widget (our main controller) is responsible for creating multiple instances of `ColorSchemeVariantColumn`, one for each available variant.

Look at this snippet inside the `_ColorSchemeExampleState`'s `build` method (from `color_scheme.0.dart`):

```dart
  @override
  Widget build(BuildContext context) {
    return MaterialApp(
      // ... theme setup ...
      home: Scaffold(
        // ... app bar ...
        body: SingleChildScrollView( // Allows scrolling horizontally
          child: Padding(
            // ... padding ...
            child: Column(
              // ... other widgets ...
              children: <Widget>[
                SingleChildScrollView(
                  scrollDirection: Axis.horizontal,
                  child: Row( // Arranges children horizontally
                    children:
                        List<Widget>.generate(schemeVariants.length, (int index) {
                          // Create a ColorSchemeVariantColumn for EACH variant
                          return ColorSchemeVariantColumn(
                            selectedColor: selectedColor, // Pass global settings
                            brightness: selectedBrightness,
                            schemeVariant: schemeVariants[index], // Pass THIS variant
                            contrastLevel: selectedContrast,
                          );
                        }).toList(),
                  ),
                ),
              ],
            ),
          ),
        ),
      ),
    );
  }
}
```

*   `SingleChildScrollView(scrollDirection: Axis.horizontal)`: This allows us to scroll the columns left and right if there are too many to fit on the screen at once.
*   `Row(...)`: The `Row` widget places its children next to each other horizontally.
*   `List<Widget>.generate(schemeVariants.length, (int index) { ... })`: This is a neat way to automatically create a list of widgets. `schemeVariants` is a list of all the available `DynamicSchemeVariant` options. This code generates one `ColorSchemeVariantColumn` for *each* variant in that list.
*   `return ColorSchemeVariantColumn(...)`: Inside the `generate` function, we create a `ColorSchemeVariantColumn`. We pass the global settings (`selectedColor`, `selectedBrightness`, `selectedContrast`) that the `_ColorSchemeExampleState` is currently holding. Crucially, we pass a *different* `schemeVariant` (`schemeVariants[index]`) to each column we create.

This means if there are 5 different color scheme variants, the `ColorSchemeExample` creates 5 `ColorSchemeVariantColumn` widgets. Each column gets the *same* seed color, brightness, and contrast, but a *different* variant instruction. They then each generate their own `ColorScheme` according to their variant and display it.

## Behind the Scenes

When [Settings](03_settings_.md) calls `widget.updateTheme` in [ColorSchemeExample](01_colorschemeexample_.md), here's what happens related to the `ColorSchemeVariantColumn`s:

```mermaid
sequenceDiagram
    participant User
    participant Settings as Settings Panel
    participant CS as ColorSchemeExample
    participant Col as ColorSchemeVariantColumn
    participant View as ColorSchemeView
    participant CSFS as ColorScheme.fromSeed

    User->Settings: Changes Seed Color
    Settings->CS: Calls updateTheme(new color)
    CS->CS: Updates selectedColor state
    CS->CS: Calls setState() (CS redraws)
    CS->Row: Rebuilds Row of Columns
    Row->Col: Creates new ColorSchemeVariantColumn instances
    Col->CSFS: Calls ColorScheme.fromSeed with new color and its variant
    CSFS-->Col: Returns new ColorScheme
    Col->View: Passes new ColorScheme to ColorSchemeView
    View-->User: Columns update with new colors based on their variants
```

1.  The user changes a setting (e.g., the seed color) in the [Settings](03_settings_.md) panel.
2.  [Settings](03_settings_.md) calls `updateTheme` on the `ColorSchemeExample`.
3.  `ColorSchemeExample` updates its internal state (`selectedColor`, etc.) and calls its own `setState()`.
4.  `ColorSchemeExample` rebuilds its `build` method, which includes rebuilding the `Row` that holds the `ColorSchemeVariantColumn`s.
5.  The `Row` tells Flutter to create new `ColorSchemeVariantColumn` widgets (or update existing ones if optimized).
6.  Each `ColorSchemeVariantColumn` widget receives the *new* `selectedColor` (and other settings) *plus* its specific `schemeVariant`.
7.  Inside each `ColorSchemeVariantColumn`, `ColorScheme.fromSeed` is called using the new color and the column's specific variant.
8.  `ColorScheme.fromSeed` calculates and returns a complete `ColorScheme` based on these inputs.
9.  Each `ColorSchemeVariantColumn` passes its newly generated `ColorScheme` to its child `ColorSchemeView`.
10. The `ColorSchemeView` for each column updates, drawing the color blocks for that specific variant using the newly generated `ColorScheme`.
11. The user sees all the columns instantly update to show the different variants of the color scheme generated from their new seed color!

This shows how the `ColorSchemeVariantColumn` acts as an intermediate step, taking the global settings and a specific variant, calculating the related `ColorScheme`, and then passing it along to be displayed.

## Conclusion

In this chapter, we introduced the `ColorSchemeVariantColumn`, a widget responsible for displaying the colors generated by a *specific* color scheme variant. We saw how it receives the global color settings (seed color, brightness, contrast) from [ColorSchemeExample](01_colorschemeexample_.md) along with its own unique `DynamicSchemeVariant`. It uses these inputs to generate a complete `ColorScheme` for that variant using `ColorScheme.fromSeed` and then passes this generated scheme to a `ColorSchemeView` to be displayed. [ColorSchemeExample](01_colorschemeexample_.md) creates multiple instances of `ColorSchemeVariantColumn` to show you side-by-side comparisons of how different variants look with your chosen settings.

We now understand how individual columns are responsible for a single variant. In the next chapter, [ColorSchemeView](05_colorschemeview_.md), we'll dive into the widget that `ColorSchemeVariantColumn` uses to actually *display* all those different colors within each column.

Ready to see how the colors are put on display? Let's move on!

[Chapter 5: ColorSchemeView](05_colorschemeview_.md)
---
# Chapter 5: ColorSchemeView

Welcome back, color connoisseur! In our previous chapter, [ColorSchemeVariantColumn](04_colorschemevariantcolumn_.md), we saw how each column on our screen represents a different *way* of generating a set of colors from our chosen settings. Each column is like a unique paint sample board for a specific "finish" of our color scheme. But how do we actually *see* all the individual colors *within* that generated scheme on that board? That's the job of the `ColorSchemeView`!

## What is ColorSchemeView?

Imagine you open up a comprehensive paint color chart. It doesn't just show you the main color; it shows you all the related shades – the light ones, the dark ones, the accent colors that go with it, maybe even the color for the trim.

The `ColorSchemeView` widget is exactly like that color chart for a `ColorScheme`. It takes a complete `ColorScheme` (the full set of colors generated by [ColorSchemeVariantColumn](04_colorschemevariantcolumn_.md)) and lays out *all* of its individual color properties one by one. It shows you the swatch for `primary`, the swatch for `secondary`, the swatch for `surface`, and so on, along with their names. It's the widget that visually presents the *entire palette* generated by a particular variant.

Our specific use case is to display all the colors within a given `ColorScheme` in a clear, organized list within each variant column on our screen.

## How does ColorSchemeView work?

The `ColorSchemeView` is quite simple at its core. Its main requirement is the `ColorScheme` object itself. It doesn't generate colors; it just displays the colors that have already been generated.

Let's peek at the `ColorSchemeView` code (from `color_scheme.0.dart`):

```dart
class ColorSchemeView extends StatelessWidget {
  const ColorSchemeView({super.key, required this.colorScheme});

  final ColorScheme colorScheme; // It only needs the full ColorScheme!

  @override
  Widget build(BuildContext context) {
    return Column( // Arranges its children vertically
      children: <Widget>[
        // Displaying groups of related colors...
        ColorGroup( // We'll look at ColorGroup later
          children: <ColorChip>[ // We'll look at ColorChip later
            ColorChip('primary', colorScheme.primary, colorScheme.onPrimary),
            ColorChip('onPrimary', colorScheme.onPrimary, colorScheme.primary),
            // ... more ColorChip widgets for primaryContainer, onPrimaryContainer
          ],
        ),
        divider, // Just a small space
        ColorGroup(
          children: <ColorChip>[
            ColorChip('secondary', colorScheme.secondary, colorScheme.onSecondary),
            // ... more secondary colors
          ],
        ),
        divider,
        // ... ColorGroups for tertiary, error, surface, outline, etc.
      ],
    );
  }
}
```

Here's the breakdown:

1.  `class ColorSchemeView extends StatelessWidget`: Just like [ColorSchemeVariantColumn](04_colorschemevariantcolumn_.md), `ColorSchemeView` displays information given to it. It doesn't change its appearance based on internal state.
2.  `required this.colorScheme`: This confirms that the `ColorSchemeView` needs one thing: a complete `ColorScheme` object. This is the object created by `ColorScheme.fromSeed` inside the [ColorSchemeVariantColumn](04_colorschemevariantcolumn_.md).
3.  `return Column(...)`: The main layout for the `ColorSchemeView` is a `Column`, because we want to list all the color swatches vertically.
4.  `ColorGroup(...)`: Notice that the colors aren't listed individually right inside the `Column`. They are grouped together using a widget called `ColorGroup`. This helps organize the display, putting related colors (like primary and its variations) together. We'll explore `ColorGroup` in a future chapter, [ColorGroup](06_colorgroup_.md).
5.  `ColorChip(...)`: Inside each `ColorGroup`, we see many instances of the `ColorChip` widget. Each `ColorChip` is responsible for displaying a *single* color swatch with its name. For example, `ColorChip('primary', colorScheme.primary, colorScheme.onPrimary)` tells a `ColorChip` to label itself 'primary', show the color defined by `colorScheme.primary`, and use `colorScheme.onPrimary` for the text color on that swatch. We'll learn more about `ColorChip` in chapter [ColorChip](07_colorchip_.md).

So, the `ColorSchemeView` takes the full `ColorScheme`, uses `ColorGroup` to organize it, and uses `ColorChip` to display each individual color and its name.

## How is ColorSchemeView Used?

As we saw in the previous chapter, [ColorSchemeVariantColumn](04_colorschemevariantcolumn_.md) creates the `ColorScheme` based on the selected settings and its specific variant. It then passes this generated `ColorScheme` to a `ColorSchemeView`.

Look at the relevant part of the [ColorSchemeVariantColumn](04_colorschemevariantcolumn_.md) build method again:

```dart
class ColorSchemeVariantColumn extends StatelessWidget {
  // ... fields and constructor ...

  @override
  Widget build(BuildContext context) {
    return ConstrainedBox(
      // ... layout constraints ...
      child: Column(
        children: <Widget>[
          // ... Variant name text ...
          Padding(
            padding: const EdgeInsets.symmetric(horizontal: 15),
            child: ColorSchemeView( // Here's where it's used!
              colorScheme: ColorScheme.fromSeed( // The generated scheme
                seedColor: selectedColor,
                brightness: brightness,
                contrastLevel: contrastLevel,
                dynamicSchemeVariant: schemeVariant,
              ),
            ),
          ),
        ],
      ),
    );
  }
}
```

The `ColorSchemeVariantColumn` is the one that says: "Okay, I figured out what all the colors are for *my* variant based on the seed color and brightness. Now, `ColorSchemeView`, please show these colors!" And it passes the result of `ColorScheme.fromSeed` directly into the `colorScheme` property of the `ColorSchemeView`.

## Behind the Scenes

When a setting changes and a new `ColorScheme` is generated by a [ColorSchemeVariantColumn](04_colorschemevariantcolumn_.md), here's what happens concerning the `ColorSchemeView`:

```mermaid
sequenceDiagram
    participant CSVC as ColorSchemeVariantColumn
    participant CSFS as ColorScheme.fromSeed
    participant CSV as ColorSchemeView
    participant CG as ColorGroup
    participant CC as ColorChip

    CSVC->CSFS: Call ColorScheme.fromSeed (with new settings/variant)
    CSFS-->CSVC: Return new ColorScheme object
    CSVC->CSV: Create new ColorSchemeView instance (passing the new ColorScheme)
    CSV->CSV: Build its Column structure
    CSV->CG: Create ColorGroup widgets (passing parts of the ColorScheme implicitely)
    CG->CC: Create ColorChip widgets (passing individual colors and names)
    CC-->User: Displays the color swatch and name
```

1.  The `ColorSchemeVariantColumn` for a specific variant and the updated settings calls `ColorScheme.fromSeed`.
2.  `ColorScheme.fromSeed` calculates and returns a new `ColorScheme` object containing all the specific colors for that variant and those settings.
3.  The `ColorSchemeVariantColumn` creates a new `ColorSchemeView` widget and gives it this brand new `ColorScheme` object.
4.  The `ColorSchemeView` starts building its layout (the `Column`).
5.  As it builds, it creates `ColorGroup` widgets for different categories of colors.
6.  Each `ColorGroup` then creates multiple `ColorChip` widgets. It passes the specific color property (like `colorScheme.primary`, `colorScheme.secondaryContainer`, etc.) to each `ColorChip`.
7.  Each `ColorChip` then draws its small colored box and the corresponding text label.
8.  The user sees the entire list of colors within that variant column update immediately to show the new generated palette.

The `ColorSchemeView` acts as the presentation layer. It takes the complex data structure that is the `ColorScheme` and organizes and visualizes it using smaller building block widgets (`ColorGroup` and `ColorChip`).

## Conclusion

In this chapter, we focused on the `ColorSchemeView`, the widget responsible for visually displaying all the individual colors contained within a `ColorScheme`. We saw how it receives a complete `ColorScheme` object (generated by [ColorSchemeVariantColumn](04_colorschemevariantcolumn_.md)) and uses helper widgets like `ColorGroup` and `ColorChip` to present a clear, itemized list of every color swatch along with its name. It's the key to seeing the full palette of a generated theme variant.

We now know how the different color palettes are generated and displayed. In the next chapter, [ColorGroup](06_colorgroup_.md), we'll zoom in on one of the helpers that `ColorSchemeView` uses to organize the display of these colors.

Ready to learn about organizing colors? Let's move on!

[Chapter 6: ColorGroup](06_colorgroup_.md)
---
# Chapter 6: ColorGroup

Welcome back, organized designer! In our last chapter, [ColorSchemeView](05_colorschemeview_.md), we saw how that widget is responsible for displaying all the different colors that make up a `ColorScheme` for a specific variant. We noticed that it doesn't just display them all in one long, messy list. It groups related colors together! How does it do that? With the help of the `ColorGroup` widget!

## What is ColorGroup?

Imagine you have a bunch of small paint chip samples. You wouldn't just randomly scatter them on a table. You'd probably group them – maybe all the blues together, all the reds together, etc., perhaps putting each group in a little box or frame to keep them tidy.

The `ColorGroup` widget is like that box or frame for a set of color swatches. It's a simple container whose main job is to hold several `ColorChip` widgets (the individual paint chip samples) and display them together, visually separated from other groups of colors.

Its purpose is purely organizational and visual. It takes a list of `ColorChip` widgets and arranges them, usually within a subtle frame or card, to make the long list of colors in a `ColorSchemeView` easier to understand and browse.

Our specific use case for this chapter is to use `ColorGroup` to bundle related `ColorChip`s together within the `ColorSchemeView`, providing visual structure to the displayed color palette.

## How does ColorGroup work?

The `ColorGroup` widget is designed to be very simple. It doesn't know anything about colors or color schemes itself. It just knows how to take a bunch of other widgets (specifically, `ColorChip`s in our case) and display them neatly together.

Let's look at the code for `ColorGroup` (from `color_scheme.0.dart`):

```dart
class ColorGroup extends StatelessWidget {
  const ColorGroup({super.key, required this.children});

  final List<Widget> children; // It just holds a list of widgets!

  @override
  Widget build(BuildContext context) {
    return RepaintBoundary( // Useful for performance, not essential to understand grouping
      child: Card( // The 'box' or 'frame'
        clipBehavior: Clip.antiAlias,
        child: Column(children: children)), // Lay out the children vertically
    );
  }
}
```

Here's what's happening:

1.  `class ColorGroup extends StatelessWidget`: `ColorGroup` is another widget that doesn't manage its own changing data. It just displays what you give it.
2.  `required this.children`: This is the key property. The `ColorGroup` needs a `List<Widget>` as its `children`. You give it the list of widgets you want it to group together. In our app, these widgets are `ColorChip`s.
3.  `return RepaintBoundary(...)`: This is a performance optimization and not central to the grouping concept itself. We can ignore it for now.
4.  `child: Card(...)`: This is where the visual grouping happens! The `Card` widget is a common Material Design container that provides padding, elevation (a subtle shadow), and rounded corners, making its contents look like they are inside a distinct frame or box.
5.  `child: Column(children: children)`: Inside the `Card`, a `Column` is used to arrange the `children` (the list of widgets you passed in) one above the other, vertically. This is how the `ColorChip`s appear stacked within the `Card`.

Essentially, `ColorGroup` takes a list of widgets, wraps them in a `Card` for visual separation, and arranges them within that `Card` using a `Column`.

## How is ColorGroup Used?

As we saw briefly in the [ColorSchemeView](05_colorschemeview_.md) chapter, the `ColorSchemeView` is the one that creates and uses multiple `ColorGroup` widgets to display the various parts of a `ColorScheme`.

Look at the relevant part of the `ColorSchemeView` build method again:

```dart
class ColorSchemeView extends StatelessWidget {
  const ColorSchemeView({super.key, required this.colorScheme});

  final ColorScheme colorScheme;

  @override
  Widget build(BuildContext context) {
    return Column(
      children: <Widget>[
        ColorGroup( // First group!
          children: <ColorChip>[
            ColorChip('primary', colorScheme.primary, colorScheme.onPrimary),
            ColorChip('onPrimary', colorScheme.onPrimary, colorScheme.primary),
            // ... more primary-related ColorChip widgets ...
          ],
        ),
        divider, // A simple space between groups
        ColorGroup( // Second group!
          children: <ColorChip>[
            ColorChip('secondary', colorScheme.secondary, colorScheme.onSecondary),
            // ... more secondary-related ColorChip widgets ...
          ],
        ),
        divider,
        // ... Many more ColorGroup widgets for tertiary, error, surface, etc.
      ],
    );
  }
}
```

The `ColorSchemeView` doesn't just pass the entire `ColorScheme` to a single `ColorGroup`. Instead, it actively creates *multiple* `ColorGroup` widgets. For each `ColorGroup`, it specifically lists the `ColorChip` widgets that correspond to a related set of colors (like primary, secondary, error, surface, etc.) and passes *that specific list* to the `children` property of that `ColorGroup`.

This is where the organization happens. The developer building the `ColorSchemeView` decides which colors belong in which group (e.g., all `primary` related colors, all `error` related colors) and manually creates a `ColorGroup` for each category, filling its `children` list with the appropriate `ColorChip`s.

## Behind the Scenes

When a `ColorSchemeView` is built or rebuilt (because the settings changed and a new `ColorScheme` was generated), here's what happens with the `ColorGroup` widgets:

```mermaid
sequenceDiagram
    participant CSV as ColorSchemeView
    participant CG as ColorGroup
    participant Card as Flutter Card Widget
    participant Column as Flutter Column Widget
    participant CC as ColorChip

    CSV->CSV: Build its main Column
    CSV->CG: Create a ColorGroup (e.g., for "primary" colors)
    CSV->CG: Pass a list of relevant ColorChip widgets to its children
    CG->Card: Build a Card widget
    Card->Column: Build a Column widget inside the Card
    Column->CC: Arrange and display the ColorChip widgets passed to the ColorGroup
    CC-->User: Show the individual color swatches inside the Card
    CSV->CSV: Create another ColorGroup (e.g., for "secondary" colors)
    CSV->CG: Repeat the process for the next group...
    CG-->User: Another Card display appears with the next group of colors
```

1.  The `ColorSchemeView` widget is built, creating its main vertical `Column`.
2.  It starts creating the first `ColorGroup` (e.g., the one for primary colors).
3.  It creates a list containing only the `ColorChip` widgets for `primary`, `onPrimary`, `primaryContainer`, etc., and passes this list to the `children` of the `ColorGroup`.
4.  The `ColorGroup` widget receives this list and starts building *its* content.
5.  It creates a `Card` widget.
6.  Inside the `Card`, it creates a `Column` widget.
7.  It tells the internal `Column` to display the list of `ColorChip` widgets it received as its `children`.
8.  Each `ColorChip` in that list then draws itself (a colored box with text).
9.  These drawn `ColorChip`s appear stacked vertically inside the `Card`.
10. The `ColorSchemeView` then continues creating the next `ColorGroup` for the next set of colors (secondary, tertiary, etc.), repeating the process.
11. The user sees a series of distinct "cards" or "boxes" stacked vertically inside each variant column, with each card containing a logically grouped set of color swatches.

The `ColorGroup` doesn't decide *which* colors go together; the developer using `ColorSchemeView` decides that by creating multiple `ColorGroup`s and putting the appropriate `ColorChip`s into each one's `children` list. The `ColorGroup` just provides the visual structure (the "box") for whatever list of widgets it's given.

## Conclusion

In this chapter, we explored the `ColorGroup` widget, a simple but effective container used within `ColorSchemeView` to organize the display of color swatches. We saw how it takes a list of child widgets (typically `ColorChip`s) and presents them neatly within a `Card` and a `Column`, helping to break down the large list of colors into understandable groups. It's a basic building block for structuring the visual output of the generated color schemes.

We now understand how different colors within a generated `ColorScheme` are grouped together for clarity. In the next chapter, [ColorChip](07_colorchip_.md), we'll zoom in even further and explore the smallest unit of display: the individual color swatch itself.

Ready to look at the individual color samples? Let's move on!

[Chapter 7: ColorChip](07_colorchip_.md)
---
# Chapter 7: ColorChip

Welcome back, color sampler! In our last chapter, [ColorGroup](06_colorgroup_.md), we learned how to use `ColorGroup` containers to keep related color swatches together, making our `ColorSchemeView` display more organized. But what about the individual color swatches themselves? The little boxes that show a specific color? That's the job of the `ColorChip`!

## What is ColorChip?

Imagine you're at the paint store, and you pick up one of those small cards that shows a specific paint color. It shows the color itself, maybe the color's name, and sometimes even a little square showing what text would look like *on* that color.

The `ColorChip` widget is exactly that little paint sample card for a single color in our app. Its purpose is solely to visually represent *one* specific color from our `ColorScheme`, show its name, and optionally show what text would look good on top of it.

It's the smallest building block in our color visualization! [ColorSchemeView](05_colorschemeview_.md) uses [ColorGroup](06_colorgroup_.md) to group them, and [ColorGroup](06_colorgroup_.md) then displays these individual `ColorChip`s.

Our specific use case for this chapter is to display a single color swatch, its name, and a contrasting text color within the `ColorSchemeView`, inside a [ColorGroup](06_colorgroup_.md).

## How does ColorChip work?

The `ColorChip` widget is designed to be very focused. It needs three pieces of information:

1.  **The name of the color:** What is this color called? (e.g., 'primary', 'surface', 'error')
2.  **The color itself:** The actual `Color` value.
3.  **A contrasting color for text:** What color text should be shown on this color so it's easy to read?

Let's look at the code for `ColorChip` (from `color_scheme.0.dart`):

```dart
class ColorChip extends StatelessWidget {
  const ColorChip(this.label, this.color, this.onColor, {super.key});

  final Color color; // The background color of the chip
  final Color? onColor; // The suggested text color on top
  final String label; // The color's name

  static Color contrastColor(Color color) {
    // Helper function to figure out black or white text for contrast
    final Brightness brightness = ThemeData.estimateBrightnessForColor(color);
    return brightness == Brightness.dark ? Colors.white : Colors.black;
  }

  @override
  Widget build(BuildContext context) {
    // Determine the text color based on 'onColor' or calculated contrast
    final Color labelColor = onColor ?? contrastColor(color);
    return ColoredBox( // Widget that simply paints a box with a color
      color: color, // Use the color provided for the background
      child: Padding( // Add some space inside the box
        padding: const EdgeInsets.all(16),
        child: Row( // Arrange content horizontally
          children: <Expanded>[
            Expanded(
              child: Text(
                label, // Display the color's name
                style: TextStyle(color: labelColor) // Use the determined text color
              )
            )
          ],
        ),
      ),
    );
  }
}
```

Here's the breakdown:

1.  `class ColorChip extends StatelessWidget`: Like its parent [ColorGroup](06_colorgroup_.md) and ancestor [ColorSchemeView](05_colorschemeview_.md), `ColorChip` is static. It just displays the information it receives.
2.  `const ColorChip(this.label, this.color, this.onColor, {super.key});`: This is a constructor that takes the three key pieces of information: the `label` (String name), the `color` (the `Color` object), and the `onColor` (an optional suggested color for text on top).
3.  `final Color color;`, `final Color? onColor;`, `final String label;`: These store the information passed into the constructor. `onColor` is marked with `?` meaning it could be null (not provided).
4.  `static Color contrastColor(Color color)`: This is a helper function. If no `onColor` is provided, this function checks if the background `color` is light or dark and suggests either black or white for good contrast.
5.  `final Color labelColor = onColor ?? contrastColor(color);`: This line decides the color of the text label. It first checks if `onColor` was provided (`onColor ?? ...`). If it was (not null), it uses *that* color. If `onColor` is null, it calls `contrastColor(color)` to get a contrasting color (black or white).
6.  `return ColoredBox(...)`: This widget is used to draw a rectangular box filled with a single color.
7.  `color: color,`: This tells the `ColoredBox` to use the `color` property (the background color passed to the `ColorChip`).
8.  `child: Padding(...)`: Adds some space *inside* the `ColoredBox` so the text isn't right up against the edges.
9.  `child: Row(...)`: Arranges the content inside the padding horizontally. In this case, it holds the text label.
10. `Expanded(child: Text(...))`: The `Expanded` widget makes the `Text` widget take up the available horizontal space within the `Row`.
11. `Text(label, style: TextStyle(color: labelColor))`: This creates the text label itself. It displays the `label` string (the color's name) and sets its text color to `labelColor` (which we determined in step 5).

So, `ColorChip` paints a box with the given color, adds some padding, and places the color's name inside the padding using a text color that provides good contrast.

## How is ColorChip Used?

As we saw in the [ColorSchemeView](05_colorschemeview_.md) chapter, `ColorChip` widgets are created directly inside `ColorSchemeView` and then passed as children to `ColorGroup` widgets.

Look at a snippet from the `ColorSchemeView` build method again:

```dart
class ColorSchemeView extends StatelessWidget {
  const ColorSchemeView({super.key, required this.colorScheme});

  final ColorScheme colorScheme;

  @override
  Widget build(BuildContext context) {
    return Column(
      children: <Widget>[
        ColorGroup(
          children: <ColorChip>[ // List of ColorChip widgets
            ColorChip('primary', colorScheme.primary, colorScheme.onPrimary), // A ColorChip!
            ColorChip('onPrimary', colorScheme.onPrimary, colorScheme.primary), // Another ColorChip!
            // ... more ColorChip widgets ...
          ],
        ),
        // ... other ColorGroup widgets ...
      ],
    );
  }
}
```

The `ColorSchemeView` is responsible for knowing *which* color properties exist in a `ColorScheme` and creating a specific `ColorChip` for each one it wants to display.

For example, `ColorSchemeView` knows about the `primary` color property in the `colorScheme` object. It also knows about the standard related color meant for text *on* the primary color, which is `onPrimary`. So, it creates a `ColorChip` like this:

`ColorChip('primary', colorScheme.primary, colorScheme.onPrimary)`

*   The label is `'primary'`, which is the name of the color property.
*   The background color is `colorScheme.primary`, which is the actual `Color` value.
*   The suggested text color is `colorScheme.onPrimary`.

It does this for `secondary`, `surface`, `error`, and many other color properties within the `ColorScheme`, creating a multitude of `ColorChip` widgets, and then groups them using [ColorGroup](06_colorgroup_.md).

## Behind the Scenes

When a `ColorSchemeView` is built and it creates `ColorChip` widgets, here's the simple process for each `ColorChip`:

```mermaid
sequenceDiagram
    participant CSV as ColorSchemeView
    participant CG as ColorGroup
    participant CC as ColorChip
    participant ColoredBox as Flutter ColoredBox
    participant Text as Flutter Text

    CSV->CG: Creates ColorGroup (eg. primary)
    CG->CG: Receives list of ColorChips
    CG->CC: Builds each ColorChip in its list
    CC->CC: Determines labelColor
    CC->ColoredBox: Builds a ColoredBox with its color
    ColoredBox->Padding: Builds Padding inside itself
    Padding->Row: Builds Row inside itself
    Row->Text: Builds Text widget with label and labelColor
    Text-->User: Displays the colored box with text
```

1.  The `ColorSchemeView` decides to create a `ColorChip` for a specific color property (e.g., `primary`).
2.  It creates the `ColorChip` instance, passing the label ('primary'), the color (`colorScheme.primary`), and the suggested text color (`colorScheme.onPrimary`).
3.  The `ColorChip` starts building its internal widgets.
4.  It determines the best text color (`labelColor`), using `onColor` if available, otherwise using `contrastColor`.
5.  It creates a `ColoredBox` and gives it the background `color`.
6.  Inside the `ColoredBox`, it creates `Padding`.
7.  Inside the `Padding`, it creates a `Row`.
8.  Inside the `Row`, it creates an `Expanded` widget containing a `Text` widget.
9.  The `Text` widget is given the `label` string and the calculated `labelColor`.
10. Flutter draws the `ColoredBox` with the background color and places the text label on top, showing the color sample to the user.

Each `ColorChip` is an independent unit that knows how to draw *one* color sample based on the color and label it receives.

## Conclusion

In this chapter, we got up close and personal with the `ColorChip`, the smallest visual component in our app's color display. We learned how it takes a specific color value, its name (label), and an optional contrasting text color. We saw how it uses `ColoredBox` to draw the color and `Text` to display the label, ensuring good contrast using its internal logic or a provided `onColor`. `ColorChip` is the fundamental piece that, when organized by [ColorGroup](06_colorgroup_.md) and displayed by [ColorSchemeView](05_colorschemeview_.md) within a [ColorSchemeVariantColumn](04_colorschemevariantcolumn_.md), allows us to see the generated color schemes based on settings from [Settings](03_settings_.md), opened by the [SettingsButton](02_settingsbutton_.md), all managed by [ColorSchemeExample](01_colorschemeexample_.md)!

We've now explored how all the individual generated colors are displayed. In the next and final chapter, [ColorSeed](08_colorseed_.md), we'll look at where the initial suggestion for our primary color comes from, the very "seed" that starts the whole color generation process.

Ready to discover the origin of our colors? Let's move on!

[Chapter 8: ColorSeed](08_colorseed_.md)

Relevant Code Snippets (Code itself remains unchanged):
--- File: color_scheme.0.dart ---
// Copyright 2014 The Flutter Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

import 'package:flutter/material.dart';

/// Flutter code sample for [ColorScheme].

const Widget divider = SizedBox(height: 10);

void main() => runApp(const ColorSchemeExample());

class ColorSchemeExample extends StatefulWidget {
  const ColorSchemeExample({super.key});

  @override
  State<ColorSchemeExample> createState() => _ColorSchemeExampleState();
}

class _ColorSchemeExampleState extends State<ColorSchemeExample> {
  Color selectedColor = ColorSeed.baseColor.color;
  Brightness selectedBrightness = Brightness.light;
  double selectedContrast = 0.0;
  static const List<DynamicSchemeVariant> schemeVariants = DynamicSchemeVariant.values;

  void updateTheme(Brightness brightness, Color color, double contrastLevel) {
    setState(() {
      selectedBrightness = brightness;
      selectedColor = color;
      selectedContrast = contrastLevel;
    });
  }

  @override
  Widget build(BuildContext context) {
    return MaterialApp(
      debugShowCheckedModeBanner: false,
      theme: ThemeData(
        colorScheme: ColorScheme.fromSeed(
          seedColor: selectedColor,
          brightness: selectedBrightness,
          contrastLevel: selectedContrast,
        ),
      ),
      home: Scaffold(
        appBar: AppBar(
          title: const Text('ColorScheme'),
          actions: <Widget>[
            SettingsButton(
              selectedColor: selectedColor,
              selectedBrightness: selectedBrightness,
              selectedContrast: selectedContrast,
              updateTheme: updateTheme,
            ),
          ],
        ),
        body: SingleChildScrollView(
          child: Padding(
            padding: const EdgeInsets.only(top: 5),
            child: Column(
              crossAxisAlignment: CrossAxisAlignment.start,
              children: <Widget>[
                SingleChildScrollView(
                  scrollDirection: Axis.horizontal,
                  child: Row(
                    children:
                        List<Widget>.generate(schemeVariants.length, (int index) {
                          return ColorSchemeVariantColumn(
                            selectedColor: selectedColor,
                            brightness: selectedBrightness,
                            schemeVariant: schemeVariants[index],
                            contrastLevel: selectedContrast,
                          );
                        }).toList(),
                  ),
                ),
              ],
            ),
          ),
        ),
      ),
    );
  }
}

class Settings extends StatefulWidget {
  const Settings({
    super.key,
    required this.updateTheme,
    required this.selectedBrightness,
    required this.selectedContrast,
    required this.selectedColor,
  });

  final Brightness selectedBrightness;
  final double selectedContrast;
  final Color selectedColor;

  final void Function(Brightness, Color, double) updateTheme;

  @override
  State<Settings> createState() => _SettingsState();
}

class _SettingsState extends State<Settings> {
  late Brightness selectedBrightness = widget.selectedBrightness;
  late Color selectedColor = widget.selectedColor;
  late double selectedContrast = widget.selectedContrast;

  @override
  Widget build(BuildContext context) {
    return Theme(
      data: Theme.of(context).copyWith(
        colorScheme: ColorScheme.fromSeed(
          seedColor: selectedColor,
          contrastLevel: selectedContrast,
          brightness: selectedBrightness,
        ),
      ),
      child: ConstrainedBox(
        constraints: const BoxConstraints(maxHeight: 200),
        child: Padding(
          padding: const EdgeInsets.all(20.0),
          child: ListView(
            children: <Widget>[
              Center(child: Text('Settings', style: Theme.of(context).textTheme.titleLarge)),
              Row(
                children: <Widget>[
                  const Text('Brightness: '),
                  Switch(
                    value: selectedBrightness == Brightness.light,
                    onChanged: (bool value) {
                      setState(() {
                        selectedBrightness = value ? Brightness.light : Brightness.dark;
                      });
                      widget.updateTheme(selectedBrightness, selectedColor, selectedContrast);
                    },
                  ),
                ],
              ),
              Wrap(
                crossAxisAlignment: WrapCrossAlignment.center,
                children: <Widget>[
                  const Text('Seed color: '),
                  ...List<Widget>.generate(ColorSeed.values.length, (int index) {
                    final Color itemColor = ColorSeed.values[index].color;
                    return IconButton(
                      icon:
                          selectedColor == ColorSeed.values[index].color
                              ? Icon(Icons.circle, color: itemColor)
                              : Icon(Icons.circle_outlined, color: itemColor),
                      onPressed: () {
                        setState(() {
                          selectedColor = itemColor;
                        });
                        widget.updateTheme(selectedBrightness, selectedColor, selectedContrast);
                      },
                    );
                  }),
                ],
              ),
              Row(
                children: <Widget>[
                  const Text('Contrast level: '),
                  Expanded(
                    child: Slider(
                      divisions: 4,
                      label: selectedContrast.toString(),
                      min: -1,
                      value: selectedContrast,
                      onChanged: (double value) {
                        setState(() {
                          selectedContrast = value;
                        });
                        widget.updateTheme(selectedBrightness, selectedColor, selectedContrast);
                      },
                    ),
                  ),
                ],
              ),
            ],
          ),
        ),
      ),
    );
  }
}

class ColorSchemeVariantColumn extends StatelessWidget {
  const ColorSchemeVariantColumn({
    super.key,
    this.schemeVariant = DynamicSchemeVariant.tonalSpot,
    this.brightness = Brightness.light,
    this.contrastLevel = 0.0,
    required this.selectedColor,
  });

  final DynamicSchemeVariant schemeVariant;
  final Brightness brightness;
  final double contrastLevel;
  final Color selectedColor;

  @override
  Widget build(BuildContext context) {
    return ConstrainedBox(
      constraints: const BoxConstraints.tightFor(width: 250),
      child: Column(
        children: <Widget>[
          Padding(
            padding: const EdgeInsets.symmetric(vertical: 15),
            child: Text(
              schemeVariant.name == 'tonalSpot'
                  ? '${schemeVariant.name} (Default)'
                  : schemeVariant.name,
              style: const TextStyle(fontWeight: FontWeight.bold),
            ),
          ),
          Padding(
            padding: const EdgeInsets.symmetric(horizontal: 15),
            child: ColorSchemeView(
              colorScheme: ColorScheme.fromSeed(
                seedColor: selectedColor,
                brightness: brightness,
                contrastLevel: contrastLevel,
                dynamicSchemeVariant: schemeVariant,
              ),
            ),
          ),
        ],
      ),
    );
  }
}

class ColorSchemeView extends StatelessWidget {
  const ColorSchemeView({super.key, required this.colorScheme});

  final ColorScheme colorScheme;

  @override
  Widget build(BuildContext context) {
    return Column(
      children: <Widget>[
        ColorGroup(
          children: <ColorChip>[
            ColorChip('primary', colorScheme.primary, colorScheme.onPrimary),
            ColorChip('onPrimary', colorScheme.onPrimary, colorScheme.primary),
            ColorChip(
              'primaryContainer',
              colorScheme.primaryContainer,
              colorScheme.onPrimaryContainer,
            ),
            ColorChip(
              'onPrimaryContainer',
              colorScheme.onPrimaryContainer,
              colorScheme.primaryContainer,
            ),
          ],
        ),
        divider,
        ColorGroup(
          children: <ColorChip>[
            ColorChip('primaryFixed', colorScheme.primaryFixed, colorScheme.onPrimaryFixed),
            ColorChip('onPrimaryFixed', colorScheme.onPrimaryFixed, colorScheme.primaryFixed),
            ColorChip(
              'primaryFixedDim',
              colorScheme.primaryFixedDim,
              colorScheme.onPrimaryFixedVariant,
            ),
            ColorChip(
              'onPrimaryFixedVariant',
              colorScheme.onPrimaryFixedVariant,
              colorScheme.primaryFixedDim,
            ),
          ],
        ),
        divider,
        ColorGroup(
          children: <ColorChip>[
            ColorChip('secondary', colorScheme.secondary, colorScheme.onSecondary),
            ColorChip('onSecondary', colorScheme.onSecondary, colorScheme.secondary),
            ColorChip(
              'secondaryContainer',
              colorScheme.secondaryContainer,
              colorScheme.onSecondaryContainer,
            ),
            ColorChip(
              'onSecondaryContainer',
              colorScheme.onSecondaryContainer,
              colorScheme.secondaryContainer,
            ),
          ],
        ),
        divider,
        ColorGroup(
          children: <ColorChip>[
            ColorChip('secondaryFixed', colorScheme.secondaryFixed, colorScheme.onSecondaryFixed),
            ColorChip('onSecondaryFixed', colorScheme.onSecondaryFixed, colorScheme.secondaryFixed),
            ColorChip(
              'secondaryFixedDim',
              colorScheme.secondaryFixedDim,
              colorScheme.onSecondaryFixedVariant,
            ),
            ColorChip(
              'onSecondaryFixedVariant',
              colorScheme.onSecondaryFixedVariant,
              colorScheme.secondaryFixedDim,
            ),
          ],
        ),
        divider,
        ColorGroup(
          children: <ColorChip>[
            ColorChip('tertiary', colorScheme.tertiary, colorScheme.onTertiary),
            ColorChip('onTertiary', colorScheme.onTertiary, colorScheme.tertiary),
            ColorChip(
              'tertiaryContainer',
              colorScheme.tertiaryContainer,
              colorScheme.onTertiaryContainer,
            ),
            ColorChip(
              'onTertiaryContainer',
              colorScheme.onTertiaryContainer,
              colorScheme.tertiaryContainer,
            ),
          ],
        ),
        divider,
        ColorGroup(
          children: <ColorChip>[
            ColorChip('tertiaryFixed', colorScheme.tertiaryFixed, colorScheme.onTertiaryFixed),
            ColorChip('onTertiaryFixed', colorScheme.onTertiaryFixed, colorScheme.tertiaryFixed),
            ColorChip(
              'tertiaryFixedDim',
              colorScheme.tertiaryFixedDim,
              colorScheme.onTertiaryFixedVariant,
            ),
            ColorChip(
              'onTertiaryFixedVariant',
              colorScheme.onTertiaryFixedVariant,
              colorScheme.tertiaryFixedDim,
            ),
          ],
        ),
        divider,
        ColorGroup(
          children: <ColorChip>[
            ColorChip('error', colorScheme.error, colorScheme.onError),
            ColorChip('onError', colorScheme.onError, colorScheme.error),
            ColorChip('errorContainer', colorScheme.errorContainer, colorScheme.onErrorContainer),
            ColorChip('onErrorContainer', colorScheme.onErrorContainer, colorScheme.errorContainer),
          ],
        ),
        divider,
        ColorGroup(
          children: <ColorChip>[
            ColorChip('surfaceDim', colorScheme.surfaceDim, colorScheme.onSurface),
            ColorChip('surface', colorScheme.surface, colorScheme.onSurface),
            ColorChip('surfaceBright', colorScheme.surfaceBright, colorScheme.onSurface),
            ColorChip(
              'surfaceContainerLowest',
              colorScheme.surfaceContainerLowest,
              colorScheme.onSurface,
            ),
            ColorChip(
              'surfaceContainerLow',
              colorScheme.surfaceContainerLow,
              colorScheme.onSurface,
            ),
            ColorChip('surfaceContainer', colorScheme.surfaceContainer, colorScheme.onSurface),
            ColorChip(
              'surfaceContainerHigh',
              colorScheme.surfaceContainerHigh,
              colorScheme.onSurface,
            ),
            ColorChip(
              'surfaceContainerHighest',
              colorScheme.surfaceContainerHighest,
              colorScheme.onSurface,
            ),
            ColorChip('onSurface', colorScheme.onSurface, colorScheme.surface),
            ColorChip(
              'onSurfaceVariant',
              colorScheme.onSurfaceVariant,
              colorScheme.surfaceContainerHighest,
            ),
          ],
        ),
        divider,
        ColorGroup(
          children: <ColorChip>[
            ColorChip('outline', colorScheme.outline, null),
            ColorChip('shadow', colorScheme.shadow, null),
            ColorChip('inverseSurface', colorScheme.inverseSurface, colorScheme.onInverseSurface),
            ColorChip('onInverseSurface', colorScheme.onInverseSurface, colorScheme.inverseSurface),
            ColorChip('inversePrimary', colorScheme.inversePrimary, colorScheme.primary),
          ],
        ),
      ],
    );
  }
}

class ColorGroup extends StatelessWidget {
  const ColorGroup({super.key, required this.children});

  final List<Widget> children;

  @override
  Widget build(BuildContext context) {
    return RepaintBoundary(
      child: Card(clipBehavior: Clip.antiAlias, child: Column(children: children)),
    );
  }
}

class ColorChip extends StatelessWidget {
  const ColorChip(this.label, this.color, this.onColor, {super.key});

  final Color color;
  final Color? onColor;
  final String label;

  static Color contrastColor(Color color) {
    final Brightness brightness = ThemeData.estimateBrightnessForColor(color);
    return brightness == Brightness.dark ? Colors.white : Colors.black;
  }

  @override
  Widget build(BuildContext context) {
    final Color labelColor = onColor ?? contrastColor(color);
    return ColoredBox(
      color: color,
      child: Padding(
        padding: const EdgeInsets.all(16),
        child: Row(
          children: <Expanded>[Expanded(child: Text(label, style: TextStyle(color: labelColor)))],
        ),
      ),
    );
  }
}

enum ColorSeed {
  baseColor('M3 Baseline', Color(0xff6750a4)),
  indigo('Indigo', Colors.indigo),
  blue('Blue', Colors.blue),
  teal('Teal', Colors.teal),
  green('Green', Colors.green),
  yellow('Yellow', Colors.yellow),
  orange('Orange', Colors.orange),
  deepOrange('Deep Orange', Colors.deepOrange),
  pink('Pink', Colors.pink),
  brightBlue('Bright Blue', Color(0xFF0000FF)),
  brightGreen('Bright Green', Color(0xFF00FF00)),
  brightRed('Bright Red', Color(0xFFFF0000));

  const ColorSeed(this.label, this.color);
  final String label;
  final Color color;
}

class SettingsButton extends StatelessWidget {
  const SettingsButton({
    super.key,
    required this.updateTheme,
    required this.selectedBrightness,
    required this.selectedContrast,
    required this.selectedColor,
  });

  final Brightness selectedBrightness;
  final double selectedContrast;
  final Color selectedColor;

  final void Function(Brightness, Color, double) updateTheme;

  @override
  Widget build(BuildContext context) {
    return IconButton(
      icon: const Icon(Icons.settings),
      onPressed: () {
        showModalBottomSheet<void>(
          barrierColor: Colors.transparent,
          context: context,
          builder: (BuildContext context) {
            return Settings(
              selectedColor: selectedColor,
              selectedBrightness: selectedBrightness,
              selectedContrast: selectedContrast,
              updateTheme: updateTheme,
            );
          },
        );
      },
    );
  }
}


Instructions for the chapter (Generate content in English unless specified otherwise):
- Start with a clear heading (e.g., `# Chapter 8: ColorSeed
`). Use the provided concept name.

- If this is not the first chapter, begin with a brief transition from the previous chapter, referencing it with a proper Markdown link using its name.

- Begin with a high-level motivation explaining what problem this abstraction solves. Start with a central use case as a concrete example. The whole chapter should guide the reader to understand how to solve this use case. Make it very minimal and friendly to beginners.

- If the abstraction is complex, break it down into key concepts. Explain each concept one-by-one in a very beginner-friendly way.

- Explain how to use this abstraction to solve the use case. Give example inputs and outputs for code snippets (if the output isn't values, describe at a high level what will happen).

- Each code block should be BELOW 10 lines! If longer code blocks are needed, break them down into smaller pieces and walk through them one-by-one. Aggresively simplify the code to make it minimal. Use comments to skip non-important implementation details. Each code block should have a beginner friendly explanation right after it.

- Describe the internal implementation to help understand what's under the hood. First provide a non-code or code-light walkthrough on what happens step-by-step when the abstraction is called. It's recommended to use a simple sequenceDiagram with a dummy example - keep it minimal with at most 5 participants to ensure clarity. If participant name has space, use: `participant QP as Query Processing`. .

- Then dive deeper into code for the internal implementation with references to files. Provide example code blocks, but make them similarly simple and beginner-friendly. Explain.

- IMPORTANT: When you need to refer to other core abstractions covered in other chapters, ALWAYS use proper Markdown links like this: [Chapter Title](filename.md). Use the Complete Tutorial Structure above to find the correct filename and the chapter title. Translate the surrounding text.

- Use mermaid diagrams to illustrate complex concepts (```mermaid``` format). .

- Heavily use analogies and examples throughout to help beginners understand.

- End the chapter with a brief conclusion that summarizes what was learned and provides a transition to the next chapter. If there is a next chapter, use a proper Markdown link: [Next Chapter Title](next_chapter_filename).

- Ensure the tone is welcoming and easy for a newcomer to understand.

- Output *only* the Markdown content for this chapter.

Now, directly provide a super beginner-friendly Markdown output (DON'T need ```markdown``` tags):

2025-05-28 16:31:53,260 - INFO - RESPONSE: # Chapter 8: ColorSeed

Welcome back, color origin seeker! We've journeyed through our app's color system, from the main [ColorSchemeExample](01_colorschemeexample_.md) controller to the individual [ColorChip](07_colorchip_.md) color samples. We saw how settings influence the generated colors and how they are displayed in different variants. But where does the *initial* color suggestion come from? The one we start with before we change anything? That's where the `ColorSeed` comes in!

## What is ColorSeed?

Imagine you're baking a cake. You start with a basic recipe and some core ingredients like flour, sugar, and eggs. But the *flavor* of the cake often starts with one key ingredient – perhaps a vanilla bean, a lemon zest, or some chocolate chips. This central ingredient influences the taste of the whole cake.

In our app's color system, the "seed color" is like that core flavor ingredient. It's the starting point, the fundamental hue that `ColorScheme.fromSeed` uses to generate all the other colors in the palette (primary, secondary, surface, etc.).

The `ColorSeed` is not a single color, but an *enumeration* (a fancy word for a قائمة with a fixed, named set of options). It provides a predefined *list* of popular, good-looking colors that you can choose from as your starting "seed". Think of it as a small catalog of suggested initial flavors for your color scheme cake.

Our specific use case is to provide a simple way for the [Settings](03_settings_.md) panel to offer a selection of popular colors that the user can pick as the starting point for their theme.

## How does ColorSeed work?

`ColorSeed` is essentially just a list that holds pairs of information: a user-friendly name for a color (like 'Indigo' or 'Teal') and the actual `Color` value associated with that name.

Let's look at the code for `ColorSeed` (from `color_scheme.0.dart`):

```dart
enum ColorSeed {
  baseColor('M3 Baseline', Color(0xff6750a4)),
  indigo('Indigo', Colors.indigo),
  blue('Blue', Colors.blue),
  teal('Teal', Colors.teal),
  // ... other predefined colors ...
  brightRed('Bright Red', Color(0xFFFF0000));

  const ColorSeed(this.label, this.color);
  final String label; // The name of the color (e.g., 'Indigo')
  final Color color; // The actual Color value (e.g., Colors.indigo)
}
```

Here's the breakdown:

1.  `enum ColorSeed { ... }`: This declares an enumeration named `ColorSeed`. This means you can only use the options listed inside the curly braces (`{}`).
2.  `baseColor('M3 Baseline', Color(0xff6750a4))`: This is one entry in the enumeration. It has a name (`baseColor`), and associated data in parentheses: a string label ('M3 Baseline') and a `Color` object (`Color(0xff6750a4)`).
3.  `indigo('Indigo', Colors.indigo)`, `blue('Blue', Colors.blue)`, etc.: These are other entries, following the same pattern. Each one gives a friendly name and connects it to a specific `Color` value (using predefined colors from `Colors` or custom hex codes).
4.  `const ColorSeed(this.label, this.color);`: This is a special constructor for the enum entries. It says that when you create an entry like `indigo('Indigo', Colors.indigo)`, the first string ('Indigo') is assigned to the `label` property, and the `Color` value (`Colors.indigo`) is assigned to the `color` property.
5.  `final String label;`, `final Color color;`: These declare that each `ColorSeed` entry will have a `label` (a string) and a `color` (a `Color` object).

So, `ColorSeed` is simply a convenient way to give names to a set of specific `Color` values and group them together under a single concept. It's like a lookup table from a friendly name to a technical color value.

## How is ColorSeed Used?

The primary place `ColorSeed` is used in our app is the [Settings](03_settings_.md) panel, where the user can select their desired seed color.

Look back at the relevant part of the `_SettingsState` build method (from `color_scheme.0.dart`):

```dart
class _SettingsState extends State<Settings> {
  // ... state variables ...

  @override
  Widget build(BuildContext context) {
    return Theme(
      // ... panel theme ...
      child: ConstrainedBox(
        // ... layout ...
        child: Padding(
          // ... padding ...
          child: ListView(
            children: <Widget>[
              // ... Brightness switch ...
              Wrap( // Arranges children side-by-side, wrapping to the next line
                crossAxisAlignment: WrapCrossAlignment.center,
                children: <Widget>[
                  const Text('Seed color: '),
                  // Loop through ALL ColorSeed entries
                  ...List<Widget>.generate(ColorSeed.values.length, (int index) {
                    // Get the current ColorSeed entry
                    final ColorSeed item = ColorSeed.values[index];
                    final Color itemColor = item.color; // Get the actual Color value

                    return IconButton( // A button that's just an icon (a circle)
                      icon:
                          // If this color is currently selected, show a filled circle
                          selectedColor == itemColor
                              ? Icon(Icons.circle, color: itemColor)
                              // Otherwise, show an outlined circle
                              : Icon(Icons.circle_outlined, color: itemColor),
                      onPressed: () {
                        setState(() {
                          // Update the local state to show which circle is selected
                          selectedColor = itemColor;
                        });
                        // Tell the main app to update the theme with the NEW color
                        widget.updateTheme(selectedBrightness, selectedColor, selectedContrast);
                      },
                    );
                  }),
                ],
              ),
              // ... Contrast slider ...
            ],
          ),
        ),
      ),
    );
  }
}
```

Here's how `ColorSeed` is used here:

1.  `Wrap(...)`: This widget is used to lay out the "Seed color" label and the icon buttons horizontally. If they don't fit on one line, they wrap to the next.
2.  `...List<Widget>.generate(ColorSeed.values.length, (int index) { ... })`: `ColorSeed.values` is a list containing *all* the entries defined in the `ColorSeed` enum (`baseColor`, `indigo`, `blue`, etc.). `generate` creates a list of widgets, one for each entry in `ColorSeed.values`. The `...` (spread operator) adds the widgets from this list directly into the `children` list of the `Wrap`.
3.  `final ColorSeed item = ColorSeed.values[index];`: Inside the loop, we get the current `ColorSeed` entry we're processing (e.g., the `ColorSeed.indigo` entry).
4.  `final Color itemColor = item.color;`: We access the `color` property of the current `ColorSeed` entry to get the actual `Color` value (`Colors.indigo` in this example).
5.  `return IconButton(...)`: An `IconButton` is created for each `ColorSeed`.
6.  `icon: selectedColor == itemColor ? Icon(Icons.circle, color: itemColor) : Icon(Icons.circle_outlined, color: itemColor)`: This line uses the `itemColor` to set the color of the icon. It also checks if this `itemColor` matches the `selectedColor` (the color currently chosen by the user). If it matches, it shows a filled circle icon (`Icons.circle`); otherwise, it shows an outlined circle (`Icons.circle_outlined`). This visually indicates which seed color is currently active.
7.  `onPressed: () { ... }`: When an `IconButton` is tapped:
    *   `setState(() { selectedColor = itemColor; });`: The `selectedColor` state variable within the `_SettingsState` is updated to the color of the tapped `ColorSeed` icon. `setState` rebuilds the `Settings` panel, making the tapped icon appear filled.
    *   `widget.updateTheme(selectedBrightness, selectedColor, selectedContrast);`: Most importantly, the `updateTheme` function on the main [ColorSchemeExample](01_colorschemeexample_.md) is called. It's passed the current brightness and contrast, *and* the newly selected `itemColor` (which is now stored in the local `selectedColor` state).

So, the `ColorSeed` enum provides the list of colors. The [Settings](03_settings_.md) widget iterates through this list, creates an interactive button for each one using the seed's `color`, and when a button is tapped, it takes that `itemColor` and uses it to update the main app's theme via `updateTheme`.

The `ColorSeed` doesn't *do* the updating; it just *defines* the options that the [Settings](03_settings_.md) widget presents to the user.

## Behind the Scenes

When the [Settings](03_settings_.md) panel is built, here's how it uses `ColorSeed` to create the color selection row:

```mermaid
sequenceDiagram
    participant SettingsState as _SettingsState
    participant ColorSeed as ColorSeed Enum
    participant ListGenerate as List.generate
    participant IconButton as Flutter IconButton
    participant User
    participant CS as ColorSchemeExample

    SettingsState->ColorSeed: Access ColorSeed.values
    ColorSeed-->SettingsState: Return list of ColorSeed entries
    SettingsState->ListGenerate: Call List.generate (looping through ColorSeed entries)
    ListGenerate->ListGenerate: For each entry...
    ListGenerate->IconButton: Create an IconButton
    IconButton->IconButton: Get item.color, set icon/color based on selectedColor
    ListGenerate-->SettingsState: Return list of ImageButtons
    SettingsState->Wrap: Add ImageButton list to Wrap children
    Wrap-->User: Show row of color circles

    User->IconButton: Tap a circle!
    IconButton->SettingsState: Call onPressed(item.color)
    SettingsState->SettingsState: Update selectedColor (setState)
    SettingsState->CS: Call widget.updateTheme(new color)
    CS->CS: Update selectedColor state (setState)
    CS-->User: Main app theme changes
    SettingsState-->User: Panel updates (tapped circle is filled)
```

1.  When the `_SettingsState` builds, it accesses the `ColorSeed.values` list.
2.  It uses `List.generate` to loop through each `ColorSeed` entry in that list.
3.  For each entry, it creates an `IconButton`.
4.  It gets the `color` from the current `ColorSeed` entry (`item.color`).
5.  It configures the `IconButton`'s icon and color using that `item.color` and checking if it matches the current `selectedColor` in the state.
6.  The `List.generate` builds a list of these configured `IconButton`s.
7.  The `_SettingsState` adds this list of `IconButton`s to the `Wrap` widget's children.
8.  Flutter displays the row of colored circles in the settings panel.
9.  When the user taps one of these circles:
    *   The `onPressed` function for that specific `IconButton` runs.
    *   The `itemColor` associated with that tapped `ColorSeed` entry is used to update the `selectedColor` in the `_SettingsState`. `setState` triggers a local rebuild of the settings panel to update the icons.
    *   `widget.updateTheme` is called with the new `selectedColor`, telling the `ColorSchemeExample` to generate a new theme.
    *   The `ColorSchemeExample` updates its state and rebuilds the entire app, showing the new theme based on the selected seed color.

`ColorSeed` itself is passive. It doesn't change state or generate colors. It simply sits there as a list of predefined color options with names, ready to be accessed by widgets like [Settings](03_settings_.md) that want to offer seed color choices.

## Conclusion

In this final chapter of our color scheme exploration, we demystified `ColorSeed`. We learned that it's an enumeration providing a predefined list of named colors that can serve as the starting point ("seed") for generating a `ColorScheme`. We saw how the [Settings](03_settings_.md) widget uses `ColorSeed.values` to present these options as tappable icons and how, when one is selected, that specific `Color` value is passed along to update the application's main theme via [ColorSchemeExample](01_colorschemeexample_.md).

You've now navigated the entire journey of how a seed color is chosen, how it affects the many colors in a theme variant, and how those colors are displayed! From the main conductor ([ColorSchemeExample](01_colorschemeexample_.md)) to the button that opens settings ([SettingsButton](02_settingsbutton_.md)), the panel itself ([Settings](03_settings_.md)) showcasing variant columns ([ColorSchemeVariantColumn](04_colorschemevariantcolumn_.md)) displaying generated color schemes ([ColorSchemeView](05_colorschemeview_.md)) using color groups ([ColorGroup](06_colorgroup_.md)) and individual color chips ([ColorChip](07_colorchip_.md)), all starting with the initial options provided by the `ColorSeed`!

Congratulations! You've taken your first steps into understanding how dynamic color schemes work in Flutter, driven by a simple seed color. Feel free to experiment with the code, try changing the seed colors, or even adding your own favorite colors to the `ColorSeed` enum!
2025-05-28 18:20:40,016 - INFO - PROMPT: Hello, how are you?
2025-05-28 18:20:42,041 - INFO - RESPONSE: I am a large language model, trained by Google. I am performing well and am ready to assist you. How can I help you today?
2025-05-28 18:21:09,784 - INFO - PROMPT: 
For the project `flutter`:

Codebase Context:
--- File Index 0: packages/flutter/lib/src/material/color_scheme.dart ---
// Copyright 2014 The Flutter Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

/// @docImport 'input_decorator.dart';
/// @docImport 'scaffold.dart';
library;

import 'dart:async';
import 'dart:ui' as ui;

import 'package:flutter/foundation.dart';
import 'package:flutter/widgets.dart';
import 'package:material_color_utilities/material_color_utilities.dart';

import 'colors.dart';
import 'theme.dart';

/// The algorithm used to construct a [ColorScheme] in [ColorScheme.fromSeed].
///
/// The `tonalSpot` variant builds default Material scheme colors. These colors are
/// mapped to light or dark tones to achieve visually accessible color
/// pairings with sufficient contrast between foreground and background elements.
///
/// In some cases, the tones can prevent colors from appearing as intended,
/// such as when a color is too light to offer enough contrast for accessibility.
/// Color fidelity (`DynamicSchemeVariant.fidelity`) is a feature that adjusts
/// tones in these cases to produce the intended visual results without harming
/// visual contrast.
enum DynamicSchemeVariant {
  /// Default for Material theme colors. Builds pastel palettes with a low chroma.
  tonalSpot,

  /// The resulting color palettes match seed color, even if the seed color
  /// is very bright (high chroma).
  fidelity,

  /// All colors are grayscale, no chroma.
  monochrome,

  /// Close to grayscale, a hint of chroma.
  neutral,

  /// Pastel colors, high chroma palettes. The primary palette's chroma is at
  /// maximum. Use `fidelity` instead if tokens should alter their tone to match
  /// the palette vibrancy.
  vibrant,

  /// Pastel colors, medium chroma palettes. The primary palette's hue is
  /// different from the seed color, for variety.
  expressive,

  /// Almost identical to `fidelity`. Tokens and palettes match the seed color.
  /// [ColorScheme.primaryContainer] is the seed color, adjusted to ensure
  /// contrast with surfaces. The tertiary palette is analogue of the seed color.
  content,

  /// A playful theme - the seed color's hue does not appear in the theme.
  rainbow,

  /// A playful theme - the seed color's hue does not appear in the theme.
  fruitSalad,
}

/// {@template flutter.material.color_scheme.ColorScheme}
/// A set of 45 colors based on the
/// [Material spec](https://m3.material.io/styles/color/the-color-system/color-roles)
/// that can be used to configure the color properties of most components.
/// {@endtemplate}
///
/// ### Colors in Material 3
///
/// {@macro flutter.material.colors.colorRoles}
///
/// The main accent color groups in the scheme are [primary], [secondary],
/// and [tertiary].
///
/// * Primary colors are used for key components across the UI, such as the FAB,
///   prominent buttons, and active states.
///
/// * Secondary colors are used for less prominent components in the UI, such as
///   filter chips, while expanding the opportunity for color expression.
///
/// * Tertiary colors are used for contrasting accents that can be used to
///   balance primary and secondary colors or bring heightened attention to
///   an element, such as an input field. The tertiary colors are left
///   for makers to use at their discretion and are intended to support
///   broader color expression in products.
///
/// Each accent color group (primary, secondary and tertiary) includes '-Fixed'
/// '-Dim' color roles, such as [primaryFixed] and [primaryFixedDim]. Fixed roles
/// are appropriate to use in places where Container roles are normally used,
/// but they stay the same color between light and dark themes. The '-Dim' roles
/// provide a stronger, more emphasized color with the same fixed behavior.
///
/// The remaining colors of the scheme are composed of neutral colors used for
/// backgrounds and surfaces, as well as specific colors for errors, dividers
/// and shadows. Surface colors are used for backgrounds and large, low-emphasis
/// areas of the screen.
///
/// Material 3 also introduces tone-based surfaces and surface containers.
/// They replace the old opacity-based model which applied a tinted overlay on
/// top of surfaces based on their elevation. These colors include: [surfaceBright],
/// [surfaceDim], [surfaceContainerLowest], [surfaceContainerLow], [surfaceContainer],
/// [surfaceContainerHigh], and [surfaceContainerHighest].
///
/// Many of the colors have matching 'on' colors, which are used for drawing
/// content on top of the matching color. For example, if something is using
/// [primary] for a background color, [onPrimary] would be used to paint text
/// and icons on top of it. For this reason, the 'on' colors should have a
/// contrast ratio with their matching colors of at least 4.5:1 in order to
/// be readable. On '-FixedVariant' roles, such as [onPrimaryFixedVariant],
/// also have the same color between light and dark themes, but compared
/// with on '-Fixed' roles, such as [onPrimaryFixed], they provide a
/// lower-emphasis option for text and icons.
///
/// {@tool dartpad}
/// This example shows all Material [ColorScheme] roles in light and dark
/// brightnesses.
///
/// ** See code in examples/api/lib/material/color_scheme/color_scheme.0.dart **
/// {@end-tool}
///
/// ### Setting Colors in Flutter
///
///{@macro flutter.material.colors.settingColors}
@immutable
class ColorScheme with Diagnosticable {
  /// Create a ColorScheme instance from the given colors.
  ///
  /// [ColorScheme.fromSeed] can be used as a simpler way to create a full
  /// color scheme derived from a single seed color.
  ///
  /// For the color parameters that are nullable, it is still recommended
  /// that applications provide values for them. They are only nullable due
  /// to backwards compatibility concerns.
  ///
  /// If a color is not provided, the closest fallback color from the given
  /// colors will be used for it (e.g. [primaryContainer] will default
  /// to [primary]). Material Design 3 makes use of these colors for many
  /// component defaults, so for the best results the application should
  /// supply colors for all the parameters. An easy way to ensure this is to
  /// use [ColorScheme.fromSeed] to generate a full set of colors.
  ///
  /// During the migration to Material Design 3, if an app's
  /// [ThemeData.useMaterial3] is false, then components will only
  /// use the following colors for defaults:
  ///
  /// * [primary]
  /// * [onPrimary]
  /// * [secondary]
  /// * [onSecondary]
  /// * [error]
  /// * [onError]
  /// * [surface]
  /// * [onSurface]
  /// DEPRECATED:
  /// * [background]
  /// * [onBackground]
  const ColorScheme({
    required this.brightness,
    required this.primary,
    required this.onPrimary,
    Color? primaryContainer,
    Color? onPrimaryContainer,
    Color? primaryFixed,
    Color? primaryFixedDim,
    Color? onPrimaryFixed,
    Color? onPrimaryFixedVariant,
    required this.secondary,
    required this.onSecondary,
    Color? secondaryContainer,
    Color? onSecondaryContainer,
    Color? secondaryFixed,
    Color? secondaryFixedDim,
    Color? onSecondaryFixed,
    Color? onSecondaryFixedVariant,
    Color? tertiary,
    Color? onTertiary,
    Color? tertiaryContainer,
    Color? onTertiaryContainer,
    Color? tertiaryFixed,
    Color? tertiaryFixedDim,
    Color? onTertiaryFixed,
    Color? onTertiaryFixedVariant,
    required this.error,
    required this.onError,
    Color? errorContainer,
    Color? onErrorContainer,
    required this.surface,
    required this.onSurface,
    Color? surfaceDim,
    Color? surfaceBright,
    Color? surfaceContainerLowest,
    Color? surfaceContainerLow,
    Color? surfaceContainer,
    Color? surfaceContainerHigh,
    Color? surfaceContainerHighest,
    Color? onSurfaceVariant,
    Color? outline,
    Color? outlineVariant,
    Color? shadow,
    Color? scrim,
    Color? inverseSurface,
    Color? onInverseSurface,
    Color? inversePrimary,
    Color? surfaceTint,
    @Deprecated(
      'Use surface instead. '
      'This feature was deprecated after v3.18.0-0.1.pre.',
    )
    Color? background,
    @Deprecated(
      'Use onSurface instead. '
      'This feature was deprecated after v3.18.0-0.1.pre.',
    )
    Color? onBackground,
    @Deprecated(
      'Use surfaceContainerHighest instead. '
      'This feature was deprecated after v3.18.0-0.1.pre.',
    )
    Color? surfaceVariant,
  }) : _primaryContainer = primaryContainer,
       _onPrimaryContainer = onPrimaryContainer,
       _primaryFixed = primaryFixed,
       _primaryFixedDim = primaryFixedDim,
       _onPrimaryFixed = onPrimaryFixed,
       _onPrimaryFixedVariant = onPrimaryFixedVariant,
       _secondaryContainer = secondaryContainer,
       _onSecondaryContainer = onSecondaryContainer,
       _secondaryFixed = secondaryFixed,
       _secondaryFixedDim = secondaryFixedDim,
       _onSecondaryFixed = onSecondaryFixed,
       _onSecondaryFixedVariant = onSecondaryFixedVariant,
       _tertiary = tertiary,
       _onTertiary = onTertiary,
       _tertiaryContainer = tertiaryContainer,
       _onTertiaryContainer = onTertiaryContainer,
       _tertiaryFixed = tertiaryFixed,
       _tertiaryFixedDim = tertiaryFixedDim,
       _onTertiaryFixed = onTertiaryFixed,
       _onTertiaryFixedVariant = onTertiaryFixedVariant,
       _errorContainer = errorContainer,
       _onErrorContainer = onErrorContainer,
       _surfaceDim = surfaceDim,
       _surfaceBright = surfaceBright,
       _surfaceContainerLowest = surfaceContainerLowest,
       _surfaceContainerLow = surfaceContainerLow,
       _surfaceContainer = surfaceContainer,
       _surfaceContainerHigh = surfaceContainerHigh,
       _surfaceContainerHighest = surfaceContainerHighest,
       _onSurfaceVariant = onSurfaceVariant,
       _outline = outline,
       _outlineVariant = outlineVariant,
       _shadow = shadow,
       _scrim = scrim,
       _inverseSurface = inverseSurface,
       _onInverseSurface = onInverseSurface,
       _inversePrimary = inversePrimary,
       _surfaceTint = surfaceTint,
       // DEPRECATED (newest deprecations at the bottom)
       _background = background,
       _onBackground = onBackground,
       _surfaceVariant = surfaceVariant;

  /// Generate a [ColorScheme] derived from the given `seedColor`.
  ///
  /// Using the `seedColor` as a starting point, a set of tonal palettes are
  /// constructed. By default, the tonal palettes are based on the Material 3
  /// Color system and provide all of the [ColorScheme] colors. These colors are
  /// designed to work well together and meet contrast requirements for
  /// accessibility.
  ///
  /// If any of the optional color parameters are non-null they will be
  /// used in place of the generated colors for that field in the resulting
  /// color scheme. This allows apps to override specific colors for their
  /// needs.
  ///
  /// Given the nature of the algorithm, the `seedColor` may not wind up as
  /// one of the ColorScheme colors.
  ///
  /// The `dynamicSchemeVariant` parameter creates different types of
  /// [DynamicScheme]s, which are used to generate different styles of [ColorScheme]s.
  /// By default, `dynamicSchemeVariant` is set to `tonalSpot`. A [ColorScheme]
  /// constructed by `dynamicSchemeVariant.tonalSpot` has pastel palettes and
  /// won't be too "colorful" even if the `seedColor` has a high chroma value.
  /// If the resulting color scheme is too dark, consider setting `dynamicSchemeVariant`
  /// to [DynamicSchemeVariant.fidelity], whose palettes match the seed color.
  ///
  /// The `contrastLevel` parameter indicates the contrast level between color
  /// pairs, such as [primary] and [onPrimary]. 0.0 is the default (normal);
  /// -1.0 is the lowest; 1.0 is the highest. From Material Design guideline, the
  /// medium and high contrast correspond to 0.5 and 1.0 respectively.
  ///
  /// {@tool dartpad}
  /// This sample shows how to use [ColorScheme.fromSeed] to create dynamic
  /// color schemes with different [DynamicSchemeVariant]s and different
  /// contrast level.
  ///
  /// ** See code in examples/api/lib/material/color_scheme/color_scheme.0.dart **
  /// {@end-tool}
  ///
  /// See also:
  ///
  ///  * <https://m3.material.io/styles/color/the-color-system/color-roles>, the
  ///    Material 3 Color system specification.
  ///  * <https://pub.dev/packages/material_color_utilities>, the package
  ///    used to generate the tonal palettes needed for the scheme.
  factory ColorScheme.fromSeed({
    required Color seedColor,
    Brightness brightness = Brightness.light,
    DynamicSchemeVariant dynamicSchemeVariant = DynamicSchemeVariant.tonalSpot,
    double contrastLevel = 0.0,
    Color? primary,
    Color? onPrimary,
    Color? primaryContainer,
    Color? onPrimaryContainer,
    Color? primaryFixed,
    Color? primaryFixedDim,
    Color? onPrimaryFixed,
    Color? onPrimaryFixedVariant,
    Color? secondary,
    Color? onSecondary,
    Color? secondaryContainer,
    Color? onSecondaryContainer,
    Color? secondaryFixed,
    Color? secondaryFixedDim,
    Color? onSecondaryFixed,
    Color? onSecondaryFixedVariant,
    Color? tertiary,
    Color? onTertiary,
    Color? tertiaryContainer,
    Color? onTertiaryContainer,
    Color? tertiaryFixed,
    Color? tertiaryFixedDim,
    Color? onTertiaryFixed,
    Color? onTertiaryFixedVariant,
    Color? error,
    Color? onError,
    Color? errorContainer,
    Color? onErrorContainer,
    Color? outline,
    Color? outlineVariant,
    Color? surface,
    Color? onSurface,
    Color? surfaceDim,
    Color? surfaceBright,
    Color? surfaceContainerLowest,
    Color? surfaceContainerLow,
    Color? surfaceContainer,
    Color? surfaceContainerHigh,
    Color? surfaceContainerHighest,
    Color? onSurfaceVariant,
    Color? inverseSurface,
    Color? onInverseSurface,
    Color? inversePrimary,
    Color? shadow,
    Color? scrim,
    Color? surfaceTint,
    @Deprecated(
      'Use surface instead. '
      'This feature was deprecated after v3.18.0-0.1.pre.',
    )
    Color? background,
    @Deprecated(
      'Use onSurface instead. '
      'This feature was deprecated after v3.18.0-0.1.pre.',
    )
    Color? onBackground,
    @Deprecated(
      'Use surfaceContainerHighest instead. '
      'This feature was deprecated after v3.18.0-0.1.pre.',
    )
    Color? surfaceVariant,
  }) {
    final DynamicScheme scheme = _buildDynamicScheme(
      brightness,
      seedColor,
      dynamicSchemeVariant,
      contrastLevel,
    );

    return ColorScheme(
      primary: primary ?? Color(MaterialDynamicColors.primary.getArgb(scheme)),
      onPrimary: onPrimary ?? Color(MaterialDynamicColors.onPrimary.getArgb(scheme)),
      primaryContainer:
          primaryContainer ?? Color(MaterialDynamicColors.primaryContainer.getArgb(scheme)),
      onPrimaryContainer:
          onPrimaryContainer ?? Color(MaterialDynamicColors.onPrimaryContainer.getArgb(scheme)),
      primaryFixed: primaryFixed ?? Color(MaterialDynamicColors.primaryFixed.getArgb(scheme)),
      primaryFixedDim:
          primaryFixedDim ?? Color(MaterialDynamicColors.primaryFixedDim.getArgb(scheme)),
      onPrimaryFixed: onPrimaryFixed ?? Color(MaterialDynamicColors.onPrimaryFixed.getArgb(scheme)),
      onPrimaryFixedVariant:
          onPrimaryFixedVariant ??
          Color(MaterialDynamicColors.onPrimaryFixedVariant.getArgb(scheme)),
      secondary: secondary ?? Color(MaterialDynamicColors.secondary.getArgb(scheme)),
      onSecondary: onSecondary ?? Color(MaterialDynamicColors.onSecondary.getArgb(scheme)),
      secondaryContainer:
          secondaryContainer ?? Color(MaterialDynamicColors.secondaryContainer.getArgb(scheme)),
      onSecondaryContainer:
          onSecondaryContainer ?? Color(MaterialDynamicColors.onSecondaryContainer.getArgb(scheme)),
      secondaryFixed: secondaryFixed ?? Color(MaterialDynamicColors.secondaryFixed.getArgb(scheme)),
      secondaryFixedDim:
          secondaryFixedDim ?? Color(MaterialDynamicColors.secondaryFixedDim.getArgb(scheme)),
      onSecondaryFixed:
          onSecondaryFixed ?? Color(MaterialDynamicColors.onSecondaryFixed.getArgb(scheme)),
      onSecondaryFixedVariant:
          onSecondaryFixedVariant ??
          Color(MaterialDynamicColors.onSecondaryFixedVariant.getArgb(scheme)),
      tertiary: tertiary ?? Color(MaterialDynamicColors.tertiary.getArgb(scheme)),
      onTertiary: onTertiary ?? Color(MaterialDynamicColors.onTertiary.getArgb(scheme)),
      tertiaryContainer:
          tertiaryContainer ?? Color(MaterialDynamicColors.tertiaryContainer.getArgb(scheme)),
      onTertiaryContainer:
          onTertiaryContainer ?? Color(MaterialDynamicColors.onTertiaryContainer.getArgb(scheme)),
      tertiaryFixed: tertiaryFixed ?? Color(MaterialDynamicColors.tertiaryFixed.getArgb(scheme)),
      tertiaryFixedDim:
          tertiaryFixedDim ?? Color(MaterialDynamicColors.tertiaryFixedDim.getArgb(scheme)),
      onTertiaryFixed:
          onTertiaryFixed ?? Color(MaterialDynamicColors.onTertiaryFixed.getArgb(scheme)),
      onTertiaryFixedVariant:
          onTertiaryFixedVariant ??
          Color(MaterialDynamicColors.onTertiaryFixedVariant.getArgb(scheme)),
      error: error ?? Color(MaterialDynamicColors.error.getArgb(scheme)),
      onError: onError ?? Color(MaterialDynamicColors.onError.getArgb(scheme)),
      errorContainer: errorContainer ?? Color(MaterialDynamicColors.errorContainer.getArgb(scheme)),
      onErrorContainer:
          onErrorContainer ?? Color(MaterialDynamicColors.onErrorContainer.getArgb(scheme)),
      outline: outline ?? Color(MaterialDynamicColors.outline.getArgb(scheme)),
      outlineVariant: outlineVariant ?? Color(MaterialDynamicColors.outlineVariant.getArgb(scheme)),
      surface: surface ?? Color(MaterialDynamicColors.surface.getArgb(scheme)),
      surfaceDim: surfaceDim ?? Color(MaterialDynamicColors.surfaceDim.getArgb(scheme)),
      surfaceBright: surfaceBright ?? Color(MaterialDynamicColors.surfaceBright.getArgb(scheme)),
      surfaceContainerLowest:
          surfaceContainerLowest ??
          Color(MaterialDynamicColors.surfaceContainerLowest.getArgb(scheme)),
      surfaceContainerLow:
          surfaceContainerLow ?? Color(MaterialDynamicColors.surfaceContainerLow.getArgb(scheme)),
      surfaceContainer:
          surfaceContainer ?? Color(MaterialDynamicColors.surfaceContainer.getArgb(scheme)),
      surfaceContainerHigh:
          surfaceContainerHigh ?? Color(MaterialDynamicColors.surfaceContainerHigh.getArgb(scheme)),
      surfaceContainerHighest:
          surfaceContainerHighest ??
          Color(MaterialDynamicColors.surfaceContainerHighest.getArgb(scheme)),
      onSurface: onSurface ?? Color(MaterialDynamicColors.onSurface.getArgb(scheme)),
      onSurfaceVariant:
          onSurfaceVariant ?? Color(MaterialDynamicColors.onSurfaceVariant.getArgb(scheme)),
      inverseSurface: inverseSurface ?? Color(MaterialDynamicColors.inverseSurface.getArgb(scheme)),
      onInverseSurface:
          onInverseSurface ?? Color(MaterialDynamicColors.inverseOnSurface.getArgb(scheme)),
      inversePrimary: inversePrimary ?? Color(MaterialDynamicColors.inversePrimary.getArgb(scheme)),
      shadow: shadow ?? Color(MaterialDynamicColors.shadow.getArgb(scheme)),
      scrim: scrim ?? Color(MaterialDynamicColors.scrim.getArgb(scheme)),
      surfaceTint: surfaceTint ?? Color(MaterialDynamicColors.primary.getArgb(scheme)),
      brightness: brightness,
      // DEPRECATED (newest deprecations at the bottom)
      background: background ?? Color(MaterialDynamicColors.background.getArgb(scheme)),
      onBackground: onBackground ?? Color(MaterialDynamicColors.onBackground.getArgb(scheme)),
      surfaceVariant: surfaceVariant ?? Color(MaterialDynamicColors.surfaceVariant.getArgb(scheme)),
    );
  }

  /// Create a light ColorScheme based on a purple primary color that matches the
  /// [baseline Material 2 color scheme](https://material.io/design/color/the-color-system.html#color-theme-creation).
  ///
  /// This constructor shouldn't be used to update the Material 3 color scheme.
  ///
  /// For Material 3, use [ColorScheme.fromSeed] to create a color scheme
  /// from a single seed color based on the Material 3 color system.
  ///
  /// {@tool snippet}
  /// This example demonstrates how to create a color scheme similar to [ColorScheme.light]
  /// using the [ColorScheme.fromSeed] constructor:
  ///
  /// ```dart
  /// colorScheme: ColorScheme.fromSeed(seedColor: const Color(0xff6200ee)).copyWith(
  ///   primaryContainer: const Color(0xff6200ee),
  ///   onPrimaryContainer: Colors.white,
  ///   secondaryContainer: const Color(0xff03dac6),
  ///   onSecondaryContainer: Colors.black,
  ///   error: const Color(0xffb00020),
  ///   onError: Colors.white,
  /// ),
  /// ```
  /// {@end-tool}
  const ColorScheme.light({
    this.brightness = Brightness.light,
    this.primary = const Color(0xff6200ee),
    this.onPrimary = Colors.white,
    Color? primaryContainer,
    Color? onPrimaryContainer,
    Color? primaryFixed,
    Color? primaryFixedDim,
    Color? onPrimaryFixed,
    Color? onPrimaryFixedVariant,
    this.secondary = const Color(0xff03dac6),
    this.onSecondary = Colors.black,
    Color? secondaryContainer,
    Color? onSecondaryContainer,
    Color? secondaryFixed,
    Color? secondaryFixedDim,
    Color? onSecondaryFixed,
    Color? onSecondaryFixedVariant,
    Color? tertiary,
    Color? onTertiary,
    Color? tertiaryContainer,
    Color? onTertiaryContainer,
    Color? tertiaryFixed,
    Color? tertiaryFixedDim,
    Color? onTertiaryFixed,
    Color? onTertiaryFixedVariant,
    this.error = const Color(0xffb00020),
    this.onError = Colors.white,
    Color? errorContainer,
    Color? onErrorContainer,
    this.surface = Colors.white,
    this.onSurface = Colors.black,
    Color? surfaceDim,
    Color? surfaceBright,
    Color? surfaceContainerLowest,
    Color? surfaceContainerLow,
    Color? surfaceContainer,
    Color? surfaceContainerHigh,
    Color? surfaceContainerHighest,
    Color? onSurfaceVariant,
    Color? outline,
    Color? outlineVariant,
    Color? shadow,
    Color? scrim,
    Color? inverseSurface,
    Color? onInverseSurface,
    Color? inversePrimary,
    Color? surfaceTint,
    @Deprecated(
      'Use surface instead. '
      'This feature was deprecated after v3.18.0-0.1.pre.',
    )
    Color? background = Colors.white,
    @Deprecated(
      'Use onSurface instead. '
      'This feature was deprecated after v3.18.0-0.1.pre.',
    )
    Color? onBackground = Colors.black,
    @Deprecated(
      'Use surfaceContainerHighest instead. '
      'This feature was deprecated after v3.18.0-0.1.pre.',
    )
    Color? surfaceVariant,
  }) : _primaryContainer = primaryContainer,
       _onPrimaryContainer = onPrimaryContainer,
       _primaryFixed = primaryFixed,
       _primaryFixedDim = primaryFixedDim,
       _onPrimaryFixed = onPrimaryFixed,
       _onPrimaryFixedVariant = onPrimaryFixedVariant,
       _secondaryContainer = secondaryContainer,
       _onSecondaryContainer = onSecondaryContainer,
       _secondaryFixed = secondaryFixed,
       _secondaryFixedDim = secondaryFixedDim,
       _onSecondaryFixed = onSecondaryFixed,
       _onSecondaryFixedVariant = onSecondaryFixedVariant,
       _tertiary = tertiary,
       _onTertiary = onTertiary,
       _tertiaryContainer = tertiaryContainer,
       _onTertiaryContainer = onTertiaryContainer,
       _tertiaryFixed = tertiaryFixed,
       _tertiaryFixedDim = tertiaryFixedDim,
       _onTertiaryFixed = onTertiaryFixed,
       _onTertiaryFixedVariant = onTertiaryFixedVariant,
       _errorContainer = errorContainer,
       _onErrorContainer = onErrorContainer,
       _surfaceDim = surfaceDim,
       _surfaceBright = surfaceBright,
       _surfaceContainerLowest = surfaceContainerLowest,
       _surfaceContainerLow = surfaceContainerLow,
       _surfaceContainer = surfaceContainer,
       _surfaceContainerHigh = surfaceContainerHigh,
       _surfaceContainerHighest = surfaceContainerHighest,
       _onSurfaceVariant = onSurfaceVariant,
       _outline = outline,
       _outlineVariant = outlineVariant,
       _shadow = shadow,
       _scrim = scrim,
       _inverseSurface = inverseSurface,
       _onInverseSurface = onInverseSurface,
       _inversePrimary = inversePrimary,
       _surfaceTint = surfaceTint,
       // DEPRECATED (newest deprecations at the bottom)
       _background = background,
       _onBackground = onBackground,
       _surfaceVariant = surfaceVariant;

  /// Create the dark color scheme that matches the
  /// [baseline Material 2 color scheme](https://material.io/design/color/dark-theme.html#ui-application).
  ///
  /// This constructor shouldn't be used to update the Material 3 color scheme.
  ///
  /// For Material 3, use [ColorScheme.fromSeed] to create a color scheme
  /// from a single seed color based on the Material 3 color system.
  /// Override the `brightness` property of [ColorScheme.fromSeed] to create a
  /// dark color scheme.
  ///
  /// {@tool snippet}
  /// This example demonstrates how to create a color scheme similar to [ColorScheme.dark]
  /// using the [ColorScheme.fromSeed] constructor:
  ///
  /// ```dart
  /// colorScheme: ColorScheme.fromSeed(
  ///   seedColor: const Color(0xffbb86fc),
  ///   brightness: Brightness.dark,
  /// ).copyWith(
  ///   primaryContainer: const Color(0xffbb86fc),
  ///   onPrimaryContainer: Colors.black,
  ///   secondaryContainer: const Color(0xff03dac6),
  ///   onSecondaryContainer: Colors.black,
  ///   error: const Color(0xffcf6679),
  ///   onError: Colors.black,
  /// ),
  /// ```
  /// {@end-tool}
  const ColorScheme.dark({
    this.brightness = Brightness.dark,
    this.primary = const Color(0xffbb86fc),
    this.onPrimary = Colors.black,
    Color? primaryContainer,
    Color? onPrimaryContainer,
    Color? primaryFixed,
    Color? primaryFixedDim,
    Color? onPrimaryFixed,
    Color? onPrimaryFixedVariant,
    this.secondary = const Color(0xff03dac6),
    this.onSecondary = Colors.black,
    Color? secondaryContainer,
    Color? onSecondaryContainer,
    Color? secondaryFixed,
    Color? secondaryFixedDim,
    Color? onSecondaryFixed,
    Color? onSecondaryFixedVariant,
    Color? tertiary,
    Color? onTertiary,
    Color? tertiaryContainer,
    Color? onTertiaryContainer,
    Color? tertiaryFixed,
    Color? tertiaryFixedDim,
    Color? onTertiaryFixed,
    Color? onTertiaryFixedVariant,
    this.error = const Color(0xffcf6679),
    this.onError = Colors.black,
    Color? errorContainer,
    Color? onErrorContainer,
    this.surface = const Color(0xff121212),
    this.onSurface = Colors.white,
    Color? surfaceDim,
    Color? surfaceBright,
    Color? surfaceContainerLowest,
    Color? surfaceContainerLow,
    Color? surfaceContainer,
    Color? surfaceContainerHigh,
    Color? surfaceContainerHighest,
    Color? onSurfaceVariant,
    Color? outline,
    Color? outlineVariant,
    Color? shadow,
    Color? scrim,
    Color? inverseSurface,
    Color? onInverseSurface,
    Color? inversePrimary,
    Color? surfaceTint,
    @Deprecated(
      'Use surface instead. '
      'This feature was deprecated after v3.18.0-0.1.pre.',
    )
    Color? background = const Color(0xff121212),
    @Deprecated(
      'Use onSurface instead. '
      'This feature was deprecated after v3.18.0-0.1.pre.',
    )
    Color? onBackground = Colors.white,
    @Deprecated(
      'Use surfaceContainerHighest instead. '
      'This feature was deprecated after v3.18.0-0.1.pre.',
    )
    Color? surfaceVariant,
  }) : _primaryContainer = primaryContainer,
       _onPrimaryContainer = onPrimaryContainer,
       _primaryFixed = primaryFixed,
       _primaryFixedDim = primaryFixedDim,
       _onPrimaryFixed = onPrimaryFixed,
       _onPrimaryFixedVariant = onPrimaryFixedVariant,
       _secondaryContainer = secondaryContainer,
       _onSecondaryContainer = onSecondaryContainer,
       _secondaryFixed = secondaryFixed,
       _secondaryFixedDim = secondaryFixedDim,
       _onSecondaryFixed = onSecondaryFixed,
       _onSecondaryFixedVariant = onSecondaryFixedVariant,
       _tertiary = tertiary,
       _onTertiary = onTertiary,
       _tertiaryContainer = tertiaryContainer,
       _onTertiaryContainer = onTertiaryContainer,
       _tertiaryFixed = tertiaryFixed,
       _tertiaryFixedDim = tertiaryFixedDim,
       _onTertiaryFixed = onTertiaryFixed,
       _onTertiaryFixedVariant = onTertiaryFixedVariant,
       _errorContainer = errorContainer,
       _onErrorContainer = onErrorContainer,
       _surfaceDim = surfaceDim,
       _surfaceBright = surfaceBright,
       _surfaceContainerLowest = surfaceContainerLowest,
       _surfaceContainerLow = surfaceContainerLow,
       _surfaceContainer = surfaceContainer,
       _surfaceContainerHigh = surfaceContainerHigh,
       _surfaceContainerHighest = surfaceContainerHighest,
       _onSurfaceVariant = onSurfaceVariant,
       _outline = outline,
       _outlineVariant = outlineVariant,
       _shadow = shadow,
       _scrim = scrim,
       _inverseSurface = inverseSurface,
       _onInverseSurface = onInverseSurface,
       _inversePrimary = inversePrimary,
       _surfaceTint = surfaceTint,
       // DEPRECATED (newest deprecations at the bottom)
       _background = background,
       _onBackground = onBackground,
       _surfaceVariant = surfaceVariant;

  /// Create a high contrast ColorScheme based on a purple primary color that
  /// matches the [baseline Material 2 color scheme](https://material.io/design/color/the-color-system.html#color-theme-creation).
  ///
  /// This constructor shouldn't be used to update the Material 3 color scheme.
  ///
  /// For Material 3, use [ColorScheme.fromSeed] to create a color scheme
  /// from a single seed color based on the Material 3 color system. To create a
  /// high-contrast color scheme, set `contrastLevel` to 1.0.
  ///
  /// {@tool snippet}
  /// This example demonstrates how to create a color scheme similar to [ColorScheme.highContrastLight]
  /// using the [ColorScheme.fromSeed] constructor:
  ///
  /// ```dart
  /// colorScheme: ColorScheme.fromSeed(seedColor: const Color(0xff0000ba)).copyWith(
  ///   primaryContainer: const Color(0xff0000ba),
  ///   onPrimaryContainer: Colors.white,
  ///   secondaryContainer: const Color(0xff66fff9),
  ///   onSecondaryContainer: Colors.black,
  ///   error: const Color(0xff790000),
  ///   onError: Colors.white,
  /// ),
  /// ```
  /// {@end-tool}
  const ColorScheme.highContrastLight({
    this.brightness = Brightness.light,
    this.primary = const Color(0xff0000ba),
    this.onPrimary = Colors.white,
    Color? primaryContainer,
    Color? onPrimaryContainer,
    Color? primaryFixed,
    Color? primaryFixedDim,
    Color? onPrimaryFixed,
    Color? onPrimaryFixedVariant,
    this.secondary = const Color(0xff66fff9),
    this.onSecondary = Colors.black,
    Color? secondaryContainer,
    Color? onSecondaryContainer,
    Color? secondaryFixed,
    Color? secondaryFixedDim,
    Color? onSecondaryFixed,
    Color? onSecondaryFixedVariant,
    Color? tertiary,
    Color? onTertiary,
    Color? tertiaryContainer,
    Color? onTertiaryContainer,
    Color? tertiaryFixed,
    Color? tertiaryFixedDim,
    Color? onTertiaryFixed,
    Color? onTertiaryFixedVariant,
    this.error = const Color(0xff790000),
    this.onError = Colors.white,
    Color? errorContainer,
    Color? onErrorContainer,
    this.surface = Colors.white,
    this.onSurface = Colors.black,
    Color? surfaceDim,
    Color? surfaceBright,
    Color? surfaceContainerLowest,
    Color? surfaceContainerLow,
    Color? surfaceContainer,
    Color? surfaceContainerHigh,
    Color? surfaceContainerHighest,
    Color? onSurfaceVariant,
    Color? outline,
    Color? outlineVariant,
    Color? shadow,
    Color? scrim,
    Color? inverseSurface,
    Color? onInverseSurface,
    Color? inversePrimary,
    Color? surfaceTint,
    @Deprecated(
      'Use surface instead. '
      'This feature was deprecated after v3.18.0-0.1.pre.',
    )
    Color? background = Colors.white,
    @Deprecated(
      'Use onSurface instead. '
      'This feature was deprecated after v3.18.0-0.1.pre.',
    )
    Color? onBackground = Colors.black,
    @Deprecated(
      'Use surfaceContainerHighest instead. '
      'This feature was deprecated after v3.18.0-0.1.pre.',
    )
    Color? surfaceVariant,
  }) : _primaryContainer = primaryContainer,
       _onPrimaryContainer = onPrimaryContainer,
       _primaryFixed = primaryFixed,
       _primaryFixedDim = primaryFixedDim,
       _onPrimaryFixed = onPrimaryFixed,
       _onPrimaryFixedVariant = onPrimaryFixedVariant,
       _secondaryContainer = secondaryContainer,
       _onSecondaryContainer = onSecondaryContainer,
       _secondaryFixed = secondaryFixed,
       _secondaryFixedDim = secondaryFixedDim,
       _onSecondaryFixed = onSecondaryFixed,
       _onSecondaryFixedVariant = onSecondaryFixedVariant,
       _tertiary = tertiary,
       _onTertiary = onTertiary,
       _tertiaryContainer = tertiaryContainer,
       _onTertiaryContainer = onTertiaryContainer,
       _tertiaryFixed = tertiaryFixed,
       _tertiaryFixedDim = tertiaryFixedDim,
       _onTertiaryFixed = onTertiaryFixed,
       _onTertiaryFixedVariant = onTertiaryFixedVariant,
       _errorContainer = errorContainer,
       _onErrorContainer = onErrorContainer,
       _surfaceDim = surfaceDim,
       _surfaceBright = surfaceBright,
       _surfaceContainerLowest = surfaceContainerLowest,
       _surfaceContainerLow = surfaceContainerLow,
       _surfaceContainer = surfaceContainer,
       _surfaceContainerHigh = surfaceContainerHigh,
       _surfaceContainerHighest = surfaceContainerHighest,
       _onSurfaceVariant = onSurfaceVariant,
       _outline = outline,
       _outlineVariant = outlineVariant,
       _shadow = shadow,
       _scrim = scrim,
       _inverseSurface = inverseSurface,
       _onInverseSurface = onInverseSurface,
       _inversePrimary = inversePrimary,
       _surfaceTint = surfaceTint,
       // DEPRECATED (newest deprecations at the bottom)
       _background = background,
       _onBackground = onBackground,
       _surfaceVariant = surfaceVariant;

  /// Create a high contrast ColorScheme based on the dark
  /// [baseline Material 2 color scheme](https://material.io/design/color/dark-theme.html#ui-application).
  ///
  /// This constructor shouldn't be used to update the Material 3 color scheme.
  ///
  /// For Material 3, use [ColorScheme.fromSeed] to create a color scheme
  /// from a single seed color based on the Material 3 color system.
  /// Override the `brightness` property of [ColorScheme.fromSeed] to create a
  /// dark color scheme. To create a high-contrast color scheme, set
  /// `contrastLevel` to 1.0.
  ///
  /// {@tool snippet}
  /// This example demonstrates how to create a color scheme similar to [ColorScheme.highContrastDark]
  /// using the [ColorScheme.fromSeed] constructor:
  ///
  /// ```dart
  /// colorScheme: ColorScheme.fromSeed(
  ///   seedColor: const Color(0xffefb7ff),
  ///   brightness: Brightness.dark,
  /// ).copyWith(
  ///   primaryContainer: const Color(0xffefb7ff),
  ///   onPrimaryContainer: Colors.black,
  ///   secondaryContainer: const Color(0xff66fff9),
  ///   onSecondaryContainer: Colors.black,
  ///   error: const Color(0xff9b374d),
  ///   onError: Colors.white,
  /// ),
  /// ```
  /// {@end-tool}
  const ColorScheme.highContrastDark({
    this.brightness = Brightness.dark,
    this.primary = const Color(0xffefb7ff),
    this.onPrimary = Colors.black,
    Color? primaryContainer,
    Color? onPrimaryContainer,
    Color? primaryFixed,
    Color? primaryFixedDim,
    Color? onPrimaryFixed,
    Color? onPrimaryFixedVariant,
    this.secondary = const Color(0xff66fff9),
    this.onSecondary = Colors.black,
    Color? secondaryContainer,
    Color? onSecondaryContainer,
    Color? secondaryFixed,
    Color? secondaryFixedDim,
    Color? onSecondaryFixed,
    Color? onSecondaryFixedVariant,
    Color? tertiary,
    Color? onTertiary,
    Color? tertiaryContainer,
    Color? onTertiaryContainer,
    Color? tertiaryFixed,
    Color? tertiaryFixedDim,
    Color? onTertiaryFixed,
    Color? onTertiaryFixedVariant,
    this.error = const Color(0xff9b374d),
    this.onError = Colors.black,
    Color? errorContainer,
    Color? onErrorContainer,
    this.surface = const Color(0xff121212),
    this.onSurface = Colors.white,
    Color? surfaceDim,
    Color? surfaceBright,
    Color? surfaceContainerLowest,
    Color? surfaceContainerLow,
    Color? surfaceContainer,
    Color? surfaceContainerHigh,
    Color? surfaceContainerHighest,
    Color? onSurfaceVariant,
    Color? outline,
    Color? outlineVariant,
    Color? shadow,
    Color? scrim,
    Color? inverseSurface,
    Color? onInverseSurface,
    Color? inversePrimary,
    Color? surfaceTint,
    @Deprecated(
      'Use surface instead. '
      'This feature was deprecated after v3.18.0-0.1.pre.',
    )
    Color? background = const Color(0xff121212),
    @Deprecated(
      'Use onSurface instead. '
      'This feature was deprecated after v3.18.0-0.1.pre.',
    )
    Color? onBackground = Colors.white,
    @Deprecated(
      'Use surfaceContainerHighest instead. '
      'This feature was deprecated after v3.18.0-0.1.pre.',
    )
    Color? surfaceVariant,
  }) : _primaryContainer = primaryContainer,
       _onPrimaryContainer = onPrimaryContainer,
       _primaryFixed = primaryFixed,
       _primaryFixedDim = primaryFixedDim,
       _onPrimaryFixed = onPrimaryFixed,
       _onPrimaryFixedVariant = onPrimaryFixedVariant,
       _secondaryContainer = secondaryContainer,
       _onSecondaryContainer = onSecondaryContainer,
       _secondaryFixed = secondaryFixed,
       _secondaryFixedDim = secondaryFixedDim,
       _onSecondaryFixed = onSecondaryFixed,
       _onSecondaryFixedVariant = onSecondaryFixedVariant,
       _tertiary = tertiary,
       _onTertiary = onTertiary,
       _tertiaryContainer = tertiaryContainer,
       _onTertiaryContainer = onTertiaryContainer,
       _tertiaryFixed = tertiaryFixed,
       _tertiaryFixedDim = tertiaryFixedDim,
       _onTertiaryFixed = onTertiaryFixed,
       _onTertiaryFixedVariant = onTertiaryFixedVariant,
       _errorContainer = errorContainer,
       _onErrorContainer = onErrorContainer,
       _surfaceDim = surfaceDim,
       _surfaceBright = surfaceBright,
       _surfaceContainerLowest = surfaceContainerLowest,
       _surfaceContainerLow = surfaceContainerLow,
       _surfaceContainer = surfaceContainer,
       _surfaceContainerHigh = surfaceContainerHigh,
       _surfaceContainerHighest = surfaceContainerHighest,
       _onSurfaceVariant = onSurfaceVariant,
       _outline = outline,
       _outlineVariant = outlineVariant,
       _shadow = shadow,
       _scrim = scrim,
       _inverseSurface = inverseSurface,
       _onInverseSurface = onInverseSurface,
       _inversePrimary = inversePrimary,
       _surfaceTint = surfaceTint,
       // DEPRECATED (newest deprecations at the bottom)
       _background = background,
       _onBackground = onBackground,
       _surfaceVariant = surfaceVariant;

  /// Creates a color scheme from a [MaterialColor] swatch.
  ///
  /// In Material 3, this constructor is ignored by [ThemeData] when creating
  /// its default color scheme. Instead, [ThemeData] uses [ColorScheme.fromSeed]
  /// to create its default color scheme. This constructor shouldn't be used
  /// to update the Material 3 color scheme. It will be phased out gradually;
  /// see https://github.com/flutter/flutter/issues/120064 for more details.
  ///
  /// If [ThemeData.useMaterial3] is false, then this constructor is used by
  /// [ThemeData] to create its default color scheme.
  factory ColorScheme.fromSwatch({
    MaterialColor primarySwatch = Colors.blue,
    Color? accentColor,
    Color? cardColor,
    Color? backgroundColor,
    Color? errorColor,
    Brightness brightness = Brightness.light,
  }) {
    final bool isDark = brightness == Brightness.dark;
    final bool primaryIsDark = _brightnessFor(primarySwatch) == Brightness.dark;
    final Color secondary = accentColor ?? (isDark ? Colors.tealAccent[200]! : primarySwatch);
    final bool secondaryIsDark = _brightnessFor(secondary) == Brightness.dark;

    return ColorScheme(
      primary: primarySwatch,
      secondary: secondary,
      surface: cardColor ?? (isDark ? Colors.grey[800]! : Colors.white),
      error: errorColor ?? Colors.red[700]!,
      onPrimary: primaryIsDark ? Colors.white : Colors.black,
      onSecondary: secondaryIsDark ? Colors.white : Colors.black,
      onSurface: isDark ? Colors.white : Colors.black,
      onError: isDark ? Colors.black : Colors.white,
      brightness: brightness,
      // DEPRECATED (newest deprecations at the bottom)
      background: backgroundColor ?? (isDark ? Colors.grey[700]! : primarySwatch[200]!),
      onBackground: primaryIsDark ? Colors.white : Colors.black,
    );
  }

  static Brightness _brightnessFor(Color color) => ThemeData.estimateBrightnessForColor(color);

  /// The overall brightness of this color scheme.
  final Brightness brightness;

  /// The color displayed most frequently across your app’s screens and components.
  final Color primary;

  /// A color that's clearly legible when drawn on [primary].
  ///
  /// To ensure that an app is accessible, a contrast ratio between
  /// [primary] and [onPrimary] of at least 4.5:1 is recommended. See
  /// <https://www.w3.org/TR/UNDERSTANDING-WCAG20/visual-audio-contrast-contrast.html>.
  final Color onPrimary;

  final Color? _primaryContainer;

  /// A color used for elements needing less emphasis than [primary].
  Color get primaryContainer => _primaryContainer ?? primary;

  final Color? _onPrimaryContainer;

  /// A color that's clearly legible when drawn on [primaryContainer].
  ///
  /// To ensure that an app is accessible, a contrast ratio between
  /// [primaryContainer] and [onPrimaryContainer] of at least 4.5:1
  /// is recommended. See
  /// <https://www.w3.org/TR/UNDERSTANDING-WCAG20/visual-audio-contrast-contrast.html>.
  Color get onPrimaryContainer => _onPrimaryContainer ?? onPrimary;

  final Color? _primaryFixed;

  /// A substitute for [primaryContainer] that's the same color for the dark
  /// and light themes.
  Color get primaryFixed => _primaryFixed ?? primary;

  final Color? _primaryFixedDim;

  /// A color used for elements needing more emphasis than [primaryFixed].
  Color get primaryFixedDim => _primaryFixedDim ?? primary;

  final Color? _onPrimaryFixed;

  /// A color that is used for text and icons that exist on top of elements having
  /// [primaryFixed] color.
  Color get onPrimaryFixed => _onPrimaryFixed ?? onPrimary;

  final Color? _onPrimaryFixedVariant;

  /// A color that provides a lower-emphasis option for text and icons than
  /// [onPrimaryFixed].
  Color get onPrimaryFixedVariant => _onPrimaryFixedVariant ?? onPrimary;

  /// An accent color used for less prominent components in the UI, such as
  /// filter chips, while expanding the opportunity for color expression.
  final Color secondary;

  /// A color that's clearly legible when drawn on [secondary].
  ///
  /// To ensure that an app is accessible, a contrast ratio between
  /// [secondary] and [onSecondary] of at least 4.5:1 is recommended. See
  /// <https://www.w3.org/TR/UNDERSTANDING-WCAG20/visual-audio-contrast-contrast.html>.
  final Color onSecondary;

  final Color? _secondaryContainer;

  /// A color used for elements needing less emphasis than [secondary].
  Color get secondaryContainer => _secondaryContainer ?? secondary;

  final Color? _onSecondaryContainer;

  /// A color that's clearly legible when drawn on [secondaryContainer].
  ///
  /// To ensure that an app is accessible, a contrast ratio between
  /// [secondaryContainer] and [onSecondaryContainer] of at least 4.5:1 is
  /// recommended. See
  /// <https://www.w3.org/TR/UNDERSTANDING-WCAG20/visual-audio-contrast-contrast.html>.
  Color get onSecondaryContainer => _onSecondaryContainer ?? onSecondary;

  final Color? _secondaryFixed;

  /// A substitute for [secondaryContainer] that's the same color for the dark
  /// and light themes.
  Color get secondaryFixed => _secondaryFixed ?? secondary;

  final Color? _secondaryFixedDim;

  /// A color used for elements needing more emphasis than [secondaryFixed].
  Color get secondaryFixedDim => _secondaryFixedDim ?? secondary;

  final Color? _onSecondaryFixed;

  /// A color that is used for text and icons that exist on top of elements having
  /// [secondaryFixed] color.
  Color get onSecondaryFixed => _onSecondaryFixed ?? onSecondary;

  final Color? _onSecondaryFixedVariant;

  /// A color that provides a lower-emphasis option for text and icons than
  /// [onSecondaryFixed].
  Color get onSecondaryFixedVariant => _onSecondaryFixedVariant ?? onSecondary;

  final Color? _tertiary;

  /// A color used as a contrasting accent that can balance [primary]
  /// and [secondary] colors or bring heightened attention to an element,
  /// such as an input field.
  Color get tertiary => _tertiary ?? secondary;

  final Color? _onTertiary;

  /// A color that's clearly legible when drawn on [tertiary].
  ///
  /// To ensure that an app is accessible, a contrast ratio between
  /// [tertiary] and [onTertiary] of at least 4.5:1 is recommended. See
  /// <https://www.w3.org/TR/UNDERSTANDING-WCAG20/visual-audio-contrast-contrast.html>.
  Color get onTertiary => _onTertiary ?? onSecondary;

  final Color? _tertiaryContainer;

  /// A color used for elements needing less emphasis than [tertiary].
  Color get tertiaryContainer => _tertiaryContainer ?? tertiary;

  final Color? _onTertiaryContainer;

  /// A color that's clearly legible when drawn on [tertiaryContainer].
  ///
  /// To ensure that an app is accessible, a contrast ratio between
  /// [tertiaryContainer] and [onTertiaryContainer] of at least 4.5:1 is
  /// recommended. See
  /// <https://www.w3.org/TR/UNDERSTANDING-WCAG20/visual-audio-contrast-contrast.html>.
  Color get onTertiaryContainer => _onTertiaryContainer ?? onTertiary;

  final Color? _tertiaryFixed;

  /// A substitute for [tertiaryContainer] that's the same color for dark
  /// and light themes.
  Color get tertiaryFixed => _tertiaryFixed ?? tertiary;

  final Color? _tertiaryFixedDim;

  /// A color used for elements needing more emphasis than [tertiaryFixed].
  Color get tertiaryFixedDim => _tertiaryFixedDim ?? tertiary;

  final Color? _onTertiaryFixed;

  /// A color that is used for text and icons that exist on top of elements having
  /// [tertiaryFixed] color.
  Color get onTertiaryFixed => _onTertiaryFixed ?? onTertiary;

  final Color? _onTertiaryFixedVariant;

  /// A color that provides a lower-emphasis option for text and icons than
  /// [onTertiaryFixed].
  Color get onTertiaryFixedVariant => _onTertiaryFixedVariant ?? onTertiary;

  /// The color to use for input validation errors, e.g. for
  /// [InputDecoration.errorText].
  final Color error;

  /// A color that's clearly legible when drawn on [error].
  ///
  /// To ensure that an app is accessible, a contrast ratio between
  /// [error] and [onError] of at least 4.5:1 is recommended. See
  /// <https://www.w3.org/TR/UNDERSTANDING-WCAG20/visual-audio-contrast-contrast.html>.
  final Color onError;

  final Color? _errorContainer;

  /// A color used for error elements needing less emphasis than [error].
  Color get errorContainer => _errorContainer ?? error;

  final Color? _onErrorContainer;

  /// A color that's clearly legible when drawn on [errorContainer].
  ///
  /// To ensure that an app is accessible, a contrast ratio between
  /// [errorContainer] and [onErrorContainer] of at least 4.5:1 is
  /// recommended. See
  /// <https://www.w3.org/TR/UNDERSTANDING-WCAG20/visual-audio-contrast-contrast.html>.
  Color get onErrorContainer => _onErrorContainer ?? onError;

  /// The background color for widgets like [Scaffold].
  final Color surface;

  /// A color that's clearly legible when drawn on [surface].
  ///
  /// To ensure that an app is accessible, a contrast ratio between
  /// [surface] and [onSurface] of at least 4.5:1 is recommended. See
  /// <https://www.w3.org/TR/UNDERSTANDING-WCAG20/visual-audio-contrast-contrast.html>.
  final Color onSurface;

  final Color? _surfaceVariant;

  /// A color variant of [surface] that can be used for differentiation against
  /// a component using [surface].
  @Deprecated(
    'Use surfaceContainerHighest instead. '
    'This feature was deprecated after v3.18.0-0.1.pre.',
  )
  Color get surfaceVariant => _surfaceVariant ?? surface;

  final Color? _surfaceDim;

  /// A color that's always darkest in the dark or light theme.
  Color get surfaceDim => _surfaceDim ?? surface;

  final Color? _surfaceBright;

  /// A color that's always the lightest in the dark or light theme.
  Color get surfaceBright => _surfaceBright ?? surface;

  final Color? _surfaceContainerLowest;

  /// A surface container color with the lightest tone and the least emphasis
  /// relative to the surface.
  Color get surfaceContainerLowest => _surfaceContainerLowest ?? surface;

  final Color? _surfaceContainerLow;

  /// A surface container color with a lighter tone that creates less emphasis
  /// than [surfaceContainer] but more emphasis than [surfaceContainerLowest].
  Color get surfaceContainerLow => _surfaceContainerLow ?? surface;

  final Color? _surfaceContainer;

  /// A recommended color role for a distinct area within the surface.
  ///
  /// Surface container color roles are independent of elevation. They replace the old
  /// opacity-based model which applied a tinted overlay on top of
  /// surfaces based on their elevation.
  ///
  /// Surface container colors include [surfaceContainerLowest], [surfaceContainerLow],
  /// [surfaceContainer], [surfaceContainerHigh] and [surfaceContainerHighest].
  Color get surfaceContainer => _surfaceContainer ?? surface;

  final Color? _surfaceContainerHigh;

  /// A surface container color with a darker tone. It is used to create more
  /// emphasis than [surfaceContainer] but less emphasis than [surfaceContainerHighest].
  Color get surfaceContainerHigh => _surfaceContainerHigh ?? surface;

  final Color? _surfaceContainerHighest;

  /// A surface container color with the darkest tone. It is used to create the
  /// most emphasis against the surface.
  Color get surfaceContainerHighest => _surfaceContainerHighest ?? surface;

  final Color? _onSurfaceVariant;

  /// A color that's clearly legible when drawn on [surfaceVariant].
  ///
  /// To ensure that an app is accessible, a contrast ratio between
  /// [surfaceVariant] and [onSurfaceVariant] of at least 4.5:1 is
  /// recommended. See
  /// <https://www.w3.org/TR/UNDERSTANDING-WCAG20/visual-audio-contrast-contrast.html>.
  Color get onSurfaceVariant => _onSurfaceVariant ?? onSurface;

  final Color? _outline;

  /// A utility color that creates boundaries and emphasis to improve usability.
  Color get outline => _outline ?? onBackground;

  final Color? _outlineVariant;

  /// A utility color that creates boundaries for decorative elements when a
  /// 3:1 contrast isn’t required, such as for dividers or decorative elements.
  Color get outlineVariant => _outlineVariant ?? onBackground;

  final Color? _shadow;

  /// A color use to paint the drop shadows of elevated components.
  Color get shadow => _shadow ?? const Color(0xff000000);

  final Color? _scrim;

  /// A color use to paint the scrim around of modal components.
  Color get scrim => _scrim ?? const Color(0xff000000);

  final Color? _inverseSurface;

  /// A surface color used for displaying the reverse of what’s seen in the
  /// surrounding UI, for example in a SnackBar to bring attention to
  /// an alert.
  Color get inverseSurface => _inverseSurface ?? onSurface;

  final Color? _onInverseSurface;

  /// A color that's clearly legible when drawn on [inverseSurface].
  ///
  /// To ensure that an app is accessible, a contrast ratio between
  /// [inverseSurface] and [onInverseSurface] of at least 4.5:1 is
  /// recommended. See
  /// <https://www.w3.org/TR/UNDERSTANDING-WCAG20/visual-audio-contrast-contrast.html>.
  Color get onInverseSurface => _onInverseSurface ?? surface;

  final Color? _inversePrimary;

  /// An accent color used for displaying a highlight color on [inverseSurface]
  /// backgrounds, like button text in a SnackBar.
  Color get inversePrimary => _inversePrimary ?? onPrimary;

  final Color? _surfaceTint;

  /// A color used as an overlay on a surface color to indicate a component's
  /// elevation.
  Color get surfaceTint => _surfaceTint ?? primary;

  final Color? _background;

  /// A color that typically appears behind scrollable content.
  @Deprecated(
    'Use surface instead. '
    'This feature was deprecated after v3.18.0-0.1.pre.',
  )
  Color get background => _background ?? surface;

  final Color? _onBackground;

  /// A color that's clearly legible when drawn on [background].
  ///
  /// To ensure that an app is accessible, a contrast ratio between
  /// [background] and [onBackground] of at least 4.5:1 is recommended. See
  /// <https://www.w3.org/TR/UNDERSTANDING-WCAG20/visual-audio-contrast-contrast.html>.
  @Deprecated(
    'Use onSurface instead. '
    'This feature was deprecated after v3.18.0-0.1.pre.',
  )
  Color get onBackground => _onBackground ?? onSurface;

  /// Creates a copy of this color scheme with the given fields
  /// replaced by the non-null parameter values.
  ColorScheme copyWith({
    Brightness? brightness,
    Color? primary,
    Color? onPrimary,
    Color? primaryContainer,
    Color? onPrimaryContainer,
    Color? primaryFixed,
    Color? primaryFixedDim,
    Color? onPrimaryFixed,
    Color? onPrimaryFixedVariant,
    Color? secondary,
    Color? onSecondary,
    Color? secondaryContainer,
    Color? onSecondaryContainer,
    Color? secondaryFixed,
    Color? secondaryFixedDim,
    Color? onSecondaryFixed,
    Color? onSecondaryFixedVariant,
    Color? tertiary,
    Color? onTertiary,
    Color? tertiaryContainer,
    Color? onTertiaryContainer,
    Color? tertiaryFixed,
    Color? tertiaryFixedDim,
    Color? onTertiaryFixed,
    Color? onTertiaryFixedVariant,
    Color? error,
    Color? onError,
    Color? errorContainer,
    Color? onErrorContainer,
    Color? surface,
    Color? onSurface,
    Color? surfaceDim,
    Color? surfaceBright,
    Color? surfaceContainerLowest,
    Color? surfaceContainerLow,
    Color? surfaceContainer,
    Color? surfaceContainerHigh,
    Color? surfaceContainerHighest,
    Color? onSurfaceVariant,
    Color? outline,
    Color? outlineVariant,
    Color? shadow,
    Color? scrim,
    Color? inverseSurface,
    Color? onInverseSurface,
    Color? inversePrimary,
    Color? surfaceTint,
    @Deprecated(
      'Use surface instead. '
      'This feature was deprecated after v3.18.0-0.1.pre.',
    )
    Color? background,
    @Deprecated(
      'Use onSurface instead. '
      'This feature was deprecated after v3.18.0-0.1.pre.',
    )
    Color? onBackground,
    @Deprecated(
      'Use surfaceContainerHighest instead. '
      'This feature was deprecated after v3.18.0-0.1.pre.',
    )
    Color? surfaceVariant,
  }) {
    return ColorScheme(
      brightness: brightness ?? this.brightness,
      primary: primary ?? this.primary,
      onPrimary: onPrimary ?? this.onPrimary,
      primaryContainer: primaryContainer ?? this.primaryContainer,
      onPrimaryContainer: onPrimaryContainer ?? this.onPrimaryContainer,
      primaryFixed: primaryFixed ?? this.primaryFixed,
      primaryFixedDim: primaryFixedDim ?? this.primaryFixedDim,
      onPrimaryFixed: onPrimaryFixed ?? this.onPrimaryFixed,
      onPrimaryFixedVariant: onPrimaryFixedVariant ?? this.onPrimaryFixedVariant,
      secondary: secondary ?? this.secondary,
      onSecondary: onSecondary ?? this.onSecondary,
      secondaryContainer: secondaryContainer ?? this.secondaryContainer,
      onSecondaryContainer: onSecondaryContainer ?? this.onSecondaryContainer,
      secondaryFixed: secondaryFixed ?? this.secondaryFixed,
      secondaryFixedDim: secondaryFixedDim ?? this.secondaryFixedDim,
      onSecondaryFixed: onSecondaryFixed ?? this.onSecondaryFixed,
      onSecondaryFixedVariant: onSecondaryFixedVariant ?? this.onSecondaryFixedVariant,
      tertiary: tertiary ?? this.tertiary,
      onTertiary: onTertiary ?? this.onTertiary,
      tertiaryContainer: tertiaryContainer ?? this.tertiaryContainer,
      onTertiaryContainer: onTertiaryContainer ?? this.onTertiaryContainer,
      tertiaryFixed: tertiaryFixed ?? this.tertiaryFixed,
      tertiaryFixedDim: tertiaryFixedDim ?? this.tertiaryFixedDim,
      onTertiaryFixed: onTertiaryFixed ?? this.onTertiaryFixed,
      onTertiaryFixedVariant: onTertiaryFixedVariant ?? this.onTertiaryFixedVariant,
      error: error ?? this.error,
      onError: onError ?? this.onError,
      errorContainer: errorContainer ?? this.errorContainer,
      onErrorContainer: onErrorContainer ?? this.onErrorContainer,
      surface: surface ?? this.surface,
      onSurface: onSurface ?? this.onSurface,
      surfaceDim: surfaceDim ?? this.surfaceDim,
      surfaceBright: surfaceBright ?? this.surfaceBright,
      surfaceContainerLowest: surfaceContainerLowest ?? this.surfaceContainerLowest,
      surfaceContainerLow: surfaceContainerLow ?? this.surfaceContainerLow,
      surfaceContainer: surfaceContainer ?? this.surfaceContainer,
      surfaceContainerHigh: surfaceContainerHigh ?? this.surfaceContainerHigh,
      surfaceContainerHighest: surfaceContainerHighest ?? this.surfaceContainerHighest,
      onSurfaceVariant: onSurfaceVariant ?? this.onSurfaceVariant,
      outline: outline ?? this.outline,
      outlineVariant: outlineVariant ?? this.outlineVariant,
      shadow: shadow ?? this.shadow,
      scrim: scrim ?? this.scrim,
      inverseSurface: inverseSurface ?? this.inverseSurface,
      onInverseSurface: onInverseSurface ?? this.onInverseSurface,
      inversePrimary: inversePrimary ?? this.inversePrimary,
      surfaceTint: surfaceTint ?? this.surfaceTint,
      // DEPRECATED (newest deprecations at the bottom)
      background: background ?? this.background,
      onBackground: onBackground ?? this.onBackground,
      surfaceVariant: surfaceVariant ?? this.surfaceVariant,
    );
  }

  /// Linearly interpolate between two [ColorScheme] objects.
  ///
  /// {@macro dart.ui.shadow.lerp}
  static ColorScheme lerp(ColorScheme a, ColorScheme b, double t) {
    if (identical(a, b)) {
      return a;
    }
    return ColorScheme(
      brightness: t < 0.5 ? a.brightness : b.brightness,
      primary: Color.lerp(a.primary, b.primary, t)!,
      onPrimary: Color.lerp(a.onPrimary, b.onPrimary, t)!,
      primaryContainer: Color.lerp(a.primaryContainer, b.primaryContainer, t),
      onPrimaryContainer: Color.lerp(a.onPrimaryContainer, b.onPrimaryContainer, t),
      primaryFixed: Color.lerp(a.primaryFixed, b.primaryFixed, t),
      primaryFixedDim: Color.lerp(a.primaryFixedDim, b.primaryFixedDim, t),
      onPrimaryFixed: Color.lerp(a.onPrimaryFixed, b.onPrimaryFixed, t),
      onPrimaryFixedVariant: Color.lerp(a.onPrimaryFixedVariant, b.onPrimaryFixedVariant, t),
      secondary: Color.lerp(a.secondary, b.secondary, t)!,
      onSecondary: Color.lerp(a.onSecondary, b.onSecondary, t)!,
      secondaryContainer: Color.lerp(a.secondaryContainer, b.secondaryContainer, t),
      onSecondaryContainer: Color.lerp(a.onSecondaryContainer, b.onSecondaryContainer, t),
      secondaryFixed: Color.lerp(a.secondaryFixed, b.secondaryFixed, t),
      secondaryFixedDim: Color.lerp(a.secondaryFixedDim, b.secondaryFixedDim, t),
      onSecondaryFixed: Color.lerp(a.onSecondaryFixed, b.onSecondaryFixed, t),
      onSecondaryFixedVariant: Color.lerp(a.onSecondaryFixedVariant, b.onSecondaryFixedVariant, t),
      tertiary: Color.lerp(a.tertiary, b.tertiary, t),
      onTertiary: Color.lerp(a.onTertiary, b.onTertiary, t),
      tertiaryContainer: Color.lerp(a.tertiaryContainer, b.tertiaryContainer, t),
      onTertiaryContainer: Color.lerp(a.onTertiaryContainer, b.onTertiaryContainer, t),
      tertiaryFixed: Color.lerp(a.tertiaryFixed, b.tertiaryFixed, t),
      tertiaryFixedDim: Color.lerp(a.tertiaryFixedDim, b.tertiaryFixedDim, t),
      onTertiaryFixed: Color.lerp(a.onTertiaryFixed, b.onTertiaryFixed, t),
      onTertiaryFixedVariant: Color.lerp(a.onTertiaryFixedVariant, b.onTertiaryFixedVariant, t),
      error: Color.lerp(a.error, b.error, t)!,
      onError: Color.lerp(a.onError, b.onError, t)!,
      errorContainer: Color.lerp(a.errorContainer, b.errorContainer, t),
      onErrorContainer: Color.lerp(a.onErrorContainer, b.onErrorContainer, t),
      surface: Color.lerp(a.surface, b.surface, t)!,
      onSurface: Color.lerp(a.onSurface, b.onSurface, t)!,
      surfaceDim: Color.lerp(a.surfaceDim, b.surfaceDim, t),
      surfaceBright: Color.lerp(a.surfaceBright, b.surfaceBright, t),
      surfaceContainerLowest: Color.lerp(a.surfaceContainerLowest, b.surfaceContainerLowest, t),
      surfaceContainerLow: Color.lerp(a.surfaceContainerLow, b.surfaceContainerLow, t),
      surfaceContainer: Color.lerp(a.surfaceContainer, b.surfaceContainer, t),
      surfaceContainerHigh: Color.lerp(a.surfaceContainerHigh, b.surfaceContainerHigh, t),
      surfaceContainerHighest: Color.lerp(a.surfaceContainerHighest, b.surfaceContainerHighest, t),
      onSurfaceVariant: Color.lerp(a.onSurfaceVariant, b.onSurfaceVariant, t),
      outline: Color.lerp(a.outline, b.outline, t),
      outlineVariant: Color.lerp(a.outlineVariant, b.outlineVariant, t),
      shadow: Color.lerp(a.shadow, b.shadow, t),
      scrim: Color.lerp(a.scrim, b.scrim, t),
      inverseSurface: Color.lerp(a.inverseSurface, b.inverseSurface, t),
      onInverseSurface: Color.lerp(a.onInverseSurface, b.onInverseSurface, t),
      inversePrimary: Color.lerp(a.inversePrimary, b.inversePrimary, t),
      surfaceTint: Color.lerp(a.surfaceTint, b.surfaceTint, t),
      // DEPRECATED (newest deprecations at the bottom)
      background: Color.lerp(a.background, b.background, t),
      onBackground: Color.lerp(a.onBackground, b.onBackground, t),
      surfaceVariant: Color.lerp(a.surfaceVariant, b.surfaceVariant, t),
    );
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other.runtimeType != runtimeType) {
      return false;
    }
    return other is ColorScheme &&
        other.brightness == brightness &&
        other.primary == primary &&
        other.onPrimary == onPrimary &&
        other.primaryContainer == primaryContainer &&
        other.onPrimaryContainer == onPrimaryContainer &&
        other.primaryFixed == primaryFixed &&
        other.primaryFixedDim == primaryFixedDim &&
        other.onPrimaryFixed == onPrimaryFixed &&
        other.onPrimaryFixedVariant == onPrimaryFixedVariant &&
        other.secondary == secondary &&
        other.onSecondary == onSecondary &&
        other.secondaryContainer == secondaryContainer &&
        other.onSecondaryContainer == onSecondaryContainer &&
        other.secondaryFixed == secondaryFixed &&
        other.secondaryFixedDim == secondaryFixedDim &&
        other.onSecondaryFixed == onSecondaryFixed &&
        other.onSecondaryFixedVariant == onSecondaryFixedVariant &&
        other.tertiary == tertiary &&
        other.onTertiary == onTertiary &&
        other.tertiaryContainer == tertiaryContainer &&
        other.onTertiaryContainer == onTertiaryContainer &&
        other.tertiaryFixed == tertiaryFixed &&
        other.tertiaryFixedDim == tertiaryFixedDim &&
        other.onTertiaryFixed == onTertiaryFixed &&
        other.onTertiaryFixedVariant == onTertiaryFixedVariant &&
        other.error == error &&
        other.onError == onError &&
        other.errorContainer == errorContainer &&
        other.onErrorContainer == onErrorContainer &&
        other.surface == surface &&
        other.onSurface == onSurface &&
        other.surfaceDim == surfaceDim &&
        other.surfaceBright == surfaceBright &&
        other.surfaceContainerLowest == surfaceContainerLowest &&
        other.surfaceContainerLow == surfaceContainerLow &&
        other.surfaceContainer == surfaceContainer &&
        other.surfaceContainerHigh == surfaceContainerHigh &&
        other.surfaceContainerHighest == surfaceContainerHighest &&
        other.onSurfaceVariant == onSurfaceVariant &&
        other.outline == outline &&
        other.outlineVariant == outlineVariant &&
        other.shadow == shadow &&
        other.scrim == scrim &&
        other.inverseSurface == inverseSurface &&
        other.onInverseSurface == onInverseSurface &&
        other.inversePrimary == inversePrimary &&
        other.surfaceTint == surfaceTint
        // DEPRECATED (newest deprecations at the bottom)
        &&
        other.background == background &&
        other.onBackground == onBackground &&
        other.surfaceVariant == surfaceVariant;
  }

  @override
  int get hashCode => Object.hash(
    brightness,
    primary,
    onPrimary,
    primaryContainer,
    onPrimaryContainer,
    secondary,
    onSecondary,
    secondaryContainer,
    onSecondaryContainer,
    tertiary,
    onTertiary,
    tertiaryContainer,
    onTertiaryContainer,
    error,
    onError,
    errorContainer,
    onErrorContainer,
    Object.hash(
      surface,
      onSurface,
      surfaceDim,
      surfaceBright,
      surfaceContainerLowest,
      surfaceContainerLow,
      surfaceContainer,
      surfaceContainerHigh,
      surfaceContainerHighest,
      onSurfaceVariant,
      outline,
      outlineVariant,
      shadow,
      scrim,
      inverseSurface,
      onInverseSurface,
      inversePrimary,
      surfaceTint,
      Object.hash(
        primaryFixed,
        primaryFixedDim,
        onPrimaryFixed,
        onPrimaryFixedVariant,
        secondaryFixed,
        secondaryFixedDim,
        onSecondaryFixed,
        onSecondaryFixedVariant,
        tertiaryFixed,
        tertiaryFixedDim,
        onTertiaryFixed,
        onTertiaryFixedVariant,
        // DEPRECATED (newest deprecations at the bottom)
        background,
        onBackground,
        surfaceVariant,
      ),
    ),
  );

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    const ColorScheme defaultScheme = ColorScheme.light();
    properties.add(
      DiagnosticsProperty<Brightness>(
        'brightness',
        brightness,
        defaultValue: defaultScheme.brightness,
      ),
    );
    properties.add(ColorProperty('primary', primary, defaultValue: defaultScheme.primary));
    properties.add(ColorProperty('onPrimary', onPrimary, defaultValue: defaultScheme.onPrimary));
    properties.add(
      ColorProperty(
        'primaryContainer',
        primaryContainer,
        defaultValue: defaultScheme.primaryContainer,
      ),
    );
    properties.add(
      ColorProperty(
        'onPrimaryContainer',
        onPrimaryContainer,
        defaultValue: defaultScheme.onPrimaryContainer,
      ),
    );
    properties.add(
      ColorProperty('primaryFixed', primaryFixed, defaultValue: defaultScheme.primaryFixed),
    );
    properties.add(
      ColorProperty(
        'primaryFixedDim',
        primaryFixedDim,
        defaultValue: defaultScheme.primaryFixedDim,
      ),
    );
    properties.add(
      ColorProperty('onPrimaryFixed', onPrimaryFixed, defaultValue: defaultScheme.onPrimaryFixed),
    );
    properties.add(
      ColorProperty(
        'onPrimaryFixedVariant',
        onPrimaryFixedVariant,
        defaultValue: defaultScheme.onPrimaryFixedVariant,
      ),
    );
    properties.add(ColorProperty('secondary', secondary, defaultValue: defaultScheme.secondary));
    properties.add(
      ColorProperty('onSecondary', onSecondary, defaultValue: defaultScheme.onSecondary),
    );
    properties.add(
      ColorProperty(
        'secondaryContainer',
        secondaryContainer,
        defaultValue: defaultScheme.secondaryContainer,
      ),
    );
    properties.add(
      ColorProperty(
        'onSecondaryContainer',
        onSecondaryContainer,
        defaultValue: defaultScheme.onSecondaryContainer,
      ),
    );
    properties.add(
      ColorProperty('secondaryFixed', secondaryFixed, defaultValue: defaultScheme.secondaryFixed),
    );
    properties.add(
      ColorProperty(
        'secondaryFixedDim',
        secondaryFixedDim,
        defaultValue: defaultScheme.secondaryFixedDim,
      ),
    );
    properties.add(
      ColorProperty(
        'onSecondaryFixed',
        onSecondaryFixed,
        defaultValue: defaultScheme.onSecondaryFixed,
      ),
    );
    properties.add(
      ColorProperty(
        'onSecondaryFixedVariant',
        onSecondaryFixedVariant,
        defaultValue: defaultScheme.onSecondaryFixedVariant,
      ),
    );
    properties.add(ColorProperty('tertiary', tertiary, defaultValue: defaultScheme.tertiary));
    properties.add(ColorProperty('onTertiary', onTertiary, defaultValue: defaultScheme.onTertiary));
    properties.add(
      ColorProperty(
        'tertiaryContainer',
        tertiaryContainer,
        defaultValue: defaultScheme.tertiaryContainer,
      ),
    );
    properties.add(
      ColorProperty(
        'onTertiaryContainer',
        onTertiaryContainer,
        defaultValue: defaultScheme.onTertiaryContainer,
      ),
    );
    properties.add(
      ColorProperty('tertiaryFixed', tertiaryFixed, defaultValue: defaultScheme.tertiaryFixed),
    );
    properties.add(
      ColorProperty(
        'tertiaryFixedDim',
        tertiaryFixedDim,
        defaultValue: defaultScheme.tertiaryFixedDim,
      ),
    );
    properties.add(
      ColorProperty(
        'onTertiaryFixed',
        onTertiaryFixed,
        defaultValue: defaultScheme.onTertiaryFixed,
      ),
    );
    properties.add(
      ColorProperty(
        'onTertiaryFixedVariant',
        onTertiaryFixedVariant,
        defaultValue: defaultScheme.onTertiaryFixedVariant,
      ),
    );
    properties.add(ColorProperty('error', error, defaultValue: defaultScheme.error));
    properties.add(ColorProperty('onError', onError, defaultValue: defaultScheme.onError));
    properties.add(
      ColorProperty('errorContainer', errorContainer, defaultValue: defaultScheme.errorContainer),
    );
    properties.add(
      ColorProperty(
        'onErrorContainer',
        onErrorContainer,
        defaultValue: defaultScheme.onErrorContainer,
      ),
    );
    properties.add(ColorProperty('surface', surface, defaultValue: defaultScheme.surface));
    properties.add(ColorProperty('onSurface', onSurface, defaultValue: defaultScheme.onSurface));
    properties.add(ColorProperty('surfaceDim', surfaceDim, defaultValue: defaultScheme.surfaceDim));
    properties.add(
      ColorProperty('surfaceBright', surfaceBright, defaultValue: defaultScheme.surfaceBright),
    );
    properties.add(
      ColorProperty(
        'surfaceContainerLowest',
        surfaceContainerLowest,
        defaultValue: defaultScheme.surfaceContainerLowest,
      ),
    );
    properties.add(
      ColorProperty(
        'surfaceContainerLow',
        surfaceContainerLow,
        defaultValue: defaultScheme.surfaceContainerLow,
      ),
    );
    properties.add(
      ColorProperty(
        'surfaceContainer',
        surfaceContainer,
        defaultValue: defaultScheme.surfaceContainer,
      ),
    );
    properties.add(
      ColorProperty(
        'surfaceContainerHigh',
        surfaceContainerHigh,
        defaultValue: defaultScheme.surfaceContainerHigh,
      ),
    );
    properties.add(
      ColorProperty(
        'surfaceContainerHighest',
        surfaceContainerHighest,
        defaultValue: defaultScheme.surfaceContainerHighest,
      ),
    );
    properties.add(
      ColorProperty(
        'onSurfaceVariant',
        onSurfaceVariant,
        defaultValue: defaultScheme.onSurfaceVariant,
      ),
    );
    properties.add(ColorProperty('outline', outline, defaultValue: defaultScheme.outline));
    properties.add(
      ColorProperty('outlineVariant', outlineVariant, defaultValue: defaultScheme.outlineVariant),
    );
    properties.add(ColorProperty('shadow', shadow, defaultValue: defaultScheme.shadow));
    properties.add(ColorProperty('scrim', scrim, defaultValue: defaultScheme.scrim));
    properties.add(
      ColorProperty('inverseSurface', inverseSurface, defaultValue: defaultScheme.inverseSurface),
    );
    properties.add(
      ColorProperty(
        'onInverseSurface',
        onInverseSurface,
        defaultValue: defaultScheme.onInverseSurface,
      ),
    );
    properties.add(
      ColorProperty('inversePrimary', inversePrimary, defaultValue: defaultScheme.inversePrimary),
    );
    properties.add(
      ColorProperty('surfaceTint', surfaceTint, defaultValue: defaultScheme.surfaceTint),
    );
    // DEPRECATED (newest deprecations at the bottom)
    properties.add(ColorProperty('background', background, defaultValue: defaultScheme.background));
    properties.add(
      ColorProperty('onBackground', onBackground, defaultValue: defaultScheme.onBackground),
    );
    properties.add(
      ColorProperty('surfaceVariant', surfaceVariant, defaultValue: defaultScheme.surfaceVariant),
    );
  }

  /// Generate a [ColorScheme] derived from the given `imageProvider`.
  ///
  /// Material Color Utilities extracts the dominant color from the
  /// supplied [ImageProvider]. Using this color, a [ColorScheme] is generated
  /// with harmonious colors that meet contrast requirements for accessibility.
  ///
  /// If any of the optional color parameters are non-null, they will be
  /// used in place of the generated colors for that field in the resulting
  /// [ColorScheme]. This allows apps to override specific colors for their
  /// needs.
  ///
  /// Given the nature of the algorithm, the most dominant color of the
  /// `imageProvider` may not wind up as one of the [ColorScheme] colors.
  ///
  /// The provided image will be scaled down to a maximum size of 112x112 pixels
  /// during color extraction.
  ///
  /// {@tool dartpad}
  /// This sample shows how to use [ColorScheme.fromImageProvider] to create
  /// content-based dynamic color schemes.
  ///
  /// ** See code in examples/api/lib/material/color_scheme/dynamic_content_color.0.dart **
  /// {@end-tool}
  ///
  /// See also:
  ///
  ///  * [M3 Guidelines: Dynamic color from content](https://m3.material.io/styles/color/dynamic-color/user-generated-color#8af550b9-a19e-4e9f-bb0a-7f611fed5d0f)
  ///  * <https://pub.dev/packages/dynamic_color>, a package to create
  ///    [ColorScheme]s based on a platform's implementation of dynamic color.
  ///  * <https://m3.material.io/styles/color/the-color-system/color-roles>, the
  ///    Material 3 Color system specification.
  ///  * <https://pub.dev/packages/material_color_utilities>, the package
  ///    used to algorithmically determine the dominant color and to generate
  ///    the [ColorScheme].
  static Future<ColorScheme> fromImageProvider({
    required ImageProvider provider,
    Brightness brightness = Brightness.light,
    DynamicSchemeVariant dynamicSchemeVariant = DynamicSchemeVariant.tonalSpot,
    double contrastLevel = 0.0,
    Color? primary,
    Color? onPrimary,
    Color? primaryContainer,
    Color? onPrimaryContainer,
    Color? primaryFixed,
    Color? primaryFixedDim,
    Color? onPrimaryFixed,
    Color? onPrimaryFixedVariant,
    Color? secondary,
    Color? onSecondary,
    Color? secondaryContainer,
    Color? onSecondaryContainer,
    Color? secondaryFixed,
    Color? secondaryFixedDim,
    Color? onSecondaryFixed,
    Color? onSecondaryFixedVariant,
    Color? tertiary,
    Color? onTertiary,
    Color? tertiaryContainer,
    Color? onTertiaryContainer,
    Color? tertiaryFixed,
    Color? tertiaryFixedDim,
    Color? onTertiaryFixed,
    Color? onTertiaryFixedVariant,
    Color? error,
    Color? onError,
    Color? errorContainer,
    Color? onErrorContainer,
    Color? outline,
    Color? outlineVariant,
    Color? surface,
    Color? onSurface,
    Color? surfaceDim,
    Color? surfaceBright,
    Color? surfaceContainerLowest,
    Color? surfaceContainerLow,
    Color? surfaceContainer,
    Color? surfaceContainerHigh,
    Color? surfaceContainerHighest,
    Color? onSurfaceVariant,
    Color? inverseSurface,
    Color? onInverseSurface,
    Color? inversePrimary,
    Color? shadow,
    Color? scrim,
    Color? surfaceTint,
    @Deprecated(
      'Use surface instead. '
      'This feature was deprecated after v3.18.0-0.1.pre.',
    )
    Color? background,
    @Deprecated(
      'Use onSurface instead. '
      'This feature was deprecated after v3.18.0-0.1.pre.',
    )
    Color? onBackground,
    @Deprecated(
      'Use surfaceContainerHighest instead. '
      'This feature was deprecated after v3.18.0-0.1.pre.',
    )
    Color? surfaceVariant,
  }) async {
    // Extract dominant colors from image.
    final QuantizerResult quantizerResult = await _extractColorsFromImageProvider(provider);
    final Map<int, int> colorToCount = quantizerResult.colorToCount.map(
      (int key, int value) => MapEntry<int, int>(_getArgbFromAbgr(key), value),
    );

    // Score colors for color scheme suitability.
    final List<int> scoredResults = Score.score(colorToCount, desired: 1);
    final ui.Color baseColor = Color(scoredResults.first);

    final DynamicScheme scheme = _buildDynamicScheme(
      brightness,
      baseColor,
      dynamicSchemeVariant,
      contrastLevel,
    );

    return ColorScheme(
      primary: primary ?? Color(MaterialDynamicColors.primary.getArgb(scheme)),
      onPrimary: onPrimary ?? Color(MaterialDynamicColors.onPrimary.getArgb(scheme)),
      primaryContainer:
          primaryContainer ?? Color(MaterialDynamicColors.primaryContainer.getArgb(scheme)),
      onPrimaryContainer:
          onPrimaryContainer ?? Color(MaterialDynamicColors.onPrimaryContainer.getArgb(scheme)),
      primaryFixed: primaryFixed ?? Color(MaterialDynamicColors.primaryFixed.getArgb(scheme)),
      primaryFixedDim:
          primaryFixedDim ?? Color(MaterialDynamicColors.primaryFixedDim.getArgb(scheme)),
      onPrimaryFixed: onPrimaryFixed ?? Color(MaterialDynamicColors.onPrimaryFixed.getArgb(scheme)),
      onPrimaryFixedVariant:
          onPrimaryFixedVariant ??
          Color(MaterialDynamicColors.onPrimaryFixedVariant.getArgb(scheme)),
      secondary: secondary ?? Color(MaterialDynamicColors.secondary.getArgb(scheme)),
      onSecondary: onSecondary ?? Color(MaterialDynamicColors.onSecondary.getArgb(scheme)),
      secondaryContainer:
          secondaryContainer ?? Color(MaterialDynamicColors.secondaryContainer.getArgb(scheme)),
      onSecondaryContainer:
          onSecondaryContainer ?? Color(MaterialDynamicColors.onSecondaryContainer.getArgb(scheme)),
      secondaryFixed: secondaryFixed ?? Color(MaterialDynamicColors.secondaryFixed.getArgb(scheme)),
      secondaryFixedDim:
          secondaryFixedDim ?? Color(MaterialDynamicColors.secondaryFixedDim.getArgb(scheme)),
      onSecondaryFixed:
          onSecondaryFixed ?? Color(MaterialDynamicColors.onSecondaryFixed.getArgb(scheme)),
      onSecondaryFixedVariant:
          onSecondaryFixedVariant ??
          Color(MaterialDynamicColors.onSecondaryFixedVariant.getArgb(scheme)),
      tertiary: tertiary ?? Color(MaterialDynamicColors.tertiary.getArgb(scheme)),
      onTertiary: onTertiary ?? Color(MaterialDynamicColors.onTertiary.getArgb(scheme)),
      tertiaryContainer:
          tertiaryContainer ?? Color(MaterialDynamicColors.tertiaryContainer.getArgb(scheme)),
      onTertiaryContainer:
          onTertiaryContainer ?? Color(MaterialDynamicColors.onTertiaryContainer.getArgb(scheme)),
      tertiaryFixed: tertiaryFixed ?? Color(MaterialDynamicColors.tertiaryFixed.getArgb(scheme)),
      tertiaryFixedDim:
          tertiaryFixedDim ?? Color(MaterialDynamicColors.tertiaryFixedDim.getArgb(scheme)),
      onTertiaryFixed:
          onTertiaryFixed ?? Color(MaterialDynamicColors.onTertiaryFixed.getArgb(scheme)),
      onTertiaryFixedVariant:
          onTertiaryFixedVariant ??
          Color(MaterialDynamicColors.onTertiaryFixedVariant.getArgb(scheme)),
      error: error ?? Color(MaterialDynamicColors.error.getArgb(scheme)),
      onError: onError ?? Color(MaterialDynamicColors.onError.getArgb(scheme)),
      errorContainer: errorContainer ?? Color(MaterialDynamicColors.errorContainer.getArgb(scheme)),
      onErrorContainer:
          onErrorContainer ?? Color(MaterialDynamicColors.onErrorContainer.getArgb(scheme)),
      outline: outline ?? Color(MaterialDynamicColors.outline.getArgb(scheme)),
      outlineVariant: outlineVariant ?? Color(MaterialDynamicColors.outlineVariant.getArgb(scheme)),
      surface: surface ?? Color(MaterialDynamicColors.surface.getArgb(scheme)),
      surfaceDim: surfaceDim ?? Color(MaterialDynamicColors.surfaceDim.getArgb(scheme)),
      surfaceBright: surfaceBright ?? Color(MaterialDynamicColors.surfaceBright.getArgb(scheme)),
      surfaceContainerLowest:
          surfaceContainerLowest ??
          Color(MaterialDynamicColors.surfaceContainerLowest.getArgb(scheme)),
      surfaceContainerLow:
          surfaceContainerLow ?? Color(MaterialDynamicColors.surfaceContainerLow.getArgb(scheme)),
      surfaceContainer:
          surfaceContainer ?? Color(MaterialDynamicColors.surfaceContainer.getArgb(scheme)),
      surfaceContainerHigh:
          surfaceContainerHigh ?? Color(MaterialDynamicColors.surfaceContainerHigh.getArgb(scheme)),
      surfaceContainerHighest:
          surfaceContainerHighest ??
          Color(MaterialDynamicColors.surfaceContainerHighest.getArgb(scheme)),
      onSurface: onSurface ?? Color(MaterialDynamicColors.onSurface.getArgb(scheme)),
      onSurfaceVariant:
          onSurfaceVariant ?? Color(MaterialDynamicColors.onSurfaceVariant.getArgb(scheme)),
      inverseSurface: inverseSurface ?? Color(MaterialDynamicColors.inverseSurface.getArgb(scheme)),
      onInverseSurface:
          onInverseSurface ?? Color(MaterialDynamicColors.inverseOnSurface.getArgb(scheme)),
      inversePrimary: inversePrimary ?? Color(MaterialDynamicColors.inversePrimary.getArgb(scheme)),
      shadow: shadow ?? Color(MaterialDynamicColors.shadow.getArgb(scheme)),
      scrim: scrim ?? Color(MaterialDynamicColors.scrim.getArgb(scheme)),
      surfaceTint: surfaceTint ?? Color(MaterialDynamicColors.primary.getArgb(scheme)),
      brightness: brightness,
      // DEPRECATED (newest deprecations at the bottom)
      background: background ?? Color(MaterialDynamicColors.background.getArgb(scheme)),
      onBackground: onBackground ?? Color(MaterialDynamicColors.onBackground.getArgb(scheme)),
      surfaceVariant: surfaceVariant ?? Color(MaterialDynamicColors.surfaceVariant.getArgb(scheme)),
    );
  }

  // ColorScheme.fromImageProvider() utilities.

  // Extracts bytes from an [ImageProvider] and returns a [QuantizerResult]
  // containing the most dominant colors.
  static Future<QuantizerResult> _extractColorsFromImageProvider(
    ImageProvider imageProvider,
  ) async {
    final ui.Image scaledImage = await _imageProviderToScaled(imageProvider);
    final ByteData? imageBytes = await scaledImage.toByteData();

    final QuantizerResult quantizerResult = await QuantizerCelebi().quantize(
      imageBytes!.buffer.asUint32List(),
      128,
      returnInputPixelToClusterPixel: true,
    );
    return quantizerResult;
  }

  // Scale image size down to reduce computation time of color extraction.
  static Future<ui.Image> _imageProviderToScaled(ImageProvider imageProvider) async {
    const double maxDimension = 112.0;
    final ImageStream stream = imageProvider.resolve(
      const ImageConfiguration(size: Size(maxDimension, maxDimension)),
    );
    final Completer<ui.Image> imageCompleter = Completer<ui.Image>();
    late ImageStreamListener listener;
    late ui.Image scaledImage;
    Timer? loadFailureTimeout;

    listener = ImageStreamListener(
      (ImageInfo info, bool sync) async {
        loadFailureTimeout?.cancel();
        stream.removeListener(listener);
        final ui.Image image = info.image;
        final int width = image.width;
        final int height = image.height;
        double paintWidth = width.toDouble();
        double paintHeight = height.toDouble();
        assert(width > 0 && height > 0);

        final bool rescale = width > maxDimension || height > maxDimension;
        if (rescale) {
          paintWidth = (width > height) ? maxDimension : (maxDimension / height) * width;
          paintHeight = (height > width) ? maxDimension : (maxDimension / width) * height;
        }
        final ui.PictureRecorder pictureRecorder = ui.PictureRecorder();
        final Canvas canvas = Canvas(pictureRecorder);
        paintImage(
          canvas: canvas,
          rect: Rect.fromLTRB(0, 0, paintWidth, paintHeight),
          image: image,
          filterQuality: FilterQuality.none,
        );

        final ui.Picture picture = pictureRecorder.endRecording();
        scaledImage = await picture.toImage(paintWidth.toInt(), paintHeight.toInt());
        imageCompleter.complete(info.image);
      },
      onError: (Object exception, StackTrace? stackTrace) {
        stream.removeListener(listener);
        throw Exception('Failed to render image: $exception');
      },
    );

    loadFailureTimeout = Timer(const Duration(seconds: 5), () {
      stream.removeListener(listener);
      imageCompleter.completeError(TimeoutException('Timeout occurred trying to load image'));
    });

    stream.addListener(listener);
    await imageCompleter.future;
    return scaledImage;
  }

  // Converts AABBGGRR color int to AARRGGBB format.
  static int _getArgbFromAbgr(int abgr) {
    const int exceptRMask = 0xFF00FFFF;
    const int onlyRMask = ~exceptRMask;
    const int exceptBMask = 0xFFFFFF00;
    const int onlyBMask = ~exceptBMask;
    final int r = (abgr & onlyRMask) >> 16;
    final int b = abgr & onlyBMask;
    return (abgr & exceptRMask & exceptBMask) | (b << 16) | r;
  }

  static DynamicScheme _buildDynamicScheme(
    Brightness brightness,
    Color seedColor,
    DynamicSchemeVariant schemeVariant,
    double contrastLevel,
  ) {
    assert(
      contrastLevel >= -1.0 && contrastLevel <= 1.0,
      'contrastLevel must be between -1.0 and 1.0 inclusive.',
    );
    final bool isDark = brightness == Brightness.dark;
    final Hct sourceColor = Hct.fromInt(seedColor.value);
    return switch (schemeVariant) {
      DynamicSchemeVariant.tonalSpot => SchemeTonalSpot(
        sourceColorHct: sourceColor,
        isDark: isDark,
        contrastLevel: contrastLevel,
      ),
      DynamicSchemeVariant.fidelity => SchemeFidelity(
        sourceColorHct: sourceColor,
        isDark: isDark,
        contrastLevel: contrastLevel,
      ),
      DynamicSchemeVariant.content => SchemeContent(
        sourceColorHct: sourceColor,
        isDark: isDark,
        contrastLevel: contrastLevel,
      ),
      DynamicSchemeVariant.monochrome => SchemeMonochrome(
        sourceColorHct: sourceColor,
        isDark: isDark,
        contrastLevel: contrastLevel,
      ),
      DynamicSchemeVariant.neutral => SchemeNeutral(
        sourceColorHct: sourceColor,
        isDark: isDark,
        contrastLevel: contrastLevel,
      ),
      DynamicSchemeVariant.vibrant => SchemeVibrant(
        sourceColorHct: sourceColor,
        isDark: isDark,
        contrastLevel: contrastLevel,
      ),
      DynamicSchemeVariant.expressive => SchemeExpressive(
        sourceColorHct: sourceColor,
        isDark: isDark,
        contrastLevel: contrastLevel,
      ),
      DynamicSchemeVariant.rainbow => SchemeRainbow(
        sourceColorHct: sourceColor,
        isDark: isDark,
        contrastLevel: contrastLevel,
      ),
      DynamicSchemeVariant.fruitSalad => SchemeFruitSalad(
        sourceColorHct: sourceColor,
        isDark: isDark,
        contrastLevel: contrastLevel,
      ),
    };
  }

  /// The [ThemeData.colorScheme] of the ambient [Theme].
  ///
  /// Equivalent to `Theme.of(context).colorScheme`.
  static ColorScheme of(BuildContext context) => Theme.of(context).colorScheme;
}


--- File Index 1: packages/flutter/lib/src/material/theme_data.dart ---
// Copyright 2014 The Flutter Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

/// @docImport 'package:flutter/material.dart';
library;

import 'dart:ui' show Color, lerpDouble;

import 'package:flutter/cupertino.dart';
import 'package:flutter/foundation.dart';

import 'action_buttons.dart';
import 'action_icons_theme.dart';
import 'app_bar_theme.dart';
import 'badge_theme.dart';
import 'banner_theme.dart';
import 'bottom_app_bar_theme.dart';
import 'bottom_navigation_bar_theme.dart';
import 'bottom_sheet_theme.dart';
import 'button_bar_theme.dart';
import 'button_theme.dart';
import 'card_theme.dart';
import 'checkbox_theme.dart';
import 'chip_theme.dart';
import 'color_scheme.dart';
import 'colors.dart';
import 'constants.dart';
import 'data_table_theme.dart';
import 'date_picker_theme.dart';
import 'dialog_theme.dart';
import 'divider_theme.dart';
import 'drawer_theme.dart';
import 'dropdown_menu_theme.dart';
import 'elevated_button_theme.dart';
import 'expansion_tile_theme.dart';
import 'filled_button_theme.dart';
import 'floating_action_button_theme.dart';
import 'icon_button_theme.dart';
import 'ink_ripple.dart';
import 'ink_sparkle.dart';
import 'ink_splash.dart';
import 'ink_well.dart' show InteractiveInkFeatureFactory;
import 'input_decorator.dart';
import 'list_tile.dart';
import 'list_tile_theme.dart';
import 'menu_bar_theme.dart';
import 'menu_button_theme.dart';
import 'menu_theme.dart';
import 'navigation_bar_theme.dart';
import 'navigation_drawer_theme.dart';
import 'navigation_rail_theme.dart';
import 'outlined_button_theme.dart';
import 'page_transitions_theme.dart';
import 'popup_menu_theme.dart';
import 'progress_indicator_theme.dart';
import 'radio_theme.dart';
import 'scrollbar_theme.dart';
import 'search_bar_theme.dart';
import 'search_view_theme.dart';
import 'segmented_button_theme.dart';
import 'slider_theme.dart';
import 'snack_bar_theme.dart';
import 'switch_theme.dart';
import 'tab_bar_theme.dart';
import 'text_button_theme.dart';
import 'text_selection_theme.dart';
import 'text_theme.dart';
import 'time_picker_theme.dart';
import 'toggle_buttons_theme.dart';
import 'tooltip_theme.dart';
import 'typography.dart';

export 'package:flutter/services.dart' show Brightness;

// Examples can assume:
// late BuildContext context;

/// Defines a customized theme for components with an `adaptive` factory constructor.
///
/// Currently, only [Switch.adaptive] supports this class.
class Adaptation<T> {
  /// Creates an [Adaptation].
  const Adaptation();

  /// The adaptation's type.
  Type get type => T;

  /// Typically, this is overridden to return an instance of a custom component
  /// ThemeData class, like [SwitchThemeData], instead of the defaultValue.
  ///
  /// Factory constructors that support adaptations - currently only
  /// [Switch.adaptive] - look for a type-specific adaptation in
  /// [ThemeData.adaptationMap] when computing their effective default component
  /// theme. If a matching adaptation is not found, the component may choose to
  /// use a default adaptation. For example, the [Switch.adaptive] component
  /// uses an empty [SwitchThemeData] if a matching adaptation is not found, for
  /// the sake of backwards compatibility.
  ///
  /// {@tool dartpad}
  /// This sample shows how to create and use subclasses of [Adaptation] that
  /// define adaptive [SwitchThemeData]s. The [adapt] method in this example is
  /// overridden to only customize cupertino-style switches, but it can also be
  /// used to customize any other platforms.
  ///
  /// ** See code in examples/api/lib/material/switch/switch.4.dart **
  /// {@end-tool}
  T adapt(ThemeData theme, T defaultValue) => defaultValue;
}

/// An interface that defines custom additions to a [ThemeData] object.
///
/// {@youtube 560 315 https://www.youtube.com/watch?v=8-szcYzFVao}
///
/// Typically used for custom colors. To use, subclass [ThemeExtension],
/// define a number of fields (e.g. [Color]s), and implement the [copyWith] and
/// [lerp] methods. The latter will ensure smooth transitions of properties when
/// switching themes.
///
/// {@tool dartpad}
/// This sample shows how to create and use a subclass of [ThemeExtension] that
/// defines two colors.
///
/// ** See code in examples/api/lib/material/theme/theme_extension.1.dart **
/// {@end-tool}
abstract class ThemeExtension<T extends ThemeExtension<T>> {
  /// Enable const constructor for subclasses.
  const ThemeExtension();

  /// The extension's type.
  Object get type => T;

  /// Creates a copy of this theme extension with the given fields
  /// replaced by the non-null parameter values.
  ThemeExtension<T> copyWith();

  /// Linearly interpolate with another [ThemeExtension] object.
  ///
  /// {@macro dart.ui.shadow.lerp}
  ThemeExtension<T> lerp(covariant ThemeExtension<T>? other, double t);
}

/// Configures the tap target and layout size of certain Material widgets.
///
/// Changing the value in [ThemeData.materialTapTargetSize] will affect the
/// accessibility experience.
///
/// Some of the impacted widgets include:
///
///   * [FloatingActionButton], only the mini tap target size is increased.
///   * [MaterialButton]
///   * [OutlinedButton]
///   * [TextButton]
///   * [ElevatedButton]
///   * [IconButton]
///   * The time picker widget ([showTimePicker])
///   * [SnackBar]
///   * [Chip]
///   * [RawChip]
///   * [InputChip]
///   * [ChoiceChip]
///   * [FilterChip]
///   * [ActionChip]
///   * [Radio]
///   * [Switch]
///   * [Checkbox]
enum MaterialTapTargetSize {
  /// Expands the minimum tap target size to 48px by 48px.
  ///
  /// This is the default value of [ThemeData.materialTapTargetSize] and the
  /// recommended size to conform to Android accessibility scanner
  /// recommendations.
  padded,

  /// Shrinks the tap target size to the minimum provided by the Material
  /// specification.
  shrinkWrap,
}

/// Defines the configuration of the overall visual [Theme] for a [MaterialApp]
/// or a widget subtree within the app.
///
/// The [MaterialApp] theme property can be used to configure the appearance
/// of the entire app. Widget subtrees within an app can override the app's
/// theme by including a [Theme] widget at the top of the subtree.
///
/// Widgets whose appearance should align with the overall theme can obtain the
/// current theme's configuration with [Theme.of]. Material components typically
/// depend exclusively on the [colorScheme] and [textTheme]. These properties
/// are guaranteed to have non-null values.
///
/// The static [Theme.of] method finds the [ThemeData] value specified for the
/// nearest [BuildContext] ancestor. This lookup is inexpensive, essentially
/// just a single HashMap access. It can sometimes be a little confusing
/// because [Theme.of] can not see a [Theme] widget that is defined in the
/// current build method's context. To overcome that, create a new custom widget
/// for the subtree that appears below the new [Theme], or insert a widget
/// that creates a new BuildContext, like [Builder].
///
/// {@tool dartpad}
/// This example demonstrates how a typical [MaterialApp] specifies
/// and uses a custom [Theme]. The theme's [ColorScheme] is based on a
/// single "seed" color and configures itself to match the platform's
/// current light or dark color configuration. The theme overrides the
/// default configuration of [FloatingActionButton] to show how to
/// customize the appearance a class of components.
///
/// ** See code in examples/api/lib/material/theme_data/theme_data.0.dart **
/// {@end-tool}
///
/// See <https://material.io/design/color/> for
/// more discussion on how to pick the right colors.

@immutable
class ThemeData with Diagnosticable {
  /// Create a [ThemeData] that's used to configure a [Theme].
  ///
  /// The [colorScheme] and [textTheme] are used by the Material components to
  /// compute default values for visual properties. The API documentation for
  /// each component widget explains exactly how the defaults are computed.
  ///
  /// When providing a [ColorScheme], apps can either provide one directly
  /// with the [colorScheme] parameter, or have one generated for them by
  /// using the [colorSchemeSeed] and [brightness] parameters. A generated
  /// color scheme will be based on the tones of [colorSchemeSeed] and all of
  /// its contrasting color will meet accessibility guidelines for readability.
  /// (See [ColorScheme.fromSeed] for more details.)
  ///
  /// If the app wants to customize a generated color scheme, it can use
  /// [ColorScheme.fromSeed] directly and then [ColorScheme.copyWith] on the
  /// result to override any colors that need to be replaced. The result of
  /// this can be used as the [colorScheme] directly.
  ///
  /// For historical reasons, instead of using a [colorSchemeSeed] or
  /// [colorScheme], you can provide either a [primaryColor] or [primarySwatch]
  /// to construct the [colorScheme], but the results will not be as complete
  /// as when using generation from a seed color.
  ///
  /// If [colorSchemeSeed] is non-null then [colorScheme], [primaryColor] and
  /// [primarySwatch] must all be null.
  ///
  /// The [textTheme] [TextStyle] colors are black if the color scheme's
  /// brightness is [Brightness.light], and white for [Brightness.dark].
  ///
  /// To override the appearance of specific components, provide
  /// a component theme parameter like [sliderTheme], [toggleButtonsTheme],
  /// or [bottomNavigationBarTheme].
  ///
  /// See also:
  ///
  ///  * [ThemeData.from], which creates a ThemeData from a [ColorScheme].
  ///  * [ThemeData.light], which creates the default light theme.
  ///  * [ThemeData.dark], which creates the default dark theme.
  ///  * [ColorScheme.fromSeed], which is used to create a [ColorScheme] from a seed color.
  factory ThemeData({
    // For the sanity of the reader, make sure these properties are in the same
    // order in every place that they are separated by section comments (e.g.
    // GENERAL CONFIGURATION). Each section except for deprecations should be
    // alphabetical by symbol name.

    // GENERAL CONFIGURATION
    Iterable<Adaptation<Object>>? adaptations,
    bool? applyElevationOverlayColor,
    NoDefaultCupertinoThemeData? cupertinoOverrideTheme,
    Iterable<ThemeExtension<dynamic>>? extensions,
    InputDecorationTheme? inputDecorationTheme,
    MaterialTapTargetSize? materialTapTargetSize,
    PageTransitionsTheme? pageTransitionsTheme,
    TargetPlatform? platform,
    ScrollbarThemeData? scrollbarTheme,
    InteractiveInkFeatureFactory? splashFactory,
    bool? useMaterial3,
    VisualDensity? visualDensity,
    // COLOR
    ColorScheme? colorScheme,
    Brightness? brightness,
    Color? colorSchemeSeed,
    // [colorScheme] is the preferred way to configure colors. The [Color] properties
    // listed below (as well as primarySwatch) will gradually be phased out, see
    // https://github.com/flutter/flutter/issues/91772.
    Color? canvasColor,
    Color? cardColor,
    Color? disabledColor,
    Color? dividerColor,
    Color? focusColor,
    Color? highlightColor,
    Color? hintColor,
    Color? hoverColor,
    Color? indicatorColor,
    Color? primaryColor,
    Color? primaryColorDark,
    Color? primaryColorLight,
    MaterialColor? primarySwatch,
    Color? scaffoldBackgroundColor,
    Color? secondaryHeaderColor,
    Color? shadowColor,
    Color? splashColor,
    Color? unselectedWidgetColor,
    // TYPOGRAPHY & ICONOGRAPHY
    String? fontFamily,
    List<String>? fontFamilyFallback,
    String? package,
    IconThemeData? iconTheme,
    IconThemeData? primaryIconTheme,
    TextTheme? primaryTextTheme,
    TextTheme? textTheme,
    Typography? typography,
    // COMPONENT THEMES
    ActionIconThemeData? actionIconTheme,
    AppBarTheme? appBarTheme,
    BadgeThemeData? badgeTheme,
    MaterialBannerThemeData? bannerTheme,
    BottomAppBarTheme? bottomAppBarTheme,
    BottomNavigationBarThemeData? bottomNavigationBarTheme,
    BottomSheetThemeData? bottomSheetTheme,
    ButtonThemeData? buttonTheme,
    // TODO(QuncCccccc): Change the parameter type to CardThemeData
    Object? cardTheme,
    CheckboxThemeData? checkboxTheme,
    ChipThemeData? chipTheme,
    DataTableThemeData? dataTableTheme,
    DatePickerThemeData? datePickerTheme,
    // TODO(QuncCccccc): Change the parameter type to DialogThemeData
    Object? dialogTheme,
    DividerThemeData? dividerTheme,
    DrawerThemeData? drawerTheme,
    DropdownMenuThemeData? dropdownMenuTheme,
    ElevatedButtonThemeData? elevatedButtonTheme,
    ExpansionTileThemeData? expansionTileTheme,
    FilledButtonThemeData? filledButtonTheme,
    FloatingActionButtonThemeData? floatingActionButtonTheme,
    IconButtonThemeData? iconButtonTheme,
    ListTileThemeData? listTileTheme,
    MenuBarThemeData? menuBarTheme,
    MenuButtonThemeData? menuButtonTheme,
    MenuThemeData? menuTheme,
    NavigationBarThemeData? navigationBarTheme,
    NavigationDrawerThemeData? navigationDrawerTheme,
    NavigationRailThemeData? navigationRailTheme,
    OutlinedButtonThemeData? outlinedButtonTheme,
    PopupMenuThemeData? popupMenuTheme,
    ProgressIndicatorThemeData? progressIndicatorTheme,
    RadioThemeData? radioTheme,
    SearchBarThemeData? searchBarTheme,
    SearchViewThemeData? searchViewTheme,
    SegmentedButtonThemeData? segmentedButtonTheme,
    SliderThemeData? sliderTheme,
    SnackBarThemeData? snackBarTheme,
    SwitchThemeData? switchTheme,
    // TODO(QuncCccccc): Change the parameter type to TabBarThemeData
    Object? tabBarTheme,
    TextButtonThemeData? textButtonTheme,
    TextSelectionThemeData? textSelectionTheme,
    TimePickerThemeData? timePickerTheme,
    ToggleButtonsThemeData? toggleButtonsTheme,
    TooltipThemeData? tooltipTheme,
    // DEPRECATED (newest deprecations at the bottom)
    @Deprecated(
      'Use OverflowBar instead. '
      'This feature was deprecated after v3.21.0-10.0.pre.',
    )
    ButtonBarThemeData? buttonBarTheme,
    @Deprecated(
      'Use DialogThemeData.backgroundColor instead. '
      'This feature was deprecated after v3.27.0-0.1.pre.',
    )
    Color? dialogBackgroundColor,
  }) {
    // GENERAL CONFIGURATION
    cupertinoOverrideTheme = cupertinoOverrideTheme?.noDefault();
    extensions ??= <ThemeExtension<dynamic>>[];
    adaptations ??= <Adaptation<Object>>[];
    inputDecorationTheme ??= const InputDecorationTheme();
    platform ??= defaultTargetPlatform;
    switch (platform) {
      case TargetPlatform.android:
      case TargetPlatform.fuchsia:
      case TargetPlatform.iOS:
        materialTapTargetSize ??= MaterialTapTargetSize.padded;
      case TargetPlatform.linux:
      case TargetPlatform.macOS:
      case TargetPlatform.windows:
        materialTapTargetSize ??= MaterialTapTargetSize.shrinkWrap;
    }
    pageTransitionsTheme ??= const PageTransitionsTheme();
    scrollbarTheme ??= const ScrollbarThemeData();
    visualDensity ??= VisualDensity.defaultDensityForPlatform(platform);
    useMaterial3 ??= true;
    final bool useInkSparkle = platform == TargetPlatform.android && !kIsWeb;
    splashFactory ??=
        useMaterial3
            ? useInkSparkle
                ? InkSparkle.splashFactory
                : InkRipple.splashFactory
            : InkSplash.splashFactory;

    // COLOR
    assert(
      colorScheme?.brightness == null ||
          brightness == null ||
          colorScheme!.brightness == brightness,
      'ThemeData.brightness does not match ColorScheme.brightness. '
      'Either override ColorScheme.brightness or ThemeData.brightness to '
      'match the other.',
    );
    assert(colorSchemeSeed == null || colorScheme == null);
    assert(colorSchemeSeed == null || primarySwatch == null);
    assert(colorSchemeSeed == null || primaryColor == null);
    final Brightness effectiveBrightness =
        brightness ?? colorScheme?.brightness ?? Brightness.light;
    final bool isDark = effectiveBrightness == Brightness.dark;
    if (colorSchemeSeed != null || useMaterial3) {
      if (colorSchemeSeed != null) {
        colorScheme = ColorScheme.fromSeed(
          seedColor: colorSchemeSeed,
          brightness: effectiveBrightness,
        );
      }
      colorScheme ??= isDark ? _colorSchemeDarkM3 : _colorSchemeLightM3;

      // For surfaces that use primary color in light themes and surface color in dark
      final Color primarySurfaceColor = isDark ? colorScheme.surface : colorScheme.primary;
      final Color onPrimarySurfaceColor = isDark ? colorScheme.onSurface : colorScheme.onPrimary;

      // Default some of the color settings to values from the color scheme
      primaryColor ??= primarySurfaceColor;
      canvasColor ??= colorScheme.surface;
      scaffoldBackgroundColor ??= colorScheme.surface;
      cardColor ??= colorScheme.surface;
      dividerColor ??= colorScheme.outline;
      dialogBackgroundColor ??= colorScheme.surface;
      indicatorColor ??= onPrimarySurfaceColor;
      applyElevationOverlayColor ??= brightness == Brightness.dark;
    }
    applyElevationOverlayColor ??= false;
    primarySwatch ??= Colors.blue;
    primaryColor ??= isDark ? Colors.grey[900]! : primarySwatch;
    final Brightness estimatedPrimaryColorBrightness = estimateBrightnessForColor(primaryColor);
    primaryColorLight ??= isDark ? Colors.grey[500]! : primarySwatch[100]!;
    primaryColorDark ??= isDark ? Colors.black : primarySwatch[700]!;
    final bool primaryIsDark = estimatedPrimaryColorBrightness == Brightness.dark;
    focusColor ??= isDark ? Colors.white.withOpacity(0.12) : Colors.black.withOpacity(0.12);
    hoverColor ??= isDark ? Colors.white.withOpacity(0.04) : Colors.black.withOpacity(0.04);
    shadowColor ??= Colors.black;
    canvasColor ??= isDark ? Colors.grey[850]! : Colors.grey[50]!;
    scaffoldBackgroundColor ??= canvasColor;
    cardColor ??= isDark ? Colors.grey[800]! : Colors.white;
    dividerColor ??= isDark ? const Color(0x1FFFFFFF) : const Color(0x1F000000);
    // Create a ColorScheme that is backwards compatible as possible
    // with the existing default ThemeData color values.
    colorScheme ??= ColorScheme.fromSwatch(
      primarySwatch: primarySwatch,
      accentColor: isDark ? Colors.tealAccent[200]! : primarySwatch[500]!,
      cardColor: cardColor,
      backgroundColor: isDark ? Colors.grey[700]! : primarySwatch[200]!,
      errorColor: Colors.red[700],
      brightness: effectiveBrightness,
    );
    unselectedWidgetColor ??= isDark ? Colors.white70 : Colors.black54;
    // Spec doesn't specify a dark theme secondaryHeaderColor, this is a guess.
    secondaryHeaderColor ??= isDark ? Colors.grey[700]! : primarySwatch[50]!;
    indicatorColor ??= colorScheme.secondary == primaryColor ? Colors.white : colorScheme.secondary;
    hintColor ??= isDark ? Colors.white60 : Colors.black.withOpacity(0.6);
    // The default [buttonTheme] is here because it doesn't use the defaults for
    // [disabledColor], [highlightColor], and [splashColor].
    buttonTheme ??= ButtonThemeData(
      colorScheme: colorScheme,
      buttonColor: isDark ? primarySwatch[600]! : Colors.grey[300]!,
      disabledColor: disabledColor,
      focusColor: focusColor,
      hoverColor: hoverColor,
      highlightColor: highlightColor,
      splashColor: splashColor,
      materialTapTargetSize: materialTapTargetSize,
    );
    disabledColor ??= isDark ? Colors.white38 : Colors.black38;
    highlightColor ??= isDark ? const Color(0x40CCCCCC) : const Color(0x66BCBCBC);
    splashColor ??= isDark ? const Color(0x40CCCCCC) : const Color(0x66C8C8C8);

    // TYPOGRAPHY & ICONOGRAPHY
    typography ??=
        useMaterial3
            ? Typography.material2021(platform: platform, colorScheme: colorScheme)
            : Typography.material2014(platform: platform);
    TextTheme defaultTextTheme = isDark ? typography.white : typography.black;
    TextTheme defaultPrimaryTextTheme = primaryIsDark ? typography.white : typography.black;
    if (fontFamily != null) {
      defaultTextTheme = defaultTextTheme.apply(fontFamily: fontFamily);
      defaultPrimaryTextTheme = defaultPrimaryTextTheme.apply(fontFamily: fontFamily);
    }
    if (fontFamilyFallback != null) {
      defaultTextTheme = defaultTextTheme.apply(fontFamilyFallback: fontFamilyFallback);
      defaultPrimaryTextTheme = defaultPrimaryTextTheme.apply(
        fontFamilyFallback: fontFamilyFallback,
      );
    }
    if (package != null) {
      defaultTextTheme = defaultTextTheme.apply(package: package);
      defaultPrimaryTextTheme = defaultPrimaryTextTheme.apply(package: package);
    }
    textTheme = defaultTextTheme.merge(textTheme);
    primaryTextTheme = defaultPrimaryTextTheme.merge(primaryTextTheme);
    iconTheme ??=
        isDark
            ? IconThemeData(color: kDefaultIconLightColor)
            : IconThemeData(color: kDefaultIconDarkColor);
    primaryIconTheme ??=
        primaryIsDark
            ? const IconThemeData(color: Colors.white)
            : const IconThemeData(color: Colors.black);

    // COMPONENT THEMES
    appBarTheme ??= const AppBarTheme();
    badgeTheme ??= const BadgeThemeData();
    bannerTheme ??= const MaterialBannerThemeData();
    bottomAppBarTheme ??= const BottomAppBarTheme();
    bottomNavigationBarTheme ??= const BottomNavigationBarThemeData();
    bottomSheetTheme ??= const BottomSheetThemeData();
    // TODO(QuncCccccc): Clean it up once the type of `cardTheme` is changed to `CardThemeData`
    if (cardTheme != null) {
      if (cardTheme is CardTheme) {
        cardTheme = cardTheme.data;
      } else if (cardTheme is! CardThemeData) {
        throw ArgumentError('cardTheme must be either a CardThemeData or a CardTheme');
      }
    }
    cardTheme ??= const CardThemeData();
    checkboxTheme ??= const CheckboxThemeData();
    chipTheme ??= const ChipThemeData();
    dataTableTheme ??= const DataTableThemeData();
    datePickerTheme ??= const DatePickerThemeData();
    // TODO(QuncCccccc): Clean this up once the type of `dialogTheme` is changed to `DialogThemeData`
    if (dialogTheme != null) {
      if (dialogTheme is DialogTheme) {
        dialogTheme = dialogTheme.data;
      } else if (dialogTheme is! DialogThemeData) {
        throw ArgumentError('dialogTheme must be either a DialogThemeData or a DialogTheme');
      }
    }
    dialogTheme ??= const DialogThemeData();
    dividerTheme ??= const DividerThemeData();
    drawerTheme ??= const DrawerThemeData();
    dropdownMenuTheme ??= const DropdownMenuThemeData();
    elevatedButtonTheme ??= const ElevatedButtonThemeData();
    expansionTileTheme ??= const ExpansionTileThemeData();
    filledButtonTheme ??= const FilledButtonThemeData();
    floatingActionButtonTheme ??= const FloatingActionButtonThemeData();
    iconButtonTheme ??= const IconButtonThemeData();
    listTileTheme ??= const ListTileThemeData();
    menuBarTheme ??= const MenuBarThemeData();
    menuButtonTheme ??= const MenuButtonThemeData();
    menuTheme ??= const MenuThemeData();
    navigationBarTheme ??= const NavigationBarThemeData();
    navigationDrawerTheme ??= const NavigationDrawerThemeData();
    navigationRailTheme ??= const NavigationRailThemeData();
    outlinedButtonTheme ??= const OutlinedButtonThemeData();
    popupMenuTheme ??= const PopupMenuThemeData();
    progressIndicatorTheme ??= const ProgressIndicatorThemeData();
    radioTheme ??= const RadioThemeData();
    searchBarTheme ??= const SearchBarThemeData();
    searchViewTheme ??= const SearchViewThemeData();
    segmentedButtonTheme ??= const SegmentedButtonThemeData();
    sliderTheme ??= const SliderThemeData();
    snackBarTheme ??= const SnackBarThemeData();
    switchTheme ??= const SwitchThemeData();
    // TODO(QuncCccccc): Clean this up once the type of `tabBarTheme` is changed to `TabBarThemeData`
    if (tabBarTheme != null) {
      if (tabBarTheme is TabBarTheme) {
        tabBarTheme = tabBarTheme.data;
      } else if (tabBarTheme is! TabBarThemeData) {
        throw ArgumentError('tabBarTheme must be either a TabBarThemeData or a TabBarTheme');
      }
    }
    tabBarTheme ??= const TabBarThemeData();
    textButtonTheme ??= const TextButtonThemeData();
    textSelectionTheme ??= const TextSelectionThemeData();
    timePickerTheme ??= const TimePickerThemeData();
    toggleButtonsTheme ??= const ToggleButtonsThemeData();
    tooltipTheme ??= const TooltipThemeData();
    // DEPRECATED (newest deprecations at the bottom)
    buttonBarTheme ??= const ButtonBarThemeData();
    dialogBackgroundColor ??= isDark ? Colors.grey[800]! : Colors.white;
    return ThemeData.raw(
      // For the sanity of the reader, make sure these properties are in the same
      // order in every place that they are separated by section comments (e.g.
      // GENERAL CONFIGURATION). Each section except for deprecations should be
      // alphabetical by symbol name.

      // GENERAL CONFIGURATION
      adaptationMap: _createAdaptationMap(adaptations),
      applyElevationOverlayColor: applyElevationOverlayColor,
      cupertinoOverrideTheme: cupertinoOverrideTheme,
      extensions: _themeExtensionIterableToMap(extensions),
      inputDecorationTheme: inputDecorationTheme,
      materialTapTargetSize: materialTapTargetSize,
      pageTransitionsTheme: pageTransitionsTheme,
      platform: platform,
      scrollbarTheme: scrollbarTheme,
      splashFactory: splashFactory,
      useMaterial3: useMaterial3,
      visualDensity: visualDensity,
      // COLOR
      canvasColor: canvasColor,
      cardColor: cardColor,
      colorScheme: colorScheme,
      disabledColor: disabledColor,
      dividerColor: dividerColor,
      focusColor: focusColor,
      highlightColor: highlightColor,
      hintColor: hintColor,
      hoverColor: hoverColor,
      indicatorColor: indicatorColor,
      primaryColor: primaryColor,
      primaryColorDark: primaryColorDark,
      primaryColorLight: primaryColorLight,
      scaffoldBackgroundColor: scaffoldBackgroundColor,
      secondaryHeaderColor: secondaryHeaderColor,
      shadowColor: shadowColor,
      splashColor: splashColor,
      unselectedWidgetColor: unselectedWidgetColor,
      // TYPOGRAPHY & ICONOGRAPHY
      iconTheme: iconTheme,
      primaryTextTheme: primaryTextTheme,
      textTheme: textTheme,
      typography: typography,
      primaryIconTheme: primaryIconTheme,
      // COMPONENT THEMES
      actionIconTheme: actionIconTheme,
      appBarTheme: appBarTheme,
      badgeTheme: badgeTheme,
      bannerTheme: bannerTheme,
      bottomAppBarTheme: bottomAppBarTheme,
      bottomNavigationBarTheme: bottomNavigationBarTheme,
      bottomSheetTheme: bottomSheetTheme,
      buttonTheme: buttonTheme,
      cardTheme: cardTheme as CardThemeData,
      checkboxTheme: checkboxTheme,
      chipTheme: chipTheme,
      dataTableTheme: dataTableTheme,
      datePickerTheme: datePickerTheme,
      dialogTheme: dialogTheme as DialogThemeData,
      dividerTheme: dividerTheme,
      drawerTheme: drawerTheme,
      dropdownMenuTheme: dropdownMenuTheme,
      elevatedButtonTheme: elevatedButtonTheme,
      expansionTileTheme: expansionTileTheme,
      filledButtonTheme: filledButtonTheme,
      floatingActionButtonTheme: floatingActionButtonTheme,
      iconButtonTheme: iconButtonTheme,
      listTileTheme: listTileTheme,
      menuBarTheme: menuBarTheme,
      menuButtonTheme: menuButtonTheme,
      menuTheme: menuTheme,
      navigationBarTheme: navigationBarTheme,
      navigationDrawerTheme: navigationDrawerTheme,
      navigationRailTheme: navigationRailTheme,
      outlinedButtonTheme: outlinedButtonTheme,
      popupMenuTheme: popupMenuTheme,
      progressIndicatorTheme: progressIndicatorTheme,
      radioTheme: radioTheme,
      searchBarTheme: searchBarTheme,
      searchViewTheme: searchViewTheme,
      segmentedButtonTheme: segmentedButtonTheme,
      sliderTheme: sliderTheme,
      snackBarTheme: snackBarTheme,
      switchTheme: switchTheme,
      tabBarTheme: tabBarTheme as TabBarThemeData,
      textButtonTheme: textButtonTheme,
      textSelectionTheme: textSelectionTheme,
      timePickerTheme: timePickerTheme,
      toggleButtonsTheme: toggleButtonsTheme,
      tooltipTheme: tooltipTheme,
      // DEPRECATED (newest deprecations at the bottom)
      buttonBarTheme: buttonBarTheme,
      dialogBackgroundColor: dialogBackgroundColor,
    );
  }

  /// Create a [ThemeData] given a set of exact values. Most values must be
  /// specified. They all must also be non-null except for
  /// [cupertinoOverrideTheme], and deprecated members.
  ///
  /// This will rarely be used directly. It is used by [lerp] to
  /// create intermediate themes based on two themes created with the
  /// [ThemeData] constructor.
  const ThemeData.raw({
    // For the sanity of the reader, make sure these properties are in the same
    // order in every place that they are separated by section comments (e.g.
    // GENERAL CONFIGURATION). Each section except for deprecations should be
    // alphabetical by symbol name.

    // GENERAL CONFIGURATION
    required this.adaptationMap,
    required this.applyElevationOverlayColor,
    required this.cupertinoOverrideTheme,
    required this.extensions,
    required this.inputDecorationTheme,
    required this.materialTapTargetSize,
    required this.pageTransitionsTheme,
    required this.platform,
    required this.scrollbarTheme,
    required this.splashFactory,
    required this.useMaterial3,
    required this.visualDensity,
    // COLOR
    required this.colorScheme,
    // [colorScheme] is the preferred way to configure colors. The [Color] properties
    // listed below (as well as primarySwatch) will gradually be phased out, see
    // https://github.com/flutter/flutter/issues/91772.
    required this.canvasColor,
    required this.cardColor,
    required this.disabledColor,
    required this.dividerColor,
    required this.focusColor,
    required this.highlightColor,
    required this.hintColor,
    required this.hoverColor,
    required this.indicatorColor,
    required this.primaryColor,
    required this.primaryColorDark,
    required this.primaryColorLight,
    required this.scaffoldBackgroundColor,
    required this.secondaryHeaderColor,
    required this.shadowColor,
    required this.splashColor,
    required this.unselectedWidgetColor,
    // TYPOGRAPHY & ICONOGRAPHY
    required this.iconTheme,
    required this.primaryIconTheme,
    required this.primaryTextTheme,
    required this.textTheme,
    required this.typography,
    // COMPONENT THEMES
    required this.actionIconTheme,
    required this.appBarTheme,
    required this.badgeTheme,
    required this.bannerTheme,
    required this.bottomAppBarTheme,
    required this.bottomNavigationBarTheme,
    required this.bottomSheetTheme,
    required this.buttonTheme,
    required this.cardTheme,
    required this.checkboxTheme,
    required this.chipTheme,
    required this.dataTableTheme,
    required this.datePickerTheme,
    required this.dialogTheme,
    required this.dividerTheme,
    required this.drawerTheme,
    required this.dropdownMenuTheme,
    required this.elevatedButtonTheme,
    required this.expansionTileTheme,
    required this.filledButtonTheme,
    required this.floatingActionButtonTheme,
    required this.iconButtonTheme,
    required this.listTileTheme,
    required this.menuBarTheme,
    required this.menuButtonTheme,
    required this.menuTheme,
    required this.navigationBarTheme,
    required this.navigationDrawerTheme,
    required this.navigationRailTheme,
    required this.outlinedButtonTheme,
    required this.popupMenuTheme,
    required this.progressIndicatorTheme,
    required this.radioTheme,
    required this.searchBarTheme,
    required this.searchViewTheme,
    required this.segmentedButtonTheme,
    required this.sliderTheme,
    required this.snackBarTheme,
    required this.switchTheme,
    required this.tabBarTheme,
    required this.textButtonTheme,
    required this.textSelectionTheme,
    required this.timePickerTheme,
    required this.toggleButtonsTheme,
    required this.tooltipTheme,
    // DEPRECATED (newest deprecations at the bottom)
    @Deprecated(
      'Use OverflowBar instead. '
      'This feature was deprecated after v3.21.0-10.0.pre.',
    )
    ButtonBarThemeData? buttonBarTheme,
    @Deprecated(
      'Use DialogThemeData.backgroundColor instead. '
      'This feature was deprecated after v3.27.0-0.1.pre.',
    )
    required this.dialogBackgroundColor,
  }) : // DEPRECATED (newest deprecations at the bottom)
       // should not be `required`, use getter pattern to avoid breakages.
       _buttonBarTheme = buttonBarTheme,
       assert(buttonBarTheme != null);

  /// Create a [ThemeData] based on the colors in the given [colorScheme] and
  /// text styles of the optional [textTheme].
  ///
  /// If [colorScheme].brightness is [Brightness.dark] then
  /// [ThemeData.applyElevationOverlayColor] will be set to true to support
  /// the Material dark theme method for indicating elevation by applying
  /// a semi-transparent onSurface color on top of the surface color.
  ///
  /// This is the recommended method to theme your application. As we move
  /// forward we will be converting all the widget implementations to only use
  /// colors or colors derived from those in [ColorScheme].
  ///
  /// {@tool snippet}
  /// This example will set up an application to use the baseline Material
  /// Design light and dark themes.
  ///
  /// ```dart
  /// MaterialApp(
  ///   theme: ThemeData.from(colorScheme: const ColorScheme.light()),
  ///   darkTheme: ThemeData.from(colorScheme: const ColorScheme.dark()),
  /// )
  /// ```
  /// {@end-tool}
  ///
  /// See <https://material.io/design/color/> for
  /// more discussion on how to pick the right colors.
  factory ThemeData.from({
    required ColorScheme colorScheme,
    TextTheme? textTheme,
    bool? useMaterial3,
  }) {
    final bool isDark = colorScheme.brightness == Brightness.dark;

    // For surfaces that use primary color in light themes and surface color in dark
    final Color primarySurfaceColor = isDark ? colorScheme.surface : colorScheme.primary;
    final Color onPrimarySurfaceColor = isDark ? colorScheme.onSurface : colorScheme.onPrimary;

    return ThemeData(
      colorScheme: colorScheme,
      brightness: colorScheme.brightness,
      primaryColor: primarySurfaceColor,
      canvasColor: colorScheme.surface,
      scaffoldBackgroundColor: colorScheme.surface,
      cardColor: colorScheme.surface,
      dividerColor: colorScheme.onSurface.withOpacity(0.12),
      dialogBackgroundColor: colorScheme.surface,
      indicatorColor: onPrimarySurfaceColor,
      textTheme: textTheme,
      applyElevationOverlayColor: isDark,
      useMaterial3: useMaterial3,
    );
  }

  /// A default light theme.
  ///
  /// This theme does not contain text geometry. Instead, it is expected that
  /// this theme is localized using text geometry using [ThemeData.localize].
  factory ThemeData.light({bool? useMaterial3}) =>
      ThemeData(brightness: Brightness.light, useMaterial3: useMaterial3);

  /// A default dark theme.
  ///
  /// This theme does not contain text geometry. Instead, it is expected that
  /// this theme is localized using text geometry using [ThemeData.localize].
  factory ThemeData.dark({bool? useMaterial3}) =>
      ThemeData(brightness: Brightness.dark, useMaterial3: useMaterial3);

  /// The default color theme. Same as [ThemeData.light].
  ///
  /// This is used by [Theme.of] when no theme has been specified.
  ///
  /// This theme does not contain text geometry. Instead, it is expected that
  /// this theme is localized using text geometry using [ThemeData.localize].
  ///
  /// Most applications would use [Theme.of], which provides correct localized
  /// text geometry.
  factory ThemeData.fallback({bool? useMaterial3}) => ThemeData.light(useMaterial3: useMaterial3);

  /// Used to obtain a particular [Adaptation] from [adaptationMap].
  ///
  /// To get an adaptation, use `Theme.of(context).getAdaptation<MyAdaptation>()`.
  Adaptation<T>? getAdaptation<T>() => adaptationMap[T] as Adaptation<T>?;

  static Map<Type, Adaptation<Object>> _createAdaptationMap(
    Iterable<Adaptation<Object>> adaptations,
  ) {
    final Map<Type, Adaptation<Object>> adaptationMap = <Type, Adaptation<Object>>{
      for (final Adaptation<Object> adaptation in adaptations) adaptation.type: adaptation,
    };
    return adaptationMap;
  }

  /// The overall theme brightness.
  ///
  /// The default [TextStyle] color for the [textTheme] is black if the
  /// theme is constructed with [Brightness.light] and white if the
  /// theme is constructed with [Brightness.dark].
  Brightness get brightness => colorScheme.brightness;

  // For the sanity of the reader, make sure these properties are in the same
  // order in every place that they are separated by section comments (e.g.
  // GENERAL CONFIGURATION). Each section except for deprecations should be
  // alphabetical by symbol name.

  // GENERAL CONFIGURATION

  /// Apply a semi-transparent overlay color on Material surfaces to indicate
  /// elevation for dark themes.
  ///
  /// If [useMaterial3] is true, then this flag is ignored as there is a new
  /// [Material.surfaceTintColor] used to create an overlay for Material 3.
  /// This flag is meant only for the Material 2 elevation overlay for dark
  /// themes.
  ///
  /// Material drop shadows can be difficult to see in a dark theme, so the
  /// elevation of a surface should be portrayed with an "overlay" in addition
  /// to the shadow. As the elevation of the component increases, the
  /// overlay increases in opacity. [applyElevationOverlayColor] turns the
  /// application of this overlay on or off for dark themes.
  ///
  /// If true and [brightness] is [Brightness.dark], a
  /// semi-transparent version of [ColorScheme.onSurface] will be
  /// applied on top of [Material] widgets that have a [ColorScheme.surface]
  /// color. The level of transparency is based on [Material.elevation] as
  /// per the Material Dark theme specification.
  ///
  /// If false the surface color will be used unmodified.
  ///
  /// Defaults to false in order to maintain backwards compatibility with
  /// apps that were built before the Material Dark theme specification
  /// was published. New apps should set this to true for any themes
  /// where [brightness] is [Brightness.dark].
  ///
  /// See also:
  ///
  ///  * [Material.elevation], which effects the level of transparency of the
  ///    overlay color.
  ///  * [ElevationOverlay.applyOverlay], which is used by [Material] to apply
  ///    the overlay color to its surface color.
  ///  * <https://material.io/design/color/dark-theme.html>, which specifies how
  ///    the overlay should be applied.
  final bool applyElevationOverlayColor;

  /// Components of the [CupertinoThemeData] to override from the Material
  /// [ThemeData] adaptation.
  ///
  /// By default, [cupertinoOverrideTheme] is null and Cupertino widgets
  /// descendant to the Material [Theme] will adhere to a [CupertinoTheme]
  /// derived from the Material [ThemeData]. e.g. [ThemeData]'s [ColorScheme]
  /// will also inform the [CupertinoThemeData]'s `primaryColor` etc.
  ///
  /// This cascading effect for individual attributes of the [CupertinoThemeData]
  /// can be overridden using attributes of this [cupertinoOverrideTheme].
  final NoDefaultCupertinoThemeData? cupertinoOverrideTheme;

  /// Arbitrary additions to this theme.
  ///
  /// To define extensions, pass an [Iterable] containing one or more [ThemeExtension]
  /// subclasses to [ThemeData.new] or [copyWith].
  ///
  /// To obtain an extension, use [extension].
  ///
  /// {@tool dartpad}
  /// This sample shows how to create and use a subclass of [ThemeExtension] that
  /// defines two colors.
  ///
  /// ** See code in examples/api/lib/material/theme/theme_extension.1.dart **
  /// {@end-tool}
  ///
  /// See also:
  ///
  /// * [extension], a convenience function for obtaining a specific extension.
  final Map<Object, ThemeExtension<dynamic>> extensions;

  /// Used to obtain a particular [ThemeExtension] from [extensions].
  ///
  /// Obtain with `Theme.of(context).extension<MyThemeExtension>()`.
  ///
  /// See [extensions] for an interactive example.
  T? extension<T>() => extensions[T] as T?;

  /// A map which contains the adaptations for the theme. The entry's key is the
  /// type of the adaptation; the value is the adaptation itself.
  ///
  /// To obtain an adaptation, use [getAdaptation].
  final Map<Type, Adaptation<Object>> adaptationMap;

  /// The default [InputDecoration] values for [InputDecorator], [TextField],
  /// and [TextFormField] are based on this theme.
  ///
  /// See [InputDecoration.applyDefaults].
  final InputDecorationTheme inputDecorationTheme;

  /// Configures the hit test size of certain Material widgets.
  ///
  /// Defaults to a [platform]-appropriate size: [MaterialTapTargetSize.padded]
  /// on mobile platforms, [MaterialTapTargetSize.shrinkWrap] on desktop
  /// platforms.
  final MaterialTapTargetSize materialTapTargetSize;

  /// Default [MaterialPageRoute] transitions per [TargetPlatform].
  ///
  /// [MaterialPageRoute.buildTransitions] delegates to a [platform] specific
  /// [PageTransitionsBuilder]. If a matching builder is not found, a builder
  /// whose platform is null is used.
  final PageTransitionsTheme pageTransitionsTheme;

  /// The platform the material widgets should adapt to target.
  ///
  /// Defaults to the current platform, as exposed by [defaultTargetPlatform].
  /// This should be used in order to style UI elements according to platform
  /// conventions.
  ///
  /// Widgets from the material library should use this getter (via [Theme.of])
  /// to determine the current platform for the purpose of emulating the
  /// platform behavior (e.g. scrolling or haptic effects). Widgets and render
  /// objects at lower layers that try to emulate the underlying platform
  /// can depend on [defaultTargetPlatform] directly, or may require
  /// that the target platform be provided as an argument. The
  /// [dart:io.Platform] object should only be used directly when it's critical
  /// to actually know the current platform, without any overrides possible (for
  /// example, when a system API is about to be called).
  ///
  /// In a test environment, the platform returned is [TargetPlatform.android]
  /// regardless of the host platform. (Android was chosen because the tests
  /// were originally written assuming Android-like behavior, and we added
  /// platform adaptations for other platforms later). Tests can check behavior
  /// for other platforms by setting the [platform] of the [Theme] explicitly to
  /// another [TargetPlatform] value, or by setting
  /// [debugDefaultTargetPlatformOverride].
  ///
  /// Determines the defaults for [typography] and [materialTapTargetSize].
  final TargetPlatform platform;

  /// A theme for customizing the colors, thickness, and shape of [Scrollbar]s.
  final ScrollbarThemeData scrollbarTheme;

  /// Defines the appearance of ink splashes produces by [InkWell]
  /// and [InkResponse].
  ///
  /// See also:
  ///
  ///  * [InkSplash.splashFactory], which defines the default splash.
  ///  * [InkRipple.splashFactory], which defines a splash that spreads out
  ///    more aggressively than the default.
  ///  * [InkSparkle.splashFactory], which defines a more aggressive and organic
  ///    splash with sparkle effects.
  final InteractiveInkFeatureFactory splashFactory;

  /// A temporary flag that can be used to opt-out of Material 3 features.
  ///
  /// This flag is _true_ by default. If false, then components will
  /// continue to use the colors, typography and other features of
  /// Material 2.
  ///
  /// In the long run this flag will be deprecated and eventually
  /// only Material 3 will be supported. We recommend that applications
  /// migrate to Material 3 as soon as that's practical. Until that migration
  /// is complete, this flag can be set to false.
  ///
  /// ## Defaults
  ///
  /// If a [ThemeData] is _constructed_ with [useMaterial3] set to true, then
  /// some properties will get updated defaults. However, the
  /// [ThemeData.copyWith] method with [useMaterial3] set to true will _not_
  /// change any of these properties in the resulting [ThemeData].
  ///
  /// <style>table,td,th { border-collapse: collapse; padding: 0.45em; } td { border: 1px solid }</style>
  ///
  /// | Property        | Material 3 default             | Material 2 default             |
  /// | :-------------- | :----------------------------- | :----------------------------- |
  /// | [colorScheme]   | M3 baseline light color scheme | M2 baseline light color scheme |
  /// | [typography]    | [Typography.material2021]      | [Typography.material2014]      |
  /// | [splashFactory] | [InkSparkle]* or [InkRipple]   | [InkSplash]                    |
  ///
  /// \* if the target platform is Android and the app is not
  /// running on the web, otherwise it will fallback to [InkRipple].
  ///
  /// If [brightness] is [Brightness.dark] then the default color scheme will
  /// be either the M3 baseline dark color scheme or the M2 baseline dark color
  /// scheme depending on [useMaterial3].
  ///
  /// ## Affected widgets
  ///
  /// This flag affects styles and components.
  ///
  /// ### Styles
  ///   * Color: [ColorScheme], [Material] (see table above)
  ///   * Shape: (see components below)
  ///   * Typography: [Typography] (see table above)
  ///
  /// ### Components
  ///   * Badges: [Badge]
  ///   * Bottom app bar: [BottomAppBar]
  ///   * Bottom sheets: [BottomSheet]
  ///   * Buttons
  ///     - Common buttons: [ElevatedButton], [FilledButton], [FilledButton.tonal], [OutlinedButton], [TextButton]
  ///     - FAB: [FloatingActionButton], [FloatingActionButton.extended]
  ///     - Icon buttons: [IconButton], [IconButton.filled] (*new*), [IconButton.filledTonal], [IconButton.outlined]
  ///     - Segmented buttons: [SegmentedButton] (replacing [ToggleButtons])
  ///   * Cards: [Card]
  ///   * Checkbox: [Checkbox], [CheckboxListTile]
  ///   * Chips:
  ///     - [ActionChip] (used for Assist and Suggestion chips),
  ///     - [FilterChip], [ChoiceChip] (used for single selection filter chips),
  ///     - [InputChip]
  ///   * Date pickers: [showDatePicker], [showDateRangePicker], [DatePickerDialog], [DateRangePickerDialog], [InputDatePickerFormField]
  ///   * Dialogs: [AlertDialog], [Dialog.fullscreen]
  ///   * Divider: [Divider], [VerticalDivider]
  ///   * Lists: [ListTile]
  ///   * Menus: [MenuAnchor], [DropdownMenu], [MenuBar]
  ///   * Navigation bar: [NavigationBar] (replacing [BottomNavigationBar])
  ///   * Navigation drawer: [NavigationDrawer] (replacing [Drawer])
  ///   * Navigation rail: [NavigationRail]
  ///   * Progress indicators: [CircularProgressIndicator], [LinearProgressIndicator]
  ///   * Radio button: [Radio], [RadioListTile]
  ///   * Search: [SearchBar], [SearchAnchor],
  ///   * Snack bar: [SnackBar]
  ///   * Slider: [Slider], [RangeSlider]
  ///   * Switch: [Switch], [SwitchListTile]
  ///   * Tabs: [TabBar], [TabBar.secondary]
  ///   * TextFields: [TextField] together with its [InputDecoration]
  ///   * Time pickers: [showTimePicker], [TimePickerDialog]
  ///   * Top app bar: [AppBar], [SliverAppBar], [SliverAppBar.medium], [SliverAppBar.large]
  ///
  /// In addition, this flag enables features introduced in Android 12.
  ///   * Stretch overscroll: [MaterialScrollBehavior]
  ///   * Ripple: `splashFactory` (see table above)
  ///
  /// See also:
  ///
  ///   * [Material 3 specification](https://m3.material.io/).
  final bool useMaterial3;

  /// The density value for specifying the compactness of various UI components.
  ///
  /// {@template flutter.material.themedata.visualDensity}
  /// Density, in the context of a UI, is the vertical and horizontal
  /// "compactness" of the elements in the UI. It is unitless, since it means
  /// different things to different UI elements. For buttons, it affects the
  /// spacing around the centered label of the button. For lists, it affects the
  /// distance between baselines of entries in the list.
  ///
  /// Typically, density values are integral, but any value in range may be
  /// used. The range includes values from [VisualDensity.minimumDensity] (which
  /// is -4), to [VisualDensity.maximumDensity] (which is 4), inclusive, where
  /// negative values indicate a denser, more compact, UI, and positive values
  /// indicate a less dense, more expanded, UI. If a component doesn't support
  /// the value given, it will clamp to the nearest supported value.
  ///
  /// The default for visual densities is zero for both vertical and horizontal
  /// densities, which corresponds to the default visual density of components
  /// in the Material Design specification.
  ///
  /// As a rule of thumb, a change of 1 or -1 in density corresponds to 4
  /// logical pixels. However, this is not a strict relationship since
  /// components interpret the density values appropriately for their needs.
  ///
  /// A larger value translates to a spacing increase (less dense), and a
  /// smaller value translates to a spacing decrease (more dense).
  ///
  /// In Material Design 3, the [visualDensity] does not override the value of
  /// [IconButton.visualDensity] which defaults to [VisualDensity.standard]
  /// for all platforms. To override the default value of [IconButton.visualDensity],
  /// use [ThemeData.iconButtonTheme] instead.
  /// {@endtemplate}
  final VisualDensity visualDensity;

  // COLOR

  /// The default color of [MaterialType.canvas] [Material].
  final Color canvasColor;

  /// The color of [Material] when it is used as a [Card].
  final Color cardColor;

  /// {@macro flutter.material.color_scheme.ColorScheme}
  ///
  /// This property was added much later than the theme's set of highly specific
  /// colors, like [cardColor], [canvasColor] etc. New components can be defined
  /// exclusively in terms of [colorScheme]. Existing components will gradually
  /// migrate to it, to the extent that is possible without significant
  /// backwards compatibility breaks.
  final ColorScheme colorScheme;

  /// The color used for widgets that are inoperative, regardless of
  /// their state. For example, a disabled checkbox (which may be
  /// checked or unchecked).
  final Color disabledColor;

  /// The color of [Divider]s and [PopupMenuDivider]s, also used
  /// between [ListTile]s, between rows in [DataTable]s, and so forth.
  ///
  /// To create an appropriate [BorderSide] that uses this color, consider
  /// [Divider.createBorderSide].
  final Color dividerColor;

  /// The focus color used indicate that a component has the input focus.
  final Color focusColor;

  /// The highlight color used during ink splash animations or to
  /// indicate an item in a menu is selected.
  final Color highlightColor;

  /// The color to use for hint text or placeholder text, e.g. in
  /// [TextField] fields.
  final Color hintColor;

  /// The hover color used to indicate when a pointer is hovering over a
  /// component.
  final Color hoverColor;

  /// The color of the selected tab indicator in a tab bar.
  final Color indicatorColor;

  /// The background color for major parts of the app (toolbars, tab bars, etc)
  ///
  /// The theme's [colorScheme] property contains [ColorScheme.primary], as
  /// well as a color that contrasts well with the primary color called
  /// [ColorScheme.onPrimary]. It might be simpler to just configure an app's
  /// visuals in terms of the theme's [colorScheme].
  final Color primaryColor;

  /// A darker version of the [primaryColor].
  final Color primaryColorDark;

  /// A lighter version of the [primaryColor].
  final Color primaryColorLight;

  /// The default color of the [Material] that underlies the [Scaffold]. The
  /// background color for a typical material app or a page within the app.
  final Color scaffoldBackgroundColor;

  /// The color of the header of a [PaginatedDataTable] when there are selected rows.
  // According to the spec for data tables:
  // https://material.io/archive/guidelines/components/data-tables.html#data-tables-tables-within-cards
  // ...this should be the "50-value of secondary app color".
  final Color secondaryHeaderColor;

  /// The color that the [Material] widget uses to draw elevation shadows.
  ///
  /// Defaults to fully opaque black.
  ///
  /// Shadows can be difficult to see in a dark theme, so the elevation of a
  /// surface should be rendered with an "overlay" in addition to the shadow.
  /// As the elevation of the component increases, the overlay increases in
  /// opacity. The [applyElevationOverlayColor] property turns the elevation
  /// overlay on or off for dark themes.
  final Color shadowColor;

  /// The color of ink splashes.
  ///
  /// See also:
  ///  * [splashFactory], which defines the appearance of the splash.
  final Color splashColor;

  /// The color used for widgets in their inactive (but enabled)
  /// state. For example, an unchecked checkbox. See also [disabledColor].
  final Color unselectedWidgetColor;

  // TYPOGRAPHY & ICONOGRAPHY

  /// An icon theme that contrasts with the card and canvas colors.
  final IconThemeData iconTheme;

  /// An icon theme that contrasts with the primary color.
  final IconThemeData primaryIconTheme;

  /// A text theme that contrasts with the primary color.
  final TextTheme primaryTextTheme;

  /// Text with a color that contrasts with the card and canvas colors.
  final TextTheme textTheme;

  /// The color and geometry [TextTheme] values used to configure [textTheme].
  ///
  /// Defaults to a [platform]-appropriate typography.
  final Typography typography;

  // COMPONENT THEMES

  /// A theme for customizing icons of [BackButtonIcon], [CloseButtonIcon],
  /// [DrawerButtonIcon], or [EndDrawerButtonIcon].
  final ActionIconThemeData? actionIconTheme;

  /// A theme for customizing the color, elevation, brightness, iconTheme and
  /// textTheme of [AppBar]s.
  final AppBarTheme appBarTheme;

  /// A theme for customizing the color of [Badge]s.
  final BadgeThemeData badgeTheme;

  /// A theme for customizing the color and text style of a [MaterialBanner].
  final MaterialBannerThemeData bannerTheme;

  /// A theme for customizing the shape, elevation, and color of a [BottomAppBar].
  final BottomAppBarTheme bottomAppBarTheme;

  /// A theme for customizing the appearance and layout of [BottomNavigationBar]
  /// widgets.
  final BottomNavigationBarThemeData bottomNavigationBarTheme;

  /// A theme for customizing the color, elevation, and shape of a bottom sheet.
  final BottomSheetThemeData bottomSheetTheme;

  /// Defines the default configuration of button widgets, like [DropdownButton]
  /// and [ButtonBar].
  final ButtonThemeData buttonTheme;

  /// The colors and styles used to render [Card].
  ///
  /// This is the value returned from [CardTheme.of].
  final CardThemeData cardTheme;

  /// A theme for customizing the appearance and layout of [Checkbox] widgets.
  final CheckboxThemeData checkboxTheme;

  /// The colors and styles used to render [Chip]s.
  ///
  /// This is the value returned from [ChipTheme.of].
  final ChipThemeData chipTheme;

  /// A theme for customizing the appearance and layout of [DataTable]
  /// widgets.
  final DataTableThemeData dataTableTheme;

  /// A theme for customizing the appearance and layout of [DatePickerDialog]
  /// widgets.
  final DatePickerThemeData datePickerTheme;

  /// A theme for customizing the shape of a dialog.
  final DialogThemeData dialogTheme;

  /// A theme for customizing the color, thickness, and indents of [Divider]s,
  /// [VerticalDivider]s, etc.
  final DividerThemeData dividerTheme;

  /// A theme for customizing the appearance and layout of [Drawer] widgets.
  final DrawerThemeData drawerTheme;

  /// A theme for customizing the appearance and layout of [DropdownMenu] widgets.
  final DropdownMenuThemeData dropdownMenuTheme;

  /// A theme for customizing the appearance and internal layout of
  /// [ElevatedButton]s.
  final ElevatedButtonThemeData elevatedButtonTheme;

  /// A theme for customizing the visual properties of [ExpansionTile]s.
  final ExpansionTileThemeData expansionTileTheme;

  /// A theme for customizing the appearance and internal layout of
  /// [FilledButton]s.
  final FilledButtonThemeData filledButtonTheme;

  /// A theme for customizing the shape, elevation, and color of a
  /// [FloatingActionButton].
  final FloatingActionButtonThemeData floatingActionButtonTheme;

  /// A theme for customizing the appearance and internal layout of
  /// [IconButton]s.
  final IconButtonThemeData iconButtonTheme;

  /// A theme for customizing the appearance of [ListTile] widgets.
  final ListTileThemeData listTileTheme;

  /// A theme for customizing the color, shape, elevation, and other [MenuStyle]
  /// aspects of the menu bar created by the [MenuBar] widget.
  final MenuBarThemeData menuBarTheme;

  /// A theme for customizing the color, shape, elevation, and text style of
  /// cascading menu buttons created by [SubmenuButton] or [MenuItemButton].
  final MenuButtonThemeData menuButtonTheme;

  /// A theme for customizing the color, shape, elevation, and other [MenuStyle]
  /// attributes of menus created by the [SubmenuButton] widget.
  final MenuThemeData menuTheme;

  /// A theme for customizing the background color, text style, and icon themes
  /// of a [NavigationBar].
  final NavigationBarThemeData navigationBarTheme;

  /// A theme for customizing the background color, text style, and icon themes
  /// of a [NavigationDrawer].
  final NavigationDrawerThemeData navigationDrawerTheme;

  /// A theme for customizing the background color, elevation, text style, and
  /// icon themes of a [NavigationRail].
  final NavigationRailThemeData navigationRailTheme;

  /// A theme for customizing the appearance and internal layout of
  /// [OutlinedButton]s.
  final OutlinedButtonThemeData outlinedButtonTheme;

  /// A theme for customizing the color, shape, elevation, and text style of
  /// popup menus.
  final PopupMenuThemeData popupMenuTheme;

  /// A theme for customizing the appearance and layout of [ProgressIndicator] widgets.
  final ProgressIndicatorThemeData progressIndicatorTheme;

  /// A theme for customizing the appearance and layout of [Radio] widgets.
  final RadioThemeData radioTheme;

  /// A theme for customizing the appearance and layout of [SearchBar] widgets.
  final SearchBarThemeData searchBarTheme;

  /// A theme for customizing the appearance and layout of search views created by [SearchAnchor] widgets.
  final SearchViewThemeData searchViewTheme;

  /// A theme for customizing the appearance and layout of [SegmentedButton] widgets.
  final SegmentedButtonThemeData segmentedButtonTheme;

  /// The colors and shapes used to render [Slider].
  ///
  /// This is the value returned from [SliderTheme.of].
  final SliderThemeData sliderTheme;

  /// A theme for customizing colors, shape, elevation, and behavior of a [SnackBar].
  final SnackBarThemeData snackBarTheme;

  /// A theme for customizing the appearance and layout of [Switch] widgets.
  final SwitchThemeData switchTheme;

  /// A theme for customizing the size, shape, and color of the tab bar indicator.
  final TabBarThemeData tabBarTheme;

  /// A theme for customizing the appearance and internal layout of
  /// [TextButton]s.
  final TextButtonThemeData textButtonTheme;

  /// A theme for customizing the appearance and layout of [TextField] widgets.
  final TextSelectionThemeData textSelectionTheme;

  /// A theme for customizing the appearance and layout of time picker widgets.
  final TimePickerThemeData timePickerTheme;

  /// Defines the default configuration of [ToggleButtons] widgets.
  final ToggleButtonsThemeData toggleButtonsTheme;

  /// A theme for customizing the visual properties of [Tooltip]s.
  ///
  /// This is the value returned from [TooltipTheme.of].
  final TooltipThemeData tooltipTheme;

  /// A theme for customizing the appearance and layout of [ButtonBar] widgets.
  @Deprecated(
    'Use OverflowBar instead. '
    'This feature was deprecated after v3.21.0-10.0.pre.',
  )
  ButtonBarThemeData get buttonBarTheme => _buttonBarTheme!;
  final ButtonBarThemeData? _buttonBarTheme;

  /// The background color of [Dialog] elements.
  @Deprecated(
    'Use DialogThemeData.backgroundColor instead. '
    'This feature was deprecated after v3.27.0-0.1.pre.',
  )
  final Color dialogBackgroundColor;

  /// Creates a copy of this theme but with the given fields replaced with the new values.
  ///
  /// The [brightness] value is applied to the [colorScheme].
  ThemeData copyWith({
    // For the sanity of the reader, make sure these properties are in the same
    // order in every place that they are separated by section comments (e.g.
    // GENERAL CONFIGURATION). Each section except for deprecations should be
    // alphabetical by symbol name.

    // GENERAL CONFIGURATION
    Iterable<Adaptation<Object>>? adaptations,
    bool? applyElevationOverlayColor,
    NoDefaultCupertinoThemeData? cupertinoOverrideTheme,
    Iterable<ThemeExtension<dynamic>>? extensions,
    InputDecorationTheme? inputDecorationTheme,
    MaterialTapTargetSize? materialTapTargetSize,
    PageTransitionsTheme? pageTransitionsTheme,
    TargetPlatform? platform,
    ScrollbarThemeData? scrollbarTheme,
    InteractiveInkFeatureFactory? splashFactory,
    VisualDensity? visualDensity,
    // COLOR
    ColorScheme? colorScheme,
    Brightness? brightness,
    // [colorScheme] is the preferred way to configure colors. The [Color] properties
    // listed below (as well as primarySwatch) will gradually be phased out, see
    // https://github.com/flutter/flutter/issues/91772.
    Color? canvasColor,
    Color? cardColor,
    Color? disabledColor,
    Color? dividerColor,
    Color? focusColor,
    Color? highlightColor,
    Color? hintColor,
    Color? hoverColor,
    Color? indicatorColor,
    Color? primaryColor,
    Color? primaryColorDark,
    Color? primaryColorLight,
    Color? scaffoldBackgroundColor,
    Color? secondaryHeaderColor,
    Color? shadowColor,
    Color? splashColor,
    Color? unselectedWidgetColor,
    // TYPOGRAPHY & ICONOGRAPHY
    IconThemeData? iconTheme,
    IconThemeData? primaryIconTheme,
    TextTheme? primaryTextTheme,
    TextTheme? textTheme,
    Typography? typography,
    // COMPONENT THEMES
    ActionIconThemeData? actionIconTheme,
    AppBarTheme? appBarTheme,
    BadgeThemeData? badgeTheme,
    MaterialBannerThemeData? bannerTheme,
    BottomAppBarTheme? bottomAppBarTheme,
    BottomNavigationBarThemeData? bottomNavigationBarTheme,
    BottomSheetThemeData? bottomSheetTheme,
    ButtonThemeData? buttonTheme,
    Object? cardTheme,
    CheckboxThemeData? checkboxTheme,
    ChipThemeData? chipTheme,
    DataTableThemeData? dataTableTheme,
    DatePickerThemeData? datePickerTheme,
    // TODO(QuncCccccc): Change the parameter type to DialogThemeData
    Object? dialogTheme,
    DividerThemeData? dividerTheme,
    DrawerThemeData? drawerTheme,
    DropdownMenuThemeData? dropdownMenuTheme,
    ElevatedButtonThemeData? elevatedButtonTheme,
    ExpansionTileThemeData? expansionTileTheme,
    FilledButtonThemeData? filledButtonTheme,
    FloatingActionButtonThemeData? floatingActionButtonTheme,
    IconButtonThemeData? iconButtonTheme,
    ListTileThemeData? listTileTheme,
    MenuBarThemeData? menuBarTheme,
    MenuButtonThemeData? menuButtonTheme,
    MenuThemeData? menuTheme,
    NavigationBarThemeData? navigationBarTheme,
    NavigationDrawerThemeData? navigationDrawerTheme,
    NavigationRailThemeData? navigationRailTheme,
    OutlinedButtonThemeData? outlinedButtonTheme,
    PopupMenuThemeData? popupMenuTheme,
    ProgressIndicatorThemeData? progressIndicatorTheme,
    RadioThemeData? radioTheme,
    SearchBarThemeData? searchBarTheme,
    SearchViewThemeData? searchViewTheme,
    SegmentedButtonThemeData? segmentedButtonTheme,
    SliderThemeData? sliderTheme,
    SnackBarThemeData? snackBarTheme,
    SwitchThemeData? switchTheme,
    // TODO(QuncCccccc): Change the parameter type to TabBarThemeData
    Object? tabBarTheme,
    TextButtonThemeData? textButtonTheme,
    TextSelectionThemeData? textSelectionTheme,
    TimePickerThemeData? timePickerTheme,
    ToggleButtonsThemeData? toggleButtonsTheme,
    TooltipThemeData? tooltipTheme,
    // DEPRECATED (newest deprecations at the bottom)
    @Deprecated(
      'Use a ThemeData constructor (.from, .light, or .dark) instead. '
      'These constructors all have a useMaterial3 argument, '
      'and they set appropriate default values based on its value. '
      'See the useMaterial3 API documentation for full details. '
      'This feature was deprecated after v3.13.0-0.2.pre.',
    )
    bool? useMaterial3,
    @Deprecated(
      'Use OverflowBar instead. '
      'This feature was deprecated after v3.21.0-10.0.pre.',
    )
    ButtonBarThemeData? buttonBarTheme,
    @Deprecated(
      'Use DialogThemeData.backgroundColor instead. '
      'This feature was deprecated after v3.27.0-0.1.pre.',
    )
    Color? dialogBackgroundColor,
  }) {
    cupertinoOverrideTheme = cupertinoOverrideTheme?.noDefault();

    // TODO(QuncCccccc): Clean it up once the type of `cardTheme` is changed to `CardThemeData`
    if (cardTheme != null) {
      if (cardTheme is CardTheme) {
        cardTheme = cardTheme.data;
      } else if (cardTheme is! CardThemeData) {
        throw ArgumentError('cardTheme must be either a CardThemeData or a CardTheme');
      }
    }

    // TODO(QuncCccccc): Clean this up once the type of `dialogTheme` is changed to `DialogThemeData`
    if (dialogTheme != null) {
      if (dialogTheme is DialogTheme) {
        dialogTheme = dialogTheme.data;
      } else if (dialogTheme is! DialogThemeData) {
        throw ArgumentError('dialogTheme must be either a DialogThemeData or a DialogTheme');
      }
    }

    // TODO(QuncCccccc): Clean this up once the type of `tabBarTheme` is changed to `TabBarThemeData`
    if (tabBarTheme != null) {
      if (tabBarTheme is TabBarTheme) {
        tabBarTheme = tabBarTheme.data;
      } else if (tabBarTheme is! TabBarThemeData) {
        throw ArgumentError('tabBarTheme must be either a TabBarThemeData or a TabBarTheme');
      }
    }
    return ThemeData.raw(
      // For the sanity of the reader, make sure these properties are in the same
      // order in every place that they are separated by section comments (e.g.
      // GENERAL CONFIGURATION). Each section except for deprecations should be
      // alphabetical by symbol name.

      // GENERAL CONFIGURATION
      adaptationMap: adaptations != null ? _createAdaptationMap(adaptations) : adaptationMap,
      applyElevationOverlayColor: applyElevationOverlayColor ?? this.applyElevationOverlayColor,
      cupertinoOverrideTheme: cupertinoOverrideTheme ?? this.cupertinoOverrideTheme,
      extensions: (extensions != null) ? _themeExtensionIterableToMap(extensions) : this.extensions,
      inputDecorationTheme: inputDecorationTheme ?? this.inputDecorationTheme,
      materialTapTargetSize: materialTapTargetSize ?? this.materialTapTargetSize,
      pageTransitionsTheme: pageTransitionsTheme ?? this.pageTransitionsTheme,
      platform: platform ?? this.platform,
      scrollbarTheme: scrollbarTheme ?? this.scrollbarTheme,
      splashFactory: splashFactory ?? this.splashFactory,
      // When deprecated useMaterial3 removed, maintain `this.useMaterial3` here
      // for == evaluation.
      useMaterial3: useMaterial3 ?? this.useMaterial3,
      visualDensity: visualDensity ?? this.visualDensity,
      // COLOR
      canvasColor: canvasColor ?? this.canvasColor,
      cardColor: cardColor ?? this.cardColor,
      colorScheme: (colorScheme ?? this.colorScheme).copyWith(brightness: brightness),
      disabledColor: disabledColor ?? this.disabledColor,
      dividerColor: dividerColor ?? this.dividerColor,
      focusColor: focusColor ?? this.focusColor,
      highlightColor: highlightColor ?? this.highlightColor,
      hintColor: hintColor ?? this.hintColor,
      hoverColor: hoverColor ?? this.hoverColor,
      indicatorColor: indicatorColor ?? this.indicatorColor,
      primaryColor: primaryColor ?? this.primaryColor,
      primaryColorDark: primaryColorDark ?? this.primaryColorDark,
      primaryColorLight: primaryColorLight ?? this.primaryColorLight,
      scaffoldBackgroundColor: scaffoldBackgroundColor ?? this.scaffoldBackgroundColor,
      secondaryHeaderColor: secondaryHeaderColor ?? this.secondaryHeaderColor,
      shadowColor: shadowColor ?? this.shadowColor,
      splashColor: splashColor ?? this.splashColor,
      unselectedWidgetColor: unselectedWidgetColor ?? this.unselectedWidgetColor,
      // TYPOGRAPHY & ICONOGRAPHY
      iconTheme: iconTheme ?? this.iconTheme,
      primaryIconTheme: primaryIconTheme ?? this.primaryIconTheme,
      primaryTextTheme: primaryTextTheme ?? this.primaryTextTheme,
      textTheme: textTheme ?? this.textTheme,
      typography: typography ?? this.typography,
      // COMPONENT THEMES
      actionIconTheme: actionIconTheme ?? this.actionIconTheme,
      appBarTheme: appBarTheme ?? this.appBarTheme,
      badgeTheme: badgeTheme ?? this.badgeTheme,
      bannerTheme: bannerTheme ?? this.bannerTheme,
      bottomAppBarTheme: bottomAppBarTheme ?? this.bottomAppBarTheme,
      bottomNavigationBarTheme: bottomNavigationBarTheme ?? this.bottomNavigationBarTheme,
      bottomSheetTheme: bottomSheetTheme ?? this.bottomSheetTheme,
      buttonTheme: buttonTheme ?? this.buttonTheme,
      cardTheme: cardTheme as CardThemeData? ?? this.cardTheme,
      checkboxTheme: checkboxTheme ?? this.checkboxTheme,
      chipTheme: chipTheme ?? this.chipTheme,
      dataTableTheme: dataTableTheme ?? this.dataTableTheme,
      datePickerTheme: datePickerTheme ?? this.datePickerTheme,
      dialogTheme: dialogTheme as DialogThemeData? ?? this.dialogTheme,
      dividerTheme: dividerTheme ?? this.dividerTheme,
      drawerTheme: drawerTheme ?? this.drawerTheme,
      dropdownMenuTheme: dropdownMenuTheme ?? this.dropdownMenuTheme,
      elevatedButtonTheme: elevatedButtonTheme ?? this.elevatedButtonTheme,
      expansionTileTheme: expansionTileTheme ?? this.expansionTileTheme,
      filledButtonTheme: filledButtonTheme ?? this.filledButtonTheme,
      floatingActionButtonTheme: floatingActionButtonTheme ?? this.floatingActionButtonTheme,
      iconButtonTheme: iconButtonTheme ?? this.iconButtonTheme,
      listTileTheme: listTileTheme ?? this.listTileTheme,
      menuBarTheme: menuBarTheme ?? this.menuBarTheme,
      menuButtonTheme: menuButtonTheme ?? this.menuButtonTheme,
      menuTheme: menuTheme ?? this.menuTheme,
      navigationBarTheme: navigationBarTheme ?? this.navigationBarTheme,
      navigationDrawerTheme: navigationDrawerTheme ?? this.navigationDrawerTheme,
      navigationRailTheme: navigationRailTheme ?? this.navigationRailTheme,
      outlinedButtonTheme: outlinedButtonTheme ?? this.outlinedButtonTheme,
      popupMenuTheme: popupMenuTheme ?? this.popupMenuTheme,
      progressIndicatorTheme: progressIndicatorTheme ?? this.progressIndicatorTheme,
      radioTheme: radioTheme ?? this.radioTheme,
      searchBarTheme: searchBarTheme ?? this.searchBarTheme,
      searchViewTheme: searchViewTheme ?? this.searchViewTheme,
      segmentedButtonTheme: segmentedButtonTheme ?? this.segmentedButtonTheme,
      sliderTheme: sliderTheme ?? this.sliderTheme,
      snackBarTheme: snackBarTheme ?? this.snackBarTheme,
      switchTheme: switchTheme ?? this.switchTheme,
      tabBarTheme: tabBarTheme as TabBarThemeData? ?? this.tabBarTheme,
      textButtonTheme: textButtonTheme ?? this.textButtonTheme,
      textSelectionTheme: textSelectionTheme ?? this.textSelectionTheme,
      timePickerTheme: timePickerTheme ?? this.timePickerTheme,
      toggleButtonsTheme: toggleButtonsTheme ?? this.toggleButtonsTheme,
      tooltipTheme: tooltipTheme ?? this.tooltipTheme,
      // DEPRECATED (newest deprecations at the bottom)
      buttonBarTheme: buttonBarTheme ?? _buttonBarTheme,
      dialogBackgroundColor: dialogBackgroundColor ?? this.dialogBackgroundColor,
    );
  }

  // The number 5 was chosen without any real science or research behind it. It
  // just seemed like a number that's not too big (we should be able to fit 5
  // copies of ThemeData in memory comfortably) and not too small (most apps
  // shouldn't have more than 5 theme/localization pairs).
  static const int _localizedThemeDataCacheSize = 5;

  /// Caches localized themes to speed up the [localize] method.
  static final _FifoCache<_IdentityThemeDataCacheKey, ThemeData> _localizedThemeDataCache =
      _FifoCache<_IdentityThemeDataCacheKey, ThemeData>(_localizedThemeDataCacheSize);

  /// Returns a new theme built by merging the text geometry provided by the
  /// [localTextGeometry] theme with the [baseTheme].
  ///
  /// For those text styles in the [baseTheme] whose [TextStyle.inherit] is set
  /// to true, the returned theme's text styles inherit the geometric properties
  /// of [localTextGeometry]. The resulting text styles' [TextStyle.inherit] is
  /// set to those provided by [localTextGeometry].
  static ThemeData localize(ThemeData baseTheme, TextTheme localTextGeometry) {
    // WARNING: this method memoizes the result in a cache based on the
    // previously seen baseTheme and localTextGeometry. Memoization is safe
    // because all inputs and outputs of this function are deeply immutable, and
    // the computations are referentially transparent. It only short-circuits
    // the computation if the new inputs are identical() to the previous ones.
    // It does not use the == operator, which performs a costly deep comparison.
    //
    // When changing this method, make sure the memoization logic is correct.
    // Remember:
    //
    // There are only two hard things in Computer Science: cache invalidation
    // and naming things. -- Phil Karlton

    return _localizedThemeDataCache.putIfAbsent(
      _IdentityThemeDataCacheKey(baseTheme, localTextGeometry),
      () {
        return baseTheme.copyWith(
          primaryTextTheme: localTextGeometry.merge(baseTheme.primaryTextTheme),
          textTheme: localTextGeometry.merge(baseTheme.textTheme),
        );
      },
    );
  }

  /// Determines whether the given [Color] is [Brightness.light] or
  /// [Brightness.dark].
  ///
  /// This compares the luminosity of the given color to a threshold value that
  /// matches the Material Design specification.
  static Brightness estimateBrightnessForColor(Color color) {
    final double relativeLuminance = color.computeLuminance();

    // See <https://www.w3.org/TR/WCAG20/#contrast-ratiodef>
    // The spec says to use kThreshold=0.0525, but Material Design appears to bias
    // more towards using light text than WCAG20 recommends. Material Design spec
    // doesn't say what value to use, but 0.15 seemed close to what the Material
    // Design spec shows for its color palette on
    // <https://material.io/go/design-theming#color-color-palette>.
    const double kThreshold = 0.15;
    if ((relativeLuminance + 0.05) * (relativeLuminance + 0.05) > kThreshold) {
      return Brightness.light;
    }
    return Brightness.dark;
  }

  /// Linearly interpolate between two [extensions].
  ///
  /// Includes all theme extensions in [a] and [b].
  ///
  /// {@macro dart.ui.shadow.lerp}
  static Map<Object, ThemeExtension<dynamic>> _lerpThemeExtensions(
    ThemeData a,
    ThemeData b,
    double t,
  ) {
    // Lerp [a].
    final Map<Object, ThemeExtension<dynamic>> newExtensions = a.extensions.map((
      Object id,
      ThemeExtension<dynamic> extensionA,
    ) {
      final ThemeExtension<dynamic>? extensionB = b.extensions[id];
      return MapEntry<Object, ThemeExtension<dynamic>>(id, extensionA.lerp(extensionB, t));
    });
    // Add [b]-only extensions.
    newExtensions.addEntries(
      b.extensions.entries.where(
        (MapEntry<Object, ThemeExtension<dynamic>> entry) => !a.extensions.containsKey(entry.key),
      ),
    );

    return newExtensions;
  }

  /// Convert the [extensionsIterable] passed to [ThemeData.new] or [copyWith]
  /// to the stored [extensions] map, where each entry's key consists of the extension's type.
  static Map<Object, ThemeExtension<dynamic>> _themeExtensionIterableToMap(
    Iterable<ThemeExtension<dynamic>> extensionsIterable,
  ) {
    return Map<Object, ThemeExtension<dynamic>>.unmodifiable(<Object, ThemeExtension<dynamic>>{
      // Strangely, the cast is necessary for tests to run.
      for (final ThemeExtension<dynamic> extension in extensionsIterable)
        extension.type: extension as ThemeExtension<ThemeExtension<dynamic>>,
    });
  }

  /// Linearly interpolate between two themes.
  ///
  /// {@macro dart.ui.shadow.lerp}
  static ThemeData lerp(ThemeData a, ThemeData b, double t) {
    if (identical(a, b)) {
      return a;
    }
    return ThemeData.raw(
      // For the sanity of the reader, make sure these properties are in the same
      // order in every place that they are separated by section comments (e.g.
      // GENERAL CONFIGURATION). Each section except for deprecations should be
      // alphabetical by symbol name.

      // GENERAL CONFIGURATION
      adaptationMap: t < 0.5 ? a.adaptationMap : b.adaptationMap,
      applyElevationOverlayColor:
          t < 0.5 ? a.applyElevationOverlayColor : b.applyElevationOverlayColor,
      cupertinoOverrideTheme: t < 0.5 ? a.cupertinoOverrideTheme : b.cupertinoOverrideTheme,
      extensions: _lerpThemeExtensions(a, b, t),
      inputDecorationTheme: t < 0.5 ? a.inputDecorationTheme : b.inputDecorationTheme,
      materialTapTargetSize: t < 0.5 ? a.materialTapTargetSize : b.materialTapTargetSize,
      pageTransitionsTheme: t < 0.5 ? a.pageTransitionsTheme : b.pageTransitionsTheme,
      platform: t < 0.5 ? a.platform : b.platform,
      scrollbarTheme: ScrollbarThemeData.lerp(a.scrollbarTheme, b.scrollbarTheme, t),
      splashFactory: t < 0.5 ? a.splashFactory : b.splashFactory,
      useMaterial3: t < 0.5 ? a.useMaterial3 : b.useMaterial3,
      visualDensity: VisualDensity.lerp(a.visualDensity, b.visualDensity, t),
      // COLOR
      canvasColor: Color.lerp(a.canvasColor, b.canvasColor, t)!,
      cardColor: Color.lerp(a.cardColor, b.cardColor, t)!,
      colorScheme: ColorScheme.lerp(a.colorScheme, b.colorScheme, t),
      disabledColor: Color.lerp(a.disabledColor, b.disabledColor, t)!,
      dividerColor: Color.lerp(a.dividerColor, b.dividerColor, t)!,
      focusColor: Color.lerp(a.focusColor, b.focusColor, t)!,
      highlightColor: Color.lerp(a.highlightColor, b.highlightColor, t)!,
      hintColor: Color.lerp(a.hintColor, b.hintColor, t)!,
      hoverColor: Color.lerp(a.hoverColor, b.hoverColor, t)!,
      indicatorColor: Color.lerp(a.indicatorColor, b.indicatorColor, t)!,
      primaryColor: Color.lerp(a.primaryColor, b.primaryColor, t)!,
      primaryColorDark: Color.lerp(a.primaryColorDark, b.primaryColorDark, t)!,
      primaryColorLight: Color.lerp(a.primaryColorLight, b.primaryColorLight, t)!,
      scaffoldBackgroundColor: Color.lerp(a.scaffoldBackgroundColor, b.scaffoldBackgroundColor, t)!,
      secondaryHeaderColor: Color.lerp(a.secondaryHeaderColor, b.secondaryHeaderColor, t)!,
      shadowColor: Color.lerp(a.shadowColor, b.shadowColor, t)!,
      splashColor: Color.lerp(a.splashColor, b.splashColor, t)!,
      unselectedWidgetColor: Color.lerp(a.unselectedWidgetColor, b.unselectedWidgetColor, t)!,
      // TYPOGRAPHY & ICONOGRAPHY
      iconTheme: IconThemeData.lerp(a.iconTheme, b.iconTheme, t),
      primaryIconTheme: IconThemeData.lerp(a.primaryIconTheme, b.primaryIconTheme, t),
      primaryTextTheme: TextTheme.lerp(a.primaryTextTheme, b.primaryTextTheme, t),
      textTheme: TextTheme.lerp(a.textTheme, b.textTheme, t),
      typography: Typography.lerp(a.typography, b.typography, t),
      // COMPONENT THEMES
      actionIconTheme: ActionIconThemeData.lerp(a.actionIconTheme, b.actionIconTheme, t),
      appBarTheme: AppBarTheme.lerp(a.appBarTheme, b.appBarTheme, t),
      badgeTheme: BadgeThemeData.lerp(a.badgeTheme, b.badgeTheme, t),
      bannerTheme: MaterialBannerThemeData.lerp(a.bannerTheme, b.bannerTheme, t),
      bottomAppBarTheme: BottomAppBarTheme.lerp(a.bottomAppBarTheme, b.bottomAppBarTheme, t),
      bottomNavigationBarTheme: BottomNavigationBarThemeData.lerp(
        a.bottomNavigationBarTheme,
        b.bottomNavigationBarTheme,
        t,
      ),
      bottomSheetTheme: BottomSheetThemeData.lerp(a.bottomSheetTheme, b.bottomSheetTheme, t)!,
      buttonTheme: t < 0.5 ? a.buttonTheme : b.buttonTheme,
      cardTheme: CardThemeData.lerp(a.cardTheme, b.cardTheme, t),
      checkboxTheme: CheckboxThemeData.lerp(a.checkboxTheme, b.checkboxTheme, t),
      chipTheme: ChipThemeData.lerp(a.chipTheme, b.chipTheme, t)!,
      dataTableTheme: DataTableThemeData.lerp(a.dataTableTheme, b.dataTableTheme, t),
      datePickerTheme: DatePickerThemeData.lerp(a.datePickerTheme, b.datePickerTheme, t),
      dialogTheme: DialogThemeData.lerp(a.dialogTheme, b.dialogTheme, t),
      dividerTheme: DividerThemeData.lerp(a.dividerTheme, b.dividerTheme, t),
      drawerTheme: DrawerThemeData.lerp(a.drawerTheme, b.drawerTheme, t)!,
      dropdownMenuTheme: DropdownMenuThemeData.lerp(a.dropdownMenuTheme, b.dropdownMenuTheme, t),
      elevatedButtonTheme:
          ElevatedButtonThemeData.lerp(a.elevatedButtonTheme, b.elevatedButtonTheme, t)!,
      expansionTileTheme:
          ExpansionTileThemeData.lerp(a.expansionTileTheme, b.expansionTileTheme, t)!,
      filledButtonTheme: FilledButtonThemeData.lerp(a.filledButtonTheme, b.filledButtonTheme, t)!,
      floatingActionButtonTheme:
          FloatingActionButtonThemeData.lerp(
            a.floatingActionButtonTheme,
            b.floatingActionButtonTheme,
            t,
          )!,
      iconButtonTheme: IconButtonThemeData.lerp(a.iconButtonTheme, b.iconButtonTheme, t)!,
      listTileTheme: ListTileThemeData.lerp(a.listTileTheme, b.listTileTheme, t)!,
      menuBarTheme: MenuBarThemeData.lerp(a.menuBarTheme, b.menuBarTheme, t)!,
      menuButtonTheme: MenuButtonThemeData.lerp(a.menuButtonTheme, b.menuButtonTheme, t)!,
      menuTheme: MenuThemeData.lerp(a.menuTheme, b.menuTheme, t)!,
      navigationBarTheme:
          NavigationBarThemeData.lerp(a.navigationBarTheme, b.navigationBarTheme, t)!,
      navigationDrawerTheme:
          NavigationDrawerThemeData.lerp(a.navigationDrawerTheme, b.navigationDrawerTheme, t)!,
      navigationRailTheme:
          NavigationRailThemeData.lerp(a.navigationRailTheme, b.navigationRailTheme, t)!,
      outlinedButtonTheme:
          OutlinedButtonThemeData.lerp(a.outlinedButtonTheme, b.outlinedButtonTheme, t)!,
      popupMenuTheme: PopupMenuThemeData.lerp(a.popupMenuTheme, b.popupMenuTheme, t)!,
      progressIndicatorTheme:
          ProgressIndicatorThemeData.lerp(a.progressIndicatorTheme, b.progressIndicatorTheme, t)!,
      radioTheme: RadioThemeData.lerp(a.radioTheme, b.radioTheme, t),
      searchBarTheme: SearchBarThemeData.lerp(a.searchBarTheme, b.searchBarTheme, t)!,
      searchViewTheme: SearchViewThemeData.lerp(a.searchViewTheme, b.searchViewTheme, t)!,
      segmentedButtonTheme: SegmentedButtonThemeData.lerp(
        a.segmentedButtonTheme,
        b.segmentedButtonTheme,
        t,
      ),
      sliderTheme: SliderThemeData.lerp(a.sliderTheme, b.sliderTheme, t),
      snackBarTheme: SnackBarThemeData.lerp(a.snackBarTheme, b.snackBarTheme, t),
      switchTheme: SwitchThemeData.lerp(a.switchTheme, b.switchTheme, t),
      tabBarTheme: TabBarThemeData.lerp(a.tabBarTheme, b.tabBarTheme, t),
      textButtonTheme: TextButtonThemeData.lerp(a.textButtonTheme, b.textButtonTheme, t)!,
      textSelectionTheme:
          TextSelectionThemeData.lerp(a.textSelectionTheme, b.textSelectionTheme, t)!,
      timePickerTheme: TimePickerThemeData.lerp(a.timePickerTheme, b.timePickerTheme, t),
      toggleButtonsTheme:
          ToggleButtonsThemeData.lerp(a.toggleButtonsTheme, b.toggleButtonsTheme, t)!,
      tooltipTheme: TooltipThemeData.lerp(a.tooltipTheme, b.tooltipTheme, t)!,
      // DEPRECATED (newest deprecations at the bottom)
      buttonBarTheme: ButtonBarThemeData.lerp(a.buttonBarTheme, b.buttonBarTheme, t),
      dialogBackgroundColor: Color.lerp(a.dialogBackgroundColor, b.dialogBackgroundColor, t)!,
    );
  }

  @override
  bool operator ==(Object other) {
    if (other.runtimeType != runtimeType) {
      return false;
    }
    return other is ThemeData &&
        // For the sanity of the reader, make sure these properties are in the same
        // order in every place that they are separated by section comments (e.g.
        // GENERAL CONFIGURATION). Each section except for deprecations should be
        // alphabetical by symbol name.
        // GENERAL CONFIGURATION
        mapEquals(other.adaptationMap, adaptationMap) &&
        other.applyElevationOverlayColor == applyElevationOverlayColor &&
        other.cupertinoOverrideTheme == cupertinoOverrideTheme &&
        mapEquals(other.extensions, extensions) &&
        other.inputDecorationTheme == inputDecorationTheme &&
        other.materialTapTargetSize == materialTapTargetSize &&
        other.pageTransitionsTheme == pageTransitionsTheme &&
        other.platform == platform &&
        other.scrollbarTheme == scrollbarTheme &&
        other.splashFactory == splashFactory &&
        other.useMaterial3 == useMaterial3 &&
        other.visualDensity == visualDensity &&
        // COLOR
        other.canvasColor == canvasColor &&
        other.cardColor == cardColor &&
        other.colorScheme == colorScheme &&
        other.disabledColor == disabledColor &&
        other.dividerColor == dividerColor &&
        other.focusColor == focusColor &&
        other.highlightColor == highlightColor &&
        other.hintColor == hintColor &&
        other.hoverColor == hoverColor &&
        other.indicatorColor == indicatorColor &&
        other.primaryColor == primaryColor &&
        other.primaryColorDark == primaryColorDark &&
        other.primaryColorLight == primaryColorLight &&
        other.scaffoldBackgroundColor == scaffoldBackgroundColor &&
        other.secondaryHeaderColor == secondaryHeaderColor &&
        other.shadowColor == shadowColor &&
        other.splashColor == splashColor &&
        other.unselectedWidgetColor == unselectedWidgetColor &&
        // TYPOGRAPHY & ICONOGRAPHY
        other.iconTheme == iconTheme &&
        other.primaryIconTheme == primaryIconTheme &&
        other.primaryTextTheme == primaryTextTheme &&
        other.textTheme == textTheme &&
        other.typography == typography &&
        // COMPONENT THEMES
        other.actionIconTheme == actionIconTheme &&
        other.appBarTheme == appBarTheme &&
        other.badgeTheme == badgeTheme &&
        other.bannerTheme == bannerTheme &&
        other.bottomAppBarTheme == bottomAppBarTheme &&
        other.bottomNavigationBarTheme == bottomNavigationBarTheme &&
        other.bottomSheetTheme == bottomSheetTheme &&
        other.buttonTheme == buttonTheme &&
        other.cardTheme == cardTheme &&
        other.checkboxTheme == checkboxTheme &&
        other.chipTheme == chipTheme &&
        other.dataTableTheme == dataTableTheme &&
        other.datePickerTheme == datePickerTheme &&
        other.dialogTheme == dialogTheme &&
        other.dividerTheme == dividerTheme &&
        other.drawerTheme == drawerTheme &&
        other.dropdownMenuTheme == dropdownMenuTheme &&
        other.elevatedButtonTheme == elevatedButtonTheme &&
        other.expansionTileTheme == expansionTileTheme &&
        other.filledButtonTheme == filledButtonTheme &&
        other.floatingActionButtonTheme == floatingActionButtonTheme &&
        other.iconButtonTheme == iconButtonTheme &&
        other.listTileTheme == listTileTheme &&
        other.menuBarTheme == menuBarTheme &&
        other.menuButtonTheme == menuButtonTheme &&
        other.menuTheme == menuTheme &&
        other.navigationBarTheme == navigationBarTheme &&
        other.navigationDrawerTheme == navigationDrawerTheme &&
        other.navigationRailTheme == navigationRailTheme &&
        other.outlinedButtonTheme == outlinedButtonTheme &&
        other.popupMenuTheme == popupMenuTheme &&
        other.progressIndicatorTheme == progressIndicatorTheme &&
        other.radioTheme == radioTheme &&
        other.searchBarTheme == searchBarTheme &&
        other.searchViewTheme == searchViewTheme &&
        other.segmentedButtonTheme == segmentedButtonTheme &&
        other.sliderTheme == sliderTheme &&
        other.snackBarTheme == snackBarTheme &&
        other.switchTheme == switchTheme &&
        other.tabBarTheme == tabBarTheme &&
        other.textButtonTheme == textButtonTheme &&
        other.textSelectionTheme == textSelectionTheme &&
        other.timePickerTheme == timePickerTheme &&
        other.toggleButtonsTheme == toggleButtonsTheme &&
        other.tooltipTheme == tooltipTheme &&
        // DEPRECATED (newest deprecations at the bottom)
        other.buttonBarTheme == buttonBarTheme &&
        other.dialogBackgroundColor == dialogBackgroundColor;
  }

  @override
  int get hashCode {
    final List<Object?> values = <Object?>[
      // For the sanity of the reader, make sure these properties are in the same
      // order in every place that they are separated by section comments (e.g.
      // GENERAL CONFIGURATION). Each section except for deprecations should be
      // alphabetical by symbol name.

      // GENERAL CONFIGURATION
      ...adaptationMap.keys,
      ...adaptationMap.values,
      applyElevationOverlayColor,
      cupertinoOverrideTheme,
      ...extensions.keys,
      ...extensions.values,
      inputDecorationTheme,
      materialTapTargetSize,
      pageTransitionsTheme,
      platform,
      scrollbarTheme,
      splashFactory,
      useMaterial3,
      visualDensity,
      // COLOR
      canvasColor,
      cardColor,
      colorScheme,
      disabledColor,
      dividerColor,
      focusColor,
      highlightColor,
      hintColor,
      hoverColor,
      indicatorColor,
      primaryColor,
      primaryColorDark,
      primaryColorLight,
      scaffoldBackgroundColor,
      secondaryHeaderColor,
      shadowColor,
      splashColor,
      unselectedWidgetColor,
      // TYPOGRAPHY & ICONOGRAPHY
      iconTheme,
      primaryIconTheme,
      primaryTextTheme,
      textTheme,
      typography,
      // COMPONENT THEMES
      actionIconTheme,
      appBarTheme,
      badgeTheme,
      bannerTheme,
      bottomAppBarTheme,
      bottomNavigationBarTheme,
      bottomSheetTheme,
      buttonTheme,
      cardTheme,
      checkboxTheme,
      chipTheme,
      dataTableTheme,
      datePickerTheme,
      dialogTheme,
      dividerTheme,
      drawerTheme,
      dropdownMenuTheme,
      elevatedButtonTheme,
      expansionTileTheme,
      filledButtonTheme,
      floatingActionButtonTheme,
      iconButtonTheme,
      listTileTheme,
      menuBarTheme,
      menuButtonTheme,
      menuTheme,
      navigationBarTheme,
      navigationDrawerTheme,
      navigationRailTheme,
      outlinedButtonTheme,
      popupMenuTheme,
      progressIndicatorTheme,
      radioTheme,
      searchBarTheme,
      searchViewTheme,
      segmentedButtonTheme,
      sliderTheme,
      snackBarTheme,
      switchTheme,
      tabBarTheme,
      textButtonTheme,
      textSelectionTheme,
      timePickerTheme,
      toggleButtonsTheme,
      tooltipTheme,
      // DEPRECATED (newest deprecations at the bottom)
      buttonBarTheme,
      dialogBackgroundColor,
    ];
    return Object.hashAll(values);
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    final ThemeData defaultData = ThemeData.fallback();
    // For the sanity of the reader, make sure these properties are in the same
    // order in every place that they are separated by section comments (e.g.
    // GENERAL CONFIGURATION). Each section except for deprecations should be
    // alphabetical by symbol name.

    // GENERAL CONFIGURATION
    properties.add(
      IterableProperty<Adaptation<dynamic>>(
        'adaptations',
        adaptationMap.values,
        defaultValue: defaultData.adaptationMap.values,
        level: DiagnosticLevel.debug,
      ),
    );
    properties.add(
      DiagnosticsProperty<bool>(
        'applyElevationOverlayColor',
        applyElevationOverlayColor,
        level: DiagnosticLevel.debug,
      ),
    );
    properties.add(
      DiagnosticsProperty<NoDefaultCupertinoThemeData>(
        'cupertinoOverrideTheme',
        cupertinoOverrideTheme,
        defaultValue: defaultData.cupertinoOverrideTheme,
        level: DiagnosticLevel.debug,
      ),
    );
    properties.add(
      IterableProperty<ThemeExtension<dynamic>>(
        'extensions',
        extensions.values,
        defaultValue: defaultData.extensions.values,
        level: DiagnosticLevel.debug,
      ),
    );
    properties.add(
      DiagnosticsProperty<InputDecorationTheme>(
        'inputDecorationTheme',
        inputDecorationTheme,
        level: DiagnosticLevel.debug,
      ),
    );
    properties.add(
      DiagnosticsProperty<MaterialTapTargetSize>(
        'materialTapTargetSize',
        materialTapTargetSize,
        level: DiagnosticLevel.debug,
      ),
    );
    properties.add(
      DiagnosticsProperty<PageTransitionsTheme>(
        'pageTransitionsTheme',
        pageTransitionsTheme,
        level: DiagnosticLevel.debug,
      ),
    );
    properties.add(
      EnumProperty<TargetPlatform>(
        'platform',
        platform,
        defaultValue: defaultTargetPlatform,
        level: DiagnosticLevel.debug,
      ),
    );
    properties.add(
      DiagnosticsProperty<ScrollbarThemeData>(
        'scrollbarTheme',
        scrollbarTheme,
        defaultValue: defaultData.scrollbarTheme,
        level: DiagnosticLevel.debug,
      ),
    );
    properties.add(
      DiagnosticsProperty<InteractiveInkFeatureFactory>(
        'splashFactory',
        splashFactory,
        defaultValue: defaultData.splashFactory,
        level: DiagnosticLevel.debug,
      ),
    );
    properties.add(
      DiagnosticsProperty<bool>(
        'useMaterial3',
        useMaterial3,
        defaultValue: defaultData.useMaterial3,
        level: DiagnosticLevel.debug,
      ),
    );
    properties.add(
      DiagnosticsProperty<VisualDensity>(
        'visualDensity',
        visualDensity,
        defaultValue: defaultData.visualDensity,
        level: DiagnosticLevel.debug,
      ),
    );
    // COLORS
    properties.add(
      ColorProperty(
        'canvasColor',
        canvasColor,
        defaultValue: defaultData.canvasColor,
        level: DiagnosticLevel.debug,
      ),
    );
    properties.add(
      ColorProperty(
        'cardColor',
        cardColor,
        defaultValue: defaultData.cardColor,
        level: DiagnosticLevel.debug,
      ),
    );
    properties.add(
      DiagnosticsProperty<ColorScheme>(
        'colorScheme',
        colorScheme,
        defaultValue: defaultData.colorScheme,
        level: DiagnosticLevel.debug,
      ),
    );
    properties.add(
      ColorProperty(
        'disabledColor',
        disabledColor,
        defaultValue: defaultData.disabledColor,
        level: DiagnosticLevel.debug,
      ),
    );
    properties.add(
      ColorProperty(
        'dividerColor',
        dividerColor,
        defaultValue: defaultData.dividerColor,
        level: DiagnosticLevel.debug,
      ),
    );
    properties.add(
      ColorProperty(
        'focusColor',
        focusColor,
        defaultValue: defaultData.focusColor,
        level: DiagnosticLevel.debug,
      ),
    );
    properties.add(
      ColorProperty(
        'highlightColor',
        highlightColor,
        defaultValue: defaultData.highlightColor,
        level: DiagnosticLevel.debug,
      ),
    );
    properties.add(
      ColorProperty(
        'hintColor',
        hintColor,
        defaultValue: defaultData.hintColor,
        level: DiagnosticLevel.debug,
      ),
    );
    properties.add(
      ColorProperty(
        'hoverColor',
        hoverColor,
        defaultValue: defaultData.hoverColor,
        level: DiagnosticLevel.debug,
      ),
    );
    properties.add(
      ColorProperty(
        'indicatorColor',
        indicatorColor,
        defaultValue: defaultData.indicatorColor,
        level: DiagnosticLevel.debug,
      ),
    );
    properties.add(
      ColorProperty(
        'primaryColorDark',
        primaryColorDark,
        defaultValue: defaultData.primaryColorDark,
        level: DiagnosticLevel.debug,
      ),
    );
    properties.add(
      ColorProperty(
        'primaryColorLight',
        primaryColorLight,
        defaultValue: defaultData.primaryColorLight,
        level: DiagnosticLevel.debug,
      ),
    );
    properties.add(
      ColorProperty(
        'primaryColor',
        primaryColor,
        defaultValue: defaultData.primaryColor,
        level: DiagnosticLevel.debug,
      ),
    );
    properties.add(
      ColorProperty(
        'scaffoldBackgroundColor',
        scaffoldBackgroundColor,
        defaultValue: defaultData.scaffoldBackgroundColor,
        level: DiagnosticLevel.debug,
      ),
    );
    properties.add(
      ColorProperty(
        'secondaryHeaderColor',
        secondaryHeaderColor,
        defaultValue: defaultData.secondaryHeaderColor,
        level: DiagnosticLevel.debug,
      ),
    );
    properties.add(
      ColorProperty(
        'shadowColor',
        shadowColor,
        defaultValue: defaultData.shadowColor,
        level: DiagnosticLevel.debug,
      ),
    );
    properties.add(
      ColorProperty(
        'splashColor',
        splashColor,
        defaultValue: defaultData.splashColor,
        level: DiagnosticLevel.debug,
      ),
    );
    properties.add(
      ColorProperty(
        'unselectedWidgetColor',
        unselectedWidgetColor,
        defaultValue: defaultData.unselectedWidgetColor,
        level: DiagnosticLevel.debug,
      ),
    );
    // TYPOGRAPHY & ICONOGRAPHY
    properties.add(
      DiagnosticsProperty<IconThemeData>('iconTheme', iconTheme, level: DiagnosticLevel.debug),
    );
    properties.add(
      DiagnosticsProperty<IconThemeData>(
        'primaryIconTheme',
        primaryIconTheme,
        level: DiagnosticLevel.debug,
      ),
    );
    properties.add(
      DiagnosticsProperty<TextTheme>(
        'primaryTextTheme',
        primaryTextTheme,
        level: DiagnosticLevel.debug,
      ),
    );
    properties.add(
      DiagnosticsProperty<TextTheme>('textTheme', textTheme, level: DiagnosticLevel.debug),
    );
    properties.add(
      DiagnosticsProperty<Typography>(
        'typography',
        typography,
        defaultValue: defaultData.typography,
        level: DiagnosticLevel.debug,
      ),
    );
    // COMPONENT THEMES
    properties.add(
      DiagnosticsProperty<ActionIconThemeData>(
        'actionIconTheme',
        actionIconTheme,
        level: DiagnosticLevel.debug,
      ),
    );
    properties.add(
      DiagnosticsProperty<AppBarTheme>(
        'appBarTheme',
        appBarTheme,
        defaultValue: defaultData.appBarTheme,
        level: DiagnosticLevel.debug,
      ),
    );
    properties.add(
      DiagnosticsProperty<BadgeThemeData>(
        'badgeTheme',
        badgeTheme,
        defaultValue: defaultData.badgeTheme,
        level: DiagnosticLevel.debug,
      ),
    );
    properties.add(
      DiagnosticsProperty<MaterialBannerThemeData>(
        'bannerTheme',
        bannerTheme,
        defaultValue: defaultData.bannerTheme,
        level: DiagnosticLevel.debug,
      ),
    );
    properties.add(
      DiagnosticsProperty<BottomAppBarTheme>(
        'bottomAppBarTheme',
        bottomAppBarTheme,
        defaultValue: defaultData.bottomAppBarTheme,
        level: DiagnosticLevel.debug,
      ),
    );
    properties.add(
      DiagnosticsProperty<BottomNavigationBarThemeData>(
        'bottomNavigationBarTheme',
        bottomNavigationBarTheme,
        defaultValue: defaultData.bottomNavigationBarTheme,
        level: DiagnosticLevel.debug,
      ),
    );
    properties.add(
      DiagnosticsProperty<BottomSheetThemeData>(
        'bottomSheetTheme',
        bottomSheetTheme,
        defaultValue: defaultData.bottomSheetTheme,
        level: DiagnosticLevel.debug,
      ),
    );
    properties.add(
      DiagnosticsProperty<ButtonThemeData>(
        'buttonTheme',
        buttonTheme,
        level: DiagnosticLevel.debug,
      ),
    );
    properties.add(
      DiagnosticsProperty<CardThemeData>('cardTheme', cardTheme, level: DiagnosticLevel.debug),
    );
    properties.add(
      DiagnosticsProperty<CheckboxThemeData>(
        'checkboxTheme',
        checkboxTheme,
        defaultValue: defaultData.checkboxTheme,
        level: DiagnosticLevel.debug,
      ),
    );
    properties.add(
      DiagnosticsProperty<ChipThemeData>('chipTheme', chipTheme, level: DiagnosticLevel.debug),
    );
    properties.add(
      DiagnosticsProperty<DataTableThemeData>(
        'dataTableTheme',
        dataTableTheme,
        defaultValue: defaultData.dataTableTheme,
        level: DiagnosticLevel.debug,
      ),
    );
    properties.add(
      DiagnosticsProperty<DatePickerThemeData>(
        'datePickerTheme',
        datePickerTheme,
        defaultValue: defaultData.datePickerTheme,
        level: DiagnosticLevel.debug,
      ),
    );
    properties.add(
      DiagnosticsProperty<DialogThemeData>(
        'dialogTheme',
        dialogTheme,
        defaultValue: defaultData.dialogTheme,
        level: DiagnosticLevel.debug,
      ),
    );
    properties.add(
      DiagnosticsProperty<DividerThemeData>(
        'dividerTheme',
        dividerTheme,
        defaultValue: defaultData.dividerTheme,
        level: DiagnosticLevel.debug,
      ),
    );
    properties.add(
      DiagnosticsProperty<DrawerThemeData>(
        'drawerTheme',
        drawerTheme,
        defaultValue: defaultData.drawerTheme,
        level: DiagnosticLevel.debug,
      ),
    );
    properties.add(
      DiagnosticsProperty<DropdownMenuThemeData>(
        'dropdownMenuTheme',
        dropdownMenuTheme,
        defaultValue: defaultData.dropdownMenuTheme,
        level: DiagnosticLevel.debug,
      ),
    );
    properties.add(
      DiagnosticsProperty<ElevatedButtonThemeData>(
        'elevatedButtonTheme',
        elevatedButtonTheme,
        defaultValue: defaultData.elevatedButtonTheme,
        level: DiagnosticLevel.debug,
      ),
    );
    properties.add(
      DiagnosticsProperty<ExpansionTileThemeData>(
        'expansionTileTheme',
        expansionTileTheme,
        level: DiagnosticLevel.debug,
      ),
    );
    properties.add(
      DiagnosticsProperty<FilledButtonThemeData>(
        'filledButtonTheme',
        filledButtonTheme,
        defaultValue: defaultData.filledButtonTheme,
        level: DiagnosticLevel.debug,
      ),
    );
    properties.add(
      DiagnosticsProperty<FloatingActionButtonThemeData>(
        'floatingActionButtonTheme',
        floatingActionButtonTheme,
        defaultValue: defaultData.floatingActionButtonTheme,
        level: DiagnosticLevel.debug,
      ),
    );
    properties.add(
      DiagnosticsProperty<IconButtonThemeData>(
        'iconButtonTheme',
        iconButtonTheme,
        defaultValue: defaultData.iconButtonTheme,
        level: DiagnosticLevel.debug,
      ),
    );
    properties.add(
      DiagnosticsProperty<ListTileThemeData>(
        'listTileTheme',
        listTileTheme,
        defaultValue: defaultData.listTileTheme,
        level: DiagnosticLevel.debug,
      ),
    );
    properties.add(
      DiagnosticsProperty<MenuBarThemeData>(
        'menuBarTheme',
        menuBarTheme,
        defaultValue: defaultData.menuBarTheme,
        level: DiagnosticLevel.debug,
      ),
    );
    properties.add(
      DiagnosticsProperty<MenuButtonThemeData>(
        'menuButtonTheme',
        menuButtonTheme,
        defaultValue: defaultData.menuButtonTheme,
        level: DiagnosticLevel.debug,
      ),
    );
    properties.add(
      DiagnosticsProperty<MenuThemeData>(
        'menuTheme',
        menuTheme,
        defaultValue: defaultData.menuTheme,
        level: DiagnosticLevel.debug,
      ),
    );
    properties.add(
      DiagnosticsProperty<NavigationBarThemeData>(
        'navigationBarTheme',
        navigationBarTheme,
        defaultValue: defaultData.navigationBarTheme,
        level: DiagnosticLevel.debug,
      ),
    );
    properties.add(
      DiagnosticsProperty<NavigationDrawerThemeData>(
        'navigationDrawerTheme',
        navigationDrawerTheme,
        defaultValue: defaultData.navigationDrawerTheme,
        level: DiagnosticLevel.debug,
      ),
    );
    properties.add(
      DiagnosticsProperty<NavigationRailThemeData>(
        'navigationRailTheme',
        navigationRailTheme,
        defaultValue: defaultData.navigationRailTheme,
        level: DiagnosticLevel.debug,
      ),
    );
    properties.add(
      DiagnosticsProperty<OutlinedButtonThemeData>(
        'outlinedButtonTheme',
        outlinedButtonTheme,
        defaultValue: defaultData.outlinedButtonTheme,
        level: DiagnosticLevel.debug,
      ),
    );
    properties.add(
      DiagnosticsProperty<PopupMenuThemeData>(
        'popupMenuTheme',
        popupMenuTheme,
        defaultValue: defaultData.popupMenuTheme,
        level: DiagnosticLevel.debug,
      ),
    );
    properties.add(
      DiagnosticsProperty<ProgressIndicatorThemeData>(
        'progressIndicatorTheme',
        progressIndicatorTheme,
        defaultValue: defaultData.progressIndicatorTheme,
        level: DiagnosticLevel.debug,
      ),
    );
    properties.add(
      DiagnosticsProperty<RadioThemeData>(
        'radioTheme',
        radioTheme,
        defaultValue: defaultData.radioTheme,
        level: DiagnosticLevel.debug,
      ),
    );
    properties.add(
      DiagnosticsProperty<SearchBarThemeData>(
        'searchBarTheme',
        searchBarTheme,
        defaultValue: defaultData.searchBarTheme,
        level: DiagnosticLevel.debug,
      ),
    );
    properties.add(
      DiagnosticsProperty<SearchViewThemeData>(
        'searchViewTheme',
        searchViewTheme,
        defaultValue: defaultData.searchViewTheme,
        level: DiagnosticLevel.debug,
      ),
    );
    properties.add(
      DiagnosticsProperty<SegmentedButtonThemeData>(
        'segmentedButtonTheme',
        segmentedButtonTheme,
        defaultValue: defaultData.segmentedButtonTheme,
        level: DiagnosticLevel.debug,
      ),
    );
    properties.add(
      DiagnosticsProperty<SliderThemeData>(
        'sliderTheme',
        sliderTheme,
        level: DiagnosticLevel.debug,
      ),
    );
    properties.add(
      DiagnosticsProperty<SnackBarThemeData>(
        'snackBarTheme',
        snackBarTheme,
        defaultValue: defaultData.snackBarTheme,
        level: DiagnosticLevel.debug,
      ),
    );
    properties.add(
      DiagnosticsProperty<SwitchThemeData>(
        'switchTheme',
        switchTheme,
        defaultValue: defaultData.switchTheme,
        level: DiagnosticLevel.debug,
      ),
    );
    properties.add(
      DiagnosticsProperty<TabBarThemeData>(
        'tabBarTheme',
        tabBarTheme,
        level: DiagnosticLevel.debug,
      ),
    );
    properties.add(
      DiagnosticsProperty<TextButtonThemeData>(
        'textButtonTheme',
        textButtonTheme,
        defaultValue: defaultData.textButtonTheme,
        level: DiagnosticLevel.debug,
      ),
    );
    properties.add(
      DiagnosticsProperty<TextSelectionThemeData>(
        'textSelectionTheme',
        textSelectionTheme,
        defaultValue: defaultData.textSelectionTheme,
        level: DiagnosticLevel.debug,
      ),
    );
    properties.add(
      DiagnosticsProperty<TimePickerThemeData>(
        'timePickerTheme',
        timePickerTheme,
        defaultValue: defaultData.timePickerTheme,
        level: DiagnosticLevel.debug,
      ),
    );
    properties.add(
      DiagnosticsProperty<ToggleButtonsThemeData>(
        'toggleButtonsTheme',
        toggleButtonsTheme,
        level: DiagnosticLevel.debug,
      ),
    );
    properties.add(
      DiagnosticsProperty<TooltipThemeData>(
        'tooltipTheme',
        tooltipTheme,
        level: DiagnosticLevel.debug,
      ),
    );
    // DEPRECATED (newest deprecations at the bottom)
    properties.add(
      DiagnosticsProperty<ButtonBarThemeData>(
        'buttonBarTheme',
        buttonBarTheme,
        defaultValue: defaultData.buttonBarTheme,
        level: DiagnosticLevel.debug,
      ),
    );
    properties.add(
      ColorProperty(
        'dialogBackgroundColor',
        dialogBackgroundColor,
        defaultValue: defaultData.dialogBackgroundColor,
        level: DiagnosticLevel.debug,
      ),
    );
  }
}

/// A [CupertinoThemeData] that defers unspecified theme attributes to an
/// upstream Material [ThemeData].
///
/// This type of [CupertinoThemeData] is used by the Material [Theme] to
/// harmonize the [CupertinoTheme] with the material theme's colors and text
/// styles.
///
/// In the most basic case, [ThemeData]'s `cupertinoOverrideTheme` is null and
/// descendant Cupertino widgets' styling is derived from the Material theme.
///
/// To override individual parts of the Material-derived Cupertino styling,
/// `cupertinoOverrideTheme`'s construction parameters can be used.
///
/// To completely decouple the Cupertino styling from Material theme derivation,
/// another [CupertinoTheme] widget can be inserted as a descendant of the
/// Material [Theme]. On a [MaterialApp], this can be done using the `builder`
/// parameter on the constructor.
///
/// See also:
///
///  * [CupertinoThemeData], whose null constructor parameters default to
///    reasonable iOS styling defaults rather than harmonizing with a Material
///    theme.
///  * [Theme], widget which inserts a [CupertinoTheme] with this
///    [MaterialBasedCupertinoThemeData].
// This class subclasses CupertinoThemeData rather than composes one because it
// _is_ a CupertinoThemeData with partially altered behavior. e.g. its textTheme
// is from the superclass and based on the primaryColor but the primaryColor
// comes from the Material theme unless overridden.
class MaterialBasedCupertinoThemeData extends CupertinoThemeData {
  /// Create a [MaterialBasedCupertinoThemeData] based on a Material [ThemeData]
  /// and its `cupertinoOverrideTheme`.
  MaterialBasedCupertinoThemeData({required ThemeData materialTheme})
    : this._(
        materialTheme,
        (materialTheme.cupertinoOverrideTheme ?? const CupertinoThemeData()).noDefault(),
      );

  MaterialBasedCupertinoThemeData._(this._materialTheme, this._cupertinoOverrideTheme)
    : // Pass all values to the superclass so Material-agnostic properties
      // like barBackgroundColor can still behave like a normal
      // CupertinoThemeData.
      super.raw(
        _cupertinoOverrideTheme.brightness,
        _cupertinoOverrideTheme.primaryColor,
        _cupertinoOverrideTheme.primaryContrastingColor,
        _cupertinoOverrideTheme.textTheme,
        _cupertinoOverrideTheme.barBackgroundColor,
        _cupertinoOverrideTheme.scaffoldBackgroundColor,
        _cupertinoOverrideTheme.applyThemeToAll,
      );

  final ThemeData _materialTheme;
  final NoDefaultCupertinoThemeData _cupertinoOverrideTheme;

  @override
  Brightness get brightness => _cupertinoOverrideTheme.brightness ?? _materialTheme.brightness;

  @override
  Color get primaryColor =>
      _cupertinoOverrideTheme.primaryColor ?? _materialTheme.colorScheme.primary;

  @override
  Color get primaryContrastingColor =>
      _cupertinoOverrideTheme.primaryContrastingColor ?? _materialTheme.colorScheme.onPrimary;

  @override
  Color get scaffoldBackgroundColor =>
      _cupertinoOverrideTheme.scaffoldBackgroundColor ?? _materialTheme.scaffoldBackgroundColor;

  /// Copies the [ThemeData]'s `cupertinoOverrideTheme`.
  ///
  /// Only the specified override attributes of the [ThemeData]'s
  /// `cupertinoOverrideTheme` and the newly specified parameters are in the
  /// returned [CupertinoThemeData]. No derived attributes from iOS defaults or
  /// from cascaded Material theme attributes are copied.
  ///
  /// This [copyWith] cannot change the base Material [ThemeData]. To change the
  /// base Material [ThemeData], create a new Material [Theme] and use
  /// [ThemeData.copyWith] on the Material [ThemeData] instead.
  @override
  MaterialBasedCupertinoThemeData copyWith({
    Brightness? brightness,
    Color? primaryColor,
    Color? primaryContrastingColor,
    CupertinoTextThemeData? textTheme,
    Color? barBackgroundColor,
    Color? scaffoldBackgroundColor,
    bool? applyThemeToAll,
  }) {
    return MaterialBasedCupertinoThemeData._(
      _materialTheme,
      _cupertinoOverrideTheme.copyWith(
        brightness: brightness,
        primaryColor: primaryColor,
        primaryContrastingColor: primaryContrastingColor,
        textTheme: textTheme,
        barBackgroundColor: barBackgroundColor,
        scaffoldBackgroundColor: scaffoldBackgroundColor,
        applyThemeToAll: applyThemeToAll,
      ),
    );
  }

  @override
  CupertinoThemeData resolveFrom(BuildContext context) {
    // Only the cupertino override theme part will be resolved.
    // If the color comes from the material theme it's not resolved.
    return MaterialBasedCupertinoThemeData._(
      _materialTheme,
      _cupertinoOverrideTheme.resolveFrom(context),
    );
  }
}

/// A class for creating a Material theme with a color scheme based off of the
/// colors from a [CupertinoThemeData]. This is intended to be used only in the
/// case when a Material widget is unable to find a Material theme in the tree,
/// but is able to find a Cupertino theme. Most often this will occur when a
/// Material widget is used inside of a [CupertinoApp].
///
/// Besides the colors, this theme will use all the defaults from Material's
/// [ThemeData], so if further customization is needed, it is best to manually
/// add a Material [Theme] above the [CupertinoApp].
class CupertinoBasedMaterialThemeData {
  /// Creates a Material theme with a color scheme based off of the colors from
  /// a [CupertinoThemeData].
  CupertinoBasedMaterialThemeData({required CupertinoThemeData themeData})
    : materialTheme = ThemeData(
        colorScheme: ColorScheme.fromSeed(
          seedColor: themeData.primaryColor,
          brightness: themeData.brightness ?? Brightness.light,
          primary: themeData.primaryColor,
          onPrimary: themeData.primaryContrastingColor,
        ),
      );

  /// The Material theme data with colors based on an existing [CupertinoThemeData].
  final ThemeData materialTheme;
}

@immutable
class _IdentityThemeDataCacheKey {
  const _IdentityThemeDataCacheKey(this.baseTheme, this.localTextGeometry);

  final ThemeData baseTheme;
  final TextTheme localTextGeometry;

  // Using XOR to make the hash function as fast as possible (e.g. Jenkins is
  // noticeably slower).
  @override
  int get hashCode => identityHashCode(baseTheme) ^ identityHashCode(localTextGeometry);

  @override
  bool operator ==(Object other) {
    // We are explicitly ignoring the possibility that the types might not
    // match in the interests of speed.
    return other is _IdentityThemeDataCacheKey &&
        identical(other.baseTheme, baseTheme) &&
        identical(other.localTextGeometry, localTextGeometry);
  }
}

/// Cache of objects of limited size that uses the first in first out eviction
/// strategy (a.k.a least recently inserted).
///
/// The key that was inserted before all other keys is evicted first, i.e. the
/// one inserted least recently.
class _FifoCache<K, V> {
  _FifoCache(this._maximumSize) : assert(_maximumSize > 0);

  /// In Dart the map literal uses a linked hash-map implementation, whose keys
  /// are stored such that [Map.keys] returns them in the order they were
  /// inserted.
  final Map<K, V> _cache = <K, V>{};

  /// Maximum number of entries to store in the cache.
  ///
  /// Once this many entries have been cached, the entry inserted least recently
  /// is evicted when adding a new entry.
  final int _maximumSize;

  /// Returns the previously cached value for the given key, if available;
  /// if not, calls the given callback to obtain it first.
  V putIfAbsent(K key, V Function() loader) {
    assert(key != null);
    final V? result = _cache[key];
    if (result != null) {
      return result;
    }
    if (_cache.length == _maximumSize) {
      _cache.remove(_cache.keys.first);
    }
    return _cache[key] = loader();
  }
}

/// Defines the visual density of user interface components.
///
/// Density, in the context of a UI, is the vertical and horizontal
/// "compactness" of the components in the UI. It is unitless, since it means
/// different things to different UI components.
///
/// The default for visual densities is zero for both vertical and horizontal
/// densities, which corresponds to the default visual density of components in
/// the Material Design specification. It does not affect text sizes, icon
/// sizes, or padding values.
///
/// For example, for buttons, it affects the spacing around the child of the
/// button. For lists, it affects the distance between baselines of entries in
/// the list. For chips, it only affects the vertical size, not the horizontal
/// size.
///
/// Here are some examples of widgets that respond to density changes:
///
///  * [Checkbox]
///  * [Chip]
///  * [ElevatedButton]
///  * [IconButton]
///  * [InputDecorator] (which gives density support to [TextField], etc.)
///  * [ListTile]
///  * [MaterialButton]
///  * [OutlinedButton]
///  * [Radio]
///  * [RawMaterialButton]
///  * [TextButton]
///
/// See also:
///
///  * [ThemeData.visualDensity], where this property is used to specify the base
///    horizontal density of Material components.
///  * [Material design guidance on density](https://material.io/design/layout/applying-density.html).
@immutable
class VisualDensity with Diagnosticable {
  /// A const constructor for [VisualDensity].
  ///
  /// The [horizontal] and [vertical] arguments must be in the interval between
  /// [minimumDensity] and [maximumDensity], inclusive.
  const VisualDensity({this.horizontal = 0.0, this.vertical = 0.0})
    : assert(vertical <= maximumDensity),
      assert(vertical >= minimumDensity),
      assert(horizontal <= maximumDensity),
      assert(horizontal >= minimumDensity);

  /// The minimum allowed density.
  static const double minimumDensity = -4.0;

  /// The maximum allowed density.
  static const double maximumDensity = 4.0;

  /// The default profile for [VisualDensity] in [ThemeData].
  ///
  /// This default value represents a visual density that is less dense than
  /// either [comfortable] or [compact], and corresponds to density values of
  /// zero in both axes.
  static const VisualDensity standard = VisualDensity();

  /// The profile for a "comfortable" interpretation of [VisualDensity].
  ///
  /// Individual components will interpret the density value independently,
  /// making themselves more visually dense than [standard] and less dense than
  /// [compact] to different degrees based on the Material Design specification
  /// of the "comfortable" setting for their particular use case.
  ///
  /// It corresponds to a density value of -1 in both axes.
  static const VisualDensity comfortable = VisualDensity(horizontal: -1.0, vertical: -1.0);

  /// The profile for a "compact" interpretation of [VisualDensity].
  ///
  /// Individual components will interpret the density value independently,
  /// making themselves more visually dense than [standard] and [comfortable] to
  /// different degrees based on the Material Design specification of the
  /// "comfortable" setting for their particular use case.
  ///
  /// It corresponds to a density value of -2 in both axes.
  static const VisualDensity compact = VisualDensity(horizontal: -2.0, vertical: -2.0);

  /// Returns a [VisualDensity] that is adaptive based on the current platform
  /// on which the framework is executing, from [defaultTargetPlatform].
  ///
  /// When [defaultTargetPlatform] is a desktop platform, this returns
  /// [compact], and for other platforms, it returns a default-constructed
  /// [VisualDensity].
  ///
  /// See also:
  ///
  /// * [defaultDensityForPlatform] which returns a [VisualDensity] that is
  ///   adaptive based on the platform given to it.
  /// * [defaultTargetPlatform] which returns the platform on which the
  ///   framework is currently executing.
  static VisualDensity get adaptivePlatformDensity =>
      defaultDensityForPlatform(defaultTargetPlatform);

  /// Returns a [VisualDensity] that is adaptive based on the given [platform].
  ///
  /// For desktop platforms, this returns [compact], and for other platforms, it
  /// returns a default-constructed [VisualDensity].
  ///
  /// See also:
  ///
  /// * [adaptivePlatformDensity] which returns a [VisualDensity] that is
  ///   adaptive based on [defaultTargetPlatform].
  static VisualDensity defaultDensityForPlatform(TargetPlatform platform) {
    return switch (platform) {
      TargetPlatform.android || TargetPlatform.iOS || TargetPlatform.fuchsia => standard,
      TargetPlatform.linux || TargetPlatform.macOS || TargetPlatform.windows => compact,
    };
  }

  /// Copy the current [VisualDensity] with the given values replacing the
  /// current values.
  VisualDensity copyWith({double? horizontal, double? vertical}) {
    return VisualDensity(
      horizontal: horizontal ?? this.horizontal,
      vertical: vertical ?? this.vertical,
    );
  }

  /// The horizontal visual density of UI components.
  ///
  /// This property affects only the horizontal spacing between and within
  /// components, to allow for different UI visual densities. It does not affect
  /// text sizes, icon sizes, or padding values. The default value is 0.0,
  /// corresponding to the metrics specified in the Material Design
  /// specification. The value can range from [minimumDensity] to
  /// [maximumDensity], inclusive.
  ///
  /// See also:
  ///
  ///  * [ThemeData.visualDensity], where this property is used to specify the base
  ///    horizontal density of Material components.
  ///  * [Material design guidance on density](https://material.io/design/layout/applying-density.html).
  final double horizontal;

  /// The vertical visual density of UI components.
  ///
  /// This property affects only the vertical spacing between and within
  /// components, to allow for different UI visual densities. It does not affect
  /// text sizes, icon sizes, or padding values. The default value is 0.0,
  /// corresponding to the metrics specified in the Material Design
  /// specification. The value can range from [minimumDensity] to
  /// [maximumDensity], inclusive.
  ///
  /// See also:
  ///
  ///  * [ThemeData.visualDensity], where this property is used to specify the base
  ///    vertical density of Material components.
  ///  * [Material design guidance on density](https://material.io/design/layout/applying-density.html).
  final double vertical;

  /// The base adjustment in logical pixels of the visual density of UI components.
  ///
  /// The input density values are multiplied by a constant to arrive at a base
  /// size adjustment that fits Material Design guidelines.
  ///
  /// Individual components may adjust this value based upon their own
  /// individual interpretation of density.
  Offset get baseSizeAdjustment {
    // The number of logical pixels represented by an increase or decrease in
    // density by one. The Material Design guidelines say to increment/decrement
    // sizes in terms of four pixel increments.
    const double interval = 4.0;

    return Offset(horizontal, vertical) * interval;
  }

  /// Linearly interpolate between two densities.
  static VisualDensity lerp(VisualDensity a, VisualDensity b, double t) {
    if (identical(a, b)) {
      return a;
    }
    return VisualDensity(
      horizontal: lerpDouble(a.horizontal, b.horizontal, t)!,
      vertical: lerpDouble(a.vertical, b.vertical, t)!,
    );
  }

  /// Return a copy of [constraints] whose minimum width and height have been
  /// updated with the [baseSizeAdjustment].
  ///
  /// The resulting minWidth and minHeight values are clamped to not exceed the
  /// maxWidth and maxHeight values, respectively.
  BoxConstraints effectiveConstraints(BoxConstraints constraints) {
    assert(constraints.debugAssertIsValid());
    return constraints.copyWith(
      minWidth: clampDouble(
        constraints.minWidth + baseSizeAdjustment.dx,
        0.0,
        constraints.maxWidth,
      ),
      minHeight: clampDouble(
        constraints.minHeight + baseSizeAdjustment.dy,
        0.0,
        constraints.maxHeight,
      ),
    );
  }

  @override
  bool operator ==(Object other) {
    if (other.runtimeType != runtimeType) {
      return false;
    }
    return other is VisualDensity && other.horizontal == horizontal && other.vertical == vertical;
  }

  @override
  int get hashCode => Object.hash(horizontal, vertical);

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties.add(DoubleProperty('horizontal', horizontal, defaultValue: 0.0));
    properties.add(DoubleProperty('vertical', vertical, defaultValue: 0.0));
  }

  @override
  String toStringShort() {
    return '${super.toStringShort()}(h: ${debugFormatDouble(horizontal)}, v: ${debugFormatDouble(vertical)})';
  }
}

// BEGIN GENERATED TOKEN PROPERTIES - ColorScheme

// Do not edit by hand. The code between the "BEGIN GENERATED" and
// "END GENERATED" comments are generated from data in the Material
// Design token database by the script:
//   dev/tools/gen_defaults/bin/gen_defaults.dart.

// dart format off
const ColorScheme _colorSchemeLightM3 = ColorScheme(
  brightness: Brightness.light,
  primary: Color(0xFF6750A4),
  onPrimary: Color(0xFFFFFFFF),
  primaryContainer: Color(0xFFEADDFF),
  onPrimaryContainer: Color(0xFF4F378B),
  primaryFixed: Color(0xFFEADDFF),
  primaryFixedDim: Color(0xFFD0BCFF),
  onPrimaryFixed: Color(0xFF21005D),
  onPrimaryFixedVariant: Color(0xFF4F378B),
  secondary: Color(0xFF625B71),
  onSecondary: Color(0xFFFFFFFF),
  secondaryContainer: Color(0xFFE8DEF8),
  onSecondaryContainer: Color(0xFF4A4458),
  secondaryFixed: Color(0xFFE8DEF8),
  secondaryFixedDim: Color(0xFFCCC2DC),
  onSecondaryFixed: Color(0xFF1D192B),
  onSecondaryFixedVariant: Color(0xFF4A4458),
  tertiary: Color(0xFF7D5260),
  onTertiary: Color(0xFFFFFFFF),
  tertiaryContainer: Color(0xFFFFD8E4),
  onTertiaryContainer: Color(0xFF633B48),
  tertiaryFixed: Color(0xFFFFD8E4),
  tertiaryFixedDim: Color(0xFFEFB8C8),
  onTertiaryFixed: Color(0xFF31111D),
  onTertiaryFixedVariant: Color(0xFF633B48),
  error: Color(0xFFB3261E),
  onError: Color(0xFFFFFFFF),
  errorContainer: Color(0xFFF9DEDC),
  onErrorContainer: Color(0xFF8C1D18),
  background: Color(0xFFFEF7FF),
  onBackground: Color(0xFF1D1B20),
  surface: Color(0xFFFEF7FF),
  surfaceBright: Color(0xFFFEF7FF),
  surfaceContainerLowest: Color(0xFFFFFFFF),
  surfaceContainerLow: Color(0xFFF7F2FA),
  surfaceContainer: Color(0xFFF3EDF7),
  surfaceContainerHigh: Color(0xFFECE6F0),
  surfaceContainerHighest: Color(0xFFE6E0E9),
  surfaceDim: Color(0xFFDED8E1),
  onSurface: Color(0xFF1D1B20),
  surfaceVariant: Color(0xFFE7E0EC),
  onSurfaceVariant: Color(0xFF49454F),
  outline: Color(0xFF79747E),
  outlineVariant: Color(0xFFCAC4D0),
  shadow: Color(0xFF000000),
  scrim: Color(0xFF000000),
  inverseSurface: Color(0xFF322F35),
  onInverseSurface: Color(0xFFF5EFF7),
  inversePrimary: Color(0xFFD0BCFF),
  // The surfaceTint color is set to the same color as the primary.
  surfaceTint: Color(0xFF6750A4),
);

const ColorScheme _colorSchemeDarkM3 = ColorScheme(
  brightness: Brightness.dark,
  primary: Color(0xFFD0BCFF),
  onPrimary: Color(0xFF381E72),
  primaryContainer: Color(0xFF4F378B),
  onPrimaryContainer: Color(0xFFEADDFF),
  primaryFixed: Color(0xFFEADDFF),
  primaryFixedDim: Color(0xFFD0BCFF),
  onPrimaryFixed: Color(0xFF21005D),
  onPrimaryFixedVariant: Color(0xFF4F378B),
  secondary: Color(0xFFCCC2DC),
  onSecondary: Color(0xFF332D41),
  secondaryContainer: Color(0xFF4A4458),
  onSecondaryContainer: Color(0xFFE8DEF8),
  secondaryFixed: Color(0xFFE8DEF8),
  secondaryFixedDim: Color(0xFFCCC2DC),
  onSecondaryFixed: Color(0xFF1D192B),
  onSecondaryFixedVariant: Color(0xFF4A4458),
  tertiary: Color(0xFFEFB8C8),
  onTertiary: Color(0xFF492532),
  tertiaryContainer: Color(0xFF633B48),
  onTertiaryContainer: Color(0xFFFFD8E4),
  tertiaryFixed: Color(0xFFFFD8E4),
  tertiaryFixedDim: Color(0xFFEFB8C8),
  onTertiaryFixed: Color(0xFF31111D),
  onTertiaryFixedVariant: Color(0xFF633B48),
  error: Color(0xFFF2B8B5),
  onError: Color(0xFF601410),
  errorContainer: Color(0xFF8C1D18),
  onErrorContainer: Color(0xFFF9DEDC),
  background: Color(0xFF141218),
  onBackground: Color(0xFFE6E0E9),
  surface: Color(0xFF141218),
  surfaceBright: Color(0xFF3B383E),
  surfaceContainerLowest: Color(0xFF0F0D13),
  surfaceContainerLow: Color(0xFF1D1B20),
  surfaceContainer: Color(0xFF211F26),
  surfaceContainerHigh: Color(0xFF2B2930),
  surfaceContainerHighest: Color(0xFF36343B),
  surfaceDim: Color(0xFF141218),
  onSurface: Color(0xFFE6E0E9),
  surfaceVariant: Color(0xFF49454F),
  onSurfaceVariant: Color(0xFFCAC4D0),
  outline: Color(0xFF938F99),
  outlineVariant: Color(0xFF49454F),
  shadow: Color(0xFF000000),
  scrim: Color(0xFF000000),
  inverseSurface: Color(0xFFE6E0E9),
  onInverseSurface: Color(0xFF322F35),
  inversePrimary: Color(0xFF6750A4),
  // The surfaceTint color is set to the same color as the primary.
  surfaceTint: Color(0xFFD0BCFF),
);
// dart format on

// END GENERATED TOKEN PROPERTIES - ColorScheme


--- File Index 2: packages/flutter/lib/src/material/theme.dart ---
// Copyright 2014 The Flutter Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

/// @docImport 'app.dart';
/// @docImport 'color_scheme.dart';
/// @docImport 'text_theme.dart';
library;

import 'package:flutter/cupertino.dart';
import 'package:flutter/foundation.dart';

import 'material_localizations.dart';
import 'theme_data.dart';
import 'typography.dart';

export 'theme_data.dart' show Brightness, ThemeData;

/// The duration over which theme changes animate by default.
const Duration kThemeAnimationDuration = Duration(milliseconds: 200);

/// Applies a theme to descendant widgets.
///
/// A theme describes the colors and typographic choices of an application.
///
/// {@youtube 560 315 https://www.youtube.com/watch?v=oTvQDJOBXmM}
///
/// Descendant widgets obtain the current theme's [ThemeData] object using
/// [Theme.of]. When a widget uses [Theme.of], it is automatically rebuilt if
/// the theme later changes, so that the changes can be applied.
///
/// The [Theme] widget implies an [IconTheme] widget, set to the value of the
/// [ThemeData.iconTheme] of the [data] for the [Theme].
///
/// See also:
///
///  * [ThemeData], which describes the actual configuration of a theme.
///  * [AnimatedTheme], which animates the [ThemeData] when it changes rather
///    than changing the theme all at once.
///  * [MaterialApp], which includes an [AnimatedTheme] widget configured via
///    the [MaterialApp.theme] argument.
class Theme extends StatelessWidget {
  /// Applies the given theme [data] to [child].
  const Theme({super.key, required this.data, required this.child});

  /// Specifies the color and typography values for descendant widgets.
  final ThemeData data;

  /// The widget below this widget in the tree.
  ///
  /// {@macro flutter.widgets.ProxyWidget.child}
  final Widget child;

  static final ThemeData _kFallbackTheme = ThemeData.fallback();

  /// The data from the closest [Theme] instance that encloses the given
  /// context.
  ///
  /// If the given context is enclosed in a [Localizations] widget providing
  /// [MaterialLocalizations], the returned data is localized according to the
  /// nearest available [MaterialLocalizations].
  ///
  /// Defaults to [ThemeData.fallback] if there is no [Theme] in the given
  /// build context.
  ///
  /// Typical usage is as follows:
  ///
  /// ```dart
  /// @override
  /// Widget build(BuildContext context) {
  ///   return Text(
  ///     'Example',
  ///     style: Theme.of(context).textTheme.titleLarge,
  ///   );
  /// }
  /// ```
  ///
  /// When the [Theme] is actually created in the same `build` function
  /// (possibly indirectly, e.g. as part of a [MaterialApp]), the `context`
  /// argument to the `build` function can't be used to find the [Theme] (since
  /// it's "above" the widget being returned). In such cases, the following
  /// technique with a [Builder] can be used to provide a new scope with a
  /// [BuildContext] that is "under" the [Theme]:
  ///
  /// ```dart
  /// @override
  /// Widget build(BuildContext context) {
  ///   return MaterialApp(
  ///     theme: ThemeData.light(),
  ///     home: Builder(
  ///       // Create an inner BuildContext so that we can refer to
  ///       // the Theme with Theme.of().
  ///       builder: (BuildContext context) {
  ///         return Center(
  ///           child: Text(
  ///             'Example',
  ///             style: Theme.of(context).textTheme.titleLarge,
  ///           ),
  ///         );
  ///       },
  ///     ),
  ///   );
  /// }
  /// ```
  ///
  /// See also:
  ///
  /// * [ColorScheme.of], a convenience method that returns [ThemeData.colorScheme]
  ///   from the closest [Theme] ancestor. (equivalent to `Theme.of(context).colorScheme`).
  /// * [TextTheme.of], a convenience method that returns [ThemeData.textTheme]
  ///   from the closest [Theme] ancestor. (equivalent to `Theme.of(context).textTheme`).
  /// * [IconTheme.of], that returns [ThemeData.iconTheme] from the closest [Theme] or
  ///   [IconThemeData.fallback] if there is no [IconTheme] ancestor.
  static ThemeData of(BuildContext context) {
    final _InheritedTheme? inheritedTheme =
        context.dependOnInheritedWidgetOfExactType<_InheritedTheme>();
    final MaterialLocalizations? localizations = Localizations.of<MaterialLocalizations>(
      context,
      MaterialLocalizations,
    );
    final ScriptCategory category = localizations?.scriptCategory ?? ScriptCategory.englishLike;
    final InheritedCupertinoTheme? inheritedCupertinoTheme =
        context.dependOnInheritedWidgetOfExactType<InheritedCupertinoTheme>();
    final ThemeData theme =
        inheritedTheme?.theme.data ??
        (inheritedCupertinoTheme != null
            ? CupertinoBasedMaterialThemeData(
              themeData: inheritedCupertinoTheme.theme.data,
            ).materialTheme
            : _kFallbackTheme);
    return ThemeData.localize(theme, theme.typography.geometryThemeFor(category));
  }

  // The inherited themes in widgets library can not infer their values from
  // Theme in material library. Wraps the child with these inherited themes to
  // overrides their values directly.
  Widget _wrapsWidgetThemes(BuildContext context, Widget child) {
    final DefaultSelectionStyle selectionStyle = DefaultSelectionStyle.of(context);
    return IconTheme(
      data: data.iconTheme,
      child: DefaultSelectionStyle(
        selectionColor: data.textSelectionTheme.selectionColor ?? selectionStyle.selectionColor,
        cursorColor: data.textSelectionTheme.cursorColor ?? selectionStyle.cursorColor,
        child: child,
      ),
    );
  }

  CupertinoThemeData _inheritedCupertinoThemeData(BuildContext context) {
    final InheritedCupertinoTheme? inheritedTheme =
        context.dependOnInheritedWidgetOfExactType<InheritedCupertinoTheme>();
    return (inheritedTheme?.theme.data ?? MaterialBasedCupertinoThemeData(materialTheme: data))
        .resolveFrom(context);
  }

  @override
  Widget build(BuildContext context) {
    return _InheritedTheme(
      theme: this,
      child: CupertinoTheme(
        // If a CupertinoThemeData doesn't exist, we're using a
        // MaterialBasedCupertinoThemeData here instead of a CupertinoThemeData
        // because it defers some properties to the Material ThemeData.
        data: _inheritedCupertinoThemeData(context),
        child: _wrapsWidgetThemes(context, child),
      ),
    );
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties.add(DiagnosticsProperty<ThemeData>('data', data, showName: false));
  }
}

class _InheritedTheme extends InheritedTheme {
  const _InheritedTheme({required this.theme, required super.child});

  final Theme theme;

  @override
  Widget wrap(BuildContext context, Widget child) {
    return Theme(data: theme.data, child: child);
  }

  @override
  bool updateShouldNotify(_InheritedTheme old) => theme.data != old.theme.data;
}

/// An interpolation between two [ThemeData]s.
///
/// This class specializes the interpolation of [Tween<ThemeData>] to call the
/// [ThemeData.lerp] method.
///
/// See [Tween] for a discussion on how to use interpolation objects.
class ThemeDataTween extends Tween<ThemeData> {
  /// Creates a [ThemeData] tween.
  ///
  /// The [begin] and [end] properties must be non-null before the tween is
  /// first used, but the arguments can be null if the values are going to be
  /// filled in later.
  ThemeDataTween({super.begin, super.end});

  @override
  ThemeData lerp(double t) => ThemeData.lerp(begin!, end!, t);
}

/// Animated version of [Theme] which automatically transitions the colors,
/// etc, over a given duration whenever the given theme changes.
///
/// Here's an illustration of what using this widget looks like, using a [curve]
/// of [Curves.elasticInOut].
/// {@animation 250 266 https://flutter.github.io/assets-for-api-docs/assets/widgets/animated_theme.mp4}
///
/// See also:
///
///  * [Theme], which [AnimatedTheme] uses to actually apply the interpolated
///    theme.
///  * [ThemeData], which describes the actual configuration of a theme.
///  * [MaterialApp], which includes an [AnimatedTheme] widget configured via
///    the [MaterialApp.theme] argument.
class AnimatedTheme extends ImplicitlyAnimatedWidget {
  /// Creates an animated theme.
  ///
  /// By default, the theme transition uses a linear curve.
  const AnimatedTheme({
    super.key,
    required this.data,
    super.curve,
    super.duration = kThemeAnimationDuration,
    super.onEnd,
    required this.child,
  });

  /// Specifies the color and typography values for descendant widgets.
  final ThemeData data;

  /// The widget below this widget in the tree.
  ///
  /// {@macro flutter.widgets.ProxyWidget.child}
  final Widget child;

  @override
  AnimatedWidgetBaseState<AnimatedTheme> createState() => _AnimatedThemeState();
}

class _AnimatedThemeState extends AnimatedWidgetBaseState<AnimatedTheme> {
  ThemeDataTween? _data;

  @override
  void forEachTween(TweenVisitor<dynamic> visitor) {
    _data =
        visitor(_data, widget.data, (dynamic value) => ThemeDataTween(begin: value as ThemeData))!
            as ThemeDataTween;
  }

  @override
  Widget build(BuildContext context) {
    return Theme(data: _data!.evaluate(animation), child: widget.child);
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder description) {
    super.debugFillProperties(description);
    description.add(
      DiagnosticsProperty<ThemeDataTween>('data', _data, showName: false, defaultValue: null),
    );
  }
}




Analyze the codebase context.
Identify the top 5-10 core most important abstractions to help those new to the codebase.

For each abstraction, provide:
1. A concise `name`.
2. A beginner-friendly `description` explaining what it is with a simple analogy, in around 100 words.
3. A list of relevant `file_indices` (integers) using the format `idx # path/comment`.

List of file indices and paths present in the context:
- 0 # packages/flutter/lib/src/material/color_scheme.dart
- 1 # packages/flutter/lib/src/material/theme_data.dart
- 2 # packages/flutter/lib/src/material/theme.dart

Format the output as a YAML list of dictionaries:

```yaml
- name: |
    Query Processing
  description: |
    Explains what the abstraction does.
    It's like a central dispatcher routing requests.
  file_indices:
    - 0 # path/to/file1.py
    - 3 # path/to/related.py
- name: |
    Query Optimization
  description: |
    Another core concept, similar to a blueprint for objects.
  file_indices:
    - 5 # path/to/another.js
# ... up to 10 abstractions
```
2025-05-28 18:21:15,862 - INFO - RESPONSE: ```yaml
- name: |
    ThemeData
  description: |
    Imagine `ThemeData` is the master plan for how your app looks. It's a big container holding all the little details about colors, fonts, button styles, and how components should behave. Think of it as the blueprint that dictates the overall visual style of your application, like choosing the color palette and font family for an entire house.
  file_indices:
    - 1 # packages/flutter/lib/src/material/theme_data.dart
    - 2 # packages/flutter/lib/src/material/theme.dart
- name: |
    ColorScheme
  description: |
    If `ThemeData` is the master plan, `ColorScheme` is the specific color palette within that plan. It defines a set of named color roles like "primary," "secondary," and "error," ensuring that the colors you use are harmonious and accessible. Picture it like choosing the paint colors for each room in the house blueprint, making sure they all work together nicely.
  file_indices:
    - 0 # packages/flutter/lib/src/material/color_scheme.dart
    - 1 # packages/flutter/lib/src/material/theme_data.dart
    - 2 # packages/flutter/lib/src/material/theme.dart
- name: |
    Theme
  description: |
    `Theme` is the widget that takes your `ThemeData` master plan and applies it to a part of your app's user interface. When you wrap a widget tree with a `Theme` widget, all the widgets inside that tree will use the styles defined in the provided `ThemeData`. It's like applying the paint colors you chose from the palette to the actual rooms in your house.
  file_indices:
    - 1 # packages/flutter/lib/src/material/theme_data.dart
    - 2 # packages/flutter/lib/src/material/theme.dart
- name: |
    ThemeExtension
  description: |
    `ThemeExtension` is like adding extra, custom information to your master plan (`ThemeData`). If the default `ThemeData` doesn't cover everything you need to style, you can create your own extension to include specific properties (like custom colors or text styles) that are unique to your app. This is like adding notes to your house blueprint for special features not included in the standard plan.
  file_indices:
    - 1 # packages/flutter/lib/src/material/theme_data.dart
    - 2 # packages/flutter/lib/src/material/theme.dart
- name: |
    MaterialTapTargetSize
  description: |
    `MaterialTapTargetSize` is a simple setting within the `ThemeData` master plan that affects how interactive elements like buttons and checkboxes respond to taps. It helps ensure that these elements are easy to press, especially for users with accessibility needs. Think of it as a rule in the house blueprint that dictates how big light switches should be to make them easy to use.
  file_indices:
    - 1 # packages/flutter/lib/src/material/theme_data.dart
- name: |
    DynamicSchemeVariant
  description: |
    This is a fancy way to describe different styles of color palettes you can generate automatically from a single "seed" color. It allows you to create variations like vibrant, muted, or even monochrome schemes based on one initial color. It's like having different pre-set filters you can apply to your main paint color to get a variety of coordinating looks.
  file_indices:
    - 0 # packages/flutter/lib/src/material/color_scheme.dart
- name: |
    VisualDensity
  description: |
    `VisualDensity` controls the "compactness" of some UI elements. It subtly adjusts spacing to make things feel more dense or spread out, without changing text or icon sizes directly. This is like having a setting in your blueprint for how closely furniture should be placed in certain rooms to achieve a specific feel.
  file_indices:
    - 1 # packages/flutter/lib/src/material/theme_data.dart
```
2025-05-28 18:21:15,873 - INFO - PROMPT: 
Based on the following abstractions and relevant code snippets from the project `flutter`:

List of Abstraction Indices and Names:
0 # ThemeData

1 # ColorScheme

2 # Theme

3 # ThemeExtension

4 # MaterialTapTargetSize

5 # DynamicSchemeVariant

6 # VisualDensity


Context (Abstractions, Descriptions, Code):
Identified Abstractions:\n- Index 0: ThemeData
 (Relevant file indices: [1, 2])\n  Description: Imagine `ThemeData` is the master plan for how your app looks. It's a big container holding all the little details about colors, fonts, button styles, and how components should behave. Think of it as the blueprint that dictates the overall visual style of your application, like choosing the color palette and font family for an entire house.
\n- Index 1: ColorScheme
 (Relevant file indices: [0, 1, 2])\n  Description: If `ThemeData` is the master plan, `ColorScheme` is the specific color palette within that plan. It defines a set of named color roles like "primary," "secondary," and "error," ensuring that the colors you use are harmonious and accessible. Picture it like choosing the paint colors for each room in the house blueprint, making sure they all work together nicely.
\n- Index 2: Theme
 (Relevant file indices: [1, 2])\n  Description: `Theme` is the widget that takes your `ThemeData` master plan and applies it to a part of your app's user interface. When you wrap a widget tree with a `Theme` widget, all the widgets inside that tree will use the styles defined in the provided `ThemeData`. It's like applying the paint colors you chose from the palette to the actual rooms in your house.
\n- Index 3: ThemeExtension
 (Relevant file indices: [1, 2])\n  Description: `ThemeExtension` is like adding extra, custom information to your master plan (`ThemeData`). If the default `ThemeData` doesn't cover everything you need to style, you can create your own extension to include specific properties (like custom colors or text styles) that are unique to your app. This is like adding notes to your house blueprint for special features not included in the standard plan.
\n- Index 4: MaterialTapTargetSize
 (Relevant file indices: [1])\n  Description: `MaterialTapTargetSize` is a simple setting within the `ThemeData` master plan that affects how interactive elements like buttons and checkboxes respond to taps. It helps ensure that these elements are easy to press, especially for users with accessibility needs. Think of it as a rule in the house blueprint that dictates how big light switches should be to make them easy to use.
\n- Index 5: DynamicSchemeVariant
 (Relevant file indices: [0])\n  Description: This is a fancy way to describe different styles of color palettes you can generate automatically from a single "seed" color. It allows you to create variations like vibrant, muted, or even monochrome schemes based on one initial color. It's like having different pre-set filters you can apply to your main paint color to get a variety of coordinating looks.
\n- Index 6: VisualDensity
 (Relevant file indices: [1])\n  Description: `VisualDensity` controls the "compactness" of some UI elements. It subtly adjusts spacing to make things feel more dense or spread out, without changing text or icon sizes directly. This is like having a setting in your blueprint for how closely furniture should be placed in certain rooms to achieve a specific feel.
\n\nRelevant File Snippets (Referenced by Index and Path):\n--- File: 0 # packages/flutter/lib/src/material/color_scheme.dart ---\n// Copyright 2014 The Flutter Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

/// @docImport 'input_decorator.dart';
/// @docImport 'scaffold.dart';
library;

import 'dart:async';
import 'dart:ui' as ui;

import 'package:flutter/foundation.dart';
import 'package:flutter/widgets.dart';
import 'package:material_color_utilities/material_color_utilities.dart';

import 'colors.dart';
import 'theme.dart';

/// The algorithm used to construct a [ColorScheme] in [ColorScheme.fromSeed].
///
/// The `tonalSpot` variant builds default Material scheme colors. These colors are
/// mapped to light or dark tones to achieve visually accessible color
/// pairings with sufficient contrast between foreground and background elements.
///
/// In some cases, the tones can prevent colors from appearing as intended,
/// such as when a color is too light to offer enough contrast for accessibility.
/// Color fidelity (`DynamicSchemeVariant.fidelity`) is a feature that adjusts
/// tones in these cases to produce the intended visual results without harming
/// visual contrast.
enum DynamicSchemeVariant {
  /// Default for Material theme colors. Builds pastel palettes with a low chroma.
  tonalSpot,

  /// The resulting color palettes match seed color, even if the seed color
  /// is very bright (high chroma).
  fidelity,

  /// All colors are grayscale, no chroma.
  monochrome,

  /// Close to grayscale, a hint of chroma.
  neutral,

  /// Pastel colors, high chroma palettes. The primary palette's chroma is at
  /// maximum. Use `fidelity` instead if tokens should alter their tone to match
  /// the palette vibrancy.
  vibrant,

  /// Pastel colors, medium chroma palettes. The primary palette's hue is
  /// different from the seed color, for variety.
  expressive,

  /// Almost identical to `fidelity`. Tokens and palettes match the seed color.
  /// [ColorScheme.primaryContainer] is the seed color, adjusted to ensure
  /// contrast with surfaces. The tertiary palette is analogue of the seed color.
  content,

  /// A playful theme - the seed color's hue does not appear in the theme.
  rainbow,

  /// A playful theme - the seed color's hue does not appear in the theme.
  fruitSalad,
}

/// {@template flutter.material.color_scheme.ColorScheme}
/// A set of 45 colors based on the
/// [Material spec](https://m3.material.io/styles/color/the-color-system/color-roles)
/// that can be used to configure the color properties of most components.
/// {@endtemplate}
///
/// ### Colors in Material 3
///
/// {@macro flutter.material.colors.colorRoles}
///
/// The main accent color groups in the scheme are [primary], [secondary],
/// and [tertiary].
///
/// * Primary colors are used for key components across the UI, such as the FAB,
///   prominent buttons, and active states.
///
/// * Secondary colors are used for less prominent components in the UI, such as
///   filter chips, while expanding the opportunity for color expression.
///
/// * Tertiary colors are used for contrasting accents that can be used to
///   balance primary and secondary colors or bring heightened attention to
///   an element, such as an input field. The tertiary colors are left
///   for makers to use at their discretion and are intended to support
///   broader color expression in products.
///
/// Each accent color group (primary, secondary and tertiary) includes '-Fixed'
/// '-Dim' color roles, such as [primaryFixed] and [primaryFixedDim]. Fixed roles
/// are appropriate to use in places where Container roles are normally used,
/// but they stay the same color between light and dark themes. The '-Dim' roles
/// provide a stronger, more emphasized color with the same fixed behavior.
///
/// The remaining colors of the scheme are composed of neutral colors used for
/// backgrounds and surfaces, as well as specific colors for errors, dividers
/// and shadows. Surface colors are used for backgrounds and large, low-emphasis
/// areas of the screen.
///
/// Material 3 also introduces tone-based surfaces and surface containers.
/// They replace the old opacity-based model which applied a tinted overlay on
/// top of surfaces based on their elevation. These colors include: [surfaceBright],
/// [surfaceDim], [surfaceContainerLowest], [surfaceContainerLow], [surfaceContainer],
/// [surfaceContainerHigh], and [surfaceContainerHighest].
///
/// Many of the colors have matching 'on' colors, which are used for drawing
/// content on top of the matching color. For example, if something is using
/// [primary] for a background color, [onPrimary] would be used to paint text
/// and icons on top of it. For this reason, the 'on' colors should have a
/// contrast ratio with their matching colors of at least 4.5:1 in order to
/// be readable. On '-FixedVariant' roles, such as [onPrimaryFixedVariant],
/// also have the same color between light and dark themes, but compared
/// with on '-Fixed' roles, such as [onPrimaryFixed], they provide a
/// lower-emphasis option for text and icons.
///
/// {@tool dartpad}
/// This example shows all Material [ColorScheme] roles in light and dark
/// brightnesses.
///
/// ** See code in examples/api/lib/material/color_scheme/color_scheme.0.dart **
/// {@end-tool}
///
/// ### Setting Colors in Flutter
///
///{@macro flutter.material.colors.settingColors}
@immutable
class ColorScheme with Diagnosticable {
  /// Create a ColorScheme instance from the given colors.
  ///
  /// [ColorScheme.fromSeed] can be used as a simpler way to create a full
  /// color scheme derived from a single seed color.
  ///
  /// For the color parameters that are nullable, it is still recommended
  /// that applications provide values for them. They are only nullable due
  /// to backwards compatibility concerns.
  ///
  /// If a color is not provided, the closest fallback color from the given
  /// colors will be used for it (e.g. [primaryContainer] will default
  /// to [primary]). Material Design 3 makes use of these colors for many
  /// component defaults, so for the best results the application should
  /// supply colors for all the parameters. An easy way to ensure this is to
  /// use [ColorScheme.fromSeed] to generate a full set of colors.
  ///
  /// During the migration to Material Design 3, if an app's
  /// [ThemeData.useMaterial3] is false, then components will only
  /// use the following colors for defaults:
  ///
  /// * [primary]
  /// * [onPrimary]
  /// * [secondary]
  /// * [onSecondary]
  /// * [error]
  /// * [onError]
  /// * [surface]
  /// * [onSurface]
  /// DEPRECATED:
  /// * [background]
  /// * [onBackground]
  const ColorScheme({
    required this.brightness,
    required this.primary,
    required this.onPrimary,
    Color? primaryContainer,
    Color? onPrimaryContainer,
    Color? primaryFixed,
    Color? primaryFixedDim,
    Color? onPrimaryFixed,
    Color? onPrimaryFixedVariant,
    required this.secondary,
    required this.onSecondary,
    Color? secondaryContainer,
    Color? onSecondaryContainer,
    Color? secondaryFixed,
    Color? secondaryFixedDim,
    Color? onSecondaryFixed,
    Color? onSecondaryFixedVariant,
    Color? tertiary,
    Color? onTertiary,
    Color? tertiaryContainer,
    Color? onTertiaryContainer,
    Color? tertiaryFixed,
    Color? tertiaryFixedDim,
    Color? onTertiaryFixed,
    Color? onTertiaryFixedVariant,
    required this.error,
    required this.onError,
    Color? errorContainer,
    Color? onErrorContainer,
    required this.surface,
    required this.onSurface,
    Color? surfaceDim,
    Color? surfaceBright,
    Color? surfaceContainerLowest,
    Color? surfaceContainerLow,
    Color? surfaceContainer,
    Color? surfaceContainerHigh,
    Color? surfaceContainerHighest,
    Color? onSurfaceVariant,
    Color? outline,
    Color? outlineVariant,
    Color? shadow,
    Color? scrim,
    Color? inverseSurface,
    Color? onInverseSurface,
    Color? inversePrimary,
    Color? surfaceTint,
    @Deprecated(
      'Use surface instead. '
      'This feature was deprecated after v3.18.0-0.1.pre.',
    )
    Color? background,
    @Deprecated(
      'Use onSurface instead. '
      'This feature was deprecated after v3.18.0-0.1.pre.',
    )
    Color? onBackground,
    @Deprecated(
      'Use surfaceContainerHighest instead. '
      'This feature was deprecated after v3.18.0-0.1.pre.',
    )
    Color? surfaceVariant,
  }) : _primaryContainer = primaryContainer,
       _onPrimaryContainer = onPrimaryContainer,
       _primaryFixed = primaryFixed,
       _primaryFixedDim = primaryFixedDim,
       _onPrimaryFixed = onPrimaryFixed,
       _onPrimaryFixedVariant = onPrimaryFixedVariant,
       _secondaryContainer = secondaryContainer,
       _onSecondaryContainer = onSecondaryContainer,
       _secondaryFixed = secondaryFixed,
       _secondaryFixedDim = secondaryFixedDim,
       _onSecondaryFixed = onSecondaryFixed,
       _onSecondaryFixedVariant = onSecondaryFixedVariant,
       _tertiary = tertiary,
       _onTertiary = onTertiary,
       _tertiaryContainer = tertiaryContainer,
       _onTertiaryContainer = onTertiaryContainer,
       _tertiaryFixed = tertiaryFixed,
       _tertiaryFixedDim = tertiaryFixedDim,
       _onTertiaryFixed = onTertiaryFixed,
       _onTertiaryFixedVariant = onTertiaryFixedVariant,
       _errorContainer = errorContainer,
       _onErrorContainer = onErrorContainer,
       _surfaceDim = surfaceDim,
       _surfaceBright = surfaceBright,
       _surfaceContainerLowest = surfaceContainerLowest,
       _surfaceContainerLow = surfaceContainerLow,
       _surfaceContainer = surfaceContainer,
       _surfaceContainerHigh = surfaceContainerHigh,
       _surfaceContainerHighest = surfaceContainerHighest,
       _onSurfaceVariant = onSurfaceVariant,
       _outline = outline,
       _outlineVariant = outlineVariant,
       _shadow = shadow,
       _scrim = scrim,
       _inverseSurface = inverseSurface,
       _onInverseSurface = onInverseSurface,
       _inversePrimary = inversePrimary,
       _surfaceTint = surfaceTint,
       // DEPRECATED (newest deprecations at the bottom)
       _background = background,
       _onBackground = onBackground,
       _surfaceVariant = surfaceVariant;

  /// Generate a [ColorScheme] derived from the given `seedColor`.
  ///
  /// Using the `seedColor` as a starting point, a set of tonal palettes are
  /// constructed. By default, the tonal palettes are based on the Material 3
  /// Color system and provide all of the [ColorScheme] colors. These colors are
  /// designed to work well together and meet contrast requirements for
  /// accessibility.
  ///
  /// If any of the optional color parameters are non-null they will be
  /// used in place of the generated colors for that field in the resulting
  /// color scheme. This allows apps to override specific colors for their
  /// needs.
  ///
  /// Given the nature of the algorithm, the `seedColor` may not wind up as
  /// one of the ColorScheme colors.
  ///
  /// The `dynamicSchemeVariant` parameter creates different types of
  /// [DynamicScheme]s, which are used to generate different styles of [ColorScheme]s.
  /// By default, `dynamicSchemeVariant` is set to `tonalSpot`. A [ColorScheme]
  /// constructed by `dynamicSchemeVariant.tonalSpot` has pastel palettes and
  /// won't be too "colorful" even if the `seedColor` has a high chroma value.
  /// If the resulting color scheme is too dark, consider setting `dynamicSchemeVariant`
  /// to [DynamicSchemeVariant.fidelity], whose palettes match the seed color.
  ///
  /// The `contrastLevel` parameter indicates the contrast level between color
  /// pairs, such as [primary] and [onPrimary]. 0.0 is the default (normal);
  /// -1.0 is the lowest; 1.0 is the highest. From Material Design guideline, the
  /// medium and high contrast correspond to 0.5 and 1.0 respectively.
  ///
  /// {@tool dartpad}
  /// This sample shows how to use [ColorScheme.fromSeed] to create dynamic
  /// color schemes with different [DynamicSchemeVariant]s and different
  /// contrast level.
  ///
  /// ** See code in examples/api/lib/material/color_scheme/color_scheme.0.dart **
  /// {@end-tool}
  ///
  /// See also:
  ///
  ///  * <https://m3.material.io/styles/color/the-color-system/color-roles>, the
  ///    Material 3 Color system specification.
  ///  * <https://pub.dev/packages/material_color_utilities>, the package
  ///    used to generate the tonal palettes needed for the scheme.
  factory ColorScheme.fromSeed({
    required Color seedColor,
    Brightness brightness = Brightness.light,
    DynamicSchemeVariant dynamicSchemeVariant = DynamicSchemeVariant.tonalSpot,
    double contrastLevel = 0.0,
    Color? primary,
    Color? onPrimary,
    Color? primaryContainer,
    Color? onPrimaryContainer,
    Color? primaryFixed,
    Color? primaryFixedDim,
    Color? onPrimaryFixed,
    Color? onPrimaryFixedVariant,
    Color? secondary,
    Color? onSecondary,
    Color? secondaryContainer,
    Color? onSecondaryContainer,
    Color? secondaryFixed,
    Color? secondaryFixedDim,
    Color? onSecondaryFixed,
    Color? onSecondaryFixedVariant,
    Color? tertiary,
    Color? onTertiary,
    Color? tertiaryContainer,
    Color? onTertiaryContainer,
    Color? tertiaryFixed,
    Color? tertiaryFixedDim,
    Color? onTertiaryFixed,
    Color? onTertiaryFixedVariant,
    Color? error,
    Color? onError,
    Color? errorContainer,
    Color? onErrorContainer,
    Color? outline,
    Color? outlineVariant,
    Color? surface,
    Color? onSurface,
    Color? surfaceDim,
    Color? surfaceBright,
    Color? surfaceContainerLowest,
    Color? surfaceContainerLow,
    Color? surfaceContainer,
    Color? surfaceContainerHigh,
    Color? surfaceContainerHighest,
    Color? onSurfaceVariant,
    Color? inverseSurface,
    Color? onInverseSurface,
    Color? inversePrimary,
    Color? shadow,
    Color? scrim,
    Color? surfaceTint,
    @Deprecated(
      'Use surface instead. '
      'This feature was deprecated after v3.18.0-0.1.pre.',
    )
    Color? background,
    @Deprecated(
      'Use onSurface instead. '
      'This feature was deprecated after v3.18.0-0.1.pre.',
    )
    Color? onBackground,
    @Deprecated(
      'Use surfaceContainerHighest instead. '
      'This feature was deprecated after v3.18.0-0.1.pre.',
    )
    Color? surfaceVariant,
  }) {
    final DynamicScheme scheme = _buildDynamicScheme(
      brightness,
      seedColor,
      dynamicSchemeVariant,
      contrastLevel,
    );

    return ColorScheme(
      primary: primary ?? Color(MaterialDynamicColors.primary.getArgb(scheme)),
      onPrimary: onPrimary ?? Color(MaterialDynamicColors.onPrimary.getArgb(scheme)),
      primaryContainer:
          primaryContainer ?? Color(MaterialDynamicColors.primaryContainer.getArgb(scheme)),
      onPrimaryContainer:
          onPrimaryContainer ?? Color(MaterialDynamicColors.onPrimaryContainer.getArgb(scheme)),
      primaryFixed: primaryFixed ?? Color(MaterialDynamicColors.primaryFixed.getArgb(scheme)),
      primaryFixedDim:
          primaryFixedDim ?? Color(MaterialDynamicColors.primaryFixedDim.getArgb(scheme)),
      onPrimaryFixed: onPrimaryFixed ?? Color(MaterialDynamicColors.onPrimaryFixed.getArgb(scheme)),
      onPrimaryFixedVariant:
          onPrimaryFixedVariant ??
          Color(MaterialDynamicColors.onPrimaryFixedVariant.getArgb(scheme)),
      secondary: secondary ?? Color(MaterialDynamicColors.secondary.getArgb(scheme)),
      onSecondary: onSecondary ?? Color(MaterialDynamicColors.onSecondary.getArgb(scheme)),
      secondaryContainer:
          secondaryContainer ?? Color(MaterialDynamicColors.secondaryContainer.getArgb(scheme)),
      onSecondaryContainer:
          onSecondaryContainer ?? Color(MaterialDynamicColors.onSecondaryContainer.getArgb(scheme)),
      secondaryFixed: secondaryFixed ?? Color(MaterialDynamicColors.secondaryFixed.getArgb(scheme)),
      secondaryFixedDim:
          secondaryFixedDim ?? Color(MaterialDynamicColors.secondaryFixedDim.getArgb(scheme)),
      onSecondaryFixed:
          onSecondaryFixed ?? Color(MaterialDynamicColors.onSecondaryFixed.getArgb(scheme)),
      onSecondaryFixedVariant:
          onSecondaryFixedVariant ??
          Color(MaterialDynamicColors.onSecondaryFixedVariant.getArgb(scheme)),
      tertiary: tertiary ?? Color(MaterialDynamicColors.tertiary.getArgb(scheme)),
      onTertiary: onTertiary ?? Color(MaterialDynamicColors.onTertiary.getArgb(scheme)),
      tertiaryContainer:
          tertiaryContainer ?? Color(MaterialDynamicColors.tertiaryContainer.getArgb(scheme)),
      onTertiaryContainer:
          onTertiaryContainer ?? Color(MaterialDynamicColors.onTertiaryContainer.getArgb(scheme)),
      tertiaryFixed: tertiaryFixed ?? Color(MaterialDynamicColors.tertiaryFixed.getArgb(scheme)),
      tertiaryFixedDim:
          tertiaryFixedDim ?? Color(MaterialDynamicColors.tertiaryFixedDim.getArgb(scheme)),
      onTertiaryFixed:
          onTertiaryFixed ?? Color(MaterialDynamicColors.onTertiaryFixed.getArgb(scheme)),
      onTertiaryFixedVariant:
          onTertiaryFixedVariant ??
          Color(MaterialDynamicColors.onTertiaryFixedVariant.getArgb(scheme)),
      error: error ?? Color(MaterialDynamicColors.error.getArgb(scheme)),
      onError: onError ?? Color(MaterialDynamicColors.onError.getArgb(scheme)),
      errorContainer: errorContainer ?? Color(MaterialDynamicColors.errorContainer.getArgb(scheme)),
      onErrorContainer:
          onErrorContainer ?? Color(MaterialDynamicColors.onErrorContainer.getArgb(scheme)),
      outline: outline ?? Color(MaterialDynamicColors.outline.getArgb(scheme)),
      outlineVariant: outlineVariant ?? Color(MaterialDynamicColors.outlineVariant.getArgb(scheme)),
      surface: surface ?? Color(MaterialDynamicColors.surface.getArgb(scheme)),
      surfaceDim: surfaceDim ?? Color(MaterialDynamicColors.surfaceDim.getArgb(scheme)),
      surfaceBright: surfaceBright ?? Color(MaterialDynamicColors.surfaceBright.getArgb(scheme)),
      surfaceContainerLowest:
          surfaceContainerLowest ??
          Color(MaterialDynamicColors.surfaceContainerLowest.getArgb(scheme)),
      surfaceContainerLow:
          surfaceContainerLow ?? Color(MaterialDynamicColors.surfaceContainerLow.getArgb(scheme)),
      surfaceContainer:
          surfaceContainer ?? Color(MaterialDynamicColors.surfaceContainer.getArgb(scheme)),
      surfaceContainerHigh:
          surfaceContainerHigh ?? Color(MaterialDynamicColors.surfaceContainerHigh.getArgb(scheme)),
      surfaceContainerHighest:
          surfaceContainerHighest ??
          Color(MaterialDynamicColors.surfaceContainerHighest.getArgb(scheme)),
      onSurface: onSurface ?? Color(MaterialDynamicColors.onSurface.getArgb(scheme)),
      onSurfaceVariant:
          onSurfaceVariant ?? Color(MaterialDynamicColors.onSurfaceVariant.getArgb(scheme)),
      inverseSurface: inverseSurface ?? Color(MaterialDynamicColors.inverseSurface.getArgb(scheme)),
      onInverseSurface:
          onInverseSurface ?? Color(MaterialDynamicColors.inverseOnSurface.getArgb(scheme)),
      inversePrimary: inversePrimary ?? Color(MaterialDynamicColors.inversePrimary.getArgb(scheme)),
      shadow: shadow ?? Color(MaterialDynamicColors.shadow.getArgb(scheme)),
      scrim: scrim ?? Color(MaterialDynamicColors.scrim.getArgb(scheme)),
      surfaceTint: surfaceTint ?? Color(MaterialDynamicColors.primary.getArgb(scheme)),
      brightness: brightness,
      // DEPRECATED (newest deprecations at the bottom)
      background: background ?? Color(MaterialDynamicColors.background.getArgb(scheme)),
      onBackground: onBackground ?? Color(MaterialDynamicColors.onBackground.getArgb(scheme)),
      surfaceVariant: surfaceVariant ?? Color(MaterialDynamicColors.surfaceVariant.getArgb(scheme)),
    );
  }

  /// Create a light ColorScheme based on a purple primary color that matches the
  /// [baseline Material 2 color scheme](https://material.io/design/color/the-color-system.html#color-theme-creation).
  ///
  /// This constructor shouldn't be used to update the Material 3 color scheme.
  ///
  /// For Material 3, use [ColorScheme.fromSeed] to create a color scheme
  /// from a single seed color based on the Material 3 color system.
  ///
  /// {@tool snippet}
  /// This example demonstrates how to create a color scheme similar to [ColorScheme.light]
  /// using the [ColorScheme.fromSeed] constructor:
  ///
  /// ```dart
  /// colorScheme: ColorScheme.fromSeed(seedColor: const Color(0xff6200ee)).copyWith(
  ///   primaryContainer: const Color(0xff6200ee),
  ///   onPrimaryContainer: Colors.white,
  ///   secondaryContainer: const Color(0xff03dac6),
  ///   onSecondaryContainer: Colors.black,
  ///   error: const Color(0xffb00020),
  ///   onError: Colors.white,
  /// ),
  /// ```
  /// {@end-tool}
  const ColorScheme.light({
    this.brightness = Brightness.light,
    this.primary = const Color(0xff6200ee),
    this.onPrimary = Colors.white,
    Color? primaryContainer,
    Color? onPrimaryContainer,
    Color? primaryFixed,
    Color? primaryFixedDim,
    Color? onPrimaryFixed,
    Color? onPrimaryFixedVariant,
    this.secondary = const Color(0xff03dac6),
    this.onSecondary = Colors.black,
    Color? secondaryContainer,
    Color? onSecondaryContainer,
    Color? secondaryFixed,
    Color? secondaryFixedDim,
    Color? onSecondaryFixed,
    Color? onSecondaryFixedVariant,
    Color? tertiary,
    Color? onTertiary,
    Color? tertiaryContainer,
    Color? onTertiaryContainer,
    Color? tertiaryFixed,
    Color? tertiaryFixedDim,
    Color? onTertiaryFixed,
    Color? onTertiaryFixedVariant,
    this.error = const Color(0xffb00020),
    this.onError = Colors.white,
    Color? errorContainer,
    Color? onErrorContainer,
    this.surface = Colors.white,
    this.onSurface = Colors.black,
    Color? surfaceDim,
    Color? surfaceBright,
    Color? surfaceContainerLowest,
    Color? surfaceContainerLow,
    Color? surfaceContainer,
    Color? surfaceContainerHigh,
    Color? surfaceContainerHighest,
    Color? onSurfaceVariant,
    Color? outline,
    Color? outlineVariant,
    Color? shadow,
    Color? scrim,
    Color? inverseSurface,
    Color? onInverseSurface,
    Color? inversePrimary,
    Color? surfaceTint,
    @Deprecated(
      'Use surface instead. '
      'This feature was deprecated after v3.18.0-0.1.pre.',
    )
    Color? background = Colors.white,
    @Deprecated(
      'Use onSurface instead. '
      'This feature was deprecated after v3.18.0-0.1.pre.',
    )
    Color? onBackground = Colors.black,
    @Deprecated(
      'Use surfaceContainerHighest instead. '
      'This feature was deprecated after v3.18.0-0.1.pre.',
    )
    Color? surfaceVariant,
  }) : _primaryContainer = primaryContainer,
       _onPrimaryContainer = onPrimaryContainer,
       _primaryFixed = primaryFixed,
       _primaryFixedDim = primaryFixedDim,
       _onPrimaryFixed = onPrimaryFixed,
       _onPrimaryFixedVariant = onPrimaryFixedVariant,
       _secondaryContainer = secondaryContainer,
       _onSecondaryContainer = onSecondaryContainer,
       _secondaryFixed = secondaryFixed,
       _secondaryFixedDim = secondaryFixedDim,
       _onSecondaryFixed = onSecondaryFixed,
       _onSecondaryFixedVariant = onSecondaryFixedVariant,
       _tertiary = tertiary,
       _onTertiary = onTertiary,
       _tertiaryContainer = tertiaryContainer,
       _onTertiaryContainer = onTertiaryContainer,
       _tertiaryFixed = tertiaryFixed,
       _tertiaryFixedDim = tertiaryFixedDim,
       _onTertiaryFixed = onTertiaryFixed,
       _onTertiaryFixedVariant = onTertiaryFixedVariant,
       _errorContainer = errorContainer,
       _onErrorContainer = onErrorContainer,
       _surfaceDim = surfaceDim,
       _surfaceBright = surfaceBright,
       _surfaceContainerLowest = surfaceContainerLowest,
       _surfaceContainerLow = surfaceContainerLow,
       _surfaceContainer = surfaceContainer,
       _surfaceContainerHigh = surfaceContainerHigh,
       _surfaceContainerHighest = surfaceContainerHighest,
       _onSurfaceVariant = onSurfaceVariant,
       _outline = outline,
       _outlineVariant = outlineVariant,
       _shadow = shadow,
       _scrim = scrim,
       _inverseSurface = inverseSurface,
       _onInverseSurface = onInverseSurface,
       _inversePrimary = inversePrimary,
       _surfaceTint = surfaceTint,
       // DEPRECATED (newest deprecations at the bottom)
       _background = background,
       _onBackground = onBackground,
       _surfaceVariant = surfaceVariant;

  /// Create the dark color scheme that matches the
  /// [baseline Material 2 color scheme](https://material.io/design/color/dark-theme.html#ui-application).
  ///
  /// This constructor shouldn't be used to update the Material 3 color scheme.
  ///
  /// For Material 3, use [ColorScheme.fromSeed] to create a color scheme
  /// from a single seed color based on the Material 3 color system.
  /// Override the `brightness` property of [ColorScheme.fromSeed] to create a
  /// dark color scheme.
  ///
  /// {@tool snippet}
  /// This example demonstrates how to create a color scheme similar to [ColorScheme.dark]
  /// using the [ColorScheme.fromSeed] constructor:
  ///
  /// ```dart
  /// colorScheme: ColorScheme.fromSeed(
  ///   seedColor: const Color(0xffbb86fc),
  ///   brightness: Brightness.dark,
  /// ).copyWith(
  ///   primaryContainer: const Color(0xffbb86fc),
  ///   onPrimaryContainer: Colors.black,
  ///   secondaryContainer: const Color(0xff03dac6),
  ///   onSecondaryContainer: Colors.black,
  ///   error: const Color(0xffcf6679),
  ///   onError: Colors.black,
  /// ),
  /// ```
  /// {@end-tool}
  const ColorScheme.dark({
    this.brightness = Brightness.dark,
    this.primary = const Color(0xffbb86fc),
    this.onPrimary = Colors.black,
    Color? primaryContainer,
    Color? onPrimaryContainer,
    Color? primaryFixed,
    Color? primaryFixedDim,
    Color? onPrimaryFixed,
    Color? onPrimaryFixedVariant,
    this.secondary = const Color(0xff03dac6),
    this.onSecondary = Colors.black,
    Color? secondaryContainer,
    Color? onSecondaryContainer,
    Color? secondaryFixed,
    Color? secondaryFixedDim,
    Color? onSecondaryFixed,
    Color? onSecondaryFixedVariant,
    Color? tertiary,
    Color? onTertiary,
    Color? tertiaryContainer,
    Color? onTertiaryContainer,
    Color? tertiaryFixed,
    Color? tertiaryFixedDim,
    Color? onTertiaryFixed,
    Color? onTertiaryFixedVariant,
    this.error = const Color(0xffcf6679),
    this.onError = Colors.black,
    Color? errorContainer,
    Color? onErrorContainer,
    this.surface = const Color(0xff121212),
    this.onSurface = Colors.white,
    Color? surfaceDim,
    Color? surfaceBright,
    Color? surfaceContainerLowest,
    Color? surfaceContainerLow,
    Color? surfaceContainer,
    Color? surfaceContainerHigh,
    Color? surfaceContainerHighest,
    Color? onSurfaceVariant,
    Color? outline,
    Color? outlineVariant,
    Color? shadow,
    Color? scrim,
    Color? inverseSurface,
    Color? onInverseSurface,
    Color? inversePrimary,
    Color? surfaceTint,
    @Deprecated(
      'Use surface instead. '
      'This feature was deprecated after v3.18.0-0.1.pre.',
    )
    Color? background = const Color(0xff121212),
    @Deprecated(
      'Use onSurface instead. '
      'This feature was deprecated after v3.18.0-0.1.pre.',
    )
    Color? onBackground = Colors.white,
    @Deprecated(
      'Use surfaceContainerHighest instead. '
      'This feature was deprecated after v3.18.0-0.1.pre.',
    )
    Color? surfaceVariant,
  }) : _primaryContainer = primaryContainer,
       _onPrimaryContainer = onPrimaryContainer,
       _primaryFixed = primaryFixed,
       _primaryFixedDim = primaryFixedDim,
       _onPrimaryFixed = onPrimaryFixed,
       _onPrimaryFixedVariant = onPrimaryFixedVariant,
       _secondaryContainer = secondaryContainer,
       _onSecondaryContainer = onSecondaryContainer,
       _secondaryFixed = secondaryFixed,
       _secondaryFixedDim = secondaryFixedDim,
       _onSecondaryFixed = onSecondaryFixed,
       _onSecondaryFixedVariant = onSecondaryFixedVariant,
       _tertiary = tertiary,
       _onTertiary = onTertiary,
       _tertiaryContainer = tertiaryContainer,
       _onTertiaryContainer = onTertiaryContainer,
       _tertiaryFixed = tertiaryFixed,
       _tertiaryFixedDim = tertiaryFixedDim,
       _onTertiaryFixed = onTertiaryFixed,
       _onTertiaryFixedVariant = onTertiaryFixedVariant,
       _errorContainer = errorContainer,
       _onErrorContainer = onErrorContainer,
       _surfaceDim = surfaceDim,
       _surfaceBright = surfaceBright,
       _surfaceContainerLowest = surfaceContainerLowest,
       _surfaceContainerLow = surfaceContainerLow,
       _surfaceContainer = surfaceContainer,
       _surfaceContainerHigh = surfaceContainerHigh,
       _surfaceContainerHighest = surfaceContainerHighest,
       _onSurfaceVariant = onSurfaceVariant,
       _outline = outline,
       _outlineVariant = outlineVariant,
       _shadow = shadow,
       _scrim = scrim,
       _inverseSurface = inverseSurface,
       _onInverseSurface = onInverseSurface,
       _inversePrimary = inversePrimary,
       _surfaceTint = surfaceTint,
       // DEPRECATED (newest deprecations at the bottom)
       _background = background,
       _onBackground = onBackground,
       _surfaceVariant = surfaceVariant;

  /// Create a high contrast ColorScheme based on a purple primary color that
  /// matches the [baseline Material 2 color scheme](https://material.io/design/color/the-color-system.html#color-theme-creation).
  ///
  /// This constructor shouldn't be used to update the Material 3 color scheme.
  ///
  /// For Material 3, use [ColorScheme.fromSeed] to create a color scheme
  /// from a single seed color based on the Material 3 color system. To create a
  /// high-contrast color scheme, set `contrastLevel` to 1.0.
  ///
  /// {@tool snippet}
  /// This example demonstrates how to create a color scheme similar to [ColorScheme.highContrastLight]
  /// using the [ColorScheme.fromSeed] constructor:
  ///
  /// ```dart
  /// colorScheme: ColorScheme.fromSeed(seedColor: const Color(0xff0000ba)).copyWith(
  ///   primaryContainer: const Color(0xff0000ba),
  ///   onPrimaryContainer: Colors.white,
  ///   secondaryContainer: const Color(0xff66fff9),
  ///   onSecondaryContainer: Colors.black,
  ///   error: const Color(0xff790000),
  ///   onError: Colors.white,
  /// ),
  /// ```
  /// {@end-tool}
  const ColorScheme.highContrastLight({
    this.brightness = Brightness.light,
    this.primary = const Color(0xff0000ba),
    this.onPrimary = Colors.white,
    Color? primaryContainer,
    Color? onPrimaryContainer,
    Color? primaryFixed,
    Color? primaryFixedDim,
    Color? onPrimaryFixed,
    Color? onPrimaryFixedVariant,
    this.secondary = const Color(0xff66fff9),
    this.onSecondary = Colors.black,
    Color? secondaryContainer,
    Color? onSecondaryContainer,
    Color? secondaryFixed,
    Color? secondaryFixedDim,
    Color? onSecondaryFixed,
    Color? onSecondaryFixedVariant,
    Color? tertiary,
    Color? onTertiary,
    Color? tertiaryContainer,
    Color? onTertiaryContainer,
    Color? tertiaryFixed,
    Color? tertiaryFixedDim,
    Color? onTertiaryFixed,
    Color? onTertiaryFixedVariant,
    this.error = const Color(0xff790000),
    this.onError = Colors.white,
    Color? errorContainer,
    Color? onErrorContainer,
    this.surface = Colors.white,
    this.onSurface = Colors.black,
    Color? surfaceDim,
    Color? surfaceBright,
    Color? surfaceContainerLowest,
    Color? surfaceContainerLow,
    Color? surfaceContainer,
    Color? surfaceContainerHigh,
    Color? surfaceContainerHighest,
    Color? onSurfaceVariant,
    Color? outline,
    Color? outlineVariant,
    Color? shadow,
    Color? scrim,
    Color? inverseSurface,
    Color? onInverseSurface,
    Color? inversePrimary,
    Color? surfaceTint,
    @Deprecated(
      'Use surface instead. '
      'This feature was deprecated after v3.18.0-0.1.pre.',
    )
    Color? background = Colors.white,
    @Deprecated(
      'Use onSurface instead. '
      'This feature was deprecated after v3.18.0-0.1.pre.',
    )
    Color? onBackground = Colors.black,
    @Deprecated(
      'Use surfaceContainerHighest instead. '
      'This feature was deprecated after v3.18.0-0.1.pre.',
    )
    Color? surfaceVariant,
  }) : _primaryContainer = primaryContainer,
       _onPrimaryContainer = onPrimaryContainer,
       _primaryFixed = primaryFixed,
       _primaryFixedDim = primaryFixedDim,
       _onPrimaryFixed = onPrimaryFixed,
       _onPrimaryFixedVariant = onPrimaryFixedVariant,
       _secondaryContainer = secondaryContainer,
       _onSecondaryContainer = onSecondaryContainer,
       _secondaryFixed = secondaryFixed,
       _secondaryFixedDim = secondaryFixedDim,
       _onSecondaryFixed = onSecondaryFixed,
       _onSecondaryFixedVariant = onSecondaryFixedVariant,
       _tertiary = tertiary,
       _onTertiary = onTertiary,
       _tertiaryContainer = tertiaryContainer,
       _onTertiaryContainer = onTertiaryContainer,
       _tertiaryFixed = tertiaryFixed,
       _tertiaryFixedDim = tertiaryFixedDim,
       _onTertiaryFixed = onTertiaryFixed,
       _onTertiaryFixedVariant = onTertiaryFixedVariant,
       _errorContainer = errorContainer,
       _onErrorContainer = onErrorContainer,
       _surfaceDim = surfaceDim,
       _surfaceBright = surfaceBright,
       _surfaceContainerLowest = surfaceContainerLowest,
       _surfaceContainerLow = surfaceContainerLow,
       _surfaceContainer = surfaceContainer,
       _surfaceContainerHigh = surfaceContainerHigh,
       _surfaceContainerHighest = surfaceContainerHighest,
       _onSurfaceVariant = onSurfaceVariant,
       _outline = outline,
       _outlineVariant = outlineVariant,
       _shadow = shadow,
       _scrim = scrim,
       _inverseSurface = inverseSurface,
       _onInverseSurface = onInverseSurface,
       _inversePrimary = inversePrimary,
       _surfaceTint = surfaceTint,
       // DEPRECATED (newest deprecations at the bottom)
       _background = background,
       _onBackground = onBackground,
       _surfaceVariant = surfaceVariant;

  /// Create a high contrast ColorScheme based on the dark
  /// [baseline Material 2 color scheme](https://material.io/design/color/dark-theme.html#ui-application).
  ///
  /// This constructor shouldn't be used to update the Material 3 color scheme.
  ///
  /// For Material 3, use [ColorScheme.fromSeed] to create a color scheme
  /// from a single seed color based on the Material 3 color system.
  /// Override the `brightness` property of [ColorScheme.fromSeed] to create a
  /// dark color scheme. To create a high-contrast color scheme, set
  /// `contrastLevel` to 1.0.
  ///
  /// {@tool snippet}
  /// This example demonstrates how to create a color scheme similar to [ColorScheme.highContrastDark]
  /// using the [ColorScheme.fromSeed] constructor:
  ///
  /// ```dart
  /// colorScheme: ColorScheme.fromSeed(
  ///   seedColor: const Color(0xffefb7ff),
  ///   brightness: Brightness.dark,
  /// ).copyWith(
  ///   primaryContainer: const Color(0xffefb7ff),
  ///   onPrimaryContainer: Colors.black,
  ///   secondaryContainer: const Color(0xff66fff9),
  ///   onSecondaryContainer: Colors.black,
  ///   error: const Color(0xff9b374d),
  ///   onError: Colors.white,
  /// ),
  /// ```
  /// {@end-tool}
  const ColorScheme.highContrastDark({
    this.brightness = Brightness.dark,
    this.primary = const Color(0xffefb7ff),
    this.onPrimary = Colors.black,
    Color? primaryContainer,
    Color? onPrimaryContainer,
    Color? primaryFixed,
    Color? primaryFixedDim,
    Color? onPrimaryFixed,
    Color? onPrimaryFixedVariant,
    this.secondary = const Color(0xff66fff9),
    this.onSecondary = Colors.black,
    Color? secondaryContainer,
    Color? onSecondaryContainer,
    Color? secondaryFixed,
    Color? secondaryFixedDim,
    Color? onSecondaryFixed,
    Color? onSecondaryFixedVariant,
    Color? tertiary,
    Color? onTertiary,
    Color? tertiaryContainer,
    Color? onTertiaryContainer,
    Color? tertiaryFixed,
    Color? tertiaryFixedDim,
    Color? onTertiaryFixed,
    Color? onTertiaryFixedVariant,
    this.error = const Color(0xff9b374d),
    this.onError = Colors.black,
    Color? errorContainer,
    Color? onErrorContainer,
    this.surface = const Color(0xff121212),
    this.onSurface = Colors.white,
    Color? surfaceDim,
    Color? surfaceBright,
    Color? surfaceContainerLowest,
    Color? surfaceContainerLow,
    Color? surfaceContainer,
    Color? surfaceContainerHigh,
    Color? surfaceContainerHighest,
    Color? onSurfaceVariant,
    Color? outline,
    Color? outlineVariant,
    Color? shadow,
    Color? scrim,
    Color? inverseSurface,
    Color? onInverseSurface,
    Color? inversePrimary,
    Color? surfaceTint,
    @Deprecated(
      'Use surface instead. '
      'This feature was deprecated after v3.18.0-0.1.pre.',
    )
    Color? background = const Color(0xff121212),
    @Deprecated(
      'Use onSurface instead. '
      'This feature was deprecated after v3.18.0-0.1.pre.',
    )
    Color? onBackground = Colors.white,
    @Deprecated(
      'Use surfaceContainerHighest instead. '
      'This feature was deprecated after v3.18.0-0.1.pre.',
    )
    Color? surfaceVariant,
  }) : _primaryContainer = primaryContainer,
       _onPrimaryContainer = onPrimaryContainer,
       _primaryFixed = primaryFixed,
       _primaryFixedDim = primaryFixedDim,
       _onPrimaryFixed = onPrimaryFixed,
       _onPrimaryFixedVariant = onPrimaryFixedVariant,
       _secondaryContainer = secondaryContainer,
       _onSecondaryContainer = onSecondaryContainer,
       _secondaryFixed = secondaryFixed,
       _secondaryFixedDim = secondaryFixedDim,
       _onSecondaryFixed = onSecondaryFixed,
       _onSecondaryFixedVariant = onSecondaryFixedVariant,
       _tertiary = tertiary,
       _onTertiary = onTertiary,
       _tertiaryContainer = tertiaryContainer,
       _onTertiaryContainer = onTertiaryContainer,
       _tertiaryFixed = tertiaryFixed,
       _tertiaryFixedDim = tertiaryFixedDim,
       _onTertiaryFixed = onTertiaryFixed,
       _onTertiaryFixedVariant = onTertiaryFixedVariant,
       _errorContainer = errorContainer,
       _onErrorContainer = onErrorContainer,
       _surfaceDim = surfaceDim,
       _surfaceBright = surfaceBright,
       _surfaceContainerLowest = surfaceContainerLowest,
       _surfaceContainerLow = surfaceContainerLow,
       _surfaceContainer = surfaceContainer,
       _surfaceContainerHigh = surfaceContainerHigh,
       _surfaceContainerHighest = surfaceContainerHighest,
       _onSurfaceVariant = onSurfaceVariant,
       _outline = outline,
       _outlineVariant = outlineVariant,
       _shadow = shadow,
       _scrim = scrim,
       _inverseSurface = inverseSurface,
       _onInverseSurface = onInverseSurface,
       _inversePrimary = inversePrimary,
       _surfaceTint = surfaceTint,
       // DEPRECATED (newest deprecations at the bottom)
       _background = background,
       _onBackground = onBackground,
       _surfaceVariant = surfaceVariant;

  /// Creates a color scheme from a [MaterialColor] swatch.
  ///
  /// In Material 3, this constructor is ignored by [ThemeData] when creating
  /// its default color scheme. Instead, [ThemeData] uses [ColorScheme.fromSeed]
  /// to create its default color scheme. This constructor shouldn't be used
  /// to update the Material 3 color scheme. It will be phased out gradually;
  /// see https://github.com/flutter/flutter/issues/120064 for more details.
  ///
  /// If [ThemeData.useMaterial3] is false, then this constructor is used by
  /// [ThemeData] to create its default color scheme.
  factory ColorScheme.fromSwatch({
    MaterialColor primarySwatch = Colors.blue,
    Color? accentColor,
    Color? cardColor,
    Color? backgroundColor,
    Color? errorColor,
    Brightness brightness = Brightness.light,
  }) {
    final bool isDark = brightness == Brightness.dark;
    final bool primaryIsDark = _brightnessFor(primarySwatch) == Brightness.dark;
    final Color secondary = accentColor ?? (isDark ? Colors.tealAccent[200]! : primarySwatch);
    final bool secondaryIsDark = _brightnessFor(secondary) == Brightness.dark;

    return ColorScheme(
      primary: primarySwatch,
      secondary: secondary,
      surface: cardColor ?? (isDark ? Colors.grey[800]! : Colors.white),
      error: errorColor ?? Colors.red[700]!,
      onPrimary: primaryIsDark ? Colors.white : Colors.black,
      onSecondary: secondaryIsDark ? Colors.white : Colors.black,
      onSurface: isDark ? Colors.white : Colors.black,
      onError: isDark ? Colors.black : Colors.white,
      brightness: brightness,
      // DEPRECATED (newest deprecations at the bottom)
      background: backgroundColor ?? (isDark ? Colors.grey[700]! : primarySwatch[200]!),
      onBackground: primaryIsDark ? Colors.white : Colors.black,
    );
  }

  static Brightness _brightnessFor(Color color) => ThemeData.estimateBrightnessForColor(color);

  /// The overall brightness of this color scheme.
  final Brightness brightness;

  /// The color displayed most frequently across your app’s screens and components.
  final Color primary;

  /// A color that's clearly legible when drawn on [primary].
  ///
  /// To ensure that an app is accessible, a contrast ratio between
  /// [primary] and [onPrimary] of at least 4.5:1 is recommended. See
  /// <https://www.w3.org/TR/UNDERSTANDING-WCAG20/visual-audio-contrast-contrast.html>.
  final Color onPrimary;

  final Color? _primaryContainer;

  /// A color used for elements needing less emphasis than [primary].
  Color get primaryContainer => _primaryContainer ?? primary;

  final Color? _onPrimaryContainer;

  /// A color that's clearly legible when drawn on [primaryContainer].
  ///
  /// To ensure that an app is accessible, a contrast ratio between
  /// [primaryContainer] and [onPrimaryContainer] of at least 4.5:1
  /// is recommended. See
  /// <https://www.w3.org/TR/UNDERSTANDING-WCAG20/visual-audio-contrast-contrast.html>.
  Color get onPrimaryContainer => _onPrimaryContainer ?? onPrimary;

  final Color? _primaryFixed;

  /// A substitute for [primaryContainer] that's the same color for the dark
  /// and light themes.
  Color get primaryFixed => _primaryFixed ?? primary;

  final Color? _primaryFixedDim;

  /// A color used for elements needing more emphasis than [primaryFixed].
  Color get primaryFixedDim => _primaryFixedDim ?? primary;

  final Color? _onPrimaryFixed;

  /// A color that is used for text and icons that exist on top of elements having
  /// [primaryFixed] color.
  Color get onPrimaryFixed => _onPrimaryFixed ?? onPrimary;

  final Color? _onPrimaryFixedVariant;

  /// A color that provides a lower-emphasis option for text and icons than
  /// [onPrimaryFixed].
  Color get onPrimaryFixedVariant => _onPrimaryFixedVariant ?? onPrimary;

  /// An accent color used for less prominent components in the UI, such as
  /// filter chips, while expanding the opportunity for color expression.
  final Color secondary;

  /// A color that's clearly legible when drawn on [secondary].
  ///
  /// To ensure that an app is accessible, a contrast ratio between
  /// [secondary] and [onSecondary] of at least 4.5:1 is recommended. See
  /// <https://www.w3.org/TR/UNDERSTANDING-WCAG20/visual-audio-contrast-contrast.html>.
  final Color onSecondary;

  final Color? _secondaryContainer;

  /// A color used for elements needing less emphasis than [secondary].
  Color get secondaryContainer => _secondaryContainer ?? secondary;

  final Color? _onSecondaryContainer;

  /// A color that's clearly legible when drawn on [secondaryContainer].
  ///
  /// To ensure that an app is accessible, a contrast ratio between
  /// [secondaryContainer] and [onSecondaryContainer] of at least 4.5:1 is
  /// recommended. See
  /// <https://www.w3.org/TR/UNDERSTANDING-WCAG20/visual-audio-contrast-contrast.html>.
  Color get onSecondaryContainer => _onSecondaryContainer ?? onSecondary;

  final Color? _secondaryFixed;

  /// A substitute for [secondaryContainer] that's the same color for the dark
  /// and light themes.
  Color get secondaryFixed => _secondaryFixed ?? secondary;

  final Color? _secondaryFixedDim;

  /// A color used for elements needing more emphasis than [secondaryFixed].
  Color get secondaryFixedDim => _secondaryFixedDim ?? secondary;

  final Color? _onSecondaryFixed;

  /// A color that is used for text and icons that exist on top of elements having
  /// [secondaryFixed] color.
  Color get onSecondaryFixed => _onSecondaryFixed ?? onSecondary;

  final Color? _onSecondaryFixedVariant;

  /// A color that provides a lower-emphasis option for text and icons than
  /// [onSecondaryFixed].
  Color get onSecondaryFixedVariant => _onSecondaryFixedVariant ?? onSecondary;

  final Color? _tertiary;

  /// A color used as a contrasting accent that can balance [primary]
  /// and [secondary] colors or bring heightened attention to an element,
  /// such as an input field.
  Color get tertiary => _tertiary ?? secondary;

  final Color? _onTertiary;

  /// A color that's clearly legible when drawn on [tertiary].
  ///
  /// To ensure that an app is accessible, a contrast ratio between
  /// [tertiary] and [onTertiary] of at least 4.5:1 is recommended. See
  /// <https://www.w3.org/TR/UNDERSTANDING-WCAG20/visual-audio-contrast-contrast.html>.
  Color get onTertiary => _onTertiary ?? onSecondary;

  final Color? _tertiaryContainer;

  /// A color used for elements needing less emphasis than [tertiary].
  Color get tertiaryContainer => _tertiaryContainer ?? tertiary;

  final Color? _onTertiaryContainer;

  /// A color that's clearly legible when drawn on [tertiaryContainer].
  ///
  /// To ensure that an app is accessible, a contrast ratio between
  /// [tertiaryContainer] and [onTertiaryContainer] of at least 4.5:1 is
  /// recommended. See
  /// <https://www.w3.org/TR/UNDERSTANDING-WCAG20/visual-audio-contrast-contrast.html>.
  Color get onTertiaryContainer => _onTertiaryContainer ?? onTertiary;

  final Color? _tertiaryFixed;

  /// A substitute for [tertiaryContainer] that's the same color for dark
  /// and light themes.
  Color get tertiaryFixed => _tertiaryFixed ?? tertiary;

  final Color? _tertiaryFixedDim;

  /// A color used for elements needing more emphasis than [tertiaryFixed].
  Color get tertiaryFixedDim => _tertiaryFixedDim ?? tertiary;

  final Color? _onTertiaryFixed;

  /// A color that is used for text and icons that exist on top of elements having
  /// [tertiaryFixed] color.
  Color get onTertiaryFixed => _onTertiaryFixed ?? onTertiary;

  final Color? _onTertiaryFixedVariant;

  /// A color that provides a lower-emphasis option for text and icons than
  /// [onTertiaryFixed].
  Color get onTertiaryFixedVariant => _onTertiaryFixedVariant ?? onTertiary;

  /// The color to use for input validation errors, e.g. for
  /// [InputDecoration.errorText].
  final Color error;

  /// A color that's clearly legible when drawn on [error].
  ///
  /// To ensure that an app is accessible, a contrast ratio between
  /// [error] and [onError] of at least 4.5:1 is recommended. See
  /// <https://www.w3.org/TR/UNDERSTANDING-WCAG20/visual-audio-contrast-contrast.html>.
  final Color onError;

  final Color? _errorContainer;

  /// A color used for error elements needing less emphasis than [error].
  Color get errorContainer => _errorContainer ?? error;

  final Color? _onErrorContainer;

  /// A color that's clearly legible when drawn on [errorContainer].
  ///
  /// To ensure that an app is accessible, a contrast ratio between
  /// [errorContainer] and [onErrorContainer] of at least 4.5:1 is
  /// recommended. See
  /// <https://www.w3.org/TR/UNDERSTANDING-WCAG20/visual-audio-contrast-contrast.html>.
  Color get onErrorContainer => _onErrorContainer ?? onError;

  /// The background color for widgets like [Scaffold].
  final Color surface;

  /// A color that's clearly legible when drawn on [surface].
  ///
  /// To ensure that an app is accessible, a contrast ratio between
  /// [surface] and [onSurface] of at least 4.5:1 is recommended. See
  /// <https://www.w3.org/TR/UNDERSTANDING-WCAG20/visual-audio-contrast-contrast.html>.
  final Color onSurface;

  final Color? _surfaceVariant;

  /// A color variant of [surface] that can be used for differentiation against
  /// a component using [surface].
  @Deprecated(
    'Use surfaceContainerHighest instead. '
    'This feature was deprecated after v3.18.0-0.1.pre.',
  )
  Color get surfaceVariant => _surfaceVariant ?? surface;

  final Color? _surfaceDim;

  /// A color that's always darkest in the dark or light theme.
  Color get surfaceDim => _surfaceDim ?? surface;

  final Color? _surfaceBright;

  /// A color that's always the lightest in the dark or light theme.
  Color get surfaceBright => _surfaceBright ?? surface;

  final Color? _surfaceContainerLowest;

  /// A surface container color with the lightest tone and the least emphasis
  /// relative to the surface.
  Color get surfaceContainerLowest => _surfaceContainerLowest ?? surface;

  final Color? _surfaceContainerLow;

  /// A surface container color with a lighter tone that creates less emphasis
  /// than [surfaceContainer] but more emphasis than [surfaceContainerLowest].
  Color get surfaceContainerLow => _surfaceContainerLow ?? surface;

  final Color? _surfaceContainer;

  /// A recommended color role for a distinct area within the surface.
  ///
  /// Surface container color roles are independent of elevation. They replace the old
  /// opacity-based model which applied a tinted overlay on top of
  /// surfaces based on their elevation.
  ///
  /// Surface container colors include [surfaceContainerLowest], [surfaceContainerLow],
  /// [surfaceContainer], [surfaceContainerHigh] and [surfaceContainerHighest].
  Color get surfaceContainer => _surfaceContainer ?? surface;

  final Color? _surfaceContainerHigh;

  /// A surface container color with a darker tone. It is used to create more
  /// emphasis than [surfaceContainer] but less emphasis than [surfaceContainerHighest].
  Color get surfaceContainerHigh => _surfaceContainerHigh ?? surface;

  final Color? _surfaceContainerHighest;

  /// A surface container color with the darkest tone. It is used to create the
  /// most emphasis against the surface.
  Color get surfaceContainerHighest => _surfaceContainerHighest ?? surface;

  final Color? _onSurfaceVariant;

  /// A color that's clearly legible when drawn on [surfaceVariant].
  ///
  /// To ensure that an app is accessible, a contrast ratio between
  /// [surfaceVariant] and [onSurfaceVariant] of at least 4.5:1 is
  /// recommended. See
  /// <https://www.w3.org/TR/UNDERSTANDING-WCAG20/visual-audio-contrast-contrast.html>.
  Color get onSurfaceVariant => _onSurfaceVariant ?? onSurface;

  final Color? _outline;

  /// A utility color that creates boundaries and emphasis to improve usability.
  Color get outline => _outline ?? onBackground;

  final Color? _outlineVariant;

  /// A utility color that creates boundaries for decorative elements when a
  /// 3:1 contrast isn’t required, such as for dividers or decorative elements.
  Color get outlineVariant => _outlineVariant ?? onBackground;

  final Color? _shadow;

  /// A color use to paint the drop shadows of elevated components.
  Color get shadow => _shadow ?? const Color(0xff000000);

  final Color? _scrim;

  /// A color use to paint the scrim around of modal components.
  Color get scrim => _scrim ?? const Color(0xff000000);

  final Color? _inverseSurface;

  /// A surface color used for displaying the reverse of what’s seen in the
  /// surrounding UI, for example in a SnackBar to bring attention to
  /// an alert.
  Color get inverseSurface => _inverseSurface ?? onSurface;

  final Color? _onInverseSurface;

  /// A color that's clearly legible when drawn on [inverseSurface].
  ///
  /// To ensure that an app is accessible, a contrast ratio between
  /// [inverseSurface] and [onInverseSurface] of at least 4.5:1 is
  /// recommended. See
  /// <https://www.w3.org/TR/UNDERSTANDING-WCAG20/visual-audio-contrast-contrast.html>.
  Color get onInverseSurface => _onInverseSurface ?? surface;

  final Color? _inversePrimary;

  /// An accent color used for displaying a highlight color on [inverseSurface]
  /// backgrounds, like button text in a SnackBar.
  Color get inversePrimary => _inversePrimary ?? onPrimary;

  final Color? _surfaceTint;

  /// A color used as an overlay on a surface color to indicate a component's
  /// elevation.
  Color get surfaceTint => _surfaceTint ?? primary;

  final Color? _background;

  /// A color that typically appears behind scrollable content.
  @Deprecated(
    'Use surface instead. '
    'This feature was deprecated after v3.18.0-0.1.pre.',
  )
  Color get background => _background ?? surface;

  final Color? _onBackground;

  /// A color that's clearly legible when drawn on [background].
  ///
  /// To ensure that an app is accessible, a contrast ratio between
  /// [background] and [onBackground] of at least 4.5:1 is recommended. See
  /// <https://www.w3.org/TR/UNDERSTANDING-WCAG20/visual-audio-contrast-contrast.html>.
  @Deprecated(
    'Use onSurface instead. '
    'This feature was deprecated after v3.18.0-0.1.pre.',
  )
  Color get onBackground => _onBackground ?? onSurface;

  /// Creates a copy of this color scheme with the given fields
  /// replaced by the non-null parameter values.
  ColorScheme copyWith({
    Brightness? brightness,
    Color? primary,
    Color? onPrimary,
    Color? primaryContainer,
    Color? onPrimaryContainer,
    Color? primaryFixed,
    Color? primaryFixedDim,
    Color? onPrimaryFixed,
    Color? onPrimaryFixedVariant,
    Color? secondary,
    Color? onSecondary,
    Color? secondaryContainer,
    Color? onSecondaryContainer,
    Color? secondaryFixed,
    Color? secondaryFixedDim,
    Color? onSecondaryFixed,
    Color? onSecondaryFixedVariant,
    Color? tertiary,
    Color? onTertiary,
    Color? tertiaryContainer,
    Color? onTertiaryContainer,
    Color? tertiaryFixed,
    Color? tertiaryFixedDim,
    Color? onTertiaryFixed,
    Color? onTertiaryFixedVariant,
    Color? error,
    Color? onError,
    Color? errorContainer,
    Color? onErrorContainer,
    Color? surface,
    Color? onSurface,
    Color? surfaceDim,
    Color? surfaceBright,
    Color? surfaceContainerLowest,
    Color? surfaceContainerLow,
    Color? surfaceContainer,
    Color? surfaceContainerHigh,
    Color? surfaceContainerHighest,
    Color? onSurfaceVariant,
    Color? outline,
    Color? outlineVariant,
    Color? shadow,
    Color? scrim,
    Color? inverseSurface,
    Color? onInverseSurface,
    Color? inversePrimary,
    Color? surfaceTint,
    @Deprecated(
      'Use surface instead. '
      'This feature was deprecated after v3.18.0-0.1.pre.',
    )
    Color? background,
    @Deprecated(
      'Use onSurface instead. '
      'This feature was deprecated after v3.18.0-0.1.pre.',
    )
    Color? onBackground,
    @Deprecated(
      'Use surfaceContainerHighest instead. '
      'This feature was deprecated after v3.18.0-0.1.pre.',
    )
    Color? surfaceVariant,
  }) {
    return ColorScheme(
      brightness: brightness ?? this.brightness,
      primary: primary ?? this.primary,
      onPrimary: onPrimary ?? this.onPrimary,
      primaryContainer: primaryContainer ?? this.primaryContainer,
      onPrimaryContainer: onPrimaryContainer ?? this.onPrimaryContainer,
      primaryFixed: primaryFixed ?? this.primaryFixed,
      primaryFixedDim: primaryFixedDim ?? this.primaryFixedDim,
      onPrimaryFixed: onPrimaryFixed ?? this.onPrimaryFixed,
      onPrimaryFixedVariant: onPrimaryFixedVariant ?? this.onPrimaryFixedVariant,
      secondary: secondary ?? this.secondary,
      onSecondary: onSecondary ?? this.onSecondary,
      secondaryContainer: secondaryContainer ?? this.secondaryContainer,
      onSecondaryContainer: onSecondaryContainer ?? this.onSecondaryContainer,
      secondaryFixed: secondaryFixed ?? this.secondaryFixed,
      secondaryFixedDim: secondaryFixedDim ?? this.secondaryFixedDim,
      onSecondaryFixed: onSecondaryFixed ?? this.onSecondaryFixed,
      onSecondaryFixedVariant: onSecondaryFixedVariant ?? this.onSecondaryFixedVariant,
      tertiary: tertiary ?? this.tertiary,
      onTertiary: onTertiary ?? this.onTertiary,
      tertiaryContainer: tertiaryContainer ?? this.tertiaryContainer,
      onTertiaryContainer: onTertiaryContainer ?? this.onTertiaryContainer,
      tertiaryFixed: tertiaryFixed ?? this.tertiaryFixed,
      tertiaryFixedDim: tertiaryFixedDim ?? this.tertiaryFixedDim,
      onTertiaryFixed: onTertiaryFixed ?? this.onTertiaryFixed,
      onTertiaryFixedVariant: onTertiaryFixedVariant ?? this.onTertiaryFixedVariant,
      error: error ?? this.error,
      onError: onError ?? this.onError,
      errorContainer: errorContainer ?? this.errorContainer,
      onErrorContainer: onErrorContainer ?? this.onErrorContainer,
      surface: surface ?? this.surface,
      onSurface: onSurface ?? this.onSurface,
      surfaceDim: surfaceDim ?? this.surfaceDim,
      surfaceBright: surfaceBright ?? this.surfaceBright,
      surfaceContainerLowest: surfaceContainerLowest ?? this.surfaceContainerLowest,
      surfaceContainerLow: surfaceContainerLow ?? this.surfaceContainerLow,
      surfaceContainer: surfaceContainer ?? this.surfaceContainer,
      surfaceContainerHigh: surfaceContainerHigh ?? this.surfaceContainerHigh,
      surfaceContainerHighest: surfaceContainerHighest ?? this.surfaceContainerHighest,
      onSurfaceVariant: onSurfaceVariant ?? this.onSurfaceVariant,
      outline: outline ?? this.outline,
      outlineVariant: outlineVariant ?? this.outlineVariant,
      shadow: shadow ?? this.shadow,
      scrim: scrim ?? this.scrim,
      inverseSurface: inverseSurface ?? this.inverseSurface,
      onInverseSurface: onInverseSurface ?? this.onInverseSurface,
      inversePrimary: inversePrimary ?? this.inversePrimary,
      surfaceTint: surfaceTint ?? this.surfaceTint,
      // DEPRECATED (newest deprecations at the bottom)
      background: background ?? this.background,
      onBackground: onBackground ?? this.onBackground,
      surfaceVariant: surfaceVariant ?? this.surfaceVariant,
    );
  }

  /// Linearly interpolate between two [ColorScheme] objects.
  ///
  /// {@macro dart.ui.shadow.lerp}
  static ColorScheme lerp(ColorScheme a, ColorScheme b, double t) {
    if (identical(a, b)) {
      return a;
    }
    return ColorScheme(
      brightness: t < 0.5 ? a.brightness : b.brightness,
      primary: Color.lerp(a.primary, b.primary, t)!,
      onPrimary: Color.lerp(a.onPrimary, b.onPrimary, t)!,
      primaryContainer: Color.lerp(a.primaryContainer, b.primaryContainer, t),
      onPrimaryContainer: Color.lerp(a.onPrimaryContainer, b.onPrimaryContainer, t),
      primaryFixed: Color.lerp(a.primaryFixed, b.primaryFixed, t),
      primaryFixedDim: Color.lerp(a.primaryFixedDim, b.primaryFixedDim, t),
      onPrimaryFixed: Color.lerp(a.onPrimaryFixed, b.onPrimaryFixed, t),
      onPrimaryFixedVariant: Color.lerp(a.onPrimaryFixedVariant, b.onPrimaryFixedVariant, t),
      secondary: Color.lerp(a.secondary, b.secondary, t)!,
      onSecondary: Color.lerp(a.onSecondary, b.onSecondary, t)!,
      secondaryContainer: Color.lerp(a.secondaryContainer, b.secondaryContainer, t),
      onSecondaryContainer: Color.lerp(a.onSecondaryContainer, b.onSecondaryContainer, t),
      secondaryFixed: Color.lerp(a.secondaryFixed, b.secondaryFixed, t),
      secondaryFixedDim: Color.lerp(a.secondaryFixedDim, b.secondaryFixedDim, t),
      onSecondaryFixed: Color.lerp(a.onSecondaryFixed, b.onSecondaryFixed, t),
      onSecondaryFixedVariant: Color.lerp(a.onSecondaryFixedVariant, b.onSecondaryFixedVariant, t),
      tertiary: Color.lerp(a.tertiary, b.tertiary, t),
      onTertiary: Color.lerp(a.onTertiary, b.onTertiary, t),
      tertiaryContainer: Color.lerp(a.tertiaryContainer, b.tertiaryContainer, t),
      onTertiaryContainer: Color.lerp(a.onTertiaryContainer, b.onTertiaryContainer, t),
      tertiaryFixed: Color.lerp(a.tertiaryFixed, b.tertiaryFixed, t),
      tertiaryFixedDim: Color.lerp(a.tertiaryFixedDim, b.tertiaryFixedDim, t),
      onTertiaryFixed: Color.lerp(a.onTertiaryFixed, b.onTertiaryFixed, t),
      onTertiaryFixedVariant: Color.lerp(a.onTertiaryFixedVariant, b.onTertiaryFixedVariant, t),
      error: Color.lerp(a.error, b.error, t)!,
      onError: Color.lerp(a.onError, b.onError, t)!,
      errorContainer: Color.lerp(a.errorContainer, b.errorContainer, t),
      onErrorContainer: Color.lerp(a.onErrorContainer, b.onErrorContainer, t),
      surface: Color.lerp(a.surface, b.surface, t)!,
      onSurface: Color.lerp(a.onSurface, b.onSurface, t)!,
      surfaceDim: Color.lerp(a.surfaceDim, b.surfaceDim, t),
      surfaceBright: Color.lerp(a.surfaceBright, b.surfaceBright, t),
      surfaceContainerLowest: Color.lerp(a.surfaceContainerLowest, b.surfaceContainerLowest, t),
      surfaceContainerLow: Color.lerp(a.surfaceContainerLow, b.surfaceContainerLow, t),
      surfaceContainer: Color.lerp(a.surfaceContainer, b.surfaceContainer, t),
      surfaceContainerHigh: Color.lerp(a.surfaceContainerHigh, b.surfaceContainerHigh, t),
      surfaceContainerHighest: Color.lerp(a.surfaceContainerHighest, b.surfaceContainerHighest, t),
      onSurfaceVariant: Color.lerp(a.onSurfaceVariant, b.onSurfaceVariant, t),
      outline: Color.lerp(a.outline, b.outline, t),
      outlineVariant: Color.lerp(a.outlineVariant, b.outlineVariant, t),
      shadow: Color.lerp(a.shadow, b.shadow, t),
      scrim: Color.lerp(a.scrim, b.scrim, t),
      inverseSurface: Color.lerp(a.inverseSurface, b.inverseSurface, t),
      onInverseSurface: Color.lerp(a.onInverseSurface, b.onInverseSurface, t),
      inversePrimary: Color.lerp(a.inversePrimary, b.inversePrimary, t),
      surfaceTint: Color.lerp(a.surfaceTint, b.surfaceTint, t),
      // DEPRECATED (newest deprecations at the bottom)
      background: Color.lerp(a.background, b.background, t),
      onBackground: Color.lerp(a.onBackground, b.onBackground, t),
      surfaceVariant: Color.lerp(a.surfaceVariant, b.surfaceVariant, t),
    );
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other.runtimeType != runtimeType) {
      return false;
    }
    return other is ColorScheme &&
        other.brightness == brightness &&
        other.primary == primary &&
        other.onPrimary == onPrimary &&
        other.primaryContainer == primaryContainer &&
        other.onPrimaryContainer == onPrimaryContainer &&
        other.primaryFixed == primaryFixed &&
        other.primaryFixedDim == primaryFixedDim &&
        other.onPrimaryFixed == onPrimaryFixed &&
        other.onPrimaryFixedVariant == onPrimaryFixedVariant &&
        other.secondary == secondary &&
        other.onSecondary == onSecondary &&
        other.secondaryContainer == secondaryContainer &&
        other.onSecondaryContainer == onSecondaryContainer &&
        other.secondaryFixed == secondaryFixed &&
        other.secondaryFixedDim == secondaryFixedDim &&
        other.onSecondaryFixed == onSecondaryFixed &&
        other.onSecondaryFixedVariant == onSecondaryFixedVariant &&
        other.tertiary == tertiary &&
        other.onTertiary == onTertiary &&
        other.tertiaryContainer == tertiaryContainer &&
        other.onTertiaryContainer == onTertiaryContainer &&
        other.tertiaryFixed == tertiaryFixed &&
        other.tertiaryFixedDim == tertiaryFixedDim &&
        other.onTertiaryFixed == onTertiaryFixed &&
        other.onTertiaryFixedVariant == onTertiaryFixedVariant &&
        other.error == error &&
        other.onError == onError &&
        other.errorContainer == errorContainer &&
        other.onErrorContainer == onErrorContainer &&
        other.surface == surface &&
        other.onSurface == onSurface &&
        other.surfaceDim == surfaceDim &&
        other.surfaceBright == surfaceBright &&
        other.surfaceContainerLowest == surfaceContainerLowest &&
        other.surfaceContainerLow == surfaceContainerLow &&
        other.surfaceContainer == surfaceContainer &&
        other.surfaceContainerHigh == surfaceContainerHigh &&
        other.surfaceContainerHighest == surfaceContainerHighest &&
        other.onSurfaceVariant == onSurfaceVariant &&
        other.outline == outline &&
        other.outlineVariant == outlineVariant &&
        other.shadow == shadow &&
        other.scrim == scrim &&
        other.inverseSurface == inverseSurface &&
        other.onInverseSurface == onInverseSurface &&
        other.inversePrimary == inversePrimary &&
        other.surfaceTint == surfaceTint
        // DEPRECATED (newest deprecations at the bottom)
        &&
        other.background == background &&
        other.onBackground == onBackground &&
        other.surfaceVariant == surfaceVariant;
  }

  @override
  int get hashCode => Object.hash(
    brightness,
    primary,
    onPrimary,
    primaryContainer,
    onPrimaryContainer,
    secondary,
    onSecondary,
    secondaryContainer,
    onSecondaryContainer,
    tertiary,
    onTertiary,
    tertiaryContainer,
    onTertiaryContainer,
    error,
    onError,
    errorContainer,
    onErrorContainer,
    Object.hash(
      surface,
      onSurface,
      surfaceDim,
      surfaceBright,
      surfaceContainerLowest,
      surfaceContainerLow,
      surfaceContainer,
      surfaceContainerHigh,
      surfaceContainerHighest,
      onSurfaceVariant,
      outline,
      outlineVariant,
      shadow,
      scrim,
      inverseSurface,
      onInverseSurface,
      inversePrimary,
      surfaceTint,
      Object.hash(
        primaryFixed,
        primaryFixedDim,
        onPrimaryFixed,
        onPrimaryFixedVariant,
        secondaryFixed,
        secondaryFixedDim,
        onSecondaryFixed,
        onSecondaryFixedVariant,
        tertiaryFixed,
        tertiaryFixedDim,
        onTertiaryFixed,
        onTertiaryFixedVariant,
        // DEPRECATED (newest deprecations at the bottom)
        background,
        onBackground,
        surfaceVariant,
      ),
    ),
  );

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    const ColorScheme defaultScheme = ColorScheme.light();
    properties.add(
      DiagnosticsProperty<Brightness>(
        'brightness',
        brightness,
        defaultValue: defaultScheme.brightness,
      ),
    );
    properties.add(ColorProperty('primary', primary, defaultValue: defaultScheme.primary));
    properties.add(ColorProperty('onPrimary', onPrimary, defaultValue: defaultScheme.onPrimary));
    properties.add(
      ColorProperty(
        'primaryContainer',
        primaryContainer,
        defaultValue: defaultScheme.primaryContainer,
      ),
    );
    properties.add(
      ColorProperty(
        'onPrimaryContainer',
        onPrimaryContainer,
        defaultValue: defaultScheme.onPrimaryContainer,
      ),
    );
    properties.add(
      ColorProperty('primaryFixed', primaryFixed, defaultValue: defaultScheme.primaryFixed),
    );
    properties.add(
      ColorProperty(
        'primaryFixedDim',
        primaryFixedDim,
        defaultValue: defaultScheme.primaryFixedDim,
      ),
    );
    properties.add(
      ColorProperty('onPrimaryFixed', onPrimaryFixed, defaultValue: defaultScheme.onPrimaryFixed),
    );
    properties.add(
      ColorProperty(
        'onPrimaryFixedVariant',
        onPrimaryFixedVariant,
        defaultValue: defaultScheme.onPrimaryFixedVariant,
      ),
    );
    properties.add(ColorProperty('secondary', secondary, defaultValue: defaultScheme.secondary));
    properties.add(
      ColorProperty('onSecondary', onSecondary, defaultValue: defaultScheme.onSecondary),
    );
    properties.add(
      ColorProperty(
        'secondaryContainer',
        secondaryContainer,
        defaultValue: defaultScheme.secondaryContainer,
      ),
    );
    properties.add(
      ColorProperty(
        'onSecondaryContainer',
        onSecondaryContainer,
        defaultValue: defaultScheme.onSecondaryContainer,
      ),
    );
    properties.add(
      ColorProperty('secondaryFixed', secondaryFixed, defaultValue: defaultScheme.secondaryFixed),
    );
    properties.add(
      ColorProperty(
        'secondaryFixedDim',
        secondaryFixedDim,
        defaultValue: defaultScheme.secondaryFixedDim,
      ),
    );
    properties.add(
      ColorProperty(
        'onSecondaryFixed',
        onSecondaryFixed,
        defaultValue: defaultScheme.onSecondaryFixed,
      ),
    );
    properties.add(
      ColorProperty(
        'onSecondaryFixedVariant',
        onSecondaryFixedVariant,
        defaultValue: defaultScheme.onSecondaryFixedVariant,
      ),
    );
    properties.add(ColorProperty('tertiary', tertiary, defaultValue: defaultScheme.tertiary));
    properties.add(ColorProperty('onTertiary', onTertiary, defaultValue: defaultScheme.onTertiary));
    properties.add(
      ColorProperty(
        'tertiaryContainer',
        tertiaryContainer,
        defaultValue: defaultScheme.tertiaryContainer,
      ),
    );
    properties.add(
      ColorProperty(
        'onTertiaryContainer',
        onTertiaryContainer,
        defaultValue: defaultScheme.onTertiaryContainer,
      ),
    );
    properties.add(
      ColorProperty('tertiaryFixed', tertiaryFixed, defaultValue: defaultScheme.tertiaryFixed),
    );
    properties.add(
      ColorProperty(
        'tertiaryFixedDim',
        tertiaryFixedDim,
        defaultValue: defaultScheme.tertiaryFixedDim,
      ),
    );
    properties.add(
      ColorProperty(
        'onTertiaryFixed',
        onTertiaryFixed,
        defaultValue: defaultScheme.onTertiaryFixed,
      ),
    );
    properties.add(
      ColorProperty(
        'onTertiaryFixedVariant',
        onTertiaryFixedVariant,
        defaultValue: defaultScheme.onTertiaryFixedVariant,
      ),
    );
    properties.add(ColorProperty('error', error, defaultValue: defaultScheme.error));
    properties.add(ColorProperty('onError', onError, defaultValue: defaultScheme.onError));
    properties.add(
      ColorProperty('errorContainer', errorContainer, defaultValue: defaultScheme.errorContainer),
    );
    properties.add(
      ColorProperty(
        'onErrorContainer',
        onErrorContainer,
        defaultValue: defaultScheme.onErrorContainer,
      ),
    );
    properties.add(ColorProperty('surface', surface, defaultValue: defaultScheme.surface));
    properties.add(ColorProperty('onSurface', onSurface, defaultValue: defaultScheme.onSurface));
    properties.add(ColorProperty('surfaceDim', surfaceDim, defaultValue: defaultScheme.surfaceDim));
    properties.add(
      ColorProperty('surfaceBright', surfaceBright, defaultValue: defaultScheme.surfaceBright),
    );
    properties.add(
      ColorProperty(
        'surfaceContainerLowest',
        surfaceContainerLowest,
        defaultValue: defaultScheme.surfaceContainerLowest,
      ),
    );
    properties.add(
      ColorProperty(
        'surfaceContainerLow',
        surfaceContainerLow,
        defaultValue: defaultScheme.surfaceContainerLow,
      ),
    );
    properties.add(
      ColorProperty(
        'surfaceContainer',
        surfaceContainer,
        defaultValue: defaultScheme.surfaceContainer,
      ),
    );
    properties.add(
      ColorProperty(
        'surfaceContainerHigh',
        surfaceContainerHigh,
        defaultValue: defaultScheme.surfaceContainerHigh,
      ),
    );
    properties.add(
      ColorProperty(
        'surfaceContainerHighest',
        surfaceContainerHighest,
        defaultValue: defaultScheme.surfaceContainerHighest,
      ),
    );
    properties.add(
      ColorProperty(
        'onSurfaceVariant',
        onSurfaceVariant,
        defaultValue: defaultScheme.onSurfaceVariant,
      ),
    );
    properties.add(ColorProperty('outline', outline, defaultValue: defaultScheme.outline));
    properties.add(
      ColorProperty('outlineVariant', outlineVariant, defaultValue: defaultScheme.outlineVariant),
    );
    properties.add(ColorProperty('shadow', shadow, defaultValue: defaultScheme.shadow));
    properties.add(ColorProperty('scrim', scrim, defaultValue: defaultScheme.scrim));
    properties.add(
      ColorProperty('inverseSurface', inverseSurface, defaultValue: defaultScheme.inverseSurface),
    );
    properties.add(
      ColorProperty(
        'onInverseSurface',
        onInverseSurface,
        defaultValue: defaultScheme.onInverseSurface,
      ),
    );
    properties.add(
      ColorProperty('inversePrimary', inversePrimary, defaultValue: defaultScheme.inversePrimary),
    );
    properties.add(
      ColorProperty('surfaceTint', surfaceTint, defaultValue: defaultScheme.surfaceTint),
    );
    // DEPRECATED (newest deprecations at the bottom)
    properties.add(ColorProperty('background', background, defaultValue: defaultScheme.background));
    properties.add(
      ColorProperty('onBackground', onBackground, defaultValue: defaultScheme.onBackground),
    );
    properties.add(
      ColorProperty('surfaceVariant', surfaceVariant, defaultValue: defaultScheme.surfaceVariant),
    );
  }

  /// Generate a [ColorScheme] derived from the given `imageProvider`.
  ///
  /// Material Color Utilities extracts the dominant color from the
  /// supplied [ImageProvider]. Using this color, a [ColorScheme] is generated
  /// with harmonious colors that meet contrast requirements for accessibility.
  ///
  /// If any of the optional color parameters are non-null, they will be
  /// used in place of the generated colors for that field in the resulting
  /// [ColorScheme]. This allows apps to override specific colors for their
  /// needs.
  ///
  /// Given the nature of the algorithm, the most dominant color of the
  /// `imageProvider` may not wind up as one of the [ColorScheme] colors.
  ///
  /// The provided image will be scaled down to a maximum size of 112x112 pixels
  /// during color extraction.
  ///
  /// {@tool dartpad}
  /// This sample shows how to use [ColorScheme.fromImageProvider] to create
  /// content-based dynamic color schemes.
  ///
  /// ** See code in examples/api/lib/material/color_scheme/dynamic_content_color.0.dart **
  /// {@end-tool}
  ///
  /// See also:
  ///
  ///  * [M3 Guidelines: Dynamic color from content](https://m3.material.io/styles/color/dynamic-color/user-generated-color#8af550b9-a19e-4e9f-bb0a-7f611fed5d0f)
  ///  * <https://pub.dev/packages/dynamic_color>, a package to create
  ///    [ColorScheme]s based on a platform's implementation of dynamic color.
  ///  * <https://m3.material.io/styles/color/the-color-system/color-roles>, the
  ///    Material 3 Color system specification.
  ///  * <https://pub.dev/packages/material_color_utilities>, the package
  ///    used to algorithmically determine the dominant color and to generate
  ///    the [ColorScheme].
  static Future<ColorScheme> fromImageProvider({
    required ImageProvider provider,
    Brightness brightness = Brightness.light,
    DynamicSchemeVariant dynamicSchemeVariant = DynamicSchemeVariant.tonalSpot,
    double contrastLevel = 0.0,
    Color? primary,
    Color? onPrimary,
    Color? primaryContainer,
    Color? onPrimaryContainer,
    Color? primaryFixed,
    Color? primaryFixedDim,
    Color? onPrimaryFixed,
    Color? onPrimaryFixedVariant,
    Color? secondary,
    Color? onSecondary,
    Color? secondaryContainer,
    Color? onSecondaryContainer,
    Color? secondaryFixed,
    Color? secondaryFixedDim,
    Color? onSecondaryFixed,
    Color? onSecondaryFixedVariant,
    Color? tertiary,
    Color? onTertiary,
    Color? tertiaryContainer,
    Color? onTertiaryContainer,
    Color? tertiaryFixed,
    Color? tertiaryFixedDim,
    Color? onTertiaryFixed,
    Color? onTertiaryFixedVariant,
    Color? error,
    Color? onError,
    Color? errorContainer,
    Color? onErrorContainer,
    Color? outline,
    Color? outlineVariant,
    Color? surface,
    Color? onSurface,
    Color? surfaceDim,
    Color? surfaceBright,
    Color? surfaceContainerLowest,
    Color? surfaceContainerLow,
    Color? surfaceContainer,
    Color? surfaceContainerHigh,
    Color? surfaceContainerHighest,
    Color? onSurfaceVariant,
    Color? inverseSurface,
    Color? onInverseSurface,
    Color? inversePrimary,
    Color? shadow,
    Color? scrim,
    Color? surfaceTint,
    @Deprecated(
      'Use surface instead. '
      'This feature was deprecated after v3.18.0-0.1.pre.',
    )
    Color? background,
    @Deprecated(
      'Use onSurface instead. '
      'This feature was deprecated after v3.18.0-0.1.pre.',
    )
    Color? onBackground,
    @Deprecated(
      'Use surfaceContainerHighest instead. '
      'This feature was deprecated after v3.18.0-0.1.pre.',
    )
    Color? surfaceVariant,
  }) async {
    // Extract dominant colors from image.
    final QuantizerResult quantizerResult = await _extractColorsFromImageProvider(provider);
    final Map<int, int> colorToCount = quantizerResult.colorToCount.map(
      (int key, int value) => MapEntry<int, int>(_getArgbFromAbgr(key), value),
    );

    // Score colors for color scheme suitability.
    final List<int> scoredResults = Score.score(colorToCount, desired: 1);
    final ui.Color baseColor = Color(scoredResults.first);

    final DynamicScheme scheme = _buildDynamicScheme(
      brightness,
      baseColor,
      dynamicSchemeVariant,
      contrastLevel,
    );

    return ColorScheme(
      primary: primary ?? Color(MaterialDynamicColors.primary.getArgb(scheme)),
      onPrimary: onPrimary ?? Color(MaterialDynamicColors.onPrimary.getArgb(scheme)),
      primaryContainer:
          primaryContainer ?? Color(MaterialDynamicColors.primaryContainer.getArgb(scheme)),
      onPrimaryContainer:
          onPrimaryContainer ?? Color(MaterialDynamicColors.onPrimaryContainer.getArgb(scheme)),
      primaryFixed: primaryFixed ?? Color(MaterialDynamicColors.primaryFixed.getArgb(scheme)),
      primaryFixedDim:
          primaryFixedDim ?? Color(MaterialDynamicColors.primaryFixedDim.getArgb(scheme)),
      onPrimaryFixed: onPrimaryFixed ?? Color(MaterialDynamicColors.onPrimaryFixed.getArgb(scheme)),
      onPrimaryFixedVariant:
          onPrimaryFixedVariant ??
          Color(MaterialDynamicColors.onPrimaryFixedVariant.getArgb(scheme)),
      secondary: secondary ?? Color(MaterialDynamicColors.secondary.getArgb(scheme)),
      onSecondary: onSecondary ?? Color(MaterialDynamicColors.onSecondary.getArgb(scheme)),
      secondaryContainer:
          secondaryContainer ?? Color(MaterialDynamicColors.secondaryContainer.getArgb(scheme)),
      onSecondaryContainer:
          onSecondaryContainer ?? Color(MaterialDynamicColors.onSecondaryContainer.getArgb(scheme)),
      secondaryFixed: secondaryFixed ?? Color(MaterialDynamicColors.secondaryFixed.getArgb(scheme)),
      secondaryFixedDim:
          secondaryFixedDim ?? Color(MaterialDynamicColors.secondaryFixedDim.getArgb(scheme)),
      onSecondaryFixed:
          onSecondaryFixed ?? Color(MaterialDynamicColors.onSecondaryFixed.getArgb(scheme)),
      onSecondaryFixedVariant:
          onSecondaryFixedVariant ??
          Color(MaterialDynamicColors.onSecondaryFixedVariant.getArgb(scheme)),
      tertiary: tertiary ?? Color(MaterialDynamicColors.tertiary.getArgb(scheme)),
      onTertiary: onTertiary ?? Color(MaterialDynamicColors.onTertiary.getArgb(scheme)),
      tertiaryContainer:
          tertiaryContainer ?? Color(MaterialDynamicColors.tertiaryContainer.getArgb(scheme)),
      onTertiaryContainer:
          onTertiaryContainer ?? Color(MaterialDynamicColors.onTertiaryContainer.getArgb(scheme)),
      tertiaryFixed: tertiaryFixed ?? Color(MaterialDynamicColors.tertiaryFixed.getArgb(scheme)),
      tertiaryFixedDim:
          tertiaryFixedDim ?? Color(MaterialDynamicColors.tertiaryFixedDim.getArgb(scheme)),
      onTertiaryFixed:
          onTertiaryFixed ?? Color(MaterialDynamicColors.onTertiaryFixed.getArgb(scheme)),
      onTertiaryFixedVariant:
          onTertiaryFixedVariant ??
          Color(MaterialDynamicColors.onTertiaryFixedVariant.getArgb(scheme)),
      error: error ?? Color(MaterialDynamicColors.error.getArgb(scheme)),
      onError: onError ?? Color(MaterialDynamicColors.onError.getArgb(scheme)),
      errorContainer: errorContainer ?? Color(MaterialDynamicColors.errorContainer.getArgb(scheme)),
      onErrorContainer:
          onErrorContainer ?? Color(MaterialDynamicColors.onErrorContainer.getArgb(scheme)),
      outline: outline ?? Color(MaterialDynamicColors.outline.getArgb(scheme)),
      outlineVariant: outlineVariant ?? Color(MaterialDynamicColors.outlineVariant.getArgb(scheme)),
      surface: surface ?? Color(MaterialDynamicColors.surface.getArgb(scheme)),
      surfaceDim: surfaceDim ?? Color(MaterialDynamicColors.surfaceDim.getArgb(scheme)),
      surfaceBright: surfaceBright ?? Color(MaterialDynamicColors.surfaceBright.getArgb(scheme)),
      surfaceContainerLowest:
          surfaceContainerLowest ??
          Color(MaterialDynamicColors.surfaceContainerLowest.getArgb(scheme)),
      surfaceContainerLow:
          surfaceContainerLow ?? Color(MaterialDynamicColors.surfaceContainerLow.getArgb(scheme)),
      surfaceContainer:
          surfaceContainer ?? Color(MaterialDynamicColors.surfaceContainer.getArgb(scheme)),
      surfaceContainerHigh:
          surfaceContainerHigh ?? Color(MaterialDynamicColors.surfaceContainerHigh.getArgb(scheme)),
      surfaceContainerHighest:
          surfaceContainerHighest ??
          Color(MaterialDynamicColors.surfaceContainerHighest.getArgb(scheme)),
      onSurface: onSurface ?? Color(MaterialDynamicColors.onSurface.getArgb(scheme)),
      onSurfaceVariant:
          onSurfaceVariant ?? Color(MaterialDynamicColors.onSurfaceVariant.getArgb(scheme)),
      inverseSurface: inverseSurface ?? Color(MaterialDynamicColors.inverseSurface.getArgb(scheme)),
      onInverseSurface:
          onInverseSurface ?? Color(MaterialDynamicColors.inverseOnSurface.getArgb(scheme)),
      inversePrimary: inversePrimary ?? Color(MaterialDynamicColors.inversePrimary.getArgb(scheme)),
      shadow: shadow ?? Color(MaterialDynamicColors.shadow.getArgb(scheme)),
      scrim: scrim ?? Color(MaterialDynamicColors.scrim.getArgb(scheme)),
      surfaceTint: surfaceTint ?? Color(MaterialDynamicColors.primary.getArgb(scheme)),
      brightness: brightness,
      // DEPRECATED (newest deprecations at the bottom)
      background: background ?? Color(MaterialDynamicColors.background.getArgb(scheme)),
      onBackground: onBackground ?? Color(MaterialDynamicColors.onBackground.getArgb(scheme)),
      surfaceVariant: surfaceVariant ?? Color(MaterialDynamicColors.surfaceVariant.getArgb(scheme)),
    );
  }

  // ColorScheme.fromImageProvider() utilities.

  // Extracts bytes from an [ImageProvider] and returns a [QuantizerResult]
  // containing the most dominant colors.
  static Future<QuantizerResult> _extractColorsFromImageProvider(
    ImageProvider imageProvider,
  ) async {
    final ui.Image scaledImage = await _imageProviderToScaled(imageProvider);
    final ByteData? imageBytes = await scaledImage.toByteData();

    final QuantizerResult quantizerResult = await QuantizerCelebi().quantize(
      imageBytes!.buffer.asUint32List(),
      128,
      returnInputPixelToClusterPixel: true,
    );
    return quantizerResult;
  }

  // Scale image size down to reduce computation time of color extraction.
  static Future<ui.Image> _imageProviderToScaled(ImageProvider imageProvider) async {
    const double maxDimension = 112.0;
    final ImageStream stream = imageProvider.resolve(
      const ImageConfiguration(size: Size(maxDimension, maxDimension)),
    );
    final Completer<ui.Image> imageCompleter = Completer<ui.Image>();
    late ImageStreamListener listener;
    late ui.Image scaledImage;
    Timer? loadFailureTimeout;

    listener = ImageStreamListener(
      (ImageInfo info, bool sync) async {
        loadFailureTimeout?.cancel();
        stream.removeListener(listener);
        final ui.Image image = info.image;
        final int width = image.width;
        final int height = image.height;
        double paintWidth = width.toDouble();
        double paintHeight = height.toDouble();
        assert(width > 0 && height > 0);

        final bool rescale = width > maxDimension || height > maxDimension;
        if (rescale) {
          paintWidth = (width > height) ? maxDimension : (maxDimension / height) * width;
          paintHeight = (height > width) ? maxDimension : (maxDimension / width) * height;
        }
        final ui.PictureRecorder pictureRecorder = ui.PictureRecorder();
        final Canvas canvas = Canvas(pictureRecorder);
        paintImage(
          canvas: canvas,
          rect: Rect.fromLTRB(0, 0, paintWidth, paintHeight),
          image: image,
          filterQuality: FilterQuality.none,
        );

        final ui.Picture picture = pictureRecorder.endRecording();
        scaledImage = await picture.toImage(paintWidth.toInt(), paintHeight.toInt());
        imageCompleter.complete(info.image);
      },
      onError: (Object exception, StackTrace? stackTrace) {
        stream.removeListener(listener);
        throw Exception('Failed to render image: $exception');
      },
    );

    loadFailureTimeout = Timer(const Duration(seconds: 5), () {
      stream.removeListener(listener);
      imageCompleter.completeError(TimeoutException('Timeout occurred trying to load image'));
    });

    stream.addListener(listener);
    await imageCompleter.future;
    return scaledImage;
  }

  // Converts AABBGGRR color int to AARRGGBB format.
  static int _getArgbFromAbgr(int abgr) {
    const int exceptRMask = 0xFF00FFFF;
    const int onlyRMask = ~exceptRMask;
    const int exceptBMask = 0xFFFFFF00;
    const int onlyBMask = ~exceptBMask;
    final int r = (abgr & onlyRMask) >> 16;
    final int b = abgr & onlyBMask;
    return (abgr & exceptRMask & exceptBMask) | (b << 16) | r;
  }

  static DynamicScheme _buildDynamicScheme(
    Brightness brightness,
    Color seedColor,
    DynamicSchemeVariant schemeVariant,
    double contrastLevel,
  ) {
    assert(
      contrastLevel >= -1.0 && contrastLevel <= 1.0,
      'contrastLevel must be between -1.0 and 1.0 inclusive.',
    );
    final bool isDark = brightness == Brightness.dark;
    final Hct sourceColor = Hct.fromInt(seedColor.value);
    return switch (schemeVariant) {
      DynamicSchemeVariant.tonalSpot => SchemeTonalSpot(
        sourceColorHct: sourceColor,
        isDark: isDark,
        contrastLevel: contrastLevel,
      ),
      DynamicSchemeVariant.fidelity => SchemeFidelity(
        sourceColorHct: sourceColor,
        isDark: isDark,
        contrastLevel: contrastLevel,
      ),
      DynamicSchemeVariant.content => SchemeContent(
        sourceColorHct: sourceColor,
        isDark: isDark,
        contrastLevel: contrastLevel,
      ),
      DynamicSchemeVariant.monochrome => SchemeMonochrome(
        sourceColorHct: sourceColor,
        isDark: isDark,
        contrastLevel: contrastLevel,
      ),
      DynamicSchemeVariant.neutral => SchemeNeutral(
        sourceColorHct: sourceColor,
        isDark: isDark,
        contrastLevel: contrastLevel,
      ),
      DynamicSchemeVariant.vibrant => SchemeVibrant(
        sourceColorHct: sourceColor,
        isDark: isDark,
        contrastLevel: contrastLevel,
      ),
      DynamicSchemeVariant.expressive => SchemeExpressive(
        sourceColorHct: sourceColor,
        isDark: isDark,
        contrastLevel: contrastLevel,
      ),
      DynamicSchemeVariant.rainbow => SchemeRainbow(
        sourceColorHct: sourceColor,
        isDark: isDark,
        contrastLevel: contrastLevel,
      ),
      DynamicSchemeVariant.fruitSalad => SchemeFruitSalad(
        sourceColorHct: sourceColor,
        isDark: isDark,
        contrastLevel: contrastLevel,
      ),
    };
  }

  /// The [ThemeData.colorScheme] of the ambient [Theme].
  ///
  /// Equivalent to `Theme.of(context).colorScheme`.
  static ColorScheme of(BuildContext context) => Theme.of(context).colorScheme;
}
\n\n--- File: 1 # packages/flutter/lib/src/material/theme_data.dart ---\n// Copyright 2014 The Flutter Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

/// @docImport 'package:flutter/material.dart';
library;

import 'dart:ui' show Color, lerpDouble;

import 'package:flutter/cupertino.dart';
import 'package:flutter/foundation.dart';

import 'action_buttons.dart';
import 'action_icons_theme.dart';
import 'app_bar_theme.dart';
import 'badge_theme.dart';
import 'banner_theme.dart';
import 'bottom_app_bar_theme.dart';
import 'bottom_navigation_bar_theme.dart';
import 'bottom_sheet_theme.dart';
import 'button_bar_theme.dart';
import 'button_theme.dart';
import 'card_theme.dart';
import 'checkbox_theme.dart';
import 'chip_theme.dart';
import 'color_scheme.dart';
import 'colors.dart';
import 'constants.dart';
import 'data_table_theme.dart';
import 'date_picker_theme.dart';
import 'dialog_theme.dart';
import 'divider_theme.dart';
import 'drawer_theme.dart';
import 'dropdown_menu_theme.dart';
import 'elevated_button_theme.dart';
import 'expansion_tile_theme.dart';
import 'filled_button_theme.dart';
import 'floating_action_button_theme.dart';
import 'icon_button_theme.dart';
import 'ink_ripple.dart';
import 'ink_sparkle.dart';
import 'ink_splash.dart';
import 'ink_well.dart' show InteractiveInkFeatureFactory;
import 'input_decorator.dart';
import 'list_tile.dart';
import 'list_tile_theme.dart';
import 'menu_bar_theme.dart';
import 'menu_button_theme.dart';
import 'menu_theme.dart';
import 'navigation_bar_theme.dart';
import 'navigation_drawer_theme.dart';
import 'navigation_rail_theme.dart';
import 'outlined_button_theme.dart';
import 'page_transitions_theme.dart';
import 'popup_menu_theme.dart';
import 'progress_indicator_theme.dart';
import 'radio_theme.dart';
import 'scrollbar_theme.dart';
import 'search_bar_theme.dart';
import 'search_view_theme.dart';
import 'segmented_button_theme.dart';
import 'slider_theme.dart';
import 'snack_bar_theme.dart';
import 'switch_theme.dart';
import 'tab_bar_theme.dart';
import 'text_button_theme.dart';
import 'text_selection_theme.dart';
import 'text_theme.dart';
import 'time_picker_theme.dart';
import 'toggle_buttons_theme.dart';
import 'tooltip_theme.dart';
import 'typography.dart';

export 'package:flutter/services.dart' show Brightness;

// Examples can assume:
// late BuildContext context;

/// Defines a customized theme for components with an `adaptive` factory constructor.
///
/// Currently, only [Switch.adaptive] supports this class.
class Adaptation<T> {
  /// Creates an [Adaptation].
  const Adaptation();

  /// The adaptation's type.
  Type get type => T;

  /// Typically, this is overridden to return an instance of a custom component
  /// ThemeData class, like [SwitchThemeData], instead of the defaultValue.
  ///
  /// Factory constructors that support adaptations - currently only
  /// [Switch.adaptive] - look for a type-specific adaptation in
  /// [ThemeData.adaptationMap] when computing their effective default component
  /// theme. If a matching adaptation is not found, the component may choose to
  /// use a default adaptation. For example, the [Switch.adaptive] component
  /// uses an empty [SwitchThemeData] if a matching adaptation is not found, for
  /// the sake of backwards compatibility.
  ///
  /// {@tool dartpad}
  /// This sample shows how to create and use subclasses of [Adaptation] that
  /// define adaptive [SwitchThemeData]s. The [adapt] method in this example is
  /// overridden to only customize cupertino-style switches, but it can also be
  /// used to customize any other platforms.
  ///
  /// ** See code in examples/api/lib/material/switch/switch.4.dart **
  /// {@end-tool}
  T adapt(ThemeData theme, T defaultValue) => defaultValue;
}

/// An interface that defines custom additions to a [ThemeData] object.
///
/// {@youtube 560 315 https://www.youtube.com/watch?v=8-szcYzFVao}
///
/// Typically used for custom colors. To use, subclass [ThemeExtension],
/// define a number of fields (e.g. [Color]s), and implement the [copyWith] and
/// [lerp] methods. The latter will ensure smooth transitions of properties when
/// switching themes.
///
/// {@tool dartpad}
/// This sample shows how to create and use a subclass of [ThemeExtension] that
/// defines two colors.
///
/// ** See code in examples/api/lib/material/theme/theme_extension.1.dart **
/// {@end-tool}
abstract class ThemeExtension<T extends ThemeExtension<T>> {
  /// Enable const constructor for subclasses.
  const ThemeExtension();

  /// The extension's type.
  Object get type => T;

  /// Creates a copy of this theme extension with the given fields
  /// replaced by the non-null parameter values.
  ThemeExtension<T> copyWith();

  /// Linearly interpolate with another [ThemeExtension] object.
  ///
  /// {@macro dart.ui.shadow.lerp}
  ThemeExtension<T> lerp(covariant ThemeExtension<T>? other, double t);
}

/// Configures the tap target and layout size of certain Material widgets.
///
/// Changing the value in [ThemeData.materialTapTargetSize] will affect the
/// accessibility experience.
///
/// Some of the impacted widgets include:
///
///   * [FloatingActionButton], only the mini tap target size is increased.
///   * [MaterialButton]
///   * [OutlinedButton]
///   * [TextButton]
///   * [ElevatedButton]
///   * [IconButton]
///   * The time picker widget ([showTimePicker])
///   * [SnackBar]
///   * [Chip]
///   * [RawChip]
///   * [InputChip]
///   * [ChoiceChip]
///   * [FilterChip]
///   * [ActionChip]
///   * [Radio]
///   * [Switch]
///   * [Checkbox]
enum MaterialTapTargetSize {
  /// Expands the minimum tap target size to 48px by 48px.
  ///
  /// This is the default value of [ThemeData.materialTapTargetSize] and the
  /// recommended size to conform to Android accessibility scanner
  /// recommendations.
  padded,

  /// Shrinks the tap target size to the minimum provided by the Material
  /// specification.
  shrinkWrap,
}

/// Defines the configuration of the overall visual [Theme] for a [MaterialApp]
/// or a widget subtree within the app.
///
/// The [MaterialApp] theme property can be used to configure the appearance
/// of the entire app. Widget subtrees within an app can override the app's
/// theme by including a [Theme] widget at the top of the subtree.
///
/// Widgets whose appearance should align with the overall theme can obtain the
/// current theme's configuration with [Theme.of]. Material components typically
/// depend exclusively on the [colorScheme] and [textTheme]. These properties
/// are guaranteed to have non-null values.
///
/// The static [Theme.of] method finds the [ThemeData] value specified for the
/// nearest [BuildContext] ancestor. This lookup is inexpensive, essentially
/// just a single HashMap access. It can sometimes be a little confusing
/// because [Theme.of] can not see a [Theme] widget that is defined in the
/// current build method's context. To overcome that, create a new custom widget
/// for the subtree that appears below the new [Theme], or insert a widget
/// that creates a new BuildContext, like [Builder].
///
/// {@tool dartpad}
/// This example demonstrates how a typical [MaterialApp] specifies
/// and uses a custom [Theme]. The theme's [ColorScheme] is based on a
/// single "seed" color and configures itself to match the platform's
/// current light or dark color configuration. The theme overrides the
/// default configuration of [FloatingActionButton] to show how to
/// customize the appearance a class of components.
///
/// ** See code in examples/api/lib/material/theme_data/theme_data.0.dart **
/// {@end-tool}
///
/// See <https://material.io/design/color/> for
/// more discussion on how to pick the right colors.

@immutable
class ThemeData with Diagnosticable {
  /// Create a [ThemeData] that's used to configure a [Theme].
  ///
  /// The [colorScheme] and [textTheme] are used by the Material components to
  /// compute default values for visual properties. The API documentation for
  /// each component widget explains exactly how the defaults are computed.
  ///
  /// When providing a [ColorScheme], apps can either provide one directly
  /// with the [colorScheme] parameter, or have one generated for them by
  /// using the [colorSchemeSeed] and [brightness] parameters. A generated
  /// color scheme will be based on the tones of [colorSchemeSeed] and all of
  /// its contrasting color will meet accessibility guidelines for readability.
  /// (See [ColorScheme.fromSeed] for more details.)
  ///
  /// If the app wants to customize a generated color scheme, it can use
  /// [ColorScheme.fromSeed] directly and then [ColorScheme.copyWith] on the
  /// result to override any colors that need to be replaced. The result of
  /// this can be used as the [colorScheme] directly.
  ///
  /// For historical reasons, instead of using a [colorSchemeSeed] or
  /// [colorScheme], you can provide either a [primaryColor] or [primarySwatch]
  /// to construct the [colorScheme], but the results will not be as complete
  /// as when using generation from a seed color.
  ///
  /// If [colorSchemeSeed] is non-null then [colorScheme], [primaryColor] and
  /// [primarySwatch] must all be null.
  ///
  /// The [textTheme] [TextStyle] colors are black if the color scheme's
  /// brightness is [Brightness.light], and white for [Brightness.dark].
  ///
  /// To override the appearance of specific components, provide
  /// a component theme parameter like [sliderTheme], [toggleButtonsTheme],
  /// or [bottomNavigationBarTheme].
  ///
  /// See also:
  ///
  ///  * [ThemeData.from], which creates a ThemeData from a [ColorScheme].
  ///  * [ThemeData.light], which creates the default light theme.
  ///  * [ThemeData.dark], which creates the default dark theme.
  ///  * [ColorScheme.fromSeed], which is used to create a [ColorScheme] from a seed color.
  factory ThemeData({
    // For the sanity of the reader, make sure these properties are in the same
    // order in every place that they are separated by section comments (e.g.
    // GENERAL CONFIGURATION). Each section except for deprecations should be
    // alphabetical by symbol name.

    // GENERAL CONFIGURATION
    Iterable<Adaptation<Object>>? adaptations,
    bool? applyElevationOverlayColor,
    NoDefaultCupertinoThemeData? cupertinoOverrideTheme,
    Iterable<ThemeExtension<dynamic>>? extensions,
    InputDecorationTheme? inputDecorationTheme,
    MaterialTapTargetSize? materialTapTargetSize,
    PageTransitionsTheme? pageTransitionsTheme,
    TargetPlatform? platform,
    ScrollbarThemeData? scrollbarTheme,
    InteractiveInkFeatureFactory? splashFactory,
    bool? useMaterial3,
    VisualDensity? visualDensity,
    // COLOR
    ColorScheme? colorScheme,
    Brightness? brightness,
    Color? colorSchemeSeed,
    // [colorScheme] is the preferred way to configure colors. The [Color] properties
    // listed below (as well as primarySwatch) will gradually be phased out, see
    // https://github.com/flutter/flutter/issues/91772.
    Color? canvasColor,
    Color? cardColor,
    Color? disabledColor,
    Color? dividerColor,
    Color? focusColor,
    Color? highlightColor,
    Color? hintColor,
    Color? hoverColor,
    Color? indicatorColor,
    Color? primaryColor,
    Color? primaryColorDark,
    Color? primaryColorLight,
    MaterialColor? primarySwatch,
    Color? scaffoldBackgroundColor,
    Color? secondaryHeaderColor,
    Color? shadowColor,
    Color? splashColor,
    Color? unselectedWidgetColor,
    // TYPOGRAPHY & ICONOGRAPHY
    String? fontFamily,
    List<String>? fontFamilyFallback,
    String? package,
    IconThemeData? iconTheme,
    IconThemeData? primaryIconTheme,
    TextTheme? primaryTextTheme,
    TextTheme? textTheme,
    Typography? typography,
    // COMPONENT THEMES
    ActionIconThemeData? actionIconTheme,
    AppBarTheme? appBarTheme,
    BadgeThemeData? badgeTheme,
    MaterialBannerThemeData? bannerTheme,
    BottomAppBarTheme? bottomAppBarTheme,
    BottomNavigationBarThemeData? bottomNavigationBarTheme,
    BottomSheetThemeData? bottomSheetTheme,
    ButtonThemeData? buttonTheme,
    // TODO(QuncCccccc): Change the parameter type to CardThemeData
    Object? cardTheme,
    CheckboxThemeData? checkboxTheme,
    ChipThemeData? chipTheme,
    DataTableThemeData? dataTableTheme,
    DatePickerThemeData? datePickerTheme,
    // TODO(QuncCccccc): Change the parameter type to DialogThemeData
    Object? dialogTheme,
    DividerThemeData? dividerTheme,
    DrawerThemeData? drawerTheme,
    DropdownMenuThemeData? dropdownMenuTheme,
    ElevatedButtonThemeData? elevatedButtonTheme,
    ExpansionTileThemeData? expansionTileTheme,
    FilledButtonThemeData? filledButtonTheme,
    FloatingActionButtonThemeData? floatingActionButtonTheme,
    IconButtonThemeData? iconButtonTheme,
    ListTileThemeData? listTileTheme,
    MenuBarThemeData? menuBarTheme,
    MenuButtonThemeData? menuButtonTheme,
    MenuThemeData? menuTheme,
    NavigationBarThemeData? navigationBarTheme,
    NavigationDrawerThemeData? navigationDrawerTheme,
    NavigationRailThemeData? navigationRailTheme,
    OutlinedButtonThemeData? outlinedButtonTheme,
    PopupMenuThemeData? popupMenuTheme,
    ProgressIndicatorThemeData? progressIndicatorTheme,
    RadioThemeData? radioTheme,
    SearchBarThemeData? searchBarTheme,
    SearchViewThemeData? searchViewTheme,
    SegmentedButtonThemeData? segmentedButtonTheme,
    SliderThemeData? sliderTheme,
    SnackBarThemeData? snackBarTheme,
    SwitchThemeData? switchTheme,
    // TODO(QuncCccccc): Change the parameter type to TabBarThemeData
    Object? tabBarTheme,
    TextButtonThemeData? textButtonTheme,
    TextSelectionThemeData? textSelectionTheme,
    TimePickerThemeData? timePickerTheme,
    ToggleButtonsThemeData? toggleButtonsTheme,
    TooltipThemeData? tooltipTheme,
    // DEPRECATED (newest deprecations at the bottom)
    @Deprecated(
      'Use OverflowBar instead. '
      'This feature was deprecated after v3.21.0-10.0.pre.',
    )
    ButtonBarThemeData? buttonBarTheme,
    @Deprecated(
      'Use DialogThemeData.backgroundColor instead. '
      'This feature was deprecated after v3.27.0-0.1.pre.',
    )
    Color? dialogBackgroundColor,
  }) {
    // GENERAL CONFIGURATION
    cupertinoOverrideTheme = cupertinoOverrideTheme?.noDefault();
    extensions ??= <ThemeExtension<dynamic>>[];
    adaptations ??= <Adaptation<Object>>[];
    inputDecorationTheme ??= const InputDecorationTheme();
    platform ??= defaultTargetPlatform;
    switch (platform) {
      case TargetPlatform.android:
      case TargetPlatform.fuchsia:
      case TargetPlatform.iOS:
        materialTapTargetSize ??= MaterialTapTargetSize.padded;
      case TargetPlatform.linux:
      case TargetPlatform.macOS:
      case TargetPlatform.windows:
        materialTapTargetSize ??= MaterialTapTargetSize.shrinkWrap;
    }
    pageTransitionsTheme ??= const PageTransitionsTheme();
    scrollbarTheme ??= const ScrollbarThemeData();
    visualDensity ??= VisualDensity.defaultDensityForPlatform(platform);
    useMaterial3 ??= true;
    final bool useInkSparkle = platform == TargetPlatform.android && !kIsWeb;
    splashFactory ??=
        useMaterial3
            ? useInkSparkle
                ? InkSparkle.splashFactory
                : InkRipple.splashFactory
            : InkSplash.splashFactory;

    // COLOR
    assert(
      colorScheme?.brightness == null ||
          brightness == null ||
          colorScheme!.brightness == brightness,
      'ThemeData.brightness does not match ColorScheme.brightness. '
      'Either override ColorScheme.brightness or ThemeData.brightness to '
      'match the other.',
    );
    assert(colorSchemeSeed == null || colorScheme == null);
    assert(colorSchemeSeed == null || primarySwatch == null);
    assert(colorSchemeSeed == null || primaryColor == null);
    final Brightness effectiveBrightness =
        brightness ?? colorScheme?.brightness ?? Brightness.light;
    final bool isDark = effectiveBrightness == Brightness.dark;
    if (colorSchemeSeed != null || useMaterial3) {
      if (colorSchemeSeed != null) {
        colorScheme = ColorScheme.fromSeed(
          seedColor: colorSchemeSeed,
          brightness: effectiveBrightness,
        );
      }
      colorScheme ??= isDark ? _colorSchemeDarkM3 : _colorSchemeLightM3;

      // For surfaces that use primary color in light themes and surface color in dark
      final Color primarySurfaceColor = isDark ? colorScheme.surface : colorScheme.primary;
      final Color onPrimarySurfaceColor = isDark ? colorScheme.onSurface : colorScheme.onPrimary;

      // Default some of the color settings to values from the color scheme
      primaryColor ??= primarySurfaceColor;
      canvasColor ??= colorScheme.surface;
      scaffoldBackgroundColor ??= colorScheme.surface;
      cardColor ??= colorScheme.surface;
      dividerColor ??= colorScheme.outline;
      dialogBackgroundColor ??= colorScheme.surface;
      indicatorColor ??= onPrimarySurfaceColor;
      applyElevationOverlayColor ??= brightness == Brightness.dark;
    }
    applyElevationOverlayColor ??= false;
    primarySwatch ??= Colors.blue;
    primaryColor ??= isDark ? Colors.grey[900]! : primarySwatch;
    final Brightness estimatedPrimaryColorBrightness = estimateBrightnessForColor(primaryColor);
    primaryColorLight ??= isDark ? Colors.grey[500]! : primarySwatch[100]!;
    primaryColorDark ??= isDark ? Colors.black : primarySwatch[700]!;
    final bool primaryIsDark = estimatedPrimaryColorBrightness == Brightness.dark;
    focusColor ??= isDark ? Colors.white.withOpacity(0.12) : Colors.black.withOpacity(0.12);
    hoverColor ??= isDark ? Colors.white.withOpacity(0.04) : Colors.black.withOpacity(0.04);
    shadowColor ??= Colors.black;
    canvasColor ??= isDark ? Colors.grey[850]! : Colors.grey[50]!;
    scaffoldBackgroundColor ??= canvasColor;
    cardColor ??= isDark ? Colors.grey[800]! : Colors.white;
    dividerColor ??= isDark ? const Color(0x1FFFFFFF) : const Color(0x1F000000);
    // Create a ColorScheme that is backwards compatible as possible
    // with the existing default ThemeData color values.
    colorScheme ??= ColorScheme.fromSwatch(
      primarySwatch: primarySwatch,
      accentColor: isDark ? Colors.tealAccent[200]! : primarySwatch[500]!,
      cardColor: cardColor,
      backgroundColor: isDark ? Colors.grey[700]! : primarySwatch[200]!,
      errorColor: Colors.red[700],
      brightness: effectiveBrightness,
    );
    unselectedWidgetColor ??= isDark ? Colors.white70 : Colors.black54;
    // Spec doesn't specify a dark theme secondaryHeaderColor, this is a guess.
    secondaryHeaderColor ??= isDark ? Colors.grey[700]! : primarySwatch[50]!;
    indicatorColor ??= colorScheme.secondary == primaryColor ? Colors.white : colorScheme.secondary;
    hintColor ??= isDark ? Colors.white60 : Colors.black.withOpacity(0.6);
    // The default [buttonTheme] is here because it doesn't use the defaults for
    // [disabledColor], [highlightColor], and [splashColor].
    buttonTheme ??= ButtonThemeData(
      colorScheme: colorScheme,
      buttonColor: isDark ? primarySwatch[600]! : Colors.grey[300]!,
      disabledColor: disabledColor,
      focusColor: focusColor,
      hoverColor: hoverColor,
      highlightColor: highlightColor,
      splashColor: splashColor,
      materialTapTargetSize: materialTapTargetSize,
    );
    disabledColor ??= isDark ? Colors.white38 : Colors.black38;
    highlightColor ??= isDark ? const Color(0x40CCCCCC) : const Color(0x66BCBCBC);
    splashColor ??= isDark ? const Color(0x40CCCCCC) : const Color(0x66C8C8C8);

    // TYPOGRAPHY & ICONOGRAPHY
    typography ??=
        useMaterial3
            ? Typography.material2021(platform: platform, colorScheme: colorScheme)
            : Typography.material2014(platform: platform);
    TextTheme defaultTextTheme = isDark ? typography.white : typography.black;
    TextTheme defaultPrimaryTextTheme = primaryIsDark ? typography.white : typography.black;
    if (fontFamily != null) {
      defaultTextTheme = defaultTextTheme.apply(fontFamily: fontFamily);
      defaultPrimaryTextTheme = defaultPrimaryTextTheme.apply(fontFamily: fontFamily);
    }
    if (fontFamilyFallback != null) {
      defaultTextTheme = defaultTextTheme.apply(fontFamilyFallback: fontFamilyFallback);
      defaultPrimaryTextTheme = defaultPrimaryTextTheme.apply(
        fontFamilyFallback: fontFamilyFallback,
      );
    }
    if (package != null) {
      defaultTextTheme = defaultTextTheme.apply(package: package);
      defaultPrimaryTextTheme = defaultPrimaryTextTheme.apply(package: package);
    }
    textTheme = defaultTextTheme.merge(textTheme);
    primaryTextTheme = defaultPrimaryTextTheme.merge(primaryTextTheme);
    iconTheme ??=
        isDark
            ? IconThemeData(color: kDefaultIconLightColor)
            : IconThemeData(color: kDefaultIconDarkColor);
    primaryIconTheme ??=
        primaryIsDark
            ? const IconThemeData(color: Colors.white)
            : const IconThemeData(color: Colors.black);

    // COMPONENT THEMES
    appBarTheme ??= const AppBarTheme();
    badgeTheme ??= const BadgeThemeData();
    bannerTheme ??= const MaterialBannerThemeData();
    bottomAppBarTheme ??= const BottomAppBarTheme();
    bottomNavigationBarTheme ??= const BottomNavigationBarThemeData();
    bottomSheetTheme ??= const BottomSheetThemeData();
    // TODO(QuncCccccc): Clean it up once the type of `cardTheme` is changed to `CardThemeData`
    if (cardTheme != null) {
      if (cardTheme is CardTheme) {
        cardTheme = cardTheme.data;
      } else if (cardTheme is! CardThemeData) {
        throw ArgumentError('cardTheme must be either a CardThemeData or a CardTheme');
      }
    }
    cardTheme ??= const CardThemeData();
    checkboxTheme ??= const CheckboxThemeData();
    chipTheme ??= const ChipThemeData();
    dataTableTheme ??= const DataTableThemeData();
    datePickerTheme ??= const DatePickerThemeData();
    // TODO(QuncCccccc): Clean this up once the type of `dialogTheme` is changed to `DialogThemeData`
    if (dialogTheme != null) {
      if (dialogTheme is DialogTheme) {
        dialogTheme = dialogTheme.data;
      } else if (dialogTheme is! DialogThemeData) {
        throw ArgumentError('dialogTheme must be either a DialogThemeData or a DialogTheme');
      }
    }
    dialogTheme ??= const DialogThemeData();
    dividerTheme ??= const DividerThemeData();
    drawerTheme ??= const DrawerThemeData();
    dropdownMenuTheme ??= const DropdownMenuThemeData();
    elevatedButtonTheme ??= const ElevatedButtonThemeData();
    expansionTileTheme ??= const ExpansionTileThemeData();
    filledButtonTheme ??= const FilledButtonThemeData();
    floatingActionButtonTheme ??= const FloatingActionButtonThemeData();
    iconButtonTheme ??= const IconButtonThemeData();
    listTileTheme ??= const ListTileThemeData();
    menuBarTheme ??= const MenuBarThemeData();
    menuButtonTheme ??= const MenuButtonThemeData();
    menuTheme ??= const MenuThemeData();
    navigationBarTheme ??= const NavigationBarThemeData();
    navigationDrawerTheme ??= const NavigationDrawerThemeData();
    navigationRailTheme ??= const NavigationRailThemeData();
    outlinedButtonTheme ??= const OutlinedButtonThemeData();
    popupMenuTheme ??= const PopupMenuThemeData();
    progressIndicatorTheme ??= const ProgressIndicatorThemeData();
    radioTheme ??= const RadioThemeData();
    searchBarTheme ??= const SearchBarThemeData();
    searchViewTheme ??= const SearchViewThemeData();
    segmentedButtonTheme ??= const SegmentedButtonThemeData();
    sliderTheme ??= const SliderThemeData();
    snackBarTheme ??= const SnackBarThemeData();
    switchTheme ??= const SwitchThemeData();
    // TODO(QuncCccccc): Clean this up once the type of `tabBarTheme` is changed to `TabBarThemeData`
    if (tabBarTheme != null) {
      if (tabBarTheme is TabBarTheme) {
        tabBarTheme = tabBarTheme.data;
      } else if (tabBarTheme is! TabBarThemeData) {
        throw ArgumentError('tabBarTheme must be either a TabBarThemeData or a TabBarTheme');
      }
    }
    tabBarTheme ??= const TabBarThemeData();
    textButtonTheme ??= const TextButtonThemeData();
    textSelectionTheme ??= const TextSelectionThemeData();
    timePickerTheme ??= const TimePickerThemeData();
    toggleButtonsTheme ??= const ToggleButtonsThemeData();
    tooltipTheme ??= const TooltipThemeData();
    // DEPRECATED (newest deprecations at the bottom)
    buttonBarTheme ??= const ButtonBarThemeData();
    dialogBackgroundColor ??= isDark ? Colors.grey[800]! : Colors.white;
    return ThemeData.raw(
      // For the sanity of the reader, make sure these properties are in the same
      // order in every place that they are separated by section comments (e.g.
      // GENERAL CONFIGURATION). Each section except for deprecations should be
      // alphabetical by symbol name.

      // GENERAL CONFIGURATION
      adaptationMap: _createAdaptationMap(adaptations),
      applyElevationOverlayColor: applyElevationOverlayColor,
      cupertinoOverrideTheme: cupertinoOverrideTheme,
      extensions: _themeExtensionIterableToMap(extensions),
      inputDecorationTheme: inputDecorationTheme,
      materialTapTargetSize: materialTapTargetSize,
      pageTransitionsTheme: pageTransitionsTheme,
      platform: platform,
      scrollbarTheme: scrollbarTheme,
      splashFactory: splashFactory,
      useMaterial3: useMaterial3,
      visualDensity: visualDensity,
      // COLOR
      canvasColor: canvasColor,
      cardColor: cardColor,
      colorScheme: colorScheme,
      disabledColor: disabledColor,
      dividerColor: dividerColor,
      focusColor: focusColor,
      highlightColor: highlightColor,
      hintColor: hintColor,
      hoverColor: hoverColor,
      indicatorColor: indicatorColor,
      primaryColor: primaryColor,
      primaryColorDark: primaryColorDark,
      primaryColorLight: primaryColorLight,
      scaffoldBackgroundColor: scaffoldBackgroundColor,
      secondaryHeaderColor: secondaryHeaderColor,
      shadowColor: shadowColor,
      splashColor: splashColor,
      unselectedWidgetColor: unselectedWidgetColor,
      // TYPOGRAPHY & ICONOGRAPHY
      iconTheme: iconTheme,
      primaryTextTheme: primaryTextTheme,
      textTheme: textTheme,
      typography: typography,
      primaryIconTheme: primaryIconTheme,
      // COMPONENT THEMES
      actionIconTheme: actionIconTheme,
      appBarTheme: appBarTheme,
      badgeTheme: badgeTheme,
      bannerTheme: bannerTheme,
      bottomAppBarTheme: bottomAppBarTheme,
      bottomNavigationBarTheme: bottomNavigationBarTheme,
      bottomSheetTheme: bottomSheetTheme,
      buttonTheme: buttonTheme,
      cardTheme: cardTheme as CardThemeData,
      checkboxTheme: checkboxTheme,
      chipTheme: chipTheme,
      dataTableTheme: dataTableTheme,
      datePickerTheme: datePickerTheme,
      dialogTheme: dialogTheme as DialogThemeData,
      dividerTheme: dividerTheme,
      drawerTheme: drawerTheme,
      dropdownMenuTheme: dropdownMenuTheme,
      elevatedButtonTheme: elevatedButtonTheme,
      expansionTileTheme: expansionTileTheme,
      filledButtonTheme: filledButtonTheme,
      floatingActionButtonTheme: floatingActionButtonTheme,
      iconButtonTheme: iconButtonTheme,
      listTileTheme: listTileTheme,
      menuBarTheme: menuBarTheme,
      menuButtonTheme: menuButtonTheme,
      menuTheme: menuTheme,
      navigationBarTheme: navigationBarTheme,
      navigationDrawerTheme: navigationDrawerTheme,
      navigationRailTheme: navigationRailTheme,
      outlinedButtonTheme: outlinedButtonTheme,
      popupMenuTheme: popupMenuTheme,
      progressIndicatorTheme: progressIndicatorTheme,
      radioTheme: radioTheme,
      searchBarTheme: searchBarTheme,
      searchViewTheme: searchViewTheme,
      segmentedButtonTheme: segmentedButtonTheme,
      sliderTheme: sliderTheme,
      snackBarTheme: snackBarTheme,
      switchTheme: switchTheme,
      tabBarTheme: tabBarTheme as TabBarThemeData,
      textButtonTheme: textButtonTheme,
      textSelectionTheme: textSelectionTheme,
      timePickerTheme: timePickerTheme,
      toggleButtonsTheme: toggleButtonsTheme,
      tooltipTheme: tooltipTheme,
      // DEPRECATED (newest deprecations at the bottom)
      buttonBarTheme: buttonBarTheme,
      dialogBackgroundColor: dialogBackgroundColor,
    );
  }

  /// Create a [ThemeData] given a set of exact values. Most values must be
  /// specified. They all must also be non-null except for
  /// [cupertinoOverrideTheme], and deprecated members.
  ///
  /// This will rarely be used directly. It is used by [lerp] to
  /// create intermediate themes based on two themes created with the
  /// [ThemeData] constructor.
  const ThemeData.raw({
    // For the sanity of the reader, make sure these properties are in the same
    // order in every place that they are separated by section comments (e.g.
    // GENERAL CONFIGURATION). Each section except for deprecations should be
    // alphabetical by symbol name.

    // GENERAL CONFIGURATION
    required this.adaptationMap,
    required this.applyElevationOverlayColor,
    required this.cupertinoOverrideTheme,
    required this.extensions,
    required this.inputDecorationTheme,
    required this.materialTapTargetSize,
    required this.pageTransitionsTheme,
    required this.platform,
    required this.scrollbarTheme,
    required this.splashFactory,
    required this.useMaterial3,
    required this.visualDensity,
    // COLOR
    required this.colorScheme,
    // [colorScheme] is the preferred way to configure colors. The [Color] properties
    // listed below (as well as primarySwatch) will gradually be phased out, see
    // https://github.com/flutter/flutter/issues/91772.
    required this.canvasColor,
    required this.cardColor,
    required this.disabledColor,
    required this.dividerColor,
    required this.focusColor,
    required this.highlightColor,
    required this.hintColor,
    required this.hoverColor,
    required this.indicatorColor,
    required this.primaryColor,
    required this.primaryColorDark,
    required this.primaryColorLight,
    required this.scaffoldBackgroundColor,
    required this.secondaryHeaderColor,
    required this.shadowColor,
    required this.splashColor,
    required this.unselectedWidgetColor,
    // TYPOGRAPHY & ICONOGRAPHY
    required this.iconTheme,
    required this.primaryIconTheme,
    required this.primaryTextTheme,
    required this.textTheme,
    required this.typography,
    // COMPONENT THEMES
    required this.actionIconTheme,
    required this.appBarTheme,
    required this.badgeTheme,
    required this.bannerTheme,
    required this.bottomAppBarTheme,
    required this.bottomNavigationBarTheme,
    required this.bottomSheetTheme,
    required this.buttonTheme,
    required this.cardTheme,
    required this.checkboxTheme,
    required this.chipTheme,
    required this.dataTableTheme,
    required this.datePickerTheme,
    required this.dialogTheme,
    required this.dividerTheme,
    required this.drawerTheme,
    required this.dropdownMenuTheme,
    required this.elevatedButtonTheme,
    required this.expansionTileTheme,
    required this.filledButtonTheme,
    required this.floatingActionButtonTheme,
    required this.iconButtonTheme,
    required this.listTileTheme,
    required this.menuBarTheme,
    required this.menuButtonTheme,
    required this.menuTheme,
    required this.navigationBarTheme,
    required this.navigationDrawerTheme,
    required this.navigationRailTheme,
    required this.outlinedButtonTheme,
    required this.popupMenuTheme,
    required this.progressIndicatorTheme,
    required this.radioTheme,
    required this.searchBarTheme,
    required this.searchViewTheme,
    required this.segmentedButtonTheme,
    required this.sliderTheme,
    required this.snackBarTheme,
    required this.switchTheme,
    required this.tabBarTheme,
    required this.textButtonTheme,
    required this.textSelectionTheme,
    required this.timePickerTheme,
    required this.toggleButtonsTheme,
    required this.tooltipTheme,
    // DEPRECATED (newest deprecations at the bottom)
    @Deprecated(
      'Use OverflowBar instead. '
      'This feature was deprecated after v3.21.0-10.0.pre.',
    )
    ButtonBarThemeData? buttonBarTheme,
    @Deprecated(
      'Use DialogThemeData.backgroundColor instead. '
      'This feature was deprecated after v3.27.0-0.1.pre.',
    )
    required this.dialogBackgroundColor,
  }) : // DEPRECATED (newest deprecations at the bottom)
       // should not be `required`, use getter pattern to avoid breakages.
       _buttonBarTheme = buttonBarTheme,
       assert(buttonBarTheme != null);

  /// Create a [ThemeData] based on the colors in the given [colorScheme] and
  /// text styles of the optional [textTheme].
  ///
  /// If [colorScheme].brightness is [Brightness.dark] then
  /// [ThemeData.applyElevationOverlayColor] will be set to true to support
  /// the Material dark theme method for indicating elevation by applying
  /// a semi-transparent onSurface color on top of the surface color.
  ///
  /// This is the recommended method to theme your application. As we move
  /// forward we will be converting all the widget implementations to only use
  /// colors or colors derived from those in [ColorScheme].
  ///
  /// {@tool snippet}
  /// This example will set up an application to use the baseline Material
  /// Design light and dark themes.
  ///
  /// ```dart
  /// MaterialApp(
  ///   theme: ThemeData.from(colorScheme: const ColorScheme.light()),
  ///   darkTheme: ThemeData.from(colorScheme: const ColorScheme.dark()),
  /// )
  /// ```
  /// {@end-tool}
  ///
  /// See <https://material.io/design/color/> for
  /// more discussion on how to pick the right colors.
  factory ThemeData.from({
    required ColorScheme colorScheme,
    TextTheme? textTheme,
    bool? useMaterial3,
  }) {
    final bool isDark = colorScheme.brightness == Brightness.dark;

    // For surfaces that use primary color in light themes and surface color in dark
    final Color primarySurfaceColor = isDark ? colorScheme.surface : colorScheme.primary;
    final Color onPrimarySurfaceColor = isDark ? colorScheme.onSurface : colorScheme.onPrimary;

    return ThemeData(
      colorScheme: colorScheme,
      brightness: colorScheme.brightness,
      primaryColor: primarySurfaceColor,
      canvasColor: colorScheme.surface,
      scaffoldBackgroundColor: colorScheme.surface,
      cardColor: colorScheme.surface,
      dividerColor: colorScheme.onSurface.withOpacity(0.12),
      dialogBackgroundColor: colorScheme.surface,
      indicatorColor: onPrimarySurfaceColor,
      textTheme: textTheme,
      applyElevationOverlayColor: isDark,
      useMaterial3: useMaterial3,
    );
  }

  /// A default light theme.
  ///
  /// This theme does not contain text geometry. Instead, it is expected that
  /// this theme is localized using text geometry using [ThemeData.localize].
  factory ThemeData.light({bool? useMaterial3}) =>
      ThemeData(brightness: Brightness.light, useMaterial3: useMaterial3);

  /// A default dark theme.
  ///
  /// This theme does not contain text geometry. Instead, it is expected that
  /// this theme is localized using text geometry using [ThemeData.localize].
  factory ThemeData.dark({bool? useMaterial3}) =>
      ThemeData(brightness: Brightness.dark, useMaterial3: useMaterial3);

  /// The default color theme. Same as [ThemeData.light].
  ///
  /// This is used by [Theme.of] when no theme has been specified.
  ///
  /// This theme does not contain text geometry. Instead, it is expected that
  /// this theme is localized using text geometry using [ThemeData.localize].
  ///
  /// Most applications would use [Theme.of], which provides correct localized
  /// text geometry.
  factory ThemeData.fallback({bool? useMaterial3}) => ThemeData.light(useMaterial3: useMaterial3);

  /// Used to obtain a particular [Adaptation] from [adaptationMap].
  ///
  /// To get an adaptation, use `Theme.of(context).getAdaptation<MyAdaptation>()`.
  Adaptation<T>? getAdaptation<T>() => adaptationMap[T] as Adaptation<T>?;

  static Map<Type, Adaptation<Object>> _createAdaptationMap(
    Iterable<Adaptation<Object>> adaptations,
  ) {
    final Map<Type, Adaptation<Object>> adaptationMap = <Type, Adaptation<Object>>{
      for (final Adaptation<Object> adaptation in adaptations) adaptation.type: adaptation,
    };
    return adaptationMap;
  }

  /// The overall theme brightness.
  ///
  /// The default [TextStyle] color for the [textTheme] is black if the
  /// theme is constructed with [Brightness.light] and white if the
  /// theme is constructed with [Brightness.dark].
  Brightness get brightness => colorScheme.brightness;

  // For the sanity of the reader, make sure these properties are in the same
  // order in every place that they are separated by section comments (e.g.
  // GENERAL CONFIGURATION). Each section except for deprecations should be
  // alphabetical by symbol name.

  // GENERAL CONFIGURATION

  /// Apply a semi-transparent overlay color on Material surfaces to indicate
  /// elevation for dark themes.
  ///
  /// If [useMaterial3] is true, then this flag is ignored as there is a new
  /// [Material.surfaceTintColor] used to create an overlay for Material 3.
  /// This flag is meant only for the Material 2 elevation overlay for dark
  /// themes.
  ///
  /// Material drop shadows can be difficult to see in a dark theme, so the
  /// elevation of a surface should be portrayed with an "overlay" in addition
  /// to the shadow. As the elevation of the component increases, the
  /// overlay increases in opacity. [applyElevationOverlayColor] turns the
  /// application of this overlay on or off for dark themes.
  ///
  /// If true and [brightness] is [Brightness.dark], a
  /// semi-transparent version of [ColorScheme.onSurface] will be
  /// applied on top of [Material] widgets that have a [ColorScheme.surface]
  /// color. The level of transparency is based on [Material.elevation] as
  /// per the Material Dark theme specification.
  ///
  /// If false the surface color will be used unmodified.
  ///
  /// Defaults to false in order to maintain backwards compatibility with
  /// apps that were built before the Material Dark theme specification
  /// was published. New apps should set this to true for any themes
  /// where [brightness] is [Brightness.dark].
  ///
  /// See also:
  ///
  ///  * [Material.elevation], which effects the level of transparency of the
  ///    overlay color.
  ///  * [ElevationOverlay.applyOverlay], which is used by [Material] to apply
  ///    the overlay color to its surface color.
  ///  * <https://material.io/design/color/dark-theme.html>, which specifies how
  ///    the overlay should be applied.
  final bool applyElevationOverlayColor;

  /// Components of the [CupertinoThemeData] to override from the Material
  /// [ThemeData] adaptation.
  ///
  /// By default, [cupertinoOverrideTheme] is null and Cupertino widgets
  /// descendant to the Material [Theme] will adhere to a [CupertinoTheme]
  /// derived from the Material [ThemeData]. e.g. [ThemeData]'s [ColorScheme]
  /// will also inform the [CupertinoThemeData]'s `primaryColor` etc.
  ///
  /// This cascading effect for individual attributes of the [CupertinoThemeData]
  /// can be overridden using attributes of this [cupertinoOverrideTheme].
  final NoDefaultCupertinoThemeData? cupertinoOverrideTheme;

  /// Arbitrary additions to this theme.
  ///
  /// To define extensions, pass an [Iterable] containing one or more [ThemeExtension]
  /// subclasses to [ThemeData.new] or [copyWith].
  ///
  /// To obtain an extension, use [extension].
  ///
  /// {@tool dartpad}
  /// This sample shows how to create and use a subclass of [ThemeExtension] that
  /// defines two colors.
  ///
  /// ** See code in examples/api/lib/material/theme/theme_extension.1.dart **
  /// {@end-tool}
  ///
  /// See also:
  ///
  /// * [extension], a convenience function for obtaining a specific extension.
  final Map<Object, ThemeExtension<dynamic>> extensions;

  /// Used to obtain a particular [ThemeExtension] from [extensions].
  ///
  /// Obtain with `Theme.of(context).extension<MyThemeExtension>()`.
  ///
  /// See [extensions] for an interactive example.
  T? extension<T>() => extensions[T] as T?;

  /// A map which contains the adaptations for the theme. The entry's key is the
  /// type of the adaptation; the value is the adaptation itself.
  ///
  /// To obtain an adaptation, use [getAdaptation].
  final Map<Type, Adaptation<Object>> adaptationMap;

  /// The default [InputDecoration] values for [InputDecorator], [TextField],
  /// and [TextFormField] are based on this theme.
  ///
  /// See [InputDecoration.applyDefaults].
  final InputDecorationTheme inputDecorationTheme;

  /// Configures the hit test size of certain Material widgets.
  ///
  /// Defaults to a [platform]-appropriate size: [MaterialTapTargetSize.padded]
  /// on mobile platforms, [MaterialTapTargetSize.shrinkWrap] on desktop
  /// platforms.
  final MaterialTapTargetSize materialTapTargetSize;

  /// Default [MaterialPageRoute] transitions per [TargetPlatform].
  ///
  /// [MaterialPageRoute.buildTransitions] delegates to a [platform] specific
  /// [PageTransitionsBuilder]. If a matching builder is not found, a builder
  /// whose platform is null is used.
  final PageTransitionsTheme pageTransitionsTheme;

  /// The platform the material widgets should adapt to target.
  ///
  /// Defaults to the current platform, as exposed by [defaultTargetPlatform].
  /// This should be used in order to style UI elements according to platform
  /// conventions.
  ///
  /// Widgets from the material library should use this getter (via [Theme.of])
  /// to determine the current platform for the purpose of emulating the
  /// platform behavior (e.g. scrolling or haptic effects). Widgets and render
  /// objects at lower layers that try to emulate the underlying platform
  /// can depend on [defaultTargetPlatform] directly, or may require
  /// that the target platform be provided as an argument. The
  /// [dart:io.Platform] object should only be used directly when it's critical
  /// to actually know the current platform, without any overrides possible (for
  /// example, when a system API is about to be called).
  ///
  /// In a test environment, the platform returned is [TargetPlatform.android]
  /// regardless of the host platform. (Android was chosen because the tests
  /// were originally written assuming Android-like behavior, and we added
  /// platform adaptations for other platforms later). Tests can check behavior
  /// for other platforms by setting the [platform] of the [Theme] explicitly to
  /// another [TargetPlatform] value, or by setting
  /// [debugDefaultTargetPlatformOverride].
  ///
  /// Determines the defaults for [typography] and [materialTapTargetSize].
  final TargetPlatform platform;

  /// A theme for customizing the colors, thickness, and shape of [Scrollbar]s.
  final ScrollbarThemeData scrollbarTheme;

  /// Defines the appearance of ink splashes produces by [InkWell]
  /// and [InkResponse].
  ///
  /// See also:
  ///
  ///  * [InkSplash.splashFactory], which defines the default splash.
  ///  * [InkRipple.splashFactory], which defines a splash that spreads out
  ///    more aggressively than the default.
  ///  * [InkSparkle.splashFactory], which defines a more aggressive and organic
  ///    splash with sparkle effects.
  final InteractiveInkFeatureFactory splashFactory;

  /// A temporary flag that can be used to opt-out of Material 3 features.
  ///
  /// This flag is _true_ by default. If false, then components will
  /// continue to use the colors, typography and other features of
  /// Material 2.
  ///
  /// In the long run this flag will be deprecated and eventually
  /// only Material 3 will be supported. We recommend that applications
  /// migrate to Material 3 as soon as that's practical. Until that migration
  /// is complete, this flag can be set to false.
  ///
  /// ## Defaults
  ///
  /// If a [ThemeData] is _constructed_ with [useMaterial3] set to true, then
  /// some properties will get updated defaults. However, the
  /// [ThemeData.copyWith] method with [useMaterial3] set to true will _not_
  /// change any of these properties in the resulting [ThemeData].
  ///
  /// <style>table,td,th { border-collapse: collapse; padding: 0.45em; } td { border: 1px solid }</style>
  ///
  /// | Property        | Material 3 default             | Material 2 default             |
  /// | :-------------- | :----------------------------- | :----------------------------- |
  /// | [colorScheme]   | M3 baseline light color scheme | M2 baseline light color scheme |
  /// | [typography]    | [Typography.material2021]      | [Typography.material2014]      |
  /// | [splashFactory] | [InkSparkle]* or [InkRipple]   | [InkSplash]                    |
  ///
  /// \* if the target platform is Android and the app is not
  /// running on the web, otherwise it will fallback to [InkRipple].
  ///
  /// If [brightness] is [Brightness.dark] then the default color scheme will
  /// be either the M3 baseline dark color scheme or the M2 baseline dark color
  /// scheme depending on [useMaterial3].
  ///
  /// ## Affected widgets
  ///
  /// This flag affects styles and components.
  ///
  /// ### Styles
  ///   * Color: [ColorScheme], [Material] (see table above)
  ///   * Shape: (see components below)
  ///   * Typography: [Typography] (see table above)
  ///
  /// ### Components
  ///   * Badges: [Badge]
  ///   * Bottom app bar: [BottomAppBar]
  ///   * Bottom sheets: [BottomSheet]
  ///   * Buttons
  ///     - Common buttons: [ElevatedButton], [FilledButton], [FilledButton.tonal], [OutlinedButton], [TextButton]
  ///     - FAB: [FloatingActionButton], [FloatingActionButton.extended]
  ///     - Icon buttons: [IconButton], [IconButton.filled] (*new*), [IconButton.filledTonal], [IconButton.outlined]
  ///     - Segmented buttons: [SegmentedButton] (replacing [ToggleButtons])
  ///   * Cards: [Card]
  ///   * Checkbox: [Checkbox], [CheckboxListTile]
  ///   * Chips:
  ///     - [ActionChip] (used for Assist and Suggestion chips),
  ///     - [FilterChip], [ChoiceChip] (used for single selection filter chips),
  ///     - [InputChip]
  ///   * Date pickers: [showDatePicker], [showDateRangePicker], [DatePickerDialog], [DateRangePickerDialog], [InputDatePickerFormField]
  ///   * Dialogs: [AlertDialog], [Dialog.fullscreen]
  ///   * Divider: [Divider], [VerticalDivider]
  ///   * Lists: [ListTile]
  ///   * Menus: [MenuAnchor], [DropdownMenu], [MenuBar]
  ///   * Navigation bar: [NavigationBar] (replacing [BottomNavigationBar])
  ///   * Navigation drawer: [NavigationDrawer] (replacing [Drawer])
  ///   * Navigation rail: [NavigationRail]
  ///   * Progress indicators: [CircularProgressIndicator], [LinearProgressIndicator]
  ///   * Radio button: [Radio], [RadioListTile]
  ///   * Search: [SearchBar], [SearchAnchor],
  ///   * Snack bar: [SnackBar]
  ///   * Slider: [Slider], [RangeSlider]
  ///   * Switch: [Switch], [SwitchListTile]
  ///   * Tabs: [TabBar], [TabBar.secondary]
  ///   * TextFields: [TextField] together with its [InputDecoration]
  ///   * Time pickers: [showTimePicker], [TimePickerDialog]
  ///   * Top app bar: [AppBar], [SliverAppBar], [SliverAppBar.medium], [SliverAppBar.large]
  ///
  /// In addition, this flag enables features introduced in Android 12.
  ///   * Stretch overscroll: [MaterialScrollBehavior]
  ///   * Ripple: `splashFactory` (see table above)
  ///
  /// See also:
  ///
  ///   * [Material 3 specification](https://m3.material.io/).
  final bool useMaterial3;

  /// The density value for specifying the compactness of various UI components.
  ///
  /// {@template flutter.material.themedata.visualDensity}
  /// Density, in the context of a UI, is the vertical and horizontal
  /// "compactness" of the elements in the UI. It is unitless, since it means
  /// different things to different UI elements. For buttons, it affects the
  /// spacing around the centered label of the button. For lists, it affects the
  /// distance between baselines of entries in the list.
  ///
  /// Typically, density values are integral, but any value in range may be
  /// used. The range includes values from [VisualDensity.minimumDensity] (which
  /// is -4), to [VisualDensity.maximumDensity] (which is 4), inclusive, where
  /// negative values indicate a denser, more compact, UI, and positive values
  /// indicate a less dense, more expanded, UI. If a component doesn't support
  /// the value given, it will clamp to the nearest supported value.
  ///
  /// The default for visual densities is zero for both vertical and horizontal
  /// densities, which corresponds to the default visual density of components
  /// in the Material Design specification.
  ///
  /// As a rule of thumb, a change of 1 or -1 in density corresponds to 4
  /// logical pixels. However, this is not a strict relationship since
  /// components interpret the density values appropriately for their needs.
  ///
  /// A larger value translates to a spacing increase (less dense), and a
  /// smaller value translates to a spacing decrease (more dense).
  ///
  /// In Material Design 3, the [visualDensity] does not override the value of
  /// [IconButton.visualDensity] which defaults to [VisualDensity.standard]
  /// for all platforms. To override the default value of [IconButton.visualDensity],
  /// use [ThemeData.iconButtonTheme] instead.
  /// {@endtemplate}
  final VisualDensity visualDensity;

  // COLOR

  /// The default color of [MaterialType.canvas] [Material].
  final Color canvasColor;

  /// The color of [Material] when it is used as a [Card].
  final Color cardColor;

  /// {@macro flutter.material.color_scheme.ColorScheme}
  ///
  /// This property was added much later than the theme's set of highly specific
  /// colors, like [cardColor], [canvasColor] etc. New components can be defined
  /// exclusively in terms of [colorScheme]. Existing components will gradually
  /// migrate to it, to the extent that is possible without significant
  /// backwards compatibility breaks.
  final ColorScheme colorScheme;

  /// The color used for widgets that are inoperative, regardless of
  /// their state. For example, a disabled checkbox (which may be
  /// checked or unchecked).
  final Color disabledColor;

  /// The color of [Divider]s and [PopupMenuDivider]s, also used
  /// between [ListTile]s, between rows in [DataTable]s, and so forth.
  ///
  /// To create an appropriate [BorderSide] that uses this color, consider
  /// [Divider.createBorderSide].
  final Color dividerColor;

  /// The focus color used indicate that a component has the input focus.
  final Color focusColor;

  /// The highlight color used during ink splash animations or to
  /// indicate an item in a menu is selected.
  final Color highlightColor;

  /// The color to use for hint text or placeholder text, e.g. in
  /// [TextField] fields.
  final Color hintColor;

  /// The hover color used to indicate when a pointer is hovering over a
  /// component.
  final Color hoverColor;

  /// The color of the selected tab indicator in a tab bar.
  final Color indicatorColor;

  /// The background color for major parts of the app (toolbars, tab bars, etc)
  ///
  /// The theme's [colorScheme] property contains [ColorScheme.primary], as
  /// well as a color that contrasts well with the primary color called
  /// [ColorScheme.onPrimary]. It might be simpler to just configure an app's
  /// visuals in terms of the theme's [colorScheme].
  final Color primaryColor;

  /// A darker version of the [primaryColor].
  final Color primaryColorDark;

  /// A lighter version of the [primaryColor].
  final Color primaryColorLight;

  /// The default color of the [Material] that underlies the [Scaffold]. The
  /// background color for a typical material app or a page within the app.
  final Color scaffoldBackgroundColor;

  /// The color of the header of a [PaginatedDataTable] when there are selected rows.
  // According to the spec for data tables:
  // https://material.io/archive/guidelines/components/data-tables.html#data-tables-tables-within-cards
  // ...this should be the "50-value of secondary app color".
  final Color secondaryHeaderColor;

  /// The color that the [Material] widget uses to draw elevation shadows.
  ///
  /// Defaults to fully opaque black.
  ///
  /// Shadows can be difficult to see in a dark theme, so the elevation of a
  /// surface should be rendered with an "overlay" in addition to the shadow.
  /// As the elevation of the component increases, the overlay increases in
  /// opacity. The [applyElevationOverlayColor] property turns the elevation
  /// overlay on or off for dark themes.
  final Color shadowColor;

  /// The color of ink splashes.
  ///
  /// See also:
  ///  * [splashFactory], which defines the appearance of the splash.
  final Color splashColor;

  /// The color used for widgets in their inactive (but enabled)
  /// state. For example, an unchecked checkbox. See also [disabledColor].
  final Color unselectedWidgetColor;

  // TYPOGRAPHY & ICONOGRAPHY

  /// An icon theme that contrasts with the card and canvas colors.
  final IconThemeData iconTheme;

  /// An icon theme that contrasts with the primary color.
  final IconThemeData primaryIconTheme;

  /// A text theme that contrasts with the primary color.
  final TextTheme primaryTextTheme;

  /// Text with a color that contrasts with the card and canvas colors.
  final TextTheme textTheme;

  /// The color and geometry [TextTheme] values used to configure [textTheme].
  ///
  /// Defaults to a [platform]-appropriate typography.
  final Typography typography;

  // COMPONENT THEMES

  /// A theme for customizing icons of [BackButtonIcon], [CloseButtonIcon],
  /// [DrawerButtonIcon], or [EndDrawerButtonIcon].
  final ActionIconThemeData? actionIconTheme;

  /// A theme for customizing the color, elevation, brightness, iconTheme and
  /// textTheme of [AppBar]s.
  final AppBarTheme appBarTheme;

  /// A theme for customizing the color of [Badge]s.
  final BadgeThemeData badgeTheme;

  /// A theme for customizing the color and text style of a [MaterialBanner].
  final MaterialBannerThemeData bannerTheme;

  /// A theme for customizing the shape, elevation, and color of a [BottomAppBar].
  final BottomAppBarTheme bottomAppBarTheme;

  /// A theme for customizing the appearance and layout of [BottomNavigationBar]
  /// widgets.
  final BottomNavigationBarThemeData bottomNavigationBarTheme;

  /// A theme for customizing the color, elevation, and shape of a bottom sheet.
  final BottomSheetThemeData bottomSheetTheme;

  /// Defines the default configuration of button widgets, like [DropdownButton]
  /// and [ButtonBar].
  final ButtonThemeData buttonTheme;

  /// The colors and styles used to render [Card].
  ///
  /// This is the value returned from [CardTheme.of].
  final CardThemeData cardTheme;

  /// A theme for customizing the appearance and layout of [Checkbox] widgets.
  final CheckboxThemeData checkboxTheme;

  /// The colors and styles used to render [Chip]s.
  ///
  /// This is the value returned from [ChipTheme.of].
  final ChipThemeData chipTheme;

  /// A theme for customizing the appearance and layout of [DataTable]
  /// widgets.
  final DataTableThemeData dataTableTheme;

  /// A theme for customizing the appearance and layout of [DatePickerDialog]
  /// widgets.
  final DatePickerThemeData datePickerTheme;

  /// A theme for customizing the shape of a dialog.
  final DialogThemeData dialogTheme;

  /// A theme for customizing the color, thickness, and indents of [Divider]s,
  /// [VerticalDivider]s, etc.
  final DividerThemeData dividerTheme;

  /// A theme for customizing the appearance and layout of [Drawer] widgets.
  final DrawerThemeData drawerTheme;

  /// A theme for customizing the appearance and layout of [DropdownMenu] widgets.
  final DropdownMenuThemeData dropdownMenuTheme;

  /// A theme for customizing the appearance and internal layout of
  /// [ElevatedButton]s.
  final ElevatedButtonThemeData elevatedButtonTheme;

  /// A theme for customizing the visual properties of [ExpansionTile]s.
  final ExpansionTileThemeData expansionTileTheme;

  /// A theme for customizing the appearance and internal layout of
  /// [FilledButton]s.
  final FilledButtonThemeData filledButtonTheme;

  /// A theme for customizing the shape, elevation, and color of a
  /// [FloatingActionButton].
  final FloatingActionButtonThemeData floatingActionButtonTheme;

  /// A theme for customizing the appearance and internal layout of
  /// [IconButton]s.
  final IconButtonThemeData iconButtonTheme;

  /// A theme for customizing the appearance of [ListTile] widgets.
  final ListTileThemeData listTileTheme;

  /// A theme for customizing the color, shape, elevation, and other [MenuStyle]
  /// aspects of the menu bar created by the [MenuBar] widget.
  final MenuBarThemeData menuBarTheme;

  /// A theme for customizing the color, shape, elevation, and text style of
  /// cascading menu buttons created by [SubmenuButton] or [MenuItemButton].
  final MenuButtonThemeData menuButtonTheme;

  /// A theme for customizing the color, shape, elevation, and other [MenuStyle]
  /// attributes of menus created by the [SubmenuButton] widget.
  final MenuThemeData menuTheme;

  /// A theme for customizing the background color, text style, and icon themes
  /// of a [NavigationBar].
  final NavigationBarThemeData navigationBarTheme;

  /// A theme for customizing the background color, text style, and icon themes
  /// of a [NavigationDrawer].
  final NavigationDrawerThemeData navigationDrawerTheme;

  /// A theme for customizing the background color, elevation, text style, and
  /// icon themes of a [NavigationRail].
  final NavigationRailThemeData navigationRailTheme;

  /// A theme for customizing the appearance and internal layout of
  /// [OutlinedButton]s.
  final OutlinedButtonThemeData outlinedButtonTheme;

  /// A theme for customizing the color, shape, elevation, and text style of
  /// popup menus.
  final PopupMenuThemeData popupMenuTheme;

  /// A theme for customizing the appearance and layout of [ProgressIndicator] widgets.
  final ProgressIndicatorThemeData progressIndicatorTheme;

  /// A theme for customizing the appearance and layout of [Radio] widgets.
  final RadioThemeData radioTheme;

  /// A theme for customizing the appearance and layout of [SearchBar] widgets.
  final SearchBarThemeData searchBarTheme;

  /// A theme for customizing the appearance and layout of search views created by [SearchAnchor] widgets.
  final SearchViewThemeData searchViewTheme;

  /// A theme for customizing the appearance and layout of [SegmentedButton] widgets.
  final SegmentedButtonThemeData segmentedButtonTheme;

  /// The colors and shapes used to render [Slider].
  ///
  /// This is the value returned from [SliderTheme.of].
  final SliderThemeData sliderTheme;

  /// A theme for customizing colors, shape, elevation, and behavior of a [SnackBar].
  final SnackBarThemeData snackBarTheme;

  /// A theme for customizing the appearance and layout of [Switch] widgets.
  final SwitchThemeData switchTheme;

  /// A theme for customizing the size, shape, and color of the tab bar indicator.
  final TabBarThemeData tabBarTheme;

  /// A theme for customizing the appearance and internal layout of
  /// [TextButton]s.
  final TextButtonThemeData textButtonTheme;

  /// A theme for customizing the appearance and layout of [TextField] widgets.
  final TextSelectionThemeData textSelectionTheme;

  /// A theme for customizing the appearance and layout of time picker widgets.
  final TimePickerThemeData timePickerTheme;

  /// Defines the default configuration of [ToggleButtons] widgets.
  final ToggleButtonsThemeData toggleButtonsTheme;

  /// A theme for customizing the visual properties of [Tooltip]s.
  ///
  /// This is the value returned from [TooltipTheme.of].
  final TooltipThemeData tooltipTheme;

  /// A theme for customizing the appearance and layout of [ButtonBar] widgets.
  @Deprecated(
    'Use OverflowBar instead. '
    'This feature was deprecated after v3.21.0-10.0.pre.',
  )
  ButtonBarThemeData get buttonBarTheme => _buttonBarTheme!;
  final ButtonBarThemeData? _buttonBarTheme;

  /// The background color of [Dialog] elements.
  @Deprecated(
    'Use DialogThemeData.backgroundColor instead. '
    'This feature was deprecated after v3.27.0-0.1.pre.',
  )
  final Color dialogBackgroundColor;

  /// Creates a copy of this theme but with the given fields replaced with the new values.
  ///
  /// The [brightness] value is applied to the [colorScheme].
  ThemeData copyWith({
    // For the sanity of the reader, make sure these properties are in the same
    // order in every place that they are separated by section comments (e.g.
    // GENERAL CONFIGURATION). Each section except for deprecations should be
    // alphabetical by symbol name.

    // GENERAL CONFIGURATION
    Iterable<Adaptation<Object>>? adaptations,
    bool? applyElevationOverlayColor,
    NoDefaultCupertinoThemeData? cupertinoOverrideTheme,
    Iterable<ThemeExtension<dynamic>>? extensions,
    InputDecorationTheme? inputDecorationTheme,
    MaterialTapTargetSize? materialTapTargetSize,
    PageTransitionsTheme? pageTransitionsTheme,
    TargetPlatform? platform,
    ScrollbarThemeData? scrollbarTheme,
    InteractiveInkFeatureFactory? splashFactory,
    VisualDensity? visualDensity,
    // COLOR
    ColorScheme? colorScheme,
    Brightness? brightness,
    // [colorScheme] is the preferred way to configure colors. The [Color] properties
    // listed below (as well as primarySwatch) will gradually be phased out, see
    // https://github.com/flutter/flutter/issues/91772.
    Color? canvasColor,
    Color? cardColor,
    Color? disabledColor,
    Color? dividerColor,
    Color? focusColor,
    Color? highlightColor,
    Color? hintColor,
    Color? hoverColor,
    Color? indicatorColor,
    Color? primaryColor,
    Color? primaryColorDark,
    Color? primaryColorLight,
    Color? scaffoldBackgroundColor,
    Color? secondaryHeaderColor,
    Color? shadowColor,
    Color? splashColor,
    Color? unselectedWidgetColor,
    // TYPOGRAPHY & ICONOGRAPHY
    IconThemeData? iconTheme,
    IconThemeData? primaryIconTheme,
    TextTheme? primaryTextTheme,
    TextTheme? textTheme,
    Typography? typography,
    // COMPONENT THEMES
    ActionIconThemeData? actionIconTheme,
    AppBarTheme? appBarTheme,
    BadgeThemeData? badgeTheme,
    MaterialBannerThemeData? bannerTheme,
    BottomAppBarTheme? bottomAppBarTheme,
    BottomNavigationBarThemeData? bottomNavigationBarTheme,
    BottomSheetThemeData? bottomSheetTheme,
    ButtonThemeData? buttonTheme,
    Object? cardTheme,
    CheckboxThemeData? checkboxTheme,
    ChipThemeData? chipTheme,
    DataTableThemeData? dataTableTheme,
    DatePickerThemeData? datePickerTheme,
    // TODO(QuncCccccc): Change the parameter type to DialogThemeData
    Object? dialogTheme,
    DividerThemeData? dividerTheme,
    DrawerThemeData? drawerTheme,
    DropdownMenuThemeData? dropdownMenuTheme,
    ElevatedButtonThemeData? elevatedButtonTheme,
    ExpansionTileThemeData? expansionTileTheme,
    FilledButtonThemeData? filledButtonTheme,
    FloatingActionButtonThemeData? floatingActionButtonTheme,
    IconButtonThemeData? iconButtonTheme,
    ListTileThemeData? listTileTheme,
    MenuBarThemeData? menuBarTheme,
    MenuButtonThemeData? menuButtonTheme,
    MenuThemeData? menuTheme,
    NavigationBarThemeData? navigationBarTheme,
    NavigationDrawerThemeData? navigationDrawerTheme,
    NavigationRailThemeData? navigationRailTheme,
    OutlinedButtonThemeData? outlinedButtonTheme,
    PopupMenuThemeData? popupMenuTheme,
    ProgressIndicatorThemeData? progressIndicatorTheme,
    RadioThemeData? radioTheme,
    SearchBarThemeData? searchBarTheme,
    SearchViewThemeData? searchViewTheme,
    SegmentedButtonThemeData? segmentedButtonTheme,
    SliderThemeData? sliderTheme,
    SnackBarThemeData? snackBarTheme,
    SwitchThemeData? switchTheme,
    // TODO(QuncCccccc): Change the parameter type to TabBarThemeData
    Object? tabBarTheme,
    TextButtonThemeData? textButtonTheme,
    TextSelectionThemeData? textSelectionTheme,
    TimePickerThemeData? timePickerTheme,
    ToggleButtonsThemeData? toggleButtonsTheme,
    TooltipThemeData? tooltipTheme,
    // DEPRECATED (newest deprecations at the bottom)
    @Deprecated(
      'Use a ThemeData constructor (.from, .light, or .dark) instead. '
      'These constructors all have a useMaterial3 argument, '
      'and they set appropriate default values based on its value. '
      'See the useMaterial3 API documentation for full details. '
      'This feature was deprecated after v3.13.0-0.2.pre.',
    )
    bool? useMaterial3,
    @Deprecated(
      'Use OverflowBar instead. '
      'This feature was deprecated after v3.21.0-10.0.pre.',
    )
    ButtonBarThemeData? buttonBarTheme,
    @Deprecated(
      'Use DialogThemeData.backgroundColor instead. '
      'This feature was deprecated after v3.27.0-0.1.pre.',
    )
    Color? dialogBackgroundColor,
  }) {
    cupertinoOverrideTheme = cupertinoOverrideTheme?.noDefault();

    // TODO(QuncCccccc): Clean it up once the type of `cardTheme` is changed to `CardThemeData`
    if (cardTheme != null) {
      if (cardTheme is CardTheme) {
        cardTheme = cardTheme.data;
      } else if (cardTheme is! CardThemeData) {
        throw ArgumentError('cardTheme must be either a CardThemeData or a CardTheme');
      }
    }

    // TODO(QuncCccccc): Clean this up once the type of `dialogTheme` is changed to `DialogThemeData`
    if (dialogTheme != null) {
      if (dialogTheme is DialogTheme) {
        dialogTheme = dialogTheme.data;
      } else if (dialogTheme is! DialogThemeData) {
        throw ArgumentError('dialogTheme must be either a DialogThemeData or a DialogTheme');
      }
    }

    // TODO(QuncCccccc): Clean this up once the type of `tabBarTheme` is changed to `TabBarThemeData`
    if (tabBarTheme != null) {
      if (tabBarTheme is TabBarTheme) {
        tabBarTheme = tabBarTheme.data;
      } else if (tabBarTheme is! TabBarThemeData) {
        throw ArgumentError('tabBarTheme must be either a TabBarThemeData or a TabBarTheme');
      }
    }
    return ThemeData.raw(
      // For the sanity of the reader, make sure these properties are in the same
      // order in every place that they are separated by section comments (e.g.
      // GENERAL CONFIGURATION). Each section except for deprecations should be
      // alphabetical by symbol name.

      // GENERAL CONFIGURATION
      adaptationMap: adaptations != null ? _createAdaptationMap(adaptations) : adaptationMap,
      applyElevationOverlayColor: applyElevationOverlayColor ?? this.applyElevationOverlayColor,
      cupertinoOverrideTheme: cupertinoOverrideTheme ?? this.cupertinoOverrideTheme,
      extensions: (extensions != null) ? _themeExtensionIterableToMap(extensions) : this.extensions,
      inputDecorationTheme: inputDecorationTheme ?? this.inputDecorationTheme,
      materialTapTargetSize: materialTapTargetSize ?? this.materialTapTargetSize,
      pageTransitionsTheme: pageTransitionsTheme ?? this.pageTransitionsTheme,
      platform: platform ?? this.platform,
      scrollbarTheme: scrollbarTheme ?? this.scrollbarTheme,
      splashFactory: splashFactory ?? this.splashFactory,
      // When deprecated useMaterial3 removed, maintain `this.useMaterial3` here
      // for == evaluation.
      useMaterial3: useMaterial3 ?? this.useMaterial3,
      visualDensity: visualDensity ?? this.visualDensity,
      // COLOR
      canvasColor: canvasColor ?? this.canvasColor,
      cardColor: cardColor ?? this.cardColor,
      colorScheme: (colorScheme ?? this.colorScheme).copyWith(brightness: brightness),
      disabledColor: disabledColor ?? this.disabledColor,
      dividerColor: dividerColor ?? this.dividerColor,
      focusColor: focusColor ?? this.focusColor,
      highlightColor: highlightColor ?? this.highlightColor,
      hintColor: hintColor ?? this.hintColor,
      hoverColor: hoverColor ?? this.hoverColor,
      indicatorColor: indicatorColor ?? this.indicatorColor,
      primaryColor: primaryColor ?? this.primaryColor,
      primaryColorDark: primaryColorDark ?? this.primaryColorDark,
      primaryColorLight: primaryColorLight ?? this.primaryColorLight,
      scaffoldBackgroundColor: scaffoldBackgroundColor ?? this.scaffoldBackgroundColor,
      secondaryHeaderColor: secondaryHeaderColor ?? this.secondaryHeaderColor,
      shadowColor: shadowColor ?? this.shadowColor,
      splashColor: splashColor ?? this.splashColor,
      unselectedWidgetColor: unselectedWidgetColor ?? this.unselectedWidgetColor,
      // TYPOGRAPHY & ICONOGRAPHY
      iconTheme: iconTheme ?? this.iconTheme,
      primaryIconTheme: primaryIconTheme ?? this.primaryIconTheme,
      primaryTextTheme: primaryTextTheme ?? this.primaryTextTheme,
      textTheme: textTheme ?? this.textTheme,
      typography: typography ?? this.typography,
      // COMPONENT THEMES
      actionIconTheme: actionIconTheme ?? this.actionIconTheme,
      appBarTheme: appBarTheme ?? this.appBarTheme,
      badgeTheme: badgeTheme ?? this.badgeTheme,
      bannerTheme: bannerTheme ?? this.bannerTheme,
      bottomAppBarTheme: bottomAppBarTheme ?? this.bottomAppBarTheme,
      bottomNavigationBarTheme: bottomNavigationBarTheme ?? this.bottomNavigationBarTheme,
      bottomSheetTheme: bottomSheetTheme ?? this.bottomSheetTheme,
      buttonTheme: buttonTheme ?? this.buttonTheme,
      cardTheme: cardTheme as CardThemeData? ?? this.cardTheme,
      checkboxTheme: checkboxTheme ?? this.checkboxTheme,
      chipTheme: chipTheme ?? this.chipTheme,
      dataTableTheme: dataTableTheme ?? this.dataTableTheme,
      datePickerTheme: datePickerTheme ?? this.datePickerTheme,
      dialogTheme: dialogTheme as DialogThemeData? ?? this.dialogTheme,
      dividerTheme: dividerTheme ?? this.dividerTheme,
      drawerTheme: drawerTheme ?? this.drawerTheme,
      dropdownMenuTheme: dropdownMenuTheme ?? this.dropdownMenuTheme,
      elevatedButtonTheme: elevatedButtonTheme ?? this.elevatedButtonTheme,
      expansionTileTheme: expansionTileTheme ?? this.expansionTileTheme,
      filledButtonTheme: filledButtonTheme ?? this.filledButtonTheme,
      floatingActionButtonTheme: floatingActionButtonTheme ?? this.floatingActionButtonTheme,
      iconButtonTheme: iconButtonTheme ?? this.iconButtonTheme,
      listTileTheme: listTileTheme ?? this.listTileTheme,
      menuBarTheme: menuBarTheme ?? this.menuBarTheme,
      menuButtonTheme: menuButtonTheme ?? this.menuButtonTheme,
      menuTheme: menuTheme ?? this.menuTheme,
      navigationBarTheme: navigationBarTheme ?? this.navigationBarTheme,
      navigationDrawerTheme: navigationDrawerTheme ?? this.navigationDrawerTheme,
      navigationRailTheme: navigationRailTheme ?? this.navigationRailTheme,
      outlinedButtonTheme: outlinedButtonTheme ?? this.outlinedButtonTheme,
      popupMenuTheme: popupMenuTheme ?? this.popupMenuTheme,
      progressIndicatorTheme: progressIndicatorTheme ?? this.progressIndicatorTheme,
      radioTheme: radioTheme ?? this.radioTheme,
      searchBarTheme: searchBarTheme ?? this.searchBarTheme,
      searchViewTheme: searchViewTheme ?? this.searchViewTheme,
      segmentedButtonTheme: segmentedButtonTheme ?? this.segmentedButtonTheme,
      sliderTheme: sliderTheme ?? this.sliderTheme,
      snackBarTheme: snackBarTheme ?? this.snackBarTheme,
      switchTheme: switchTheme ?? this.switchTheme,
      tabBarTheme: tabBarTheme as TabBarThemeData? ?? this.tabBarTheme,
      textButtonTheme: textButtonTheme ?? this.textButtonTheme,
      textSelectionTheme: textSelectionTheme ?? this.textSelectionTheme,
      timePickerTheme: timePickerTheme ?? this.timePickerTheme,
      toggleButtonsTheme: toggleButtonsTheme ?? this.toggleButtonsTheme,
      tooltipTheme: tooltipTheme ?? this.tooltipTheme,
      // DEPRECATED (newest deprecations at the bottom)
      buttonBarTheme: buttonBarTheme ?? _buttonBarTheme,
      dialogBackgroundColor: dialogBackgroundColor ?? this.dialogBackgroundColor,
    );
  }

  // The number 5 was chosen without any real science or research behind it. It
  // just seemed like a number that's not too big (we should be able to fit 5
  // copies of ThemeData in memory comfortably) and not too small (most apps
  // shouldn't have more than 5 theme/localization pairs).
  static const int _localizedThemeDataCacheSize = 5;

  /// Caches localized themes to speed up the [localize] method.
  static final _FifoCache<_IdentityThemeDataCacheKey, ThemeData> _localizedThemeDataCache =
      _FifoCache<_IdentityThemeDataCacheKey, ThemeData>(_localizedThemeDataCacheSize);

  /// Returns a new theme built by merging the text geometry provided by the
  /// [localTextGeometry] theme with the [baseTheme].
  ///
  /// For those text styles in the [baseTheme] whose [TextStyle.inherit] is set
  /// to true, the returned theme's text styles inherit the geometric properties
  /// of [localTextGeometry]. The resulting text styles' [TextStyle.inherit] is
  /// set to those provided by [localTextGeometry].
  static ThemeData localize(ThemeData baseTheme, TextTheme localTextGeometry) {
    // WARNING: this method memoizes the result in a cache based on the
    // previously seen baseTheme and localTextGeometry. Memoization is safe
    // because all inputs and outputs of this function are deeply immutable, and
    // the computations are referentially transparent. It only short-circuits
    // the computation if the new inputs are identical() to the previous ones.
    // It does not use the == operator, which performs a costly deep comparison.
    //
    // When changing this method, make sure the memoization logic is correct.
    // Remember:
    //
    // There are only two hard things in Computer Science: cache invalidation
    // and naming things. -- Phil Karlton

    return _localizedThemeDataCache.putIfAbsent(
      _IdentityThemeDataCacheKey(baseTheme, localTextGeometry),
      () {
        return baseTheme.copyWith(
          primaryTextTheme: localTextGeometry.merge(baseTheme.primaryTextTheme),
          textTheme: localTextGeometry.merge(baseTheme.textTheme),
        );
      },
    );
  }

  /// Determines whether the given [Color] is [Brightness.light] or
  /// [Brightness.dark].
  ///
  /// This compares the luminosity of the given color to a threshold value that
  /// matches the Material Design specification.
  static Brightness estimateBrightnessForColor(Color color) {
    final double relativeLuminance = color.computeLuminance();

    // See <https://www.w3.org/TR/WCAG20/#contrast-ratiodef>
    // The spec says to use kThreshold=0.0525, but Material Design appears to bias
    // more towards using light text than WCAG20 recommends. Material Design spec
    // doesn't say what value to use, but 0.15 seemed close to what the Material
    // Design spec shows for its color palette on
    // <https://material.io/go/design-theming#color-color-palette>.
    const double kThreshold = 0.15;
    if ((relativeLuminance + 0.05) * (relativeLuminance + 0.05) > kThreshold) {
      return Brightness.light;
    }
    return Brightness.dark;
  }

  /// Linearly interpolate between two [extensions].
  ///
  /// Includes all theme extensions in [a] and [b].
  ///
  /// {@macro dart.ui.shadow.lerp}
  static Map<Object, ThemeExtension<dynamic>> _lerpThemeExtensions(
    ThemeData a,
    ThemeData b,
    double t,
  ) {
    // Lerp [a].
    final Map<Object, ThemeExtension<dynamic>> newExtensions = a.extensions.map((
      Object id,
      ThemeExtension<dynamic> extensionA,
    ) {
      final ThemeExtension<dynamic>? extensionB = b.extensions[id];
      return MapEntry<Object, ThemeExtension<dynamic>>(id, extensionA.lerp(extensionB, t));
    });
    // Add [b]-only extensions.
    newExtensions.addEntries(
      b.extensions.entries.where(
        (MapEntry<Object, ThemeExtension<dynamic>> entry) => !a.extensions.containsKey(entry.key),
      ),
    );

    return newExtensions;
  }

  /// Convert the [extensionsIterable] passed to [ThemeData.new] or [copyWith]
  /// to the stored [extensions] map, where each entry's key consists of the extension's type.
  static Map<Object, ThemeExtension<dynamic>> _themeExtensionIterableToMap(
    Iterable<ThemeExtension<dynamic>> extensionsIterable,
  ) {
    return Map<Object, ThemeExtension<dynamic>>.unmodifiable(<Object, ThemeExtension<dynamic>>{
      // Strangely, the cast is necessary for tests to run.
      for (final ThemeExtension<dynamic> extension in extensionsIterable)
        extension.type: extension as ThemeExtension<ThemeExtension<dynamic>>,
    });
  }

  /// Linearly interpolate between two themes.
  ///
  /// {@macro dart.ui.shadow.lerp}
  static ThemeData lerp(ThemeData a, ThemeData b, double t) {
    if (identical(a, b)) {
      return a;
    }
    return ThemeData.raw(
      // For the sanity of the reader, make sure these properties are in the same
      // order in every place that they are separated by section comments (e.g.
      // GENERAL CONFIGURATION). Each section except for deprecations should be
      // alphabetical by symbol name.

      // GENERAL CONFIGURATION
      adaptationMap: t < 0.5 ? a.adaptationMap : b.adaptationMap,
      applyElevationOverlayColor:
          t < 0.5 ? a.applyElevationOverlayColor : b.applyElevationOverlayColor,
      cupertinoOverrideTheme: t < 0.5 ? a.cupertinoOverrideTheme : b.cupertinoOverrideTheme,
      extensions: _lerpThemeExtensions(a, b, t),
      inputDecorationTheme: t < 0.5 ? a.inputDecorationTheme : b.inputDecorationTheme,
      materialTapTargetSize: t < 0.5 ? a.materialTapTargetSize : b.materialTapTargetSize,
      pageTransitionsTheme: t < 0.5 ? a.pageTransitionsTheme : b.pageTransitionsTheme,
      platform: t < 0.5 ? a.platform : b.platform,
      scrollbarTheme: ScrollbarThemeData.lerp(a.scrollbarTheme, b.scrollbarTheme, t),
      splashFactory: t < 0.5 ? a.splashFactory : b.splashFactory,
      useMaterial3: t < 0.5 ? a.useMaterial3 : b.useMaterial3,
      visualDensity: VisualDensity.lerp(a.visualDensity, b.visualDensity, t),
      // COLOR
      canvasColor: Color.lerp(a.canvasColor, b.canvasColor, t)!,
      cardColor: Color.lerp(a.cardColor, b.cardColor, t)!,
      colorScheme: ColorScheme.lerp(a.colorScheme, b.colorScheme, t),
      disabledColor: Color.lerp(a.disabledColor, b.disabledColor, t)!,
      dividerColor: Color.lerp(a.dividerColor, b.dividerColor, t)!,
      focusColor: Color.lerp(a.focusColor, b.focusColor, t)!,
      highlightColor: Color.lerp(a.highlightColor, b.highlightColor, t)!,
      hintColor: Color.lerp(a.hintColor, b.hintColor, t)!,
      hoverColor: Color.lerp(a.hoverColor, b.hoverColor, t)!,
      indicatorColor: Color.lerp(a.indicatorColor, b.indicatorColor, t)!,
      primaryColor: Color.lerp(a.primaryColor, b.primaryColor, t)!,
      primaryColorDark: Color.lerp(a.primaryColorDark, b.primaryColorDark, t)!,
      primaryColorLight: Color.lerp(a.primaryColorLight, b.primaryColorLight, t)!,
      scaffoldBackgroundColor: Color.lerp(a.scaffoldBackgroundColor, b.scaffoldBackgroundColor, t)!,
      secondaryHeaderColor: Color.lerp(a.secondaryHeaderColor, b.secondaryHeaderColor, t)!,
      shadowColor: Color.lerp(a.shadowColor, b.shadowColor, t)!,
      splashColor: Color.lerp(a.splashColor, b.splashColor, t)!,
      unselectedWidgetColor: Color.lerp(a.unselectedWidgetColor, b.unselectedWidgetColor, t)!,
      // TYPOGRAPHY & ICONOGRAPHY
      iconTheme: IconThemeData.lerp(a.iconTheme, b.iconTheme, t),
      primaryIconTheme: IconThemeData.lerp(a.primaryIconTheme, b.primaryIconTheme, t),
      primaryTextTheme: TextTheme.lerp(a.primaryTextTheme, b.primaryTextTheme, t),
      textTheme: TextTheme.lerp(a.textTheme, b.textTheme, t),
      typography: Typography.lerp(a.typography, b.typography, t),
      // COMPONENT THEMES
      actionIconTheme: ActionIconThemeData.lerp(a.actionIconTheme, b.actionIconTheme, t),
      appBarTheme: AppBarTheme.lerp(a.appBarTheme, b.appBarTheme, t),
      badgeTheme: BadgeThemeData.lerp(a.badgeTheme, b.badgeTheme, t),
      bannerTheme: MaterialBannerThemeData.lerp(a.bannerTheme, b.bannerTheme, t),
      bottomAppBarTheme: BottomAppBarTheme.lerp(a.bottomAppBarTheme, b.bottomAppBarTheme, t),
      bottomNavigationBarTheme: BottomNavigationBarThemeData.lerp(
        a.bottomNavigationBarTheme,
        b.bottomNavigationBarTheme,
        t,
      ),
      bottomSheetTheme: BottomSheetThemeData.lerp(a.bottomSheetTheme, b.bottomSheetTheme, t)!,
      buttonTheme: t < 0.5 ? a.buttonTheme : b.buttonTheme,
      cardTheme: CardThemeData.lerp(a.cardTheme, b.cardTheme, t),
      checkboxTheme: CheckboxThemeData.lerp(a.checkboxTheme, b.checkboxTheme, t),
      chipTheme: ChipThemeData.lerp(a.chipTheme, b.chipTheme, t)!,
      dataTableTheme: DataTableThemeData.lerp(a.dataTableTheme, b.dataTableTheme, t),
      datePickerTheme: DatePickerThemeData.lerp(a.datePickerTheme, b.datePickerTheme, t),
      dialogTheme: DialogThemeData.lerp(a.dialogTheme, b.dialogTheme, t),
      dividerTheme: DividerThemeData.lerp(a.dividerTheme, b.dividerTheme, t),
      drawerTheme: DrawerThemeData.lerp(a.drawerTheme, b.drawerTheme, t)!,
      dropdownMenuTheme: DropdownMenuThemeData.lerp(a.dropdownMenuTheme, b.dropdownMenuTheme, t),
      elevatedButtonTheme:
          ElevatedButtonThemeData.lerp(a.elevatedButtonTheme, b.elevatedButtonTheme, t)!,
      expansionTileTheme:
          ExpansionTileThemeData.lerp(a.expansionTileTheme, b.expansionTileTheme, t)!,
      filledButtonTheme: FilledButtonThemeData.lerp(a.filledButtonTheme, b.filledButtonTheme, t)!,
      floatingActionButtonTheme:
          FloatingActionButtonThemeData.lerp(
            a.floatingActionButtonTheme,
            b.floatingActionButtonTheme,
            t,
          )!,
      iconButtonTheme: IconButtonThemeData.lerp(a.iconButtonTheme, b.iconButtonTheme, t)!,
      listTileTheme: ListTileThemeData.lerp(a.listTileTheme, b.listTileTheme, t)!,
      menuBarTheme: MenuBarThemeData.lerp(a.menuBarTheme, b.menuBarTheme, t)!,
      menuButtonTheme: MenuButtonThemeData.lerp(a.menuButtonTheme, b.menuButtonTheme, t)!,
      menuTheme: MenuThemeData.lerp(a.menuTheme, b.menuTheme, t)!,
      navigationBarTheme:
          NavigationBarThemeData.lerp(a.navigationBarTheme, b.navigationBarTheme, t)!,
      navigationDrawerTheme:
          NavigationDrawerThemeData.lerp(a.navigationDrawerTheme, b.navigationDrawerTheme, t)!,
      navigationRailTheme:
          NavigationRailThemeData.lerp(a.navigationRailTheme, b.navigationRailTheme, t)!,
      outlinedButtonTheme:
          OutlinedButtonThemeData.lerp(a.outlinedButtonTheme, b.outlinedButtonTheme, t)!,
      popupMenuTheme: PopupMenuThemeData.lerp(a.popupMenuTheme, b.popupMenuTheme, t)!,
      progressIndicatorTheme:
          ProgressIndicatorThemeData.lerp(a.progressIndicatorTheme, b.progressIndicatorTheme, t)!,
      radioTheme: RadioThemeData.lerp(a.radioTheme, b.radioTheme, t),
      searchBarTheme: SearchBarThemeData.lerp(a.searchBarTheme, b.searchBarTheme, t)!,
      searchViewTheme: SearchViewThemeData.lerp(a.searchViewTheme, b.searchViewTheme, t)!,
      segmentedButtonTheme: SegmentedButtonThemeData.lerp(
        a.segmentedButtonTheme,
        b.segmentedButtonTheme,
        t,
      ),
      sliderTheme: SliderThemeData.lerp(a.sliderTheme, b.sliderTheme, t),
      snackBarTheme: SnackBarThemeData.lerp(a.snackBarTheme, b.snackBarTheme, t),
      switchTheme: SwitchThemeData.lerp(a.switchTheme, b.switchTheme, t),
      tabBarTheme: TabBarThemeData.lerp(a.tabBarTheme, b.tabBarTheme, t),
      textButtonTheme: TextButtonThemeData.lerp(a.textButtonTheme, b.textButtonTheme, t)!,
      textSelectionTheme:
          TextSelectionThemeData.lerp(a.textSelectionTheme, b.textSelectionTheme, t)!,
      timePickerTheme: TimePickerThemeData.lerp(a.timePickerTheme, b.timePickerTheme, t),
      toggleButtonsTheme:
          ToggleButtonsThemeData.lerp(a.toggleButtonsTheme, b.toggleButtonsTheme, t)!,
      tooltipTheme: TooltipThemeData.lerp(a.tooltipTheme, b.tooltipTheme, t)!,
      // DEPRECATED (newest deprecations at the bottom)
      buttonBarTheme: ButtonBarThemeData.lerp(a.buttonBarTheme, b.buttonBarTheme, t),
      dialogBackgroundColor: Color.lerp(a.dialogBackgroundColor, b.dialogBackgroundColor, t)!,
    );
  }

  @override
  bool operator ==(Object other) {
    if (other.runtimeType != runtimeType) {
      return false;
    }
    return other is ThemeData &&
        // For the sanity of the reader, make sure these properties are in the same
        // order in every place that they are separated by section comments (e.g.
        // GENERAL CONFIGURATION). Each section except for deprecations should be
        // alphabetical by symbol name.
        // GENERAL CONFIGURATION
        mapEquals(other.adaptationMap, adaptationMap) &&
        other.applyElevationOverlayColor == applyElevationOverlayColor &&
        other.cupertinoOverrideTheme == cupertinoOverrideTheme &&
        mapEquals(other.extensions, extensions) &&
        other.inputDecorationTheme == inputDecorationTheme &&
        other.materialTapTargetSize == materialTapTargetSize &&
        other.pageTransitionsTheme == pageTransitionsTheme &&
        other.platform == platform &&
        other.scrollbarTheme == scrollbarTheme &&
        other.splashFactory == splashFactory &&
        other.useMaterial3 == useMaterial3 &&
        other.visualDensity == visualDensity &&
        // COLOR
        other.canvasColor == canvasColor &&
        other.cardColor == cardColor &&
        other.colorScheme == colorScheme &&
        other.disabledColor == disabledColor &&
        other.dividerColor == dividerColor &&
        other.focusColor == focusColor &&
        other.highlightColor == highlightColor &&
        other.hintColor == hintColor &&
        other.hoverColor == hoverColor &&
        other.indicatorColor == indicatorColor &&
        other.primaryColor == primaryColor &&
        other.primaryColorDark == primaryColorDark &&
        other.primaryColorLight == primaryColorLight &&
        other.scaffoldBackgroundColor == scaffoldBackgroundColor &&
        other.secondaryHeaderColor == secondaryHeaderColor &&
        other.shadowColor == shadowColor &&
        other.splashColor == splashColor &&
        other.unselectedWidgetColor == unselectedWidgetColor &&
        // TYPOGRAPHY & ICONOGRAPHY
        other.iconTheme == iconTheme &&
        other.primaryIconTheme == primaryIconTheme &&
        other.primaryTextTheme == primaryTextTheme &&
        other.textTheme == textTheme &&
        other.typography == typography &&
        // COMPONENT THEMES
        other.actionIconTheme == actionIconTheme &&
        other.appBarTheme == appBarTheme &&
        other.badgeTheme == badgeTheme &&
        other.bannerTheme == bannerTheme &&
        other.bottomAppBarTheme == bottomAppBarTheme &&
        other.bottomNavigationBarTheme == bottomNavigationBarTheme &&
        other.bottomSheetTheme == bottomSheetTheme &&
        other.buttonTheme == buttonTheme &&
        other.cardTheme == cardTheme &&
        other.checkboxTheme == checkboxTheme &&
        other.chipTheme == chipTheme &&
        other.dataTableTheme == dataTableTheme &&
        other.datePickerTheme == datePickerTheme &&
        other.dialogTheme == dialogTheme &&
        other.dividerTheme == dividerTheme &&
        other.drawerTheme == drawerTheme &&
        other.dropdownMenuTheme == dropdownMenuTheme &&
        other.elevatedButtonTheme == elevatedButtonTheme &&
        other.expansionTileTheme == expansionTileTheme &&
        other.filledButtonTheme == filledButtonTheme &&
        other.floatingActionButtonTheme == floatingActionButtonTheme &&
        other.iconButtonTheme == iconButtonTheme &&
        other.listTileTheme == listTileTheme &&
        other.menuBarTheme == menuBarTheme &&
        other.menuButtonTheme == menuButtonTheme &&
        other.menuTheme == menuTheme &&
        other.navigationBarTheme == navigationBarTheme &&
        other.navigationDrawerTheme == navigationDrawerTheme &&
        other.navigationRailTheme == navigationRailTheme &&
        other.outlinedButtonTheme == outlinedButtonTheme &&
        other.popupMenuTheme == popupMenuTheme &&
        other.progressIndicatorTheme == progressIndicatorTheme &&
        other.radioTheme == radioTheme &&
        other.searchBarTheme == searchBarTheme &&
        other.searchViewTheme == searchViewTheme &&
        other.segmentedButtonTheme == segmentedButtonTheme &&
        other.sliderTheme == sliderTheme &&
        other.snackBarTheme == snackBarTheme &&
        other.switchTheme == switchTheme &&
        other.tabBarTheme == tabBarTheme &&
        other.textButtonTheme == textButtonTheme &&
        other.textSelectionTheme == textSelectionTheme &&
        other.timePickerTheme == timePickerTheme &&
        other.toggleButtonsTheme == toggleButtonsTheme &&
        other.tooltipTheme == tooltipTheme &&
        // DEPRECATED (newest deprecations at the bottom)
        other.buttonBarTheme == buttonBarTheme &&
        other.dialogBackgroundColor == dialogBackgroundColor;
  }

  @override
  int get hashCode {
    final List<Object?> values = <Object?>[
      // For the sanity of the reader, make sure these properties are in the same
      // order in every place that they are separated by section comments (e.g.
      // GENERAL CONFIGURATION). Each section except for deprecations should be
      // alphabetical by symbol name.

      // GENERAL CONFIGURATION
      ...adaptationMap.keys,
      ...adaptationMap.values,
      applyElevationOverlayColor,
      cupertinoOverrideTheme,
      ...extensions.keys,
      ...extensions.values,
      inputDecorationTheme,
      materialTapTargetSize,
      pageTransitionsTheme,
      platform,
      scrollbarTheme,
      splashFactory,
      useMaterial3,
      visualDensity,
      // COLOR
      canvasColor,
      cardColor,
      colorScheme,
      disabledColor,
      dividerColor,
      focusColor,
      highlightColor,
      hintColor,
      hoverColor,
      indicatorColor,
      primaryColor,
      primaryColorDark,
      primaryColorLight,
      scaffoldBackgroundColor,
      secondaryHeaderColor,
      shadowColor,
      splashColor,
      unselectedWidgetColor,
      // TYPOGRAPHY & ICONOGRAPHY
      iconTheme,
      primaryIconTheme,
      primaryTextTheme,
      textTheme,
      typography,
      // COMPONENT THEMES
      actionIconTheme,
      appBarTheme,
      badgeTheme,
      bannerTheme,
      bottomAppBarTheme,
      bottomNavigationBarTheme,
      bottomSheetTheme,
      buttonTheme,
      cardTheme,
      checkboxTheme,
      chipTheme,
      dataTableTheme,
      datePickerTheme,
      dialogTheme,
      dividerTheme,
      drawerTheme,
      dropdownMenuTheme,
      elevatedButtonTheme,
      expansionTileTheme,
      filledButtonTheme,
      floatingActionButtonTheme,
      iconButtonTheme,
      listTileTheme,
      menuBarTheme,
      menuButtonTheme,
      menuTheme,
      navigationBarTheme,
      navigationDrawerTheme,
      navigationRailTheme,
      outlinedButtonTheme,
      popupMenuTheme,
      progressIndicatorTheme,
      radioTheme,
      searchBarTheme,
      searchViewTheme,
      segmentedButtonTheme,
      sliderTheme,
      snackBarTheme,
      switchTheme,
      tabBarTheme,
      textButtonTheme,
      textSelectionTheme,
      timePickerTheme,
      toggleButtonsTheme,
      tooltipTheme,
      // DEPRECATED (newest deprecations at the bottom)
      buttonBarTheme,
      dialogBackgroundColor,
    ];
    return Object.hashAll(values);
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    final ThemeData defaultData = ThemeData.fallback();
    // For the sanity of the reader, make sure these properties are in the same
    // order in every place that they are separated by section comments (e.g.
    // GENERAL CONFIGURATION). Each section except for deprecations should be
    // alphabetical by symbol name.

    // GENERAL CONFIGURATION
    properties.add(
      IterableProperty<Adaptation<dynamic>>(
        'adaptations',
        adaptationMap.values,
        defaultValue: defaultData.adaptationMap.values,
        level: DiagnosticLevel.debug,
      ),
    );
    properties.add(
      DiagnosticsProperty<bool>(
        'applyElevationOverlayColor',
        applyElevationOverlayColor,
        level: DiagnosticLevel.debug,
      ),
    );
    properties.add(
      DiagnosticsProperty<NoDefaultCupertinoThemeData>(
        'cupertinoOverrideTheme',
        cupertinoOverrideTheme,
        defaultValue: defaultData.cupertinoOverrideTheme,
        level: DiagnosticLevel.debug,
      ),
    );
    properties.add(
      IterableProperty<ThemeExtension<dynamic>>(
        'extensions',
        extensions.values,
        defaultValue: defaultData.extensions.values,
        level: DiagnosticLevel.debug,
      ),
    );
    properties.add(
      DiagnosticsProperty<InputDecorationTheme>(
        'inputDecorationTheme',
        inputDecorationTheme,
        level: DiagnosticLevel.debug,
      ),
    );
    properties.add(
      DiagnosticsProperty<MaterialTapTargetSize>(
        'materialTapTargetSize',
        materialTapTargetSize,
        level: DiagnosticLevel.debug,
      ),
    );
    properties.add(
      DiagnosticsProperty<PageTransitionsTheme>(
        'pageTransitionsTheme',
        pageTransitionsTheme,
        level: DiagnosticLevel.debug,
      ),
    );
    properties.add(
      EnumProperty<TargetPlatform>(
        'platform',
        platform,
        defaultValue: defaultTargetPlatform,
        level: DiagnosticLevel.debug,
      ),
    );
    properties.add(
      DiagnosticsProperty<ScrollbarThemeData>(
        'scrollbarTheme',
        scrollbarTheme,
        defaultValue: defaultData.scrollbarTheme,
        level: DiagnosticLevel.debug,
      ),
    );
    properties.add(
      DiagnosticsProperty<InteractiveInkFeatureFactory>(
        'splashFactory',
        splashFactory,
        defaultValue: defaultData.splashFactory,
        level: DiagnosticLevel.debug,
      ),
    );
    properties.add(
      DiagnosticsProperty<bool>(
        'useMaterial3',
        useMaterial3,
        defaultValue: defaultData.useMaterial3,
        level: DiagnosticLevel.debug,
      ),
    );
    properties.add(
      DiagnosticsProperty<VisualDensity>(
        'visualDensity',
        visualDensity,
        defaultValue: defaultData.visualDensity,
        level: DiagnosticLevel.debug,
      ),
    );
    // COLORS
    properties.add(
      ColorProperty(
        'canvasColor',
        canvasColor,
        defaultValue: defaultData.canvasColor,
        level: DiagnosticLevel.debug,
      ),
    );
    properties.add(
      ColorProperty(
        'cardColor',
        cardColor,
        defaultValue: defaultData.cardColor,
        level: DiagnosticLevel.debug,
      ),
    );
    properties.add(
      DiagnosticsProperty<ColorScheme>(
        'colorScheme',
        colorScheme,
        defaultValue: defaultData.colorScheme,
        level: DiagnosticLevel.debug,
      ),
    );
    properties.add(
      ColorProperty(
        'disabledColor',
        disabledColor,
        defaultValue: defaultData.disabledColor,
        level: DiagnosticLevel.debug,
      ),
    );
    properties.add(
      ColorProperty(
        'dividerColor',
        dividerColor,
        defaultValue: defaultData.dividerColor,
        level: DiagnosticLevel.debug,
      ),
    );
    properties.add(
      ColorProperty(
        'focusColor',
        focusColor,
        defaultValue: defaultData.focusColor,
        level: DiagnosticLevel.debug,
      ),
    );
    properties.add(
      ColorProperty(
        'highlightColor',
        highlightColor,
        defaultValue: defaultData.highlightColor,
        level: DiagnosticLevel.debug,
      ),
    );
    properties.add(
      ColorProperty(
        'hintColor',
        hintColor,
        defaultValue: defaultData.hintColor,
        level: DiagnosticLevel.debug,
      ),
    );
    properties.add(
      ColorProperty(
        'hoverColor',
        hoverColor,
        defaultValue: defaultData.hoverColor,
        level: DiagnosticLevel.debug,
      ),
    );
    properties.add(
      ColorProperty(
        'indicatorColor',
        indicatorColor,
        defaultValue: defaultData.indicatorColor,
        level: DiagnosticLevel.debug,
      ),
    );
    properties.add(
      ColorProperty(
        'primaryColorDark',
        primaryColorDark,
        defaultValue: defaultData.primaryColorDark,
        level: DiagnosticLevel.debug,
      ),
    );
    properties.add(
      ColorProperty(
        'primaryColorLight',
        primaryColorLight,
        defaultValue: defaultData.primaryColorLight,
        level: DiagnosticLevel.debug,
      ),
    );
    properties.add(
      ColorProperty(
        'primaryColor',
        primaryColor,
        defaultValue: defaultData.primaryColor,
        level: DiagnosticLevel.debug,
      ),
    );
    properties.add(
      ColorProperty(
        'scaffoldBackgroundColor',
        scaffoldBackgroundColor,
        defaultValue: defaultData.scaffoldBackgroundColor,
        level: DiagnosticLevel.debug,
      ),
    );
    properties.add(
      ColorProperty(
        'secondaryHeaderColor',
        secondaryHeaderColor,
        defaultValue: defaultData.secondaryHeaderColor,
        level: DiagnosticLevel.debug,
      ),
    );
    properties.add(
      ColorProperty(
        'shadowColor',
        shadowColor,
        defaultValue: defaultData.shadowColor,
        level: DiagnosticLevel.debug,
      ),
    );
    properties.add(
      ColorProperty(
        'splashColor',
        splashColor,
        defaultValue: defaultData.splashColor,
        level: DiagnosticLevel.debug,
      ),
    );
    properties.add(
      ColorProperty(
        'unselectedWidgetColor',
        unselectedWidgetColor,
        defaultValue: defaultData.unselectedWidgetColor,
        level: DiagnosticLevel.debug,
      ),
    );
    // TYPOGRAPHY & ICONOGRAPHY
    properties.add(
      DiagnosticsProperty<IconThemeData>('iconTheme', iconTheme, level: DiagnosticLevel.debug),
    );
    properties.add(
      DiagnosticsProperty<IconThemeData>(
        'primaryIconTheme',
        primaryIconTheme,
        level: DiagnosticLevel.debug,
      ),
    );
    properties.add(
      DiagnosticsProperty<TextTheme>(
        'primaryTextTheme',
        primaryTextTheme,
        level: DiagnosticLevel.debug,
      ),
    );
    properties.add(
      DiagnosticsProperty<TextTheme>('textTheme', textTheme, level: DiagnosticLevel.debug),
    );
    properties.add(
      DiagnosticsProperty<Typography>(
        'typography',
        typography,
        defaultValue: defaultData.typography,
        level: DiagnosticLevel.debug,
      ),
    );
    // COMPONENT THEMES
    properties.add(
      DiagnosticsProperty<ActionIconThemeData>(
        'actionIconTheme',
        actionIconTheme,
        level: DiagnosticLevel.debug,
      ),
    );
    properties.add(
      DiagnosticsProperty<AppBarTheme>(
        'appBarTheme',
        appBarTheme,
        defaultValue: defaultData.appBarTheme,
        level: DiagnosticLevel.debug,
      ),
    );
    properties.add(
      DiagnosticsProperty<BadgeThemeData>(
        'badgeTheme',
        badgeTheme,
        defaultValue: defaultData.badgeTheme,
        level: DiagnosticLevel.debug,
      ),
    );
    properties.add(
      DiagnosticsProperty<MaterialBannerThemeData>(
        'bannerTheme',
        bannerTheme,
        defaultValue: defaultData.bannerTheme,
        level: DiagnosticLevel.debug,
      ),
    );
    properties.add(
      DiagnosticsProperty<BottomAppBarTheme>(
        'bottomAppBarTheme',
        bottomAppBarTheme,
        defaultValue: defaultData.bottomAppBarTheme,
        level: DiagnosticLevel.debug,
      ),
    );
    properties.add(
      DiagnosticsProperty<BottomNavigationBarThemeData>(
        'bottomNavigationBarTheme',
        bottomNavigationBarTheme,
        defaultValue: defaultData.bottomNavigationBarTheme,
        level: DiagnosticLevel.debug,
      ),
    );
    properties.add(
      DiagnosticsProperty<BottomSheetThemeData>(
        'bottomSheetTheme',
        bottomSheetTheme,
        defaultValue: defaultData.bottomSheetTheme,
        level: DiagnosticLevel.debug,
      ),
    );
    properties.add(
      DiagnosticsProperty<ButtonThemeData>(
        'buttonTheme',
        buttonTheme,
        level: DiagnosticLevel.debug,
      ),
    );
    properties.add(
      DiagnosticsProperty<CardThemeData>('cardTheme', cardTheme, level: DiagnosticLevel.debug),
    );
    properties.add(
      DiagnosticsProperty<CheckboxThemeData>(
        'checkboxTheme',
        checkboxTheme,
        defaultValue: defaultData.checkboxTheme,
        level: DiagnosticLevel.debug,
      ),
    );
    properties.add(
      DiagnosticsProperty<ChipThemeData>('chipTheme', chipTheme, level: DiagnosticLevel.debug),
    );
    properties.add(
      DiagnosticsProperty<DataTableThemeData>(
        'dataTableTheme',
        dataTableTheme,
        defaultValue: defaultData.dataTableTheme,
        level: DiagnosticLevel.debug,
      ),
    );
    properties.add(
      DiagnosticsProperty<DatePickerThemeData>(
        'datePickerTheme',
        datePickerTheme,
        defaultValue: defaultData.datePickerTheme,
        level: DiagnosticLevel.debug,
      ),
    );
    properties.add(
      DiagnosticsProperty<DialogThemeData>(
        'dialogTheme',
        dialogTheme,
        defaultValue: defaultData.dialogTheme,
        level: DiagnosticLevel.debug,
      ),
    );
    properties.add(
      DiagnosticsProperty<DividerThemeData>(
        'dividerTheme',
        dividerTheme,
        defaultValue: defaultData.dividerTheme,
        level: DiagnosticLevel.debug,
      ),
    );
    properties.add(
      DiagnosticsProperty<DrawerThemeData>(
        'drawerTheme',
        drawerTheme,
        defaultValue: defaultData.drawerTheme,
        level: DiagnosticLevel.debug,
      ),
    );
    properties.add(
      DiagnosticsProperty<DropdownMenuThemeData>(
        'dropdownMenuTheme',
        dropdownMenuTheme,
        defaultValue: defaultData.dropdownMenuTheme,
        level: DiagnosticLevel.debug,
      ),
    );
    properties.add(
      DiagnosticsProperty<ElevatedButtonThemeData>(
        'elevatedButtonTheme',
        elevatedButtonTheme,
        defaultValue: defaultData.elevatedButtonTheme,
        level: DiagnosticLevel.debug,
      ),
    );
    properties.add(
      DiagnosticsProperty<ExpansionTileThemeData>(
        'expansionTileTheme',
        expansionTileTheme,
        level: DiagnosticLevel.debug,
      ),
    );
    properties.add(
      DiagnosticsProperty<FilledButtonThemeData>(
        'filledButtonTheme',
        filledButtonTheme,
        defaultValue: defaultData.filledButtonTheme,
        level: DiagnosticLevel.debug,
      ),
    );
    properties.add(
      DiagnosticsProperty<FloatingActionButtonThemeData>(
        'floatingActionButtonTheme',
        floatingActionButtonTheme,
        defaultValue: defaultData.floatingActionButtonTheme,
        level: DiagnosticLevel.debug,
      ),
    );
    properties.add(
      DiagnosticsProperty<IconButtonThemeData>(
        'iconButtonTheme',
        iconButtonTheme,
        defaultValue: defaultData.iconButtonTheme,
        level: DiagnosticLevel.debug,
      ),
    );
    properties.add(
      DiagnosticsProperty<ListTileThemeData>(
        'listTileTheme',
        listTileTheme,
        defaultValue: defaultData.listTileTheme,
        level: DiagnosticLevel.debug,
      ),
    );
    properties.add(
      DiagnosticsProperty<MenuBarThemeData>(
        'menuBarTheme',
        menuBarTheme,
        defaultValue: defaultData.menuBarTheme,
        level: DiagnosticLevel.debug,
      ),
    );
    properties.add(
      DiagnosticsProperty<MenuButtonThemeData>(
        'menuButtonTheme',
        menuButtonTheme,
        defaultValue: defaultData.menuButtonTheme,
        level: DiagnosticLevel.debug,
      ),
    );
    properties.add(
      DiagnosticsProperty<MenuThemeData>(
        'menuTheme',
        menuTheme,
        defaultValue: defaultData.menuTheme,
        level: DiagnosticLevel.debug,
      ),
    );
    properties.add(
      DiagnosticsProperty<NavigationBarThemeData>(
        'navigationBarTheme',
        navigationBarTheme,
        defaultValue: defaultData.navigationBarTheme,
        level: DiagnosticLevel.debug,
      ),
    );
    properties.add(
      DiagnosticsProperty<NavigationDrawerThemeData>(
        'navigationDrawerTheme',
        navigationDrawerTheme,
        defaultValue: defaultData.navigationDrawerTheme,
        level: DiagnosticLevel.debug,
      ),
    );
    properties.add(
      DiagnosticsProperty<NavigationRailThemeData>(
        'navigationRailTheme',
        navigationRailTheme,
        defaultValue: defaultData.navigationRailTheme,
        level: DiagnosticLevel.debug,
      ),
    );
    properties.add(
      DiagnosticsProperty<OutlinedButtonThemeData>(
        'outlinedButtonTheme',
        outlinedButtonTheme,
        defaultValue: defaultData.outlinedButtonTheme,
        level: DiagnosticLevel.debug,
      ),
    );
    properties.add(
      DiagnosticsProperty<PopupMenuThemeData>(
        'popupMenuTheme',
        popupMenuTheme,
        defaultValue: defaultData.popupMenuTheme,
        level: DiagnosticLevel.debug,
      ),
    );
    properties.add(
      DiagnosticsProperty<ProgressIndicatorThemeData>(
        'progressIndicatorTheme',
        progressIndicatorTheme,
        defaultValue: defaultData.progressIndicatorTheme,
        level: DiagnosticLevel.debug,
      ),
    );
    properties.add(
      DiagnosticsProperty<RadioThemeData>(
        'radioTheme',
        radioTheme,
        defaultValue: defaultData.radioTheme,
        level: DiagnosticLevel.debug,
      ),
    );
    properties.add(
      DiagnosticsProperty<SearchBarThemeData>(
        'searchBarTheme',
        searchBarTheme,
        defaultValue: defaultData.searchBarTheme,
        level: DiagnosticLevel.debug,
      ),
    );
    properties.add(
      DiagnosticsProperty<SearchViewThemeData>(
        'searchViewTheme',
        searchViewTheme,
        defaultValue: defaultData.searchViewTheme,
        level: DiagnosticLevel.debug,
      ),
    );
    properties.add(
      DiagnosticsProperty<SegmentedButtonThemeData>(
        'segmentedButtonTheme',
        segmentedButtonTheme,
        defaultValue: defaultData.segmentedButtonTheme,
        level: DiagnosticLevel.debug,
      ),
    );
    properties.add(
      DiagnosticsProperty<SliderThemeData>(
        'sliderTheme',
        sliderTheme,
        level: DiagnosticLevel.debug,
      ),
    );
    properties.add(
      DiagnosticsProperty<SnackBarThemeData>(
        'snackBarTheme',
        snackBarTheme,
        defaultValue: defaultData.snackBarTheme,
        level: DiagnosticLevel.debug,
      ),
    );
    properties.add(
      DiagnosticsProperty<SwitchThemeData>(
        'switchTheme',
        switchTheme,
        defaultValue: defaultData.switchTheme,
        level: DiagnosticLevel.debug,
      ),
    );
    properties.add(
      DiagnosticsProperty<TabBarThemeData>(
        'tabBarTheme',
        tabBarTheme,
        level: DiagnosticLevel.debug,
      ),
    );
    properties.add(
      DiagnosticsProperty<TextButtonThemeData>(
        'textButtonTheme',
        textButtonTheme,
        defaultValue: defaultData.textButtonTheme,
        level: DiagnosticLevel.debug,
      ),
    );
    properties.add(
      DiagnosticsProperty<TextSelectionThemeData>(
        'textSelectionTheme',
        textSelectionTheme,
        defaultValue: defaultData.textSelectionTheme,
        level: DiagnosticLevel.debug,
      ),
    );
    properties.add(
      DiagnosticsProperty<TimePickerThemeData>(
        'timePickerTheme',
        timePickerTheme,
        defaultValue: defaultData.timePickerTheme,
        level: DiagnosticLevel.debug,
      ),
    );
    properties.add(
      DiagnosticsProperty<ToggleButtonsThemeData>(
        'toggleButtonsTheme',
        toggleButtonsTheme,
        level: DiagnosticLevel.debug,
      ),
    );
    properties.add(
      DiagnosticsProperty<TooltipThemeData>(
        'tooltipTheme',
        tooltipTheme,
        level: DiagnosticLevel.debug,
      ),
    );
    // DEPRECATED (newest deprecations at the bottom)
    properties.add(
      DiagnosticsProperty<ButtonBarThemeData>(
        'buttonBarTheme',
        buttonBarTheme,
        defaultValue: defaultData.buttonBarTheme,
        level: DiagnosticLevel.debug,
      ),
    );
    properties.add(
      ColorProperty(
        'dialogBackgroundColor',
        dialogBackgroundColor,
        defaultValue: defaultData.dialogBackgroundColor,
        level: DiagnosticLevel.debug,
      ),
    );
  }
}

/// A [CupertinoThemeData] that defers unspecified theme attributes to an
/// upstream Material [ThemeData].
///
/// This type of [CupertinoThemeData] is used by the Material [Theme] to
/// harmonize the [CupertinoTheme] with the material theme's colors and text
/// styles.
///
/// In the most basic case, [ThemeData]'s `cupertinoOverrideTheme` is null and
/// descendant Cupertino widgets' styling is derived from the Material theme.
///
/// To override individual parts of the Material-derived Cupertino styling,
/// `cupertinoOverrideTheme`'s construction parameters can be used.
///
/// To completely decouple the Cupertino styling from Material theme derivation,
/// another [CupertinoTheme] widget can be inserted as a descendant of the
/// Material [Theme]. On a [MaterialApp], this can be done using the `builder`
/// parameter on the constructor.
///
/// See also:
///
///  * [CupertinoThemeData], whose null constructor parameters default to
///    reasonable iOS styling defaults rather than harmonizing with a Material
///    theme.
///  * [Theme], widget which inserts a [CupertinoTheme] with this
///    [MaterialBasedCupertinoThemeData].
// This class subclasses CupertinoThemeData rather than composes one because it
// _is_ a CupertinoThemeData with partially altered behavior. e.g. its textTheme
// is from the superclass and based on the primaryColor but the primaryColor
// comes from the Material theme unless overridden.
class MaterialBasedCupertinoThemeData extends CupertinoThemeData {
  /// Create a [MaterialBasedCupertinoThemeData] based on a Material [ThemeData]
  /// and its `cupertinoOverrideTheme`.
  MaterialBasedCupertinoThemeData({required ThemeData materialTheme})
    : this._(
        materialTheme,
        (materialTheme.cupertinoOverrideTheme ?? const CupertinoThemeData()).noDefault(),
      );

  MaterialBasedCupertinoThemeData._(this._materialTheme, this._cupertinoOverrideTheme)
    : // Pass all values to the superclass so Material-agnostic properties
      // like barBackgroundColor can still behave like a normal
      // CupertinoThemeData.
      super.raw(
        _cupertinoOverrideTheme.brightness,
        _cupertinoOverrideTheme.primaryColor,
        _cupertinoOverrideTheme.primaryContrastingColor,
        _cupertinoOverrideTheme.textTheme,
        _cupertinoOverrideTheme.barBackgroundColor,
        _cupertinoOverrideTheme.scaffoldBackgroundColor,
        _cupertinoOverrideTheme.applyThemeToAll,
      );

  final ThemeData _materialTheme;
  final NoDefaultCupertinoThemeData _cupertinoOverrideTheme;

  @override
  Brightness get brightness => _cupertinoOverrideTheme.brightness ?? _materialTheme.brightness;

  @override
  Color get primaryColor =>
      _cupertinoOverrideTheme.primaryColor ?? _materialTheme.colorScheme.primary;

  @override
  Color get primaryContrastingColor =>
      _cupertinoOverrideTheme.primaryContrastingColor ?? _materialTheme.colorScheme.onPrimary;

  @override
  Color get scaffoldBackgroundColor =>
      _cupertinoOverrideTheme.scaffoldBackgroundColor ?? _materialTheme.scaffoldBackgroundColor;

  /// Copies the [ThemeData]'s `cupertinoOverrideTheme`.
  ///
  /// Only the specified override attributes of the [ThemeData]'s
  /// `cupertinoOverrideTheme` and the newly specified parameters are in the
  /// returned [CupertinoThemeData]. No derived attributes from iOS defaults or
  /// from cascaded Material theme attributes are copied.
  ///
  /// This [copyWith] cannot change the base Material [ThemeData]. To change the
  /// base Material [ThemeData], create a new Material [Theme] and use
  /// [ThemeData.copyWith] on the Material [ThemeData] instead.
  @override
  MaterialBasedCupertinoThemeData copyWith({
    Brightness? brightness,
    Color? primaryColor,
    Color? primaryContrastingColor,
    CupertinoTextThemeData? textTheme,
    Color? barBackgroundColor,
    Color? scaffoldBackgroundColor,
    bool? applyThemeToAll,
  }) {
    return MaterialBasedCupertinoThemeData._(
      _materialTheme,
      _cupertinoOverrideTheme.copyWith(
        brightness: brightness,
        primaryColor: primaryColor,
        primaryContrastingColor: primaryContrastingColor,
        textTheme: textTheme,
        barBackgroundColor: barBackgroundColor,
        scaffoldBackgroundColor: scaffoldBackgroundColor,
        applyThemeToAll: applyThemeToAll,
      ),
    );
  }

  @override
  CupertinoThemeData resolveFrom(BuildContext context) {
    // Only the cupertino override theme part will be resolved.
    // If the color comes from the material theme it's not resolved.
    return MaterialBasedCupertinoThemeData._(
      _materialTheme,
      _cupertinoOverrideTheme.resolveFrom(context),
    );
  }
}

/// A class for creating a Material theme with a color scheme based off of the
/// colors from a [CupertinoThemeData]. This is intended to be used only in the
/// case when a Material widget is unable to find a Material theme in the tree,
/// but is able to find a Cupertino theme. Most often this will occur when a
/// Material widget is used inside of a [CupertinoApp].
///
/// Besides the colors, this theme will use all the defaults from Material's
/// [ThemeData], so if further customization is needed, it is best to manually
/// add a Material [Theme] above the [CupertinoApp].
class CupertinoBasedMaterialThemeData {
  /// Creates a Material theme with a color scheme based off of the colors from
  /// a [CupertinoThemeData].
  CupertinoBasedMaterialThemeData({required CupertinoThemeData themeData})
    : materialTheme = ThemeData(
        colorScheme: ColorScheme.fromSeed(
          seedColor: themeData.primaryColor,
          brightness: themeData.brightness ?? Brightness.light,
          primary: themeData.primaryColor,
          onPrimary: themeData.primaryContrastingColor,
        ),
      );

  /// The Material theme data with colors based on an existing [CupertinoThemeData].
  final ThemeData materialTheme;
}

@immutable
class _IdentityThemeDataCacheKey {
  const _IdentityThemeDataCacheKey(this.baseTheme, this.localTextGeometry);

  final ThemeData baseTheme;
  final TextTheme localTextGeometry;

  // Using XOR to make the hash function as fast as possible (e.g. Jenkins is
  // noticeably slower).
  @override
  int get hashCode => identityHashCode(baseTheme) ^ identityHashCode(localTextGeometry);

  @override
  bool operator ==(Object other) {
    // We are explicitly ignoring the possibility that the types might not
    // match in the interests of speed.
    return other is _IdentityThemeDataCacheKey &&
        identical(other.baseTheme, baseTheme) &&
        identical(other.localTextGeometry, localTextGeometry);
  }
}

/// Cache of objects of limited size that uses the first in first out eviction
/// strategy (a.k.a least recently inserted).
///
/// The key that was inserted before all other keys is evicted first, i.e. the
/// one inserted least recently.
class _FifoCache<K, V> {
  _FifoCache(this._maximumSize) : assert(_maximumSize > 0);

  /// In Dart the map literal uses a linked hash-map implementation, whose keys
  /// are stored such that [Map.keys] returns them in the order they were
  /// inserted.
  final Map<K, V> _cache = <K, V>{};

  /// Maximum number of entries to store in the cache.
  ///
  /// Once this many entries have been cached, the entry inserted least recently
  /// is evicted when adding a new entry.
  final int _maximumSize;

  /// Returns the previously cached value for the given key, if available;
  /// if not, calls the given callback to obtain it first.
  V putIfAbsent(K key, V Function() loader) {
    assert(key != null);
    final V? result = _cache[key];
    if (result != null) {
      return result;
    }
    if (_cache.length == _maximumSize) {
      _cache.remove(_cache.keys.first);
    }
    return _cache[key] = loader();
  }
}

/// Defines the visual density of user interface components.
///
/// Density, in the context of a UI, is the vertical and horizontal
/// "compactness" of the components in the UI. It is unitless, since it means
/// different things to different UI components.
///
/// The default for visual densities is zero for both vertical and horizontal
/// densities, which corresponds to the default visual density of components in
/// the Material Design specification. It does not affect text sizes, icon
/// sizes, or padding values.
///
/// For example, for buttons, it affects the spacing around the child of the
/// button. For lists, it affects the distance between baselines of entries in
/// the list. For chips, it only affects the vertical size, not the horizontal
/// size.
///
/// Here are some examples of widgets that respond to density changes:
///
///  * [Checkbox]
///  * [Chip]
///  * [ElevatedButton]
///  * [IconButton]
///  * [InputDecorator] (which gives density support to [TextField], etc.)
///  * [ListTile]
///  * [MaterialButton]
///  * [OutlinedButton]
///  * [Radio]
///  * [RawMaterialButton]
///  * [TextButton]
///
/// See also:
///
///  * [ThemeData.visualDensity], where this property is used to specify the base
///    horizontal density of Material components.
///  * [Material design guidance on density](https://material.io/design/layout/applying-density.html).
@immutable
class VisualDensity with Diagnosticable {
  /// A const constructor for [VisualDensity].
  ///
  /// The [horizontal] and [vertical] arguments must be in the interval between
  /// [minimumDensity] and [maximumDensity], inclusive.
  const VisualDensity({this.horizontal = 0.0, this.vertical = 0.0})
    : assert(vertical <= maximumDensity),
      assert(vertical >= minimumDensity),
      assert(horizontal <= maximumDensity),
      assert(horizontal >= minimumDensity);

  /// The minimum allowed density.
  static const double minimumDensity = -4.0;

  /// The maximum allowed density.
  static const double maximumDensity = 4.0;

  /// The default profile for [VisualDensity] in [ThemeData].
  ///
  /// This default value represents a visual density that is less dense than
  /// either [comfortable] or [compact], and corresponds to density values of
  /// zero in both axes.
  static const VisualDensity standard = VisualDensity();

  /// The profile for a "comfortable" interpretation of [VisualDensity].
  ///
  /// Individual components will interpret the density value independently,
  /// making themselves more visually dense than [standard] and less dense than
  /// [compact] to different degrees based on the Material Design specification
  /// of the "comfortable" setting for their particular use case.
  ///
  /// It corresponds to a density value of -1 in both axes.
  static const VisualDensity comfortable = VisualDensity(horizontal: -1.0, vertical: -1.0);

  /// The profile for a "compact" interpretation of [VisualDensity].
  ///
  /// Individual components will interpret the density value independently,
  /// making themselves more visually dense than [standard] and [comfortable] to
  /// different degrees based on the Material Design specification of the
  /// "comfortable" setting for their particular use case.
  ///
  /// It corresponds to a density value of -2 in both axes.
  static const VisualDensity compact = VisualDensity(horizontal: -2.0, vertical: -2.0);

  /// Returns a [VisualDensity] that is adaptive based on the current platform
  /// on which the framework is executing, from [defaultTargetPlatform].
  ///
  /// When [defaultTargetPlatform] is a desktop platform, this returns
  /// [compact], and for other platforms, it returns a default-constructed
  /// [VisualDensity].
  ///
  /// See also:
  ///
  /// * [defaultDensityForPlatform] which returns a [VisualDensity] that is
  ///   adaptive based on the platform given to it.
  /// * [defaultTargetPlatform] which returns the platform on which the
  ///   framework is currently executing.
  static VisualDensity get adaptivePlatformDensity =>
      defaultDensityForPlatform(defaultTargetPlatform);

  /// Returns a [VisualDensity] that is adaptive based on the given [platform].
  ///
  /// For desktop platforms, this returns [compact], and for other platforms, it
  /// returns a default-constructed [VisualDensity].
  ///
  /// See also:
  ///
  /// * [adaptivePlatformDensity] which returns a [VisualDensity] that is
  ///   adaptive based on [defaultTargetPlatform].
  static VisualDensity defaultDensityForPlatform(TargetPlatform platform) {
    return switch (platform) {
      TargetPlatform.android || TargetPlatform.iOS || TargetPlatform.fuchsia => standard,
      TargetPlatform.linux || TargetPlatform.macOS || TargetPlatform.windows => compact,
    };
  }

  /// Copy the current [VisualDensity] with the given values replacing the
  /// current values.
  VisualDensity copyWith({double? horizontal, double? vertical}) {
    return VisualDensity(
      horizontal: horizontal ?? this.horizontal,
      vertical: vertical ?? this.vertical,
    );
  }

  /// The horizontal visual density of UI components.
  ///
  /// This property affects only the horizontal spacing between and within
  /// components, to allow for different UI visual densities. It does not affect
  /// text sizes, icon sizes, or padding values. The default value is 0.0,
  /// corresponding to the metrics specified in the Material Design
  /// specification. The value can range from [minimumDensity] to
  /// [maximumDensity], inclusive.
  ///
  /// See also:
  ///
  ///  * [ThemeData.visualDensity], where this property is used to specify the base
  ///    horizontal density of Material components.
  ///  * [Material design guidance on density](https://material.io/design/layout/applying-density.html).
  final double horizontal;

  /// The vertical visual density of UI components.
  ///
  /// This property affects only the vertical spacing between and within
  /// components, to allow for different UI visual densities. It does not affect
  /// text sizes, icon sizes, or padding values. The default value is 0.0,
  /// corresponding to the metrics specified in the Material Design
  /// specification. The value can range from [minimumDensity] to
  /// [maximumDensity], inclusive.
  ///
  /// See also:
  ///
  ///  * [ThemeData.visualDensity], where this property is used to specify the base
  ///    vertical density of Material components.
  ///  * [Material design guidance on density](https://material.io/design/layout/applying-density.html).
  final double vertical;

  /// The base adjustment in logical pixels of the visual density of UI components.
  ///
  /// The input density values are multiplied by a constant to arrive at a base
  /// size adjustment that fits Material Design guidelines.
  ///
  /// Individual components may adjust this value based upon their own
  /// individual interpretation of density.
  Offset get baseSizeAdjustment {
    // The number of logical pixels represented by an increase or decrease in
    // density by one. The Material Design guidelines say to increment/decrement
    // sizes in terms of four pixel increments.
    const double interval = 4.0;

    return Offset(horizontal, vertical) * interval;
  }

  /// Linearly interpolate between two densities.
  static VisualDensity lerp(VisualDensity a, VisualDensity b, double t) {
    if (identical(a, b)) {
      return a;
    }
    return VisualDensity(
      horizontal: lerpDouble(a.horizontal, b.horizontal, t)!,
      vertical: lerpDouble(a.vertical, b.vertical, t)!,
    );
  }

  /// Return a copy of [constraints] whose minimum width and height have been
  /// updated with the [baseSizeAdjustment].
  ///
  /// The resulting minWidth and minHeight values are clamped to not exceed the
  /// maxWidth and maxHeight values, respectively.
  BoxConstraints effectiveConstraints(BoxConstraints constraints) {
    assert(constraints.debugAssertIsValid());
    return constraints.copyWith(
      minWidth: clampDouble(
        constraints.minWidth + baseSizeAdjustment.dx,
        0.0,
        constraints.maxWidth,
      ),
      minHeight: clampDouble(
        constraints.minHeight + baseSizeAdjustment.dy,
        0.0,
        constraints.maxHeight,
      ),
    );
  }

  @override
  bool operator ==(Object other) {
    if (other.runtimeType != runtimeType) {
      return false;
    }
    return other is VisualDensity && other.horizontal == horizontal && other.vertical == vertical;
  }

  @override
  int get hashCode => Object.hash(horizontal, vertical);

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties.add(DoubleProperty('horizontal', horizontal, defaultValue: 0.0));
    properties.add(DoubleProperty('vertical', vertical, defaultValue: 0.0));
  }

  @override
  String toStringShort() {
    return '${super.toStringShort()}(h: ${debugFormatDouble(horizontal)}, v: ${debugFormatDouble(vertical)})';
  }
}

// BEGIN GENERATED TOKEN PROPERTIES - ColorScheme

// Do not edit by hand. The code between the "BEGIN GENERATED" and
// "END GENERATED" comments are generated from data in the Material
// Design token database by the script:
//   dev/tools/gen_defaults/bin/gen_defaults.dart.

// dart format off
const ColorScheme _colorSchemeLightM3 = ColorScheme(
  brightness: Brightness.light,
  primary: Color(0xFF6750A4),
  onPrimary: Color(0xFFFFFFFF),
  primaryContainer: Color(0xFFEADDFF),
  onPrimaryContainer: Color(0xFF4F378B),
  primaryFixed: Color(0xFFEADDFF),
  primaryFixedDim: Color(0xFFD0BCFF),
  onPrimaryFixed: Color(0xFF21005D),
  onPrimaryFixedVariant: Color(0xFF4F378B),
  secondary: Color(0xFF625B71),
  onSecondary: Color(0xFFFFFFFF),
  secondaryContainer: Color(0xFFE8DEF8),
  onSecondaryContainer: Color(0xFF4A4458),
  secondaryFixed: Color(0xFFE8DEF8),
  secondaryFixedDim: Color(0xFFCCC2DC),
  onSecondaryFixed: Color(0xFF1D192B),
  onSecondaryFixedVariant: Color(0xFF4A4458),
  tertiary: Color(0xFF7D5260),
  onTertiary: Color(0xFFFFFFFF),
  tertiaryContainer: Color(0xFFFFD8E4),
  onTertiaryContainer: Color(0xFF633B48),
  tertiaryFixed: Color(0xFFFFD8E4),
  tertiaryFixedDim: Color(0xFFEFB8C8),
  onTertiaryFixed: Color(0xFF31111D),
  onTertiaryFixedVariant: Color(0xFF633B48),
  error: Color(0xFFB3261E),
  onError: Color(0xFFFFFFFF),
  errorContainer: Color(0xFFF9DEDC),
  onErrorContainer: Color(0xFF8C1D18),
  background: Color(0xFFFEF7FF),
  onBackground: Color(0xFF1D1B20),
  surface: Color(0xFFFEF7FF),
  surfaceBright: Color(0xFFFEF7FF),
  surfaceContainerLowest: Color(0xFFFFFFFF),
  surfaceContainerLow: Color(0xFFF7F2FA),
  surfaceContainer: Color(0xFFF3EDF7),
  surfaceContainerHigh: Color(0xFFECE6F0),
  surfaceContainerHighest: Color(0xFFE6E0E9),
  surfaceDim: Color(0xFFDED8E1),
  onSurface: Color(0xFF1D1B20),
  surfaceVariant: Color(0xFFE7E0EC),
  onSurfaceVariant: Color(0xFF49454F),
  outline: Color(0xFF79747E),
  outlineVariant: Color(0xFFCAC4D0),
  shadow: Color(0xFF000000),
  scrim: Color(0xFF000000),
  inverseSurface: Color(0xFF322F35),
  onInverseSurface: Color(0xFFF5EFF7),
  inversePrimary: Color(0xFFD0BCFF),
  // The surfaceTint color is set to the same color as the primary.
  surfaceTint: Color(0xFF6750A4),
);

const ColorScheme _colorSchemeDarkM3 = ColorScheme(
  brightness: Brightness.dark,
  primary: Color(0xFFD0BCFF),
  onPrimary: Color(0xFF381E72),
  primaryContainer: Color(0xFF4F378B),
  onPrimaryContainer: Color(0xFFEADDFF),
  primaryFixed: Color(0xFFEADDFF),
  primaryFixedDim: Color(0xFFD0BCFF),
  onPrimaryFixed: Color(0xFF21005D),
  onPrimaryFixedVariant: Color(0xFF4F378B),
  secondary: Color(0xFFCCC2DC),
  onSecondary: Color(0xFF332D41),
  secondaryContainer: Color(0xFF4A4458),
  onSecondaryContainer: Color(0xFFE8DEF8),
  secondaryFixed: Color(0xFFE8DEF8),
  secondaryFixedDim: Color(0xFFCCC2DC),
  onSecondaryFixed: Color(0xFF1D192B),
  onSecondaryFixedVariant: Color(0xFF4A4458),
  tertiary: Color(0xFFEFB8C8),
  onTertiary: Color(0xFF492532),
  tertiaryContainer: Color(0xFF633B48),
  onTertiaryContainer: Color(0xFFFFD8E4),
  tertiaryFixed: Color(0xFFFFD8E4),
  tertiaryFixedDim: Color(0xFFEFB8C8),
  onTertiaryFixed: Color(0xFF31111D),
  onTertiaryFixedVariant: Color(0xFF633B48),
  error: Color(0xFFF2B8B5),
  onError: Color(0xFF601410),
  errorContainer: Color(0xFF8C1D18),
  onErrorContainer: Color(0xFFF9DEDC),
  background: Color(0xFF141218),
  onBackground: Color(0xFFE6E0E9),
  surface: Color(0xFF141218),
  surfaceBright: Color(0xFF3B383E),
  surfaceContainerLowest: Color(0xFF0F0D13),
  surfaceContainerLow: Color(0xFF1D1B20),
  surfaceContainer: Color(0xFF211F26),
  surfaceContainerHigh: Color(0xFF2B2930),
  surfaceContainerHighest: Color(0xFF36343B),
  surfaceDim: Color(0xFF141218),
  onSurface: Color(0xFFE6E0E9),
  surfaceVariant: Color(0xFF49454F),
  onSurfaceVariant: Color(0xFFCAC4D0),
  outline: Color(0xFF938F99),
  outlineVariant: Color(0xFF49454F),
  shadow: Color(0xFF000000),
  scrim: Color(0xFF000000),
  inverseSurface: Color(0xFFE6E0E9),
  onInverseSurface: Color(0xFF322F35),
  inversePrimary: Color(0xFF6750A4),
  // The surfaceTint color is set to the same color as the primary.
  surfaceTint: Color(0xFFD0BCFF),
);
// dart format on

// END GENERATED TOKEN PROPERTIES - ColorScheme
\n\n--- File: 2 # packages/flutter/lib/src/material/theme.dart ---\n// Copyright 2014 The Flutter Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

/// @docImport 'app.dart';
/// @docImport 'color_scheme.dart';
/// @docImport 'text_theme.dart';
library;

import 'package:flutter/cupertino.dart';
import 'package:flutter/foundation.dart';

import 'material_localizations.dart';
import 'theme_data.dart';
import 'typography.dart';

export 'theme_data.dart' show Brightness, ThemeData;

/// The duration over which theme changes animate by default.
const Duration kThemeAnimationDuration = Duration(milliseconds: 200);

/// Applies a theme to descendant widgets.
///
/// A theme describes the colors and typographic choices of an application.
///
/// {@youtube 560 315 https://www.youtube.com/watch?v=oTvQDJOBXmM}
///
/// Descendant widgets obtain the current theme's [ThemeData] object using
/// [Theme.of]. When a widget uses [Theme.of], it is automatically rebuilt if
/// the theme later changes, so that the changes can be applied.
///
/// The [Theme] widget implies an [IconTheme] widget, set to the value of the
/// [ThemeData.iconTheme] of the [data] for the [Theme].
///
/// See also:
///
///  * [ThemeData], which describes the actual configuration of a theme.
///  * [AnimatedTheme], which animates the [ThemeData] when it changes rather
///    than changing the theme all at once.
///  * [MaterialApp], which includes an [AnimatedTheme] widget configured via
///    the [MaterialApp.theme] argument.
class Theme extends StatelessWidget {
  /// Applies the given theme [data] to [child].
  const Theme({super.key, required this.data, required this.child});

  /// Specifies the color and typography values for descendant widgets.
  final ThemeData data;

  /// The widget below this widget in the tree.
  ///
  /// {@macro flutter.widgets.ProxyWidget.child}
  final Widget child;

  static final ThemeData _kFallbackTheme = ThemeData.fallback();

  /// The data from the closest [Theme] instance that encloses the given
  /// context.
  ///
  /// If the given context is enclosed in a [Localizations] widget providing
  /// [MaterialLocalizations], the returned data is localized according to the
  /// nearest available [MaterialLocalizations].
  ///
  /// Defaults to [ThemeData.fallback] if there is no [Theme] in the given
  /// build context.
  ///
  /// Typical usage is as follows:
  ///
  /// ```dart
  /// @override
  /// Widget build(BuildContext context) {
  ///   return Text(
  ///     'Example',
  ///     style: Theme.of(context).textTheme.titleLarge,
  ///   );
  /// }
  /// ```
  ///
  /// When the [Theme] is actually created in the same `build` function
  /// (possibly indirectly, e.g. as part of a [MaterialApp]), the `context`
  /// argument to the `build` function can't be used to find the [Theme] (since
  /// it's "above" the widget being returned). In such cases, the following
  /// technique with a [Builder] can be used to provide a new scope with a
  /// [BuildContext] that is "under" the [Theme]:
  ///
  /// ```dart
  /// @override
  /// Widget build(BuildContext context) {
  ///   return MaterialApp(
  ///     theme: ThemeData.light(),
  ///     home: Builder(
  ///       // Create an inner BuildContext so that we can refer to
  ///       // the Theme with Theme.of().
  ///       builder: (BuildContext context) {
  ///         return Center(
  ///           child: Text(
  ///             'Example',
  ///             style: Theme.of(context).textTheme.titleLarge,
  ///           ),
  ///         );
  ///       },
  ///     ),
  ///   );
  /// }
  /// ```
  ///
  /// See also:
  ///
  /// * [ColorScheme.of], a convenience method that returns [ThemeData.colorScheme]
  ///   from the closest [Theme] ancestor. (equivalent to `Theme.of(context).colorScheme`).
  /// * [TextTheme.of], a convenience method that returns [ThemeData.textTheme]
  ///   from the closest [Theme] ancestor. (equivalent to `Theme.of(context).textTheme`).
  /// * [IconTheme.of], that returns [ThemeData.iconTheme] from the closest [Theme] or
  ///   [IconThemeData.fallback] if there is no [IconTheme] ancestor.
  static ThemeData of(BuildContext context) {
    final _InheritedTheme? inheritedTheme =
        context.dependOnInheritedWidgetOfExactType<_InheritedTheme>();
    final MaterialLocalizations? localizations = Localizations.of<MaterialLocalizations>(
      context,
      MaterialLocalizations,
    );
    final ScriptCategory category = localizations?.scriptCategory ?? ScriptCategory.englishLike;
    final InheritedCupertinoTheme? inheritedCupertinoTheme =
        context.dependOnInheritedWidgetOfExactType<InheritedCupertinoTheme>();
    final ThemeData theme =
        inheritedTheme?.theme.data ??
        (inheritedCupertinoTheme != null
            ? CupertinoBasedMaterialThemeData(
              themeData: inheritedCupertinoTheme.theme.data,
            ).materialTheme
            : _kFallbackTheme);
    return ThemeData.localize(theme, theme.typography.geometryThemeFor(category));
  }

  // The inherited themes in widgets library can not infer their values from
  // Theme in material library. Wraps the child with these inherited themes to
  // overrides their values directly.
  Widget _wrapsWidgetThemes(BuildContext context, Widget child) {
    final DefaultSelectionStyle selectionStyle = DefaultSelectionStyle.of(context);
    return IconTheme(
      data: data.iconTheme,
      child: DefaultSelectionStyle(
        selectionColor: data.textSelectionTheme.selectionColor ?? selectionStyle.selectionColor,
        cursorColor: data.textSelectionTheme.cursorColor ?? selectionStyle.cursorColor,
        child: child,
      ),
    );
  }

  CupertinoThemeData _inheritedCupertinoThemeData(BuildContext context) {
    final InheritedCupertinoTheme? inheritedTheme =
        context.dependOnInheritedWidgetOfExactType<InheritedCupertinoTheme>();
    return (inheritedTheme?.theme.data ?? MaterialBasedCupertinoThemeData(materialTheme: data))
        .resolveFrom(context);
  }

  @override
  Widget build(BuildContext context) {
    return _InheritedTheme(
      theme: this,
      child: CupertinoTheme(
        // If a CupertinoThemeData doesn't exist, we're using a
        // MaterialBasedCupertinoThemeData here instead of a CupertinoThemeData
        // because it defers some properties to the Material ThemeData.
        data: _inheritedCupertinoThemeData(context),
        child: _wrapsWidgetThemes(context, child),
      ),
    );
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties.add(DiagnosticsProperty<ThemeData>('data', data, showName: false));
  }
}

class _InheritedTheme extends InheritedTheme {
  const _InheritedTheme({required this.theme, required super.child});

  final Theme theme;

  @override
  Widget wrap(BuildContext context, Widget child) {
    return Theme(data: theme.data, child: child);
  }

  @override
  bool updateShouldNotify(_InheritedTheme old) => theme.data != old.theme.data;
}

/// An interpolation between two [ThemeData]s.
///
/// This class specializes the interpolation of [Tween<ThemeData>] to call the
/// [ThemeData.lerp] method.
///
/// See [Tween] for a discussion on how to use interpolation objects.
class ThemeDataTween extends Tween<ThemeData> {
  /// Creates a [ThemeData] tween.
  ///
  /// The [begin] and [end] properties must be non-null before the tween is
  /// first used, but the arguments can be null if the values are going to be
  /// filled in later.
  ThemeDataTween({super.begin, super.end});

  @override
  ThemeData lerp(double t) => ThemeData.lerp(begin!, end!, t);
}

/// Animated version of [Theme] which automatically transitions the colors,
/// etc, over a given duration whenever the given theme changes.
///
/// Here's an illustration of what using this widget looks like, using a [curve]
/// of [Curves.elasticInOut].
/// {@animation 250 266 https://flutter.github.io/assets-for-api-docs/assets/widgets/animated_theme.mp4}
///
/// See also:
///
///  * [Theme], which [AnimatedTheme] uses to actually apply the interpolated
///    theme.
///  * [ThemeData], which describes the actual configuration of a theme.
///  * [MaterialApp], which includes an [AnimatedTheme] widget configured via
///    the [MaterialApp.theme] argument.
class AnimatedTheme extends ImplicitlyAnimatedWidget {
  /// Creates an animated theme.
  ///
  /// By default, the theme transition uses a linear curve.
  const AnimatedTheme({
    super.key,
    required this.data,
    super.curve,
    super.duration = kThemeAnimationDuration,
    super.onEnd,
    required this.child,
  });

  /// Specifies the color and typography values for descendant widgets.
  final ThemeData data;

  /// The widget below this widget in the tree.
  ///
  /// {@macro flutter.widgets.ProxyWidget.child}
  final Widget child;

  @override
  AnimatedWidgetBaseState<AnimatedTheme> createState() => _AnimatedThemeState();
}

class _AnimatedThemeState extends AnimatedWidgetBaseState<AnimatedTheme> {
  ThemeDataTween? _data;

  @override
  void forEachTween(TweenVisitor<dynamic> visitor) {
    _data =
        visitor(_data, widget.data, (dynamic value) => ThemeDataTween(begin: value as ThemeData))!
            as ThemeDataTween;
  }

  @override
  Widget build(BuildContext context) {
    return Theme(data: _data!.evaluate(animation), child: widget.child);
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder description) {
    super.debugFillProperties(description);
    description.add(
      DiagnosticsProperty<ThemeDataTween>('data', _data, showName: false, defaultValue: null),
    );
  }
}


Please provide:
1. A high-level `summary` of the project's main purpose and functionality in a few beginner-friendly sentences. Use markdown formatting with **bold** and *italic* text to highlight important concepts.
2. A list (`relationships`) describing the key interactions between these abstractions. For each relationship, specify:
    - `from_abstraction`: Index of the source abstraction (e.g., `0 # AbstractionName1`)
    - `to_abstraction`: Index of the target abstraction (e.g., `1 # AbstractionName2`)
    - `label`: A brief label for the interaction **in just a few words** (e.g., "Manages", "Inherits", "Uses").
    Ideally the relationship should be backed by one abstraction calling or passing parameters to another.
    Simplify the relationship and exclude those non-important ones.

IMPORTANT: Make sure EVERY abstraction is involved in at least ONE relationship (either as source or target). Each abstraction index must appear at least once across all relationships.

Format the output as YAML:

```yaml
summary: |
  A brief, simple explanation of the project.
  Can span multiple lines with **bold** and *italic* for emphasis.
relationships:
  - from_abstraction: 0 # AbstractionName1
    to_abstraction: 1 # AbstractionName2
    label: "Manages"
  - from_abstraction: 2 # AbstractionName3
    to_abstraction: 0 # AbstractionName1
    label: "Provides config"
  # ... other relationships
```

Now, provide the YAML output:

2025-05-28 18:21:20,170 - INFO - RESPONSE: ```yaml
summary: |
  Flutter's theming system allows you to define the *visual style* of your app using **ThemeData**.
  This master plan, including **ColorScheme** for colors and various component themes, is then applied
  to parts of your UI using the **Theme** widget. You can also customize themes with **ThemeExtension**
  and control element spacing with **VisualDensity** and tap target sizes with **MaterialTapTargetSize**,
  using **DynamicSchemeVariant** for generating color schemes.
relationships:
  - from_abstraction: 0 # ThemeData
    to_abstraction: 1 # ColorScheme
    label: "Includes"
  - from_abstraction: 2 # Theme
    to_abstraction: 0 # ThemeData
    label: "Applies"
  - from_abstraction: 0 # ThemeData
    to_abstraction: 3 # ThemeExtension
    label: "Includes"
  - from_abstraction: 0 # ThemeData
    to_abstraction: 4 # MaterialTapTargetSize
    label: "Includes"
  - from_abstraction: 1 # ColorScheme
    to_abstraction: 5 # DynamicSchemeVariant
    label: "Uses for generation"
  - from_abstraction: 0 # ThemeData
    to_abstraction: 6 # VisualDensity
    label: "Includes"
```
2025-05-28 18:21:20,178 - INFO - PROMPT: 
Given the following project abstractions and their relationships for the project ```` flutter ````:

Abstractions (Index # Name):
- 0 # ThemeData

- 1 # ColorScheme

- 2 # Theme

- 3 # ThemeExtension

- 4 # MaterialTapTargetSize

- 5 # DynamicSchemeVariant

- 6 # VisualDensity


Context about relationships and project summary:
Project Summary:
Flutter's theming system allows you to define the *visual style* of your app using **ThemeData**.
This master plan, including **ColorScheme** for colors and various component themes, is then applied
to parts of your UI using the **Theme** widget. You can also customize themes with **ThemeExtension**
and control element spacing with **VisualDensity** and tap target sizes with **MaterialTapTargetSize**,
using **DynamicSchemeVariant** for generating color schemes.


Relationships (Indices refer to abstractions above):
- From 0 (ThemeData
) to 1 (ColorScheme
): Includes
- From 2 (Theme
) to 0 (ThemeData
): Applies
- From 0 (ThemeData
) to 3 (ThemeExtension
): Includes
- From 0 (ThemeData
) to 4 (MaterialTapTargetSize
): Includes
- From 1 (ColorScheme
) to 5 (DynamicSchemeVariant
): Uses for generation
- From 0 (ThemeData
) to 6 (VisualDensity
): Includes


If you are going to make a tutorial for ```` flutter ````, what is the best order to explain these abstractions, from first to last?
Ideally, first explain those that are the most important or foundational, perhaps user-facing concepts or entry points. Then move to more detailed, lower-level implementation details or supporting concepts.

Output the ordered list of abstraction indices, including the name in a comment for clarity. Use the format `idx # AbstractionName`.

```yaml
- 2 # FoundationalConcept
- 0 # CoreClassA
- 1 # CoreClassB (uses CoreClassA)
- ...
```

Now, provide the YAML output:

2025-05-28 18:21:21,195 - INFO - RESPONSE: ```yaml
- 2 # Theme
- 0 # ThemeData
- 1 # ColorScheme
- 3 # ThemeExtension
- 6 # VisualDensity
- 4 # MaterialTapTargetSize
- 5 # DynamicSchemeVariant
```
2025-05-28 18:21:21,204 - INFO - PROMPT: 
Write a very beginner-friendly tutorial chapter (in Markdown format) for the project `flutter` about the concept: "Theme
". This is Chapter 1.

Concept Details:
- Name: Theme

- Description:
`Theme` is the widget that takes your `ThemeData` master plan and applies it to a part of your app's user interface. When you wrap a widget tree with a `Theme` widget, all the widgets inside that tree will use the styles defined in the provided `ThemeData`. It's like applying the paint colors you chose from the palette to the actual rooms in your house.


Complete Tutorial Structure:
1. [Theme
](01_theme_.md)
2. [ThemeData
](02_themedata_.md)
3. [ColorScheme
](03_colorscheme_.md)
4. [ThemeExtension
](04_themeextension_.md)
5. [VisualDensity
](05_visualdensity_.md)
6. [MaterialTapTargetSize
](06_materialtaptargetsize_.md)
7. [DynamicSchemeVariant
](07_dynamicschemevariant_.md)

Context from previous chapters:
This is the first chapter.

Relevant Code Snippets (Code itself remains unchanged):
--- File: packages/flutter/lib/src/material/theme_data.dart ---
// Copyright 2014 The Flutter Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

/// @docImport 'package:flutter/material.dart';
library;

import 'dart:ui' show Color, lerpDouble;

import 'package:flutter/cupertino.dart';
import 'package:flutter/foundation.dart';

import 'action_buttons.dart';
import 'action_icons_theme.dart';
import 'app_bar_theme.dart';
import 'badge_theme.dart';
import 'banner_theme.dart';
import 'bottom_app_bar_theme.dart';
import 'bottom_navigation_bar_theme.dart';
import 'bottom_sheet_theme.dart';
import 'button_bar_theme.dart';
import 'button_theme.dart';
import 'card_theme.dart';
import 'checkbox_theme.dart';
import 'chip_theme.dart';
import 'color_scheme.dart';
import 'colors.dart';
import 'constants.dart';
import 'data_table_theme.dart';
import 'date_picker_theme.dart';
import 'dialog_theme.dart';
import 'divider_theme.dart';
import 'drawer_theme.dart';
import 'dropdown_menu_theme.dart';
import 'elevated_button_theme.dart';
import 'expansion_tile_theme.dart';
import 'filled_button_theme.dart';
import 'floating_action_button_theme.dart';
import 'icon_button_theme.dart';
import 'ink_ripple.dart';
import 'ink_sparkle.dart';
import 'ink_splash.dart';
import 'ink_well.dart' show InteractiveInkFeatureFactory;
import 'input_decorator.dart';
import 'list_tile.dart';
import 'list_tile_theme.dart';
import 'menu_bar_theme.dart';
import 'menu_button_theme.dart';
import 'menu_theme.dart';
import 'navigation_bar_theme.dart';
import 'navigation_drawer_theme.dart';
import 'navigation_rail_theme.dart';
import 'outlined_button_theme.dart';
import 'page_transitions_theme.dart';
import 'popup_menu_theme.dart';
import 'progress_indicator_theme.dart';
import 'radio_theme.dart';
import 'scrollbar_theme.dart';
import 'search_bar_theme.dart';
import 'search_view_theme.dart';
import 'segmented_button_theme.dart';
import 'slider_theme.dart';
import 'snack_bar_theme.dart';
import 'switch_theme.dart';
import 'tab_bar_theme.dart';
import 'text_button_theme.dart';
import 'text_selection_theme.dart';
import 'text_theme.dart';
import 'time_picker_theme.dart';
import 'toggle_buttons_theme.dart';
import 'tooltip_theme.dart';
import 'typography.dart';

export 'package:flutter/services.dart' show Brightness;

// Examples can assume:
// late BuildContext context;

/// Defines a customized theme for components with an `adaptive` factory constructor.
///
/// Currently, only [Switch.adaptive] supports this class.
class Adaptation<T> {
  /// Creates an [Adaptation].
  const Adaptation();

  /// The adaptation's type.
  Type get type => T;

  /// Typically, this is overridden to return an instance of a custom component
  /// ThemeData class, like [SwitchThemeData], instead of the defaultValue.
  ///
  /// Factory constructors that support adaptations - currently only
  /// [Switch.adaptive] - look for a type-specific adaptation in
  /// [ThemeData.adaptationMap] when computing their effective default component
  /// theme. If a matching adaptation is not found, the component may choose to
  /// use a default adaptation. For example, the [Switch.adaptive] component
  /// uses an empty [SwitchThemeData] if a matching adaptation is not found, for
  /// the sake of backwards compatibility.
  ///
  /// {@tool dartpad}
  /// This sample shows how to create and use subclasses of [Adaptation] that
  /// define adaptive [SwitchThemeData]s. The [adapt] method in this example is
  /// overridden to only customize cupertino-style switches, but it can also be
  /// used to customize any other platforms.
  ///
  /// ** See code in examples/api/lib/material/switch/switch.4.dart **
  /// {@end-tool}
  T adapt(ThemeData theme, T defaultValue) => defaultValue;
}

/// An interface that defines custom additions to a [ThemeData] object.
///
/// {@youtube 560 315 https://www.youtube.com/watch?v=8-szcYzFVao}
///
/// Typically used for custom colors. To use, subclass [ThemeExtension],
/// define a number of fields (e.g. [Color]s), and implement the [copyWith] and
/// [lerp] methods. The latter will ensure smooth transitions of properties when
/// switching themes.
///
/// {@tool dartpad}
/// This sample shows how to create and use a subclass of [ThemeExtension] that
/// defines two colors.
///
/// ** See code in examples/api/lib/material/theme/theme_extension.1.dart **
/// {@end-tool}
abstract class ThemeExtension<T extends ThemeExtension<T>> {
  /// Enable const constructor for subclasses.
  const ThemeExtension();

  /// The extension's type.
  Object get type => T;

  /// Creates a copy of this theme extension with the given fields
  /// replaced by the non-null parameter values.
  ThemeExtension<T> copyWith();

  /// Linearly interpolate with another [ThemeExtension] object.
  ///
  /// {@macro dart.ui.shadow.lerp}
  ThemeExtension<T> lerp(covariant ThemeExtension<T>? other, double t);
}

/// Configures the tap target and layout size of certain Material widgets.
///
/// Changing the value in [ThemeData.materialTapTargetSize] will affect the
/// accessibility experience.
///
/// Some of the impacted widgets include:
///
///   * [FloatingActionButton], only the mini tap target size is increased.
///   * [MaterialButton]
///   * [OutlinedButton]
///   * [TextButton]
///   * [ElevatedButton]
///   * [IconButton]
///   * The time picker widget ([showTimePicker])
///   * [SnackBar]
///   * [Chip]
///   * [RawChip]
///   * [InputChip]
///   * [ChoiceChip]
///   * [FilterChip]
///   * [ActionChip]
///   * [Radio]
///   * [Switch]
///   * [Checkbox]
enum MaterialTapTargetSize {
  /// Expands the minimum tap target size to 48px by 48px.
  ///
  /// This is the default value of [ThemeData.materialTapTargetSize] and the
  /// recommended size to conform to Android accessibility scanner
  /// recommendations.
  padded,

  /// Shrinks the tap target size to the minimum provided by the Material
  /// specification.
  shrinkWrap,
}

/// Defines the configuration of the overall visual [Theme] for a [MaterialApp]
/// or a widget subtree within the app.
///
/// The [MaterialApp] theme property can be used to configure the appearance
/// of the entire app. Widget subtrees within an app can override the app's
/// theme by including a [Theme] widget at the top of the subtree.
///
/// Widgets whose appearance should align with the overall theme can obtain the
/// current theme's configuration with [Theme.of]. Material components typically
/// depend exclusively on the [colorScheme] and [textTheme]. These properties
/// are guaranteed to have non-null values.
///
/// The static [Theme.of] method finds the [ThemeData] value specified for the
/// nearest [BuildContext] ancestor. This lookup is inexpensive, essentially
/// just a single HashMap access. It can sometimes be a little confusing
/// because [Theme.of] can not see a [Theme] widget that is defined in the
/// current build method's context. To overcome that, create a new custom widget
/// for the subtree that appears below the new [Theme], or insert a widget
/// that creates a new BuildContext, like [Builder].
///
/// {@tool dartpad}
/// This example demonstrates how a typical [MaterialApp] specifies
/// and uses a custom [Theme]. The theme's [ColorScheme] is based on a
/// single "seed" color and configures itself to match the platform's
/// current light or dark color configuration. The theme overrides the
/// default configuration of [FloatingActionButton] to show how to
/// customize the appearance a class of components.
///
/// ** See code in examples/api/lib/material/theme_data/theme_data.0.dart **
/// {@end-tool}
///
/// See <https://material.io/design/color/> for
/// more discussion on how to pick the right colors.

@immutable
class ThemeData with Diagnosticable {
  /// Create a [ThemeData] that's used to configure a [Theme].
  ///
  /// The [colorScheme] and [textTheme] are used by the Material components to
  /// compute default values for visual properties. The API documentation for
  /// each component widget explains exactly how the defaults are computed.
  ///
  /// When providing a [ColorScheme], apps can either provide one directly
  /// with the [colorScheme] parameter, or have one generated for them by
  /// using the [colorSchemeSeed] and [brightness] parameters. A generated
  /// color scheme will be based on the tones of [colorSchemeSeed] and all of
  /// its contrasting color will meet accessibility guidelines for readability.
  /// (See [ColorScheme.fromSeed] for more details.)
  ///
  /// If the app wants to customize a generated color scheme, it can use
  /// [ColorScheme.fromSeed] directly and then [ColorScheme.copyWith] on the
  /// result to override any colors that need to be replaced. The result of
  /// this can be used as the [colorScheme] directly.
  ///
  /// For historical reasons, instead of using a [colorSchemeSeed] or
  /// [colorScheme], you can provide either a [primaryColor] or [primarySwatch]
  /// to construct the [colorScheme], but the results will not be as complete
  /// as when using generation from a seed color.
  ///
  /// If [colorSchemeSeed] is non-null then [colorScheme], [primaryColor] and
  /// [primarySwatch] must all be null.
  ///
  /// The [textTheme] [TextStyle] colors are black if the color scheme's
  /// brightness is [Brightness.light], and white for [Brightness.dark].
  ///
  /// To override the appearance of specific components, provide
  /// a component theme parameter like [sliderTheme], [toggleButtonsTheme],
  /// or [bottomNavigationBarTheme].
  ///
  /// See also:
  ///
  ///  * [ThemeData.from], which creates a ThemeData from a [ColorScheme].
  ///  * [ThemeData.light], which creates the default light theme.
  ///  * [ThemeData.dark], which creates the default dark theme.
  ///  * [ColorScheme.fromSeed], which is used to create a [ColorScheme] from a seed color.
  factory ThemeData({
    // For the sanity of the reader, make sure these properties are in the same
    // order in every place that they are separated by section comments (e.g.
    // GENERAL CONFIGURATION). Each section except for deprecations should be
    // alphabetical by symbol name.

    // GENERAL CONFIGURATION
    Iterable<Adaptation<Object>>? adaptations,
    bool? applyElevationOverlayColor,
    NoDefaultCupertinoThemeData? cupertinoOverrideTheme,
    Iterable<ThemeExtension<dynamic>>? extensions,
    InputDecorationTheme? inputDecorationTheme,
    MaterialTapTargetSize? materialTapTargetSize,
    PageTransitionsTheme? pageTransitionsTheme,
    TargetPlatform? platform,
    ScrollbarThemeData? scrollbarTheme,
    InteractiveInkFeatureFactory? splashFactory,
    bool? useMaterial3,
    VisualDensity? visualDensity,
    // COLOR
    ColorScheme? colorScheme,
    Brightness? brightness,
    Color? colorSchemeSeed,
    // [colorScheme] is the preferred way to configure colors. The [Color] properties
    // listed below (as well as primarySwatch) will gradually be phased out, see
    // https://github.com/flutter/flutter/issues/91772.
    Color? canvasColor,
    Color? cardColor,
    Color? disabledColor,
    Color? dividerColor,
    Color? focusColor,
    Color? highlightColor,
    Color? hintColor,
    Color? hoverColor,
    Color? indicatorColor,
    Color? primaryColor,
    Color? primaryColorDark,
    Color? primaryColorLight,
    MaterialColor? primarySwatch,
    Color? scaffoldBackgroundColor,
    Color? secondaryHeaderColor,
    Color? shadowColor,
    Color? splashColor,
    Color? unselectedWidgetColor,
    // TYPOGRAPHY & ICONOGRAPHY
    String? fontFamily,
    List<String>? fontFamilyFallback,
    String? package,
    IconThemeData? iconTheme,
    IconThemeData? primaryIconTheme,
    TextTheme? primaryTextTheme,
    TextTheme? textTheme,
    Typography? typography,
    // COMPONENT THEMES
    ActionIconThemeData? actionIconTheme,
    AppBarTheme? appBarTheme,
    BadgeThemeData? badgeTheme,
    MaterialBannerThemeData? bannerTheme,
    BottomAppBarTheme? bottomAppBarTheme,
    BottomNavigationBarThemeData? bottomNavigationBarTheme,
    BottomSheetThemeData? bottomSheetTheme,
    ButtonThemeData? buttonTheme,
    // TODO(QuncCccccc): Change the parameter type to CardThemeData
    Object? cardTheme,
    CheckboxThemeData? checkboxTheme,
    ChipThemeData? chipTheme,
    DataTableThemeData? dataTableTheme,
    DatePickerThemeData? datePickerTheme,
    // TODO(QuncCccccc): Change the parameter type to DialogThemeData
    Object? dialogTheme,
    DividerThemeData? dividerTheme,
    DrawerThemeData? drawerTheme,
    DropdownMenuThemeData? dropdownMenuTheme,
    ElevatedButtonThemeData? elevatedButtonTheme,
    ExpansionTileThemeData? expansionTileTheme,
    FilledButtonThemeData? filledButtonTheme,
    FloatingActionButtonThemeData? floatingActionButtonTheme,
    IconButtonThemeData? iconButtonTheme,
    ListTileThemeData? listTileTheme,
    MenuBarThemeData? menuBarTheme,
    MenuButtonThemeData? menuButtonTheme,
    MenuThemeData? menuTheme,
    NavigationBarThemeData? navigationBarTheme,
    NavigationDrawerThemeData? navigationDrawerTheme,
    NavigationRailThemeData? navigationRailTheme,
    OutlinedButtonThemeData? outlinedButtonTheme,
    PopupMenuThemeData? popupMenuTheme,
    ProgressIndicatorThemeData? progressIndicatorTheme,
    RadioThemeData? radioTheme,
    SearchBarThemeData? searchBarTheme,
    SearchViewThemeData? searchViewTheme,
    SegmentedButtonThemeData? segmentedButtonTheme,
    SliderThemeData? sliderTheme,
    SnackBarThemeData? snackBarTheme,
    SwitchThemeData? switchTheme,
    // TODO(QuncCccccc): Change the parameter type to TabBarThemeData
    Object? tabBarTheme,
    TextButtonThemeData? textButtonTheme,
    TextSelectionThemeData? textSelectionTheme,
    TimePickerThemeData? timePickerTheme,
    ToggleButtonsThemeData? toggleButtonsTheme,
    TooltipThemeData? tooltipTheme,
    // DEPRECATED (newest deprecations at the bottom)
    @Deprecated(
      'Use OverflowBar instead. '
      'This feature was deprecated after v3.21.0-10.0.pre.',
    )
    ButtonBarThemeData? buttonBarTheme,
    @Deprecated(
      'Use DialogThemeData.backgroundColor instead. '
      'This feature was deprecated after v3.27.0-0.1.pre.',
    )
    Color? dialogBackgroundColor,
  }) {
    // GENERAL CONFIGURATION
    cupertinoOverrideTheme = cupertinoOverrideTheme?.noDefault();
    extensions ??= <ThemeExtension<dynamic>>[];
    adaptations ??= <Adaptation<Object>>[];
    inputDecorationTheme ??= const InputDecorationTheme();
    platform ??= defaultTargetPlatform;
    switch (platform) {
      case TargetPlatform.android:
      case TargetPlatform.fuchsia:
      case TargetPlatform.iOS:
        materialTapTargetSize ??= MaterialTapTargetSize.padded;
      case TargetPlatform.linux:
      case TargetPlatform.macOS:
      case TargetPlatform.windows:
        materialTapTargetSize ??= MaterialTapTargetSize.shrinkWrap;
    }
    pageTransitionsTheme ??= const PageTransitionsTheme();
    scrollbarTheme ??= const ScrollbarThemeData();
    visualDensity ??= VisualDensity.defaultDensityForPlatform(platform);
    useMaterial3 ??= true;
    final bool useInkSparkle = platform == TargetPlatform.android && !kIsWeb;
    splashFactory ??=
        useMaterial3
            ? useInkSparkle
                ? InkSparkle.splashFactory
                : InkRipple.splashFactory
            : InkSplash.splashFactory;

    // COLOR
    assert(
      colorScheme?.brightness == null ||
          brightness == null ||
          colorScheme!.brightness == brightness,
      'ThemeData.brightness does not match ColorScheme.brightness. '
      'Either override ColorScheme.brightness or ThemeData.brightness to '
      'match the other.',
    );
    assert(colorSchemeSeed == null || colorScheme == null);
    assert(colorSchemeSeed == null || primarySwatch == null);
    assert(colorSchemeSeed == null || primaryColor == null);
    final Brightness effectiveBrightness =
        brightness ?? colorScheme?.brightness ?? Brightness.light;
    final bool isDark = effectiveBrightness == Brightness.dark;
    if (colorSchemeSeed != null || useMaterial3) {
      if (colorSchemeSeed != null) {
        colorScheme = ColorScheme.fromSeed(
          seedColor: colorSchemeSeed,
          brightness: effectiveBrightness,
        );
      }
      colorScheme ??= isDark ? _colorSchemeDarkM3 : _colorSchemeLightM3;

      // For surfaces that use primary color in light themes and surface color in dark
      final Color primarySurfaceColor = isDark ? colorScheme.surface : colorScheme.primary;
      final Color onPrimarySurfaceColor = isDark ? colorScheme.onSurface : colorScheme.onPrimary;

      // Default some of the color settings to values from the color scheme
      primaryColor ??= primarySurfaceColor;
      canvasColor ??= colorScheme.surface;
      scaffoldBackgroundColor ??= colorScheme.surface;
      cardColor ??= colorScheme.surface;
      dividerColor ??= colorScheme.outline;
      dialogBackgroundColor ??= colorScheme.surface;
      indicatorColor ??= onPrimarySurfaceColor;
      applyElevationOverlayColor ??= brightness == Brightness.dark;
    }
    applyElevationOverlayColor ??= false;
    primarySwatch ??= Colors.blue;
    primaryColor ??= isDark ? Colors.grey[900]! : primarySwatch;
    final Brightness estimatedPrimaryColorBrightness = estimateBrightnessForColor(primaryColor);
    primaryColorLight ??= isDark ? Colors.grey[500]! : primarySwatch[100]!;
    primaryColorDark ??= isDark ? Colors.black : primarySwatch[700]!;
    final bool primaryIsDark = estimatedPrimaryColorBrightness == Brightness.dark;
    focusColor ??= isDark ? Colors.white.withOpacity(0.12) : Colors.black.withOpacity(0.12);
    hoverColor ??= isDark ? Colors.white.withOpacity(0.04) : Colors.black.withOpacity(0.04);
    shadowColor ??= Colors.black;
    canvasColor ??= isDark ? Colors.grey[850]! : Colors.grey[50]!;
    scaffoldBackgroundColor ??= canvasColor;
    cardColor ??= isDark ? Colors.grey[800]! : Colors.white;
    dividerColor ??= isDark ? const Color(0x1FFFFFFF) : const Color(0x1F000000);
    // Create a ColorScheme that is backwards compatible as possible
    // with the existing default ThemeData color values.
    colorScheme ??= ColorScheme.fromSwatch(
      primarySwatch: primarySwatch,
      accentColor: isDark ? Colors.tealAccent[200]! : primarySwatch[500]!,
      cardColor: cardColor,
      backgroundColor: isDark ? Colors.grey[700]! : primarySwatch[200]!,
      errorColor: Colors.red[700],
      brightness: effectiveBrightness,
    );
    unselectedWidgetColor ??= isDark ? Colors.white70 : Colors.black54;
    // Spec doesn't specify a dark theme secondaryHeaderColor, this is a guess.
    secondaryHeaderColor ??= isDark ? Colors.grey[700]! : primarySwatch[50]!;
    indicatorColor ??= colorScheme.secondary == primaryColor ? Colors.white : colorScheme.secondary;
    hintColor ??= isDark ? Colors.white60 : Colors.black.withOpacity(0.6);
    // The default [buttonTheme] is here because it doesn't use the defaults for
    // [disabledColor], [highlightColor], and [splashColor].
    buttonTheme ??= ButtonThemeData(
      colorScheme: colorScheme,
      buttonColor: isDark ? primarySwatch[600]! : Colors.grey[300]!,
      disabledColor: disabledColor,
      focusColor: focusColor,
      hoverColor: hoverColor,
      highlightColor: highlightColor,
      splashColor: splashColor,
      materialTapTargetSize: materialTapTargetSize,
    );
    disabledColor ??= isDark ? Colors.white38 : Colors.black38;
    highlightColor ??= isDark ? const Color(0x40CCCCCC) : const Color(0x66BCBCBC);
    splashColor ??= isDark ? const Color(0x40CCCCCC) : const Color(0x66C8C8C8);

    // TYPOGRAPHY & ICONOGRAPHY
    typography ??=
        useMaterial3
            ? Typography.material2021(platform: platform, colorScheme: colorScheme)
            : Typography.material2014(platform: platform);
    TextTheme defaultTextTheme = isDark ? typography.white : typography.black;
    TextTheme defaultPrimaryTextTheme = primaryIsDark ? typography.white : typography.black;
    if (fontFamily != null) {
      defaultTextTheme = defaultTextTheme.apply(fontFamily: fontFamily);
      defaultPrimaryTextTheme = defaultPrimaryTextTheme.apply(fontFamily: fontFamily);
    }
    if (fontFamilyFallback != null) {
      defaultTextTheme = defaultTextTheme.apply(fontFamilyFallback: fontFamilyFallback);
      defaultPrimaryTextTheme = defaultPrimaryTextTheme.apply(
        fontFamilyFallback: fontFamilyFallback,
      );
    }
    if (package != null) {
      defaultTextTheme = defaultTextTheme.apply(package: package);
      defaultPrimaryTextTheme = defaultPrimaryTextTheme.apply(package: package);
    }
    textTheme = defaultTextTheme.merge(textTheme);
    primaryTextTheme = defaultPrimaryTextTheme.merge(primaryTextTheme);
    iconTheme ??=
        isDark
            ? IconThemeData(color: kDefaultIconLightColor)
            : IconThemeData(color: kDefaultIconDarkColor);
    primaryIconTheme ??=
        primaryIsDark
            ? const IconThemeData(color: Colors.white)
            : const IconThemeData(color: Colors.black);

    // COMPONENT THEMES
    appBarTheme ??= const AppBarTheme();
    badgeTheme ??= const BadgeThemeData();
    bannerTheme ??= const MaterialBannerThemeData();
    bottomAppBarTheme ??= const BottomAppBarTheme();
    bottomNavigationBarTheme ??= const BottomNavigationBarThemeData();
    bottomSheetTheme ??= const BottomSheetThemeData();
    // TODO(QuncCccccc): Clean it up once the type of `cardTheme` is changed to `CardThemeData`
    if (cardTheme != null) {
      if (cardTheme is CardTheme) {
        cardTheme = cardTheme.data;
      } else if (cardTheme is! CardThemeData) {
        throw ArgumentError('cardTheme must be either a CardThemeData or a CardTheme');
      }
    }
    cardTheme ??= const CardThemeData();
    checkboxTheme ??= const CheckboxThemeData();
    chipTheme ??= const ChipThemeData();
    dataTableTheme ??= const DataTableThemeData();
    datePickerTheme ??= const DatePickerThemeData();
    // TODO(QuncCccccc): Clean this up once the type of `dialogTheme` is changed to `DialogThemeData`
    if (dialogTheme != null) {
      if (dialogTheme is DialogTheme) {
        dialogTheme = dialogTheme.data;
      } else if (dialogTheme is! DialogThemeData) {
        throw ArgumentError('dialogTheme must be either a DialogThemeData or a DialogTheme');
      }
    }
    dialogTheme ??= const DialogThemeData();
    dividerTheme ??= const DividerThemeData();
    drawerTheme ??= const DrawerThemeData();
    dropdownMenuTheme ??= const DropdownMenuThemeData();
    elevatedButtonTheme ??= const ElevatedButtonThemeData();
    expansionTileTheme ??= const ExpansionTileThemeData();
    filledButtonTheme ??= const FilledButtonThemeData();
    floatingActionButtonTheme ??= const FloatingActionButtonThemeData();
    iconButtonTheme ??= const IconButtonThemeData();
    listTileTheme ??= const ListTileThemeData();
    menuBarTheme ??= const MenuBarThemeData();
    menuButtonTheme ??= const MenuButtonThemeData();
    menuTheme ??= const MenuThemeData();
    navigationBarTheme ??= const NavigationBarThemeData();
    navigationDrawerTheme ??= const NavigationDrawerThemeData();
    navigationRailTheme ??= const NavigationRailThemeData();
    outlinedButtonTheme ??= const OutlinedButtonThemeData();
    popupMenuTheme ??= const PopupMenuThemeData();
    progressIndicatorTheme ??= const ProgressIndicatorThemeData();
    radioTheme ??= const RadioThemeData();
    searchBarTheme ??= const SearchBarThemeData();
    searchViewTheme ??= const SearchViewThemeData();
    segmentedButtonTheme ??= const SegmentedButtonThemeData();
    sliderTheme ??= const SliderThemeData();
    snackBarTheme ??= const SnackBarThemeData();
    switchTheme ??= const SwitchThemeData();
    // TODO(QuncCccccc): Clean this up once the type of `tabBarTheme` is changed to `TabBarThemeData`
    if (tabBarTheme != null) {
      if (tabBarTheme is TabBarTheme) {
        tabBarTheme = tabBarTheme.data;
      } else if (tabBarTheme is! TabBarThemeData) {
        throw ArgumentError('tabBarTheme must be either a TabBarThemeData or a TabBarTheme');
      }
    }
    tabBarTheme ??= const TabBarThemeData();
    textButtonTheme ??= const TextButtonThemeData();
    textSelectionTheme ??= const TextSelectionThemeData();
    timePickerTheme ??= const TimePickerThemeData();
    toggleButtonsTheme ??= const ToggleButtonsThemeData();
    tooltipTheme ??= const TooltipThemeData();
    // DEPRECATED (newest deprecations at the bottom)
    buttonBarTheme ??= const ButtonBarThemeData();
    dialogBackgroundColor ??= isDark ? Colors.grey[800]! : Colors.white;
    return ThemeData.raw(
      // For the sanity of the reader, make sure these properties are in the same
      // order in every place that they are separated by section comments (e.g.
      // GENERAL CONFIGURATION). Each section except for deprecations should be
      // alphabetical by symbol name.

      // GENERAL CONFIGURATION
      adaptationMap: _createAdaptationMap(adaptations),
      applyElevationOverlayColor: applyElevationOverlayColor,
      cupertinoOverrideTheme: cupertinoOverrideTheme,
      extensions: _themeExtensionIterableToMap(extensions),
      inputDecorationTheme: inputDecorationTheme,
      materialTapTargetSize: materialTapTargetSize,
      pageTransitionsTheme: pageTransitionsTheme,
      platform: platform,
      scrollbarTheme: scrollbarTheme,
      splashFactory: splashFactory,
      useMaterial3: useMaterial3,
      visualDensity: visualDensity,
      // COLOR
      canvasColor: canvasColor,
      cardColor: cardColor,
      colorScheme: colorScheme,
      disabledColor: disabledColor,
      dividerColor: dividerColor,
      focusColor: focusColor,
      highlightColor: highlightColor,
      hintColor: hintColor,
      hoverColor: hoverColor,
      indicatorColor: indicatorColor,
      primaryColor: primaryColor,
      primaryColorDark: primaryColorDark,
      primaryColorLight: primaryColorLight,
      scaffoldBackgroundColor: scaffoldBackgroundColor,
      secondaryHeaderColor: secondaryHeaderColor,
      shadowColor: shadowColor,
      splashColor: splashColor,
      unselectedWidgetColor: unselectedWidgetColor,
      // TYPOGRAPHY & ICONOGRAPHY
      iconTheme: iconTheme,
      primaryTextTheme: primaryTextTheme,
      textTheme: textTheme,
      typography: typography,
      primaryIconTheme: primaryIconTheme,
      // COMPONENT THEMES
      actionIconTheme: actionIconTheme,
      appBarTheme: appBarTheme,
      badgeTheme: badgeTheme,
      bannerTheme: bannerTheme,
      bottomAppBarTheme: bottomAppBarTheme,
      bottomNavigationBarTheme: bottomNavigationBarTheme,
      bottomSheetTheme: bottomSheetTheme,
      buttonTheme: buttonTheme,
      cardTheme: cardTheme as CardThemeData,
      checkboxTheme: checkboxTheme,
      chipTheme: chipTheme,
      dataTableTheme: dataTableTheme,
      datePickerTheme: datePickerTheme,
      dialogTheme: dialogTheme as DialogThemeData,
      dividerTheme: dividerTheme,
      drawerTheme: drawerTheme,
      dropdownMenuTheme: dropdownMenuTheme,
      elevatedButtonTheme: elevatedButtonTheme,
      expansionTileTheme: expansionTileTheme,
      filledButtonTheme: filledButtonTheme,
      floatingActionButtonTheme: floatingActionButtonTheme,
      iconButtonTheme: iconButtonTheme,
      listTileTheme: listTileTheme,
      menuBarTheme: menuBarTheme,
      menuButtonTheme: menuButtonTheme,
      menuTheme: menuTheme,
      navigationBarTheme: navigationBarTheme,
      navigationDrawerTheme: navigationDrawerTheme,
      navigationRailTheme: navigationRailTheme,
      outlinedButtonTheme: outlinedButtonTheme,
      popupMenuTheme: popupMenuTheme,
      progressIndicatorTheme: progressIndicatorTheme,
      radioTheme: radioTheme,
      searchBarTheme: searchBarTheme,
      searchViewTheme: searchViewTheme,
      segmentedButtonTheme: segmentedButtonTheme,
      sliderTheme: sliderTheme,
      snackBarTheme: snackBarTheme,
      switchTheme: switchTheme,
      tabBarTheme: tabBarTheme as TabBarThemeData,
      textButtonTheme: textButtonTheme,
      textSelectionTheme: textSelectionTheme,
      timePickerTheme: timePickerTheme,
      toggleButtonsTheme: toggleButtonsTheme,
      tooltipTheme: tooltipTheme,
      // DEPRECATED (newest deprecations at the bottom)
      buttonBarTheme: buttonBarTheme,
      dialogBackgroundColor: dialogBackgroundColor,
    );
  }

  /// Create a [ThemeData] given a set of exact values. Most values must be
  /// specified. They all must also be non-null except for
  /// [cupertinoOverrideTheme], and deprecated members.
  ///
  /// This will rarely be used directly. It is used by [lerp] to
  /// create intermediate themes based on two themes created with the
  /// [ThemeData] constructor.
  const ThemeData.raw({
    // For the sanity of the reader, make sure these properties are in the same
    // order in every place that they are separated by section comments (e.g.
    // GENERAL CONFIGURATION). Each section except for deprecations should be
    // alphabetical by symbol name.

    // GENERAL CONFIGURATION
    required this.adaptationMap,
    required this.applyElevationOverlayColor,
    required this.cupertinoOverrideTheme,
    required this.extensions,
    required this.inputDecorationTheme,
    required this.materialTapTargetSize,
    required this.pageTransitionsTheme,
    required this.platform,
    required this.scrollbarTheme,
    required this.splashFactory,
    required this.useMaterial3,
    required this.visualDensity,
    // COLOR
    required this.colorScheme,
    // [colorScheme] is the preferred way to configure colors. The [Color] properties
    // listed below (as well as primarySwatch) will gradually be phased out, see
    // https://github.com/flutter/flutter/issues/91772.
    required this.canvasColor,
    required this.cardColor,
    required this.disabledColor,
    required this.dividerColor,
    required this.focusColor,
    required this.highlightColor,
    required this.hintColor,
    required this.hoverColor,
    required this.indicatorColor,
    required this.primaryColor,
    required this.primaryColorDark,
    required this.primaryColorLight,
    required this.scaffoldBackgroundColor,
    required this.secondaryHeaderColor,
    required this.shadowColor,
    required this.splashColor,
    required this.unselectedWidgetColor,
    // TYPOGRAPHY & ICONOGRAPHY
    required this.iconTheme,
    required this.primaryIconTheme,
    required this.primaryTextTheme,
    required this.textTheme,
    required this.typography,
    // COMPONENT THEMES
    required this.actionIconTheme,
    required this.appBarTheme,
    required this.badgeTheme,
    required this.bannerTheme,
    required this.bottomAppBarTheme,
    required this.bottomNavigationBarTheme,
    required this.bottomSheetTheme,
    required this.buttonTheme,
    required this.cardTheme,
    required this.checkboxTheme,
    required this.chipTheme,
    required this.dataTableTheme,
    required this.datePickerTheme,
    required this.dialogTheme,
    required this.dividerTheme,
    required this.drawerTheme,
    required this.dropdownMenuTheme,
    required this.elevatedButtonTheme,
    required this.expansionTileTheme,
    required this.filledButtonTheme,
    required this.floatingActionButtonTheme,
    required this.iconButtonTheme,
    required this.listTileTheme,
    required this.menuBarTheme,
    required this.menuButtonTheme,
    required this.menuTheme,
    required this.navigationBarTheme,
    required this.navigationDrawerTheme,
    required this.navigationRailTheme,
    required this.outlinedButtonTheme,
    required this.popupMenuTheme,
    required this.progressIndicatorTheme,
    required this.radioTheme,
    required this.searchBarTheme,
    required this.searchViewTheme,
    required this.segmentedButtonTheme,
    required this.sliderTheme,
    required this.snackBarTheme,
    required this.switchTheme,
    required this.tabBarTheme,
    required this.textButtonTheme,
    required this.textSelectionTheme,
    required this.timePickerTheme,
    required this.toggleButtonsTheme,
    required this.tooltipTheme,
    // DEPRECATED (newest deprecations at the bottom)
    @Deprecated(
      'Use OverflowBar instead. '
      'This feature was deprecated after v3.21.0-10.0.pre.',
    )
    ButtonBarThemeData? buttonBarTheme,
    @Deprecated(
      'Use DialogThemeData.backgroundColor instead. '
      'This feature was deprecated after v3.27.0-0.1.pre.',
    )
    required this.dialogBackgroundColor,
  }) : // DEPRECATED (newest deprecations at the bottom)
       // should not be `required`, use getter pattern to avoid breakages.
       _buttonBarTheme = buttonBarTheme,
       assert(buttonBarTheme != null);

  /// Create a [ThemeData] based on the colors in the given [colorScheme] and
  /// text styles of the optional [textTheme].
  ///
  /// If [colorScheme].brightness is [Brightness.dark] then
  /// [ThemeData.applyElevationOverlayColor] will be set to true to support
  /// the Material dark theme method for indicating elevation by applying
  /// a semi-transparent onSurface color on top of the surface color.
  ///
  /// This is the recommended method to theme your application. As we move
  /// forward we will be converting all the widget implementations to only use
  /// colors or colors derived from those in [ColorScheme].
  ///
  /// {@tool snippet}
  /// This example will set up an application to use the baseline Material
  /// Design light and dark themes.
  ///
  /// ```dart
  /// MaterialApp(
  ///   theme: ThemeData.from(colorScheme: const ColorScheme.light()),
  ///   darkTheme: ThemeData.from(colorScheme: const ColorScheme.dark()),
  /// )
  /// ```
  /// {@end-tool}
  ///
  /// See <https://material.io/design/color/> for
  /// more discussion on how to pick the right colors.
  factory ThemeData.from({
    required ColorScheme colorScheme,
    TextTheme? textTheme,
    bool? useMaterial3,
  }) {
    final bool isDark = colorScheme.brightness == Brightness.dark;

    // For surfaces that use primary color in light themes and surface color in dark
    final Color primarySurfaceColor = isDark ? colorScheme.surface : colorScheme.primary;
    final Color onPrimarySurfaceColor = isDark ? colorScheme.onSurface : colorScheme.onPrimary;

    return ThemeData(
      colorScheme: colorScheme,
      brightness: colorScheme.brightness,
      primaryColor: primarySurfaceColor,
      canvasColor: colorScheme.surface,
      scaffoldBackgroundColor: colorScheme.surface,
      cardColor: colorScheme.surface,
      dividerColor: colorScheme.onSurface.withOpacity(0.12),
      dialogBackgroundColor: colorScheme.surface,
      indicatorColor: onPrimarySurfaceColor,
      textTheme: textTheme,
      applyElevationOverlayColor: isDark,
      useMaterial3: useMaterial3,
    );
  }

  /// A default light theme.
  ///
  /// This theme does not contain text geometry. Instead, it is expected that
  /// this theme is localized using text geometry using [ThemeData.localize].
  factory ThemeData.light({bool? useMaterial3}) =>
      ThemeData(brightness: Brightness.light, useMaterial3: useMaterial3);

  /// A default dark theme.
  ///
  /// This theme does not contain text geometry. Instead, it is expected that
  /// this theme is localized using text geometry using [ThemeData.localize].
  factory ThemeData.dark({bool? useMaterial3}) =>
      ThemeData(brightness: Brightness.dark, useMaterial3: useMaterial3);

  /// The default color theme. Same as [ThemeData.light].
  ///
  /// This is used by [Theme.of] when no theme has been specified.
  ///
  /// This theme does not contain text geometry. Instead, it is expected that
  /// this theme is localized using text geometry using [ThemeData.localize].
  ///
  /// Most applications would use [Theme.of], which provides correct localized
  /// text geometry.
  factory ThemeData.fallback({bool? useMaterial3}) => ThemeData.light(useMaterial3: useMaterial3);

  /// Used to obtain a particular [Adaptation] from [adaptationMap].
  ///
  /// To get an adaptation, use `Theme.of(context).getAdaptation<MyAdaptation>()`.
  Adaptation<T>? getAdaptation<T>() => adaptationMap[T] as Adaptation<T>?;

  static Map<Type, Adaptation<Object>> _createAdaptationMap(
    Iterable<Adaptation<Object>> adaptations,
  ) {
    final Map<Type, Adaptation<Object>> adaptationMap = <Type, Adaptation<Object>>{
      for (final Adaptation<Object> adaptation in adaptations) adaptation.type: adaptation,
    };
    return adaptationMap;
  }

  /// The overall theme brightness.
  ///
  /// The default [TextStyle] color for the [textTheme] is black if the
  /// theme is constructed with [Brightness.light] and white if the
  /// theme is constructed with [Brightness.dark].
  Brightness get brightness => colorScheme.brightness;

  // For the sanity of the reader, make sure these properties are in the same
  // order in every place that they are separated by section comments (e.g.
  // GENERAL CONFIGURATION). Each section except for deprecations should be
  // alphabetical by symbol name.

  // GENERAL CONFIGURATION

  /// Apply a semi-transparent overlay color on Material surfaces to indicate
  /// elevation for dark themes.
  ///
  /// If [useMaterial3] is true, then this flag is ignored as there is a new
  /// [Material.surfaceTintColor] used to create an overlay for Material 3.
  /// This flag is meant only for the Material 2 elevation overlay for dark
  /// themes.
  ///
  /// Material drop shadows can be difficult to see in a dark theme, so the
  /// elevation of a surface should be portrayed with an "overlay" in addition
  /// to the shadow. As the elevation of the component increases, the
  /// overlay increases in opacity. [applyElevationOverlayColor] turns the
  /// application of this overlay on or off for dark themes.
  ///
  /// If true and [brightness] is [Brightness.dark], a
  /// semi-transparent version of [ColorScheme.onSurface] will be
  /// applied on top of [Material] widgets that have a [ColorScheme.surface]
  /// color. The level of transparency is based on [Material.elevation] as
  /// per the Material Dark theme specification.
  ///
  /// If false the surface color will be used unmodified.
  ///
  /// Defaults to false in order to maintain backwards compatibility with
  /// apps that were built before the Material Dark theme specification
  /// was published. New apps should set this to true for any themes
  /// where [brightness] is [Brightness.dark].
  ///
  /// See also:
  ///
  ///  * [Material.elevation], which effects the level of transparency of the
  ///    overlay color.
  ///  * [ElevationOverlay.applyOverlay], which is used by [Material] to apply
  ///    the overlay color to its surface color.
  ///  * <https://material.io/design/color/dark-theme.html>, which specifies how
  ///    the overlay should be applied.
  final bool applyElevationOverlayColor;

  /// Components of the [CupertinoThemeData] to override from the Material
  /// [ThemeData] adaptation.
  ///
  /// By default, [cupertinoOverrideTheme] is null and Cupertino widgets
  /// descendant to the Material [Theme] will adhere to a [CupertinoTheme]
  /// derived from the Material [ThemeData]. e.g. [ThemeData]'s [ColorScheme]
  /// will also inform the [CupertinoThemeData]'s `primaryColor` etc.
  ///
  /// This cascading effect for individual attributes of the [CupertinoThemeData]
  /// can be overridden using attributes of this [cupertinoOverrideTheme].
  final NoDefaultCupertinoThemeData? cupertinoOverrideTheme;

  /// Arbitrary additions to this theme.
  ///
  /// To define extensions, pass an [Iterable] containing one or more [ThemeExtension]
  /// subclasses to [ThemeData.new] or [copyWith].
  ///
  /// To obtain an extension, use [extension].
  ///
  /// {@tool dartpad}
  /// This sample shows how to create and use a subclass of [ThemeExtension] that
  /// defines two colors.
  ///
  /// ** See code in examples/api/lib/material/theme/theme_extension.1.dart **
  /// {@end-tool}
  ///
  /// See also:
  ///
  /// * [extension], a convenience function for obtaining a specific extension.
  final Map<Object, ThemeExtension<dynamic>> extensions;

  /// Used to obtain a particular [ThemeExtension] from [extensions].
  ///
  /// Obtain with `Theme.of(context).extension<MyThemeExtension>()`.
  ///
  /// See [extensions] for an interactive example.
  T? extension<T>() => extensions[T] as T?;

  /// A map which contains the adaptations for the theme. The entry's key is the
  /// type of the adaptation; the value is the adaptation itself.
  ///
  /// To obtain an adaptation, use [getAdaptation].
  final Map<Type, Adaptation<Object>> adaptationMap;

  /// The default [InputDecoration] values for [InputDecorator], [TextField],
  /// and [TextFormField] are based on this theme.
  ///
  /// See [InputDecoration.applyDefaults].
  final InputDecorationTheme inputDecorationTheme;

  /// Configures the hit test size of certain Material widgets.
  ///
  /// Defaults to a [platform]-appropriate size: [MaterialTapTargetSize.padded]
  /// on mobile platforms, [MaterialTapTargetSize.shrinkWrap] on desktop
  /// platforms.
  final MaterialTapTargetSize materialTapTargetSize;

  /// Default [MaterialPageRoute] transitions per [TargetPlatform].
  ///
  /// [MaterialPageRoute.buildTransitions] delegates to a [platform] specific
  /// [PageTransitionsBuilder]. If a matching builder is not found, a builder
  /// whose platform is null is used.
  final PageTransitionsTheme pageTransitionsTheme;

  /// The platform the material widgets should adapt to target.
  ///
  /// Defaults to the current platform, as exposed by [defaultTargetPlatform].
  /// This should be used in order to style UI elements according to platform
  /// conventions.
  ///
  /// Widgets from the material library should use this getter (via [Theme.of])
  /// to determine the current platform for the purpose of emulating the
  /// platform behavior (e.g. scrolling or haptic effects). Widgets and render
  /// objects at lower layers that try to emulate the underlying platform
  /// can depend on [defaultTargetPlatform] directly, or may require
  /// that the target platform be provided as an argument. The
  /// [dart:io.Platform] object should only be used directly when it's critical
  /// to actually know the current platform, without any overrides possible (for
  /// example, when a system API is about to be called).
  ///
  /// In a test environment, the platform returned is [TargetPlatform.android]
  /// regardless of the host platform. (Android was chosen because the tests
  /// were originally written assuming Android-like behavior, and we added
  /// platform adaptations for other platforms later). Tests can check behavior
  /// for other platforms by setting the [platform] of the [Theme] explicitly to
  /// another [TargetPlatform] value, or by setting
  /// [debugDefaultTargetPlatformOverride].
  ///
  /// Determines the defaults for [typography] and [materialTapTargetSize].
  final TargetPlatform platform;

  /// A theme for customizing the colors, thickness, and shape of [Scrollbar]s.
  final ScrollbarThemeData scrollbarTheme;

  /// Defines the appearance of ink splashes produces by [InkWell]
  /// and [InkResponse].
  ///
  /// See also:
  ///
  ///  * [InkSplash.splashFactory], which defines the default splash.
  ///  * [InkRipple.splashFactory], which defines a splash that spreads out
  ///    more aggressively than the default.
  ///  * [InkSparkle.splashFactory], which defines a more aggressive and organic
  ///    splash with sparkle effects.
  final InteractiveInkFeatureFactory splashFactory;

  /// A temporary flag that can be used to opt-out of Material 3 features.
  ///
  /// This flag is _true_ by default. If false, then components will
  /// continue to use the colors, typography and other features of
  /// Material 2.
  ///
  /// In the long run this flag will be deprecated and eventually
  /// only Material 3 will be supported. We recommend that applications
  /// migrate to Material 3 as soon as that's practical. Until that migration
  /// is complete, this flag can be set to false.
  ///
  /// ## Defaults
  ///
  /// If a [ThemeData] is _constructed_ with [useMaterial3] set to true, then
  /// some properties will get updated defaults. However, the
  /// [ThemeData.copyWith] method with [useMaterial3] set to true will _not_
  /// change any of these properties in the resulting [ThemeData].
  ///
  /// <style>table,td,th { border-collapse: collapse; padding: 0.45em; } td { border: 1px solid }</style>
  ///
  /// | Property        | Material 3 default             | Material 2 default             |
  /// | :-------------- | :----------------------------- | :----------------------------- |
  /// | [colorScheme]   | M3 baseline light color scheme | M2 baseline light color scheme |
  /// | [typography]    | [Typography.material2021]      | [Typography.material2014]      |
  /// | [splashFactory] | [InkSparkle]* or [InkRipple]   | [InkSplash]                    |
  ///
  /// \* if the target platform is Android and the app is not
  /// running on the web, otherwise it will fallback to [InkRipple].
  ///
  /// If [brightness] is [Brightness.dark] then the default color scheme will
  /// be either the M3 baseline dark color scheme or the M2 baseline dark color
  /// scheme depending on [useMaterial3].
  ///
  /// ## Affected widgets
  ///
  /// This flag affects styles and components.
  ///
  /// ### Styles
  ///   * Color: [ColorScheme], [Material] (see table above)
  ///   * Shape: (see components below)
  ///   * Typography: [Typography] (see table above)
  ///
  /// ### Components
  ///   * Badges: [Badge]
  ///   * Bottom app bar: [BottomAppBar]
  ///   * Bottom sheets: [BottomSheet]
  ///   * Buttons
  ///     - Common buttons: [ElevatedButton], [FilledButton], [FilledButton.tonal], [OutlinedButton], [TextButton]
  ///     - FAB: [FloatingActionButton], [FloatingActionButton.extended]
  ///     - Icon buttons: [IconButton], [IconButton.filled] (*new*), [IconButton.filledTonal], [IconButton.outlined]
  ///     - Segmented buttons: [SegmentedButton] (replacing [ToggleButtons])
  ///   * Cards: [Card]
  ///   * Checkbox: [Checkbox], [CheckboxListTile]
  ///   * Chips:
  ///     - [ActionChip] (used for Assist and Suggestion chips),
  ///     - [FilterChip], [ChoiceChip] (used for single selection filter chips),
  ///     - [InputChip]
  ///   * Date pickers: [showDatePicker], [showDateRangePicker], [DatePickerDialog], [DateRangePickerDialog], [InputDatePickerFormField]
  ///   * Dialogs: [AlertDialog], [Dialog.fullscreen]
  ///   * Divider: [Divider], [VerticalDivider]
  ///   * Lists: [ListTile]
  ///   * Menus: [MenuAnchor], [DropdownMenu], [MenuBar]
  ///   * Navigation bar: [NavigationBar] (replacing [BottomNavigationBar])
  ///   * Navigation drawer: [NavigationDrawer] (replacing [Drawer])
  ///   * Navigation rail: [NavigationRail]
  ///   * Progress indicators: [CircularProgressIndicator], [LinearProgressIndicator]
  ///   * Radio button: [Radio], [RadioListTile]
  ///   * Search: [SearchBar], [SearchAnchor],
  ///   * Snack bar: [SnackBar]
  ///   * Slider: [Slider], [RangeSlider]
  ///   * Switch: [Switch], [SwitchListTile]
  ///   * Tabs: [TabBar], [TabBar.secondary]
  ///   * TextFields: [TextField] together with its [InputDecoration]
  ///   * Time pickers: [showTimePicker], [TimePickerDialog]
  ///   * Top app bar: [AppBar], [SliverAppBar], [SliverAppBar.medium], [SliverAppBar.large]
  ///
  /// In addition, this flag enables features introduced in Android 12.
  ///   * Stretch overscroll: [MaterialScrollBehavior]
  ///   * Ripple: `splashFactory` (see table above)
  ///
  /// See also:
  ///
  ///   * [Material 3 specification](https://m3.material.io/).
  final bool useMaterial3;

  /// The density value for specifying the compactness of various UI components.
  ///
  /// {@template flutter.material.themedata.visualDensity}
  /// Density, in the context of a UI, is the vertical and horizontal
  /// "compactness" of the elements in the UI. It is unitless, since it means
  /// different things to different UI elements. For buttons, it affects the
  /// spacing around the centered label of the button. For lists, it affects the
  /// distance between baselines of entries in the list.
  ///
  /// Typically, density values are integral, but any value in range may be
  /// used. The range includes values from [VisualDensity.minimumDensity] (which
  /// is -4), to [VisualDensity.maximumDensity] (which is 4), inclusive, where
  /// negative values indicate a denser, more compact, UI, and positive values
  /// indicate a less dense, more expanded, UI. If a component doesn't support
  /// the value given, it will clamp to the nearest supported value.
  ///
  /// The default for visual densities is zero for both vertical and horizontal
  /// densities, which corresponds to the default visual density of components
  /// in the Material Design specification.
  ///
  /// As a rule of thumb, a change of 1 or -1 in density corresponds to 4
  /// logical pixels. However, this is not a strict relationship since
  /// components interpret the density values appropriately for their needs.
  ///
  /// A larger value translates to a spacing increase (less dense), and a
  /// smaller value translates to a spacing decrease (more dense).
  ///
  /// In Material Design 3, the [visualDensity] does not override the value of
  /// [IconButton.visualDensity] which defaults to [VisualDensity.standard]
  /// for all platforms. To override the default value of [IconButton.visualDensity],
  /// use [ThemeData.iconButtonTheme] instead.
  /// {@endtemplate}
  final VisualDensity visualDensity;

  // COLOR

  /// The default color of [MaterialType.canvas] [Material].
  final Color canvasColor;

  /// The color of [Material] when it is used as a [Card].
  final Color cardColor;

  /// {@macro flutter.material.color_scheme.ColorScheme}
  ///
  /// This property was added much later than the theme's set of highly specific
  /// colors, like [cardColor], [canvasColor] etc. New components can be defined
  /// exclusively in terms of [colorScheme]. Existing components will gradually
  /// migrate to it, to the extent that is possible without significant
  /// backwards compatibility breaks.
  final ColorScheme colorScheme;

  /// The color used for widgets that are inoperative, regardless of
  /// their state. For example, a disabled checkbox (which may be
  /// checked or unchecked).
  final Color disabledColor;

  /// The color of [Divider]s and [PopupMenuDivider]s, also used
  /// between [ListTile]s, between rows in [DataTable]s, and so forth.
  ///
  /// To create an appropriate [BorderSide] that uses this color, consider
  /// [Divider.createBorderSide].
  final Color dividerColor;

  /// The focus color used indicate that a component has the input focus.
  final Color focusColor;

  /// The highlight color used during ink splash animations or to
  /// indicate an item in a menu is selected.
  final Color highlightColor;

  /// The color to use for hint text or placeholder text, e.g. in
  /// [TextField] fields.
  final Color hintColor;

  /// The hover color used to indicate when a pointer is hovering over a
  /// component.
  final Color hoverColor;

  /// The color of the selected tab indicator in a tab bar.
  final Color indicatorColor;

  /// The background color for major parts of the app (toolbars, tab bars, etc)
  ///
  /// The theme's [colorScheme] property contains [ColorScheme.primary], as
  /// well as a color that contrasts well with the primary color called
  /// [ColorScheme.onPrimary]. It might be simpler to just configure an app's
  /// visuals in terms of the theme's [colorScheme].
  final Color primaryColor;

  /// A darker version of the [primaryColor].
  final Color primaryColorDark;

  /// A lighter version of the [primaryColor].
  final Color primaryColorLight;

  /// The default color of the [Material] that underlies the [Scaffold]. The
  /// background color for a typical material app or a page within the app.
  final Color scaffoldBackgroundColor;

  /// The color of the header of a [PaginatedDataTable] when there are selected rows.
  // According to the spec for data tables:
  // https://material.io/archive/guidelines/components/data-tables.html#data-tables-tables-within-cards
  // ...this should be the "50-value of secondary app color".
  final Color secondaryHeaderColor;

  /// The color that the [Material] widget uses to draw elevation shadows.
  ///
  /// Defaults to fully opaque black.
  ///
  /// Shadows can be difficult to see in a dark theme, so the elevation of a
  /// surface should be rendered with an "overlay" in addition to the shadow.
  /// As the elevation of the component increases, the overlay increases in
  /// opacity. The [applyElevationOverlayColor] property turns the elevation
  /// overlay on or off for dark themes.
  final Color shadowColor;

  /// The color of ink splashes.
  ///
  /// See also:
  ///  * [splashFactory], which defines the appearance of the splash.
  final Color splashColor;

  /// The color used for widgets in their inactive (but enabled)
  /// state. For example, an unchecked checkbox. See also [disabledColor].
  final Color unselectedWidgetColor;

  // TYPOGRAPHY & ICONOGRAPHY

  /// An icon theme that contrasts with the card and canvas colors.
  final IconThemeData iconTheme;

  /// An icon theme that contrasts with the primary color.
  final IconThemeData primaryIconTheme;

  /// A text theme that contrasts with the primary color.
  final TextTheme primaryTextTheme;

  /// Text with a color that contrasts with the card and canvas colors.
  final TextTheme textTheme;

  /// The color and geometry [TextTheme] values used to configure [textTheme].
  ///
  /// Defaults to a [platform]-appropriate typography.
  final Typography typography;

  // COMPONENT THEMES

  /// A theme for customizing icons of [BackButtonIcon], [CloseButtonIcon],
  /// [DrawerButtonIcon], or [EndDrawerButtonIcon].
  final ActionIconThemeData? actionIconTheme;

  /// A theme for customizing the color, elevation, brightness, iconTheme and
  /// textTheme of [AppBar]s.
  final AppBarTheme appBarTheme;

  /// A theme for customizing the color of [Badge]s.
  final BadgeThemeData badgeTheme;

  /// A theme for customizing the color and text style of a [MaterialBanner].
  final MaterialBannerThemeData bannerTheme;

  /// A theme for customizing the shape, elevation, and color of a [BottomAppBar].
  final BottomAppBarTheme bottomAppBarTheme;

  /// A theme for customizing the appearance and layout of [BottomNavigationBar]
  /// widgets.
  final BottomNavigationBarThemeData bottomNavigationBarTheme;

  /// A theme for customizing the color, elevation, and shape of a bottom sheet.
  final BottomSheetThemeData bottomSheetTheme;

  /// Defines the default configuration of button widgets, like [DropdownButton]
  /// and [ButtonBar].
  final ButtonThemeData buttonTheme;

  /// The colors and styles used to render [Card].
  ///
  /// This is the value returned from [CardTheme.of].
  final CardThemeData cardTheme;

  /// A theme for customizing the appearance and layout of [Checkbox] widgets.
  final CheckboxThemeData checkboxTheme;

  /// The colors and styles used to render [Chip]s.
  ///
  /// This is the value returned from [ChipTheme.of].
  final ChipThemeData chipTheme;

  /// A theme for customizing the appearance and layout of [DataTable]
  /// widgets.
  final DataTableThemeData dataTableTheme;

  /// A theme for customizing the appearance and layout of [DatePickerDialog]
  /// widgets.
  final DatePickerThemeData datePickerTheme;

  /// A theme for customizing the shape of a dialog.
  final DialogThemeData dialogTheme;

  /// A theme for customizing the color, thickness, and indents of [Divider]s,
  /// [VerticalDivider]s, etc.
  final DividerThemeData dividerTheme;

  /// A theme for customizing the appearance and layout of [Drawer] widgets.
  final DrawerThemeData drawerTheme;

  /// A theme for customizing the appearance and layout of [DropdownMenu] widgets.
  final DropdownMenuThemeData dropdownMenuTheme;

  /// A theme for customizing the appearance and internal layout of
  /// [ElevatedButton]s.
  final ElevatedButtonThemeData elevatedButtonTheme;

  /// A theme for customizing the visual properties of [ExpansionTile]s.
  final ExpansionTileThemeData expansionTileTheme;

  /// A theme for customizing the appearance and internal layout of
  /// [FilledButton]s.
  final FilledButtonThemeData filledButtonTheme;

  /// A theme for customizing the shape, elevation, and color of a
  /// [FloatingActionButton].
  final FloatingActionButtonThemeData floatingActionButtonTheme;

  /// A theme for customizing the appearance and internal layout of
  /// [IconButton]s.
  final IconButtonThemeData iconButtonTheme;

  /// A theme for customizing the appearance of [ListTile] widgets.
  final ListTileThemeData listTileTheme;

  /// A theme for customizing the color, shape, elevation, and other [MenuStyle]
  /// aspects of the menu bar created by the [MenuBar] widget.
  final MenuBarThemeData menuBarTheme;

  /// A theme for customizing the color, shape, elevation, and text style of
  /// cascading menu buttons created by [SubmenuButton] or [MenuItemButton].
  final MenuButtonThemeData menuButtonTheme;

  /// A theme for customizing the color, shape, elevation, and other [MenuStyle]
  /// attributes of menus created by the [SubmenuButton] widget.
  final MenuThemeData menuTheme;

  /// A theme for customizing the background color, text style, and icon themes
  /// of a [NavigationBar].
  final NavigationBarThemeData navigationBarTheme;

  /// A theme for customizing the background color, text style, and icon themes
  /// of a [NavigationDrawer].
  final NavigationDrawerThemeData navigationDrawerTheme;

  /// A theme for customizing the background color, elevation, text style, and
  /// icon themes of a [NavigationRail].
  final NavigationRailThemeData navigationRailTheme;

  /// A theme for customizing the appearance and internal layout of
  /// [OutlinedButton]s.
  final OutlinedButtonThemeData outlinedButtonTheme;

  /// A theme for customizing the color, shape, elevation, and text style of
  /// popup menus.
  final PopupMenuThemeData popupMenuTheme;

  /// A theme for customizing the appearance and layout of [ProgressIndicator] widgets.
  final ProgressIndicatorThemeData progressIndicatorTheme;

  /// A theme for customizing the appearance and layout of [Radio] widgets.
  final RadioThemeData radioTheme;

  /// A theme for customizing the appearance and layout of [SearchBar] widgets.
  final SearchBarThemeData searchBarTheme;

  /// A theme for customizing the appearance and layout of search views created by [SearchAnchor] widgets.
  final SearchViewThemeData searchViewTheme;

  /// A theme for customizing the appearance and layout of [SegmentedButton] widgets.
  final SegmentedButtonThemeData segmentedButtonTheme;

  /// The colors and shapes used to render [Slider].
  ///
  /// This is the value returned from [SliderTheme.of].
  final SliderThemeData sliderTheme;

  /// A theme for customizing colors, shape, elevation, and behavior of a [SnackBar].
  final SnackBarThemeData snackBarTheme;

  /// A theme for customizing the appearance and layout of [Switch] widgets.
  final SwitchThemeData switchTheme;

  /// A theme for customizing the size, shape, and color of the tab bar indicator.
  final TabBarThemeData tabBarTheme;

  /// A theme for customizing the appearance and internal layout of
  /// [TextButton]s.
  final TextButtonThemeData textButtonTheme;

  /// A theme for customizing the appearance and layout of [TextField] widgets.
  final TextSelectionThemeData textSelectionTheme;

  /// A theme for customizing the appearance and layout of time picker widgets.
  final TimePickerThemeData timePickerTheme;

  /// Defines the default configuration of [ToggleButtons] widgets.
  final ToggleButtonsThemeData toggleButtonsTheme;

  /// A theme for customizing the visual properties of [Tooltip]s.
  ///
  /// This is the value returned from [TooltipTheme.of].
  final TooltipThemeData tooltipTheme;

  /// A theme for customizing the appearance and layout of [ButtonBar] widgets.
  @Deprecated(
    'Use OverflowBar instead. '
    'This feature was deprecated after v3.21.0-10.0.pre.',
  )
  ButtonBarThemeData get buttonBarTheme => _buttonBarTheme!;
  final ButtonBarThemeData? _buttonBarTheme;

  /// The background color of [Dialog] elements.
  @Deprecated(
    'Use DialogThemeData.backgroundColor instead. '
    'This feature was deprecated after v3.27.0-0.1.pre.',
  )
  final Color dialogBackgroundColor;

  /// Creates a copy of this theme but with the given fields replaced with the new values.
  ///
  /// The [brightness] value is applied to the [colorScheme].
  ThemeData copyWith({
    // For the sanity of the reader, make sure these properties are in the same
    // order in every place that they are separated by section comments (e.g.
    // GENERAL CONFIGURATION). Each section except for deprecations should be
    // alphabetical by symbol name.

    // GENERAL CONFIGURATION
    Iterable<Adaptation<Object>>? adaptations,
    bool? applyElevationOverlayColor,
    NoDefaultCupertinoThemeData? cupertinoOverrideTheme,
    Iterable<ThemeExtension<dynamic>>? extensions,
    InputDecorationTheme? inputDecorationTheme,
    MaterialTapTargetSize? materialTapTargetSize,
    PageTransitionsTheme? pageTransitionsTheme,
    TargetPlatform? platform,
    ScrollbarThemeData? scrollbarTheme,
    InteractiveInkFeatureFactory? splashFactory,
    VisualDensity? visualDensity,
    // COLOR
    ColorScheme? colorScheme,
    Brightness? brightness,
    // [colorScheme] is the preferred way to configure colors. The [Color] properties
    // listed below (as well as primarySwatch) will gradually be phased out, see
    // https://github.com/flutter/flutter/issues/91772.
    Color? canvasColor,
    Color? cardColor,
    Color? disabledColor,
    Color? dividerColor,
    Color? focusColor,
    Color? highlightColor,
    Color? hintColor,
    Color? hoverColor,
    Color? indicatorColor,
    Color? primaryColor,
    Color? primaryColorDark,
    Color? primaryColorLight,
    Color? scaffoldBackgroundColor,
    Color? secondaryHeaderColor,
    Color? shadowColor,
    Color? splashColor,
    Color? unselectedWidgetColor,
    // TYPOGRAPHY & ICONOGRAPHY
    IconThemeData? iconTheme,
    IconThemeData? primaryIconTheme,
    TextTheme? primaryTextTheme,
    TextTheme? textTheme,
    Typography? typography,
    // COMPONENT THEMES
    ActionIconThemeData? actionIconTheme,
    AppBarTheme? appBarTheme,
    BadgeThemeData? badgeTheme,
    MaterialBannerThemeData? bannerTheme,
    BottomAppBarTheme? bottomAppBarTheme,
    BottomNavigationBarThemeData? bottomNavigationBarTheme,
    BottomSheetThemeData? bottomSheetTheme,
    ButtonThemeData? buttonTheme,
    Object? cardTheme,
    CheckboxThemeData? checkboxTheme,
    ChipThemeData? chipTheme,
    DataTableThemeData? dataTableTheme,
    DatePickerThemeData? datePickerTheme,
    // TODO(QuncCccccc): Change the parameter type to DialogThemeData
    Object? dialogTheme,
    DividerThemeData? dividerTheme,
    DrawerThemeData? drawerTheme,
    DropdownMenuThemeData? dropdownMenuTheme,
    ElevatedButtonThemeData? elevatedButtonTheme,
    ExpansionTileThemeData? expansionTileTheme,
    FilledButtonThemeData? filledButtonTheme,
    FloatingActionButtonThemeData? floatingActionButtonTheme,
    IconButtonThemeData? iconButtonTheme,
    ListTileThemeData? listTileTheme,
    MenuBarThemeData? menuBarTheme,
    MenuButtonThemeData? menuButtonTheme,
    MenuThemeData? menuTheme,
    NavigationBarThemeData? navigationBarTheme,
    NavigationDrawerThemeData? navigationDrawerTheme,
    NavigationRailThemeData? navigationRailTheme,
    OutlinedButtonThemeData? outlinedButtonTheme,
    PopupMenuThemeData? popupMenuTheme,
    ProgressIndicatorThemeData? progressIndicatorTheme,
    RadioThemeData? radioTheme,
    SearchBarThemeData? searchBarTheme,
    SearchViewThemeData? searchViewTheme,
    SegmentedButtonThemeData? segmentedButtonTheme,
    SliderThemeData? sliderTheme,
    SnackBarThemeData? snackBarTheme,
    SwitchThemeData? switchTheme,
    // TODO(QuncCccccc): Change the parameter type to TabBarThemeData
    Object? tabBarTheme,
    TextButtonThemeData? textButtonTheme,
    TextSelectionThemeData? textSelectionTheme,
    TimePickerThemeData? timePickerTheme,
    ToggleButtonsThemeData? toggleButtonsTheme,
    TooltipThemeData? tooltipTheme,
    // DEPRECATED (newest deprecations at the bottom)
    @Deprecated(
      'Use a ThemeData constructor (.from, .light, or .dark) instead. '
      'These constructors all have a useMaterial3 argument, '
      'and they set appropriate default values based on its value. '
      'See the useMaterial3 API documentation for full details. '
      'This feature was deprecated after v3.13.0-0.2.pre.',
    )
    bool? useMaterial3,
    @Deprecated(
      'Use OverflowBar instead. '
      'This feature was deprecated after v3.21.0-10.0.pre.',
    )
    ButtonBarThemeData? buttonBarTheme,
    @Deprecated(
      'Use DialogThemeData.backgroundColor instead. '
      'This feature was deprecated after v3.27.0-0.1.pre.',
    )
    Color? dialogBackgroundColor,
  }) {
    cupertinoOverrideTheme = cupertinoOverrideTheme?.noDefault();

    // TODO(QuncCccccc): Clean it up once the type of `cardTheme` is changed to `CardThemeData`
    if (cardTheme != null) {
      if (cardTheme is CardTheme) {
        cardTheme = cardTheme.data;
      } else if (cardTheme is! CardThemeData) {
        throw ArgumentError('cardTheme must be either a CardThemeData or a CardTheme');
      }
    }

    // TODO(QuncCccccc): Clean this up once the type of `dialogTheme` is changed to `DialogThemeData`
    if (dialogTheme != null) {
      if (dialogTheme is DialogTheme) {
        dialogTheme = dialogTheme.data;
      } else if (dialogTheme is! DialogThemeData) {
        throw ArgumentError('dialogTheme must be either a DialogThemeData or a DialogTheme');
      }
    }

    // TODO(QuncCccccc): Clean this up once the type of `tabBarTheme` is changed to `TabBarThemeData`
    if (tabBarTheme != null) {
      if (tabBarTheme is TabBarTheme) {
        tabBarTheme = tabBarTheme.data;
      } else if (tabBarTheme is! TabBarThemeData) {
        throw ArgumentError('tabBarTheme must be either a TabBarThemeData or a TabBarTheme');
      }
    }
    return ThemeData.raw(
      // For the sanity of the reader, make sure these properties are in the same
      // order in every place that they are separated by section comments (e.g.
      // GENERAL CONFIGURATION). Each section except for deprecations should be
      // alphabetical by symbol name.

      // GENERAL CONFIGURATION
      adaptationMap: adaptations != null ? _createAdaptationMap(adaptations) : adaptationMap,
      applyElevationOverlayColor: applyElevationOverlayColor ?? this.applyElevationOverlayColor,
      cupertinoOverrideTheme: cupertinoOverrideTheme ?? this.cupertinoOverrideTheme,
      extensions: (extensions != null) ? _themeExtensionIterableToMap(extensions) : this.extensions,
      inputDecorationTheme: inputDecorationTheme ?? this.inputDecorationTheme,
      materialTapTargetSize: materialTapTargetSize ?? this.materialTapTargetSize,
      pageTransitionsTheme: pageTransitionsTheme ?? this.pageTransitionsTheme,
      platform: platform ?? this.platform,
      scrollbarTheme: scrollbarTheme ?? this.scrollbarTheme,
      splashFactory: splashFactory ?? this.splashFactory,
      // When deprecated useMaterial3 removed, maintain `this.useMaterial3` here
      // for == evaluation.
      useMaterial3: useMaterial3 ?? this.useMaterial3,
      visualDensity: visualDensity ?? this.visualDensity,
      // COLOR
      canvasColor: canvasColor ?? this.canvasColor,
      cardColor: cardColor ?? this.cardColor,
      colorScheme: (colorScheme ?? this.colorScheme).copyWith(brightness: brightness),
      disabledColor: disabledColor ?? this.disabledColor,
      dividerColor: dividerColor ?? this.dividerColor,
      focusColor: focusColor ?? this.focusColor,
      highlightColor: highlightColor ?? this.highlightColor,
      hintColor: hintColor ?? this.hintColor,
      hoverColor: hoverColor ?? this.hoverColor,
      indicatorColor: indicatorColor ?? this.indicatorColor,
      primaryColor: primaryColor ?? this.primaryColor,
      primaryColorDark: primaryColorDark ?? this.primaryColorDark,
      primaryColorLight: primaryColorLight ?? this.primaryColorLight,
      scaffoldBackgroundColor: scaffoldBackgroundColor ?? this.scaffoldBackgroundColor,
      secondaryHeaderColor: secondaryHeaderColor ?? this.secondaryHeaderColor,
      shadowColor: shadowColor ?? this.shadowColor,
      splashColor: splashColor ?? this.splashColor,
      unselectedWidgetColor: unselectedWidgetColor ?? this.unselectedWidgetColor,
      // TYPOGRAPHY & ICONOGRAPHY
      iconTheme: iconTheme ?? this.iconTheme,
      primaryIconTheme: primaryIconTheme ?? this.primaryIconTheme,
      primaryTextTheme: primaryTextTheme ?? this.primaryTextTheme,
      textTheme: textTheme ?? this.textTheme,
      typography: typography ?? this.typography,
      // COMPONENT THEMES
      actionIconTheme: actionIconTheme ?? this.actionIconTheme,
      appBarTheme: appBarTheme ?? this.appBarTheme,
      badgeTheme: badgeTheme ?? this.badgeTheme,
      bannerTheme: bannerTheme ?? this.bannerTheme,
      bottomAppBarTheme: bottomAppBarTheme ?? this.bottomAppBarTheme,
      bottomNavigationBarTheme: bottomNavigationBarTheme ?? this.bottomNavigationBarTheme,
      bottomSheetTheme: bottomSheetTheme ?? this.bottomSheetTheme,
      buttonTheme: buttonTheme ?? this.buttonTheme,
      cardTheme: cardTheme as CardThemeData? ?? this.cardTheme,
      checkboxTheme: checkboxTheme ?? this.checkboxTheme,
      chipTheme: chipTheme ?? this.chipTheme,
      dataTableTheme: dataTableTheme ?? this.dataTableTheme,
      datePickerTheme: datePickerTheme ?? this.datePickerTheme,
      dialogTheme: dialogTheme as DialogThemeData? ?? this.dialogTheme,
      dividerTheme: dividerTheme ?? this.dividerTheme,
      drawerTheme: drawerTheme ?? this.drawerTheme,
      dropdownMenuTheme: dropdownMenuTheme ?? this.dropdownMenuTheme,
      elevatedButtonTheme: elevatedButtonTheme ?? this.elevatedButtonTheme,
      expansionTileTheme: expansionTileTheme ?? this.expansionTileTheme,
      filledButtonTheme: filledButtonTheme ?? this.filledButtonTheme,
      floatingActionButtonTheme: floatingActionButtonTheme ?? this.floatingActionButtonTheme,
      iconButtonTheme: iconButtonTheme ?? this.iconButtonTheme,
      listTileTheme: listTileTheme ?? this.listTileTheme,
      menuBarTheme: menuBarTheme ?? this.menuBarTheme,
      menuButtonTheme: menuButtonTheme ?? this.menuButtonTheme,
      menuTheme: menuTheme ?? this.menuTheme,
      navigationBarTheme: navigationBarTheme ?? this.navigationBarTheme,
      navigationDrawerTheme: navigationDrawerTheme ?? this.navigationDrawerTheme,
      navigationRailTheme: navigationRailTheme ?? this.navigationRailTheme,
      outlinedButtonTheme: outlinedButtonTheme ?? this.outlinedButtonTheme,
      popupMenuTheme: popupMenuTheme ?? this.popupMenuTheme,
      progressIndicatorTheme: progressIndicatorTheme ?? this.progressIndicatorTheme,
      radioTheme: radioTheme ?? this.radioTheme,
      searchBarTheme: searchBarTheme ?? this.searchBarTheme,
      searchViewTheme: searchViewTheme ?? this.searchViewTheme,
      segmentedButtonTheme: segmentedButtonTheme ?? this.segmentedButtonTheme,
      sliderTheme: sliderTheme ?? this.sliderTheme,
      snackBarTheme: snackBarTheme ?? this.snackBarTheme,
      switchTheme: switchTheme ?? this.switchTheme,
      tabBarTheme: tabBarTheme as TabBarThemeData? ?? this.tabBarTheme,
      textButtonTheme: textButtonTheme ?? this.textButtonTheme,
      textSelectionTheme: textSelectionTheme ?? this.textSelectionTheme,
      timePickerTheme: timePickerTheme ?? this.timePickerTheme,
      toggleButtonsTheme: toggleButtonsTheme ?? this.toggleButtonsTheme,
      tooltipTheme: tooltipTheme ?? this.tooltipTheme,
      // DEPRECATED (newest deprecations at the bottom)
      buttonBarTheme: buttonBarTheme ?? _buttonBarTheme,
      dialogBackgroundColor: dialogBackgroundColor ?? this.dialogBackgroundColor,
    );
  }

  // The number 5 was chosen without any real science or research behind it. It
  // just seemed like a number that's not too big (we should be able to fit 5
  // copies of ThemeData in memory comfortably) and not too small (most apps
  // shouldn't have more than 5 theme/localization pairs).
  static const int _localizedThemeDataCacheSize = 5;

  /// Caches localized themes to speed up the [localize] method.
  static final _FifoCache<_IdentityThemeDataCacheKey, ThemeData> _localizedThemeDataCache =
      _FifoCache<_IdentityThemeDataCacheKey, ThemeData>(_localizedThemeDataCacheSize);

  /// Returns a new theme built by merging the text geometry provided by the
  /// [localTextGeometry] theme with the [baseTheme].
  ///
  /// For those text styles in the [baseTheme] whose [TextStyle.inherit] is set
  /// to true, the returned theme's text styles inherit the geometric properties
  /// of [localTextGeometry]. The resulting text styles' [TextStyle.inherit] is
  /// set to those provided by [localTextGeometry].
  static ThemeData localize(ThemeData baseTheme, TextTheme localTextGeometry) {
    // WARNING: this method memoizes the result in a cache based on the
    // previously seen baseTheme and localTextGeometry. Memoization is safe
    // because all inputs and outputs of this function are deeply immutable, and
    // the computations are referentially transparent. It only short-circuits
    // the computation if the new inputs are identical() to the previous ones.
    // It does not use the == operator, which performs a costly deep comparison.
    //
    // When changing this method, make sure the memoization logic is correct.
    // Remember:
    //
    // There are only two hard things in Computer Science: cache invalidation
    // and naming things. -- Phil Karlton

    return _localizedThemeDataCache.putIfAbsent(
      _IdentityThemeDataCacheKey(baseTheme, localTextGeometry),
      () {
        return baseTheme.copyWith(
          primaryTextTheme: localTextGeometry.merge(baseTheme.primaryTextTheme),
          textTheme: localTextGeometry.merge(baseTheme.textTheme),
        );
      },
    );
  }

  /// Determines whether the given [Color] is [Brightness.light] or
  /// [Brightness.dark].
  ///
  /// This compares the luminosity of the given color to a threshold value that
  /// matches the Material Design specification.
  static Brightness estimateBrightnessForColor(Color color) {
    final double relativeLuminance = color.computeLuminance();

    // See <https://www.w3.org/TR/WCAG20/#contrast-ratiodef>
    // The spec says to use kThreshold=0.0525, but Material Design appears to bias
    // more towards using light text than WCAG20 recommends. Material Design spec
    // doesn't say what value to use, but 0.15 seemed close to what the Material
    // Design spec shows for its color palette on
    // <https://material.io/go/design-theming#color-color-palette>.
    const double kThreshold = 0.15;
    if ((relativeLuminance + 0.05) * (relativeLuminance + 0.05) > kThreshold) {
      return Brightness.light;
    }
    return Brightness.dark;
  }

  /// Linearly interpolate between two [extensions].
  ///
  /// Includes all theme extensions in [a] and [b].
  ///
  /// {@macro dart.ui.shadow.lerp}
  static Map<Object, ThemeExtension<dynamic>> _lerpThemeExtensions(
    ThemeData a,
    ThemeData b,
    double t,
  ) {
    // Lerp [a].
    final Map<Object, ThemeExtension<dynamic>> newExtensions = a.extensions.map((
      Object id,
      ThemeExtension<dynamic> extensionA,
    ) {
      final ThemeExtension<dynamic>? extensionB = b.extensions[id];
      return MapEntry<Object, ThemeExtension<dynamic>>(id, extensionA.lerp(extensionB, t));
    });
    // Add [b]-only extensions.
    newExtensions.addEntries(
      b.extensions.entries.where(
        (MapEntry<Object, ThemeExtension<dynamic>> entry) => !a.extensions.containsKey(entry.key),
      ),
    );

    return newExtensions;
  }

  /// Convert the [extensionsIterable] passed to [ThemeData.new] or [copyWith]
  /// to the stored [extensions] map, where each entry's key consists of the extension's type.
  static Map<Object, ThemeExtension<dynamic>> _themeExtensionIterableToMap(
    Iterable<ThemeExtension<dynamic>> extensionsIterable,
  ) {
    return Map<Object, ThemeExtension<dynamic>>.unmodifiable(<Object, ThemeExtension<dynamic>>{
      // Strangely, the cast is necessary for tests to run.
      for (final ThemeExtension<dynamic> extension in extensionsIterable)
        extension.type: extension as ThemeExtension<ThemeExtension<dynamic>>,
    });
  }

  /// Linearly interpolate between two themes.
  ///
  /// {@macro dart.ui.shadow.lerp}
  static ThemeData lerp(ThemeData a, ThemeData b, double t) {
    if (identical(a, b)) {
      return a;
    }
    return ThemeData.raw(
      // For the sanity of the reader, make sure these properties are in the same
      // order in every place that they are separated by section comments (e.g.
      // GENERAL CONFIGURATION). Each section except for deprecations should be
      // alphabetical by symbol name.

      // GENERAL CONFIGURATION
      adaptationMap: t < 0.5 ? a.adaptationMap : b.adaptationMap,
      applyElevationOverlayColor:
          t < 0.5 ? a.applyElevationOverlayColor : b.applyElevationOverlayColor,
      cupertinoOverrideTheme: t < 0.5 ? a.cupertinoOverrideTheme : b.cupertinoOverrideTheme,
      extensions: _lerpThemeExtensions(a, b, t),
      inputDecorationTheme: t < 0.5 ? a.inputDecorationTheme : b.inputDecorationTheme,
      materialTapTargetSize: t < 0.5 ? a.materialTapTargetSize : b.materialTapTargetSize,
      pageTransitionsTheme: t < 0.5 ? a.pageTransitionsTheme : b.pageTransitionsTheme,
      platform: t < 0.5 ? a.platform : b.platform,
      scrollbarTheme: ScrollbarThemeData.lerp(a.scrollbarTheme, b.scrollbarTheme, t),
      splashFactory: t < 0.5 ? a.splashFactory : b.splashFactory,
      useMaterial3: t < 0.5 ? a.useMaterial3 : b.useMaterial3,
      visualDensity: VisualDensity.lerp(a.visualDensity, b.visualDensity, t),
      // COLOR
      canvasColor: Color.lerp(a.canvasColor, b.canvasColor, t)!,
      cardColor: Color.lerp(a.cardColor, b.cardColor, t)!,
      colorScheme: ColorScheme.lerp(a.colorScheme, b.colorScheme, t),
      disabledColor: Color.lerp(a.disabledColor, b.disabledColor, t)!,
      dividerColor: Color.lerp(a.dividerColor, b.dividerColor, t)!,
      focusColor: Color.lerp(a.focusColor, b.focusColor, t)!,
      highlightColor: Color.lerp(a.highlightColor, b.highlightColor, t)!,
      hintColor: Color.lerp(a.hintColor, b.hintColor, t)!,
      hoverColor: Color.lerp(a.hoverColor, b.hoverColor, t)!,
      indicatorColor: Color.lerp(a.indicatorColor, b.indicatorColor, t)!,
      primaryColor: Color.lerp(a.primaryColor, b.primaryColor, t)!,
      primaryColorDark: Color.lerp(a.primaryColorDark, b.primaryColorDark, t)!,
      primaryColorLight: Color.lerp(a.primaryColorLight, b.primaryColorLight, t)!,
      scaffoldBackgroundColor: Color.lerp(a.scaffoldBackgroundColor, b.scaffoldBackgroundColor, t)!,
      secondaryHeaderColor: Color.lerp(a.secondaryHeaderColor, b.secondaryHeaderColor, t)!,
      shadowColor: Color.lerp(a.shadowColor, b.shadowColor, t)!,
      splashColor: Color.lerp(a.splashColor, b.splashColor, t)!,
      unselectedWidgetColor: Color.lerp(a.unselectedWidgetColor, b.unselectedWidgetColor, t)!,
      // TYPOGRAPHY & ICONOGRAPHY
      iconTheme: IconThemeData.lerp(a.iconTheme, b.iconTheme, t),
      primaryIconTheme: IconThemeData.lerp(a.primaryIconTheme, b.primaryIconTheme, t),
      primaryTextTheme: TextTheme.lerp(a.primaryTextTheme, b.primaryTextTheme, t),
      textTheme: TextTheme.lerp(a.textTheme, b.textTheme, t),
      typography: Typography.lerp(a.typography, b.typography, t),
      // COMPONENT THEMES
      actionIconTheme: ActionIconThemeData.lerp(a.actionIconTheme, b.actionIconTheme, t),
      appBarTheme: AppBarTheme.lerp(a.appBarTheme, b.appBarTheme, t),
      badgeTheme: BadgeThemeData.lerp(a.badgeTheme, b.badgeTheme, t),
      bannerTheme: MaterialBannerThemeData.lerp(a.bannerTheme, b.bannerTheme, t),
      bottomAppBarTheme: BottomAppBarTheme.lerp(a.bottomAppBarTheme, b.bottomAppBarTheme, t),
      bottomNavigationBarTheme: BottomNavigationBarThemeData.lerp(
        a.bottomNavigationBarTheme,
        b.bottomNavigationBarTheme,
        t,
      ),
      bottomSheetTheme: BottomSheetThemeData.lerp(a.bottomSheetTheme, b.bottomSheetTheme, t)!,
      buttonTheme: t < 0.5 ? a.buttonTheme : b.buttonTheme,
      cardTheme: CardThemeData.lerp(a.cardTheme, b.cardTheme, t),
      checkboxTheme: CheckboxThemeData.lerp(a.checkboxTheme, b.checkboxTheme, t),
      chipTheme: ChipThemeData.lerp(a.chipTheme, b.chipTheme, t)!,
      dataTableTheme: DataTableThemeData.lerp(a.dataTableTheme, b.dataTableTheme, t),
      datePickerTheme: DatePickerThemeData.lerp(a.datePickerTheme, b.datePickerTheme, t),
      dialogTheme: DialogThemeData.lerp(a.dialogTheme, b.dialogTheme, t),
      dividerTheme: DividerThemeData.lerp(a.dividerTheme, b.dividerTheme, t),
      drawerTheme: DrawerThemeData.lerp(a.drawerTheme, b.drawerTheme, t)!,
      dropdownMenuTheme: DropdownMenuThemeData.lerp(a.dropdownMenuTheme, b.dropdownMenuTheme, t),
      elevatedButtonTheme:
          ElevatedButtonThemeData.lerp(a.elevatedButtonTheme, b.elevatedButtonTheme, t)!,
      expansionTileTheme:
          ExpansionTileThemeData.lerp(a.expansionTileTheme, b.expansionTileTheme, t)!,
      filledButtonTheme: FilledButtonThemeData.lerp(a.filledButtonTheme, b.filledButtonTheme, t)!,
      floatingActionButtonTheme:
          FloatingActionButtonThemeData.lerp(
            a.floatingActionButtonTheme,
            b.floatingActionButtonTheme,
            t,
          )!,
      iconButtonTheme: IconButtonThemeData.lerp(a.iconButtonTheme, b.iconButtonTheme, t)!,
      listTileTheme: ListTileThemeData.lerp(a.listTileTheme, b.listTileTheme, t)!,
      menuBarTheme: MenuBarThemeData.lerp(a.menuBarTheme, b.menuBarTheme, t)!,
      menuButtonTheme: MenuButtonThemeData.lerp(a.menuButtonTheme, b.menuButtonTheme, t)!,
      menuTheme: MenuThemeData.lerp(a.menuTheme, b.menuTheme, t)!,
      navigationBarTheme:
          NavigationBarThemeData.lerp(a.navigationBarTheme, b.navigationBarTheme, t)!,
      navigationDrawerTheme:
          NavigationDrawerThemeData.lerp(a.navigationDrawerTheme, b.navigationDrawerTheme, t)!,
      navigationRailTheme:
          NavigationRailThemeData.lerp(a.navigationRailTheme, b.navigationRailTheme, t)!,
      outlinedButtonTheme:
          OutlinedButtonThemeData.lerp(a.outlinedButtonTheme, b.outlinedButtonTheme, t)!,
      popupMenuTheme: PopupMenuThemeData.lerp(a.popupMenuTheme, b.popupMenuTheme, t)!,
      progressIndicatorTheme:
          ProgressIndicatorThemeData.lerp(a.progressIndicatorTheme, b.progressIndicatorTheme, t)!,
      radioTheme: RadioThemeData.lerp(a.radioTheme, b.radioTheme, t),
      searchBarTheme: SearchBarThemeData.lerp(a.searchBarTheme, b.searchBarTheme, t)!,
      searchViewTheme: SearchViewThemeData.lerp(a.searchViewTheme, b.searchViewTheme, t)!,
      segmentedButtonTheme: SegmentedButtonThemeData.lerp(
        a.segmentedButtonTheme,
        b.segmentedButtonTheme,
        t,
      ),
      sliderTheme: SliderThemeData.lerp(a.sliderTheme, b.sliderTheme, t),
      snackBarTheme: SnackBarThemeData.lerp(a.snackBarTheme, b.snackBarTheme, t),
      switchTheme: SwitchThemeData.lerp(a.switchTheme, b.switchTheme, t),
      tabBarTheme: TabBarThemeData.lerp(a.tabBarTheme, b.tabBarTheme, t),
      textButtonTheme: TextButtonThemeData.lerp(a.textButtonTheme, b.textButtonTheme, t)!,
      textSelectionTheme:
          TextSelectionThemeData.lerp(a.textSelectionTheme, b.textSelectionTheme, t)!,
      timePickerTheme: TimePickerThemeData.lerp(a.timePickerTheme, b.timePickerTheme, t),
      toggleButtonsTheme:
          ToggleButtonsThemeData.lerp(a.toggleButtonsTheme, b.toggleButtonsTheme, t)!,
      tooltipTheme: TooltipThemeData.lerp(a.tooltipTheme, b.tooltipTheme, t)!,
      // DEPRECATED (newest deprecations at the bottom)
      buttonBarTheme: ButtonBarThemeData.lerp(a.buttonBarTheme, b.buttonBarTheme, t),
      dialogBackgroundColor: Color.lerp(a.dialogBackgroundColor, b.dialogBackgroundColor, t)!,
    );
  }

  @override
  bool operator ==(Object other) {
    if (other.runtimeType != runtimeType) {
      return false;
    }
    return other is ThemeData &&
        // For the sanity of the reader, make sure these properties are in the same
        // order in every place that they are separated by section comments (e.g.
        // GENERAL CONFIGURATION). Each section except for deprecations should be
        // alphabetical by symbol name.
        // GENERAL CONFIGURATION
        mapEquals(other.adaptationMap, adaptationMap) &&
        other.applyElevationOverlayColor == applyElevationOverlayColor &&
        other.cupertinoOverrideTheme == cupertinoOverrideTheme &&
        mapEquals(other.extensions, extensions) &&
        other.inputDecorationTheme == inputDecorationTheme &&
        other.materialTapTargetSize == materialTapTargetSize &&
        other.pageTransitionsTheme == pageTransitionsTheme &&
        other.platform == platform &&
        other.scrollbarTheme == scrollbarTheme &&
        other.splashFactory == splashFactory &&
        other.useMaterial3 == useMaterial3 &&
        other.visualDensity == visualDensity &&
        // COLOR
        other.canvasColor == canvasColor &&
        other.cardColor == cardColor &&
        other.colorScheme == colorScheme &&
        other.disabledColor == disabledColor &&
        other.dividerColor == dividerColor &&
        other.focusColor == focusColor &&
        other.highlightColor == highlightColor &&
        other.hintColor == hintColor &&
        other.hoverColor == hoverColor &&
        other.indicatorColor == indicatorColor &&
        other.primaryColor == primaryColor &&
        other.primaryColorDark == primaryColorDark &&
        other.primaryColorLight == primaryColorLight &&
        other.scaffoldBackgroundColor == scaffoldBackgroundColor &&
        other.secondaryHeaderColor == secondaryHeaderColor &&
        other.shadowColor == shadowColor &&
        other.splashColor == splashColor &&
        other.unselectedWidgetColor == unselectedWidgetColor &&
        // TYPOGRAPHY & ICONOGRAPHY
        other.iconTheme == iconTheme &&
        other.primaryIconTheme == primaryIconTheme &&
        other.primaryTextTheme == primaryTextTheme &&
        other.textTheme == textTheme &&
        other.typography == typography &&
        // COMPONENT THEMES
        other.actionIconTheme == actionIconTheme &&
        other.appBarTheme == appBarTheme &&
        other.badgeTheme == badgeTheme &&
        other.bannerTheme == bannerTheme &&
        other.bottomAppBarTheme == bottomAppBarTheme &&
        other.bottomNavigationBarTheme == bottomNavigationBarTheme &&
        other.bottomSheetTheme == bottomSheetTheme &&
        other.buttonTheme == buttonTheme &&
        other.cardTheme == cardTheme &&
        other.checkboxTheme == checkboxTheme &&
        other.chipTheme == chipTheme &&
        other.dataTableTheme == dataTableTheme &&
        other.datePickerTheme == datePickerTheme &&
        other.dialogTheme == dialogTheme &&
        other.dividerTheme == dividerTheme &&
        other.drawerTheme == drawerTheme &&
        other.dropdownMenuTheme == dropdownMenuTheme &&
        other.elevatedButtonTheme == elevatedButtonTheme &&
        other.expansionTileTheme == expansionTileTheme &&
        other.filledButtonTheme == filledButtonTheme &&
        other.floatingActionButtonTheme == floatingActionButtonTheme &&
        other.iconButtonTheme == iconButtonTheme &&
        other.listTileTheme == listTileTheme &&
        other.menuBarTheme == menuBarTheme &&
        other.menuButtonTheme == menuButtonTheme &&
        other.menuTheme == menuTheme &&
        other.navigationBarTheme == navigationBarTheme &&
        other.navigationDrawerTheme == navigationDrawerTheme &&
        other.navigationRailTheme == navigationRailTheme &&
        other.outlinedButtonTheme == outlinedButtonTheme &&
        other.popupMenuTheme == popupMenuTheme &&
        other.progressIndicatorTheme == progressIndicatorTheme &&
        other.radioTheme == radioTheme &&
        other.searchBarTheme == searchBarTheme &&
        other.searchViewTheme == searchViewTheme &&
        other.segmentedButtonTheme == segmentedButtonTheme &&
        other.sliderTheme == sliderTheme &&
        other.snackBarTheme == snackBarTheme &&
        other.switchTheme == switchTheme &&
        other.tabBarTheme == tabBarTheme &&
        other.textButtonTheme == textButtonTheme &&
        other.textSelectionTheme == textSelectionTheme &&
        other.timePickerTheme == timePickerTheme &&
        other.toggleButtonsTheme == toggleButtonsTheme &&
        other.tooltipTheme == tooltipTheme &&
        // DEPRECATED (newest deprecations at the bottom)
        other.buttonBarTheme == buttonBarTheme &&
        other.dialogBackgroundColor == dialogBackgroundColor;
  }

  @override
  int get hashCode {
    final List<Object?> values = <Object?>[
      // For the sanity of the reader, make sure these properties are in the same
      // order in every place that they are separated by section comments (e.g.
      // GENERAL CONFIGURATION). Each section except for deprecations should be
      // alphabetical by symbol name.

      // GENERAL CONFIGURATION
      ...adaptationMap.keys,
      ...adaptationMap.values,
      applyElevationOverlayColor,
      cupertinoOverrideTheme,
      ...extensions.keys,
      ...extensions.values,
      inputDecorationTheme,
      materialTapTargetSize,
      pageTransitionsTheme,
      platform,
      scrollbarTheme,
      splashFactory,
      useMaterial3,
      visualDensity,
      // COLOR
      canvasColor,
      cardColor,
      colorScheme,
      disabledColor,
      dividerColor,
      focusColor,
      highlightColor,
      hintColor,
      hoverColor,
      indicatorColor,
      primaryColor,
      primaryColorDark,
      primaryColorLight,
      scaffoldBackgroundColor,
      secondaryHeaderColor,
      shadowColor,
      splashColor,
      unselectedWidgetColor,
      // TYPOGRAPHY & ICONOGRAPHY
      iconTheme,
      primaryIconTheme,
      primaryTextTheme,
      textTheme,
      typography,
      // COMPONENT THEMES
      actionIconTheme,
      appBarTheme,
      badgeTheme,
      bannerTheme,
      bottomAppBarTheme,
      bottomNavigationBarTheme,
      bottomSheetTheme,
      buttonTheme,
      cardTheme,
      checkboxTheme,
      chipTheme,
      dataTableTheme,
      datePickerTheme,
      dialogTheme,
      dividerTheme,
      drawerTheme,
      dropdownMenuTheme,
      elevatedButtonTheme,
      expansionTileTheme,
      filledButtonTheme,
      floatingActionButtonTheme,
      iconButtonTheme,
      listTileTheme,
      menuBarTheme,
      menuButtonTheme,
      menuTheme,
      navigationBarTheme,
      navigationDrawerTheme,
      navigationRailTheme,
      outlinedButtonTheme,
      popupMenuTheme,
      progressIndicatorTheme,
      radioTheme,
      searchBarTheme,
      searchViewTheme,
      segmentedButtonTheme,
      sliderTheme,
      snackBarTheme,
      switchTheme,
      tabBarTheme,
      textButtonTheme,
      textSelectionTheme,
      timePickerTheme,
      toggleButtonsTheme,
      tooltipTheme,
      // DEPRECATED (newest deprecations at the bottom)
      buttonBarTheme,
      dialogBackgroundColor,
    ];
    return Object.hashAll(values);
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    final ThemeData defaultData = ThemeData.fallback();
    // For the sanity of the reader, make sure these properties are in the same
    // order in every place that they are separated by section comments (e.g.
    // GENERAL CONFIGURATION). Each section except for deprecations should be
    // alphabetical by symbol name.

    // GENERAL CONFIGURATION
    properties.add(
      IterableProperty<Adaptation<dynamic>>(
        'adaptations',
        adaptationMap.values,
        defaultValue: defaultData.adaptationMap.values,
        level: DiagnosticLevel.debug,
      ),
    );
    properties.add(
      DiagnosticsProperty<bool>(
        'applyElevationOverlayColor',
        applyElevationOverlayColor,
        level: DiagnosticLevel.debug,
      ),
    );
    properties.add(
      DiagnosticsProperty<NoDefaultCupertinoThemeData>(
        'cupertinoOverrideTheme',
        cupertinoOverrideTheme,
        defaultValue: defaultData.cupertinoOverrideTheme,
        level: DiagnosticLevel.debug,
      ),
    );
    properties.add(
      IterableProperty<ThemeExtension<dynamic>>(
        'extensions',
        extensions.values,
        defaultValue: defaultData.extensions.values,
        level: DiagnosticLevel.debug,
      ),
    );
    properties.add(
      DiagnosticsProperty<InputDecorationTheme>(
        'inputDecorationTheme',
        inputDecorationTheme,
        level: DiagnosticLevel.debug,
      ),
    );
    properties.add(
      DiagnosticsProperty<MaterialTapTargetSize>(
        'materialTapTargetSize',
        materialTapTargetSize,
        level: DiagnosticLevel.debug,
      ),
    );
    properties.add(
      DiagnosticsProperty<PageTransitionsTheme>(
        'pageTransitionsTheme',
        pageTransitionsTheme,
        level: DiagnosticLevel.debug,
      ),
    );
    properties.add(
      EnumProperty<TargetPlatform>(
        'platform',
        platform,
        defaultValue: defaultTargetPlatform,
        level: DiagnosticLevel.debug,
      ),
    );
    properties.add(
      DiagnosticsProperty<ScrollbarThemeData>(
        'scrollbarTheme',
        scrollbarTheme,
        defaultValue: defaultData.scrollbarTheme,
        level: DiagnosticLevel.debug,
      ),
    );
    properties.add(
      DiagnosticsProperty<InteractiveInkFeatureFactory>(
        'splashFactory',
        splashFactory,
        defaultValue: defaultData.splashFactory,
        level: DiagnosticLevel.debug,
      ),
    );
    properties.add(
      DiagnosticsProperty<bool>(
        'useMaterial3',
        useMaterial3,
        defaultValue: defaultData.useMaterial3,
        level: DiagnosticLevel.debug,
      ),
    );
    properties.add(
      DiagnosticsProperty<VisualDensity>(
        'visualDensity',
        visualDensity,
        defaultValue: defaultData.visualDensity,
        level: DiagnosticLevel.debug,
      ),
    );
    // COLORS
    properties.add(
      ColorProperty(
        'canvasColor',
        canvasColor,
        defaultValue: defaultData.canvasColor,
        level: DiagnosticLevel.debug,
      ),
    );
    properties.add(
      ColorProperty(
        'cardColor',
        cardColor,
        defaultValue: defaultData.cardColor,
        level: DiagnosticLevel.debug,
      ),
    );
    properties.add(
      DiagnosticsProperty<ColorScheme>(
        'colorScheme',
        colorScheme,
        defaultValue: defaultData.colorScheme,
        level: DiagnosticLevel.debug,
      ),
    );
    properties.add(
      ColorProperty(
        'disabledColor',
        disabledColor,
        defaultValue: defaultData.disabledColor,
        level: DiagnosticLevel.debug,
      ),
    );
    properties.add(
      ColorProperty(
        'dividerColor',
        dividerColor,
        defaultValue: defaultData.dividerColor,
        level: DiagnosticLevel.debug,
      ),
    );
    properties.add(
      ColorProperty(
        'focusColor',
        focusColor,
        defaultValue: defaultData.focusColor,
        level: DiagnosticLevel.debug,
      ),
    );
    properties.add(
      ColorProperty(
        'highlightColor',
        highlightColor,
        defaultValue: defaultData.highlightColor,
        level: DiagnosticLevel.debug,
      ),
    );
    properties.add(
      ColorProperty(
        'hintColor',
        hintColor,
        defaultValue: defaultData.hintColor,
        level: DiagnosticLevel.debug,
      ),
    );
    properties.add(
      ColorProperty(
        'hoverColor',
        hoverColor,
        defaultValue: defaultData.hoverColor,
        level: DiagnosticLevel.debug,
      ),
    );
    properties.add(
      ColorProperty(
        'indicatorColor',
        indicatorColor,
        defaultValue: defaultData.indicatorColor,
        level: DiagnosticLevel.debug,
      ),
    );
    properties.add(
      ColorProperty(
        'primaryColorDark',
        primaryColorDark,
        defaultValue: defaultData.primaryColorDark,
        level: DiagnosticLevel.debug,
      ),
    );
    properties.add(
      ColorProperty(
        'primaryColorLight',
        primaryColorLight,
        defaultValue: defaultData.primaryColorLight,
        level: DiagnosticLevel.debug,
      ),
    );
    properties.add(
      ColorProperty(
        'primaryColor',
        primaryColor,
        defaultValue: defaultData.primaryColor,
        level: DiagnosticLevel.debug,
      ),
    );
    properties.add(
      ColorProperty(
        'scaffoldBackgroundColor',
        scaffoldBackgroundColor,
        defaultValue: defaultData.scaffoldBackgroundColor,
        level: DiagnosticLevel.debug,
      ),
    );
    properties.add(
      ColorProperty(
        'secondaryHeaderColor',
        secondaryHeaderColor,
        defaultValue: defaultData.secondaryHeaderColor,
        level: DiagnosticLevel.debug,
      ),
    );
    properties.add(
      ColorProperty(
        'shadowColor',
        shadowColor,
        defaultValue: defaultData.shadowColor,
        level: DiagnosticLevel.debug,
      ),
    );
    properties.add(
      ColorProperty(
        'splashColor',
        splashColor,
        defaultValue: defaultData.splashColor,
        level: DiagnosticLevel.debug,
      ),
    );
    properties.add(
      ColorProperty(
        'unselectedWidgetColor',
        unselectedWidgetColor,
        defaultValue: defaultData.unselectedWidgetColor,
        level: DiagnosticLevel.debug,
      ),
    );
    // TYPOGRAPHY & ICONOGRAPHY
    properties.add(
      DiagnosticsProperty<IconThemeData>('iconTheme', iconTheme, level: DiagnosticLevel.debug),
    );
    properties.add(
      DiagnosticsProperty<IconThemeData>(
        'primaryIconTheme',
        primaryIconTheme,
        level: DiagnosticLevel.debug,
      ),
    );
    properties.add(
      DiagnosticsProperty<TextTheme>(
        'primaryTextTheme',
        primaryTextTheme,
        level: DiagnosticLevel.debug,
      ),
    );
    properties.add(
      DiagnosticsProperty<TextTheme>('textTheme', textTheme, level: DiagnosticLevel.debug),
    );
    properties.add(
      DiagnosticsProperty<Typography>(
        'typography',
        typography,
        defaultValue: defaultData.typography,
        level: DiagnosticLevel.debug,
      ),
    );
    // COMPONENT THEMES
    properties.add(
      DiagnosticsProperty<ActionIconThemeData>(
        'actionIconTheme',
        actionIconTheme,
        level: DiagnosticLevel.debug,
      ),
    );
    properties.add(
      DiagnosticsProperty<AppBarTheme>(
        'appBarTheme',
        appBarTheme,
        defaultValue: defaultData.appBarTheme,
        level: DiagnosticLevel.debug,
      ),
    );
    properties.add(
      DiagnosticsProperty<BadgeThemeData>(
        'badgeTheme',
        badgeTheme,
        defaultValue: defaultData.badgeTheme,
        level: DiagnosticLevel.debug,
      ),
    );
    properties.add(
      DiagnosticsProperty<MaterialBannerThemeData>(
        'bannerTheme',
        bannerTheme,
        defaultValue: defaultData.bannerTheme,
        level: DiagnosticLevel.debug,
      ),
    );
    properties.add(
      DiagnosticsProperty<BottomAppBarTheme>(
        'bottomAppBarTheme',
        bottomAppBarTheme,
        defaultValue: defaultData.bottomAppBarTheme,
        level: DiagnosticLevel.debug,
      ),
    );
    properties.add(
      DiagnosticsProperty<BottomNavigationBarThemeData>(
        'bottomNavigationBarTheme',
        bottomNavigationBarTheme,
        defaultValue: defaultData.bottomNavigationBarTheme,
        level: DiagnosticLevel.debug,
      ),
    );
    properties.add(
      DiagnosticsProperty<BottomSheetThemeData>(
        'bottomSheetTheme',
        bottomSheetTheme,
        defaultValue: defaultData.bottomSheetTheme,
        level: DiagnosticLevel.debug,
      ),
    );
    properties.add(
      DiagnosticsProperty<ButtonThemeData>(
        'buttonTheme',
        buttonTheme,
        level: DiagnosticLevel.debug,
      ),
    );
    properties.add(
      DiagnosticsProperty<CardThemeData>('cardTheme', cardTheme, level: DiagnosticLevel.debug),
    );
    properties.add(
      DiagnosticsProperty<CheckboxThemeData>(
        'checkboxTheme',
        checkboxTheme,
        defaultValue: defaultData.checkboxTheme,
        level: DiagnosticLevel.debug,
      ),
    );
    properties.add(
      DiagnosticsProperty<ChipThemeData>('chipTheme', chipTheme, level: DiagnosticLevel.debug),
    );
    properties.add(
      DiagnosticsProperty<DataTableThemeData>(
        'dataTableTheme',
        dataTableTheme,
        defaultValue: defaultData.dataTableTheme,
        level: DiagnosticLevel.debug,
      ),
    );
    properties.add(
      DiagnosticsProperty<DatePickerThemeData>(
        'datePickerTheme',
        datePickerTheme,
        defaultValue: defaultData.datePickerTheme,
        level: DiagnosticLevel.debug,
      ),
    );
    properties.add(
      DiagnosticsProperty<DialogThemeData>(
        'dialogTheme',
        dialogTheme,
        defaultValue: defaultData.dialogTheme,
        level: DiagnosticLevel.debug,
      ),
    );
    properties.add(
      DiagnosticsProperty<DividerThemeData>(
        'dividerTheme',
        dividerTheme,
        defaultValue: defaultData.dividerTheme,
        level: DiagnosticLevel.debug,
      ),
    );
    properties.add(
      DiagnosticsProperty<DrawerThemeData>(
        'drawerTheme',
        drawerTheme,
        defaultValue: defaultData.drawerTheme,
        level: DiagnosticLevel.debug,
      ),
    );
    properties.add(
      DiagnosticsProperty<DropdownMenuThemeData>(
        'dropdownMenuTheme',
        dropdownMenuTheme,
        defaultValue: defaultData.dropdownMenuTheme,
        level: DiagnosticLevel.debug,
      ),
    );
    properties.add(
      DiagnosticsProperty<ElevatedButtonThemeData>(
        'elevatedButtonTheme',
        elevatedButtonTheme,
        defaultValue: defaultData.elevatedButtonTheme,
        level: DiagnosticLevel.debug,
      ),
    );
    properties.add(
      DiagnosticsProperty<ExpansionTileThemeData>(
        'expansionTileTheme',
        expansionTileTheme,
        level: DiagnosticLevel.debug,
      ),
    );
    properties.add(
      DiagnosticsProperty<FilledButtonThemeData>(
        'filledButtonTheme',
        filledButtonTheme,
        defaultValue: defaultData.filledButtonTheme,
        level: DiagnosticLevel.debug,
      ),
    );
    properties.add(
      DiagnosticsProperty<FloatingActionButtonThemeData>(
        'floatingActionButtonTheme',
        floatingActionButtonTheme,
        defaultValue: defaultData.floatingActionButtonTheme,
        level: DiagnosticLevel.debug,
      ),
    );
    properties.add(
      DiagnosticsProperty<IconButtonThemeData>(
        'iconButtonTheme',
        iconButtonTheme,
        defaultValue: defaultData.iconButtonTheme,
        level: DiagnosticLevel.debug,
      ),
    );
    properties.add(
      DiagnosticsProperty<ListTileThemeData>(
        'listTileTheme',
        listTileTheme,
        defaultValue: defaultData.listTileTheme,
        level: DiagnosticLevel.debug,
      ),
    );
    properties.add(
      DiagnosticsProperty<MenuBarThemeData>(
        'menuBarTheme',
        menuBarTheme,
        defaultValue: defaultData.menuBarTheme,
        level: DiagnosticLevel.debug,
      ),
    );
    properties.add(
      DiagnosticsProperty<MenuButtonThemeData>(
        'menuButtonTheme',
        menuButtonTheme,
        defaultValue: defaultData.menuButtonTheme,
        level: DiagnosticLevel.debug,
      ),
    );
    properties.add(
      DiagnosticsProperty<MenuThemeData>(
        'menuTheme',
        menuTheme,
        defaultValue: defaultData.menuTheme,
        level: DiagnosticLevel.debug,
      ),
    );
    properties.add(
      DiagnosticsProperty<NavigationBarThemeData>(
        'navigationBarTheme',
        navigationBarTheme,
        defaultValue: defaultData.navigationBarTheme,
        level: DiagnosticLevel.debug,
      ),
    );
    properties.add(
      DiagnosticsProperty<NavigationDrawerThemeData>(
        'navigationDrawerTheme',
        navigationDrawerTheme,
        defaultValue: defaultData.navigationDrawerTheme,
        level: DiagnosticLevel.debug,
      ),
    );
    properties.add(
      DiagnosticsProperty<NavigationRailThemeData>(
        'navigationRailTheme',
        navigationRailTheme,
        defaultValue: defaultData.navigationRailTheme,
        level: DiagnosticLevel.debug,
      ),
    );
    properties.add(
      DiagnosticsProperty<OutlinedButtonThemeData>(
        'outlinedButtonTheme',
        outlinedButtonTheme,
        defaultValue: defaultData.outlinedButtonTheme,
        level: DiagnosticLevel.debug,
      ),
    );
    properties.add(
      DiagnosticsProperty<PopupMenuThemeData>(
        'popupMenuTheme',
        popupMenuTheme,
        defaultValue: defaultData.popupMenuTheme,
        level: DiagnosticLevel.debug,
      ),
    );
    properties.add(
      DiagnosticsProperty<ProgressIndicatorThemeData>(
        'progressIndicatorTheme',
        progressIndicatorTheme,
        defaultValue: defaultData.progressIndicatorTheme,
        level: DiagnosticLevel.debug,
      ),
    );
    properties.add(
      DiagnosticsProperty<RadioThemeData>(
        'radioTheme',
        radioTheme,
        defaultValue: defaultData.radioTheme,
        level: DiagnosticLevel.debug,
      ),
    );
    properties.add(
      DiagnosticsProperty<SearchBarThemeData>(
        'searchBarTheme',
        searchBarTheme,
        defaultValue: defaultData.searchBarTheme,
        level: DiagnosticLevel.debug,
      ),
    );
    properties.add(
      DiagnosticsProperty<SearchViewThemeData>(
        'searchViewTheme',
        searchViewTheme,
        defaultValue: defaultData.searchViewTheme,
        level: DiagnosticLevel.debug,
      ),
    );
    properties.add(
      DiagnosticsProperty<SegmentedButtonThemeData>(
        'segmentedButtonTheme',
        segmentedButtonTheme,
        defaultValue: defaultData.segmentedButtonTheme,
        level: DiagnosticLevel.debug,
      ),
    );
    properties.add(
      DiagnosticsProperty<SliderThemeData>(
        'sliderTheme',
        sliderTheme,
        level: DiagnosticLevel.debug,
      ),
    );
    properties.add(
      DiagnosticsProperty<SnackBarThemeData>(
        'snackBarTheme',
        snackBarTheme,
        defaultValue: defaultData.snackBarTheme,
        level: DiagnosticLevel.debug,
      ),
    );
    properties.add(
      DiagnosticsProperty<SwitchThemeData>(
        'switchTheme',
        switchTheme,
        defaultValue: defaultData.switchTheme,
        level: DiagnosticLevel.debug,
      ),
    );
    properties.add(
      DiagnosticsProperty<TabBarThemeData>(
        'tabBarTheme',
        tabBarTheme,
        level: DiagnosticLevel.debug,
      ),
    );
    properties.add(
      DiagnosticsProperty<TextButtonThemeData>(
        'textButtonTheme',
        textButtonTheme,
        defaultValue: defaultData.textButtonTheme,
        level: DiagnosticLevel.debug,
      ),
    );
    properties.add(
      DiagnosticsProperty<TextSelectionThemeData>(
        'textSelectionTheme',
        textSelectionTheme,
        defaultValue: defaultData.textSelectionTheme,
        level: DiagnosticLevel.debug,
      ),
    );
    properties.add(
      DiagnosticsProperty<TimePickerThemeData>(
        'timePickerTheme',
        timePickerTheme,
        defaultValue: defaultData.timePickerTheme,
        level: DiagnosticLevel.debug,
      ),
    );
    properties.add(
      DiagnosticsProperty<ToggleButtonsThemeData>(
        'toggleButtonsTheme',
        toggleButtonsTheme,
        level: DiagnosticLevel.debug,
      ),
    );
    properties.add(
      DiagnosticsProperty<TooltipThemeData>(
        'tooltipTheme',
        tooltipTheme,
        level: DiagnosticLevel.debug,
      ),
    );
    // DEPRECATED (newest deprecations at the bottom)
    properties.add(
      DiagnosticsProperty<ButtonBarThemeData>(
        'buttonBarTheme',
        buttonBarTheme,
        defaultValue: defaultData.buttonBarTheme,
        level: DiagnosticLevel.debug,
      ),
    );
    properties.add(
      ColorProperty(
        'dialogBackgroundColor',
        dialogBackgroundColor,
        defaultValue: defaultData.dialogBackgroundColor,
        level: DiagnosticLevel.debug,
      ),
    );
  }
}

/// A [CupertinoThemeData] that defers unspecified theme attributes to an
/// upstream Material [ThemeData].
///
/// This type of [CupertinoThemeData] is used by the Material [Theme] to
/// harmonize the [CupertinoTheme] with the material theme's colors and text
/// styles.
///
/// In the most basic case, [ThemeData]'s `cupertinoOverrideTheme` is null and
/// descendant Cupertino widgets' styling is derived from the Material theme.
///
/// To override individual parts of the Material-derived Cupertino styling,
/// `cupertinoOverrideTheme`'s construction parameters can be used.
///
/// To completely decouple the Cupertino styling from Material theme derivation,
/// another [CupertinoTheme] widget can be inserted as a descendant of the
/// Material [Theme]. On a [MaterialApp], this can be done using the `builder`
/// parameter on the constructor.
///
/// See also:
///
///  * [CupertinoThemeData], whose null constructor parameters default to
///    reasonable iOS styling defaults rather than harmonizing with a Material
///    theme.
///  * [Theme], widget which inserts a [CupertinoTheme] with this
///    [MaterialBasedCupertinoThemeData].
// This class subclasses CupertinoThemeData rather than composes one because it
// _is_ a CupertinoThemeData with partially altered behavior. e.g. its textTheme
// is from the superclass and based on the primaryColor but the primaryColor
// comes from the Material theme unless overridden.
class MaterialBasedCupertinoThemeData extends CupertinoThemeData {
  /// Create a [MaterialBasedCupertinoThemeData] based on a Material [ThemeData]
  /// and its `cupertinoOverrideTheme`.
  MaterialBasedCupertinoThemeData({required ThemeData materialTheme})
    : this._(
        materialTheme,
        (materialTheme.cupertinoOverrideTheme ?? const CupertinoThemeData()).noDefault(),
      );

  MaterialBasedCupertinoThemeData._(this._materialTheme, this._cupertinoOverrideTheme)
    : // Pass all values to the superclass so Material-agnostic properties
      // like barBackgroundColor can still behave like a normal
      // CupertinoThemeData.
      super.raw(
        _cupertinoOverrideTheme.brightness,
        _cupertinoOverrideTheme.primaryColor,
        _cupertinoOverrideTheme.primaryContrastingColor,
        _cupertinoOverrideTheme.textTheme,
        _cupertinoOverrideTheme.barBackgroundColor,
        _cupertinoOverrideTheme.scaffoldBackgroundColor,
        _cupertinoOverrideTheme.applyThemeToAll,
      );

  final ThemeData _materialTheme;
  final NoDefaultCupertinoThemeData _cupertinoOverrideTheme;

  @override
  Brightness get brightness => _cupertinoOverrideTheme.brightness ?? _materialTheme.brightness;

  @override
  Color get primaryColor =>
      _cupertinoOverrideTheme.primaryColor ?? _materialTheme.colorScheme.primary;

  @override
  Color get primaryContrastingColor =>
      _cupertinoOverrideTheme.primaryContrastingColor ?? _materialTheme.colorScheme.onPrimary;

  @override
  Color get scaffoldBackgroundColor =>
      _cupertinoOverrideTheme.scaffoldBackgroundColor ?? _materialTheme.scaffoldBackgroundColor;

  /// Copies the [ThemeData]'s `cupertinoOverrideTheme`.
  ///
  /// Only the specified override attributes of the [ThemeData]'s
  /// `cupertinoOverrideTheme` and the newly specified parameters are in the
  /// returned [CupertinoThemeData]. No derived attributes from iOS defaults or
  /// from cascaded Material theme attributes are copied.
  ///
  /// This [copyWith] cannot change the base Material [ThemeData]. To change the
  /// base Material [ThemeData], create a new Material [Theme] and use
  /// [ThemeData.copyWith] on the Material [ThemeData] instead.
  @override
  MaterialBasedCupertinoThemeData copyWith({
    Brightness? brightness,
    Color? primaryColor,
    Color? primaryContrastingColor,
    CupertinoTextThemeData? textTheme,
    Color? barBackgroundColor,
    Color? scaffoldBackgroundColor,
    bool? applyThemeToAll,
  }) {
    return MaterialBasedCupertinoThemeData._(
      _materialTheme,
      _cupertinoOverrideTheme.copyWith(
        brightness: brightness,
        primaryColor: primaryColor,
        primaryContrastingColor: primaryContrastingColor,
        textTheme: textTheme,
        barBackgroundColor: barBackgroundColor,
        scaffoldBackgroundColor: scaffoldBackgroundColor,
        applyThemeToAll: applyThemeToAll,
      ),
    );
  }

  @override
  CupertinoThemeData resolveFrom(BuildContext context) {
    // Only the cupertino override theme part will be resolved.
    // If the color comes from the material theme it's not resolved.
    return MaterialBasedCupertinoThemeData._(
      _materialTheme,
      _cupertinoOverrideTheme.resolveFrom(context),
    );
  }
}

/// A class for creating a Material theme with a color scheme based off of the
/// colors from a [CupertinoThemeData]. This is intended to be used only in the
/// case when a Material widget is unable to find a Material theme in the tree,
/// but is able to find a Cupertino theme. Most often this will occur when a
/// Material widget is used inside of a [CupertinoApp].
///
/// Besides the colors, this theme will use all the defaults from Material's
/// [ThemeData], so if further customization is needed, it is best to manually
/// add a Material [Theme] above the [CupertinoApp].
class CupertinoBasedMaterialThemeData {
  /// Creates a Material theme with a color scheme based off of the colors from
  /// a [CupertinoThemeData].
  CupertinoBasedMaterialThemeData({required CupertinoThemeData themeData})
    : materialTheme = ThemeData(
        colorScheme: ColorScheme.fromSeed(
          seedColor: themeData.primaryColor,
          brightness: themeData.brightness ?? Brightness.light,
          primary: themeData.primaryColor,
          onPrimary: themeData.primaryContrastingColor,
        ),
      );

  /// The Material theme data with colors based on an existing [CupertinoThemeData].
  final ThemeData materialTheme;
}

@immutable
class _IdentityThemeDataCacheKey {
  const _IdentityThemeDataCacheKey(this.baseTheme, this.localTextGeometry);

  final ThemeData baseTheme;
  final TextTheme localTextGeometry;

  // Using XOR to make the hash function as fast as possible (e.g. Jenkins is
  // noticeably slower).
  @override
  int get hashCode => identityHashCode(baseTheme) ^ identityHashCode(localTextGeometry);

  @override
  bool operator ==(Object other) {
    // We are explicitly ignoring the possibility that the types might not
    // match in the interests of speed.
    return other is _IdentityThemeDataCacheKey &&
        identical(other.baseTheme, baseTheme) &&
        identical(other.localTextGeometry, localTextGeometry);
  }
}

/// Cache of objects of limited size that uses the first in first out eviction
/// strategy (a.k.a least recently inserted).
///
/// The key that was inserted before all other keys is evicted first, i.e. the
/// one inserted least recently.
class _FifoCache<K, V> {
  _FifoCache(this._maximumSize) : assert(_maximumSize > 0);

  /// In Dart the map literal uses a linked hash-map implementation, whose keys
  /// are stored such that [Map.keys] returns them in the order they were
  /// inserted.
  final Map<K, V> _cache = <K, V>{};

  /// Maximum number of entries to store in the cache.
  ///
  /// Once this many entries have been cached, the entry inserted least recently
  /// is evicted when adding a new entry.
  final int _maximumSize;

  /// Returns the previously cached value for the given key, if available;
  /// if not, calls the given callback to obtain it first.
  V putIfAbsent(K key, V Function() loader) {
    assert(key != null);
    final V? result = _cache[key];
    if (result != null) {
      return result;
    }
    if (_cache.length == _maximumSize) {
      _cache.remove(_cache.keys.first);
    }
    return _cache[key] = loader();
  }
}

/// Defines the visual density of user interface components.
///
/// Density, in the context of a UI, is the vertical and horizontal
/// "compactness" of the components in the UI. It is unitless, since it means
/// different things to different UI components.
///
/// The default for visual densities is zero for both vertical and horizontal
/// densities, which corresponds to the default visual density of components in
/// the Material Design specification. It does not affect text sizes, icon
/// sizes, or padding values.
///
/// For example, for buttons, it affects the spacing around the child of the
/// button. For lists, it affects the distance between baselines of entries in
/// the list. For chips, it only affects the vertical size, not the horizontal
/// size.
///
/// Here are some examples of widgets that respond to density changes:
///
///  * [Checkbox]
///  * [Chip]
///  * [ElevatedButton]
///  * [IconButton]
///  * [InputDecorator] (which gives density support to [TextField], etc.)
///  * [ListTile]
///  * [MaterialButton]
///  * [OutlinedButton]
///  * [Radio]
///  * [RawMaterialButton]
///  * [TextButton]
///
/// See also:
///
///  * [ThemeData.visualDensity], where this property is used to specify the base
///    horizontal density of Material components.
///  * [Material design guidance on density](https://material.io/design/layout/applying-density.html).
@immutable
class VisualDensity with Diagnosticable {
  /// A const constructor for [VisualDensity].
  ///
  /// The [horizontal] and [vertical] arguments must be in the interval between
  /// [minimumDensity] and [maximumDensity], inclusive.
  const VisualDensity({this.horizontal = 0.0, this.vertical = 0.0})
    : assert(vertical <= maximumDensity),
      assert(vertical >= minimumDensity),
      assert(horizontal <= maximumDensity),
      assert(horizontal >= minimumDensity);

  /// The minimum allowed density.
  static const double minimumDensity = -4.0;

  /// The maximum allowed density.
  static const double maximumDensity = 4.0;

  /// The default profile for [VisualDensity] in [ThemeData].
  ///
  /// This default value represents a visual density that is less dense than
  /// either [comfortable] or [compact], and corresponds to density values of
  /// zero in both axes.
  static const VisualDensity standard = VisualDensity();

  /// The profile for a "comfortable" interpretation of [VisualDensity].
  ///
  /// Individual components will interpret the density value independently,
  /// making themselves more visually dense than [standard] and less dense than
  /// [compact] to different degrees based on the Material Design specification
  /// of the "comfortable" setting for their particular use case.
  ///
  /// It corresponds to a density value of -1 in both axes.
  static const VisualDensity comfortable = VisualDensity(horizontal: -1.0, vertical: -1.0);

  /// The profile for a "compact" interpretation of [VisualDensity].
  ///
  /// Individual components will interpret the density value independently,
  /// making themselves more visually dense than [standard] and [comfortable] to
  /// different degrees based on the Material Design specification of the
  /// "comfortable" setting for their particular use case.
  ///
  /// It corresponds to a density value of -2 in both axes.
  static const VisualDensity compact = VisualDensity(horizontal: -2.0, vertical: -2.0);

  /// Returns a [VisualDensity] that is adaptive based on the current platform
  /// on which the framework is executing, from [defaultTargetPlatform].
  ///
  /// When [defaultTargetPlatform] is a desktop platform, this returns
  /// [compact], and for other platforms, it returns a default-constructed
  /// [VisualDensity].
  ///
  /// See also:
  ///
  /// * [defaultDensityForPlatform] which returns a [VisualDensity] that is
  ///   adaptive based on the platform given to it.
  /// * [defaultTargetPlatform] which returns the platform on which the
  ///   framework is currently executing.
  static VisualDensity get adaptivePlatformDensity =>
      defaultDensityForPlatform(defaultTargetPlatform);

  /// Returns a [VisualDensity] that is adaptive based on the given [platform].
  ///
  /// For desktop platforms, this returns [compact], and for other platforms, it
  /// returns a default-constructed [VisualDensity].
  ///
  /// See also:
  ///
  /// * [adaptivePlatformDensity] which returns a [VisualDensity] that is
  ///   adaptive based on [defaultTargetPlatform].
  static VisualDensity defaultDensityForPlatform(TargetPlatform platform) {
    return switch (platform) {
      TargetPlatform.android || TargetPlatform.iOS || TargetPlatform.fuchsia => standard,
      TargetPlatform.linux || TargetPlatform.macOS || TargetPlatform.windows => compact,
    };
  }

  /// Copy the current [VisualDensity] with the given values replacing the
  /// current values.
  VisualDensity copyWith({double? horizontal, double? vertical}) {
    return VisualDensity(
      horizontal: horizontal ?? this.horizontal,
      vertical: vertical ?? this.vertical,
    );
  }

  /// The horizontal visual density of UI components.
  ///
  /// This property affects only the horizontal spacing between and within
  /// components, to allow for different UI visual densities. It does not affect
  /// text sizes, icon sizes, or padding values. The default value is 0.0,
  /// corresponding to the metrics specified in the Material Design
  /// specification. The value can range from [minimumDensity] to
  /// [maximumDensity], inclusive.
  ///
  /// See also:
  ///
  ///  * [ThemeData.visualDensity], where this property is used to specify the base
  ///    horizontal density of Material components.
  ///  * [Material design guidance on density](https://material.io/design/layout/applying-density.html).
  final double horizontal;

  /// The vertical visual density of UI components.
  ///
  /// This property affects only the vertical spacing between and within
  /// components, to allow for different UI visual densities. It does not affect
  /// text sizes, icon sizes, or padding values. The default value is 0.0,
  /// corresponding to the metrics specified in the Material Design
  /// specification. The value can range from [minimumDensity] to
  /// [maximumDensity], inclusive.
  ///
  /// See also:
  ///
  ///  * [ThemeData.visualDensity], where this property is used to specify the base
  ///    vertical density of Material components.
  ///  * [Material design guidance on density](https://material.io/design/layout/applying-density.html).
  final double vertical;

  /// The base adjustment in logical pixels of the visual density of UI components.
  ///
  /// The input density values are multiplied by a constant to arrive at a base
  /// size adjustment that fits Material Design guidelines.
  ///
  /// Individual components may adjust this value based upon their own
  /// individual interpretation of density.
  Offset get baseSizeAdjustment {
    // The number of logical pixels represented by an increase or decrease in
    // density by one. The Material Design guidelines say to increment/decrement
    // sizes in terms of four pixel increments.
    const double interval = 4.0;

    return Offset(horizontal, vertical) * interval;
  }

  /// Linearly interpolate between two densities.
  static VisualDensity lerp(VisualDensity a, VisualDensity b, double t) {
    if (identical(a, b)) {
      return a;
    }
    return VisualDensity(
      horizontal: lerpDouble(a.horizontal, b.horizontal, t)!,
      vertical: lerpDouble(a.vertical, b.vertical, t)!,
    );
  }

  /// Return a copy of [constraints] whose minimum width and height have been
  /// updated with the [baseSizeAdjustment].
  ///
  /// The resulting minWidth and minHeight values are clamped to not exceed the
  /// maxWidth and maxHeight values, respectively.
  BoxConstraints effectiveConstraints(BoxConstraints constraints) {
    assert(constraints.debugAssertIsValid());
    return constraints.copyWith(
      minWidth: clampDouble(
        constraints.minWidth + baseSizeAdjustment.dx,
        0.0,
        constraints.maxWidth,
      ),
      minHeight: clampDouble(
        constraints.minHeight + baseSizeAdjustment.dy,
        0.0,
        constraints.maxHeight,
      ),
    );
  }

  @override
  bool operator ==(Object other) {
    if (other.runtimeType != runtimeType) {
      return false;
    }
    return other is VisualDensity && other.horizontal == horizontal && other.vertical == vertical;
  }

  @override
  int get hashCode => Object.hash(horizontal, vertical);

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties.add(DoubleProperty('horizontal', horizontal, defaultValue: 0.0));
    properties.add(DoubleProperty('vertical', vertical, defaultValue: 0.0));
  }

  @override
  String toStringShort() {
    return '${super.toStringShort()}(h: ${debugFormatDouble(horizontal)}, v: ${debugFormatDouble(vertical)})';
  }
}

// BEGIN GENERATED TOKEN PROPERTIES - ColorScheme

// Do not edit by hand. The code between the "BEGIN GENERATED" and
// "END GENERATED" comments are generated from data in the Material
// Design token database by the script:
//   dev/tools/gen_defaults/bin/gen_defaults.dart.

// dart format off
const ColorScheme _colorSchemeLightM3 = ColorScheme(
  brightness: Brightness.light,
  primary: Color(0xFF6750A4),
  onPrimary: Color(0xFFFFFFFF),
  primaryContainer: Color(0xFFEADDFF),
  onPrimaryContainer: Color(0xFF4F378B),
  primaryFixed: Color(0xFFEADDFF),
  primaryFixedDim: Color(0xFFD0BCFF),
  onPrimaryFixed: Color(0xFF21005D),
  onPrimaryFixedVariant: Color(0xFF4F378B),
  secondary: Color(0xFF625B71),
  onSecondary: Color(0xFFFFFFFF),
  secondaryContainer: Color(0xFFE8DEF8),
  onSecondaryContainer: Color(0xFF4A4458),
  secondaryFixed: Color(0xFFE8DEF8),
  secondaryFixedDim: Color(0xFFCCC2DC),
  onSecondaryFixed: Color(0xFF1D192B),
  onSecondaryFixedVariant: Color(0xFF4A4458),
  tertiary: Color(0xFF7D5260),
  onTertiary: Color(0xFFFFFFFF),
  tertiaryContainer: Color(0xFFFFD8E4),
  onTertiaryContainer: Color(0xFF633B48),
  tertiaryFixed: Color(0xFFFFD8E4),
  tertiaryFixedDim: Color(0xFFEFB8C8),
  onTertiaryFixed: Color(0xFF31111D),
  onTertiaryFixedVariant: Color(0xFF633B48),
  error: Color(0xFFB3261E),
  onError: Color(0xFFFFFFFF),
  errorContainer: Color(0xFFF9DEDC),
  onErrorContainer: Color(0xFF8C1D18),
  background: Color(0xFFFEF7FF),
  onBackground: Color(0xFF1D1B20),
  surface: Color(0xFFFEF7FF),
  surfaceBright: Color(0xFFFEF7FF),
  surfaceContainerLowest: Color(0xFFFFFFFF),
  surfaceContainerLow: Color(0xFFF7F2FA),
  surfaceContainer: Color(0xFFF3EDF7),
  surfaceContainerHigh: Color(0xFFECE6F0),
  surfaceContainerHighest: Color(0xFFE6E0E9),
  surfaceDim: Color(0xFFDED8E1),
  onSurface: Color(0xFF1D1B20),
  surfaceVariant: Color(0xFFE7E0EC),
  onSurfaceVariant: Color(0xFF49454F),
  outline: Color(0xFF79747E),
  outlineVariant: Color(0xFFCAC4D0),
  shadow: Color(0xFF000000),
  scrim: Color(0xFF000000),
  inverseSurface: Color(0xFF322F35),
  onInverseSurface: Color(0xFFF5EFF7),
  inversePrimary: Color(0xFFD0BCFF),
  // The surfaceTint color is set to the same color as the primary.
  surfaceTint: Color(0xFF6750A4),
);

const ColorScheme _colorSchemeDarkM3 = ColorScheme(
  brightness: Brightness.dark,
  primary: Color(0xFFD0BCFF),
  onPrimary: Color(0xFF381E72),
  primaryContainer: Color(0xFF4F378B),
  onPrimaryContainer: Color(0xFFEADDFF),
  primaryFixed: Color(0xFFEADDFF),
  primaryFixedDim: Color(0xFFD0BCFF),
  onPrimaryFixed: Color(0xFF21005D),
  onPrimaryFixedVariant: Color(0xFF4F378B),
  secondary: Color(0xFFCCC2DC),
  onSecondary: Color(0xFF332D41),
  secondaryContainer: Color(0xFF4A4458),
  onSecondaryContainer: Color(0xFFE8DEF8),
  secondaryFixed: Color(0xFFE8DEF8),
  secondaryFixedDim: Color(0xFFCCC2DC),
  onSecondaryFixed: Color(0xFF1D192B),
  onSecondaryFixedVariant: Color(0xFF4A4458),
  tertiary: Color(0xFFEFB8C8),
  onTertiary: Color(0xFF492532),
  tertiaryContainer: Color(0xFF633B48),
  onTertiaryContainer: Color(0xFFFFD8E4),
  tertiaryFixed: Color(0xFFFFD8E4),
  tertiaryFixedDim: Color(0xFFEFB8C8),
  onTertiaryFixed: Color(0xFF31111D),
  onTertiaryFixedVariant: Color(0xFF633B48),
  error: Color(0xFFF2B8B5),
  onError: Color(0xFF601410),
  errorContainer: Color(0xFF8C1D18),
  onErrorContainer: Color(0xFFF9DEDC),
  background: Color(0xFF141218),
  onBackground: Color(0xFFE6E0E9),
  surface: Color(0xFF141218),
  surfaceBright: Color(0xFF3B383E),
  surfaceContainerLowest: Color(0xFF0F0D13),
  surfaceContainerLow: Color(0xFF1D1B20),
  surfaceContainer: Color(0xFF211F26),
  surfaceContainerHigh: Color(0xFF2B2930),
  surfaceContainerHighest: Color(0xFF36343B),
  surfaceDim: Color(0xFF141218),
  onSurface: Color(0xFFE6E0E9),
  surfaceVariant: Color(0xFF49454F),
  onSurfaceVariant: Color(0xFFCAC4D0),
  outline: Color(0xFF938F99),
  outlineVariant: Color(0xFF49454F),
  shadow: Color(0xFF000000),
  scrim: Color(0xFF000000),
  inverseSurface: Color(0xFFE6E0E9),
  onInverseSurface: Color(0xFF322F35),
  inversePrimary: Color(0xFF6750A4),
  // The surfaceTint color is set to the same color as the primary.
  surfaceTint: Color(0xFFD0BCFF),
);
// dart format on

// END GENERATED TOKEN PROPERTIES - ColorScheme


--- File: packages/flutter/lib/src/material/theme.dart ---
// Copyright 2014 The Flutter Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

/// @docImport 'app.dart';
/// @docImport 'color_scheme.dart';
/// @docImport 'text_theme.dart';
library;

import 'package:flutter/cupertino.dart';
import 'package:flutter/foundation.dart';

import 'material_localizations.dart';
import 'theme_data.dart';
import 'typography.dart';

export 'theme_data.dart' show Brightness, ThemeData;

/// The duration over which theme changes animate by default.
const Duration kThemeAnimationDuration = Duration(milliseconds: 200);

/// Applies a theme to descendant widgets.
///
/// A theme describes the colors and typographic choices of an application.
///
/// {@youtube 560 315 https://www.youtube.com/watch?v=oTvQDJOBXmM}
///
/// Descendant widgets obtain the current theme's [ThemeData] object using
/// [Theme.of]. When a widget uses [Theme.of], it is automatically rebuilt if
/// the theme later changes, so that the changes can be applied.
///
/// The [Theme] widget implies an [IconTheme] widget, set to the value of the
/// [ThemeData.iconTheme] of the [data] for the [Theme].
///
/// See also:
///
///  * [ThemeData], which describes the actual configuration of a theme.
///  * [AnimatedTheme], which animates the [ThemeData] when it changes rather
///    than changing the theme all at once.
///  * [MaterialApp], which includes an [AnimatedTheme] widget configured via
///    the [MaterialApp.theme] argument.
class Theme extends StatelessWidget {
  /// Applies the given theme [data] to [child].
  const Theme({super.key, required this.data, required this.child});

  /// Specifies the color and typography values for descendant widgets.
  final ThemeData data;

  /// The widget below this widget in the tree.
  ///
  /// {@macro flutter.widgets.ProxyWidget.child}
  final Widget child;

  static final ThemeData _kFallbackTheme = ThemeData.fallback();

  /// The data from the closest [Theme] instance that encloses the given
  /// context.
  ///
  /// If the given context is enclosed in a [Localizations] widget providing
  /// [MaterialLocalizations], the returned data is localized according to the
  /// nearest available [MaterialLocalizations].
  ///
  /// Defaults to [ThemeData.fallback] if there is no [Theme] in the given
  /// build context.
  ///
  /// Typical usage is as follows:
  ///
  /// ```dart
  /// @override
  /// Widget build(BuildContext context) {
  ///   return Text(
  ///     'Example',
  ///     style: Theme.of(context).textTheme.titleLarge,
  ///   );
  /// }
  /// ```
  ///
  /// When the [Theme] is actually created in the same `build` function
  /// (possibly indirectly, e.g. as part of a [MaterialApp]), the `context`
  /// argument to the `build` function can't be used to find the [Theme] (since
  /// it's "above" the widget being returned). In such cases, the following
  /// technique with a [Builder] can be used to provide a new scope with a
  /// [BuildContext] that is "under" the [Theme]:
  ///
  /// ```dart
  /// @override
  /// Widget build(BuildContext context) {
  ///   return MaterialApp(
  ///     theme: ThemeData.light(),
  ///     home: Builder(
  ///       // Create an inner BuildContext so that we can refer to
  ///       // the Theme with Theme.of().
  ///       builder: (BuildContext context) {
  ///         return Center(
  ///           child: Text(
  ///             'Example',
  ///             style: Theme.of(context).textTheme.titleLarge,
  ///           ),
  ///         );
  ///       },
  ///     ),
  ///   );
  /// }
  /// ```
  ///
  /// See also:
  ///
  /// * [ColorScheme.of], a convenience method that returns [ThemeData.colorScheme]
  ///   from the closest [Theme] ancestor. (equivalent to `Theme.of(context).colorScheme`).
  /// * [TextTheme.of], a convenience method that returns [ThemeData.textTheme]
  ///   from the closest [Theme] ancestor. (equivalent to `Theme.of(context).textTheme`).
  /// * [IconTheme.of], that returns [ThemeData.iconTheme] from the closest [Theme] or
  ///   [IconThemeData.fallback] if there is no [IconTheme] ancestor.
  static ThemeData of(BuildContext context) {
    final _InheritedTheme? inheritedTheme =
        context.dependOnInheritedWidgetOfExactType<_InheritedTheme>();
    final MaterialLocalizations? localizations = Localizations.of<MaterialLocalizations>(
      context,
      MaterialLocalizations,
    );
    final ScriptCategory category = localizations?.scriptCategory ?? ScriptCategory.englishLike;
    final InheritedCupertinoTheme? inheritedCupertinoTheme =
        context.dependOnInheritedWidgetOfExactType<InheritedCupertinoTheme>();
    final ThemeData theme =
        inheritedTheme?.theme.data ??
        (inheritedCupertinoTheme != null
            ? CupertinoBasedMaterialThemeData(
              themeData: inheritedCupertinoTheme.theme.data,
            ).materialTheme
            : _kFallbackTheme);
    return ThemeData.localize(theme, theme.typography.geometryThemeFor(category));
  }

  // The inherited themes in widgets library can not infer their values from
  // Theme in material library. Wraps the child with these inherited themes to
  // overrides their values directly.
  Widget _wrapsWidgetThemes(BuildContext context, Widget child) {
    final DefaultSelectionStyle selectionStyle = DefaultSelectionStyle.of(context);
    return IconTheme(
      data: data.iconTheme,
      child: DefaultSelectionStyle(
        selectionColor: data.textSelectionTheme.selectionColor ?? selectionStyle.selectionColor,
        cursorColor: data.textSelectionTheme.cursorColor ?? selectionStyle.cursorColor,
        child: child,
      ),
    );
  }

  CupertinoThemeData _inheritedCupertinoThemeData(BuildContext context) {
    final InheritedCupertinoTheme? inheritedTheme =
        context.dependOnInheritedWidgetOfExactType<InheritedCupertinoTheme>();
    return (inheritedTheme?.theme.data ?? MaterialBasedCupertinoThemeData(materialTheme: data))
        .resolveFrom(context);
  }

  @override
  Widget build(BuildContext context) {
    return _InheritedTheme(
      theme: this,
      child: CupertinoTheme(
        // If a CupertinoThemeData doesn't exist, we're using a
        // MaterialBasedCupertinoThemeData here instead of a CupertinoThemeData
        // because it defers some properties to the Material ThemeData.
        data: _inheritedCupertinoThemeData(context),
        child: _wrapsWidgetThemes(context, child),
      ),
    );
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties.add(DiagnosticsProperty<ThemeData>('data', data, showName: false));
  }
}

class _InheritedTheme extends InheritedTheme {
  const _InheritedTheme({required this.theme, required super.child});

  final Theme theme;

  @override
  Widget wrap(BuildContext context, Widget child) {
    return Theme(data: theme.data, child: child);
  }

  @override
  bool updateShouldNotify(_InheritedTheme old) => theme.data != old.theme.data;
}

/// An interpolation between two [ThemeData]s.
///
/// This class specializes the interpolation of [Tween<ThemeData>] to call the
/// [ThemeData.lerp] method.
///
/// See [Tween] for a discussion on how to use interpolation objects.
class ThemeDataTween extends Tween<ThemeData> {
  /// Creates a [ThemeData] tween.
  ///
  /// The [begin] and [end] properties must be non-null before the tween is
  /// first used, but the arguments can be null if the values are going to be
  /// filled in later.
  ThemeDataTween({super.begin, super.end});

  @override
  ThemeData lerp(double t) => ThemeData.lerp(begin!, end!, t);
}

/// Animated version of [Theme] which automatically transitions the colors,
/// etc, over a given duration whenever the given theme changes.
///
/// Here's an illustration of what using this widget looks like, using a [curve]
/// of [Curves.elasticInOut].
/// {@animation 250 266 https://flutter.github.io/assets-for-api-docs/assets/widgets/animated_theme.mp4}
///
/// See also:
///
///  * [Theme], which [AnimatedTheme] uses to actually apply the interpolated
///    theme.
///  * [ThemeData], which describes the actual configuration of a theme.
///  * [MaterialApp], which includes an [AnimatedTheme] widget configured via
///    the [MaterialApp.theme] argument.
class AnimatedTheme extends ImplicitlyAnimatedWidget {
  /// Creates an animated theme.
  ///
  /// By default, the theme transition uses a linear curve.
  const AnimatedTheme({
    super.key,
    required this.data,
    super.curve,
    super.duration = kThemeAnimationDuration,
    super.onEnd,
    required this.child,
  });

  /// Specifies the color and typography values for descendant widgets.
  final ThemeData data;

  /// The widget below this widget in the tree.
  ///
  /// {@macro flutter.widgets.ProxyWidget.child}
  final Widget child;

  @override
  AnimatedWidgetBaseState<AnimatedTheme> createState() => _AnimatedThemeState();
}

class _AnimatedThemeState extends AnimatedWidgetBaseState<AnimatedTheme> {
  ThemeDataTween? _data;

  @override
  void forEachTween(TweenVisitor<dynamic> visitor) {
    _data =
        visitor(_data, widget.data, (dynamic value) => ThemeDataTween(begin: value as ThemeData))!
            as ThemeDataTween;
  }

  @override
  Widget build(BuildContext context) {
    return Theme(data: _data!.evaluate(animation), child: widget.child);
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder description) {
    super.debugFillProperties(description);
    description.add(
      DiagnosticsProperty<ThemeDataTween>('data', _data, showName: false, defaultValue: null),
    );
  }
}


Instructions for the chapter (Generate content in English unless specified otherwise):
- Start with a clear heading (e.g., `# Chapter 1: Theme
`). Use the provided concept name.

- If this is not the first chapter, begin with a brief transition from the previous chapter, referencing it with a proper Markdown link using its name.

- Begin with a high-level motivation explaining what problem this abstraction solves. Start with a central use case as a concrete example. The whole chapter should guide the reader to understand how to solve this use case. Make it very minimal and friendly to beginners.

- If the abstraction is complex, break it down into key concepts. Explain each concept one-by-one in a very beginner-friendly way.

- Explain how to use this abstraction to solve the use case. Give example inputs and outputs for code snippets (if the output isn't values, describe at a high level what will happen).

- Each code block should be BELOW 10 lines! If longer code blocks are needed, break them down into smaller pieces and walk through them one-by-one. Aggresively simplify the code to make it minimal. Use comments to skip non-important implementation details. Each code block should have a beginner friendly explanation right after it.

- Describe the internal implementation to help understand what's under the hood. First provide a non-code or code-light walkthrough on what happens step-by-step when the abstraction is called. It's recommended to use a simple sequenceDiagram with a dummy example - keep it minimal with at most 5 participants to ensure clarity. If participant name has space, use: `participant QP as Query Processing`. .

- Then dive deeper into code for the internal implementation with references to files. Provide example code blocks, but make them similarly simple and beginner-friendly. Explain.

- IMPORTANT: When you need to refer to other core abstractions covered in other chapters, ALWAYS use proper Markdown links like this: [Chapter Title](filename.md). Use the Complete Tutorial Structure above to find the correct filename and the chapter title. Translate the surrounding text.

- Use mermaid diagrams to illustrate complex concepts (```mermaid``` format). .

- Heavily use analogies and examples throughout to help beginners understand.

- End the chapter with a brief conclusion that summarizes what was learned and provides a transition to the next chapter. If there is a next chapter, use a proper Markdown link: [Next Chapter Title](next_chapter_filename).

- Ensure the tone is welcoming and easy for a newcomer to understand.

- Output *only* the Markdown content for this chapter.

Now, directly provide a super beginner-friendly Markdown output (DON'T need ```markdown``` tags):

2025-05-28 18:21:35,509 - INFO - RESPONSE: # Chapter 1: Theme

Welcome to the very first chapter on how to make your Flutter app look great! In this chapter, we're going to talk about a really important concept called `Theme`.

Imagine you're decorating a room. You pick a color palette, decide on the furniture style, and choose the overall "feel" you want the room to have. In Flutter, `Theme` is kind of like applying that master decoration plan (`ThemeData`) to a specific part of your app's screen.

### What Problem Does `Theme` Solve?

Think about building an app with lots of buttons, text, and other visual elements. If you had to set the color, font size, and style for *each* button and *each* piece of text individually, it would be a lot of work! And if you ever wanted to change your app's look (maybe switch from light mode to dark mode), you'd have to update *everything* manually. That sounds like a nightmare!

`Theme` solves this problem by letting you define a set of styles and colors in one place, and then easily apply those styles to different parts of your app. When you change the `Theme`, all the widgets that use that theme will automatically update their appearance. It's like changing the paint color for a whole room with just one click!

### What is `Theme`?

In Flutter, `Theme` is actually a **widget**. Widgets are the building blocks of Flutter apps. The `Theme` widget is a *special* kind of widget because it doesn't just show something on the screen; it influences how the widgets *below* it in the widget tree look.

When you place a `Theme` widget around other widgets, you're essentially telling all those widgets to follow the style rules defined in the `Theme`.

Here's a super simple peek at what using `Theme` looks like:

```dart
MaterialApp(
  home: Scaffold(
    body: Theme( // Here's the Theme widget!
      data: ThemeData( // We'll learn about this in the next chapter!
        primaryColor: Colors.blue,
        // Other style settings...
      ),
      child: Center(
        child: Text(
          'Hello, Themed Text!',
        ),
      ),
    ),
  ),
);
```

In this example, we're wrapping a `Center` widget (which contains a `Text` widget) with a `Theme` widget. We're giving the `Theme` some `data` (we'll dive deep into `ThemeData` in the next chapter!), and this `data` tells it how things like primary colors should look. Any widgets inside this `Theme` that use primary colors will now use the blue color we specified.

### How `Theme` Works (Under the Hood)

You might be wondering how a widget can "talk" to the widgets below it. Flutter uses a system called "Inherited Widgets" for this. `Theme` is an example of an inherited widget.

Think of an inherited widget like a shop sign that everyone in the building can see and use. When a widget needs some information (like what the theme color should be), it "looks up" the widget tree until it finds the nearest `Theme` widget. Then it uses the `data` from that `Theme` widget to style itself.

Here's a simplified idea of how a `Text` widget might get its color:

```mermaid
sequenceDiagram
    participant T as Text Widget
    participant B as BuildContext
    participant TH as Theme Widget
    participant TD as ThemeData

    T->>B: "Hey BuildContext, what's the current theme data?"
    B->>TH: "Nearest Theme widget, what's your data?"
    TH->>TD: "ThemeData object, what's the text color?"
    TD-->>TH: Returns text color
    TH-->>B: Returns text color
    B-->>T: Returns text color
    T->>T: Displays text with that color
```
This diagram shows a `Text` widget asking its `BuildContext` (which connects it to the widget tree) for the theme information. The `BuildContext` then finds the `Theme` widget, which provides the `ThemeData`. The `Text` widget can then use this `ThemeData` to decide how it should look.

The core of this mechanism is the `Theme.of(BuildContext context)` method. This is the standard way for any widget in Flutter to access the theme information from the nearest `Theme` ancestor in the tree. You'll see `Theme.of(context)` very often in Flutter code!

Looking at the `Theme.of` method in the `theme.dart` file, you can see how it uses `context.dependOnInheritedWidgetOfExactType<_InheritedTheme>()` to find the nearest `_InheritedTheme` (which is the internal widget Flutter uses for the `Theme`).

```dart
// From packages/flutter/lib/src/material/theme.dart
static ThemeData of(BuildContext context) {
  final _InheritedTheme? inheritedTheme =
      context.dependOnInheritedWidgetOfExactType<_InheritedTheme>();
  // ... other logic ...
  final ThemeData theme =
      inheritedTheme?.theme.data ??
      // ... fallback logic ...
      _kFallbackTheme;
  return ThemeData.localize(theme, theme.typography.geometryThemeFor(category));
}
```
Don't worry too much about all the details here; the key is that `dependOnInheritedWidgetOfExactType` is the magic that allows a widget to look up the tree and get information from a parent `Theme` widget.

### Applying `Theme` to a Part of Your App

You can use the `Theme` widget to apply different themes to different parts of your app. For example, you might have a standard theme for most of your app, but a specific section might have a slightly different look, perhaps highlighting a special feature.

```dart
// Imagine this is somewhere inside your app's build method
Column(
  children: [
    Text('Regular Text'), // This uses the main app theme
    Theme( // Applying a different theme here
      data: ThemeData(
        primaryColor: Colors.green, // A different color
      ),
      child: ElevatedButton( // This button will use the green primary color
        onPressed: () {},
        child: Text('Green Button'),
      ),
    ),
    Text('More Regular Text'), // This goes back to the main app theme
  ],
)
```

In this example, the `ElevatedButton` inside the second `Theme` widget will use the specified green color for its primary color, while the `Text` widgets will use the colors from the `ThemeData` higher up in the widget tree (likely from your `MaterialApp`).

This ability to apply themes to specific subtrees of your app gives you a lot of flexibility in designing your UI.

### Conclusion

In this chapter, we learned that `Theme` is a fundamental Flutter widget used to apply styles and visual configurations (`ThemeData`) to parts of your application. It helps you manage your app's look in a consistent and efficient way. We saw how `Theme` works using the concept of inherited widgets and how you can apply different themes to different sections of your app.

Now that you have a basic understanding of `Theme`, the next step is to explore what actually *goes inside* the `Theme` widget: the `ThemeData`.

[ThemeData](02_themedata_.md)
2025-05-28 18:21:35,520 - INFO - PROMPT: 
Write a very beginner-friendly tutorial chapter (in Markdown format) for the project `flutter` about the concept: "ThemeData
". This is Chapter 2.

Concept Details:
- Name: ThemeData

- Description:
Imagine `ThemeData` is the master plan for how your app looks. It's a big container holding all the little details about colors, fonts, button styles, and how components should behave. Think of it as the blueprint that dictates the overall visual style of your application, like choosing the color palette and font family for an entire house.


Complete Tutorial Structure:
1. [Theme
](01_theme_.md)
2. [ThemeData
](02_themedata_.md)
3. [ColorScheme
](03_colorscheme_.md)
4. [ThemeExtension
](04_themeextension_.md)
5. [VisualDensity
](05_visualdensity_.md)
6. [MaterialTapTargetSize
](06_materialtaptargetsize_.md)
7. [DynamicSchemeVariant
](07_dynamicschemevariant_.md)

Context from previous chapters:
# Chapter 1: Theme

Welcome to the very first chapter on how to make your Flutter app look great! In this chapter, we're going to talk about a really important concept called `Theme`.

Imagine you're decorating a room. You pick a color palette, decide on the furniture style, and choose the overall "feel" you want the room to have. In Flutter, `Theme` is kind of like applying that master decoration plan (`ThemeData`) to a specific part of your app's screen.

### What Problem Does `Theme` Solve?

Think about building an app with lots of buttons, text, and other visual elements. If you had to set the color, font size, and style for *each* button and *each* piece of text individually, it would be a lot of work! And if you ever wanted to change your app's look (maybe switch from light mode to dark mode), you'd have to update *everything* manually. That sounds like a nightmare!

`Theme` solves this problem by letting you define a set of styles and colors in one place, and then easily apply those styles to different parts of your app. When you change the `Theme`, all the widgets that use that theme will automatically update their appearance. It's like changing the paint color for a whole room with just one click!

### What is `Theme`?

In Flutter, `Theme` is actually a **widget**. Widgets are the building blocks of Flutter apps. The `Theme` widget is a *special* kind of widget because it doesn't just show something on the screen; it influences how the widgets *below* it in the widget tree look.

When you place a `Theme` widget around other widgets, you're essentially telling all those widgets to follow the style rules defined in the `Theme`.

Here's a super simple peek at what using `Theme` looks like:

```dart
MaterialApp(
  home: Scaffold(
    body: Theme( // Here's the Theme widget!
      data: ThemeData( // We'll learn about this in the next chapter!
        primaryColor: Colors.blue,
        // Other style settings...
      ),
      child: Center(
        child: Text(
          'Hello, Themed Text!',
        ),
      ),
    ),
  ),
);
```

In this example, we're wrapping a `Center` widget (which contains a `Text` widget) with a `Theme` widget. We're giving the `Theme` some `data` (we'll dive deep into `ThemeData` in the next chapter!), and this `data` tells it how things like primary colors should look. Any widgets inside this `Theme` that use primary colors will now use the blue color we specified.

### How `Theme` Works (Under the Hood)

You might be wondering how a widget can "talk" to the widgets below it. Flutter uses a system called "Inherited Widgets" for this. `Theme` is an example of an inherited widget.

Think of an inherited widget like a shop sign that everyone in the building can see and use. When a widget needs some information (like what the theme color should be), it "looks up" the widget tree until it finds the nearest `Theme` widget. Then it uses the `data` from that `Theme` widget to style itself.

Here's a simplified idea of how a `Text` widget might get its color:

```mermaid
sequenceDiagram
    participant T as Text Widget
    participant B as BuildContext
    participant TH as Theme Widget
    participant TD as ThemeData

    T->>B: "Hey BuildContext, what's the current theme data?"
    B->>TH: "Nearest Theme widget, what's your data?"
    TH->>TD: "ThemeData object, what's the text color?"
    TD-->>TH: Returns text color
    TH-->>B: Returns text color
    B-->>T: Returns text color
    T->>T: Displays text with that color
```
This diagram shows a `Text` widget asking its `BuildContext` (which connects it to the widget tree) for the theme information. The `BuildContext` then finds the `Theme` widget, which provides the `ThemeData`. The `Text` widget can then use this `ThemeData` to decide how it should look.

The core of this mechanism is the `Theme.of(BuildContext context)` method. This is the standard way for any widget in Flutter to access the theme information from the nearest `Theme` ancestor in the tree. You'll see `Theme.of(context)` very often in Flutter code!

Looking at the `Theme.of` method in the `theme.dart` file, you can see how it uses `context.dependOnInheritedWidgetOfExactType<_InheritedTheme>()` to find the nearest `_InheritedTheme` (which is the internal widget Flutter uses for the `Theme`).

```dart
// From packages/flutter/lib/src/material/theme.dart
static ThemeData of(BuildContext context) {
  final _InheritedTheme? inheritedTheme =
      context.dependOnInheritedWidgetOfExactType<_InheritedTheme>();
  // ... other logic ...
  final ThemeData theme =
      inheritedTheme?.theme.data ??
      // ... fallback logic ...
      _kFallbackTheme;
  return ThemeData.localize(theme, theme.typography.geometryThemeFor(category));
}
```
Don't worry too much about all the details here; the key is that `dependOnInheritedWidgetOfExactType` is the magic that allows a widget to look up the tree and get information from a parent `Theme` widget.

### Applying `Theme` to a Part of Your App

You can use the `Theme` widget to apply different themes to different parts of your app. For example, you might have a standard theme for most of your app, but a specific section might have a slightly different look, perhaps highlighting a special feature.

```dart
// Imagine this is somewhere inside your app's build method
Column(
  children: [
    Text('Regular Text'), // This uses the main app theme
    Theme( // Applying a different theme here
      data: ThemeData(
        primaryColor: Colors.green, // A different color
      ),
      child: ElevatedButton( // This button will use the green primary color
        onPressed: () {},
        child: Text('Green Button'),
      ),
    ),
    Text('More Regular Text'), // This goes back to the main app theme
  ],
)
```

In this example, the `ElevatedButton` inside the second `Theme` widget will use the specified green color for its primary color, while the `Text` widgets will use the colors from the `ThemeData` higher up in the widget tree (likely from your `MaterialApp`).

This ability to apply themes to specific subtrees of your app gives you a lot of flexibility in designing your UI.

### Conclusion

In this chapter, we learned that `Theme` is a fundamental Flutter widget used to apply styles and visual configurations (`ThemeData`) to parts of your application. It helps you manage your app's look in a consistent and efficient way. We saw how `Theme` works using the concept of inherited widgets and how you can apply different themes to different sections of your app.

Now that you have a basic understanding of `Theme`, the next step is to explore what actually *goes inside* the `Theme` widget: the `ThemeData`.

[ThemeData](02_themedata_.md)

Relevant Code Snippets (Code itself remains unchanged):
--- File: packages/flutter/lib/src/material/theme_data.dart ---
// Copyright 2014 The Flutter Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

/// @docImport 'package:flutter/material.dart';
library;

import 'dart:ui' show Color, lerpDouble;

import 'package:flutter/cupertino.dart';
import 'package:flutter/foundation.dart';

import 'action_buttons.dart';
import 'action_icons_theme.dart';
import 'app_bar_theme.dart';
import 'badge_theme.dart';
import 'banner_theme.dart';
import 'bottom_app_bar_theme.dart';
import 'bottom_navigation_bar_theme.dart';
import 'bottom_sheet_theme.dart';
import 'button_bar_theme.dart';
import 'button_theme.dart';
import 'card_theme.dart';
import 'checkbox_theme.dart';
import 'chip_theme.dart';
import 'color_scheme.dart';
import 'colors.dart';
import 'constants.dart';
import 'data_table_theme.dart';
import 'date_picker_theme.dart';
import 'dialog_theme.dart';
import 'divider_theme.dart';
import 'drawer_theme.dart';
import 'dropdown_menu_theme.dart';
import 'elevated_button_theme.dart';
import 'expansion_tile_theme.dart';
import 'filled_button_theme.dart';
import 'floating_action_button_theme.dart';
import 'icon_button_theme.dart';
import 'ink_ripple.dart';
import 'ink_sparkle.dart';
import 'ink_splash.dart';
import 'ink_well.dart' show InteractiveInkFeatureFactory;
import 'input_decorator.dart';
import 'list_tile.dart';
import 'list_tile_theme.dart';
import 'menu_bar_theme.dart';
import 'menu_button_theme.dart';
import 'menu_theme.dart';
import 'navigation_bar_theme.dart';
import 'navigation_drawer_theme.dart';
import 'navigation_rail_theme.dart';
import 'outlined_button_theme.dart';
import 'page_transitions_theme.dart';
import 'popup_menu_theme.dart';
import 'progress_indicator_theme.dart';
import 'radio_theme.dart';
import 'scrollbar_theme.dart';
import 'search_bar_theme.dart';
import 'search_view_theme.dart';
import 'segmented_button_theme.dart';
import 'slider_theme.dart';
import 'snack_bar_theme.dart';
import 'switch_theme.dart';
import 'tab_bar_theme.dart';
import 'text_button_theme.dart';
import 'text_selection_theme.dart';
import 'text_theme.dart';
import 'time_picker_theme.dart';
import 'toggle_buttons_theme.dart';
import 'tooltip_theme.dart';
import 'typography.dart';

export 'package:flutter/services.dart' show Brightness;

// Examples can assume:
// late BuildContext context;

/// Defines a customized theme for components with an `adaptive` factory constructor.
///
/// Currently, only [Switch.adaptive] supports this class.
class Adaptation<T> {
  /// Creates an [Adaptation].
  const Adaptation();

  /// The adaptation's type.
  Type get type => T;

  /// Typically, this is overridden to return an instance of a custom component
  /// ThemeData class, like [SwitchThemeData], instead of the defaultValue.
  ///
  /// Factory constructors that support adaptations - currently only
  /// [Switch.adaptive] - look for a type-specific adaptation in
  /// [ThemeData.adaptationMap] when computing their effective default component
  /// theme. If a matching adaptation is not found, the component may choose to
  /// use a default adaptation. For example, the [Switch.adaptive] component
  /// uses an empty [SwitchThemeData] if a matching adaptation is not found, for
  /// the sake of backwards compatibility.
  ///
  /// {@tool dartpad}
  /// This sample shows how to create and use subclasses of [Adaptation] that
  /// define adaptive [SwitchThemeData]s. The [adapt] method in this example is
  /// overridden to only customize cupertino-style switches, but it can also be
  /// used to customize any other platforms.
  ///
  /// ** See code in examples/api/lib/material/switch/switch.4.dart **
  /// {@end-tool}
  T adapt(ThemeData theme, T defaultValue) => defaultValue;
}

/// An interface that defines custom additions to a [ThemeData] object.
///
/// {@youtube 560 315 https://www.youtube.com/watch?v=8-szcYzFVao}
///
/// Typically used for custom colors. To use, subclass [ThemeExtension],
/// define a number of fields (e.g. [Color]s), and implement the [copyWith] and
/// [lerp] methods. The latter will ensure smooth transitions of properties when
/// switching themes.
///
/// {@tool dartpad}
/// This sample shows how to create and use a subclass of [ThemeExtension] that
/// defines two colors.
///
/// ** See code in examples/api/lib/material/theme/theme_extension.1.dart **
/// {@end-tool}
abstract class ThemeExtension<T extends ThemeExtension<T>> {
  /// Enable const constructor for subclasses.
  const ThemeExtension();

  /// The extension's type.
  Object get type => T;

  /// Creates a copy of this theme extension with the given fields
  /// replaced by the non-null parameter values.
  ThemeExtension<T> copyWith();

  /// Linearly interpolate with another [ThemeExtension] object.
  ///
  /// {@macro dart.ui.shadow.lerp}
  ThemeExtension<T> lerp(covariant ThemeExtension<T>? other, double t);
}

/// Configures the tap target and layout size of certain Material widgets.
///
/// Changing the value in [ThemeData.materialTapTargetSize] will affect the
/// accessibility experience.
///
/// Some of the impacted widgets include:
///
///   * [FloatingActionButton], only the mini tap target size is increased.
///   * [MaterialButton]
///   * [OutlinedButton]
///   * [TextButton]
///   * [ElevatedButton]
///   * [IconButton]
///   * The time picker widget ([showTimePicker])
///   * [SnackBar]
///   * [Chip]
///   * [RawChip]
///   * [InputChip]
///   * [ChoiceChip]
///   * [FilterChip]
///   * [ActionChip]
///   * [Radio]
///   * [Switch]
///   * [Checkbox]
enum MaterialTapTargetSize {
  /// Expands the minimum tap target size to 48px by 48px.
  ///
  /// This is the default value of [ThemeData.materialTapTargetSize] and the
  /// recommended size to conform to Android accessibility scanner
  /// recommendations.
  padded,

  /// Shrinks the tap target size to the minimum provided by the Material
  /// specification.
  shrinkWrap,
}

/// Defines the configuration of the overall visual [Theme] for a [MaterialApp]
/// or a widget subtree within the app.
///
/// The [MaterialApp] theme property can be used to configure the appearance
/// of the entire app. Widget subtrees within an app can override the app's
/// theme by including a [Theme] widget at the top of the subtree.
///
/// Widgets whose appearance should align with the overall theme can obtain the
/// current theme's configuration with [Theme.of]. Material components typically
/// depend exclusively on the [colorScheme] and [textTheme]. These properties
/// are guaranteed to have non-null values.
///
/// The static [Theme.of] method finds the [ThemeData] value specified for the
/// nearest [BuildContext] ancestor. This lookup is inexpensive, essentially
/// just a single HashMap access. It can sometimes be a little confusing
/// because [Theme.of] can not see a [Theme] widget that is defined in the
/// current build method's context. To overcome that, create a new custom widget
/// for the subtree that appears below the new [Theme], or insert a widget
/// that creates a new BuildContext, like [Builder].
///
/// {@tool dartpad}
/// This example demonstrates how a typical [MaterialApp] specifies
/// and uses a custom [Theme]. The theme's [ColorScheme] is based on a
/// single "seed" color and configures itself to match the platform's
/// current light or dark color configuration. The theme overrides the
/// default configuration of [FloatingActionButton] to show how to
/// customize the appearance a class of components.
///
/// ** See code in examples/api/lib/material/theme_data/theme_data.0.dart **
/// {@end-tool}
///
/// See <https://material.io/design/color/> for
/// more discussion on how to pick the right colors.

@immutable
class ThemeData with Diagnosticable {
  /// Create a [ThemeData] that's used to configure a [Theme].
  ///
  /// The [colorScheme] and [textTheme] are used by the Material components to
  /// compute default values for visual properties. The API documentation for
  /// each component widget explains exactly how the defaults are computed.
  ///
  /// When providing a [ColorScheme], apps can either provide one directly
  /// with the [colorScheme] parameter, or have one generated for them by
  /// using the [colorSchemeSeed] and [brightness] parameters. A generated
  /// color scheme will be based on the tones of [colorSchemeSeed] and all of
  /// its contrasting color will meet accessibility guidelines for readability.
  /// (See [ColorScheme.fromSeed] for more details.)
  ///
  /// If the app wants to customize a generated color scheme, it can use
  /// [ColorScheme.fromSeed] directly and then [ColorScheme.copyWith] on the
  /// result to override any colors that need to be replaced. The result of
  /// this can be used as the [colorScheme] directly.
  ///
  /// For historical reasons, instead of using a [colorSchemeSeed] or
  /// [colorScheme], you can provide either a [primaryColor] or [primarySwatch]
  /// to construct the [colorScheme], but the results will not be as complete
  /// as when using generation from a seed color.
  ///
  /// If [colorSchemeSeed] is non-null then [colorScheme], [primaryColor] and
  /// [primarySwatch] must all be null.
  ///
  /// The [textTheme] [TextStyle] colors are black if the color scheme's
  /// brightness is [Brightness.light], and white for [Brightness.dark].
  ///
  /// To override the appearance of specific components, provide
  /// a component theme parameter like [sliderTheme], [toggleButtonsTheme],
  /// or [bottomNavigationBarTheme].
  ///
  /// See also:
  ///
  ///  * [ThemeData.from], which creates a ThemeData from a [ColorScheme].
  ///  * [ThemeData.light], which creates the default light theme.
  ///  * [ThemeData.dark], which creates the default dark theme.
  ///  * [ColorScheme.fromSeed], which is used to create a [ColorScheme] from a seed color.
  factory ThemeData({
    // For the sanity of the reader, make sure these properties are in the same
    // order in every place that they are separated by section comments (e.g.
    // GENERAL CONFIGURATION). Each section except for deprecations should be
    // alphabetical by symbol name.

    // GENERAL CONFIGURATION
    Iterable<Adaptation<Object>>? adaptations,
    bool? applyElevationOverlayColor,
    NoDefaultCupertinoThemeData? cupertinoOverrideTheme,
    Iterable<ThemeExtension<dynamic>>? extensions,
    InputDecorationTheme? inputDecorationTheme,
    MaterialTapTargetSize? materialTapTargetSize,
    PageTransitionsTheme? pageTransitionsTheme,
    TargetPlatform? platform,
    ScrollbarThemeData? scrollbarTheme,
    InteractiveInkFeatureFactory? splashFactory,
    bool? useMaterial3,
    VisualDensity? visualDensity,
    // COLOR
    ColorScheme? colorScheme,
    Brightness? brightness,
    Color? colorSchemeSeed,
    // [colorScheme] is the preferred way to configure colors. The [Color] properties
    // listed below (as well as primarySwatch) will gradually be phased out, see
    // https://github.com/flutter/flutter/issues/91772.
    Color? canvasColor,
    Color? cardColor,
    Color? disabledColor,
    Color? dividerColor,
    Color? focusColor,
    Color? highlightColor,
    Color? hintColor,
    Color? hoverColor,
    Color? indicatorColor,
    Color? primaryColor,
    Color? primaryColorDark,
    Color? primaryColorLight,
    MaterialColor? primarySwatch,
    Color? scaffoldBackgroundColor,
    Color? secondaryHeaderColor,
    Color? shadowColor,
    Color? splashColor,
    Color? unselectedWidgetColor,
    // TYPOGRAPHY & ICONOGRAPHY
    String? fontFamily,
    List<String>? fontFamilyFallback,
    String? package,
    IconThemeData? iconTheme,
    IconThemeData? primaryIconTheme,
    TextTheme? primaryTextTheme,
    TextTheme? textTheme,
    Typography? typography,
    // COMPONENT THEMES
    ActionIconThemeData? actionIconTheme,
    AppBarTheme? appBarTheme,
    BadgeThemeData? badgeTheme,
    MaterialBannerThemeData? bannerTheme,
    BottomAppBarTheme? bottomAppBarTheme,
    BottomNavigationBarThemeData? bottomNavigationBarTheme,
    BottomSheetThemeData? bottomSheetTheme,
    ButtonThemeData? buttonTheme,
    // TODO(QuncCccccc): Change the parameter type to CardThemeData
    Object? cardTheme,
    CheckboxThemeData? checkboxTheme,
    ChipThemeData? chipTheme,
    DataTableThemeData? dataTableTheme,
    DatePickerThemeData? datePickerTheme,
    // TODO(QuncCccccc): Change the parameter type to DialogThemeData
    Object? dialogTheme,
    DividerThemeData? dividerTheme,
    DrawerThemeData? drawerTheme,
    DropdownMenuThemeData? dropdownMenuTheme,
    ElevatedButtonThemeData? elevatedButtonTheme,
    ExpansionTileThemeData? expansionTileTheme,
    FilledButtonThemeData? filledButtonTheme,
    FloatingActionButtonThemeData? floatingActionButtonTheme,
    IconButtonThemeData? iconButtonTheme,
    ListTileThemeData? listTileTheme,
    MenuBarThemeData? menuBarTheme,
    MenuButtonThemeData? menuButtonTheme,
    MenuThemeData? menuTheme,
    NavigationBarThemeData? navigationBarTheme,
    NavigationDrawerThemeData? navigationDrawerTheme,
    NavigationRailThemeData? navigationRailTheme,
    OutlinedButtonThemeData? outlinedButtonTheme,
    PopupMenuThemeData? popupMenuTheme,
    ProgressIndicatorThemeData? progressIndicatorTheme,
    RadioThemeData? radioTheme,
    SearchBarThemeData? searchBarTheme,
    SearchViewThemeData? searchViewTheme,
    SegmentedButtonThemeData? segmentedButtonTheme,
    SliderThemeData? sliderTheme,
    SnackBarThemeData? snackBarTheme,
    SwitchThemeData? switchTheme,
    // TODO(QuncCccccc): Change the parameter type to TabBarThemeData
    Object? tabBarTheme,
    TextButtonThemeData? textButtonTheme,
    TextSelectionThemeData? textSelectionTheme,
    TimePickerThemeData? timePickerTheme,
    ToggleButtonsThemeData? toggleButtonsTheme,
    TooltipThemeData? tooltipTheme,
    // DEPRECATED (newest deprecations at the bottom)
    @Deprecated(
      'Use OverflowBar instead. '
      'This feature was deprecated after v3.21.0-10.0.pre.',
    )
    ButtonBarThemeData? buttonBarTheme,
    @Deprecated(
      'Use DialogThemeData.backgroundColor instead. '
      'This feature was deprecated after v3.27.0-0.1.pre.',
    )
    Color? dialogBackgroundColor,
  }) {
    // GENERAL CONFIGURATION
    cupertinoOverrideTheme = cupertinoOverrideTheme?.noDefault();
    extensions ??= <ThemeExtension<dynamic>>[];
    adaptations ??= <Adaptation<Object>>[];
    inputDecorationTheme ??= const InputDecorationTheme();
    platform ??= defaultTargetPlatform;
    switch (platform) {
      case TargetPlatform.android:
      case TargetPlatform.fuchsia:
      case TargetPlatform.iOS:
        materialTapTargetSize ??= MaterialTapTargetSize.padded;
      case TargetPlatform.linux:
      case TargetPlatform.macOS:
      case TargetPlatform.windows:
        materialTapTargetSize ??= MaterialTapTargetSize.shrinkWrap;
    }
    pageTransitionsTheme ??= const PageTransitionsTheme();
    scrollbarTheme ??= const ScrollbarThemeData();
    visualDensity ??= VisualDensity.defaultDensityForPlatform(platform);
    useMaterial3 ??= true;
    final bool useInkSparkle = platform == TargetPlatform.android && !kIsWeb;
    splashFactory ??=
        useMaterial3
            ? useInkSparkle
                ? InkSparkle.splashFactory
                : InkRipple.splashFactory
            : InkSplash.splashFactory;

    // COLOR
    assert(
      colorScheme?.brightness == null ||
          brightness == null ||
          colorScheme!.brightness == brightness,
      'ThemeData.brightness does not match ColorScheme.brightness. '
      'Either override ColorScheme.brightness or ThemeData.brightness to '
      'match the other.',
    );
    assert(colorSchemeSeed == null || colorScheme == null);
    assert(colorSchemeSeed == null || primarySwatch == null);
    assert(colorSchemeSeed == null || primaryColor == null);
    final Brightness effectiveBrightness =
        brightness ?? colorScheme?.brightness ?? Brightness.light;
    final bool isDark = effectiveBrightness == Brightness.dark;
    if (colorSchemeSeed != null || useMaterial3) {
      if (colorSchemeSeed != null) {
        colorScheme = ColorScheme.fromSeed(
          seedColor: colorSchemeSeed,
          brightness: effectiveBrightness,
        );
      }
      colorScheme ??= isDark ? _colorSchemeDarkM3 : _colorSchemeLightM3;

      // For surfaces that use primary color in light themes and surface color in dark
      final Color primarySurfaceColor = isDark ? colorScheme.surface : colorScheme.primary;
      final Color onPrimarySurfaceColor = isDark ? colorScheme.onSurface : colorScheme.onPrimary;

      // Default some of the color settings to values from the color scheme
      primaryColor ??= primarySurfaceColor;
      canvasColor ??= colorScheme.surface;
      scaffoldBackgroundColor ??= colorScheme.surface;
      cardColor ??= colorScheme.surface;
      dividerColor ??= colorScheme.outline;
      dialogBackgroundColor ??= colorScheme.surface;
      indicatorColor ??= onPrimarySurfaceColor;
      applyElevationOverlayColor ??= brightness == Brightness.dark;
    }
    applyElevationOverlayColor ??= false;
    primarySwatch ??= Colors.blue;
    primaryColor ??= isDark ? Colors.grey[900]! : primarySwatch;
    final Brightness estimatedPrimaryColorBrightness = estimateBrightnessForColor(primaryColor);
    primaryColorLight ??= isDark ? Colors.grey[500]! : primarySwatch[100]!;
    primaryColorDark ??= isDark ? Colors.black : primarySwatch[700]!;
    final bool primaryIsDark = estimatedPrimaryColorBrightness == Brightness.dark;
    focusColor ??= isDark ? Colors.white.withOpacity(0.12) : Colors.black.withOpacity(0.12);
    hoverColor ??= isDark ? Colors.white.withOpacity(0.04) : Colors.black.withOpacity(0.04);
    shadowColor ??= Colors.black;
    canvasColor ??= isDark ? Colors.grey[850]! : Colors.grey[50]!;
    scaffoldBackgroundColor ??= canvasColor;
    cardColor ??= isDark ? Colors.grey[800]! : Colors.white;
    dividerColor ??= isDark ? const Color(0x1FFFFFFF) : const Color(0x1F000000);
    // Create a ColorScheme that is backwards compatible as possible
    // with the existing default ThemeData color values.
    colorScheme ??= ColorScheme.fromSwatch(
      primarySwatch: primarySwatch,
      accentColor: isDark ? Colors.tealAccent[200]! : primarySwatch[500]!,
      cardColor: cardColor,
      backgroundColor: isDark ? Colors.grey[700]! : primarySwatch[200]!,
      errorColor: Colors.red[700],
      brightness: effectiveBrightness,
    );
    unselectedWidgetColor ??= isDark ? Colors.white70 : Colors.black54;
    // Spec doesn't specify a dark theme secondaryHeaderColor, this is a guess.
    secondaryHeaderColor ??= isDark ? Colors.grey[700]! : primarySwatch[50]!;
    indicatorColor ??= colorScheme.secondary == primaryColor ? Colors.white : colorScheme.secondary;
    hintColor ??= isDark ? Colors.white60 : Colors.black.withOpacity(0.6);
    // The default [buttonTheme] is here because it doesn't use the defaults for
    // [disabledColor], [highlightColor], and [splashColor].
    buttonTheme ??= ButtonThemeData(
      colorScheme: colorScheme,
      buttonColor: isDark ? primarySwatch[600]! : Colors.grey[300]!,
      disabledColor: disabledColor,
      focusColor: focusColor,
      hoverColor: hoverColor,
      highlightColor: highlightColor,
      splashColor: splashColor,
      materialTapTargetSize: materialTapTargetSize,
    );
    disabledColor ??= isDark ? Colors.white38 : Colors.black38;
    highlightColor ??= isDark ? const Color(0x40CCCCCC) : const Color(0x66BCBCBC);
    splashColor ??= isDark ? const Color(0x40CCCCCC) : const Color(0x66C8C8C8);

    // TYPOGRAPHY & ICONOGRAPHY
    typography ??=
        useMaterial3
            ? Typography.material2021(platform: platform, colorScheme: colorScheme)
            : Typography.material2014(platform: platform);
    TextTheme defaultTextTheme = isDark ? typography.white : typography.black;
    TextTheme defaultPrimaryTextTheme = primaryIsDark ? typography.white : typography.black;
    if (fontFamily != null) {
      defaultTextTheme = defaultTextTheme.apply(fontFamily: fontFamily);
      defaultPrimaryTextTheme = defaultPrimaryTextTheme.apply(fontFamily: fontFamily);
    }
    if (fontFamilyFallback != null) {
      defaultTextTheme = defaultTextTheme.apply(fontFamilyFallback: fontFamilyFallback);
      defaultPrimaryTextTheme = defaultPrimaryTextTheme.apply(
        fontFamilyFallback: fontFamilyFallback,
      );
    }
    if (package != null) {
      defaultTextTheme = defaultTextTheme.apply(package: package);
      defaultPrimaryTextTheme = defaultPrimaryTextTheme.apply(package: package);
    }
    textTheme = defaultTextTheme.merge(textTheme);
    primaryTextTheme = defaultPrimaryTextTheme.merge(primaryTextTheme);
    iconTheme ??=
        isDark
            ? IconThemeData(color: kDefaultIconLightColor)
            : IconThemeData(color: kDefaultIconDarkColor);
    primaryIconTheme ??=
        primaryIsDark
            ? const IconThemeData(color: Colors.white)
            : const IconThemeData(color: Colors.black);

    // COMPONENT THEMES
    appBarTheme ??= const AppBarTheme();
    badgeTheme ??= const BadgeThemeData();
    bannerTheme ??= const MaterialBannerThemeData();
    bottomAppBarTheme ??= const BottomAppBarTheme();
    bottomNavigationBarTheme ??= const BottomNavigationBarThemeData();
    bottomSheetTheme ??= const BottomSheetThemeData();
    // TODO(QuncCccccc): Clean it up once the type of `cardTheme` is changed to `CardThemeData`
    if (cardTheme != null) {
      if (cardTheme is CardTheme) {
        cardTheme = cardTheme.data;
      } else if (cardTheme is! CardThemeData) {
        throw ArgumentError('cardTheme must be either a CardThemeData or a CardTheme');
      }
    }
    cardTheme ??= const CardThemeData();
    checkboxTheme ??= const CheckboxThemeData();
    chipTheme ??= const ChipThemeData();
    dataTableTheme ??= const DataTableThemeData();
    datePickerTheme ??= const DatePickerThemeData();
    // TODO(QuncCccccc): Clean this up once the type of `dialogTheme` is changed to `DialogThemeData`
    if (dialogTheme != null) {
      if (dialogTheme is DialogTheme) {
        dialogTheme = dialogTheme.data;
      } else if (dialogTheme is! DialogThemeData) {
        throw ArgumentError('dialogTheme must be either a DialogThemeData or a DialogTheme');
      }
    }
    dialogTheme ??= const DialogThemeData();
    dividerTheme ??= const DividerThemeData();
    drawerTheme ??= const DrawerThemeData();
    dropdownMenuTheme ??= const DropdownMenuThemeData();
    elevatedButtonTheme ??= const ElevatedButtonThemeData();
    expansionTileTheme ??= const ExpansionTileThemeData();
    filledButtonTheme ??= const FilledButtonThemeData();
    floatingActionButtonTheme ??= const FloatingActionButtonThemeData();
    iconButtonTheme ??= const IconButtonThemeData();
    listTileTheme ??= const ListTileThemeData();
    menuBarTheme ??= const MenuBarThemeData();
    menuButtonTheme ??= const MenuButtonThemeData();
    menuTheme ??= const MenuThemeData();
    navigationBarTheme ??= const NavigationBarThemeData();
    navigationDrawerTheme ??= const NavigationDrawerThemeData();
    navigationRailTheme ??= const NavigationRailThemeData();
    outlinedButtonTheme ??= const OutlinedButtonThemeData();
    popupMenuTheme ??= const PopupMenuThemeData();
    progressIndicatorTheme ??= const ProgressIndicatorThemeData();
    radioTheme ??= const RadioThemeData();
    searchBarTheme ??= const SearchBarThemeData();
    searchViewTheme ??= const SearchViewThemeData();
    segmentedButtonTheme ??= const SegmentedButtonThemeData();
    sliderTheme ??= const SliderThemeData();
    snackBarTheme ??= const SnackBarThemeData();
    switchTheme ??= const SwitchThemeData();
    // TODO(QuncCccccc): Clean this up once the type of `tabBarTheme` is changed to `TabBarThemeData`
    if (tabBarTheme != null) {
      if (tabBarTheme is TabBarTheme) {
        tabBarTheme = tabBarTheme.data;
      } else if (tabBarTheme is! TabBarThemeData) {
        throw ArgumentError('tabBarTheme must be either a TabBarThemeData or a TabBarTheme');
      }
    }
    tabBarTheme ??= const TabBarThemeData();
    textButtonTheme ??= const TextButtonThemeData();
    textSelectionTheme ??= const TextSelectionThemeData();
    timePickerTheme ??= const TimePickerThemeData();
    toggleButtonsTheme ??= const ToggleButtonsThemeData();
    tooltipTheme ??= const TooltipThemeData();
    // DEPRECATED (newest deprecations at the bottom)
    buttonBarTheme ??= const ButtonBarThemeData();
    dialogBackgroundColor ??= isDark ? Colors.grey[800]! : Colors.white;
    return ThemeData.raw(
      // For the sanity of the reader, make sure these properties are in the same
      // order in every place that they are separated by section comments (e.g.
      // GENERAL CONFIGURATION). Each section except for deprecations should be
      // alphabetical by symbol name.

      // GENERAL CONFIGURATION
      adaptationMap: _createAdaptationMap(adaptations),
      applyElevationOverlayColor: applyElevationOverlayColor,
      cupertinoOverrideTheme: cupertinoOverrideTheme,
      extensions: _themeExtensionIterableToMap(extensions),
      inputDecorationTheme: inputDecorationTheme,
      materialTapTargetSize: materialTapTargetSize,
      pageTransitionsTheme: pageTransitionsTheme,
      platform: platform,
      scrollbarTheme: scrollbarTheme,
      splashFactory: splashFactory,
      useMaterial3: useMaterial3,
      visualDensity: visualDensity,
      // COLOR
      canvasColor: canvasColor,
      cardColor: cardColor,
      colorScheme: colorScheme,
      disabledColor: disabledColor,
      dividerColor: dividerColor,
      focusColor: focusColor,
      highlightColor: highlightColor,
      hintColor: hintColor,
      hoverColor: hoverColor,
      indicatorColor: indicatorColor,
      primaryColor: primaryColor,
      primaryColorDark: primaryColorDark,
      primaryColorLight: primaryColorLight,
      scaffoldBackgroundColor: scaffoldBackgroundColor,
      secondaryHeaderColor: secondaryHeaderColor,
      shadowColor: shadowColor,
      splashColor: splashColor,
      unselectedWidgetColor: unselectedWidgetColor,
      // TYPOGRAPHY & ICONOGRAPHY
      iconTheme: iconTheme,
      primaryTextTheme: primaryTextTheme,
      textTheme: textTheme,
      typography: typography,
      primaryIconTheme: primaryIconTheme,
      // COMPONENT THEMES
      actionIconTheme: actionIconTheme,
      appBarTheme: appBarTheme,
      badgeTheme: badgeTheme,
      bannerTheme: bannerTheme,
      bottomAppBarTheme: bottomAppBarTheme,
      bottomNavigationBarTheme: bottomNavigationBarTheme,
      bottomSheetTheme: bottomSheetTheme,
      buttonTheme: buttonTheme,
      cardTheme: cardTheme as CardThemeData,
      checkboxTheme: checkboxTheme,
      chipTheme: chipTheme,
      dataTableTheme: dataTableTheme,
      datePickerTheme: datePickerTheme,
      dialogTheme: dialogTheme as DialogThemeData,
      dividerTheme: dividerTheme,
      drawerTheme: drawerTheme,
      dropdownMenuTheme: dropdownMenuTheme,
      elevatedButtonTheme: elevatedButtonTheme,
      expansionTileTheme: expansionTileTheme,
      filledButtonTheme: filledButtonTheme,
      floatingActionButtonTheme: floatingActionButtonTheme,
      iconButtonTheme: iconButtonTheme,
      listTileTheme: listTileTheme,
      menuBarTheme: menuBarTheme,
      menuButtonTheme: menuButtonTheme,
      menuTheme: menuTheme,
      navigationBarTheme: navigationBarTheme,
      navigationDrawerTheme: navigationDrawerTheme,
      navigationRailTheme: navigationRailTheme,
      outlinedButtonTheme: outlinedButtonTheme,
      popupMenuTheme: popupMenuTheme,
      progressIndicatorTheme: progressIndicatorTheme,
      radioTheme: radioTheme,
      searchBarTheme: searchBarTheme,
      searchViewTheme: searchViewTheme,
      segmentedButtonTheme: segmentedButtonTheme,
      sliderTheme: sliderTheme,
      snackBarTheme: snackBarTheme,
      switchTheme: switchTheme,
      tabBarTheme: tabBarTheme as TabBarThemeData,
      textButtonTheme: textButtonTheme,
      textSelectionTheme: textSelectionTheme,
      timePickerTheme: timePickerTheme,
      toggleButtonsTheme: toggleButtonsTheme,
      tooltipTheme: tooltipTheme,
      // DEPRECATED (newest deprecations at the bottom)
      buttonBarTheme: buttonBarTheme,
      dialogBackgroundColor: dialogBackgroundColor,
    );
  }

  /// Create a [ThemeData] given a set of exact values. Most values must be
  /// specified. They all must also be non-null except for
  /// [cupertinoOverrideTheme], and deprecated members.
  ///
  /// This will rarely be used directly. It is used by [lerp] to
  /// create intermediate themes based on two themes created with the
  /// [ThemeData] constructor.
  const ThemeData.raw({
    // For the sanity of the reader, make sure these properties are in the same
    // order in every place that they are separated by section comments (e.g.
    // GENERAL CONFIGURATION). Each section except for deprecations should be
    // alphabetical by symbol name.

    // GENERAL CONFIGURATION
    required this.adaptationMap,
    required this.applyElevationOverlayColor,
    required this.cupertinoOverrideTheme,
    required this.extensions,
    required this.inputDecorationTheme,
    required this.materialTapTargetSize,
    required this.pageTransitionsTheme,
    required this.platform,
    required this.scrollbarTheme,
    required this.splashFactory,
    required this.useMaterial3,
    required this.visualDensity,
    // COLOR
    required this.colorScheme,
    // [colorScheme] is the preferred way to configure colors. The [Color] properties
    // listed below (as well as primarySwatch) will gradually be phased out, see
    // https://github.com/flutter/flutter/issues/91772.
    required this.canvasColor,
    required this.cardColor,
    required this.disabledColor,
    required this.dividerColor,
    required this.focusColor,
    required this.highlightColor,
    required this.hintColor,
    required this.hoverColor,
    required this.indicatorColor,
    required this.primaryColor,
    required this.primaryColorDark,
    required this.primaryColorLight,
    required this.scaffoldBackgroundColor,
    required this.secondaryHeaderColor,
    required this.shadowColor,
    required this.splashColor,
    required this.unselectedWidgetColor,
    // TYPOGRAPHY & ICONOGRAPHY
    required this.iconTheme,
    required this.primaryIconTheme,
    required this.primaryTextTheme,
    required this.textTheme,
    required this.typography,
    // COMPONENT THEMES
    required this.actionIconTheme,
    required this.appBarTheme,
    required this.badgeTheme,
    required this.bannerTheme,
    required this.bottomAppBarTheme,
    required this.bottomNavigationBarTheme,
    required this.bottomSheetTheme,
    required this.buttonTheme,
    required this.cardTheme,
    required this.checkboxTheme,
    required this.chipTheme,
    required this.dataTableTheme,
    required this.datePickerTheme,
    required this.dialogTheme,
    required this.dividerTheme,
    required this.drawerTheme,
    required this.dropdownMenuTheme,
    required this.elevatedButtonTheme,
    required this.expansionTileTheme,
    required this.filledButtonTheme,
    required this.floatingActionButtonTheme,
    required this.iconButtonTheme,
    required this.listTileTheme,
    required this.menuBarTheme,
    required this.menuButtonTheme,
    required this.menuTheme,
    required this.navigationBarTheme,
    required this.navigationDrawerTheme,
    required this.navigationRailTheme,
    required this.outlinedButtonTheme,
    required this.popupMenuTheme,
    required this.progressIndicatorTheme,
    required this.radioTheme,
    required this.searchBarTheme,
    required this.searchViewTheme,
    required this.segmentedButtonTheme,
    required this.sliderTheme,
    required this.snackBarTheme,
    required this.switchTheme,
    required this.tabBarTheme,
    required this.textButtonTheme,
    required this.textSelectionTheme,
    required this.timePickerTheme,
    required this.toggleButtonsTheme,
    required this.tooltipTheme,
    // DEPRECATED (newest deprecations at the bottom)
    @Deprecated(
      'Use OverflowBar instead. '
      'This feature was deprecated after v3.21.0-10.0.pre.',
    )
    ButtonBarThemeData? buttonBarTheme,
    @Deprecated(
      'Use DialogThemeData.backgroundColor instead. '
      'This feature was deprecated after v3.27.0-0.1.pre.',
    )
    required this.dialogBackgroundColor,
  }) : // DEPRECATED (newest deprecations at the bottom)
       // should not be `required`, use getter pattern to avoid breakages.
       _buttonBarTheme = buttonBarTheme,
       assert(buttonBarTheme != null);

  /// Create a [ThemeData] based on the colors in the given [colorScheme] and
  /// text styles of the optional [textTheme].
  ///
  /// If [colorScheme].brightness is [Brightness.dark] then
  /// [ThemeData.applyElevationOverlayColor] will be set to true to support
  /// the Material dark theme method for indicating elevation by applying
  /// a semi-transparent onSurface color on top of the surface color.
  ///
  /// This is the recommended method to theme your application. As we move
  /// forward we will be converting all the widget implementations to only use
  /// colors or colors derived from those in [ColorScheme].
  ///
  /// {@tool snippet}
  /// This example will set up an application to use the baseline Material
  /// Design light and dark themes.
  ///
  /// ```dart
  /// MaterialApp(
  ///   theme: ThemeData.from(colorScheme: const ColorScheme.light()),
  ///   darkTheme: ThemeData.from(colorScheme: const ColorScheme.dark()),
  /// )
  /// ```
  /// {@end-tool}
  ///
  /// See <https://material.io/design/color/> for
  /// more discussion on how to pick the right colors.
  factory ThemeData.from({
    required ColorScheme colorScheme,
    TextTheme? textTheme,
    bool? useMaterial3,
  }) {
    final bool isDark = colorScheme.brightness == Brightness.dark;

    // For surfaces that use primary color in light themes and surface color in dark
    final Color primarySurfaceColor = isDark ? colorScheme.surface : colorScheme.primary;
    final Color onPrimarySurfaceColor = isDark ? colorScheme.onSurface : colorScheme.onPrimary;

    return ThemeData(
      colorScheme: colorScheme,
      brightness: colorScheme.brightness,
      primaryColor: primarySurfaceColor,
      canvasColor: colorScheme.surface,
      scaffoldBackgroundColor: colorScheme.surface,
      cardColor: colorScheme.surface,
      dividerColor: colorScheme.onSurface.withOpacity(0.12),
      dialogBackgroundColor: colorScheme.surface,
      indicatorColor: onPrimarySurfaceColor,
      textTheme: textTheme,
      applyElevationOverlayColor: isDark,
      useMaterial3: useMaterial3,
    );
  }

  /// A default light theme.
  ///
  /// This theme does not contain text geometry. Instead, it is expected that
  /// this theme is localized using text geometry using [ThemeData.localize].
  factory ThemeData.light({bool? useMaterial3}) =>
      ThemeData(brightness: Brightness.light, useMaterial3: useMaterial3);

  /// A default dark theme.
  ///
  /// This theme does not contain text geometry. Instead, it is expected that
  /// this theme is localized using text geometry using [ThemeData.localize].
  factory ThemeData.dark({bool? useMaterial3}) =>
      ThemeData(brightness: Brightness.dark, useMaterial3: useMaterial3);

  /// The default color theme. Same as [ThemeData.light].
  ///
  /// This is used by [Theme.of] when no theme has been specified.
  ///
  /// This theme does not contain text geometry. Instead, it is expected that
  /// this theme is localized using text geometry using [ThemeData.localize].
  ///
  /// Most applications would use [Theme.of], which provides correct localized
  /// text geometry.
  factory ThemeData.fallback({bool? useMaterial3}) => ThemeData.light(useMaterial3: useMaterial3);

  /// Used to obtain a particular [Adaptation] from [adaptationMap].
  ///
  /// To get an adaptation, use `Theme.of(context).getAdaptation<MyAdaptation>()`.
  Adaptation<T>? getAdaptation<T>() => adaptationMap[T] as Adaptation<T>?;

  static Map<Type, Adaptation<Object>> _createAdaptationMap(
    Iterable<Adaptation<Object>> adaptations,
  ) {
    final Map<Type, Adaptation<Object>> adaptationMap = <Type, Adaptation<Object>>{
      for (final Adaptation<Object> adaptation in adaptations) adaptation.type: adaptation,
    };
    return adaptationMap;
  }

  /// The overall theme brightness.
  ///
  /// The default [TextStyle] color for the [textTheme] is black if the
  /// theme is constructed with [Brightness.light] and white if the
  /// theme is constructed with [Brightness.dark].
  Brightness get brightness => colorScheme.brightness;

  // For the sanity of the reader, make sure these properties are in the same
  // order in every place that they are separated by section comments (e.g.
  // GENERAL CONFIGURATION). Each section except for deprecations should be
  // alphabetical by symbol name.

  // GENERAL CONFIGURATION

  /// Apply a semi-transparent overlay color on Material surfaces to indicate
  /// elevation for dark themes.
  ///
  /// If [useMaterial3] is true, then this flag is ignored as there is a new
  /// [Material.surfaceTintColor] used to create an overlay for Material 3.
  /// This flag is meant only for the Material 2 elevation overlay for dark
  /// themes.
  ///
  /// Material drop shadows can be difficult to see in a dark theme, so the
  /// elevation of a surface should be portrayed with an "overlay" in addition
  /// to the shadow. As the elevation of the component increases, the
  /// overlay increases in opacity. [applyElevationOverlayColor] turns the
  /// application of this overlay on or off for dark themes.
  ///
  /// If true and [brightness] is [Brightness.dark], a
  /// semi-transparent version of [ColorScheme.onSurface] will be
  /// applied on top of [Material] widgets that have a [ColorScheme.surface]
  /// color. The level of transparency is based on [Material.elevation] as
  /// per the Material Dark theme specification.
  ///
  /// If false the surface color will be used unmodified.
  ///
  /// Defaults to false in order to maintain backwards compatibility with
  /// apps that were built before the Material Dark theme specification
  /// was published. New apps should set this to true for any themes
  /// where [brightness] is [Brightness.dark].
  ///
  /// See also:
  ///
  ///  * [Material.elevation], which effects the level of transparency of the
  ///    overlay color.
  ///  * [ElevationOverlay.applyOverlay], which is used by [Material] to apply
  ///    the overlay color to its surface color.
  ///  * <https://material.io/design/color/dark-theme.html>, which specifies how
  ///    the overlay should be applied.
  final bool applyElevationOverlayColor;

  /// Components of the [CupertinoThemeData] to override from the Material
  /// [ThemeData] adaptation.
  ///
  /// By default, [cupertinoOverrideTheme] is null and Cupertino widgets
  /// descendant to the Material [Theme] will adhere to a [CupertinoTheme]
  /// derived from the Material [ThemeData]. e.g. [ThemeData]'s [ColorScheme]
  /// will also inform the [CupertinoThemeData]'s `primaryColor` etc.
  ///
  /// This cascading effect for individual attributes of the [CupertinoThemeData]
  /// can be overridden using attributes of this [cupertinoOverrideTheme].
  final NoDefaultCupertinoThemeData? cupertinoOverrideTheme;

  /// Arbitrary additions to this theme.
  ///
  /// To define extensions, pass an [Iterable] containing one or more [ThemeExtension]
  /// subclasses to [ThemeData.new] or [copyWith].
  ///
  /// To obtain an extension, use [extension].
  ///
  /// {@tool dartpad}
  /// This sample shows how to create and use a subclass of [ThemeExtension] that
  /// defines two colors.
  ///
  /// ** See code in examples/api/lib/material/theme/theme_extension.1.dart **
  /// {@end-tool}
  ///
  /// See also:
  ///
  /// * [extension], a convenience function for obtaining a specific extension.
  final Map<Object, ThemeExtension<dynamic>> extensions;

  /// Used to obtain a particular [ThemeExtension] from [extensions].
  ///
  /// Obtain with `Theme.of(context).extension<MyThemeExtension>()`.
  ///
  /// See [extensions] for an interactive example.
  T? extension<T>() => extensions[T] as T?;

  /// A map which contains the adaptations for the theme. The entry's key is the
  /// type of the adaptation; the value is the adaptation itself.
  ///
  /// To obtain an adaptation, use [getAdaptation].
  final Map<Type, Adaptation<Object>> adaptationMap;

  /// The default [InputDecoration] values for [InputDecorator], [TextField],
  /// and [TextFormField] are based on this theme.
  ///
  /// See [InputDecoration.applyDefaults].
  final InputDecorationTheme inputDecorationTheme;

  /// Configures the hit test size of certain Material widgets.
  ///
  /// Defaults to a [platform]-appropriate size: [MaterialTapTargetSize.padded]
  /// on mobile platforms, [MaterialTapTargetSize.shrinkWrap] on desktop
  /// platforms.
  final MaterialTapTargetSize materialTapTargetSize;

  /// Default [MaterialPageRoute] transitions per [TargetPlatform].
  ///
  /// [MaterialPageRoute.buildTransitions] delegates to a [platform] specific
  /// [PageTransitionsBuilder]. If a matching builder is not found, a builder
  /// whose platform is null is used.
  final PageTransitionsTheme pageTransitionsTheme;

  /// The platform the material widgets should adapt to target.
  ///
  /// Defaults to the current platform, as exposed by [defaultTargetPlatform].
  /// This should be used in order to style UI elements according to platform
  /// conventions.
  ///
  /// Widgets from the material library should use this getter (via [Theme.of])
  /// to determine the current platform for the purpose of emulating the
  /// platform behavior (e.g. scrolling or haptic effects). Widgets and render
  /// objects at lower layers that try to emulate the underlying platform
  /// can depend on [defaultTargetPlatform] directly, or may require
  /// that the target platform be provided as an argument. The
  /// [dart:io.Platform] object should only be used directly when it's critical
  /// to actually know the current platform, without any overrides possible (for
  /// example, when a system API is about to be called).
  ///
  /// In a test environment, the platform returned is [TargetPlatform.android]
  /// regardless of the host platform. (Android was chosen because the tests
  /// were originally written assuming Android-like behavior, and we added
  /// platform adaptations for other platforms later). Tests can check behavior
  /// for other platforms by setting the [platform] of the [Theme] explicitly to
  /// another [TargetPlatform] value, or by setting
  /// [debugDefaultTargetPlatformOverride].
  ///
  /// Determines the defaults for [typography] and [materialTapTargetSize].
  final TargetPlatform platform;

  /// A theme for customizing the colors, thickness, and shape of [Scrollbar]s.
  final ScrollbarThemeData scrollbarTheme;

  /// Defines the appearance of ink splashes produces by [InkWell]
  /// and [InkResponse].
  ///
  /// See also:
  ///
  ///  * [InkSplash.splashFactory], which defines the default splash.
  ///  * [InkRipple.splashFactory], which defines a splash that spreads out
  ///    more aggressively than the default.
  ///  * [InkSparkle.splashFactory], which defines a more aggressive and organic
  ///    splash with sparkle effects.
  final InteractiveInkFeatureFactory splashFactory;

  /// A temporary flag that can be used to opt-out of Material 3 features.
  ///
  /// This flag is _true_ by default. If false, then components will
  /// continue to use the colors, typography and other features of
  /// Material 2.
  ///
  /// In the long run this flag will be deprecated and eventually
  /// only Material 3 will be supported. We recommend that applications
  /// migrate to Material 3 as soon as that's practical. Until that migration
  /// is complete, this flag can be set to false.
  ///
  /// ## Defaults
  ///
  /// If a [ThemeData] is _constructed_ with [useMaterial3] set to true, then
  /// some properties will get updated defaults. However, the
  /// [ThemeData.copyWith] method with [useMaterial3] set to true will _not_
  /// change any of these properties in the resulting [ThemeData].
  ///
  /// <style>table,td,th { border-collapse: collapse; padding: 0.45em; } td { border: 1px solid }</style>
  ///
  /// | Property        | Material 3 default             | Material 2 default             |
  /// | :-------------- | :----------------------------- | :----------------------------- |
  /// | [colorScheme]   | M3 baseline light color scheme | M2 baseline light color scheme |
  /// | [typography]    | [Typography.material2021]      | [Typography.material2014]      |
  /// | [splashFactory] | [InkSparkle]* or [InkRipple]   | [InkSplash]                    |
  ///
  /// \* if the target platform is Android and the app is not
  /// running on the web, otherwise it will fallback to [InkRipple].
  ///
  /// If [brightness] is [Brightness.dark] then the default color scheme will
  /// be either the M3 baseline dark color scheme or the M2 baseline dark color
  /// scheme depending on [useMaterial3].
  ///
  /// ## Affected widgets
  ///
  /// This flag affects styles and components.
  ///
  /// ### Styles
  ///   * Color: [ColorScheme], [Material] (see table above)
  ///   * Shape: (see components below)
  ///   * Typography: [Typography] (see table above)
  ///
  /// ### Components
  ///   * Badges: [Badge]
  ///   * Bottom app bar: [BottomAppBar]
  ///   * Bottom sheets: [BottomSheet]
  ///   * Buttons
  ///     - Common buttons: [ElevatedButton], [FilledButton], [FilledButton.tonal], [OutlinedButton], [TextButton]
  ///     - FAB: [FloatingActionButton], [FloatingActionButton.extended]
  ///     - Icon buttons: [IconButton], [IconButton.filled] (*new*), [IconButton.filledTonal], [IconButton.outlined]
  ///     - Segmented buttons: [SegmentedButton] (replacing [ToggleButtons])
  ///   * Cards: [Card]
  ///   * Checkbox: [Checkbox], [CheckboxListTile]
  ///   * Chips:
  ///     - [ActionChip] (used for Assist and Suggestion chips),
  ///     - [FilterChip], [ChoiceChip] (used for single selection filter chips),
  ///     - [InputChip]
  ///   * Date pickers: [showDatePicker], [showDateRangePicker], [DatePickerDialog], [DateRangePickerDialog], [InputDatePickerFormField]
  ///   * Dialogs: [AlertDialog], [Dialog.fullscreen]
  ///   * Divider: [Divider], [VerticalDivider]
  ///   * Lists: [ListTile]
  ///   * Menus: [MenuAnchor], [DropdownMenu], [MenuBar]
  ///   * Navigation bar: [NavigationBar] (replacing [BottomNavigationBar])
  ///   * Navigation drawer: [NavigationDrawer] (replacing [Drawer])
  ///   * Navigation rail: [NavigationRail]
  ///   * Progress indicators: [CircularProgressIndicator], [LinearProgressIndicator]
  ///   * Radio button: [Radio], [RadioListTile]
  ///   * Search: [SearchBar], [SearchAnchor],
  ///   * Snack bar: [SnackBar]
  ///   * Slider: [Slider], [RangeSlider]
  ///   * Switch: [Switch], [SwitchListTile]
  ///   * Tabs: [TabBar], [TabBar.secondary]
  ///   * TextFields: [TextField] together with its [InputDecoration]
  ///   * Time pickers: [showTimePicker], [TimePickerDialog]
  ///   * Top app bar: [AppBar], [SliverAppBar], [SliverAppBar.medium], [SliverAppBar.large]
  ///
  /// In addition, this flag enables features introduced in Android 12.
  ///   * Stretch overscroll: [MaterialScrollBehavior]
  ///   * Ripple: `splashFactory` (see table above)
  ///
  /// See also:
  ///
  ///   * [Material 3 specification](https://m3.material.io/).
  final bool useMaterial3;

  /// The density value for specifying the compactness of various UI components.
  ///
  /// {@template flutter.material.themedata.visualDensity}
  /// Density, in the context of a UI, is the vertical and horizontal
  /// "compactness" of the elements in the UI. It is unitless, since it means
  /// different things to different UI elements. For buttons, it affects the
  /// spacing around the centered label of the button. For lists, it affects the
  /// distance between baselines of entries in the list.
  ///
  /// Typically, density values are integral, but any value in range may be
  /// used. The range includes values from [VisualDensity.minimumDensity] (which
  /// is -4), to [VisualDensity.maximumDensity] (which is 4), inclusive, where
  /// negative values indicate a denser, more compact, UI, and positive values
  /// indicate a less dense, more expanded, UI. If a component doesn't support
  /// the value given, it will clamp to the nearest supported value.
  ///
  /// The default for visual densities is zero for both vertical and horizontal
  /// densities, which corresponds to the default visual density of components
  /// in the Material Design specification.
  ///
  /// As a rule of thumb, a change of 1 or -1 in density corresponds to 4
  /// logical pixels. However, this is not a strict relationship since
  /// components interpret the density values appropriately for their needs.
  ///
  /// A larger value translates to a spacing increase (less dense), and a
  /// smaller value translates to a spacing decrease (more dense).
  ///
  /// In Material Design 3, the [visualDensity] does not override the value of
  /// [IconButton.visualDensity] which defaults to [VisualDensity.standard]
  /// for all platforms. To override the default value of [IconButton.visualDensity],
  /// use [ThemeData.iconButtonTheme] instead.
  /// {@endtemplate}
  final VisualDensity visualDensity;

  // COLOR

  /// The default color of [MaterialType.canvas] [Material].
  final Color canvasColor;

  /// The color of [Material] when it is used as a [Card].
  final Color cardColor;

  /// {@macro flutter.material.color_scheme.ColorScheme}
  ///
  /// This property was added much later than the theme's set of highly specific
  /// colors, like [cardColor], [canvasColor] etc. New components can be defined
  /// exclusively in terms of [colorScheme]. Existing components will gradually
  /// migrate to it, to the extent that is possible without significant
  /// backwards compatibility breaks.
  final ColorScheme colorScheme;

  /// The color used for widgets that are inoperative, regardless of
  /// their state. For example, a disabled checkbox (which may be
  /// checked or unchecked).
  final Color disabledColor;

  /// The color of [Divider]s and [PopupMenuDivider]s, also used
  /// between [ListTile]s, between rows in [DataTable]s, and so forth.
  ///
  /// To create an appropriate [BorderSide] that uses this color, consider
  /// [Divider.createBorderSide].
  final Color dividerColor;

  /// The focus color used indicate that a component has the input focus.
  final Color focusColor;

  /// The highlight color used during ink splash animations or to
  /// indicate an item in a menu is selected.
  final Color highlightColor;

  /// The color to use for hint text or placeholder text, e.g. in
  /// [TextField] fields.
  final Color hintColor;

  /// The hover color used to indicate when a pointer is hovering over a
  /// component.
  final Color hoverColor;

  /// The color of the selected tab indicator in a tab bar.
  final Color indicatorColor;

  /// The background color for major parts of the app (toolbars, tab bars, etc)
  ///
  /// The theme's [colorScheme] property contains [ColorScheme.primary], as
  /// well as a color that contrasts well with the primary color called
  /// [ColorScheme.onPrimary]. It might be simpler to just configure an app's
  /// visuals in terms of the theme's [colorScheme].
  final Color primaryColor;

  /// A darker version of the [primaryColor].
  final Color primaryColorDark;

  /// A lighter version of the [primaryColor].
  final Color primaryColorLight;

  /// The default color of the [Material] that underlies the [Scaffold]. The
  /// background color for a typical material app or a page within the app.
  final Color scaffoldBackgroundColor;

  /// The color of the header of a [PaginatedDataTable] when there are selected rows.
  // According to the spec for data tables:
  // https://material.io/archive/guidelines/components/data-tables.html#data-tables-tables-within-cards
  // ...this should be the "50-value of secondary app color".
  final Color secondaryHeaderColor;

  /// The color that the [Material] widget uses to draw elevation shadows.
  ///
  /// Defaults to fully opaque black.
  ///
  /// Shadows can be difficult to see in a dark theme, so the elevation of a
  /// surface should be rendered with an "overlay" in addition to the shadow.
  /// As the elevation of the component increases, the overlay increases in
  /// opacity. The [applyElevationOverlayColor] property turns the elevation
  /// overlay on or off for dark themes.
  final Color shadowColor;

  /// The color of ink splashes.
  ///
  /// See also:
  ///  * [splashFactory], which defines the appearance of the splash.
  final Color splashColor;

  /// The color used for widgets in their inactive (but enabled)
  /// state. For example, an unchecked checkbox. See also [disabledColor].
  final Color unselectedWidgetColor;

  // TYPOGRAPHY & ICONOGRAPHY

  /// An icon theme that contrasts with the card and canvas colors.
  final IconThemeData iconTheme;

  /// An icon theme that contrasts with the primary color.
  final IconThemeData primaryIconTheme;

  /// A text theme that contrasts with the primary color.
  final TextTheme primaryTextTheme;

  /// Text with a color that contrasts with the card and canvas colors.
  final TextTheme textTheme;

  /// The color and geometry [TextTheme] values used to configure [textTheme].
  ///
  /// Defaults to a [platform]-appropriate typography.
  final Typography typography;

  // COMPONENT THEMES

  /// A theme for customizing icons of [BackButtonIcon], [CloseButtonIcon],
  /// [DrawerButtonIcon], or [EndDrawerButtonIcon].
  final ActionIconThemeData? actionIconTheme;

  /// A theme for customizing the color, elevation, brightness, iconTheme and
  /// textTheme of [AppBar]s.
  final AppBarTheme appBarTheme;

  /// A theme for customizing the color of [Badge]s.
  final BadgeThemeData badgeTheme;

  /// A theme for customizing the color and text style of a [MaterialBanner].
  final MaterialBannerThemeData bannerTheme;

  /// A theme for customizing the shape, elevation, and color of a [BottomAppBar].
  final BottomAppBarTheme bottomAppBarTheme;

  /// A theme for customizing the appearance and layout of [BottomNavigationBar]
  /// widgets.
  final BottomNavigationBarThemeData bottomNavigationBarTheme;

  /// A theme for customizing the color, elevation, and shape of a bottom sheet.
  final BottomSheetThemeData bottomSheetTheme;

  /// Defines the default configuration of button widgets, like [DropdownButton]
  /// and [ButtonBar].
  final ButtonThemeData buttonTheme;

  /// The colors and styles used to render [Card].
  ///
  /// This is the value returned from [CardTheme.of].
  final CardThemeData cardTheme;

  /// A theme for customizing the appearance and layout of [Checkbox] widgets.
  final CheckboxThemeData checkboxTheme;

  /// The colors and styles used to render [Chip]s.
  ///
  /// This is the value returned from [ChipTheme.of].
  final ChipThemeData chipTheme;

  /// A theme for customizing the appearance and layout of [DataTable]
  /// widgets.
  final DataTableThemeData dataTableTheme;

  /// A theme for customizing the appearance and layout of [DatePickerDialog]
  /// widgets.
  final DatePickerThemeData datePickerTheme;

  /// A theme for customizing the shape of a dialog.
  final DialogThemeData dialogTheme;

  /// A theme for customizing the color, thickness, and indents of [Divider]s,
  /// [VerticalDivider]s, etc.
  final DividerThemeData dividerTheme;

  /// A theme for customizing the appearance and layout of [Drawer] widgets.
  final DrawerThemeData drawerTheme;

  /// A theme for customizing the appearance and layout of [DropdownMenu] widgets.
  final DropdownMenuThemeData dropdownMenuTheme;

  /// A theme for customizing the appearance and internal layout of
  /// [ElevatedButton]s.
  final ElevatedButtonThemeData elevatedButtonTheme;

  /// A theme for customizing the visual properties of [ExpansionTile]s.
  final ExpansionTileThemeData expansionTileTheme;

  /// A theme for customizing the appearance and internal layout of
  /// [FilledButton]s.
  final FilledButtonThemeData filledButtonTheme;

  /// A theme for customizing the shape, elevation, and color of a
  /// [FloatingActionButton].
  final FloatingActionButtonThemeData floatingActionButtonTheme;

  /// A theme for customizing the appearance and internal layout of
  /// [IconButton]s.
  final IconButtonThemeData iconButtonTheme;

  /// A theme for customizing the appearance of [ListTile] widgets.
  final ListTileThemeData listTileTheme;

  /// A theme for customizing the color, shape, elevation, and other [MenuStyle]
  /// aspects of the menu bar created by the [MenuBar] widget.
  final MenuBarThemeData menuBarTheme;

  /// A theme for customizing the color, shape, elevation, and text style of
  /// cascading menu buttons created by [SubmenuButton] or [MenuItemButton].
  final MenuButtonThemeData menuButtonTheme;

  /// A theme for customizing the color, shape, elevation, and other [MenuStyle]
  /// attributes of menus created by the [SubmenuButton] widget.
  final MenuThemeData menuTheme;

  /// A theme for customizing the background color, text style, and icon themes
  /// of a [NavigationBar].
  final NavigationBarThemeData navigationBarTheme;

  /// A theme for customizing the background color, text style, and icon themes
  /// of a [NavigationDrawer].
  final NavigationDrawerThemeData navigationDrawerTheme;

  /// A theme for customizing the background color, elevation, text style, and
  /// icon themes of a [NavigationRail].
  final NavigationRailThemeData navigationRailTheme;

  /// A theme for customizing the appearance and internal layout of
  /// [OutlinedButton]s.
  final OutlinedButtonThemeData outlinedButtonTheme;

  /// A theme for customizing the color, shape, elevation, and text style of
  /// popup menus.
  final PopupMenuThemeData popupMenuTheme;

  /// A theme for customizing the appearance and layout of [ProgressIndicator] widgets.
  final ProgressIndicatorThemeData progressIndicatorTheme;

  /// A theme for customizing the appearance and layout of [Radio] widgets.
  final RadioThemeData radioTheme;

  /// A theme for customizing the appearance and layout of [SearchBar] widgets.
  final SearchBarThemeData searchBarTheme;

  /// A theme for customizing the appearance and layout of search views created by [SearchAnchor] widgets.
  final SearchViewThemeData searchViewTheme;

  /// A theme for customizing the appearance and layout of [SegmentedButton] widgets.
  final SegmentedButtonThemeData segmentedButtonTheme;

  /// The colors and shapes used to render [Slider].
  ///
  /// This is the value returned from [SliderTheme.of].
  final SliderThemeData sliderTheme;

  /// A theme for customizing colors, shape, elevation, and behavior of a [SnackBar].
  final SnackBarThemeData snackBarTheme;

  /// A theme for customizing the appearance and layout of [Switch] widgets.
  final SwitchThemeData switchTheme;

  /// A theme for customizing the size, shape, and color of the tab bar indicator.
  final TabBarThemeData tabBarTheme;

  /// A theme for customizing the appearance and internal layout of
  /// [TextButton]s.
  final TextButtonThemeData textButtonTheme;

  /// A theme for customizing the appearance and layout of [TextField] widgets.
  final TextSelectionThemeData textSelectionTheme;

  /// A theme for customizing the appearance and layout of time picker widgets.
  final TimePickerThemeData timePickerTheme;

  /// Defines the default configuration of [ToggleButtons] widgets.
  final ToggleButtonsThemeData toggleButtonsTheme;

  /// A theme for customizing the visual properties of [Tooltip]s.
  ///
  /// This is the value returned from [TooltipTheme.of].
  final TooltipThemeData tooltipTheme;

  /// A theme for customizing the appearance and layout of [ButtonBar] widgets.
  @Deprecated(
    'Use OverflowBar instead. '
    'This feature was deprecated after v3.21.0-10.0.pre.',
  )
  ButtonBarThemeData get buttonBarTheme => _buttonBarTheme!;
  final ButtonBarThemeData? _buttonBarTheme;

  /// The background color of [Dialog] elements.
  @Deprecated(
    'Use DialogThemeData.backgroundColor instead. '
    'This feature was deprecated after v3.27.0-0.1.pre.',
  )
  final Color dialogBackgroundColor;

  /// Creates a copy of this theme but with the given fields replaced with the new values.
  ///
  /// The [brightness] value is applied to the [colorScheme].
  ThemeData copyWith({
    // For the sanity of the reader, make sure these properties are in the same
    // order in every place that they are separated by section comments (e.g.
    // GENERAL CONFIGURATION). Each section except for deprecations should be
    // alphabetical by symbol name.

    // GENERAL CONFIGURATION
    Iterable<Adaptation<Object>>? adaptations,
    bool? applyElevationOverlayColor,
    NoDefaultCupertinoThemeData? cupertinoOverrideTheme,
    Iterable<ThemeExtension<dynamic>>? extensions,
    InputDecorationTheme? inputDecorationTheme,
    MaterialTapTargetSize? materialTapTargetSize,
    PageTransitionsTheme? pageTransitionsTheme,
    TargetPlatform? platform,
    ScrollbarThemeData? scrollbarTheme,
    InteractiveInkFeatureFactory? splashFactory,
    VisualDensity? visualDensity,
    // COLOR
    ColorScheme? colorScheme,
    Brightness? brightness,
    // [colorScheme] is the preferred way to configure colors. The [Color] properties
    // listed below (as well as primarySwatch) will gradually be phased out, see
    // https://github.com/flutter/flutter/issues/91772.
    Color? canvasColor,
    Color? cardColor,
    Color? disabledColor,
    Color? dividerColor,
    Color? focusColor,
    Color? highlightColor,
    Color? hintColor,
    Color? hoverColor,
    Color? indicatorColor,
    Color? primaryColor,
    Color? primaryColorDark,
    Color? primaryColorLight,
    Color? scaffoldBackgroundColor,
    Color? secondaryHeaderColor,
    Color? shadowColor,
    Color? splashColor,
    Color? unselectedWidgetColor,
    // TYPOGRAPHY & ICONOGRAPHY
    IconThemeData? iconTheme,
    IconThemeData? primaryIconTheme,
    TextTheme? primaryTextTheme,
    TextTheme? textTheme,
    Typography? typography,
    // COMPONENT THEMES
    ActionIconThemeData? actionIconTheme,
    AppBarTheme? appBarTheme,
    BadgeThemeData? badgeTheme,
    MaterialBannerThemeData? bannerTheme,
    BottomAppBarTheme? bottomAppBarTheme,
    BottomNavigationBarThemeData? bottomNavigationBarTheme,
    BottomSheetThemeData? bottomSheetTheme,
    ButtonThemeData? buttonTheme,
    Object? cardTheme,
    CheckboxThemeData? checkboxTheme,
    ChipThemeData? chipTheme,
    DataTableThemeData? dataTableTheme,
    DatePickerThemeData? datePickerTheme,
    // TODO(QuncCccccc): Change the parameter type to DialogThemeData
    Object? dialogTheme,
    DividerThemeData? dividerTheme,
    DrawerThemeData? drawerTheme,
    DropdownMenuThemeData? dropdownMenuTheme,
    ElevatedButtonThemeData? elevatedButtonTheme,
    ExpansionTileThemeData? expansionTileTheme,
    FilledButtonThemeData? filledButtonTheme,
    FloatingActionButtonThemeData? floatingActionButtonTheme,
    IconButtonThemeData? iconButtonTheme,
    ListTileThemeData? listTileTheme,
    MenuBarThemeData? menuBarTheme,
    MenuButtonThemeData? menuButtonTheme,
    MenuThemeData? menuTheme,
    NavigationBarThemeData? navigationBarTheme,
    NavigationDrawerThemeData? navigationDrawerTheme,
    NavigationRailThemeData? navigationRailTheme,
    OutlinedButtonThemeData? outlinedButtonTheme,
    PopupMenuThemeData? popupMenuTheme,
    ProgressIndicatorThemeData? progressIndicatorTheme,
    RadioThemeData? radioTheme,
    SearchBarThemeData? searchBarTheme,
    SearchViewThemeData? searchViewTheme,
    SegmentedButtonThemeData? segmentedButtonTheme,
    SliderThemeData? sliderTheme,
    SnackBarThemeData? snackBarTheme,
    SwitchThemeData? switchTheme,
    // TODO(QuncCccccc): Change the parameter type to TabBarThemeData
    Object? tabBarTheme,
    TextButtonThemeData? textButtonTheme,
    TextSelectionThemeData? textSelectionTheme,
    TimePickerThemeData? timePickerTheme,
    ToggleButtonsThemeData? toggleButtonsTheme,
    TooltipThemeData? tooltipTheme,
    // DEPRECATED (newest deprecations at the bottom)
    @Deprecated(
      'Use a ThemeData constructor (.from, .light, or .dark) instead. '
      'These constructors all have a useMaterial3 argument, '
      'and they set appropriate default values based on its value. '
      'See the useMaterial3 API documentation for full details. '
      'This feature was deprecated after v3.13.0-0.2.pre.',
    )
    bool? useMaterial3,
    @Deprecated(
      'Use OverflowBar instead. '
      'This feature was deprecated after v3.21.0-10.0.pre.',
    )
    ButtonBarThemeData? buttonBarTheme,
    @Deprecated(
      'Use DialogThemeData.backgroundColor instead. '
      'This feature was deprecated after v3.27.0-0.1.pre.',
    )
    Color? dialogBackgroundColor,
  }) {
    cupertinoOverrideTheme = cupertinoOverrideTheme?.noDefault();

    // TODO(QuncCccccc): Clean it up once the type of `cardTheme` is changed to `CardThemeData`
    if (cardTheme != null) {
      if (cardTheme is CardTheme) {
        cardTheme = cardTheme.data;
      } else if (cardTheme is! CardThemeData) {
        throw ArgumentError('cardTheme must be either a CardThemeData or a CardTheme');
      }
    }

    // TODO(QuncCccccc): Clean this up once the type of `dialogTheme` is changed to `DialogThemeData`
    if (dialogTheme != null) {
      if (dialogTheme is DialogTheme) {
        dialogTheme = dialogTheme.data;
      } else if (dialogTheme is! DialogThemeData) {
        throw ArgumentError('dialogTheme must be either a DialogThemeData or a DialogTheme');
      }
    }

    // TODO(QuncCccccc): Clean this up once the type of `tabBarTheme` is changed to `TabBarThemeData`
    if (tabBarTheme != null) {
      if (tabBarTheme is TabBarTheme) {
        tabBarTheme = tabBarTheme.data;
      } else if (tabBarTheme is! TabBarThemeData) {
        throw ArgumentError('tabBarTheme must be either a TabBarThemeData or a TabBarTheme');
      }
    }
    return ThemeData.raw(
      // For the sanity of the reader, make sure these properties are in the same
      // order in every place that they are separated by section comments (e.g.
      // GENERAL CONFIGURATION). Each section except for deprecations should be
      // alphabetical by symbol name.

      // GENERAL CONFIGURATION
      adaptationMap: adaptations != null ? _createAdaptationMap(adaptations) : adaptationMap,
      applyElevationOverlayColor: applyElevationOverlayColor ?? this.applyElevationOverlayColor,
      cupertinoOverrideTheme: cupertinoOverrideTheme ?? this.cupertinoOverrideTheme,
      extensions: (extensions != null) ? _themeExtensionIterableToMap(extensions) : this.extensions,
      inputDecorationTheme: inputDecorationTheme ?? this.inputDecorationTheme,
      materialTapTargetSize: materialTapTargetSize ?? this.materialTapTargetSize,
      pageTransitionsTheme: pageTransitionsTheme ?? this.pageTransitionsTheme,
      platform: platform ?? this.platform,
      scrollbarTheme: scrollbarTheme ?? this.scrollbarTheme,
      splashFactory: splashFactory ?? this.splashFactory,
      // When deprecated useMaterial3 removed, maintain `this.useMaterial3` here
      // for == evaluation.
      useMaterial3: useMaterial3 ?? this.useMaterial3,
      visualDensity: visualDensity ?? this.visualDensity,
      // COLOR
      canvasColor: canvasColor ?? this.canvasColor,
      cardColor: cardColor ?? this.cardColor,
      colorScheme: (colorScheme ?? this.colorScheme).copyWith(brightness: brightness),
      disabledColor: disabledColor ?? this.disabledColor,
      dividerColor: dividerColor ?? this.dividerColor,
      focusColor: focusColor ?? this.focusColor,
      highlightColor: highlightColor ?? this.highlightColor,
      hintColor: hintColor ?? this.hintColor,
      hoverColor: hoverColor ?? this.hoverColor,
      indicatorColor: indicatorColor ?? this.indicatorColor,
      primaryColor: primaryColor ?? this.primaryColor,
      primaryColorDark: primaryColorDark ?? this.primaryColorDark,
      primaryColorLight: primaryColorLight ?? this.primaryColorLight,
      scaffoldBackgroundColor: scaffoldBackgroundColor ?? this.scaffoldBackgroundColor,
      secondaryHeaderColor: secondaryHeaderColor ?? this.secondaryHeaderColor,
      shadowColor: shadowColor ?? this.shadowColor,
      splashColor: splashColor ?? this.splashColor,
      unselectedWidgetColor: unselectedWidgetColor ?? this.unselectedWidgetColor,
      // TYPOGRAPHY & ICONOGRAPHY
      iconTheme: iconTheme ?? this.iconTheme,
      primaryIconTheme: primaryIconTheme ?? this.primaryIconTheme,
      primaryTextTheme: primaryTextTheme ?? this.primaryTextTheme,
      textTheme: textTheme ?? this.textTheme,
      typography: typography ?? this.typography,
      // COMPONENT THEMES
      actionIconTheme: actionIconTheme ?? this.actionIconTheme,
      appBarTheme: appBarTheme ?? this.appBarTheme,
      badgeTheme: badgeTheme ?? this.badgeTheme,
      bannerTheme: bannerTheme ?? this.bannerTheme,
      bottomAppBarTheme: bottomAppBarTheme ?? this.bottomAppBarTheme,
      bottomNavigationBarTheme: bottomNavigationBarTheme ?? this.bottomNavigationBarTheme,
      bottomSheetTheme: bottomSheetTheme ?? this.bottomSheetTheme,
      buttonTheme: buttonTheme ?? this.buttonTheme,
      cardTheme: cardTheme as CardThemeData? ?? this.cardTheme,
      checkboxTheme: checkboxTheme ?? this.checkboxTheme,
      chipTheme: chipTheme ?? this.chipTheme,
      dataTableTheme: dataTableTheme ?? this.dataTableTheme,
      datePickerTheme: datePickerTheme ?? this.datePickerTheme,
      dialogTheme: dialogTheme as DialogThemeData? ?? this.dialogTheme,
      dividerTheme: dividerTheme ?? this.dividerTheme,
      drawerTheme: drawerTheme ?? this.drawerTheme,
      dropdownMenuTheme: dropdownMenuTheme ?? this.dropdownMenuTheme,
      elevatedButtonTheme: elevatedButtonTheme ?? this.elevatedButtonTheme,
      expansionTileTheme: expansionTileTheme ?? this.expansionTileTheme,
      filledButtonTheme: filledButtonTheme ?? this.filledButtonTheme,
      floatingActionButtonTheme: floatingActionButtonTheme ?? this.floatingActionButtonTheme,
      iconButtonTheme: iconButtonTheme ?? this.iconButtonTheme,
      listTileTheme: listTileTheme ?? this.listTileTheme,
      menuBarTheme: menuBarTheme ?? this.menuBarTheme,
      menuButtonTheme: menuButtonTheme ?? this.menuButtonTheme,
      menuTheme: menuTheme ?? this.menuTheme,
      navigationBarTheme: navigationBarTheme ?? this.navigationBarTheme,
      navigationDrawerTheme: navigationDrawerTheme ?? this.navigationDrawerTheme,
      navigationRailTheme: navigationRailTheme ?? this.navigationRailTheme,
      outlinedButtonTheme: outlinedButtonTheme ?? this.outlinedButtonTheme,
      popupMenuTheme: popupMenuTheme ?? this.popupMenuTheme,
      progressIndicatorTheme: progressIndicatorTheme ?? this.progressIndicatorTheme,
      radioTheme: radioTheme ?? this.radioTheme,
      searchBarTheme: searchBarTheme ?? this.searchBarTheme,
      searchViewTheme: searchViewTheme ?? this.searchViewTheme,
      segmentedButtonTheme: segmentedButtonTheme ?? this.segmentedButtonTheme,
      sliderTheme: sliderTheme ?? this.sliderTheme,
      snackBarTheme: snackBarTheme ?? this.snackBarTheme,
      switchTheme: switchTheme ?? this.switchTheme,
      tabBarTheme: tabBarTheme as TabBarThemeData? ?? this.tabBarTheme,
      textButtonTheme: textButtonTheme ?? this.textButtonTheme,
      textSelectionTheme: textSelectionTheme ?? this.textSelectionTheme,
      timePickerTheme: timePickerTheme ?? this.timePickerTheme,
      toggleButtonsTheme: toggleButtonsTheme ?? this.toggleButtonsTheme,
      tooltipTheme: tooltipTheme ?? this.tooltipTheme,
      // DEPRECATED (newest deprecations at the bottom)
      buttonBarTheme: buttonBarTheme ?? _buttonBarTheme,
      dialogBackgroundColor: dialogBackgroundColor ?? this.dialogBackgroundColor,
    );
  }

  // The number 5 was chosen without any real science or research behind it. It
  // just seemed like a number that's not too big (we should be able to fit 5
  // copies of ThemeData in memory comfortably) and not too small (most apps
  // shouldn't have more than 5 theme/localization pairs).
  static const int _localizedThemeDataCacheSize = 5;

  /// Caches localized themes to speed up the [localize] method.
  static final _FifoCache<_IdentityThemeDataCacheKey, ThemeData> _localizedThemeDataCache =
      _FifoCache<_IdentityThemeDataCacheKey, ThemeData>(_localizedThemeDataCacheSize);

  /// Returns a new theme built by merging the text geometry provided by the
  /// [localTextGeometry] theme with the [baseTheme].
  ///
  /// For those text styles in the [baseTheme] whose [TextStyle.inherit] is set
  /// to true, the returned theme's text styles inherit the geometric properties
  /// of [localTextGeometry]. The resulting text styles' [TextStyle.inherit] is
  /// set to those provided by [localTextGeometry].
  static ThemeData localize(ThemeData baseTheme, TextTheme localTextGeometry) {
    // WARNING: this method memoizes the result in a cache based on the
    // previously seen baseTheme and localTextGeometry. Memoization is safe
    // because all inputs and outputs of this function are deeply immutable, and
    // the computations are referentially transparent. It only short-circuits
    // the computation if the new inputs are identical() to the previous ones.
    // It does not use the == operator, which performs a costly deep comparison.
    //
    // When changing this method, make sure the memoization logic is correct.
    // Remember:
    //
    // There are only two hard things in Computer Science: cache invalidation
    // and naming things. -- Phil Karlton

    return _localizedThemeDataCache.putIfAbsent(
      _IdentityThemeDataCacheKey(baseTheme, localTextGeometry),
      () {
        return baseTheme.copyWith(
          primaryTextTheme: localTextGeometry.merge(baseTheme.primaryTextTheme),
          textTheme: localTextGeometry.merge(baseTheme.textTheme),
        );
      },
    );
  }

  /// Determines whether the given [Color] is [Brightness.light] or
  /// [Brightness.dark].
  ///
  /// This compares the luminosity of the given color to a threshold value that
  /// matches the Material Design specification.
  static Brightness estimateBrightnessForColor(Color color) {
    final double relativeLuminance = color.computeLuminance();

    // See <https://www.w3.org/TR/WCAG20/#contrast-ratiodef>
    // The spec says to use kThreshold=0.0525, but Material Design appears to bias
    // more towards using light text than WCAG20 recommends. Material Design spec
    // doesn't say what value to use, but 0.15 seemed close to what the Material
    // Design spec shows for its color palette on
    // <https://material.io/go/design-theming#color-color-palette>.
    const double kThreshold = 0.15;
    if ((relativeLuminance + 0.05) * (relativeLuminance + 0.05) > kThreshold) {
      return Brightness.light;
    }
    return Brightness.dark;
  }

  /// Linearly interpolate between two [extensions].
  ///
  /// Includes all theme extensions in [a] and [b].
  ///
  /// {@macro dart.ui.shadow.lerp}
  static Map<Object, ThemeExtension<dynamic>> _lerpThemeExtensions(
    ThemeData a,
    ThemeData b,
    double t,
  ) {
    // Lerp [a].
    final Map<Object, ThemeExtension<dynamic>> newExtensions = a.extensions.map((
      Object id,
      ThemeExtension<dynamic> extensionA,
    ) {
      final ThemeExtension<dynamic>? extensionB = b.extensions[id];
      return MapEntry<Object, ThemeExtension<dynamic>>(id, extensionA.lerp(extensionB, t));
    });
    // Add [b]-only extensions.
    newExtensions.addEntries(
      b.extensions.entries.where(
        (MapEntry<Object, ThemeExtension<dynamic>> entry) => !a.extensions.containsKey(entry.key),
      ),
    );

    return newExtensions;
  }

  /// Convert the [extensionsIterable] passed to [ThemeData.new] or [copyWith]
  /// to the stored [extensions] map, where each entry's key consists of the extension's type.
  static Map<Object, ThemeExtension<dynamic>> _themeExtensionIterableToMap(
    Iterable<ThemeExtension<dynamic>> extensionsIterable,
  ) {
    return Map<Object, ThemeExtension<dynamic>>.unmodifiable(<Object, ThemeExtension<dynamic>>{
      // Strangely, the cast is necessary for tests to run.
      for (final ThemeExtension<dynamic> extension in extensionsIterable)
        extension.type: extension as ThemeExtension<ThemeExtension<dynamic>>,
    });
  }

  /// Linearly interpolate between two themes.
  ///
  /// {@macro dart.ui.shadow.lerp}
  static ThemeData lerp(ThemeData a, ThemeData b, double t) {
    if (identical(a, b)) {
      return a;
    }
    return ThemeData.raw(
      // For the sanity of the reader, make sure these properties are in the same
      // order in every place that they are separated by section comments (e.g.
      // GENERAL CONFIGURATION). Each section except for deprecations should be
      // alphabetical by symbol name.

      // GENERAL CONFIGURATION
      adaptationMap: t < 0.5 ? a.adaptationMap : b.adaptationMap,
      applyElevationOverlayColor:
          t < 0.5 ? a.applyElevationOverlayColor : b.applyElevationOverlayColor,
      cupertinoOverrideTheme: t < 0.5 ? a.cupertinoOverrideTheme : b.cupertinoOverrideTheme,
      extensions: _lerpThemeExtensions(a, b, t),
      inputDecorationTheme: t < 0.5 ? a.inputDecorationTheme : b.inputDecorationTheme,
      materialTapTargetSize: t < 0.5 ? a.materialTapTargetSize : b.materialTapTargetSize,
      pageTransitionsTheme: t < 0.5 ? a.pageTransitionsTheme : b.pageTransitionsTheme,
      platform: t < 0.5 ? a.platform : b.platform,
      scrollbarTheme: ScrollbarThemeData.lerp(a.scrollbarTheme, b.scrollbarTheme, t),
      splashFactory: t < 0.5 ? a.splashFactory : b.splashFactory,
      useMaterial3: t < 0.5 ? a.useMaterial3 : b.useMaterial3,
      visualDensity: VisualDensity.lerp(a.visualDensity, b.visualDensity, t),
      // COLOR
      canvasColor: Color.lerp(a.canvasColor, b.canvasColor, t)!,
      cardColor: Color.lerp(a.cardColor, b.cardColor, t)!,
      colorScheme: ColorScheme.lerp(a.colorScheme, b.colorScheme, t),
      disabledColor: Color.lerp(a.disabledColor, b.disabledColor, t)!,
      dividerColor: Color.lerp(a.dividerColor, b.dividerColor, t)!,
      focusColor: Color.lerp(a.focusColor, b.focusColor, t)!,
      highlightColor: Color.lerp(a.highlightColor, b.highlightColor, t)!,
      hintColor: Color.lerp(a.hintColor, b.hintColor, t)!,
      hoverColor: Color.lerp(a.hoverColor, b.hoverColor, t)!,
      indicatorColor: Color.lerp(a.indicatorColor, b.indicatorColor, t)!,
      primaryColor: Color.lerp(a.primaryColor, b.primaryColor, t)!,
      primaryColorDark: Color.lerp(a.primaryColorDark, b.primaryColorDark, t)!,
      primaryColorLight: Color.lerp(a.primaryColorLight, b.primaryColorLight, t)!,
      scaffoldBackgroundColor: Color.lerp(a.scaffoldBackgroundColor, b.scaffoldBackgroundColor, t)!,
      secondaryHeaderColor: Color.lerp(a.secondaryHeaderColor, b.secondaryHeaderColor, t)!,
      shadowColor: Color.lerp(a.shadowColor, b.shadowColor, t)!,
      splashColor: Color.lerp(a.splashColor, b.splashColor, t)!,
      unselectedWidgetColor: Color.lerp(a.unselectedWidgetColor, b.unselectedWidgetColor, t)!,
      // TYPOGRAPHY & ICONOGRAPHY
      iconTheme: IconThemeData.lerp(a.iconTheme, b.iconTheme, t),
      primaryIconTheme: IconThemeData.lerp(a.primaryIconTheme, b.primaryIconTheme, t),
      primaryTextTheme: TextTheme.lerp(a.primaryTextTheme, b.primaryTextTheme, t),
      textTheme: TextTheme.lerp(a.textTheme, b.textTheme, t),
      typography: Typography.lerp(a.typography, b.typography, t),
      // COMPONENT THEMES
      actionIconTheme: ActionIconThemeData.lerp(a.actionIconTheme, b.actionIconTheme, t),
      appBarTheme: AppBarTheme.lerp(a.appBarTheme, b.appBarTheme, t),
      badgeTheme: BadgeThemeData.lerp(a.badgeTheme, b.badgeTheme, t),
      bannerTheme: MaterialBannerThemeData.lerp(a.bannerTheme, b.bannerTheme, t),
      bottomAppBarTheme: BottomAppBarTheme.lerp(a.bottomAppBarTheme, b.bottomAppBarTheme, t),
      bottomNavigationBarTheme: BottomNavigationBarThemeData.lerp(
        a.bottomNavigationBarTheme,
        b.bottomNavigationBarTheme,
        t,
      ),
      bottomSheetTheme: BottomSheetThemeData.lerp(a.bottomSheetTheme, b.bottomSheetTheme, t)!,
      buttonTheme: t < 0.5 ? a.buttonTheme : b.buttonTheme,
      cardTheme: CardThemeData.lerp(a.cardTheme, b.cardTheme, t),
      checkboxTheme: CheckboxThemeData.lerp(a.checkboxTheme, b.checkboxTheme, t),
      chipTheme: ChipThemeData.lerp(a.chipTheme, b.chipTheme, t)!,
      dataTableTheme: DataTableThemeData.lerp(a.dataTableTheme, b.dataTableTheme, t),
      datePickerTheme: DatePickerThemeData.lerp(a.datePickerTheme, b.datePickerTheme, t),
      dialogTheme: DialogThemeData.lerp(a.dialogTheme, b.dialogTheme, t),
      dividerTheme: DividerThemeData.lerp(a.dividerTheme, b.dividerTheme, t),
      drawerTheme: DrawerThemeData.lerp(a.drawerTheme, b.drawerTheme, t)!,
      dropdownMenuTheme: DropdownMenuThemeData.lerp(a.dropdownMenuTheme, b.dropdownMenuTheme, t),
      elevatedButtonTheme:
          ElevatedButtonThemeData.lerp(a.elevatedButtonTheme, b.elevatedButtonTheme, t)!,
      expansionTileTheme:
          ExpansionTileThemeData.lerp(a.expansionTileTheme, b.expansionTileTheme, t)!,
      filledButtonTheme: FilledButtonThemeData.lerp(a.filledButtonTheme, b.filledButtonTheme, t)!,
      floatingActionButtonTheme:
          FloatingActionButtonThemeData.lerp(
            a.floatingActionButtonTheme,
            b.floatingActionButtonTheme,
            t,
          )!,
      iconButtonTheme: IconButtonThemeData.lerp(a.iconButtonTheme, b.iconButtonTheme, t)!,
      listTileTheme: ListTileThemeData.lerp(a.listTileTheme, b.listTileTheme, t)!,
      menuBarTheme: MenuBarThemeData.lerp(a.menuBarTheme, b.menuBarTheme, t)!,
      menuButtonTheme: MenuButtonThemeData.lerp(a.menuButtonTheme, b.menuButtonTheme, t)!,
      menuTheme: MenuThemeData.lerp(a.menuTheme, b.menuTheme, t)!,
      navigationBarTheme:
          NavigationBarThemeData.lerp(a.navigationBarTheme, b.navigationBarTheme, t)!,
      navigationDrawerTheme:
          NavigationDrawerThemeData.lerp(a.navigationDrawerTheme, b.navigationDrawerTheme, t)!,
      navigationRailTheme:
          NavigationRailThemeData.lerp(a.navigationRailTheme, b.navigationRailTheme, t)!,
      outlinedButtonTheme:
          OutlinedButtonThemeData.lerp(a.outlinedButtonTheme, b.outlinedButtonTheme, t)!,
      popupMenuTheme: PopupMenuThemeData.lerp(a.popupMenuTheme, b.popupMenuTheme, t)!,
      progressIndicatorTheme:
          ProgressIndicatorThemeData.lerp(a.progressIndicatorTheme, b.progressIndicatorTheme, t)!,
      radioTheme: RadioThemeData.lerp(a.radioTheme, b.radioTheme, t),
      searchBarTheme: SearchBarThemeData.lerp(a.searchBarTheme, b.searchBarTheme, t)!,
      searchViewTheme: SearchViewThemeData.lerp(a.searchViewTheme, b.searchViewTheme, t)!,
      segmentedButtonTheme: SegmentedButtonThemeData.lerp(
        a.segmentedButtonTheme,
        b.segmentedButtonTheme,
        t,
      ),
      sliderTheme: SliderThemeData.lerp(a.sliderTheme, b.sliderTheme, t),
      snackBarTheme: SnackBarThemeData.lerp(a.snackBarTheme, b.snackBarTheme, t),
      switchTheme: SwitchThemeData.lerp(a.switchTheme, b.switchTheme, t),
      tabBarTheme: TabBarThemeData.lerp(a.tabBarTheme, b.tabBarTheme, t),
      textButtonTheme: TextButtonThemeData.lerp(a.textButtonTheme, b.textButtonTheme, t)!,
      textSelectionTheme:
          TextSelectionThemeData.lerp(a.textSelectionTheme, b.textSelectionTheme, t)!,
      timePickerTheme: TimePickerThemeData.lerp(a.timePickerTheme, b.timePickerTheme, t),
      toggleButtonsTheme:
          ToggleButtonsThemeData.lerp(a.toggleButtonsTheme, b.toggleButtonsTheme, t)!,
      tooltipTheme: TooltipThemeData.lerp(a.tooltipTheme, b.tooltipTheme, t)!,
      // DEPRECATED (newest deprecations at the bottom)
      buttonBarTheme: ButtonBarThemeData.lerp(a.buttonBarTheme, b.buttonBarTheme, t),
      dialogBackgroundColor: Color.lerp(a.dialogBackgroundColor, b.dialogBackgroundColor, t)!,
    );
  }

  @override
  bool operator ==(Object other) {
    if (other.runtimeType != runtimeType) {
      return false;
    }
    return other is ThemeData &&
        // For the sanity of the reader, make sure these properties are in the same
        // order in every place that they are separated by section comments (e.g.
        // GENERAL CONFIGURATION). Each section except for deprecations should be
        // alphabetical by symbol name.
        // GENERAL CONFIGURATION
        mapEquals(other.adaptationMap, adaptationMap) &&
        other.applyElevationOverlayColor == applyElevationOverlayColor &&
        other.cupertinoOverrideTheme == cupertinoOverrideTheme &&
        mapEquals(other.extensions, extensions) &&
        other.inputDecorationTheme == inputDecorationTheme &&
        other.materialTapTargetSize == materialTapTargetSize &&
        other.pageTransitionsTheme == pageTransitionsTheme &&
        other.platform == platform &&
        other.scrollbarTheme == scrollbarTheme &&
        other.splashFactory == splashFactory &&
        other.useMaterial3 == useMaterial3 &&
        other.visualDensity == visualDensity &&
        // COLOR
        other.canvasColor == canvasColor &&
        other.cardColor == cardColor &&
        other.colorScheme == colorScheme &&
        other.disabledColor == disabledColor &&
        other.dividerColor == dividerColor &&
        other.focusColor == focusColor &&
        other.highlightColor == highlightColor &&
        other.hintColor == hintColor &&
        other.hoverColor == hoverColor &&
        other.indicatorColor == indicatorColor &&
        other.primaryColor == primaryColor &&
        other.primaryColorDark == primaryColorDark &&
        other.primaryColorLight == primaryColorLight &&
        other.scaffoldBackgroundColor == scaffoldBackgroundColor &&
        other.secondaryHeaderColor == secondaryHeaderColor &&
        other.shadowColor == shadowColor &&
        other.splashColor == splashColor &&
        other.unselectedWidgetColor == unselectedWidgetColor &&
        // TYPOGRAPHY & ICONOGRAPHY
        other.iconTheme == iconTheme &&
        other.primaryIconTheme == primaryIconTheme &&
        other.primaryTextTheme == primaryTextTheme &&
        other.textTheme == textTheme &&
        other.typography == typography &&
        // COMPONENT THEMES
        other.actionIconTheme == actionIconTheme &&
        other.appBarTheme == appBarTheme &&
        other.badgeTheme == badgeTheme &&
        other.bannerTheme == bannerTheme &&
        other.bottomAppBarTheme == bottomAppBarTheme &&
        other.bottomNavigationBarTheme == bottomNavigationBarTheme &&
        other.bottomSheetTheme == bottomSheetTheme &&
        other.buttonTheme == buttonTheme &&
        other.cardTheme == cardTheme &&
        other.checkboxTheme == checkboxTheme &&
        other.chipTheme == chipTheme &&
        other.dataTableTheme == dataTableTheme &&
        other.datePickerTheme == datePickerTheme &&
        other.dialogTheme == dialogTheme &&
        other.dividerTheme == dividerTheme &&
        other.drawerTheme == drawerTheme &&
        other.dropdownMenuTheme == dropdownMenuTheme &&
        other.elevatedButtonTheme == elevatedButtonTheme &&
        other.expansionTileTheme == expansionTileTheme &&
        other.filledButtonTheme == filledButtonTheme &&
        other.floatingActionButtonTheme == floatingActionButtonTheme &&
        other.iconButtonTheme == iconButtonTheme &&
        other.listTileTheme == listTileTheme &&
        other.menuBarTheme == menuBarTheme &&
        other.menuButtonTheme == menuButtonTheme &&
        other.menuTheme == menuTheme &&
        other.navigationBarTheme == navigationBarTheme &&
        other.navigationDrawerTheme == navigationDrawerTheme &&
        other.navigationRailTheme == navigationRailTheme &&
        other.outlinedButtonTheme == outlinedButtonTheme &&
        other.popupMenuTheme == popupMenuTheme &&
        other.progressIndicatorTheme == progressIndicatorTheme &&
        other.radioTheme == radioTheme &&
        other.searchBarTheme == searchBarTheme &&
        other.searchViewTheme == searchViewTheme &&
        other.segmentedButtonTheme == segmentedButtonTheme &&
        other.sliderTheme == sliderTheme &&
        other.snackBarTheme == snackBarTheme &&
        other.switchTheme == switchTheme &&
        other.tabBarTheme == tabBarTheme &&
        other.textButtonTheme == textButtonTheme &&
        other.textSelectionTheme == textSelectionTheme &&
        other.timePickerTheme == timePickerTheme &&
        other.toggleButtonsTheme == toggleButtonsTheme &&
        other.tooltipTheme == tooltipTheme &&
        // DEPRECATED (newest deprecations at the bottom)
        other.buttonBarTheme == buttonBarTheme &&
        other.dialogBackgroundColor == dialogBackgroundColor;
  }

  @override
  int get hashCode {
    final List<Object?> values = <Object?>[
      // For the sanity of the reader, make sure these properties are in the same
      // order in every place that they are separated by section comments (e.g.
      // GENERAL CONFIGURATION). Each section except for deprecations should be
      // alphabetical by symbol name.

      // GENERAL CONFIGURATION
      ...adaptationMap.keys,
      ...adaptationMap.values,
      applyElevationOverlayColor,
      cupertinoOverrideTheme,
      ...extensions.keys,
      ...extensions.values,
      inputDecorationTheme,
      materialTapTargetSize,
      pageTransitionsTheme,
      platform,
      scrollbarTheme,
      splashFactory,
      useMaterial3,
      visualDensity,
      // COLOR
      canvasColor,
      cardColor,
      colorScheme,
      disabledColor,
      dividerColor,
      focusColor,
      highlightColor,
      hintColor,
      hoverColor,
      indicatorColor,
      primaryColor,
      primaryColorDark,
      primaryColorLight,
      scaffoldBackgroundColor,
      secondaryHeaderColor,
      shadowColor,
      splashColor,
      unselectedWidgetColor,
      // TYPOGRAPHY & ICONOGRAPHY
      iconTheme,
      primaryIconTheme,
      primaryTextTheme,
      textTheme,
      typography,
      // COMPONENT THEMES
      actionIconTheme,
      appBarTheme,
      badgeTheme,
      bannerTheme,
      bottomAppBarTheme,
      bottomNavigationBarTheme,
      bottomSheetTheme,
      buttonTheme,
      cardTheme,
      checkboxTheme,
      chipTheme,
      dataTableTheme,
      datePickerTheme,
      dialogTheme,
      dividerTheme,
      drawerTheme,
      dropdownMenuTheme,
      elevatedButtonTheme,
      expansionTileTheme,
      filledButtonTheme,
      floatingActionButtonTheme,
      iconButtonTheme,
      listTileTheme,
      menuBarTheme,
      menuButtonTheme,
      menuTheme,
      navigationBarTheme,
      navigationDrawerTheme,
      navigationRailTheme,
      outlinedButtonTheme,
      popupMenuTheme,
      progressIndicatorTheme,
      radioTheme,
      searchBarTheme,
      searchViewTheme,
      segmentedButtonTheme,
      sliderTheme,
      snackBarTheme,
      switchTheme,
      tabBarTheme,
      textButtonTheme,
      textSelectionTheme,
      timePickerTheme,
      toggleButtonsTheme,
      tooltipTheme,
      // DEPRECATED (newest deprecations at the bottom)
      buttonBarTheme,
      dialogBackgroundColor,
    ];
    return Object.hashAll(values);
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    final ThemeData defaultData = ThemeData.fallback();
    // For the sanity of the reader, make sure these properties are in the same
    // order in every place that they are separated by section comments (e.g.
    // GENERAL CONFIGURATION). Each section except for deprecations should be
    // alphabetical by symbol name.

    // GENERAL CONFIGURATION
    properties.add(
      IterableProperty<Adaptation<dynamic>>(
        'adaptations',
        adaptationMap.values,
        defaultValue: defaultData.adaptationMap.values,
        level: DiagnosticLevel.debug,
      ),
    );
    properties.add(
      DiagnosticsProperty<bool>(
        'applyElevationOverlayColor',
        applyElevationOverlayColor,
        level: DiagnosticLevel.debug,
      ),
    );
    properties.add(
      DiagnosticsProperty<NoDefaultCupertinoThemeData>(
        'cupertinoOverrideTheme',
        cupertinoOverrideTheme,
        defaultValue: defaultData.cupertinoOverrideTheme,
        level: DiagnosticLevel.debug,
      ),
    );
    properties.add(
      IterableProperty<ThemeExtension<dynamic>>(
        'extensions',
        extensions.values,
        defaultValue: defaultData.extensions.values,
        level: DiagnosticLevel.debug,
      ),
    );
    properties.add(
      DiagnosticsProperty<InputDecorationTheme>(
        'inputDecorationTheme',
        inputDecorationTheme,
        level: DiagnosticLevel.debug,
      ),
    );
    properties.add(
      DiagnosticsProperty<MaterialTapTargetSize>(
        'materialTapTargetSize',
        materialTapTargetSize,
        level: DiagnosticLevel.debug,
      ),
    );
    properties.add(
      DiagnosticsProperty<PageTransitionsTheme>(
        'pageTransitionsTheme',
        pageTransitionsTheme,
        level: DiagnosticLevel.debug,
      ),
    );
    properties.add(
      EnumProperty<TargetPlatform>(
        'platform',
        platform,
        defaultValue: defaultTargetPlatform,
        level: DiagnosticLevel.debug,
      ),
    );
    properties.add(
      DiagnosticsProperty<ScrollbarThemeData>(
        'scrollbarTheme',
        scrollbarTheme,
        defaultValue: defaultData.scrollbarTheme,
        level: DiagnosticLevel.debug,
      ),
    );
    properties.add(
      DiagnosticsProperty<InteractiveInkFeatureFactory>(
        'splashFactory',
        splashFactory,
        defaultValue: defaultData.splashFactory,
        level: DiagnosticLevel.debug,
      ),
    );
    properties.add(
      DiagnosticsProperty<bool>(
        'useMaterial3',
        useMaterial3,
        defaultValue: defaultData.useMaterial3,
        level: DiagnosticLevel.debug,
      ),
    );
    properties.add(
      DiagnosticsProperty<VisualDensity>(
        'visualDensity',
        visualDensity,
        defaultValue: defaultData.visualDensity,
        level: DiagnosticLevel.debug,
      ),
    );
    // COLORS
    properties.add(
      ColorProperty(
        'canvasColor',
        canvasColor,
        defaultValue: defaultData.canvasColor,
        level: DiagnosticLevel.debug,
      ),
    );
    properties.add(
      ColorProperty(
        'cardColor',
        cardColor,
        defaultValue: defaultData.cardColor,
        level: DiagnosticLevel.debug,
      ),
    );
    properties.add(
      DiagnosticsProperty<ColorScheme>(
        'colorScheme',
        colorScheme,
        defaultValue: defaultData.colorScheme,
        level: DiagnosticLevel.debug,
      ),
    );
    properties.add(
      ColorProperty(
        'disabledColor',
        disabledColor,
        defaultValue: defaultData.disabledColor,
        level: DiagnosticLevel.debug,
      ),
    );
    properties.add(
      ColorProperty(
        'dividerColor',
        dividerColor,
        defaultValue: defaultData.dividerColor,
        level: DiagnosticLevel.debug,
      ),
    );
    properties.add(
      ColorProperty(
        'focusColor',
        focusColor,
        defaultValue: defaultData.focusColor,
        level: DiagnosticLevel.debug,
      ),
    );
    properties.add(
      ColorProperty(
        'highlightColor',
        highlightColor,
        defaultValue: defaultData.highlightColor,
        level: DiagnosticLevel.debug,
      ),
    );
    properties.add(
      ColorProperty(
        'hintColor',
        hintColor,
        defaultValue: defaultData.hintColor,
        level: DiagnosticLevel.debug,
      ),
    );
    properties.add(
      ColorProperty(
        'hoverColor',
        hoverColor,
        defaultValue: defaultData.hoverColor,
        level: DiagnosticLevel.debug,
      ),
    );
    properties.add(
      ColorProperty(
        'indicatorColor',
        indicatorColor,
        defaultValue: defaultData.indicatorColor,
        level: DiagnosticLevel.debug,
      ),
    );
    properties.add(
      ColorProperty(
        'primaryColorDark',
        primaryColorDark,
        defaultValue: defaultData.primaryColorDark,
        level: DiagnosticLevel.debug,
      ),
    );
    properties.add(
      ColorProperty(
        'primaryColorLight',
        primaryColorLight,
        defaultValue: defaultData.primaryColorLight,
        level: DiagnosticLevel.debug,
      ),
    );
    properties.add(
      ColorProperty(
        'primaryColor',
        primaryColor,
        defaultValue: defaultData.primaryColor,
        level: DiagnosticLevel.debug,
      ),
    );
    properties.add(
      ColorProperty(
        'scaffoldBackgroundColor',
        scaffoldBackgroundColor,
        defaultValue: defaultData.scaffoldBackgroundColor,
        level: DiagnosticLevel.debug,
      ),
    );
    properties.add(
      ColorProperty(
        'secondaryHeaderColor',
        secondaryHeaderColor,
        defaultValue: defaultData.secondaryHeaderColor,
        level: DiagnosticLevel.debug,
      ),
    );
    properties.add(
      ColorProperty(
        'shadowColor',
        shadowColor,
        defaultValue: defaultData.shadowColor,
        level: DiagnosticLevel.debug,
      ),
    );
    properties.add(
      ColorProperty(
        'splashColor',
        splashColor,
        defaultValue: defaultData.splashColor,
        level: DiagnosticLevel.debug,
      ),
    );
    properties.add(
      ColorProperty(
        'unselectedWidgetColor',
        unselectedWidgetColor,
        defaultValue: defaultData.unselectedWidgetColor,
        level: DiagnosticLevel.debug,
      ),
    );
    // TYPOGRAPHY & ICONOGRAPHY
    properties.add(
      DiagnosticsProperty<IconThemeData>('iconTheme', iconTheme, level: DiagnosticLevel.debug),
    );
    properties.add(
      DiagnosticsProperty<IconThemeData>(
        'primaryIconTheme',
        primaryIconTheme,
        level: DiagnosticLevel.debug,
      ),
    );
    properties.add(
      DiagnosticsProperty<TextTheme>(
        'primaryTextTheme',
        primaryTextTheme,
        level: DiagnosticLevel.debug,
      ),
    );
    properties.add(
      DiagnosticsProperty<TextTheme>('textTheme', textTheme, level: DiagnosticLevel.debug),
    );
    properties.add(
      DiagnosticsProperty<Typography>(
        'typography',
        typography,
        defaultValue: defaultData.typography,
        level: DiagnosticLevel.debug,
      ),
    );
    // COMPONENT THEMES
    properties.add(
      DiagnosticsProperty<ActionIconThemeData>(
        'actionIconTheme',
        actionIconTheme,
        level: DiagnosticLevel.debug,
      ),
    );
    properties.add(
      DiagnosticsProperty<AppBarTheme>(
        'appBarTheme',
        appBarTheme,
        defaultValue: defaultData.appBarTheme,
        level: DiagnosticLevel.debug,
      ),
    );
    properties.add(
      DiagnosticsProperty<BadgeThemeData>(
        'badgeTheme',
        badgeTheme,
        defaultValue: defaultData.badgeTheme,
        level: DiagnosticLevel.debug,
      ),
    );
    properties.add(
      DiagnosticsProperty<MaterialBannerThemeData>(
        'bannerTheme',
        bannerTheme,
        defaultValue: defaultData.bannerTheme,
        level: DiagnosticLevel.debug,
      ),
    );
    properties.add(
      DiagnosticsProperty<BottomAppBarTheme>(
        'bottomAppBarTheme',
        bottomAppBarTheme,
        defaultValue: defaultData.bottomAppBarTheme,
        level: DiagnosticLevel.debug,
      ),
    );
    properties.add(
      DiagnosticsProperty<BottomNavigationBarThemeData>(
        'bottomNavigationBarTheme',
        bottomNavigationBarTheme,
        defaultValue: defaultData.bottomNavigationBarTheme,
        level: DiagnosticLevel.debug,
      ),
    );
    properties.add(
      DiagnosticsProperty<BottomSheetThemeData>(
        'bottomSheetTheme',
        bottomSheetTheme,
        defaultValue: defaultData.bottomSheetTheme,
        level: DiagnosticLevel.debug,
      ),
    );
    properties.add(
      DiagnosticsProperty<ButtonThemeData>(
        'buttonTheme',
        buttonTheme,
        level: DiagnosticLevel.debug,
      ),
    );
    properties.add(
      DiagnosticsProperty<CardThemeData>('cardTheme', cardTheme, level: DiagnosticLevel.debug),
    );
    properties.add(
      DiagnosticsProperty<CheckboxThemeData>(
        'checkboxTheme',
        checkboxTheme,
        defaultValue: defaultData.checkboxTheme,
        level: DiagnosticLevel.debug,
      ),
    );
    properties.add(
      DiagnosticsProperty<ChipThemeData>('chipTheme', chipTheme, level: DiagnosticLevel.debug),
    );
    properties.add(
      DiagnosticsProperty<DataTableThemeData>(
        'dataTableTheme',
        dataTableTheme,
        defaultValue: defaultData.dataTableTheme,
        level: DiagnosticLevel.debug,
      ),
    );
    properties.add(
      DiagnosticsProperty<DatePickerThemeData>(
        'datePickerTheme',
        datePickerTheme,
        defaultValue: defaultData.datePickerTheme,
        level: DiagnosticLevel.debug,
      ),
    );
    properties.add(
      DiagnosticsProperty<DialogThemeData>(
        'dialogTheme',
        dialogTheme,
        defaultValue: defaultData.dialogTheme,
        level: DiagnosticLevel.debug,
      ),
    );
    properties.add(
      DiagnosticsProperty<DividerThemeData>(
        'dividerTheme',
        dividerTheme,
        defaultValue: defaultData.dividerTheme,
        level: DiagnosticLevel.debug,
      ),
    );
    properties.add(
      DiagnosticsProperty<DrawerThemeData>(
        'drawerTheme',
        drawerTheme,
        defaultValue: defaultData.drawerTheme,
        level: DiagnosticLevel.debug,
      ),
    );
    properties.add(
      DiagnosticsProperty<DropdownMenuThemeData>(
        'dropdownMenuTheme',
        dropdownMenuTheme,
        defaultValue: defaultData.dropdownMenuTheme,
        level: DiagnosticLevel.debug,
      ),
    );
    properties.add(
      DiagnosticsProperty<ElevatedButtonThemeData>(
        'elevatedButtonTheme',
        elevatedButtonTheme,
        defaultValue: defaultData.elevatedButtonTheme,
        level: DiagnosticLevel.debug,
      ),
    );
    properties.add(
      DiagnosticsProperty<ExpansionTileThemeData>(
        'expansionTileTheme',
        expansionTileTheme,
        level: DiagnosticLevel.debug,
      ),
    );
    properties.add(
      DiagnosticsProperty<FilledButtonThemeData>(
        'filledButtonTheme',
        filledButtonTheme,
        defaultValue: defaultData.filledButtonTheme,
        level: DiagnosticLevel.debug,
      ),
    );
    properties.add(
      DiagnosticsProperty<FloatingActionButtonThemeData>(
        'floatingActionButtonTheme',
        floatingActionButtonTheme,
        defaultValue: defaultData.floatingActionButtonTheme,
        level: DiagnosticLevel.debug,
      ),
    );
    properties.add(
      DiagnosticsProperty<IconButtonThemeData>(
        'iconButtonTheme',
        iconButtonTheme,
        defaultValue: defaultData.iconButtonTheme,
        level: DiagnosticLevel.debug,
      ),
    );
    properties.add(
      DiagnosticsProperty<ListTileThemeData>(
        'listTileTheme',
        listTileTheme,
        defaultValue: defaultData.listTileTheme,
        level: DiagnosticLevel.debug,
      ),
    );
    properties.add(
      DiagnosticsProperty<MenuBarThemeData>(
        'menuBarTheme',
        menuBarTheme,
        defaultValue: defaultData.menuBarTheme,
        level: DiagnosticLevel.debug,
      ),
    );
    properties.add(
      DiagnosticsProperty<MenuButtonThemeData>(
        'menuButtonTheme',
        menuButtonTheme,
        defaultValue: defaultData.menuButtonTheme,
        level: DiagnosticLevel.debug,
      ),
    );
    properties.add(
      DiagnosticsProperty<MenuThemeData>(
        'menuTheme',
        menuTheme,
        defaultValue: defaultData.menuTheme,
        level: DiagnosticLevel.debug,
      ),
    );
    properties.add(
      DiagnosticsProperty<NavigationBarThemeData>(
        'navigationBarTheme',
        navigationBarTheme,
        defaultValue: defaultData.navigationBarTheme,
        level: DiagnosticLevel.debug,
      ),
    );
    properties.add(
      DiagnosticsProperty<NavigationDrawerThemeData>(
        'navigationDrawerTheme',
        navigationDrawerTheme,
        defaultValue: defaultData.navigationDrawerTheme,
        level: DiagnosticLevel.debug,
      ),
    );
    properties.add(
      DiagnosticsProperty<NavigationRailThemeData>(
        'navigationRailTheme',
        navigationRailTheme,
        defaultValue: defaultData.navigationRailTheme,
        level: DiagnosticLevel.debug,
      ),
    );
    properties.add(
      DiagnosticsProperty<OutlinedButtonThemeData>(
        'outlinedButtonTheme',
        outlinedButtonTheme,
        defaultValue: defaultData.outlinedButtonTheme,
        level: DiagnosticLevel.debug,
      ),
    );
    properties.add(
      DiagnosticsProperty<PopupMenuThemeData>(
        'popupMenuTheme',
        popupMenuTheme,
        defaultValue: defaultData.popupMenuTheme,
        level: DiagnosticLevel.debug,
      ),
    );
    properties.add(
      DiagnosticsProperty<ProgressIndicatorThemeData>(
        'progressIndicatorTheme',
        progressIndicatorTheme,
        defaultValue: defaultData.progressIndicatorTheme,
        level: DiagnosticLevel.debug,
      ),
    );
    properties.add(
      DiagnosticsProperty<RadioThemeData>(
        'radioTheme',
        radioTheme,
        defaultValue: defaultData.radioTheme,
        level: DiagnosticLevel.debug,
      ),
    );
    properties.add(
      DiagnosticsProperty<SearchBarThemeData>(
        'searchBarTheme',
        searchBarTheme,
        defaultValue: defaultData.searchBarTheme,
        level: DiagnosticLevel.debug,
      ),
    );
    properties.add(
      DiagnosticsProperty<SearchViewThemeData>(
        'searchViewTheme',
        searchViewTheme,
        defaultValue: defaultData.searchViewTheme,
        level: DiagnosticLevel.debug,
      ),
    );
    properties.add(
      DiagnosticsProperty<SegmentedButtonThemeData>(
        'segmentedButtonTheme',
        segmentedButtonTheme,
        defaultValue: defaultData.segmentedButtonTheme,
        level: DiagnosticLevel.debug,
      ),
    );
    properties.add(
      DiagnosticsProperty<SliderThemeData>(
        'sliderTheme',
        sliderTheme,
        level: DiagnosticLevel.debug,
      ),
    );
    properties.add(
      DiagnosticsProperty<SnackBarThemeData>(
        'snackBarTheme',
        snackBarTheme,
        defaultValue: defaultData.snackBarTheme,
        level: DiagnosticLevel.debug,
      ),
    );
    properties.add(
      DiagnosticsProperty<SwitchThemeData>(
        'switchTheme',
        switchTheme,
        defaultValue: defaultData.switchTheme,
        level: DiagnosticLevel.debug,
      ),
    );
    properties.add(
      DiagnosticsProperty<TabBarThemeData>(
        'tabBarTheme',
        tabBarTheme,
        level: DiagnosticLevel.debug,
      ),
    );
    properties.add(
      DiagnosticsProperty<TextButtonThemeData>(
        'textButtonTheme',
        textButtonTheme,
        defaultValue: defaultData.textButtonTheme,
        level: DiagnosticLevel.debug,
      ),
    );
    properties.add(
      DiagnosticsProperty<TextSelectionThemeData>(
        'textSelectionTheme',
        textSelectionTheme,
        defaultValue: defaultData.textSelectionTheme,
        level: DiagnosticLevel.debug,
      ),
    );
    properties.add(
      DiagnosticsProperty<TimePickerThemeData>(
        'timePickerTheme',
        timePickerTheme,
        defaultValue: defaultData.timePickerTheme,
        level: DiagnosticLevel.debug,
      ),
    );
    properties.add(
      DiagnosticsProperty<ToggleButtonsThemeData>(
        'toggleButtonsTheme',
        toggleButtonsTheme,
        level: DiagnosticLevel.debug,
      ),
    );
    properties.add(
      DiagnosticsProperty<TooltipThemeData>(
        'tooltipTheme',
        tooltipTheme,
        level: DiagnosticLevel.debug,
      ),
    );
    // DEPRECATED (newest deprecations at the bottom)
    properties.add(
      DiagnosticsProperty<ButtonBarThemeData>(
        'buttonBarTheme',
        buttonBarTheme,
        defaultValue: defaultData.buttonBarTheme,
        level: DiagnosticLevel.debug,
      ),
    );
    properties.add(
      ColorProperty(
        'dialogBackgroundColor',
        dialogBackgroundColor,
        defaultValue: defaultData.dialogBackgroundColor,
        level: DiagnosticLevel.debug,
      ),
    );
  }
}

/// A [CupertinoThemeData] that defers unspecified theme attributes to an
/// upstream Material [ThemeData].
///
/// This type of [CupertinoThemeData] is used by the Material [Theme] to
/// harmonize the [CupertinoTheme] with the material theme's colors and text
/// styles.
///
/// In the most basic case, [ThemeData]'s `cupertinoOverrideTheme` is null and
/// descendant Cupertino widgets' styling is derived from the Material theme.
///
/// To override individual parts of the Material-derived Cupertino styling,
/// `cupertinoOverrideTheme`'s construction parameters can be used.
///
/// To completely decouple the Cupertino styling from Material theme derivation,
/// another [CupertinoTheme] widget can be inserted as a descendant of the
/// Material [Theme]. On a [MaterialApp], this can be done using the `builder`
/// parameter on the constructor.
///
/// See also:
///
///  * [CupertinoThemeData], whose null constructor parameters default to
///    reasonable iOS styling defaults rather than harmonizing with a Material
///    theme.
///  * [Theme], widget which inserts a [CupertinoTheme] with this
///    [MaterialBasedCupertinoThemeData].
// This class subclasses CupertinoThemeData rather than composes one because it
// _is_ a CupertinoThemeData with partially altered behavior. e.g. its textTheme
// is from the superclass and based on the primaryColor but the primaryColor
// comes from the Material theme unless overridden.
class MaterialBasedCupertinoThemeData extends CupertinoThemeData {
  /// Create a [MaterialBasedCupertinoThemeData] based on a Material [ThemeData]
  /// and its `cupertinoOverrideTheme`.
  MaterialBasedCupertinoThemeData({required ThemeData materialTheme})
    : this._(
        materialTheme,
        (materialTheme.cupertinoOverrideTheme ?? const CupertinoThemeData()).noDefault(),
      );

  MaterialBasedCupertinoThemeData._(this._materialTheme, this._cupertinoOverrideTheme)
    : // Pass all values to the superclass so Material-agnostic properties
      // like barBackgroundColor can still behave like a normal
      // CupertinoThemeData.
      super.raw(
        _cupertinoOverrideTheme.brightness,
        _cupertinoOverrideTheme.primaryColor,
        _cupertinoOverrideTheme.primaryContrastingColor,
        _cupertinoOverrideTheme.textTheme,
        _cupertinoOverrideTheme.barBackgroundColor,
        _cupertinoOverrideTheme.scaffoldBackgroundColor,
        _cupertinoOverrideTheme.applyThemeToAll,
      );

  final ThemeData _materialTheme;
  final NoDefaultCupertinoThemeData _cupertinoOverrideTheme;

  @override
  Brightness get brightness => _cupertinoOverrideTheme.brightness ?? _materialTheme.brightness;

  @override
  Color get primaryColor =>
      _cupertinoOverrideTheme.primaryColor ?? _materialTheme.colorScheme.primary;

  @override
  Color get primaryContrastingColor =>
      _cupertinoOverrideTheme.primaryContrastingColor ?? _materialTheme.colorScheme.onPrimary;

  @override
  Color get scaffoldBackgroundColor =>
      _cupertinoOverrideTheme.scaffoldBackgroundColor ?? _materialTheme.scaffoldBackgroundColor;

  /// Copies the [ThemeData]'s `cupertinoOverrideTheme`.
  ///
  /// Only the specified override attributes of the [ThemeData]'s
  /// `cupertinoOverrideTheme` and the newly specified parameters are in the
  /// returned [CupertinoThemeData]. No derived attributes from iOS defaults or
  /// from cascaded Material theme attributes are copied.
  ///
  /// This [copyWith] cannot change the base Material [ThemeData]. To change the
  /// base Material [ThemeData], create a new Material [Theme] and use
  /// [ThemeData.copyWith] on the Material [ThemeData] instead.
  @override
  MaterialBasedCupertinoThemeData copyWith({
    Brightness? brightness,
    Color? primaryColor,
    Color? primaryContrastingColor,
    CupertinoTextThemeData? textTheme,
    Color? barBackgroundColor,
    Color? scaffoldBackgroundColor,
    bool? applyThemeToAll,
  }) {
    return MaterialBasedCupertinoThemeData._(
      _materialTheme,
      _cupertinoOverrideTheme.copyWith(
        brightness: brightness,
        primaryColor: primaryColor,
        primaryContrastingColor: primaryContrastingColor,
        textTheme: textTheme,
        barBackgroundColor: barBackgroundColor,
        scaffoldBackgroundColor: scaffoldBackgroundColor,
        applyThemeToAll: applyThemeToAll,
      ),
    );
  }

  @override
  CupertinoThemeData resolveFrom(BuildContext context) {
    // Only the cupertino override theme part will be resolved.
    // If the color comes from the material theme it's not resolved.
    return MaterialBasedCupertinoThemeData._(
      _materialTheme,
      _cupertinoOverrideTheme.resolveFrom(context),
    );
  }
}

/// A class for creating a Material theme with a color scheme based off of the
/// colors from a [CupertinoThemeData]. This is intended to be used only in the
/// case when a Material widget is unable to find a Material theme in the tree,
/// but is able to find a Cupertino theme. Most often this will occur when a
/// Material widget is used inside of a [CupertinoApp].
///
/// Besides the colors, this theme will use all the defaults from Material's
/// [ThemeData], so if further customization is needed, it is best to manually
/// add a Material [Theme] above the [CupertinoApp].
class CupertinoBasedMaterialThemeData {
  /// Creates a Material theme with a color scheme based off of the colors from
  /// a [CupertinoThemeData].
  CupertinoBasedMaterialThemeData({required CupertinoThemeData themeData})
    : materialTheme = ThemeData(
        colorScheme: ColorScheme.fromSeed(
          seedColor: themeData.primaryColor,
          brightness: themeData.brightness ?? Brightness.light,
          primary: themeData.primaryColor,
          onPrimary: themeData.primaryContrastingColor,
        ),
      );

  /// The Material theme data with colors based on an existing [CupertinoThemeData].
  final ThemeData materialTheme;
}

@immutable
class _IdentityThemeDataCacheKey {
  const _IdentityThemeDataCacheKey(this.baseTheme, this.localTextGeometry);

  final ThemeData baseTheme;
  final TextTheme localTextGeometry;

  // Using XOR to make the hash function as fast as possible (e.g. Jenkins is
  // noticeably slower).
  @override
  int get hashCode => identityHashCode(baseTheme) ^ identityHashCode(localTextGeometry);

  @override
  bool operator ==(Object other) {
    // We are explicitly ignoring the possibility that the types might not
    // match in the interests of speed.
    return other is _IdentityThemeDataCacheKey &&
        identical(other.baseTheme, baseTheme) &&
        identical(other.localTextGeometry, localTextGeometry);
  }
}

/// Cache of objects of limited size that uses the first in first out eviction
/// strategy (a.k.a least recently inserted).
///
/// The key that was inserted before all other keys is evicted first, i.e. the
/// one inserted least recently.
class _FifoCache<K, V> {
  _FifoCache(this._maximumSize) : assert(_maximumSize > 0);

  /// In Dart the map literal uses a linked hash-map implementation, whose keys
  /// are stored such that [Map.keys] returns them in the order they were
  /// inserted.
  final Map<K, V> _cache = <K, V>{};

  /// Maximum number of entries to store in the cache.
  ///
  /// Once this many entries have been cached, the entry inserted least recently
  /// is evicted when adding a new entry.
  final int _maximumSize;

  /// Returns the previously cached value for the given key, if available;
  /// if not, calls the given callback to obtain it first.
  V putIfAbsent(K key, V Function() loader) {
    assert(key != null);
    final V? result = _cache[key];
    if (result != null) {
      return result;
    }
    if (_cache.length == _maximumSize) {
      _cache.remove(_cache.keys.first);
    }
    return _cache[key] = loader();
  }
}

/// Defines the visual density of user interface components.
///
/// Density, in the context of a UI, is the vertical and horizontal
/// "compactness" of the components in the UI. It is unitless, since it means
/// different things to different UI components.
///
/// The default for visual densities is zero for both vertical and horizontal
/// densities, which corresponds to the default visual density of components in
/// the Material Design specification. It does not affect text sizes, icon
/// sizes, or padding values.
///
/// For example, for buttons, it affects the spacing around the child of the
/// button. For lists, it affects the distance between baselines of entries in
/// the list. For chips, it only affects the vertical size, not the horizontal
/// size.
///
/// Here are some examples of widgets that respond to density changes:
///
///  * [Checkbox]
///  * [Chip]
///  * [ElevatedButton]
///  * [IconButton]
///  * [InputDecorator] (which gives density support to [TextField], etc.)
///  * [ListTile]
///  * [MaterialButton]
///  * [OutlinedButton]
///  * [Radio]
///  * [RawMaterialButton]
///  * [TextButton]
///
/// See also:
///
///  * [ThemeData.visualDensity], where this property is used to specify the base
///    horizontal density of Material components.
///  * [Material design guidance on density](https://material.io/design/layout/applying-density.html).
@immutable
class VisualDensity with Diagnosticable {
  /// A const constructor for [VisualDensity].
  ///
  /// The [horizontal] and [vertical] arguments must be in the interval between
  /// [minimumDensity] and [maximumDensity], inclusive.
  const VisualDensity({this.horizontal = 0.0, this.vertical = 0.0})
    : assert(vertical <= maximumDensity),
      assert(vertical >= minimumDensity),
      assert(horizontal <= maximumDensity),
      assert(horizontal >= minimumDensity);

  /// The minimum allowed density.
  static const double minimumDensity = -4.0;

  /// The maximum allowed density.
  static const double maximumDensity = 4.0;

  /// The default profile for [VisualDensity] in [ThemeData].
  ///
  /// This default value represents a visual density that is less dense than
  /// either [comfortable] or [compact], and corresponds to density values of
  /// zero in both axes.
  static const VisualDensity standard = VisualDensity();

  /// The profile for a "comfortable" interpretation of [VisualDensity].
  ///
  /// Individual components will interpret the density value independently,
  /// making themselves more visually dense than [standard] and less dense than
  /// [compact] to different degrees based on the Material Design specification
  /// of the "comfortable" setting for their particular use case.
  ///
  /// It corresponds to a density value of -1 in both axes.
  static const VisualDensity comfortable = VisualDensity(horizontal: -1.0, vertical: -1.0);

  /// The profile for a "compact" interpretation of [VisualDensity].
  ///
  /// Individual components will interpret the density value independently,
  /// making themselves more visually dense than [standard] and [comfortable] to
  /// different degrees based on the Material Design specification of the
  /// "comfortable" setting for their particular use case.
  ///
  /// It corresponds to a density value of -2 in both axes.
  static const VisualDensity compact = VisualDensity(horizontal: -2.0, vertical: -2.0);

  /// Returns a [VisualDensity] that is adaptive based on the current platform
  /// on which the framework is executing, from [defaultTargetPlatform].
  ///
  /// When [defaultTargetPlatform] is a desktop platform, this returns
  /// [compact], and for other platforms, it returns a default-constructed
  /// [VisualDensity].
  ///
  /// See also:
  ///
  /// * [defaultDensityForPlatform] which returns a [VisualDensity] that is
  ///   adaptive based on the platform given to it.
  /// * [defaultTargetPlatform] which returns the platform on which the
  ///   framework is currently executing.
  static VisualDensity get adaptivePlatformDensity =>
      defaultDensityForPlatform(defaultTargetPlatform);

  /// Returns a [VisualDensity] that is adaptive based on the given [platform].
  ///
  /// For desktop platforms, this returns [compact], and for other platforms, it
  /// returns a default-constructed [VisualDensity].
  ///
  /// See also:
  ///
  /// * [adaptivePlatformDensity] which returns a [VisualDensity] that is
  ///   adaptive based on [defaultTargetPlatform].
  static VisualDensity defaultDensityForPlatform(TargetPlatform platform) {
    return switch (platform) {
      TargetPlatform.android || TargetPlatform.iOS || TargetPlatform.fuchsia => standard,
      TargetPlatform.linux || TargetPlatform.macOS || TargetPlatform.windows => compact,
    };
  }

  /// Copy the current [VisualDensity] with the given values replacing the
  /// current values.
  VisualDensity copyWith({double? horizontal, double? vertical}) {
    return VisualDensity(
      horizontal: horizontal ?? this.horizontal,
      vertical: vertical ?? this.vertical,
    );
  }

  /// The horizontal visual density of UI components.
  ///
  /// This property affects only the horizontal spacing between and within
  /// components, to allow for different UI visual densities. It does not affect
  /// text sizes, icon sizes, or padding values. The default value is 0.0,
  /// corresponding to the metrics specified in the Material Design
  /// specification. The value can range from [minimumDensity] to
  /// [maximumDensity], inclusive.
  ///
  /// See also:
  ///
  ///  * [ThemeData.visualDensity], where this property is used to specify the base
  ///    horizontal density of Material components.
  ///  * [Material design guidance on density](https://material.io/design/layout/applying-density.html).
  final double horizontal;

  /// The vertical visual density of UI components.
  ///
  /// This property affects only the vertical spacing between and within
  /// components, to allow for different UI visual densities. It does not affect
  /// text sizes, icon sizes, or padding values. The default value is 0.0,
  /// corresponding to the metrics specified in the Material Design
  /// specification. The value can range from [minimumDensity] to
  /// [maximumDensity], inclusive.
  ///
  /// See also:
  ///
  ///  * [ThemeData.visualDensity], where this property is used to specify the base
  ///    vertical density of Material components.
  ///  * [Material design guidance on density](https://material.io/design/layout/applying-density.html).
  final double vertical;

  /// The base adjustment in logical pixels of the visual density of UI components.
  ///
  /// The input density values are multiplied by a constant to arrive at a base
  /// size adjustment that fits Material Design guidelines.
  ///
  /// Individual components may adjust this value based upon their own
  /// individual interpretation of density.
  Offset get baseSizeAdjustment {
    // The number of logical pixels represented by an increase or decrease in
    // density by one. The Material Design guidelines say to increment/decrement
    // sizes in terms of four pixel increments.
    const double interval = 4.0;

    return Offset(horizontal, vertical) * interval;
  }

  /// Linearly interpolate between two densities.
  static VisualDensity lerp(VisualDensity a, VisualDensity b, double t) {
    if (identical(a, b)) {
      return a;
    }
    return VisualDensity(
      horizontal: lerpDouble(a.horizontal, b.horizontal, t)!,
      vertical: lerpDouble(a.vertical, b.vertical, t)!,
    );
  }

  /// Return a copy of [constraints] whose minimum width and height have been
  /// updated with the [baseSizeAdjustment].
  ///
  /// The resulting minWidth and minHeight values are clamped to not exceed the
  /// maxWidth and maxHeight values, respectively.
  BoxConstraints effectiveConstraints(BoxConstraints constraints) {
    assert(constraints.debugAssertIsValid());
    return constraints.copyWith(
      minWidth: clampDouble(
        constraints.minWidth + baseSizeAdjustment.dx,
        0.0,
        constraints.maxWidth,
      ),
      minHeight: clampDouble(
        constraints.minHeight + baseSizeAdjustment.dy,
        0.0,
        constraints.maxHeight,
      ),
    );
  }

  @override
  bool operator ==(Object other) {
    if (other.runtimeType != runtimeType) {
      return false;
    }
    return other is VisualDensity && other.horizontal == horizontal && other.vertical == vertical;
  }

  @override
  int get hashCode => Object.hash(horizontal, vertical);

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties.add(DoubleProperty('horizontal', horizontal, defaultValue: 0.0));
    properties.add(DoubleProperty('vertical', vertical, defaultValue: 0.0));
  }

  @override
  String toStringShort() {
    return '${super.toStringShort()}(h: ${debugFormatDouble(horizontal)}, v: ${debugFormatDouble(vertical)})';
  }
}

// BEGIN GENERATED TOKEN PROPERTIES - ColorScheme

// Do not edit by hand. The code between the "BEGIN GENERATED" and
// "END GENERATED" comments are generated from data in the Material
// Design token database by the script:
//   dev/tools/gen_defaults/bin/gen_defaults.dart.

// dart format off
const ColorScheme _colorSchemeLightM3 = ColorScheme(
  brightness: Brightness.light,
  primary: Color(0xFF6750A4),
  onPrimary: Color(0xFFFFFFFF),
  primaryContainer: Color(0xFFEADDFF),
  onPrimaryContainer: Color(0xFF4F378B),
  primaryFixed: Color(0xFFEADDFF),
  primaryFixedDim: Color(0xFFD0BCFF),
  onPrimaryFixed: Color(0xFF21005D),
  onPrimaryFixedVariant: Color(0xFF4F378B),
  secondary: Color(0xFF625B71),
  onSecondary: Color(0xFFFFFFFF),
  secondaryContainer: Color(0xFFE8DEF8),
  onSecondaryContainer: Color(0xFF4A4458),
  secondaryFixed: Color(0xFFE8DEF8),
  secondaryFixedDim: Color(0xFFCCC2DC),
  onSecondaryFixed: Color(0xFF1D192B),
  onSecondaryFixedVariant: Color(0xFF4A4458),
  tertiary: Color(0xFF7D5260),
  onTertiary: Color(0xFFFFFFFF),
  tertiaryContainer: Color(0xFFFFD8E4),
  onTertiaryContainer: Color(0xFF633B48),
  tertiaryFixed: Color(0xFFFFD8E4),
  tertiaryFixedDim: Color(0xFFEFB8C8),
  onTertiaryFixed: Color(0xFF31111D),
  onTertiaryFixedVariant: Color(0xFF633B48),
  error: Color(0xFFB3261E),
  onError: Color(0xFFFFFFFF),
  errorContainer: Color(0xFFF9DEDC),
  onErrorContainer: Color(0xFF8C1D18),
  background: Color(0xFFFEF7FF),
  onBackground: Color(0xFF1D1B20),
  surface: Color(0xFFFEF7FF),
  surfaceBright: Color(0xFFFEF7FF),
  surfaceContainerLowest: Color(0xFFFFFFFF),
  surfaceContainerLow: Color(0xFFF7F2FA),
  surfaceContainer: Color(0xFFF3EDF7),
  surfaceContainerHigh: Color(0xFFECE6F0),
  surfaceContainerHighest: Color(0xFFE6E0E9),
  surfaceDim: Color(0xFFDED8E1),
  onSurface: Color(0xFF1D1B20),
  surfaceVariant: Color(0xFFE7E0EC),
  onSurfaceVariant: Color(0xFF49454F),
  outline: Color(0xFF79747E),
  outlineVariant: Color(0xFFCAC4D0),
  shadow: Color(0xFF000000),
  scrim: Color(0xFF000000),
  inverseSurface: Color(0xFF322F35),
  onInverseSurface: Color(0xFFF5EFF7),
  inversePrimary: Color(0xFFD0BCFF),
  // The surfaceTint color is set to the same color as the primary.
  surfaceTint: Color(0xFF6750A4),
);

const ColorScheme _colorSchemeDarkM3 = ColorScheme(
  brightness: Brightness.dark,
  primary: Color(0xFFD0BCFF),
  onPrimary: Color(0xFF381E72),
  primaryContainer: Color(0xFF4F378B),
  onPrimaryContainer: Color(0xFFEADDFF),
  primaryFixed: Color(0xFFEADDFF),
  primaryFixedDim: Color(0xFFD0BCFF),
  onPrimaryFixed: Color(0xFF21005D),
  onPrimaryFixedVariant: Color(0xFF4F378B),
  secondary: Color(0xFFCCC2DC),
  onSecondary: Color(0xFF332D41),
  secondaryContainer: Color(0xFF4A4458),
  onSecondaryContainer: Color(0xFFE8DEF8),
  secondaryFixed: Color(0xFFE8DEF8),
  secondaryFixedDim: Color(0xFFCCC2DC),
  onSecondaryFixed: Color(0xFF1D192B),
  onSecondaryFixedVariant: Color(0xFF4A4458),
  tertiary: Color(0xFFEFB8C8),
  onTertiary: Color(0xFF492532),
  tertiaryContainer: Color(0xFF633B48),
  onTertiaryContainer: Color(0xFFFFD8E4),
  tertiaryFixed: Color(0xFFFFD8E4),
  tertiaryFixedDim: Color(0xFFEFB8C8),
  onTertiaryFixed: Color(0xFF31111D),
  onTertiaryFixedVariant: Color(0xFF633B48),
  error: Color(0xFFF2B8B5),
  onError: Color(0xFF601410),
  errorContainer: Color(0xFF8C1D18),
  onErrorContainer: Color(0xFFF9DEDC),
  background: Color(0xFF141218),
  onBackground: Color(0xFFE6E0E9),
  surface: Color(0xFF141218),
  surfaceBright: Color(0xFF3B383E),
  surfaceContainerLowest: Color(0xFF0F0D13),
  surfaceContainerLow: Color(0xFF1D1B20),
  surfaceContainer: Color(0xFF211F26),
  surfaceContainerHigh: Color(0xFF2B2930),
  surfaceContainerHighest: Color(0xFF36343B),
  surfaceDim: Color(0xFF141218),
  onSurface: Color(0xFFE6E0E9),
  surfaceVariant: Color(0xFF49454F),
  onSurfaceVariant: Color(0xFFCAC4D0),
  outline: Color(0xFF938F99),
  outlineVariant: Color(0xFF49454F),
  shadow: Color(0xFF000000),
  scrim: Color(0xFF000000),
  inverseSurface: Color(0xFFE6E0E9),
  onInverseSurface: Color(0xFF322F35),
  inversePrimary: Color(0xFF6750A4),
  // The surfaceTint color is set to the same color as the primary.
  surfaceTint: Color(0xFFD0BCFF),
);
// dart format on

// END GENERATED TOKEN PROPERTIES - ColorScheme


--- File: packages/flutter/lib/src/material/theme.dart ---
// Copyright 2014 The Flutter Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

/// @docImport 'app.dart';
/// @docImport 'color_scheme.dart';
/// @docImport 'text_theme.dart';
library;

import 'package:flutter/cupertino.dart';
import 'package:flutter/foundation.dart';

import 'material_localizations.dart';
import 'theme_data.dart';
import 'typography.dart';

export 'theme_data.dart' show Brightness, ThemeData;

/// The duration over which theme changes animate by default.
const Duration kThemeAnimationDuration = Duration(milliseconds: 200);

/// Applies a theme to descendant widgets.
///
/// A theme describes the colors and typographic choices of an application.
///
/// {@youtube 560 315 https://www.youtube.com/watch?v=oTvQDJOBXmM}
///
/// Descendant widgets obtain the current theme's [ThemeData] object using
/// [Theme.of]. When a widget uses [Theme.of], it is automatically rebuilt if
/// the theme later changes, so that the changes can be applied.
///
/// The [Theme] widget implies an [IconTheme] widget, set to the value of the
/// [ThemeData.iconTheme] of the [data] for the [Theme].
///
/// See also:
///
///  * [ThemeData], which describes the actual configuration of a theme.
///  * [AnimatedTheme], which animates the [ThemeData] when it changes rather
///    than changing the theme all at once.
///  * [MaterialApp], which includes an [AnimatedTheme] widget configured via
///    the [MaterialApp.theme] argument.
class Theme extends StatelessWidget {
  /// Applies the given theme [data] to [child].
  const Theme({super.key, required this.data, required this.child});

  /// Specifies the color and typography values for descendant widgets.
  final ThemeData data;

  /// The widget below this widget in the tree.
  ///
  /// {@macro flutter.widgets.ProxyWidget.child}
  final Widget child;

  static final ThemeData _kFallbackTheme = ThemeData.fallback();

  /// The data from the closest [Theme] instance that encloses the given
  /// context.
  ///
  /// If the given context is enclosed in a [Localizations] widget providing
  /// [MaterialLocalizations], the returned data is localized according to the
  /// nearest available [MaterialLocalizations].
  ///
  /// Defaults to [ThemeData.fallback] if there is no [Theme] in the given
  /// build context.
  ///
  /// Typical usage is as follows:
  ///
  /// ```dart
  /// @override
  /// Widget build(BuildContext context) {
  ///   return Text(
  ///     'Example',
  ///     style: Theme.of(context).textTheme.titleLarge,
  ///   );
  /// }
  /// ```
  ///
  /// When the [Theme] is actually created in the same `build` function
  /// (possibly indirectly, e.g. as part of a [MaterialApp]), the `context`
  /// argument to the `build` function can't be used to find the [Theme] (since
  /// it's "above" the widget being returned). In such cases, the following
  /// technique with a [Builder] can be used to provide a new scope with a
  /// [BuildContext] that is "under" the [Theme]:
  ///
  /// ```dart
  /// @override
  /// Widget build(BuildContext context) {
  ///   return MaterialApp(
  ///     theme: ThemeData.light(),
  ///     home: Builder(
  ///       // Create an inner BuildContext so that we can refer to
  ///       // the Theme with Theme.of().
  ///       builder: (BuildContext context) {
  ///         return Center(
  ///           child: Text(
  ///             'Example',
  ///             style: Theme.of(context).textTheme.titleLarge,
  ///           ),
  ///         );
  ///       },
  ///     ),
  ///   );
  /// }
  /// ```
  ///
  /// See also:
  ///
  /// * [ColorScheme.of], a convenience method that returns [ThemeData.colorScheme]
  ///   from the closest [Theme] ancestor. (equivalent to `Theme.of(context).colorScheme`).
  /// * [TextTheme.of], a convenience method that returns [ThemeData.textTheme]
  ///   from the closest [Theme] ancestor. (equivalent to `Theme.of(context).textTheme`).
  /// * [IconTheme.of], that returns [ThemeData.iconTheme] from the closest [Theme] or
  ///   [IconThemeData.fallback] if there is no [IconTheme] ancestor.
  static ThemeData of(BuildContext context) {
    final _InheritedTheme? inheritedTheme =
        context.dependOnInheritedWidgetOfExactType<_InheritedTheme>();
    final MaterialLocalizations? localizations = Localizations.of<MaterialLocalizations>(
      context,
      MaterialLocalizations,
    );
    final ScriptCategory category = localizations?.scriptCategory ?? ScriptCategory.englishLike;
    final InheritedCupertinoTheme? inheritedCupertinoTheme =
        context.dependOnInheritedWidgetOfExactType<InheritedCupertinoTheme>();
    final ThemeData theme =
        inheritedTheme?.theme.data ??
        (inheritedCupertinoTheme != null
            ? CupertinoBasedMaterialThemeData(
              themeData: inheritedCupertinoTheme.theme.data,
            ).materialTheme
            : _kFallbackTheme);
    return ThemeData.localize(theme, theme.typography.geometryThemeFor(category));
  }

  // The inherited themes in widgets library can not infer their values from
  // Theme in material library. Wraps the child with these inherited themes to
  // overrides their values directly.
  Widget _wrapsWidgetThemes(BuildContext context, Widget child) {
    final DefaultSelectionStyle selectionStyle = DefaultSelectionStyle.of(context);
    return IconTheme(
      data: data.iconTheme,
      child: DefaultSelectionStyle(
        selectionColor: data.textSelectionTheme.selectionColor ?? selectionStyle.selectionColor,
        cursorColor: data.textSelectionTheme.cursorColor ?? selectionStyle.cursorColor,
        child: child,
      ),
    );
  }

  CupertinoThemeData _inheritedCupertinoThemeData(BuildContext context) {
    final InheritedCupertinoTheme? inheritedTheme =
        context.dependOnInheritedWidgetOfExactType<InheritedCupertinoTheme>();
    return (inheritedTheme?.theme.data ?? MaterialBasedCupertinoThemeData(materialTheme: data))
        .resolveFrom(context);
  }

  @override
  Widget build(BuildContext context) {
    return _InheritedTheme(
      theme: this,
      child: CupertinoTheme(
        // If a CupertinoThemeData doesn't exist, we're using a
        // MaterialBasedCupertinoThemeData here instead of a CupertinoThemeData
        // because it defers some properties to the Material ThemeData.
        data: _inheritedCupertinoThemeData(context),
        child: _wrapsWidgetThemes(context, child),
      ),
    );
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties.add(DiagnosticsProperty<ThemeData>('data', data, showName: false));
  }
}

class _InheritedTheme extends InheritedTheme {
  const _InheritedTheme({required this.theme, required super.child});

  final Theme theme;

  @override
  Widget wrap(BuildContext context, Widget child) {
    return Theme(data: theme.data, child: child);
  }

  @override
  bool updateShouldNotify(_InheritedTheme old) => theme.data != old.theme.data;
}

/// An interpolation between two [ThemeData]s.
///
/// This class specializes the interpolation of [Tween<ThemeData>] to call the
/// [ThemeData.lerp] method.
///
/// See [Tween] for a discussion on how to use interpolation objects.
class ThemeDataTween extends Tween<ThemeData> {
  /// Creates a [ThemeData] tween.
  ///
  /// The [begin] and [end] properties must be non-null before the tween is
  /// first used, but the arguments can be null if the values are going to be
  /// filled in later.
  ThemeDataTween({super.begin, super.end});

  @override
  ThemeData lerp(double t) => ThemeData.lerp(begin!, end!, t);
}

/// Animated version of [Theme] which automatically transitions the colors,
/// etc, over a given duration whenever the given theme changes.
///
/// Here's an illustration of what using this widget looks like, using a [curve]
/// of [Curves.elasticInOut].
/// {@animation 250 266 https://flutter.github.io/assets-for-api-docs/assets/widgets/animated_theme.mp4}
///
/// See also:
///
///  * [Theme], which [AnimatedTheme] uses to actually apply the interpolated
///    theme.
///  * [ThemeData], which describes the actual configuration of a theme.
///  * [MaterialApp], which includes an [AnimatedTheme] widget configured via
///    the [MaterialApp.theme] argument.
class AnimatedTheme extends ImplicitlyAnimatedWidget {
  /// Creates an animated theme.
  ///
  /// By default, the theme transition uses a linear curve.
  const AnimatedTheme({
    super.key,
    required this.data,
    super.curve,
    super.duration = kThemeAnimationDuration,
    super.onEnd,
    required this.child,
  });

  /// Specifies the color and typography values for descendant widgets.
  final ThemeData data;

  /// The widget below this widget in the tree.
  ///
  /// {@macro flutter.widgets.ProxyWidget.child}
  final Widget child;

  @override
  AnimatedWidgetBaseState<AnimatedTheme> createState() => _AnimatedThemeState();
}

class _AnimatedThemeState extends AnimatedWidgetBaseState<AnimatedTheme> {
  ThemeDataTween? _data;

  @override
  void forEachTween(TweenVisitor<dynamic> visitor) {
    _data =
        visitor(_data, widget.data, (dynamic value) => ThemeDataTween(begin: value as ThemeData))!
            as ThemeDataTween;
  }

  @override
  Widget build(BuildContext context) {
    return Theme(data: _data!.evaluate(animation), child: widget.child);
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder description) {
    super.debugFillProperties(description);
    description.add(
      DiagnosticsProperty<ThemeDataTween>('data', _data, showName: false, defaultValue: null),
    );
  }
}


Instructions for the chapter (Generate content in English unless specified otherwise):
- Start with a clear heading (e.g., `# Chapter 2: ThemeData
`). Use the provided concept name.

- If this is not the first chapter, begin with a brief transition from the previous chapter, referencing it with a proper Markdown link using its name.

- Begin with a high-level motivation explaining what problem this abstraction solves. Start with a central use case as a concrete example. The whole chapter should guide the reader to understand how to solve this use case. Make it very minimal and friendly to beginners.

- If the abstraction is complex, break it down into key concepts. Explain each concept one-by-one in a very beginner-friendly way.

- Explain how to use this abstraction to solve the use case. Give example inputs and outputs for code snippets (if the output isn't values, describe at a high level what will happen).

- Each code block should be BELOW 10 lines! If longer code blocks are needed, break them down into smaller pieces and walk through them one-by-one. Aggresively simplify the code to make it minimal. Use comments to skip non-important implementation details. Each code block should have a beginner friendly explanation right after it.

- Describe the internal implementation to help understand what's under the hood. First provide a non-code or code-light walkthrough on what happens step-by-step when the abstraction is called. It's recommended to use a simple sequenceDiagram with a dummy example - keep it minimal with at most 5 participants to ensure clarity. If participant name has space, use: `participant QP as Query Processing`. .

- Then dive deeper into code for the internal implementation with references to files. Provide example code blocks, but make them similarly simple and beginner-friendly. Explain.

- IMPORTANT: When you need to refer to other core abstractions covered in other chapters, ALWAYS use proper Markdown links like this: [Chapter Title](filename.md). Use the Complete Tutorial Structure above to find the correct filename and the chapter title. Translate the surrounding text.

- Use mermaid diagrams to illustrate complex concepts (```mermaid``` format). .

- Heavily use analogies and examples throughout to help beginners understand.

- End the chapter with a brief conclusion that summarizes what was learned and provides a transition to the next chapter. If there is a next chapter, use a proper Markdown link: [Next Chapter Title](next_chapter_filename).

- Ensure the tone is welcoming and easy for a newcomer to understand.

- Output *only* the Markdown content for this chapter.

Now, directly provide a super beginner-friendly Markdown output (DON'T need ```markdown``` tags):

2025-05-28 18:21:51,213 - INFO - RESPONSE: # Chapter 2: ThemeData

Welcome back! In the last chapter, we learned about the `Theme` widget, which is like a magical box that applies a design plan to parts of your Flutter app. But what exactly is that design plan? That's where `ThemeData` comes in!

### What Problem Does `ThemeData` Solve?

Imagine you're building a large app with many screens. Each screen has buttons, text, backgrounds, and more. If you had to manually pick colors and font styles for every single item on every single screen, it would be a huge mess! What if your company decided to change the main brand color? You'd have to go through your entire app, finding every place you used the old color and replacing it with the new one. This is time-consuming and prone to errors.

`ThemeData` solves this problem by being a central place where you define the overall look and feel of your app. It's like having a style guide for your entire application. Instead of styling each individual button, you define the *default* style for *all* buttons in your `ThemeData`. Then, every button in your app will automatically follow that default style. If you want to change the button style later, you just update the `ThemeData`, and all your buttons instantly change!

Think of it as choosing all the paint colors, furniture styles, and lighting fixtures for an entire house *before* you start decorating any specific room. `ThemeData` is that master plan.

### What is `ThemeData`?

`ThemeData` is **not** a widget. Unlike the `Theme` widget (which you place in your app's layout), `ThemeData` is simply a **Dart class** that holds a bunch of properties about your app's theme. These properties include things like:

*   **Colors:** The main colors used in your app, like the primary color, accent color, background color, etc. (We'll talk even more about colors in the next chapter on [ColorScheme](03_colorscheme_.md)!).
*   **Text Styles:** The default fonts, sizes, and weights for different types of text (headings, body text, captions).
*   **Component Themes:** Specific default styles for individual widgets like buttons (`ElevatedButtonThemeData`, `TextButtonThemeData`), App Bars (`AppBarTheme`), dialogs (`DialogThemeData`), and many more.

Here's a simple example of creating a basic `ThemeData`:

```dart
ThemeData myCustomTheme = ThemeData(
  primarySwatch: Colors.purple, // A collection of purple shades
  textTheme: TextTheme( // Defining text styles
    bodyMedium: TextStyle(fontSize: 16.0),
  ),
  elevatedButtonTheme: ElevatedButtonThemeData( // Styling the button
    style: ElevatedButton.styleFrom(
      backgroundColor: Colors.deepOrange, // Button color
      foregroundColor: Colors.white, // Text color on the button
    ),
  ),
);
```

In this code snippet, we're creating a `ThemeData` object named `myCustomTheme`. We're setting the `primarySwatch` to purple (which provides different shades of purple), defining a default style for body text, and setting a specific background and text color for `ElevatedButton`s.

### How to Use `ThemeData`

You typically use your `ThemeData` object within a `Theme` widget (like we saw in Chapter 1) or within the `theme` property of your `MaterialApp` (which is the most common way to set the theme for your entire app).

Here's how you'd apply the `myCustomTheme` from the previous example to your whole app using `MaterialApp`:

```dart
import 'package:flutter/material.dart';

void main() {
  runApp(const MyApp());
}

class MyApp extends StatelessWidget {
  const MyApp({super.key});

  @override
  Widget build(BuildContext context) {
    ThemeData myCustomTheme = ThemeData(
      primarySwatch: Colors.purple,
      textTheme: const TextTheme(
        bodyMedium: TextStyle(fontSize: 16.0),
      ),
      elevatedButtonTheme: ElevatedButtonThemeData(
        style: ElevatedButton.styleFrom(
          backgroundColor: Colors.deepOrange,
          foregroundColor: Colors.white,
        ),
      ),
    );

    return MaterialApp(
      title: 'Themed App',
      theme: myCustomTheme, // Applying our custom theme!
      home: Scaffold(
        appBar: AppBar(
          title: const Text('Home Screen'),
        ),
        body: Center(
          child: Column(
            mainAxisAlignment: MainAxisAlignment.center,
            children: [
              Text(
                'This text uses the default bodyMedium style.',
              ),
              const SizedBox(height: 20),
              ElevatedButton(
                onPressed: () {
                  // Do something
                },
                child: const Text('Styled Button'),
              ),
            ],
          ),
        ),
      ),
    );
  }
}
```

In this example, because we set `myCustomTheme` in the `theme` property of `MaterialApp`, the `AppBar` will likely pick colors based on the `primarySwatch` (purple), the first `Text` widget will use the `bodyMedium` style (16.0 font size), and the `ElevatedButton` will have a deep orange background and white text. All these styles are defined just once in our `ThemeData`!

### Default `ThemeData`

Flutter provides default light and dark themes out of the box. You can easily use these by setting the `theme` property of your `MaterialApp` to `ThemeData.light()` or `ThemeData.dark()`.

```dart
MaterialApp(
  title: 'Default Light Theme App',
  theme: ThemeData.light(), // Using the default light theme
  home: Scaffold(
    appBar: AppBar(title: Text('Light Theme')),
    body: Center(child: Text('Default colors and fonts')),
  ),
);
```

You can also start with a default theme and then modify specific parts using `copyWith`:

```dart
ThemeData lightThemeWithRedButtons = ThemeData.light().copyWith(
  elevatedButtonTheme: ElevatedButtonThemeData(
    style: ElevatedButton.styleFrom(
      backgroundColor: Colors.red, // Only change button color
      foregroundColor: Colors.white,
    ),
  ),
);

MaterialApp(
  title: 'Customized Light Theme App',
  theme: lightThemeWithRedButtons, // Using the customized light theme
  home: Scaffold(
    appBar: AppBar(title: Text('Custom Theme')),
    body: Center(
      child: ElevatedButton(
        onPressed: () {},
        child: Text('Red Button'),
      ),
    ),
  ),
);
```

This is a powerful way to quickly customize a few things while keeping the rest of the standard Material Design look.

### Under the Hood: `ThemeData.raw` and Interpolation

While you'll mostly use the main `ThemeData` constructor or `ThemeData.light()/dark()`, it's good to know that there's also a `ThemeData.raw` constructor. This constructor is used internally by Flutter, especially for smoothly transitioning between themes (like when switching from light to dark mode).

The `ThemeData.raw` constructor requires you to provide *every single* theme property. This seems like a lot, because it is! It's not meant for you to use directly very often. Its purpose is to allow for linear interpolation between two `ThemeData` objects when animating theme changes (which happens automatically with `AnimatedTheme`).

Here's a simplified idea of how animating themes might work:

```mermaid
sequenceDiagram
    participant AT as AnimatedTheme
    participant TD1 as ThemeData (Start)
    participant TD2 as ThemeData (End)
    participant TD_lerp as ThemeData (Interpolated)

    AT->>TD1: Get initial ThemeData
    AT->>TD2: Get final ThemeData
    AT->>AT: Start Animation (t from 0 to 1)
    loop For each animation step
        AT->>TD1: Get value (e.g. color)
        AT->>TD2: Get matching value (e.g. color)
        AT->>TD_lerp: Calculate interpolated value (lerpColor(color1, color2, t))
        TD_lerp-->>AT: Return interpolated value
    end
    AT->>AT: Pass interpolated ThemeData down widget tree
```

This diagram shows that when `AnimatedTheme` changes, it doesn't just swap `ThemeData` instantly. It uses the `ThemeData.lerp` method to calculate intermediate `ThemeData` objects based on how far the animation has progressed (`t`). This creates a smooth visual transition, for example, colors fading from one to another. The `ThemeData.raw` constructor is what `ThemeData.lerp` uses to construct these intermediate theme data objects.

Looking at the `ThemeData.lerp` code snippet, you can see it calls `Color.lerp`, `TextTheme.lerp`, and other `lerp` methods for individual theme properties:

```dart
// From packages/flutter/lib/src/material/theme_data.dart
static ThemeData lerp(ThemeData a, ThemeData b, double t) {
  if (identical(a, b)) {
    return a;
  }
  return ThemeData.raw(
    // ... other properties
    canvasColor: Color.lerp(a.canvasColor, b.canvasColor, t)!, // Interpolating colors
    // ... other properties
    textTheme: TextTheme.lerp(a.textTheme, b.textTheme, t), // Interpolating text styles
    // ... other properties
  );
}
```

This shows how `ThemeData.lerp` combines the individual properties from two themes based on the interpolation factor `t` (which goes from 0 to 1 during the animation) and uses `ThemeData.raw` to build the resulting interpolated theme.

### Conclusion

`ThemeData` is the blueprint for your app's visual design. By defining colors, text styles, and component appearances in a single place using `ThemeData`, you make your app's look consistent and easy to manage and update. You can use the default light or dark themes, create your own entirely, or modify existing ones. `ThemeData` also supports animating visual changes smoothly using interpolation, leveraging the `ThemeData.raw` constructor internally.

In the next chapter, we'll dive deeper into the concept of [ColorScheme](03_colorscheme_.md), which is a very important part of `ThemeData` and a modern way to manage your app's colors according to Material Design principles.

[ColorScheme](03_colorscheme_.md)
2025-05-28 18:21:51,224 - INFO - PROMPT: 
Write a very beginner-friendly tutorial chapter (in Markdown format) for the project `flutter` about the concept: "ColorScheme
". This is Chapter 3.

Concept Details:
- Name: ColorScheme

- Description:
If `ThemeData` is the master plan, `ColorScheme` is the specific color palette within that plan. It defines a set of named color roles like "primary," "secondary," and "error," ensuring that the colors you use are harmonious and accessible. Picture it like choosing the paint colors for each room in the house blueprint, making sure they all work together nicely.


Complete Tutorial Structure:
1. [Theme
](01_theme_.md)
2. [ThemeData
](02_themedata_.md)
3. [ColorScheme
](03_colorscheme_.md)
4. [ThemeExtension
](04_themeextension_.md)
5. [VisualDensity
](05_visualdensity_.md)
6. [MaterialTapTargetSize
](06_materialtaptargetsize_.md)
7. [DynamicSchemeVariant
](07_dynamicschemevariant_.md)

Context from previous chapters:
# Chapter 1: Theme

Welcome to the very first chapter on how to make your Flutter app look great! In this chapter, we're going to talk about a really important concept called `Theme`.

Imagine you're decorating a room. You pick a color palette, decide on the furniture style, and choose the overall "feel" you want the room to have. In Flutter, `Theme` is kind of like applying that master decoration plan (`ThemeData`) to a specific part of your app's screen.

### What Problem Does `Theme` Solve?

Think about building an app with lots of buttons, text, and other visual elements. If you had to set the color, font size, and style for *each* button and *each* piece of text individually, it would be a lot of work! And if you ever wanted to change your app's look (maybe switch from light mode to dark mode), you'd have to update *everything* manually. That sounds like a nightmare!

`Theme` solves this problem by letting you define a set of styles and colors in one place, and then easily apply those styles to different parts of your app. When you change the `Theme`, all the widgets that use that theme will automatically update their appearance. It's like changing the paint color for a whole room with just one click!

### What is `Theme`?

In Flutter, `Theme` is actually a **widget**. Widgets are the building blocks of Flutter apps. The `Theme` widget is a *special* kind of widget because it doesn't just show something on the screen; it influences how the widgets *below* it in the widget tree look.

When you place a `Theme` widget around other widgets, you're essentially telling all those widgets to follow the style rules defined in the `Theme`.

Here's a super simple peek at what using `Theme` looks like:

```dart
MaterialApp(
  home: Scaffold(
    body: Theme( // Here's the Theme widget!
      data: ThemeData( // We'll learn about this in the next chapter!
        primaryColor: Colors.blue,
        // Other style settings...
      ),
      child: Center(
        child: Text(
          'Hello, Themed Text!',
        ),
      ),
    ),
  ),
);
```

In this example, we're wrapping a `Center` widget (which contains a `Text` widget) with a `Theme` widget. We're giving the `Theme` some `data` (we'll dive deep into `ThemeData` in the next chapter!), and this `data` tells it how things like primary colors should look. Any widgets inside this `Theme` that use primary colors will now use the blue color we specified.

### How `Theme` Works (Under the Hood)

You might be wondering how a widget can "talk" to the widgets below it. Flutter uses a system called "Inherited Widgets" for this. `Theme` is an example of an inherited widget.

Think of an inherited widget like a shop sign that everyone in the building can see and use. When a widget needs some information (like what the theme color should be), it "looks up" the widget tree until it finds the nearest `Theme` widget. Then it uses the `data` from that `Theme` widget to style itself.

Here's a simplified idea of how a `Text` widget might get its color:

```mermaid
sequenceDiagram
    participant T as Text Widget
    participant B as BuildContext
    participant TH as Theme Widget
    participant TD as ThemeData

    T->>B: "Hey BuildContext, what's the current theme data?"
    B->>TH: "Nearest Theme widget, what's your data?"
    TH->>TD: "ThemeData object, what's the text color?"
    TD-->>TH: Returns text color
    TH-->>B: Returns text color
    B-->>T: Returns text color
    T->>T: Displays text with that color
```
This diagram shows a `Text` widget asking its `BuildContext` (which connects it to the widget tree) for the theme information. The `BuildContext` then finds the `Theme` widget, which provides the `ThemeData`. The `Text` widget can then use this `ThemeData` to decide how it should look.

The core of this mechanism is the `Theme.of(BuildContext context)` method. This is the standard way for any widget in Flutter to access the theme information from the nearest `Theme` ancestor in the tree. You'll see `Theme.of(context)` very often in Flutter code!

Looking at the `Theme.of` method in the `theme.dart` file, you can see how it uses `context.dependOnInheritedWidgetOfExactType<_InheritedTheme>()` to find the nearest `_InheritedTheme` (which is the internal widget Flutter uses for the `Theme`).

```dart
// From packages/flutter/lib/src/material/theme.dart
static ThemeData of(BuildContext context) {
  final _InheritedTheme? inheritedTheme =
      context.dependOnInheritedWidgetOfExactType<_InheritedTheme>();
  // ... other logic ...
  final ThemeData theme =
      inheritedTheme?.theme.data ??
      // ... fallback logic ...
      _kFallbackTheme;
  return ThemeData.localize(theme, theme.typography.geometryThemeFor(category));
}
```
Don't worry too much about all the details here; the key is that `dependOnInheritedWidgetOfExactType` is the magic that allows a widget to look up the tree and get information from a parent `Theme` widget.

### Applying `Theme` to a Part of Your App

You can use the `Theme` widget to apply different themes to different parts of your app. For example, you might have a standard theme for most of your app, but a specific section might have a slightly different look, perhaps highlighting a special feature.

```dart
// Imagine this is somewhere inside your app's build method
Column(
  children: [
    Text('Regular Text'), // This uses the main app theme
    Theme( // Applying a different theme here
      data: ThemeData(
        primaryColor: Colors.green, // A different color
      ),
      child: ElevatedButton( // This button will use the green primary color
        onPressed: () {},
        child: Text('Green Button'),
      ),
    ),
    Text('More Regular Text'), // This goes back to the main app theme
  ],
)
```

In this example, the `ElevatedButton` inside the second `Theme` widget will use the specified green color for its primary color, while the `Text` widgets will use the colors from the `ThemeData` higher up in the widget tree (likely from your `MaterialApp`).

This ability to apply themes to specific subtrees of your app gives you a lot of flexibility in designing your UI.

### Conclusion

In this chapter, we learned that `Theme` is a fundamental Flutter widget used to apply styles and visual configurations (`ThemeData`) to parts of your application. It helps you manage your app's look in a consistent and efficient way. We saw how `Theme` works using the concept of inherited widgets and how you can apply different themes to different sections of your app.

Now that you have a basic understanding of `Theme`, the next step is to explore what actually *goes inside* the `Theme` widget: the `ThemeData`.

[ThemeData](02_themedata_.md)
---
# Chapter 2: ThemeData

Welcome back! In the last chapter, we learned about the `Theme` widget, which is like a magical box that applies a design plan to parts of your Flutter app. But what exactly is that design plan? That's where `ThemeData` comes in!

### What Problem Does `ThemeData` Solve?

Imagine you're building a large app with many screens. Each screen has buttons, text, backgrounds, and more. If you had to manually pick colors and font styles for every single item on every single screen, it would be a huge mess! What if your company decided to change the main brand color? You'd have to go through your entire app, finding every place you used the old color and replacing it with the new one. This is time-consuming and prone to errors.

`ThemeData` solves this problem by being a central place where you define the overall look and feel of your app. It's like having a style guide for your entire application. Instead of styling each individual button, you define the *default* style for *all* buttons in your `ThemeData`. Then, every button in your app will automatically follow that default style. If you want to change the button style later, you just update the `ThemeData`, and all your buttons instantly change!

Think of it as choosing all the paint colors, furniture styles, and lighting fixtures for an entire house *before* you start decorating any specific room. `ThemeData` is that master plan.

### What is `ThemeData`?

`ThemeData` is **not** a widget. Unlike the `Theme` widget (which you place in your app's layout), `ThemeData` is simply a **Dart class** that holds a bunch of properties about your app's theme. These properties include things like:

*   **Colors:** The main colors used in your app, like the primary color, accent color, background color, etc. (We'll talk even more about colors in the next chapter on [ColorScheme](03_colorscheme_.md)!).
*   **Text Styles:** The default fonts, sizes, and weights for different types of text (headings, body text, captions).
*   **Component Themes:** Specific default styles for individual widgets like buttons (`ElevatedButtonThemeData`, `TextButtonThemeData`), App Bars (`AppBarTheme`), dialogs (`DialogThemeData`), and many more.

Here's a simple example of creating a basic `ThemeData`:

```dart
ThemeData myCustomTheme = ThemeData(
  primarySwatch: Colors.purple, // A collection of purple shades
  textTheme: TextTheme( // Defining text styles
    bodyMedium: TextStyle(fontSize: 16.0),
  ),
  elevatedButtonTheme: ElevatedButtonThemeData( // Styling the button
    style: ElevatedButton.styleFrom(
      backgroundColor: Colors.deepOrange, // Button color
      foregroundColor: Colors.white, // Text color on the button
    ),
  ),
);
```

In this code snippet, we're creating a `ThemeData` object named `myCustomTheme`. We're setting the `primarySwatch` to purple (which provides different shades of purple), defining a default style for body text, and setting a specific background and text color for `ElevatedButton`s.

### How to Use `ThemeData`

You typically use your `ThemeData` object within a `Theme` widget (like we saw in Chapter 1) or within the `theme` property of your `MaterialApp` (which is the most common way to set the theme for your entire app).

Here's how you'd apply the `myCustomTheme` from the previous example to your whole app using `MaterialApp`:

```dart
import 'package:flutter/material.dart';

void main() {
  runApp(const MyApp());
}

class MyApp extends StatelessWidget {
  const MyApp({super.key});

  @override
  Widget build(BuildContext context) {
    ThemeData myCustomTheme = ThemeData(
      primarySwatch: Colors.purple,
      textTheme: const TextTheme(
        bodyMedium: TextStyle(fontSize: 16.0),
      ),
      elevatedButtonTheme: ElevatedButtonThemeData(
        style: ElevatedButton.styleFrom(
          backgroundColor: Colors.deepOrange,
          foregroundColor: Colors.white,
        ),
      ),
    );

    return MaterialApp(
      title: 'Themed App',
      theme: myCustomTheme, // Applying our custom theme!
      home: Scaffold(
        appBar: AppBar(
          title: const Text('Home Screen'),
        ),
        body: Center(
          child: Column(
            mainAxisAlignment: MainAxisAlignment.center,
            children: [
              Text(
                'This text uses the default bodyMedium style.',
              ),
              const SizedBox(height: 20),
              ElevatedButton(
                onPressed: () {
                  // Do something
                },
                child: const Text('Styled Button'),
              ),
            ],
          ),
        ),
      ),
    );
  }
}
```

In this example, because we set `myCustomTheme` in the `theme` property of `MaterialApp`, the `AppBar` will likely pick colors based on the `primarySwatch` (purple), the first `Text` widget will use the `bodyMedium` style (16.0 font size), and the `ElevatedButton` will have a deep orange background and white text. All these styles are defined just once in our `ThemeData`!

### Default `ThemeData`

Flutter provides default light and dark themes out of the box. You can easily use these by setting the `theme` property of your `MaterialApp` to `ThemeData.light()` or `ThemeData.dark()`.

```dart
MaterialApp(
  title: 'Default Light Theme App',
  theme: ThemeData.light(), // Using the default light theme
  home: Scaffold(
    appBar: AppBar(title: Text('Light Theme')),
    body: Center(child: Text('Default colors and fonts')),
  ),
);
```

You can also start with a default theme and then modify specific parts using `copyWith`:

```dart
ThemeData lightThemeWithRedButtons = ThemeData.light().copyWith(
  elevatedButtonTheme: ElevatedButtonThemeData(
    style: ElevatedButton.styleFrom(
      backgroundColor: Colors.red, // Only change button color
      foregroundColor: Colors.white,
    ),
  ),
);

MaterialApp(
  title: 'Customized Light Theme App',
  theme: lightThemeWithRedButtons, // Using the customized light theme
  home: Scaffold(
    appBar: AppBar(title: Text('Custom Theme')),
    body: Center(
      child: ElevatedButton(
        onPressed: () {},
        child: Text('Red Button'),
      ),
    ),
  ),
);
```

This is a powerful way to quickly customize a few things while keeping the rest of the standard Material Design look.

### Under the Hood: `ThemeData.raw` and Interpolation

While you'll mostly use the main `ThemeData` constructor or `ThemeData.light()/dark()`, it's good to know that there's also a `ThemeData.raw` constructor. This constructor is used internally by Flutter, especially for smoothly transitioning between themes (like when switching from light to dark mode).

The `ThemeData.raw` constructor requires you to provide *every single* theme property. This seems like a lot, because it is! It's not meant for you to use directly very often. Its purpose is to allow for linear interpolation between two `ThemeData` objects when animating theme changes (which happens automatically with `AnimatedTheme`).

Here's a simplified idea of how animating themes might work:

```mermaid
sequenceDiagram
    participant AT as AnimatedTheme
    participant TD1 as ThemeData (Start)
    participant TD2 as ThemeData (End)
    participant TD_lerp as ThemeData (Interpolated)

    AT->>TD1: Get initial ThemeData
    AT->>TD2: Get final ThemeData
    AT->>AT: Start Animation (t from 0 to 1)
    loop For each animation step
        AT->>TD1: Get value (e.g. color)
        AT->>TD2: Get matching value (e.g. color)
        AT->>TD_lerp: Calculate interpolated value (lerpColor(color1, color2, t))
        TD_lerp-->>AT: Return interpolated value
    end
    AT->>AT: Pass interpolated ThemeData down widget tree
```

This diagram shows that when `AnimatedTheme` changes, it doesn't just swap `ThemeData` instantly. It uses the `ThemeData.lerp` method to calculate intermediate `ThemeData` objects based on how far the animation has progressed (`t`). This creates a smooth visual transition, for example, colors fading from one to another. The `ThemeData.raw` constructor is what `ThemeData.lerp` uses to construct these intermediate theme data objects.

Looking at the `ThemeData.lerp` code snippet, you can see it calls `Color.lerp`, `TextTheme.lerp`, and other `lerp` methods for individual theme properties:

```dart
// From packages/flutter/lib/src/material/theme_data.dart
static ThemeData lerp(ThemeData a, ThemeData b, double t) {
  if (identical(a, b)) {
    return a;
  }
  return ThemeData.raw(
    // ... other properties
    canvasColor: Color.lerp(a.canvasColor, b.canvasColor, t)!, // Interpolating colors
    // ... other properties
    textTheme: TextTheme.lerp(a.textTheme, b.textTheme, t), // Interpolating text styles
    // ... other properties
  );
}
```

This shows how `ThemeData.lerp` combines the individual properties from two themes based on the interpolation factor `t` (which goes from 0 to 1 during the animation) and uses `ThemeData.raw` to build the resulting interpolated theme.

### Conclusion

`ThemeData` is the blueprint for your app's visual design. By defining colors, text styles, and component appearances in a single place using `ThemeData`, you make your app's look consistent and easy to manage and update. You can use the default light or dark themes, create your own entirely, or modify existing ones. `ThemeData` also supports animating visual changes smoothly using interpolation, leveraging the `ThemeData.raw` constructor internally.

In the next chapter, we'll dive deeper into the concept of [ColorScheme](03_colorscheme_.md), which is a very important part of `ThemeData` and a modern way to manage your app's colors according to Material Design principles.

[ColorScheme](03_colorscheme_.md)

Relevant Code Snippets (Code itself remains unchanged):
--- File: packages/flutter/lib/src/material/color_scheme.dart ---
// Copyright 2014 The Flutter Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

/// @docImport 'input_decorator.dart';
/// @docImport 'scaffold.dart';
library;

import 'dart:async';
import 'dart:ui' as ui;

import 'package:flutter/foundation.dart';
import 'package:flutter/widgets.dart';
import 'package:material_color_utilities/material_color_utilities.dart';

import 'colors.dart';
import 'theme.dart';

/// The algorithm used to construct a [ColorScheme] in [ColorScheme.fromSeed].
///
/// The `tonalSpot` variant builds default Material scheme colors. These colors are
/// mapped to light or dark tones to achieve visually accessible color
/// pairings with sufficient contrast between foreground and background elements.
///
/// In some cases, the tones can prevent colors from appearing as intended,
/// such as when a color is too light to offer enough contrast for accessibility.
/// Color fidelity (`DynamicSchemeVariant.fidelity`) is a feature that adjusts
/// tones in these cases to produce the intended visual results without harming
/// visual contrast.
enum DynamicSchemeVariant {
  /// Default for Material theme colors. Builds pastel palettes with a low chroma.
  tonalSpot,

  /// The resulting color palettes match seed color, even if the seed color
  /// is very bright (high chroma).
  fidelity,

  /// All colors are grayscale, no chroma.
  monochrome,

  /// Close to grayscale, a hint of chroma.
  neutral,

  /// Pastel colors, high chroma palettes. The primary palette's chroma is at
  /// maximum. Use `fidelity` instead if tokens should alter their tone to match
  /// the palette vibrancy.
  vibrant,

  /// Pastel colors, medium chroma palettes. The primary palette's hue is
  /// different from the seed color, for variety.
  expressive,

  /// Almost identical to `fidelity`. Tokens and palettes match the seed color.
  /// [ColorScheme.primaryContainer] is the seed color, adjusted to ensure
  /// contrast with surfaces. The tertiary palette is analogue of the seed color.
  content,

  /// A playful theme - the seed color's hue does not appear in the theme.
  rainbow,

  /// A playful theme - the seed color's hue does not appear in the theme.
  fruitSalad,
}

/// {@template flutter.material.color_scheme.ColorScheme}
/// A set of 45 colors based on the
/// [Material spec](https://m3.material.io/styles/color/the-color-system/color-roles)
/// that can be used to configure the color properties of most components.
/// {@endtemplate}
///
/// ### Colors in Material 3
///
/// {@macro flutter.material.colors.colorRoles}
///
/// The main accent color groups in the scheme are [primary], [secondary],
/// and [tertiary].
///
/// * Primary colors are used for key components across the UI, such as the FAB,
///   prominent buttons, and active states.
///
/// * Secondary colors are used for less prominent components in the UI, such as
///   filter chips, while expanding the opportunity for color expression.
///
/// * Tertiary colors are used for contrasting accents that can be used to
///   balance primary and secondary colors or bring heightened attention to
///   an element, such as an input field. The tertiary colors are left
///   for makers to use at their discretion and are intended to support
///   broader color expression in products.
///
/// Each accent color group (primary, secondary and tertiary) includes '-Fixed'
/// '-Dim' color roles, such as [primaryFixed] and [primaryFixedDim]. Fixed roles
/// are appropriate to use in places where Container roles are normally used,
/// but they stay the same color between light and dark themes. The '-Dim' roles
/// provide a stronger, more emphasized color with the same fixed behavior.
///
/// The remaining colors of the scheme are composed of neutral colors used for
/// backgrounds and surfaces, as well as specific colors for errors, dividers
/// and shadows. Surface colors are used for backgrounds and large, low-emphasis
/// areas of the screen.
///
/// Material 3 also introduces tone-based surfaces and surface containers.
/// They replace the old opacity-based model which applied a tinted overlay on
/// top of surfaces based on their elevation. These colors include: [surfaceBright],
/// [surfaceDim], [surfaceContainerLowest], [surfaceContainerLow], [surfaceContainer],
/// [surfaceContainerHigh], and [surfaceContainerHighest].
///
/// Many of the colors have matching 'on' colors, which are used for drawing
/// content on top of the matching color. For example, if something is using
/// [primary] for a background color, [onPrimary] would be used to paint text
/// and icons on top of it. For this reason, the 'on' colors should have a
/// contrast ratio with their matching colors of at least 4.5:1 in order to
/// be readable. On '-FixedVariant' roles, such as [onPrimaryFixedVariant],
/// also have the same color between light and dark themes, but compared
/// with on '-Fixed' roles, such as [onPrimaryFixed], they provide a
/// lower-emphasis option for text and icons.
///
/// {@tool dartpad}
/// This example shows all Material [ColorScheme] roles in light and dark
/// brightnesses.
///
/// ** See code in examples/api/lib/material/color_scheme/color_scheme.0.dart **
/// {@end-tool}
///
/// ### Setting Colors in Flutter
///
///{@macro flutter.material.colors.settingColors}
@immutable
class ColorScheme with Diagnosticable {
  /// Create a ColorScheme instance from the given colors.
  ///
  /// [ColorScheme.fromSeed] can be used as a simpler way to create a full
  /// color scheme derived from a single seed color.
  ///
  /// For the color parameters that are nullable, it is still recommended
  /// that applications provide values for them. They are only nullable due
  /// to backwards compatibility concerns.
  ///
  /// If a color is not provided, the closest fallback color from the given
  /// colors will be used for it (e.g. [primaryContainer] will default
  /// to [primary]). Material Design 3 makes use of these colors for many
  /// component defaults, so for the best results the application should
  /// supply colors for all the parameters. An easy way to ensure this is to
  /// use [ColorScheme.fromSeed] to generate a full set of colors.
  ///
  /// During the migration to Material Design 3, if an app's
  /// [ThemeData.useMaterial3] is false, then components will only
  /// use the following colors for defaults:
  ///
  /// * [primary]
  /// * [onPrimary]
  /// * [secondary]
  /// * [onSecondary]
  /// * [error]
  /// * [onError]
  /// * [surface]
  /// * [onSurface]
  /// DEPRECATED:
  /// * [background]
  /// * [onBackground]
  const ColorScheme({
    required this.brightness,
    required this.primary,
    required this.onPrimary,
    Color? primaryContainer,
    Color? onPrimaryContainer,
    Color? primaryFixed,
    Color? primaryFixedDim,
    Color? onPrimaryFixed,
    Color? onPrimaryFixedVariant,
    required this.secondary,
    required this.onSecondary,
    Color? secondaryContainer,
    Color? onSecondaryContainer,
    Color? secondaryFixed,
    Color? secondaryFixedDim,
    Color? onSecondaryFixed,
    Color? onSecondaryFixedVariant,
    Color? tertiary,
    Color? onTertiary,
    Color? tertiaryContainer,
    Color? onTertiaryContainer,
    Color? tertiaryFixed,
    Color? tertiaryFixedDim,
    Color? onTertiaryFixed,
    Color? onTertiaryFixedVariant,
    required this.error,
    required this.onError,
    Color? errorContainer,
    Color? onErrorContainer,
    required this.surface,
    required this.onSurface,
    Color? surfaceDim,
    Color? surfaceBright,
    Color? surfaceContainerLowest,
    Color? surfaceContainerLow,
    Color? surfaceContainer,
    Color? surfaceContainerHigh,
    Color? surfaceContainerHighest,
    Color? onSurfaceVariant,
    Color? outline,
    Color? outlineVariant,
    Color? shadow,
    Color? scrim,
    Color? inverseSurface,
    Color? onInverseSurface,
    Color? inversePrimary,
    Color? surfaceTint,
    @Deprecated(
      'Use surface instead. '
      'This feature was deprecated after v3.18.0-0.1.pre.',
    )
    Color? background,
    @Deprecated(
      'Use onSurface instead. '
      'This feature was deprecated after v3.18.0-0.1.pre.',
    )
    Color? onBackground,
    @Deprecated(
      'Use surfaceContainerHighest instead. '
      'This feature was deprecated after v3.18.0-0.1.pre.',
    )
    Color? surfaceVariant,
  }) : _primaryContainer = primaryContainer,
       _onPrimaryContainer = onPrimaryContainer,
       _primaryFixed = primaryFixed,
       _primaryFixedDim = primaryFixedDim,
       _onPrimaryFixed = onPrimaryFixed,
       _onPrimaryFixedVariant = onPrimaryFixedVariant,
       _secondaryContainer = secondaryContainer,
       _onSecondaryContainer = onSecondaryContainer,
       _secondaryFixed = secondaryFixed,
       _secondaryFixedDim = secondaryFixedDim,
       _onSecondaryFixed = onSecondaryFixed,
       _onSecondaryFixedVariant = onSecondaryFixedVariant,
       _tertiary = tertiary,
       _onTertiary = onTertiary,
       _tertiaryContainer = tertiaryContainer,
       _onTertiaryContainer = onTertiaryContainer,
       _tertiaryFixed = tertiaryFixed,
       _tertiaryFixedDim = tertiaryFixedDim,
       _onTertiaryFixed = onTertiaryFixed,
       _onTertiaryFixedVariant = onTertiaryFixedVariant,
       _errorContainer = errorContainer,
       _onErrorContainer = onErrorContainer,
       _surfaceDim = surfaceDim,
       _surfaceBright = surfaceBright,
       _surfaceContainerLowest = surfaceContainerLowest,
       _surfaceContainerLow = surfaceContainerLow,
       _surfaceContainer = surfaceContainer,
       _surfaceContainerHigh = surfaceContainerHigh,
       _surfaceContainerHighest = surfaceContainerHighest,
       _onSurfaceVariant = onSurfaceVariant,
       _outline = outline,
       _outlineVariant = outlineVariant,
       _shadow = shadow,
       _scrim = scrim,
       _inverseSurface = inverseSurface,
       _onInverseSurface = onInverseSurface,
       _inversePrimary = inversePrimary,
       _surfaceTint = surfaceTint,
       // DEPRECATED (newest deprecations at the bottom)
       _background = background,
       _onBackground = onBackground,
       _surfaceVariant = surfaceVariant;

  /// Generate a [ColorScheme] derived from the given `seedColor`.
  ///
  /// Using the `seedColor` as a starting point, a set of tonal palettes are
  /// constructed. By default, the tonal palettes are based on the Material 3
  /// Color system and provide all of the [ColorScheme] colors. These colors are
  /// designed to work well together and meet contrast requirements for
  /// accessibility.
  ///
  /// If any of the optional color parameters are non-null they will be
  /// used in place of the generated colors for that field in the resulting
  /// color scheme. This allows apps to override specific colors for their
  /// needs.
  ///
  /// Given the nature of the algorithm, the `seedColor` may not wind up as
  /// one of the ColorScheme colors.
  ///
  /// The `dynamicSchemeVariant` parameter creates different types of
  /// [DynamicScheme]s, which are used to generate different styles of [ColorScheme]s.
  /// By default, `dynamicSchemeVariant` is set to `tonalSpot`. A [ColorScheme]
  /// constructed by `dynamicSchemeVariant.tonalSpot` has pastel palettes and
  /// won't be too "colorful" even if the `seedColor` has a high chroma value.
  /// If the resulting color scheme is too dark, consider setting `dynamicSchemeVariant`
  /// to [DynamicSchemeVariant.fidelity], whose palettes match the seed color.
  ///
  /// The `contrastLevel` parameter indicates the contrast level between color
  /// pairs, such as [primary] and [onPrimary]. 0.0 is the default (normal);
  /// -1.0 is the lowest; 1.0 is the highest. From Material Design guideline, the
  /// medium and high contrast correspond to 0.5 and 1.0 respectively.
  ///
  /// {@tool dartpad}
  /// This sample shows how to use [ColorScheme.fromSeed] to create dynamic
  /// color schemes with different [DynamicSchemeVariant]s and different
  /// contrast level.
  ///
  /// ** See code in examples/api/lib/material/color_scheme/color_scheme.0.dart **
  /// {@end-tool}
  ///
  /// See also:
  ///
  ///  * <https://m3.material.io/styles/color/the-color-system/color-roles>, the
  ///    Material 3 Color system specification.
  ///  * <https://pub.dev/packages/material_color_utilities>, the package
  ///    used to generate the tonal palettes needed for the scheme.
  factory ColorScheme.fromSeed({
    required Color seedColor,
    Brightness brightness = Brightness.light,
    DynamicSchemeVariant dynamicSchemeVariant = DynamicSchemeVariant.tonalSpot,
    double contrastLevel = 0.0,
    Color? primary,
    Color? onPrimary,
    Color? primaryContainer,
    Color? onPrimaryContainer,
    Color? primaryFixed,
    Color? primaryFixedDim,
    Color? onPrimaryFixed,
    Color? onPrimaryFixedVariant,
    Color? secondary,
    Color? onSecondary,
    Color? secondaryContainer,
    Color? onSecondaryContainer,
    Color? secondaryFixed,
    Color? secondaryFixedDim,
    Color? onSecondaryFixed,
    Color? onSecondaryFixedVariant,
    Color? tertiary,
    Color? onTertiary,
    Color? tertiaryContainer,
    Color? onTertiaryContainer,
    Color? tertiaryFixed,
    Color? tertiaryFixedDim,
    Color? onTertiaryFixed,
    Color? onTertiaryFixedVariant,
    Color? error,
    Color? onError,
    Color? errorContainer,
    Color? onErrorContainer,
    Color? outline,
    Color? outlineVariant,
    Color? surface,
    Color? onSurface,
    Color? surfaceDim,
    Color? surfaceBright,
    Color? surfaceContainerLowest,
    Color? surfaceContainerLow,
    Color? surfaceContainer,
    Color? surfaceContainerHigh,
    Color? surfaceContainerHighest,
    Color? onSurfaceVariant,
    Color? inverseSurface,
    Color? onInverseSurface,
    Color? inversePrimary,
    Color? shadow,
    Color? scrim,
    Color? surfaceTint,
    @Deprecated(
      'Use surface instead. '
      'This feature was deprecated after v3.18.0-0.1.pre.',
    )
    Color? background,
    @Deprecated(
      'Use onSurface instead. '
      'This feature was deprecated after v3.18.0-0.1.pre.',
    )
    Color? onBackground,
    @Deprecated(
      'Use surfaceContainerHighest instead. '
      'This feature was deprecated after v3.18.0-0.1.pre.',
    )
    Color? surfaceVariant,
  }) {
    final DynamicScheme scheme = _buildDynamicScheme(
      brightness,
      seedColor,
      dynamicSchemeVariant,
      contrastLevel,
    );

    return ColorScheme(
      primary: primary ?? Color(MaterialDynamicColors.primary.getArgb(scheme)),
      onPrimary: onPrimary ?? Color(MaterialDynamicColors.onPrimary.getArgb(scheme)),
      primaryContainer:
          primaryContainer ?? Color(MaterialDynamicColors.primaryContainer.getArgb(scheme)),
      onPrimaryContainer:
          onPrimaryContainer ?? Color(MaterialDynamicColors.onPrimaryContainer.getArgb(scheme)),
      primaryFixed: primaryFixed ?? Color(MaterialDynamicColors.primaryFixed.getArgb(scheme)),
      primaryFixedDim:
          primaryFixedDim ?? Color(MaterialDynamicColors.primaryFixedDim.getArgb(scheme)),
      onPrimaryFixed: onPrimaryFixed ?? Color(MaterialDynamicColors.onPrimaryFixed.getArgb(scheme)),
      onPrimaryFixedVariant:
          onPrimaryFixedVariant ??
          Color(MaterialDynamicColors.onPrimaryFixedVariant.getArgb(scheme)),
      secondary: secondary ?? Color(MaterialDynamicColors.secondary.getArgb(scheme)),
      onSecondary: onSecondary ?? Color(MaterialDynamicColors.onSecondary.getArgb(scheme)),
      secondaryContainer:
          secondaryContainer ?? Color(MaterialDynamicColors.secondaryContainer.getArgb(scheme)),
      onSecondaryContainer:
          onSecondaryContainer ?? Color(MaterialDynamicColors.onSecondaryContainer.getArgb(scheme)),
      secondaryFixed: secondaryFixed ?? Color(MaterialDynamicColors.secondaryFixed.getArgb(scheme)),
      secondaryFixedDim:
          secondaryFixedDim ?? Color(MaterialDynamicColors.secondaryFixedDim.getArgb(scheme)),
      onSecondaryFixed:
          onSecondaryFixed ?? Color(MaterialDynamicColors.onSecondaryFixed.getArgb(scheme)),
      onSecondaryFixedVariant:
          onSecondaryFixedVariant ??
          Color(MaterialDynamicColors.onSecondaryFixedVariant.getArgb(scheme)),
      tertiary: tertiary ?? Color(MaterialDynamicColors.tertiary.getArgb(scheme)),
      onTertiary: onTertiary ?? Color(MaterialDynamicColors.onTertiary.getArgb(scheme)),
      tertiaryContainer:
          tertiaryContainer ?? Color(MaterialDynamicColors.tertiaryContainer.getArgb(scheme)),
      onTertiaryContainer:
          onTertiaryContainer ?? Color(MaterialDynamicColors.onTertiaryContainer.getArgb(scheme)),
      tertiaryFixed: tertiaryFixed ?? Color(MaterialDynamicColors.tertiaryFixed.getArgb(scheme)),
      tertiaryFixedDim:
          tertiaryFixedDim ?? Color(MaterialDynamicColors.tertiaryFixedDim.getArgb(scheme)),
      onTertiaryFixed:
          onTertiaryFixed ?? Color(MaterialDynamicColors.onTertiaryFixed.getArgb(scheme)),
      onTertiaryFixedVariant:
          onTertiaryFixedVariant ??
          Color(MaterialDynamicColors.onTertiaryFixedVariant.getArgb(scheme)),
      error: error ?? Color(MaterialDynamicColors.error.getArgb(scheme)),
      onError: onError ?? Color(MaterialDynamicColors.onError.getArgb(scheme)),
      errorContainer: errorContainer ?? Color(MaterialDynamicColors.errorContainer.getArgb(scheme)),
      onErrorContainer:
          onErrorContainer ?? Color(MaterialDynamicColors.onErrorContainer.getArgb(scheme)),
      outline: outline ?? Color(MaterialDynamicColors.outline.getArgb(scheme)),
      outlineVariant: outlineVariant ?? Color(MaterialDynamicColors.outlineVariant.getArgb(scheme)),
      surface: surface ?? Color(MaterialDynamicColors.surface.getArgb(scheme)),
      surfaceDim: surfaceDim ?? Color(MaterialDynamicColors.surfaceDim.getArgb(scheme)),
      surfaceBright: surfaceBright ?? Color(MaterialDynamicColors.surfaceBright.getArgb(scheme)),
      surfaceContainerLowest:
          surfaceContainerLowest ??
          Color(MaterialDynamicColors.surfaceContainerLowest.getArgb(scheme)),
      surfaceContainerLow:
          surfaceContainerLow ?? Color(MaterialDynamicColors.surfaceContainerLow.getArgb(scheme)),
      surfaceContainer:
          surfaceContainer ?? Color(MaterialDynamicColors.surfaceContainer.getArgb(scheme)),
      surfaceContainerHigh:
          surfaceContainerHigh ?? Color(MaterialDynamicColors.surfaceContainerHigh.getArgb(scheme)),
      surfaceContainerHighest:
          surfaceContainerHighest ??
          Color(MaterialDynamicColors.surfaceContainerHighest.getArgb(scheme)),
      onSurface: onSurface ?? Color(MaterialDynamicColors.onSurface.getArgb(scheme)),
      onSurfaceVariant:
          onSurfaceVariant ?? Color(MaterialDynamicColors.onSurfaceVariant.getArgb(scheme)),
      inverseSurface: inverseSurface ?? Color(MaterialDynamicColors.inverseSurface.getArgb(scheme)),
      onInverseSurface:
          onInverseSurface ?? Color(MaterialDynamicColors.inverseOnSurface.getArgb(scheme)),
      inversePrimary: inversePrimary ?? Color(MaterialDynamicColors.inversePrimary.getArgb(scheme)),
      shadow: shadow ?? Color(MaterialDynamicColors.shadow.getArgb(scheme)),
      scrim: scrim ?? Color(MaterialDynamicColors.scrim.getArgb(scheme)),
      surfaceTint: surfaceTint ?? Color(MaterialDynamicColors.primary.getArgb(scheme)),
      brightness: brightness,
      // DEPRECATED (newest deprecations at the bottom)
      background: background ?? Color(MaterialDynamicColors.background.getArgb(scheme)),
      onBackground: onBackground ?? Color(MaterialDynamicColors.onBackground.getArgb(scheme)),
      surfaceVariant: surfaceVariant ?? Color(MaterialDynamicColors.surfaceVariant.getArgb(scheme)),
    );
  }

  /// Create a light ColorScheme based on a purple primary color that matches the
  /// [baseline Material 2 color scheme](https://material.io/design/color/the-color-system.html#color-theme-creation).
  ///
  /// This constructor shouldn't be used to update the Material 3 color scheme.
  ///
  /// For Material 3, use [ColorScheme.fromSeed] to create a color scheme
  /// from a single seed color based on the Material 3 color system.
  ///
  /// {@tool snippet}
  /// This example demonstrates how to create a color scheme similar to [ColorScheme.light]
  /// using the [ColorScheme.fromSeed] constructor:
  ///
  /// ```dart
  /// colorScheme: ColorScheme.fromSeed(seedColor: const Color(0xff6200ee)).copyWith(
  ///   primaryContainer: const Color(0xff6200ee),
  ///   onPrimaryContainer: Colors.white,
  ///   secondaryContainer: const Color(0xff03dac6),
  ///   onSecondaryContainer: Colors.black,
  ///   error: const Color(0xffb00020),
  ///   onError: Colors.white,
  /// ),
  /// ```
  /// {@end-tool}
  const ColorScheme.light({
    this.brightness = Brightness.light,
    this.primary = const Color(0xff6200ee),
    this.onPrimary = Colors.white,
    Color? primaryContainer,
    Color? onPrimaryContainer,
    Color? primaryFixed,
    Color? primaryFixedDim,
    Color? onPrimaryFixed,
    Color? onPrimaryFixedVariant,
    this.secondary = const Color(0xff03dac6),
    this.onSecondary = Colors.black,
    Color? secondaryContainer,
    Color? onSecondaryContainer,
    Color? secondaryFixed,
    Color? secondaryFixedDim,
    Color? onSecondaryFixed,
    Color? onSecondaryFixedVariant,
    Color? tertiary,
    Color? onTertiary,
    Color? tertiaryContainer,
    Color? onTertiaryContainer,
    Color? tertiaryFixed,
    Color? tertiaryFixedDim,
    Color? onTertiaryFixed,
    Color? onTertiaryFixedVariant,
    this.error = const Color(0xffb00020),
    this.onError = Colors.white,
    Color? errorContainer,
    Color? onErrorContainer,
    this.surface = Colors.white,
    this.onSurface = Colors.black,
    Color? surfaceDim,
    Color? surfaceBright,
    Color? surfaceContainerLowest,
    Color? surfaceContainerLow,
    Color? surfaceContainer,
    Color? surfaceContainerHigh,
    Color? surfaceContainerHighest,
    Color? onSurfaceVariant,
    Color? outline,
    Color? outlineVariant,
    Color? shadow,
    Color? scrim,
    Color? inverseSurface,
    Color? onInverseSurface,
    Color? inversePrimary,
    Color? surfaceTint,
    @Deprecated(
      'Use surface instead. '
      'This feature was deprecated after v3.18.0-0.1.pre.',
    )
    Color? background = Colors.white,
    @Deprecated(
      'Use onSurface instead. '
      'This feature was deprecated after v3.18.0-0.1.pre.',
    )
    Color? onBackground = Colors.black,
    @Deprecated(
      'Use surfaceContainerHighest instead. '
      'This feature was deprecated after v3.18.0-0.1.pre.',
    )
    Color? surfaceVariant,
  }) : _primaryContainer = primaryContainer,
       _onPrimaryContainer = onPrimaryContainer,
       _primaryFixed = primaryFixed,
       _primaryFixedDim = primaryFixedDim,
       _onPrimaryFixed = onPrimaryFixed,
       _onPrimaryFixedVariant = onPrimaryFixedVariant,
       _secondaryContainer = secondaryContainer,
       _onSecondaryContainer = onSecondaryContainer,
       _secondaryFixed = secondaryFixed,
       _secondaryFixedDim = secondaryFixedDim,
       _onSecondaryFixed = onSecondaryFixed,
       _onSecondaryFixedVariant = onSecondaryFixedVariant,
       _tertiary = tertiary,
       _onTertiary = onTertiary,
       _tertiaryContainer = tertiaryContainer,
       _onTertiaryContainer = onTertiaryContainer,
       _tertiaryFixed = tertiaryFixed,
       _tertiaryFixedDim = tertiaryFixedDim,
       _onTertiaryFixed = onTertiaryFixed,
       _onTertiaryFixedVariant = onTertiaryFixedVariant,
       _errorContainer = errorContainer,
       _onErrorContainer = onErrorContainer,
       _surfaceDim = surfaceDim,
       _surfaceBright = surfaceBright,
       _surfaceContainerLowest = surfaceContainerLowest,
       _surfaceContainerLow = surfaceContainerLow,
       _surfaceContainer = surfaceContainer,
       _surfaceContainerHigh = surfaceContainerHigh,
       _surfaceContainerHighest = surfaceContainerHighest,
       _onSurfaceVariant = onSurfaceVariant,
       _outline = outline,
       _outlineVariant = outlineVariant,
       _shadow = shadow,
       _scrim = scrim,
       _inverseSurface = inverseSurface,
       _onInverseSurface = onInverseSurface,
       _inversePrimary = inversePrimary,
       _surfaceTint = surfaceTint,
       // DEPRECATED (newest deprecations at the bottom)
       _background = background,
       _onBackground = onBackground,
       _surfaceVariant = surfaceVariant;

  /// Create the dark color scheme that matches the
  /// [baseline Material 2 color scheme](https://material.io/design/color/dark-theme.html#ui-application).
  ///
  /// This constructor shouldn't be used to update the Material 3 color scheme.
  ///
  /// For Material 3, use [ColorScheme.fromSeed] to create a color scheme
  /// from a single seed color based on the Material 3 color system.
  /// Override the `brightness` property of [ColorScheme.fromSeed] to create a
  /// dark color scheme.
  ///
  /// {@tool snippet}
  /// This example demonstrates how to create a color scheme similar to [ColorScheme.dark]
  /// using the [ColorScheme.fromSeed] constructor:
  ///
  /// ```dart
  /// colorScheme: ColorScheme.fromSeed(
  ///   seedColor: const Color(0xffbb86fc),
  ///   brightness: Brightness.dark,
  /// ).copyWith(
  ///   primaryContainer: const Color(0xffbb86fc),
  ///   onPrimaryContainer: Colors.black,
  ///   secondaryContainer: const Color(0xff03dac6),
  ///   onSecondaryContainer: Colors.black,
  ///   error: const Color(0xffcf6679),
  ///   onError: Colors.black,
  /// ),
  /// ```
  /// {@end-tool}
  const ColorScheme.dark({
    this.brightness = Brightness.dark,
    this.primary = const Color(0xffbb86fc),
    this.onPrimary = Colors.black,
    Color? primaryContainer,
    Color? onPrimaryContainer,
    Color? primaryFixed,
    Color? primaryFixedDim,
    Color? onPrimaryFixed,
    Color? onPrimaryFixedVariant,
    this.secondary = const Color(0xff03dac6),
    this.onSecondary = Colors.black,
    Color? secondaryContainer,
    Color? onSecondaryContainer,
    Color? secondaryFixed,
    Color? secondaryFixedDim,
    Color? onSecondaryFixed,
    Color? onSecondaryFixedVariant,
    Color? tertiary,
    Color? onTertiary,
    Color? tertiaryContainer,
    Color? onTertiaryContainer,
    Color? tertiaryFixed,
    Color? tertiaryFixedDim,
    Color? onTertiaryFixed,
    Color? onTertiaryFixedVariant,
    this.error = const Color(0xffcf6679),
    this.onError = Colors.black,
    Color? errorContainer,
    Color? onErrorContainer,
    this.surface = const Color(0xff121212),
    this.onSurface = Colors.white,
    Color? surfaceDim,
    Color? surfaceBright,
    Color? surfaceContainerLowest,
    Color? surfaceContainerLow,
    Color? surfaceContainer,
    Color? surfaceContainerHigh,
    Color? surfaceContainerHighest,
    Color? onSurfaceVariant,
    Color? outline,
    Color? outlineVariant,
    Color? shadow,
    Color? scrim,
    Color? inverseSurface,
    Color? onInverseSurface,
    Color? inversePrimary,
    Color? surfaceTint,
    @Deprecated(
      'Use surface instead. '
      'This feature was deprecated after v3.18.0-0.1.pre.',
    )
    Color? background = const Color(0xff121212),
    @Deprecated(
      'Use onSurface instead. '
      'This feature was deprecated after v3.18.0-0.1.pre.',
    )
    Color? onBackground = Colors.white,
    @Deprecated(
      'Use surfaceContainerHighest instead. '
      'This feature was deprecated after v3.18.0-0.1.pre.',
    )
    Color? surfaceVariant,
  }) : _primaryContainer = primaryContainer,
       _onPrimaryContainer = onPrimaryContainer,
       _primaryFixed = primaryFixed,
       _primaryFixedDim = primaryFixedDim,
       _onPrimaryFixed = onPrimaryFixed,
       _onPrimaryFixedVariant = onPrimaryFixedVariant,
       _secondaryContainer = secondaryContainer,
       _onSecondaryContainer = onSecondaryContainer,
       _secondaryFixed = secondaryFixed,
       _secondaryFixedDim = secondaryFixedDim,
       _onSecondaryFixed = onSecondaryFixed,
       _onSecondaryFixedVariant = onSecondaryFixedVariant,
       _tertiary = tertiary,
       _onTertiary = onTertiary,
       _tertiaryContainer = tertiaryContainer,
       _onTertiaryContainer = onTertiaryContainer,
       _tertiaryFixed = tertiaryFixed,
       _tertiaryFixedDim = tertiaryFixedDim,
       _onTertiaryFixed = onTertiaryFixed,
       _onTertiaryFixedVariant = onTertiaryFixedVariant,
       _errorContainer = errorContainer,
       _onErrorContainer = onErrorContainer,
       _surfaceDim = surfaceDim,
       _surfaceBright = surfaceBright,
       _surfaceContainerLowest = surfaceContainerLowest,
       _surfaceContainerLow = surfaceContainerLow,
       _surfaceContainer = surfaceContainer,
       _surfaceContainerHigh = surfaceContainerHigh,
       _surfaceContainerHighest = surfaceContainerHighest,
       _onSurfaceVariant = onSurfaceVariant,
       _outline = outline,
       _outlineVariant = outlineVariant,
       _shadow = shadow,
       _scrim = scrim,
       _inverseSurface = inverseSurface,
       _onInverseSurface = onInverseSurface,
       _inversePrimary = inversePrimary,
       _surfaceTint = surfaceTint,
       // DEPRECATED (newest deprecations at the bottom)
       _background = background,
       _onBackground = onBackground,
       _surfaceVariant = surfaceVariant;

  /// Create a high contrast ColorScheme based on a purple primary color that
  /// matches the [baseline Material 2 color scheme](https://material.io/design/color/the-color-system.html#color-theme-creation).
  ///
  /// This constructor shouldn't be used to update the Material 3 color scheme.
  ///
  /// For Material 3, use [ColorScheme.fromSeed] to create a color scheme
  /// from a single seed color based on the Material 3 color system. To create a
  /// high-contrast color scheme, set `contrastLevel` to 1.0.
  ///
  /// {@tool snippet}
  /// This example demonstrates how to create a color scheme similar to [ColorScheme.highContrastLight]
  /// using the [ColorScheme.fromSeed] constructor:
  ///
  /// ```dart
  /// colorScheme: ColorScheme.fromSeed(seedColor: const Color(0xff0000ba)).copyWith(
  ///   primaryContainer: const Color(0xff0000ba),
  ///   onPrimaryContainer: Colors.white,
  ///   secondaryContainer: const Color(0xff66fff9),
  ///   onSecondaryContainer: Colors.black,
  ///   error: const Color(0xff790000),
  ///   onError: Colors.white,
  /// ),
  /// ```
  /// {@end-tool}
  const ColorScheme.highContrastLight({
    this.brightness = Brightness.light,
    this.primary = const Color(0xff0000ba),
    this.onPrimary = Colors.white,
    Color? primaryContainer,
    Color? onPrimaryContainer,
    Color? primaryFixed,
    Color? primaryFixedDim,
    Color? onPrimaryFixed,
    Color? onPrimaryFixedVariant,
    this.secondary = const Color(0xff66fff9),
    this.onSecondary = Colors.black,
    Color? secondaryContainer,
    Color? onSecondaryContainer,
    Color? secondaryFixed,
    Color? secondaryFixedDim,
    Color? onSecondaryFixed,
    Color? onSecondaryFixedVariant,
    Color? tertiary,
    Color? onTertiary,
    Color? tertiaryContainer,
    Color? onTertiaryContainer,
    Color? tertiaryFixed,
    Color? tertiaryFixedDim,
    Color? onTertiaryFixed,
    Color? onTertiaryFixedVariant,
    this.error = const Color(0xff790000),
    this.onError = Colors.white,
    Color? errorContainer,
    Color? onErrorContainer,
    this.surface = Colors.white,
    this.onSurface = Colors.black,
    Color? surfaceDim,
    Color? surfaceBright,
    Color? surfaceContainerLowest,
    Color? surfaceContainerLow,
    Color? surfaceContainer,
    Color? surfaceContainerHigh,
    Color? surfaceContainerHighest,
    Color? onSurfaceVariant,
    Color? outline,
    Color? outlineVariant,
    Color? shadow,
    Color? scrim,
    Color? inverseSurface,
    Color? onInverseSurface,
    Color? inversePrimary,
    Color? surfaceTint,
    @Deprecated(
      'Use surface instead. '
      'This feature was deprecated after v3.18.0-0.1.pre.',
    )
    Color? background = Colors.white,
    @Deprecated(
      'Use onSurface instead. '
      'This feature was deprecated after v3.18.0-0.1.pre.',
    )
    Color? onBackground = Colors.black,
    @Deprecated(
      'Use surfaceContainerHighest instead. '
      'This feature was deprecated after v3.18.0-0.1.pre.',
    )
    Color? surfaceVariant,
  }) : _primaryContainer = primaryContainer,
       _onPrimaryContainer = onPrimaryContainer,
       _primaryFixed = primaryFixed,
       _primaryFixedDim = primaryFixedDim,
       _onPrimaryFixed = onPrimaryFixed,
       _onPrimaryFixedVariant = onPrimaryFixedVariant,
       _secondaryContainer = secondaryContainer,
       _onSecondaryContainer = onSecondaryContainer,
       _secondaryFixed = secondaryFixed,
       _secondaryFixedDim = secondaryFixedDim,
       _onSecondaryFixed = onSecondaryFixed,
       _onSecondaryFixedVariant = onSecondaryFixedVariant,
       _tertiary = tertiary,
       _onTertiary = onTertiary,
       _tertiaryContainer = tertiaryContainer,
       _onTertiaryContainer = onTertiaryContainer,
       _tertiaryFixed = tertiaryFixed,
       _tertiaryFixedDim = tertiaryFixedDim,
       _onTertiaryFixed = onTertiaryFixed,
       _onTertiaryFixedVariant = onTertiaryFixedVariant,
       _errorContainer = errorContainer,
       _onErrorContainer = onErrorContainer,
       _surfaceDim = surfaceDim,
       _surfaceBright = surfaceBright,
       _surfaceContainerLowest = surfaceContainerLowest,
       _surfaceContainerLow = surfaceContainerLow,
       _surfaceContainer = surfaceContainer,
       _surfaceContainerHigh = surfaceContainerHigh,
       _surfaceContainerHighest = surfaceContainerHighest,
       _onSurfaceVariant = onSurfaceVariant,
       _outline = outline,
       _outlineVariant = outlineVariant,
       _shadow = shadow,
       _scrim = scrim,
       _inverseSurface = inverseSurface,
       _onInverseSurface = onInverseSurface,
       _inversePrimary = inversePrimary,
       _surfaceTint = surfaceTint,
       // DEPRECATED (newest deprecations at the bottom)
       _background = background,
       _onBackground = onBackground,
       _surfaceVariant = surfaceVariant;

  /// Create a high contrast ColorScheme based on the dark
  /// [baseline Material 2 color scheme](https://material.io/design/color/dark-theme.html#ui-application).
  ///
  /// This constructor shouldn't be used to update the Material 3 color scheme.
  ///
  /// For Material 3, use [ColorScheme.fromSeed] to create a color scheme
  /// from a single seed color based on the Material 3 color system.
  /// Override the `brightness` property of [ColorScheme.fromSeed] to create a
  /// dark color scheme. To create a high-contrast color scheme, set
  /// `contrastLevel` to 1.0.
  ///
  /// {@tool snippet}
  /// This example demonstrates how to create a color scheme similar to [ColorScheme.highContrastDark]
  /// using the [ColorScheme.fromSeed] constructor:
  ///
  /// ```dart
  /// colorScheme: ColorScheme.fromSeed(
  ///   seedColor: const Color(0xffefb7ff),
  ///   brightness: Brightness.dark,
  /// ).copyWith(
  ///   primaryContainer: const Color(0xffefb7ff),
  ///   onPrimaryContainer: Colors.black,
  ///   secondaryContainer: const Color(0xff66fff9),
  ///   onSecondaryContainer: Colors.black,
  ///   error: const Color(0xff9b374d),
  ///   onError: Colors.white,
  /// ),
  /// ```
  /// {@end-tool}
  const ColorScheme.highContrastDark({
    this.brightness = Brightness.dark,
    this.primary = const Color(0xffefb7ff),
    this.onPrimary = Colors.black,
    Color? primaryContainer,
    Color? onPrimaryContainer,
    Color? primaryFixed,
    Color? primaryFixedDim,
    Color? onPrimaryFixed,
    Color? onPrimaryFixedVariant,
    this.secondary = const Color(0xff66fff9),
    this.onSecondary = Colors.black,
    Color? secondaryContainer,
    Color? onSecondaryContainer,
    Color? secondaryFixed,
    Color? secondaryFixedDim,
    Color? onSecondaryFixed,
    Color? onSecondaryFixedVariant,
    Color? tertiary,
    Color? onTertiary,
    Color? tertiaryContainer,
    Color? onTertiaryContainer,
    Color? tertiaryFixed,
    Color? tertiaryFixedDim,
    Color? onTertiaryFixed,
    Color? onTertiaryFixedVariant,
    this.error = const Color(0xff9b374d),
    this.onError = Colors.black,
    Color? errorContainer,
    Color? onErrorContainer,
    this.surface = const Color(0xff121212),
    this.onSurface = Colors.white,
    Color? surfaceDim,
    Color? surfaceBright,
    Color? surfaceContainerLowest,
    Color? surfaceContainerLow,
    Color? surfaceContainer,
    Color? surfaceContainerHigh,
    Color? surfaceContainerHighest,
    Color? onSurfaceVariant,
    Color? outline,
    Color? outlineVariant,
    Color? shadow,
    Color? scrim,
    Color? inverseSurface,
    Color? onInverseSurface,
    Color? inversePrimary,
    Color? surfaceTint,
    @Deprecated(
      'Use surface instead. '
      'This feature was deprecated after v3.18.0-0.1.pre.',
    )
    Color? background = const Color(0xff121212),
    @Deprecated(
      'Use onSurface instead. '
      'This feature was deprecated after v3.18.0-0.1.pre.',
    )
    Color? onBackground = Colors.white,
    @Deprecated(
      'Use surfaceContainerHighest instead. '
      'This feature was deprecated after v3.18.0-0.1.pre.',
    )
    Color? surfaceVariant,
  }) : _primaryContainer = primaryContainer,
       _onPrimaryContainer = onPrimaryContainer,
       _primaryFixed = primaryFixed,
       _primaryFixedDim = primaryFixedDim,
       _onPrimaryFixed = onPrimaryFixed,
       _onPrimaryFixedVariant = onPrimaryFixedVariant,
       _secondaryContainer = secondaryContainer,
       _onSecondaryContainer = onSecondaryContainer,
       _secondaryFixed = secondaryFixed,
       _secondaryFixedDim = secondaryFixedDim,
       _onSecondaryFixed = onSecondaryFixed,
       _onSecondaryFixedVariant = onSecondaryFixedVariant,
       _tertiary = tertiary,
       _onTertiary = onTertiary,
       _tertiaryContainer = tertiaryContainer,
       _onTertiaryContainer = onTertiaryContainer,
       _tertiaryFixed = tertiaryFixed,
       _tertiaryFixedDim = tertiaryFixedDim,
       _onTertiaryFixed = onTertiaryFixed,
       _onTertiaryFixedVariant = onTertiaryFixedVariant,
       _errorContainer = errorContainer,
       _onErrorContainer = onErrorContainer,
       _surfaceDim = surfaceDim,
       _surfaceBright = surfaceBright,
       _surfaceContainerLowest = surfaceContainerLowest,
       _surfaceContainerLow = surfaceContainerLow,
       _surfaceContainer = surfaceContainer,
       _surfaceContainerHigh = surfaceContainerHigh,
       _surfaceContainerHighest = surfaceContainerHighest,
       _onSurfaceVariant = onSurfaceVariant,
       _outline = outline,
       _outlineVariant = outlineVariant,
       _shadow = shadow,
       _scrim = scrim,
       _inverseSurface = inverseSurface,
       _onInverseSurface = onInverseSurface,
       _inversePrimary = inversePrimary,
       _surfaceTint = surfaceTint,
       // DEPRECATED (newest deprecations at the bottom)
       _background = background,
       _onBackground = onBackground,
       _surfaceVariant = surfaceVariant;

  /// Creates a color scheme from a [MaterialColor] swatch.
  ///
  /// In Material 3, this constructor is ignored by [ThemeData] when creating
  /// its default color scheme. Instead, [ThemeData] uses [ColorScheme.fromSeed]
  /// to create its default color scheme. This constructor shouldn't be used
  /// to update the Material 3 color scheme. It will be phased out gradually;
  /// see https://github.com/flutter/flutter/issues/120064 for more details.
  ///
  /// If [ThemeData.useMaterial3] is false, then this constructor is used by
  /// [ThemeData] to create its default color scheme.
  factory ColorScheme.fromSwatch({
    MaterialColor primarySwatch = Colors.blue,
    Color? accentColor,
    Color? cardColor,
    Color? backgroundColor,
    Color? errorColor,
    Brightness brightness = Brightness.light,
  }) {
    final bool isDark = brightness == Brightness.dark;
    final bool primaryIsDark = _brightnessFor(primarySwatch) == Brightness.dark;
    final Color secondary = accentColor ?? (isDark ? Colors.tealAccent[200]! : primarySwatch);
    final bool secondaryIsDark = _brightnessFor(secondary) == Brightness.dark;

    return ColorScheme(
      primary: primarySwatch,
      secondary: secondary,
      surface: cardColor ?? (isDark ? Colors.grey[800]! : Colors.white),
      error: errorColor ?? Colors.red[700]!,
      onPrimary: primaryIsDark ? Colors.white : Colors.black,
      onSecondary: secondaryIsDark ? Colors.white : Colors.black,
      onSurface: isDark ? Colors.white : Colors.black,
      onError: isDark ? Colors.black : Colors.white,
      brightness: brightness,
      // DEPRECATED (newest deprecations at the bottom)
      background: backgroundColor ?? (isDark ? Colors.grey[700]! : primarySwatch[200]!),
      onBackground: primaryIsDark ? Colors.white : Colors.black,
    );
  }

  static Brightness _brightnessFor(Color color) => ThemeData.estimateBrightnessForColor(color);

  /// The overall brightness of this color scheme.
  final Brightness brightness;

  /// The color displayed most frequently across your app’s screens and components.
  final Color primary;

  /// A color that's clearly legible when drawn on [primary].
  ///
  /// To ensure that an app is accessible, a contrast ratio between
  /// [primary] and [onPrimary] of at least 4.5:1 is recommended. See
  /// <https://www.w3.org/TR/UNDERSTANDING-WCAG20/visual-audio-contrast-contrast.html>.
  final Color onPrimary;

  final Color? _primaryContainer;

  /// A color used for elements needing less emphasis than [primary].
  Color get primaryContainer => _primaryContainer ?? primary;

  final Color? _onPrimaryContainer;

  /// A color that's clearly legible when drawn on [primaryContainer].
  ///
  /// To ensure that an app is accessible, a contrast ratio between
  /// [primaryContainer] and [onPrimaryContainer] of at least 4.5:1
  /// is recommended. See
  /// <https://www.w3.org/TR/UNDERSTANDING-WCAG20/visual-audio-contrast-contrast.html>.
  Color get onPrimaryContainer => _onPrimaryContainer ?? onPrimary;

  final Color? _primaryFixed;

  /// A substitute for [primaryContainer] that's the same color for the dark
  /// and light themes.
  Color get primaryFixed => _primaryFixed ?? primary;

  final Color? _primaryFixedDim;

  /// A color used for elements needing more emphasis than [primaryFixed].
  Color get primaryFixedDim => _primaryFixedDim ?? primary;

  final Color? _onPrimaryFixed;

  /// A color that is used for text and icons that exist on top of elements having
  /// [primaryFixed] color.
  Color get onPrimaryFixed => _onPrimaryFixed ?? onPrimary;

  final Color? _onPrimaryFixedVariant;

  /// A color that provides a lower-emphasis option for text and icons than
  /// [onPrimaryFixed].
  Color get onPrimaryFixedVariant => _onPrimaryFixedVariant ?? onPrimary;

  /// An accent color used for less prominent components in the UI, such as
  /// filter chips, while expanding the opportunity for color expression.
  final Color secondary;

  /// A color that's clearly legible when drawn on [secondary].
  ///
  /// To ensure that an app is accessible, a contrast ratio between
  /// [secondary] and [onSecondary] of at least 4.5:1 is recommended. See
  /// <https://www.w3.org/TR/UNDERSTANDING-WCAG20/visual-audio-contrast-contrast.html>.
  final Color onSecondary;

  final Color? _secondaryContainer;

  /// A color used for elements needing less emphasis than [secondary].
  Color get secondaryContainer => _secondaryContainer ?? secondary;

  final Color? _onSecondaryContainer;

  /// A color that's clearly legible when drawn on [secondaryContainer].
  ///
  /// To ensure that an app is accessible, a contrast ratio between
  /// [secondaryContainer] and [onSecondaryContainer] of at least 4.5:1 is
  /// recommended. See
  /// <https://www.w3.org/TR/UNDERSTANDING-WCAG20/visual-audio-contrast-contrast.html>.
  Color get onSecondaryContainer => _onSecondaryContainer ?? onSecondary;

  final Color? _secondaryFixed;

  /// A substitute for [secondaryContainer] that's the same color for the dark
  /// and light themes.
  Color get secondaryFixed => _secondaryFixed ?? secondary;

  final Color? _secondaryFixedDim;

  /// A color used for elements needing more emphasis than [secondaryFixed].
  Color get secondaryFixedDim => _secondaryFixedDim ?? secondary;

  final Color? _onSecondaryFixed;

  /// A color that is used for text and icons that exist on top of elements having
  /// [secondaryFixed] color.
  Color get onSecondaryFixed => _onSecondaryFixed ?? onSecondary;

  final Color? _onSecondaryFixedVariant;

  /// A color that provides a lower-emphasis option for text and icons than
  /// [onSecondaryFixed].
  Color get onSecondaryFixedVariant => _onSecondaryFixedVariant ?? onSecondary;

  final Color? _tertiary;

  /// A color used as a contrasting accent that can balance [primary]
  /// and [secondary] colors or bring heightened attention to an element,
  /// such as an input field.
  Color get tertiary => _tertiary ?? secondary;

  final Color? _onTertiary;

  /// A color that's clearly legible when drawn on [tertiary].
  ///
  /// To ensure that an app is accessible, a contrast ratio between
  /// [tertiary] and [onTertiary] of at least 4.5:1 is recommended. See
  /// <https://www.w3.org/TR/UNDERSTANDING-WCAG20/visual-audio-contrast-contrast.html>.
  Color get onTertiary => _onTertiary ?? onSecondary;

  final Color? _tertiaryContainer;

  /// A color used for elements needing less emphasis than [tertiary].
  Color get tertiaryContainer => _tertiaryContainer ?? tertiary;

  final Color? _onTertiaryContainer;

  /// A color that's clearly legible when drawn on [tertiaryContainer].
  ///
  /// To ensure that an app is accessible, a contrast ratio between
  /// [tertiaryContainer] and [onTertiaryContainer] of at least 4.5:1 is
  /// recommended. See
  /// <https://www.w3.org/TR/UNDERSTANDING-WCAG20/visual-audio-contrast-contrast.html>.
  Color get onTertiaryContainer => _onTertiaryContainer ?? onTertiary;

  final Color? _tertiaryFixed;

  /// A substitute for [tertiaryContainer] that's the same color for dark
  /// and light themes.
  Color get tertiaryFixed => _tertiaryFixed ?? tertiary;

  final Color? _tertiaryFixedDim;

  /// A color used for elements needing more emphasis than [tertiaryFixed].
  Color get tertiaryFixedDim => _tertiaryFixedDim ?? tertiary;

  final Color? _onTertiaryFixed;

  /// A color that is used for text and icons that exist on top of elements having
  /// [tertiaryFixed] color.
  Color get onTertiaryFixed => _onTertiaryFixed ?? onTertiary;

  final Color? _onTertiaryFixedVariant;

  /// A color that provides a lower-emphasis option for text and icons than
  /// [onTertiaryFixed].
  Color get onTertiaryFixedVariant => _onTertiaryFixedVariant ?? onTertiary;

  /// The color to use for input validation errors, e.g. for
  /// [InputDecoration.errorText].
  final Color error;

  /// A color that's clearly legible when drawn on [error].
  ///
  /// To ensure that an app is accessible, a contrast ratio between
  /// [error] and [onError] of at least 4.5:1 is recommended. See
  /// <https://www.w3.org/TR/UNDERSTANDING-WCAG20/visual-audio-contrast-contrast.html>.
  final Color onError;

  final Color? _errorContainer;

  /// A color used for error elements needing less emphasis than [error].
  Color get errorContainer => _errorContainer ?? error;

  final Color? _onErrorContainer;

  /// A color that's clearly legible when drawn on [errorContainer].
  ///
  /// To ensure that an app is accessible, a contrast ratio between
  /// [errorContainer] and [onErrorContainer] of at least 4.5:1 is
  /// recommended. See
  /// <https://www.w3.org/TR/UNDERSTANDING-WCAG20/visual-audio-contrast-contrast.html>.
  Color get onErrorContainer => _onErrorContainer ?? onError;

  /// The background color for widgets like [Scaffold].
  final Color surface;

  /// A color that's clearly legible when drawn on [surface].
  ///
  /// To ensure that an app is accessible, a contrast ratio between
  /// [surface] and [onSurface] of at least 4.5:1 is recommended. See
  /// <https://www.w3.org/TR/UNDERSTANDING-WCAG20/visual-audio-contrast-contrast.html>.
  final Color onSurface;

  final Color? _surfaceVariant;

  /// A color variant of [surface] that can be used for differentiation against
  /// a component using [surface].
  @Deprecated(
    'Use surfaceContainerHighest instead. '
    'This feature was deprecated after v3.18.0-0.1.pre.',
  )
  Color get surfaceVariant => _surfaceVariant ?? surface;

  final Color? _surfaceDim;

  /// A color that's always darkest in the dark or light theme.
  Color get surfaceDim => _surfaceDim ?? surface;

  final Color? _surfaceBright;

  /// A color that's always the lightest in the dark or light theme.
  Color get surfaceBright => _surfaceBright ?? surface;

  final Color? _surfaceContainerLowest;

  /// A surface container color with the lightest tone and the least emphasis
  /// relative to the surface.
  Color get surfaceContainerLowest => _surfaceContainerLowest ?? surface;

  final Color? _surfaceContainerLow;

  /// A surface container color with a lighter tone that creates less emphasis
  /// than [surfaceContainer] but more emphasis than [surfaceContainerLowest].
  Color get surfaceContainerLow => _surfaceContainerLow ?? surface;

  final Color? _surfaceContainer;

  /// A recommended color role for a distinct area within the surface.
  ///
  /// Surface container color roles are independent of elevation. They replace the old
  /// opacity-based model which applied a tinted overlay on top of
  /// surfaces based on their elevation.
  ///
  /// Surface container colors include [surfaceContainerLowest], [surfaceContainerLow],
  /// [surfaceContainer], [surfaceContainerHigh] and [surfaceContainerHighest].
  Color get surfaceContainer => _surfaceContainer ?? surface;

  final Color? _surfaceContainerHigh;

  /// A surface container color with a darker tone. It is used to create more
  /// emphasis than [surfaceContainer] but less emphasis than [surfaceContainerHighest].
  Color get surfaceContainerHigh => _surfaceContainerHigh ?? surface;

  final Color? _surfaceContainerHighest;

  /// A surface container color with the darkest tone. It is used to create the
  /// most emphasis against the surface.
  Color get surfaceContainerHighest => _surfaceContainerHighest ?? surface;

  final Color? _onSurfaceVariant;

  /// A color that's clearly legible when drawn on [surfaceVariant].
  ///
  /// To ensure that an app is accessible, a contrast ratio between
  /// [surfaceVariant] and [onSurfaceVariant] of at least 4.5:1 is
  /// recommended. See
  /// <https://www.w3.org/TR/UNDERSTANDING-WCAG20/visual-audio-contrast-contrast.html>.
  Color get onSurfaceVariant => _onSurfaceVariant ?? onSurface;

  final Color? _outline;

  /// A utility color that creates boundaries and emphasis to improve usability.
  Color get outline => _outline ?? onBackground;

  final Color? _outlineVariant;

  /// A utility color that creates boundaries for decorative elements when a
  /// 3:1 contrast isn’t required, such as for dividers or decorative elements.
  Color get outlineVariant => _outlineVariant ?? onBackground;

  final Color? _shadow;

  /// A color use to paint the drop shadows of elevated components.
  Color get shadow => _shadow ?? const Color(0xff000000);

  final Color? _scrim;

  /// A color use to paint the scrim around of modal components.
  Color get scrim => _scrim ?? const Color(0xff000000);

  final Color? _inverseSurface;

  /// A surface color used for displaying the reverse of what’s seen in the
  /// surrounding UI, for example in a SnackBar to bring attention to
  /// an alert.
  Color get inverseSurface => _inverseSurface ?? onSurface;

  final Color? _onInverseSurface;

  /// A color that's clearly legible when drawn on [inverseSurface].
  ///
  /// To ensure that an app is accessible, a contrast ratio between
  /// [inverseSurface] and [onInverseSurface] of at least 4.5:1 is
  /// recommended. See
  /// <https://www.w3.org/TR/UNDERSTANDING-WCAG20/visual-audio-contrast-contrast.html>.
  Color get onInverseSurface => _onInverseSurface ?? surface;

  final Color? _inversePrimary;

  /// An accent color used for displaying a highlight color on [inverseSurface]
  /// backgrounds, like button text in a SnackBar.
  Color get inversePrimary => _inversePrimary ?? onPrimary;

  final Color? _surfaceTint;

  /// A color used as an overlay on a surface color to indicate a component's
  /// elevation.
  Color get surfaceTint => _surfaceTint ?? primary;

  final Color? _background;

  /// A color that typically appears behind scrollable content.
  @Deprecated(
    'Use surface instead. '
    'This feature was deprecated after v3.18.0-0.1.pre.',
  )
  Color get background => _background ?? surface;

  final Color? _onBackground;

  /// A color that's clearly legible when drawn on [background].
  ///
  /// To ensure that an app is accessible, a contrast ratio between
  /// [background] and [onBackground] of at least 4.5:1 is recommended. See
  /// <https://www.w3.org/TR/UNDERSTANDING-WCAG20/visual-audio-contrast-contrast.html>.
  @Deprecated(
    'Use onSurface instead. '
    'This feature was deprecated after v3.18.0-0.1.pre.',
  )
  Color get onBackground => _onBackground ?? onSurface;

  /// Creates a copy of this color scheme with the given fields
  /// replaced by the non-null parameter values.
  ColorScheme copyWith({
    Brightness? brightness,
    Color? primary,
    Color? onPrimary,
    Color? primaryContainer,
    Color? onPrimaryContainer,
    Color? primaryFixed,
    Color? primaryFixedDim,
    Color? onPrimaryFixed,
    Color? onPrimaryFixedVariant,
    Color? secondary,
    Color? onSecondary,
    Color? secondaryContainer,
    Color? onSecondaryContainer,
    Color? secondaryFixed,
    Color? secondaryFixedDim,
    Color? onSecondaryFixed,
    Color? onSecondaryFixedVariant,
    Color? tertiary,
    Color? onTertiary,
    Color? tertiaryContainer,
    Color? onTertiaryContainer,
    Color? tertiaryFixed,
    Color? tertiaryFixedDim,
    Color? onTertiaryFixed,
    Color? onTertiaryFixedVariant,
    Color? error,
    Color? onError,
    Color? errorContainer,
    Color? onErrorContainer,
    Color? surface,
    Color? onSurface,
    Color? surfaceDim,
    Color? surfaceBright,
    Color? surfaceContainerLowest,
    Color? surfaceContainerLow,
    Color? surfaceContainer,
    Color? surfaceContainerHigh,
    Color? surfaceContainerHighest,
    Color? onSurfaceVariant,
    Color? outline,
    Color? outlineVariant,
    Color? shadow,
    Color? scrim,
    Color? inverseSurface,
    Color? onInverseSurface,
    Color? inversePrimary,
    Color? surfaceTint,
    @Deprecated(
      'Use surface instead. '
      'This feature was deprecated after v3.18.0-0.1.pre.',
    )
    Color? background,
    @Deprecated(
      'Use onSurface instead. '
      'This feature was deprecated after v3.18.0-0.1.pre.',
    )
    Color? onBackground,
    @Deprecated(
      'Use surfaceContainerHighest instead. '
      'This feature was deprecated after v3.18.0-0.1.pre.',
    )
    Color? surfaceVariant,
  }) {
    return ColorScheme(
      brightness: brightness ?? this.brightness,
      primary: primary ?? this.primary,
      onPrimary: onPrimary ?? this.onPrimary,
      primaryContainer: primaryContainer ?? this.primaryContainer,
      onPrimaryContainer: onPrimaryContainer ?? this.onPrimaryContainer,
      primaryFixed: primaryFixed ?? this.primaryFixed,
      primaryFixedDim: primaryFixedDim ?? this.primaryFixedDim,
      onPrimaryFixed: onPrimaryFixed ?? this.onPrimaryFixed,
      onPrimaryFixedVariant: onPrimaryFixedVariant ?? this.onPrimaryFixedVariant,
      secondary: secondary ?? this.secondary,
      onSecondary: onSecondary ?? this.onSecondary,
      secondaryContainer: secondaryContainer ?? this.secondaryContainer,
      onSecondaryContainer: onSecondaryContainer ?? this.onSecondaryContainer,
      secondaryFixed: secondaryFixed ?? this.secondaryFixed,
      secondaryFixedDim: secondaryFixedDim ?? this.secondaryFixedDim,
      onSecondaryFixed: onSecondaryFixed ?? this.onSecondaryFixed,
      onSecondaryFixedVariant: onSecondaryFixedVariant ?? this.onSecondaryFixedVariant,
      tertiary: tertiary ?? this.tertiary,
      onTertiary: onTertiary ?? this.onTertiary,
      tertiaryContainer: tertiaryContainer ?? this.tertiaryContainer,
      onTertiaryContainer: onTertiaryContainer ?? this.onTertiaryContainer,
      tertiaryFixed: tertiaryFixed ?? this.tertiaryFixed,
      tertiaryFixedDim: tertiaryFixedDim ?? this.tertiaryFixedDim,
      onTertiaryFixed: onTertiaryFixed ?? this.onTertiaryFixed,
      onTertiaryFixedVariant: onTertiaryFixedVariant ?? this.onTertiaryFixedVariant,
      error: error ?? this.error,
      onError: onError ?? this.onError,
      errorContainer: errorContainer ?? this.errorContainer,
      onErrorContainer: onErrorContainer ?? this.onErrorContainer,
      surface: surface ?? this.surface,
      onSurface: onSurface ?? this.onSurface,
      surfaceDim: surfaceDim ?? this.surfaceDim,
      surfaceBright: surfaceBright ?? this.surfaceBright,
      surfaceContainerLowest: surfaceContainerLowest ?? this.surfaceContainerLowest,
      surfaceContainerLow: surfaceContainerLow ?? this.surfaceContainerLow,
      surfaceContainer: surfaceContainer ?? this.surfaceContainer,
      surfaceContainerHigh: surfaceContainerHigh ?? this.surfaceContainerHigh,
      surfaceContainerHighest: surfaceContainerHighest ?? this.surfaceContainerHighest,
      onSurfaceVariant: onSurfaceVariant ?? this.onSurfaceVariant,
      outline: outline ?? this.outline,
      outlineVariant: outlineVariant ?? this.outlineVariant,
      shadow: shadow ?? this.shadow,
      scrim: scrim ?? this.scrim,
      inverseSurface: inverseSurface ?? this.inverseSurface,
      onInverseSurface: onInverseSurface ?? this.onInverseSurface,
      inversePrimary: inversePrimary ?? this.inversePrimary,
      surfaceTint: surfaceTint ?? this.surfaceTint,
      // DEPRECATED (newest deprecations at the bottom)
      background: background ?? this.background,
      onBackground: onBackground ?? this.onBackground,
      surfaceVariant: surfaceVariant ?? this.surfaceVariant,
    );
  }

  /// Linearly interpolate between two [ColorScheme] objects.
  ///
  /// {@macro dart.ui.shadow.lerp}
  static ColorScheme lerp(ColorScheme a, ColorScheme b, double t) {
    if (identical(a, b)) {
      return a;
    }
    return ColorScheme(
      brightness: t < 0.5 ? a.brightness : b.brightness,
      primary: Color.lerp(a.primary, b.primary, t)!,
      onPrimary: Color.lerp(a.onPrimary, b.onPrimary, t)!,
      primaryContainer: Color.lerp(a.primaryContainer, b.primaryContainer, t),
      onPrimaryContainer: Color.lerp(a.onPrimaryContainer, b.onPrimaryContainer, t),
      primaryFixed: Color.lerp(a.primaryFixed, b.primaryFixed, t),
      primaryFixedDim: Color.lerp(a.primaryFixedDim, b.primaryFixedDim, t),
      onPrimaryFixed: Color.lerp(a.onPrimaryFixed, b.onPrimaryFixed, t),
      onPrimaryFixedVariant: Color.lerp(a.onPrimaryFixedVariant, b.onPrimaryFixedVariant, t),
      secondary: Color.lerp(a.secondary, b.secondary, t)!,
      onSecondary: Color.lerp(a.onSecondary, b.onSecondary, t)!,
      secondaryContainer: Color.lerp(a.secondaryContainer, b.secondaryContainer, t),
      onSecondaryContainer: Color.lerp(a.onSecondaryContainer, b.onSecondaryContainer, t),
      secondaryFixed: Color.lerp(a.secondaryFixed, b.secondaryFixed, t),
      secondaryFixedDim: Color.lerp(a.secondaryFixedDim, b.secondaryFixedDim, t),
      onSecondaryFixed: Color.lerp(a.onSecondaryFixed, b.onSecondaryFixed, t),
      onSecondaryFixedVariant: Color.lerp(a.onSecondaryFixedVariant, b.onSecondaryFixedVariant, t),
      tertiary: Color.lerp(a.tertiary, b.tertiary, t),
      onTertiary: Color.lerp(a.onTertiary, b.onTertiary, t),
      tertiaryContainer: Color.lerp(a.tertiaryContainer, b.tertiaryContainer, t),
      onTertiaryContainer: Color.lerp(a.onTertiaryContainer, b.onTertiaryContainer, t),
      tertiaryFixed: Color.lerp(a.tertiaryFixed, b.tertiaryFixed, t),
      tertiaryFixedDim: Color.lerp(a.tertiaryFixedDim, b.tertiaryFixedDim, t),
      onTertiaryFixed: Color.lerp(a.onTertiaryFixed, b.onTertiaryFixed, t),
      onTertiaryFixedVariant: Color.lerp(a.onTertiaryFixedVariant, b.onTertiaryFixedVariant, t),
      error: Color.lerp(a.error, b.error, t)!,
      onError: Color.lerp(a.onError, b.onError, t)!,
      errorContainer: Color.lerp(a.errorContainer, b.errorContainer, t),
      onErrorContainer: Color.lerp(a.onErrorContainer, b.onErrorContainer, t),
      surface: Color.lerp(a.surface, b.surface, t)!,
      onSurface: Color.lerp(a.onSurface, b.onSurface, t)!,
      surfaceDim: Color.lerp(a.surfaceDim, b.surfaceDim, t),
      surfaceBright: Color.lerp(a.surfaceBright, b.surfaceBright, t),
      surfaceContainerLowest: Color.lerp(a.surfaceContainerLowest, b.surfaceContainerLowest, t),
      surfaceContainerLow: Color.lerp(a.surfaceContainerLow, b.surfaceContainerLow, t),
      surfaceContainer: Color.lerp(a.surfaceContainer, b.surfaceContainer, t),
      surfaceContainerHigh: Color.lerp(a.surfaceContainerHigh, b.surfaceContainerHigh, t),
      surfaceContainerHighest: Color.lerp(a.surfaceContainerHighest, b.surfaceContainerHighest, t),
      onSurfaceVariant: Color.lerp(a.onSurfaceVariant, b.onSurfaceVariant, t),
      outline: Color.lerp(a.outline, b.outline, t),
      outlineVariant: Color.lerp(a.outlineVariant, b.outlineVariant, t),
      shadow: Color.lerp(a.shadow, b.shadow, t),
      scrim: Color.lerp(a.scrim, b.scrim, t),
      inverseSurface: Color.lerp(a.inverseSurface, b.inverseSurface, t),
      onInverseSurface: Color.lerp(a.onInverseSurface, b.onInverseSurface, t),
      inversePrimary: Color.lerp(a.inversePrimary, b.inversePrimary, t),
      surfaceTint: Color.lerp(a.surfaceTint, b.surfaceTint, t),
      // DEPRECATED (newest deprecations at the bottom)
      background: Color.lerp(a.background, b.background, t),
      onBackground: Color.lerp(a.onBackground, b.onBackground, t),
      surfaceVariant: Color.lerp(a.surfaceVariant, b.surfaceVariant, t),
    );
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other.runtimeType != runtimeType) {
      return false;
    }
    return other is ColorScheme &&
        other.brightness == brightness &&
        other.primary == primary &&
        other.onPrimary == onPrimary &&
        other.primaryContainer == primaryContainer &&
        other.onPrimaryContainer == onPrimaryContainer &&
        other.primaryFixed == primaryFixed &&
        other.primaryFixedDim == primaryFixedDim &&
        other.onPrimaryFixed == onPrimaryFixed &&
        other.onPrimaryFixedVariant == onPrimaryFixedVariant &&
        other.secondary == secondary &&
        other.onSecondary == onSecondary &&
        other.secondaryContainer == secondaryContainer &&
        other.onSecondaryContainer == onSecondaryContainer &&
        other.secondaryFixed == secondaryFixed &&
        other.secondaryFixedDim == secondaryFixedDim &&
        other.onSecondaryFixed == onSecondaryFixed &&
        other.onSecondaryFixedVariant == onSecondaryFixedVariant &&
        other.tertiary == tertiary &&
        other.onTertiary == onTertiary &&
        other.tertiaryContainer == tertiaryContainer &&
        other.onTertiaryContainer == onTertiaryContainer &&
        other.tertiaryFixed == tertiaryFixed &&
        other.tertiaryFixedDim == tertiaryFixedDim &&
        other.onTertiaryFixed == onTertiaryFixed &&
        other.onTertiaryFixedVariant == onTertiaryFixedVariant &&
        other.error == error &&
        other.onError == onError &&
        other.errorContainer == errorContainer &&
        other.onErrorContainer == onErrorContainer &&
        other.surface == surface &&
        other.onSurface == onSurface &&
        other.surfaceDim == surfaceDim &&
        other.surfaceBright == surfaceBright &&
        other.surfaceContainerLowest == surfaceContainerLowest &&
        other.surfaceContainerLow == surfaceContainerLow &&
        other.surfaceContainer == surfaceContainer &&
        other.surfaceContainerHigh == surfaceContainerHigh &&
        other.surfaceContainerHighest == surfaceContainerHighest &&
        other.onSurfaceVariant == onSurfaceVariant &&
        other.outline == outline &&
        other.outlineVariant == outlineVariant &&
        other.shadow == shadow &&
        other.scrim == scrim &&
        other.inverseSurface == inverseSurface &&
        other.onInverseSurface == onInverseSurface &&
        other.inversePrimary == inversePrimary &&
        other.surfaceTint == surfaceTint
        // DEPRECATED (newest deprecations at the bottom)
        &&
        other.background == background &&
        other.onBackground == onBackground &&
        other.surfaceVariant == surfaceVariant;
  }

  @override
  int get hashCode => Object.hash(
    brightness,
    primary,
    onPrimary,
    primaryContainer,
    onPrimaryContainer,
    secondary,
    onSecondary,
    secondaryContainer,
    onSecondaryContainer,
    tertiary,
    onTertiary,
    tertiaryContainer,
    onTertiaryContainer,
    error,
    onError,
    errorContainer,
    onErrorContainer,
    Object.hash(
      surface,
      onSurface,
      surfaceDim,
      surfaceBright,
      surfaceContainerLowest,
      surfaceContainerLow,
      surfaceContainer,
      surfaceContainerHigh,
      surfaceContainerHighest,
      onSurfaceVariant,
      outline,
      outlineVariant,
      shadow,
      scrim,
      inverseSurface,
      onInverseSurface,
      inversePrimary,
      surfaceTint,
      Object.hash(
        primaryFixed,
        primaryFixedDim,
        onPrimaryFixed,
        onPrimaryFixedVariant,
        secondaryFixed,
        secondaryFixedDim,
        onSecondaryFixed,
        onSecondaryFixedVariant,
        tertiaryFixed,
        tertiaryFixedDim,
        onTertiaryFixed,
        onTertiaryFixedVariant,
        // DEPRECATED (newest deprecations at the bottom)
        background,
        onBackground,
        surfaceVariant,
      ),
    ),
  );

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    const ColorScheme defaultScheme = ColorScheme.light();
    properties.add(
      DiagnosticsProperty<Brightness>(
        'brightness',
        brightness,
        defaultValue: defaultScheme.brightness,
      ),
    );
    properties.add(ColorProperty('primary', primary, defaultValue: defaultScheme.primary));
    properties.add(ColorProperty('onPrimary', onPrimary, defaultValue: defaultScheme.onPrimary));
    properties.add(
      ColorProperty(
        'primaryContainer',
        primaryContainer,
        defaultValue: defaultScheme.primaryContainer,
      ),
    );
    properties.add(
      ColorProperty(
        'onPrimaryContainer',
        onPrimaryContainer,
        defaultValue: defaultScheme.onPrimaryContainer,
      ),
    );
    properties.add(
      ColorProperty('primaryFixed', primaryFixed, defaultValue: defaultScheme.primaryFixed),
    );
    properties.add(
      ColorProperty(
        'primaryFixedDim',
        primaryFixedDim,
        defaultValue: defaultScheme.primaryFixedDim,
      ),
    );
    properties.add(
      ColorProperty('onPrimaryFixed', onPrimaryFixed, defaultValue: defaultScheme.onPrimaryFixed),
    );
    properties.add(
      ColorProperty(
        'onPrimaryFixedVariant',
        onPrimaryFixedVariant,
        defaultValue: defaultScheme.onPrimaryFixedVariant,
      ),
    );
    properties.add(ColorProperty('secondary', secondary, defaultValue: defaultScheme.secondary));
    properties.add(
      ColorProperty('onSecondary', onSecondary, defaultValue: defaultScheme.onSecondary),
    );
    properties.add(
      ColorProperty(
        'secondaryContainer',
        secondaryContainer,
        defaultValue: defaultScheme.secondaryContainer,
      ),
    );
    properties.add(
      ColorProperty(
        'onSecondaryContainer',
        onSecondaryContainer,
        defaultValue: defaultScheme.onSecondaryContainer,
      ),
    );
    properties.add(
      ColorProperty('secondaryFixed', secondaryFixed, defaultValue: defaultScheme.secondaryFixed),
    );
    properties.add(
      ColorProperty(
        'secondaryFixedDim',
        secondaryFixedDim,
        defaultValue: defaultScheme.secondaryFixedDim,
      ),
    );
    properties.add(
      ColorProperty(
        'onSecondaryFixed',
        onSecondaryFixed,
        defaultValue: defaultScheme.onSecondaryFixed,
      ),
    );
    properties.add(
      ColorProperty(
        'onSecondaryFixedVariant',
        onSecondaryFixedVariant,
        defaultValue: defaultScheme.onSecondaryFixedVariant,
      ),
    );
    properties.add(ColorProperty('tertiary', tertiary, defaultValue: defaultScheme.tertiary));
    properties.add(ColorProperty('onTertiary', onTertiary, defaultValue: defaultScheme.onTertiary));
    properties.add(
      ColorProperty(
        'tertiaryContainer',
        tertiaryContainer,
        defaultValue: defaultScheme.tertiaryContainer,
      ),
    );
    properties.add(
      ColorProperty(
        'onTertiaryContainer',
        onTertiaryContainer,
        defaultValue: defaultScheme.onTertiaryContainer,
      ),
    );
    properties.add(
      ColorProperty('tertiaryFixed', tertiaryFixed, defaultValue: defaultScheme.tertiaryFixed),
    );
    properties.add(
      ColorProperty(
        'tertiaryFixedDim',
        tertiaryFixedDim,
        defaultValue: defaultScheme.tertiaryFixedDim,
      ),
    );
    properties.add(
      ColorProperty(
        'onTertiaryFixed',
        onTertiaryFixed,
        defaultValue: defaultScheme.onTertiaryFixed,
      ),
    );
    properties.add(
      ColorProperty(
        'onTertiaryFixedVariant',
        onTertiaryFixedVariant,
        defaultValue: defaultScheme.onTertiaryFixedVariant,
      ),
    );
    properties.add(ColorProperty('error', error, defaultValue: defaultScheme.error));
    properties.add(ColorProperty('onError', onError, defaultValue: defaultScheme.onError));
    properties.add(
      ColorProperty('errorContainer', errorContainer, defaultValue: defaultScheme.errorContainer),
    );
    properties.add(
      ColorProperty(
        'onErrorContainer',
        onErrorContainer,
        defaultValue: defaultScheme.onErrorContainer,
      ),
    );
    properties.add(ColorProperty('surface', surface, defaultValue: defaultScheme.surface));
    properties.add(ColorProperty('onSurface', onSurface, defaultValue: defaultScheme.onSurface));
    properties.add(ColorProperty('surfaceDim', surfaceDim, defaultValue: defaultScheme.surfaceDim));
    properties.add(
      ColorProperty('surfaceBright', surfaceBright, defaultValue: defaultScheme.surfaceBright),
    );
    properties.add(
      ColorProperty(
        'surfaceContainerLowest',
        surfaceContainerLowest,
        defaultValue: defaultScheme.surfaceContainerLowest,
      ),
    );
    properties.add(
      ColorProperty(
        'surfaceContainerLow',
        surfaceContainerLow,
        defaultValue: defaultScheme.surfaceContainerLow,
      ),
    );
    properties.add(
      ColorProperty(
        'surfaceContainer',
        surfaceContainer,
        defaultValue: defaultScheme.surfaceContainer,
      ),
    );
    properties.add(
      ColorProperty(
        'surfaceContainerHigh',
        surfaceContainerHigh,
        defaultValue: defaultScheme.surfaceContainerHigh,
      ),
    );
    properties.add(
      ColorProperty(
        'surfaceContainerHighest',
        surfaceContainerHighest,
        defaultValue: defaultScheme.surfaceContainerHighest,
      ),
    );
    properties.add(
      ColorProperty(
        'onSurfaceVariant',
        onSurfaceVariant,
        defaultValue: defaultScheme.onSurfaceVariant,
      ),
    );
    properties.add(ColorProperty('outline', outline, defaultValue: defaultScheme.outline));
    properties.add(
      ColorProperty('outlineVariant', outlineVariant, defaultValue: defaultScheme.outlineVariant),
    );
    properties.add(ColorProperty('shadow', shadow, defaultValue: defaultScheme.shadow));
    properties.add(ColorProperty('scrim', scrim, defaultValue: defaultScheme.scrim));
    properties.add(
      ColorProperty('inverseSurface', inverseSurface, defaultValue: defaultScheme.inverseSurface),
    );
    properties.add(
      ColorProperty(
        'onInverseSurface',
        onInverseSurface,
        defaultValue: defaultScheme.onInverseSurface,
      ),
    );
    properties.add(
      ColorProperty('inversePrimary', inversePrimary, defaultValue: defaultScheme.inversePrimary),
    );
    properties.add(
      ColorProperty('surfaceTint', surfaceTint, defaultValue: defaultScheme.surfaceTint),
    );
    // DEPRECATED (newest deprecations at the bottom)
    properties.add(ColorProperty('background', background, defaultValue: defaultScheme.background));
    properties.add(
      ColorProperty('onBackground', onBackground, defaultValue: defaultScheme.onBackground),
    );
    properties.add(
      ColorProperty('surfaceVariant', surfaceVariant, defaultValue: defaultScheme.surfaceVariant),
    );
  }

  /// Generate a [ColorScheme] derived from the given `imageProvider`.
  ///
  /// Material Color Utilities extracts the dominant color from the
  /// supplied [ImageProvider]. Using this color, a [ColorScheme] is generated
  /// with harmonious colors that meet contrast requirements for accessibility.
  ///
  /// If any of the optional color parameters are non-null, they will be
  /// used in place of the generated colors for that field in the resulting
  /// [ColorScheme]. This allows apps to override specific colors for their
  /// needs.
  ///
  /// Given the nature of the algorithm, the most dominant color of the
  /// `imageProvider` may not wind up as one of the [ColorScheme] colors.
  ///
  /// The provided image will be scaled down to a maximum size of 112x112 pixels
  /// during color extraction.
  ///
  /// {@tool dartpad}
  /// This sample shows how to use [ColorScheme.fromImageProvider] to create
  /// content-based dynamic color schemes.
  ///
  /// ** See code in examples/api/lib/material/color_scheme/dynamic_content_color.0.dart **
  /// {@end-tool}
  ///
  /// See also:
  ///
  ///  * [M3 Guidelines: Dynamic color from content](https://m3.material.io/styles/color/dynamic-color/user-generated-color#8af550b9-a19e-4e9f-bb0a-7f611fed5d0f)
  ///  * <https://pub.dev/packages/dynamic_color>, a package to create
  ///    [ColorScheme]s based on a platform's implementation of dynamic color.
  ///  * <https://m3.material.io/styles/color/the-color-system/color-roles>, the
  ///    Material 3 Color system specification.
  ///  * <https://pub.dev/packages/material_color_utilities>, the package
  ///    used to algorithmically determine the dominant color and to generate
  ///    the [ColorScheme].
  static Future<ColorScheme> fromImageProvider({
    required ImageProvider provider,
    Brightness brightness = Brightness.light,
    DynamicSchemeVariant dynamicSchemeVariant = DynamicSchemeVariant.tonalSpot,
    double contrastLevel = 0.0,
    Color? primary,
    Color? onPrimary,
    Color? primaryContainer,
    Color? onPrimaryContainer,
    Color? primaryFixed,
    Color? primaryFixedDim,
    Color? onPrimaryFixed,
    Color? onPrimaryFixedVariant,
    Color? secondary,
    Color? onSecondary,
    Color? secondaryContainer,
    Color? onSecondaryContainer,
    Color? secondaryFixed,
    Color? secondaryFixedDim,
    Color? onSecondaryFixed,
    Color? onSecondaryFixedVariant,
    Color? tertiary,
    Color? onTertiary,
    Color? tertiaryContainer,
    Color? onTertiaryContainer,
    Color? tertiaryFixed,
    Color? tertiaryFixedDim,
    Color? onTertiaryFixed,
    Color? onTertiaryFixedVariant,
    Color? error,
    Color? onError,
    Color? errorContainer,
    Color? onErrorContainer,
    Color? outline,
    Color? outlineVariant,
    Color? surface,
    Color? onSurface,
    Color? surfaceDim,
    Color? surfaceBright,
    Color? surfaceContainerLowest,
    Color? surfaceContainerLow,
    Color? surfaceContainer,
    Color? surfaceContainerHigh,
    Color? surfaceContainerHighest,
    Color? onSurfaceVariant,
    Color? inverseSurface,
    Color? onInverseSurface,
    Color? inversePrimary,
    Color? shadow,
    Color? scrim,
    Color? surfaceTint,
    @Deprecated(
      'Use surface instead. '
      'This feature was deprecated after v3.18.0-0.1.pre.',
    )
    Color? background,
    @Deprecated(
      'Use onSurface instead. '
      'This feature was deprecated after v3.18.0-0.1.pre.',
    )
    Color? onBackground,
    @Deprecated(
      'Use surfaceContainerHighest instead. '
      'This feature was deprecated after v3.18.0-0.1.pre.',
    )
    Color? surfaceVariant,
  }) async {
    // Extract dominant colors from image.
    final QuantizerResult quantizerResult = await _extractColorsFromImageProvider(provider);
    final Map<int, int> colorToCount = quantizerResult.colorToCount.map(
      (int key, int value) => MapEntry<int, int>(_getArgbFromAbgr(key), value),
    );

    // Score colors for color scheme suitability.
    final List<int> scoredResults = Score.score(colorToCount, desired: 1);
    final ui.Color baseColor = Color(scoredResults.first);

    final DynamicScheme scheme = _buildDynamicScheme(
      brightness,
      baseColor,
      dynamicSchemeVariant,
      contrastLevel,
    );

    return ColorScheme(
      primary: primary ?? Color(MaterialDynamicColors.primary.getArgb(scheme)),
      onPrimary: onPrimary ?? Color(MaterialDynamicColors.onPrimary.getArgb(scheme)),
      primaryContainer:
          primaryContainer ?? Color(MaterialDynamicColors.primaryContainer.getArgb(scheme)),
      onPrimaryContainer:
          onPrimaryContainer ?? Color(MaterialDynamicColors.onPrimaryContainer.getArgb(scheme)),
      primaryFixed: primaryFixed ?? Color(MaterialDynamicColors.primaryFixed.getArgb(scheme)),
      primaryFixedDim:
          primaryFixedDim ?? Color(MaterialDynamicColors.primaryFixedDim.getArgb(scheme)),
      onPrimaryFixed: onPrimaryFixed ?? Color(MaterialDynamicColors.onPrimaryFixed.getArgb(scheme)),
      onPrimaryFixedVariant:
          onPrimaryFixedVariant ??
          Color(MaterialDynamicColors.onPrimaryFixedVariant.getArgb(scheme)),
      secondary: secondary ?? Color(MaterialDynamicColors.secondary.getArgb(scheme)),
      onSecondary: onSecondary ?? Color(MaterialDynamicColors.onSecondary.getArgb(scheme)),
      secondaryContainer:
          secondaryContainer ?? Color(MaterialDynamicColors.secondaryContainer.getArgb(scheme)),
      onSecondaryContainer:
          onSecondaryContainer ?? Color(MaterialDynamicColors.onSecondaryContainer.getArgb(scheme)),
      secondaryFixed: secondaryFixed ?? Color(MaterialDynamicColors.secondaryFixed.getArgb(scheme)),
      secondaryFixedDim:
          secondaryFixedDim ?? Color(MaterialDynamicColors.secondaryFixedDim.getArgb(scheme)),
      onSecondaryFixed:
          onSecondaryFixed ?? Color(MaterialDynamicColors.onSecondaryFixed.getArgb(scheme)),
      onSecondaryFixedVariant:
          onSecondaryFixedVariant ??
          Color(MaterialDynamicColors.onSecondaryFixedVariant.getArgb(scheme)),
      tertiary: tertiary ?? Color(MaterialDynamicColors.tertiary.getArgb(scheme)),
      onTertiary: onTertiary ?? Color(MaterialDynamicColors.onTertiary.getArgb(scheme)),
      tertiaryContainer:
          tertiaryContainer ?? Color(MaterialDynamicColors.tertiaryContainer.getArgb(scheme)),
      onTertiaryContainer:
          onTertiaryContainer ?? Color(MaterialDynamicColors.onTertiaryContainer.getArgb(scheme)),
      tertiaryFixed: tertiaryFixed ?? Color(MaterialDynamicColors.tertiaryFixed.getArgb(scheme)),
      tertiaryFixedDim:
          tertiaryFixedDim ?? Color(MaterialDynamicColors.tertiaryFixedDim.getArgb(scheme)),
      onTertiaryFixed:
          onTertiaryFixed ?? Color(MaterialDynamicColors.onTertiaryFixed.getArgb(scheme)),
      onTertiaryFixedVariant:
          onTertiaryFixedVariant ??
          Color(MaterialDynamicColors.onTertiaryFixedVariant.getArgb(scheme)),
      error: error ?? Color(MaterialDynamicColors.error.getArgb(scheme)),
      onError: onError ?? Color(MaterialDynamicColors.onError.getArgb(scheme)),
      errorContainer: errorContainer ?? Color(MaterialDynamicColors.errorContainer.getArgb(scheme)),
      onErrorContainer:
          onErrorContainer ?? Color(MaterialDynamicColors.onErrorContainer.getArgb(scheme)),
      outline: outline ?? Color(MaterialDynamicColors.outline.getArgb(scheme)),
      outlineVariant: outlineVariant ?? Color(MaterialDynamicColors.outlineVariant.getArgb(scheme)),
      surface: surface ?? Color(MaterialDynamicColors.surface.getArgb(scheme)),
      surfaceDim: surfaceDim ?? Color(MaterialDynamicColors.surfaceDim.getArgb(scheme)),
      surfaceBright: surfaceBright ?? Color(MaterialDynamicColors.surfaceBright.getArgb(scheme)),
      surfaceContainerLowest:
          surfaceContainerLowest ??
          Color(MaterialDynamicColors.surfaceContainerLowest.getArgb(scheme)),
      surfaceContainerLow:
          surfaceContainerLow ?? Color(MaterialDynamicColors.surfaceContainerLow.getArgb(scheme)),
      surfaceContainer:
          surfaceContainer ?? Color(MaterialDynamicColors.surfaceContainer.getArgb(scheme)),
      surfaceContainerHigh:
          surfaceContainerHigh ?? Color(MaterialDynamicColors.surfaceContainerHigh.getArgb(scheme)),
      surfaceContainerHighest:
          surfaceContainerHighest ??
          Color(MaterialDynamicColors.surfaceContainerHighest.getArgb(scheme)),
      onSurface: onSurface ?? Color(MaterialDynamicColors.onSurface.getArgb(scheme)),
      onSurfaceVariant:
          onSurfaceVariant ?? Color(MaterialDynamicColors.onSurfaceVariant.getArgb(scheme)),
      inverseSurface: inverseSurface ?? Color(MaterialDynamicColors.inverseSurface.getArgb(scheme)),
      onInverseSurface:
          onInverseSurface ?? Color(MaterialDynamicColors.inverseOnSurface.getArgb(scheme)),
      inversePrimary: inversePrimary ?? Color(MaterialDynamicColors.inversePrimary.getArgb(scheme)),
      shadow: shadow ?? Color(MaterialDynamicColors.shadow.getArgb(scheme)),
      scrim: scrim ?? Color(MaterialDynamicColors.scrim.getArgb(scheme)),
      surfaceTint: surfaceTint ?? Color(MaterialDynamicColors.primary.getArgb(scheme)),
      brightness: brightness,
      // DEPRECATED (newest deprecations at the bottom)
      background: background ?? Color(MaterialDynamicColors.background.getArgb(scheme)),
      onBackground: onBackground ?? Color(MaterialDynamicColors.onBackground.getArgb(scheme)),
      surfaceVariant: surfaceVariant ?? Color(MaterialDynamicColors.surfaceVariant.getArgb(scheme)),
    );
  }

  // ColorScheme.fromImageProvider() utilities.

  // Extracts bytes from an [ImageProvider] and returns a [QuantizerResult]
  // containing the most dominant colors.
  static Future<QuantizerResult> _extractColorsFromImageProvider(
    ImageProvider imageProvider,
  ) async {
    final ui.Image scaledImage = await _imageProviderToScaled(imageProvider);
    final ByteData? imageBytes = await scaledImage.toByteData();

    final QuantizerResult quantizerResult = await QuantizerCelebi().quantize(
      imageBytes!.buffer.asUint32List(),
      128,
      returnInputPixelToClusterPixel: true,
    );
    return quantizerResult;
  }

  // Scale image size down to reduce computation time of color extraction.
  static Future<ui.Image> _imageProviderToScaled(ImageProvider imageProvider) async {
    const double maxDimension = 112.0;
    final ImageStream stream = imageProvider.resolve(
      const ImageConfiguration(size: Size(maxDimension, maxDimension)),
    );
    final Completer<ui.Image> imageCompleter = Completer<ui.Image>();
    late ImageStreamListener listener;
    late ui.Image scaledImage;
    Timer? loadFailureTimeout;

    listener = ImageStreamListener(
      (ImageInfo info, bool sync) async {
        loadFailureTimeout?.cancel();
        stream.removeListener(listener);
        final ui.Image image = info.image;
        final int width = image.width;
        final int height = image.height;
        double paintWidth = width.toDouble();
        double paintHeight = height.toDouble();
        assert(width > 0 && height > 0);

        final bool rescale = width > maxDimension || height > maxDimension;
        if (rescale) {
          paintWidth = (width > height) ? maxDimension : (maxDimension / height) * width;
          paintHeight = (height > width) ? maxDimension : (maxDimension / width) * height;
        }
        final ui.PictureRecorder pictureRecorder = ui.PictureRecorder();
        final Canvas canvas = Canvas(pictureRecorder);
        paintImage(
          canvas: canvas,
          rect: Rect.fromLTRB(0, 0, paintWidth, paintHeight),
          image: image,
          filterQuality: FilterQuality.none,
        );

        final ui.Picture picture = pictureRecorder.endRecording();
        scaledImage = await picture.toImage(paintWidth.toInt(), paintHeight.toInt());
        imageCompleter.complete(info.image);
      },
      onError: (Object exception, StackTrace? stackTrace) {
        stream.removeListener(listener);
        throw Exception('Failed to render image: $exception');
      },
    );

    loadFailureTimeout = Timer(const Duration(seconds: 5), () {
      stream.removeListener(listener);
      imageCompleter.completeError(TimeoutException('Timeout occurred trying to load image'));
    });

    stream.addListener(listener);
    await imageCompleter.future;
    return scaledImage;
  }

  // Converts AABBGGRR color int to AARRGGBB format.
  static int _getArgbFromAbgr(int abgr) {
    const int exceptRMask = 0xFF00FFFF;
    const int onlyRMask = ~exceptRMask;
    const int exceptBMask = 0xFFFFFF00;
    const int onlyBMask = ~exceptBMask;
    final int r = (abgr & onlyRMask) >> 16;
    final int b = abgr & onlyBMask;
    return (abgr & exceptRMask & exceptBMask) | (b << 16) | r;
  }

  static DynamicScheme _buildDynamicScheme(
    Brightness brightness,
    Color seedColor,
    DynamicSchemeVariant schemeVariant,
    double contrastLevel,
  ) {
    assert(
      contrastLevel >= -1.0 && contrastLevel <= 1.0,
      'contrastLevel must be between -1.0 and 1.0 inclusive.',
    );
    final bool isDark = brightness == Brightness.dark;
    final Hct sourceColor = Hct.fromInt(seedColor.value);
    return switch (schemeVariant) {
      DynamicSchemeVariant.tonalSpot => SchemeTonalSpot(
        sourceColorHct: sourceColor,
        isDark: isDark,
        contrastLevel: contrastLevel,
      ),
      DynamicSchemeVariant.fidelity => SchemeFidelity(
        sourceColorHct: sourceColor,
        isDark: isDark,
        contrastLevel: contrastLevel,
      ),
      DynamicSchemeVariant.content => SchemeContent(
        sourceColorHct: sourceColor,
        isDark: isDark,
        contrastLevel: contrastLevel,
      ),
      DynamicSchemeVariant.monochrome => SchemeMonochrome(
        sourceColorHct: sourceColor,
        isDark: isDark,
        contrastLevel: contrastLevel,
      ),
      DynamicSchemeVariant.neutral => SchemeNeutral(
        sourceColorHct: sourceColor,
        isDark: isDark,
        contrastLevel: contrastLevel,
      ),
      DynamicSchemeVariant.vibrant => SchemeVibrant(
        sourceColorHct: sourceColor,
        isDark: isDark,
        contrastLevel: contrastLevel,
      ),
      DynamicSchemeVariant.expressive => SchemeExpressive(
        sourceColorHct: sourceColor,
        isDark: isDark,
        contrastLevel: contrastLevel,
      ),
      DynamicSchemeVariant.rainbow => SchemeRainbow(
        sourceColorHct: sourceColor,
        isDark: isDark,
        contrastLevel: contrastLevel,
      ),
      DynamicSchemeVariant.fruitSalad => SchemeFruitSalad(
        sourceColorHct: sourceColor,
        isDark: isDark,
        contrastLevel: contrastLevel,
      ),
    };
  }

  /// The [ThemeData.colorScheme] of the ambient [Theme].
  ///
  /// Equivalent to `Theme.of(context).colorScheme`.
  static ColorScheme of(BuildContext context) => Theme.of(context).colorScheme;
}


--- File: packages/flutter/lib/src/material/theme_data.dart ---
// Copyright 2014 The Flutter Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

/// @docImport 'package:flutter/material.dart';
library;

import 'dart:ui' show Color, lerpDouble;

import 'package:flutter/cupertino.dart';
import 'package:flutter/foundation.dart';

import 'action_buttons.dart';
import 'action_icons_theme.dart';
import 'app_bar_theme.dart';
import 'badge_theme.dart';
import 'banner_theme.dart';
import 'bottom_app_bar_theme.dart';
import 'bottom_navigation_bar_theme.dart';
import 'bottom_sheet_theme.dart';
import 'button_bar_theme.dart';
import 'button_theme.dart';
import 'card_theme.dart';
import 'checkbox_theme.dart';
import 'chip_theme.dart';
import 'color_scheme.dart';
import 'colors.dart';
import 'constants.dart';
import 'data_table_theme.dart';
import 'date_picker_theme.dart';
import 'dialog_theme.dart';
import 'divider_theme.dart';
import 'drawer_theme.dart';
import 'dropdown_menu_theme.dart';
import 'elevated_button_theme.dart';
import 'expansion_tile_theme.dart';
import 'filled_button_theme.dart';
import 'floating_action_button_theme.dart';
import 'icon_button_theme.dart';
import 'ink_ripple.dart';
import 'ink_sparkle.dart';
import 'ink_splash.dart';
import 'ink_well.dart' show InteractiveInkFeatureFactory;
import 'input_decorator.dart';
import 'list_tile.dart';
import 'list_tile_theme.dart';
import 'menu_bar_theme.dart';
import 'menu_button_theme.dart';
import 'menu_theme.dart';
import 'navigation_bar_theme.dart';
import 'navigation_drawer_theme.dart';
import 'navigation_rail_theme.dart';
import 'outlined_button_theme.dart';
import 'page_transitions_theme.dart';
import 'popup_menu_theme.dart';
import 'progress_indicator_theme.dart';
import 'radio_theme.dart';
import 'scrollbar_theme.dart';
import 'search_bar_theme.dart';
import 'search_view_theme.dart';
import 'segmented_button_theme.dart';
import 'slider_theme.dart';
import 'snack_bar_theme.dart';
import 'switch_theme.dart';
import 'tab_bar_theme.dart';
import 'text_button_theme.dart';
import 'text_selection_theme.dart';
import 'text_theme.dart';
import 'time_picker_theme.dart';
import 'toggle_buttons_theme.dart';
import 'tooltip_theme.dart';
import 'typography.dart';

export 'package:flutter/services.dart' show Brightness;

// Examples can assume:
// late BuildContext context;

/// Defines a customized theme for components with an `adaptive` factory constructor.
///
/// Currently, only [Switch.adaptive] supports this class.
class Adaptation<T> {
  /// Creates an [Adaptation].
  const Adaptation();

  /// The adaptation's type.
  Type get type => T;

  /// Typically, this is overridden to return an instance of a custom component
  /// ThemeData class, like [SwitchThemeData], instead of the defaultValue.
  ///
  /// Factory constructors that support adaptations - currently only
  /// [Switch.adaptive] - look for a type-specific adaptation in
  /// [ThemeData.adaptationMap] when computing their effective default component
  /// theme. If a matching adaptation is not found, the component may choose to
  /// use a default adaptation. For example, the [Switch.adaptive] component
  /// uses an empty [SwitchThemeData] if a matching adaptation is not found, for
  /// the sake of backwards compatibility.
  ///
  /// {@tool dartpad}
  /// This sample shows how to create and use subclasses of [Adaptation] that
  /// define adaptive [SwitchThemeData]s. The [adapt] method in this example is
  /// overridden to only customize cupertino-style switches, but it can also be
  /// used to customize any other platforms.
  ///
  /// ** See code in examples/api/lib/material/switch/switch.4.dart **
  /// {@end-tool}
  T adapt(ThemeData theme, T defaultValue) => defaultValue;
}

/// An interface that defines custom additions to a [ThemeData] object.
///
/// {@youtube 560 315 https://www.youtube.com/watch?v=8-szcYzFVao}
///
/// Typically used for custom colors. To use, subclass [ThemeExtension],
/// define a number of fields (e.g. [Color]s), and implement the [copyWith] and
/// [lerp] methods. The latter will ensure smooth transitions of properties when
/// switching themes.
///
/// {@tool dartpad}
/// This sample shows how to create and use a subclass of [ThemeExtension] that
/// defines two colors.
///
/// ** See code in examples/api/lib/material/theme/theme_extension.1.dart **
/// {@end-tool}
abstract class ThemeExtension<T extends ThemeExtension<T>> {
  /// Enable const constructor for subclasses.
  const ThemeExtension();

  /// The extension's type.
  Object get type => T;

  /// Creates a copy of this theme extension with the given fields
  /// replaced by the non-null parameter values.
  ThemeExtension<T> copyWith();

  /// Linearly interpolate with another [ThemeExtension] object.
  ///
  /// {@macro dart.ui.shadow.lerp}
  ThemeExtension<T> lerp(covariant ThemeExtension<T>? other, double t);
}

/// Configures the tap target and layout size of certain Material widgets.
///
/// Changing the value in [ThemeData.materialTapTargetSize] will affect the
/// accessibility experience.
///
/// Some of the impacted widgets include:
///
///   * [FloatingActionButton], only the mini tap target size is increased.
///   * [MaterialButton]
///   * [OutlinedButton]
///   * [TextButton]
///   * [ElevatedButton]
///   * [IconButton]
///   * The time picker widget ([showTimePicker])
///   * [SnackBar]
///   * [Chip]
///   * [RawChip]
///   * [InputChip]
///   * [ChoiceChip]
///   * [FilterChip]
///   * [ActionChip]
///   * [Radio]
///   * [Switch]
///   * [Checkbox]
enum MaterialTapTargetSize {
  /// Expands the minimum tap target size to 48px by 48px.
  ///
  /// This is the default value of [ThemeData.materialTapTargetSize] and the
  /// recommended size to conform to Android accessibility scanner
  /// recommendations.
  padded,

  /// Shrinks the tap target size to the minimum provided by the Material
  /// specification.
  shrinkWrap,
}

/// Defines the configuration of the overall visual [Theme] for a [MaterialApp]
/// or a widget subtree within the app.
///
/// The [MaterialApp] theme property can be used to configure the appearance
/// of the entire app. Widget subtrees within an app can override the app's
/// theme by including a [Theme] widget at the top of the subtree.
///
/// Widgets whose appearance should align with the overall theme can obtain the
/// current theme's configuration with [Theme.of]. Material components typically
/// depend exclusively on the [colorScheme] and [textTheme]. These properties
/// are guaranteed to have non-null values.
///
/// The static [Theme.of] method finds the [ThemeData] value specified for the
/// nearest [BuildContext] ancestor. This lookup is inexpensive, essentially
/// just a single HashMap access. It can sometimes be a little confusing
/// because [Theme.of] can not see a [Theme] widget that is defined in the
/// current build method's context. To overcome that, create a new custom widget
/// for the subtree that appears below the new [Theme], or insert a widget
/// that creates a new BuildContext, like [Builder].
///
/// {@tool dartpad}
/// This example demonstrates how a typical [MaterialApp] specifies
/// and uses a custom [Theme]. The theme's [ColorScheme] is based on a
/// single "seed" color and configures itself to match the platform's
/// current light or dark color configuration. The theme overrides the
/// default configuration of [FloatingActionButton] to show how to
/// customize the appearance a class of components.
///
/// ** See code in examples/api/lib/material/theme_data/theme_data.0.dart **
/// {@end-tool}
///
/// See <https://material.io/design/color/> for
/// more discussion on how to pick the right colors.

@immutable
class ThemeData with Diagnosticable {
  /// Create a [ThemeData] that's used to configure a [Theme].
  ///
  /// The [colorScheme] and [textTheme] are used by the Material components to
  /// compute default values for visual properties. The API documentation for
  /// each component widget explains exactly how the defaults are computed.
  ///
  /// When providing a [ColorScheme], apps can either provide one directly
  /// with the [colorScheme] parameter, or have one generated for them by
  /// using the [colorSchemeSeed] and [brightness] parameters. A generated
  /// color scheme will be based on the tones of [colorSchemeSeed] and all of
  /// its contrasting color will meet accessibility guidelines for readability.
  /// (See [ColorScheme.fromSeed] for more details.)
  ///
  /// If the app wants to customize a generated color scheme, it can use
  /// [ColorScheme.fromSeed] directly and then [ColorScheme.copyWith] on the
  /// result to override any colors that need to be replaced. The result of
  /// this can be used as the [colorScheme] directly.
  ///
  /// For historical reasons, instead of using a [colorSchemeSeed] or
  /// [colorScheme], you can provide either a [primaryColor] or [primarySwatch]
  /// to construct the [colorScheme], but the results will not be as complete
  /// as when using generation from a seed color.
  ///
  /// If [colorSchemeSeed] is non-null then [colorScheme], [primaryColor] and
  /// [primarySwatch] must all be null.
  ///
  /// The [textTheme] [TextStyle] colors are black if the color scheme's
  /// brightness is [Brightness.light], and white for [Brightness.dark].
  ///
  /// To override the appearance of specific components, provide
  /// a component theme parameter like [sliderTheme], [toggleButtonsTheme],
  /// or [bottomNavigationBarTheme].
  ///
  /// See also:
  ///
  ///  * [ThemeData.from], which creates a ThemeData from a [ColorScheme].
  ///  * [ThemeData.light], which creates the default light theme.
  ///  * [ThemeData.dark], which creates the default dark theme.
  ///  * [ColorScheme.fromSeed], which is used to create a [ColorScheme] from a seed color.
  factory ThemeData({
    // For the sanity of the reader, make sure these properties are in the same
    // order in every place that they are separated by section comments (e.g.
    // GENERAL CONFIGURATION). Each section except for deprecations should be
    // alphabetical by symbol name.

    // GENERAL CONFIGURATION
    Iterable<Adaptation<Object>>? adaptations,
    bool? applyElevationOverlayColor,
    NoDefaultCupertinoThemeData? cupertinoOverrideTheme,
    Iterable<ThemeExtension<dynamic>>? extensions,
    InputDecorationTheme? inputDecorationTheme,
    MaterialTapTargetSize? materialTapTargetSize,
    PageTransitionsTheme? pageTransitionsTheme,
    TargetPlatform? platform,
    ScrollbarThemeData? scrollbarTheme,
    InteractiveInkFeatureFactory? splashFactory,
    bool? useMaterial3,
    VisualDensity? visualDensity,
    // COLOR
    ColorScheme? colorScheme,
    Brightness? brightness,
    Color? colorSchemeSeed,
    // [colorScheme] is the preferred way to configure colors. The [Color] properties
    // listed below (as well as primarySwatch) will gradually be phased out, see
    // https://github.com/flutter/flutter/issues/91772.
    Color? canvasColor,
    Color? cardColor,
    Color? disabledColor,
    Color? dividerColor,
    Color? focusColor,
    Color? highlightColor,
    Color? hintColor,
    Color? hoverColor,
    Color? indicatorColor,
    Color? primaryColor,
    Color? primaryColorDark,
    Color? primaryColorLight,
    MaterialColor? primarySwatch,
    Color? scaffoldBackgroundColor,
    Color? secondaryHeaderColor,
    Color? shadowColor,
    Color? splashColor,
    Color? unselectedWidgetColor,
    // TYPOGRAPHY & ICONOGRAPHY
    String? fontFamily,
    List<String>? fontFamilyFallback,
    String? package,
    IconThemeData? iconTheme,
    IconThemeData? primaryIconTheme,
    TextTheme? primaryTextTheme,
    TextTheme? textTheme,
    Typography? typography,
    // COMPONENT THEMES
    ActionIconThemeData? actionIconTheme,
    AppBarTheme? appBarTheme,
    BadgeThemeData? badgeTheme,
    MaterialBannerThemeData? bannerTheme,
    BottomAppBarTheme? bottomAppBarTheme,
    BottomNavigationBarThemeData? bottomNavigationBarTheme,
    BottomSheetThemeData? bottomSheetTheme,
    ButtonThemeData? buttonTheme,
    // TODO(QuncCccccc): Change the parameter type to CardThemeData
    Object? cardTheme,
    CheckboxThemeData? checkboxTheme,
    ChipThemeData? chipTheme,
    DataTableThemeData? dataTableTheme,
    DatePickerThemeData? datePickerTheme,
    // TODO(QuncCccccc): Change the parameter type to DialogThemeData
    Object? dialogTheme,
    DividerThemeData? dividerTheme,
    DrawerThemeData? drawerTheme,
    DropdownMenuThemeData? dropdownMenuTheme,
    ElevatedButtonThemeData? elevatedButtonTheme,
    ExpansionTileThemeData? expansionTileTheme,
    FilledButtonThemeData? filledButtonTheme,
    FloatingActionButtonThemeData? floatingActionButtonTheme,
    IconButtonThemeData? iconButtonTheme,
    ListTileThemeData? listTileTheme,
    MenuBarThemeData? menuBarTheme,
    MenuButtonThemeData? menuButtonTheme,
    MenuThemeData? menuTheme,
    NavigationBarThemeData? navigationBarTheme,
    NavigationDrawerThemeData? navigationDrawerTheme,
    NavigationRailThemeData? navigationRailTheme,
    OutlinedButtonThemeData? outlinedButtonTheme,
    PopupMenuThemeData? popupMenuTheme,
    ProgressIndicatorThemeData? progressIndicatorTheme,
    RadioThemeData? radioTheme,
    SearchBarThemeData? searchBarTheme,
    SearchViewThemeData? searchViewTheme,
    SegmentedButtonThemeData? segmentedButtonTheme,
    SliderThemeData? sliderTheme,
    SnackBarThemeData? snackBarTheme,
    SwitchThemeData? switchTheme,
    // TODO(QuncCccccc): Change the parameter type to TabBarThemeData
    Object? tabBarTheme,
    TextButtonThemeData? textButtonTheme,
    TextSelectionThemeData? textSelectionTheme,
    TimePickerThemeData? timePickerTheme,
    ToggleButtonsThemeData? toggleButtonsTheme,
    TooltipThemeData? tooltipTheme,
    // DEPRECATED (newest deprecations at the bottom)
    @Deprecated(
      'Use OverflowBar instead. '
      'This feature was deprecated after v3.21.0-10.0.pre.',
    )
    ButtonBarThemeData? buttonBarTheme,
    @Deprecated(
      'Use DialogThemeData.backgroundColor instead. '
      'This feature was deprecated after v3.27.0-0.1.pre.',
    )
    Color? dialogBackgroundColor,
  }) {
    // GENERAL CONFIGURATION
    cupertinoOverrideTheme = cupertinoOverrideTheme?.noDefault();
    extensions ??= <ThemeExtension<dynamic>>[];
    adaptations ??= <Adaptation<Object>>[];
    inputDecorationTheme ??= const InputDecorationTheme();
    platform ??= defaultTargetPlatform;
    switch (platform) {
      case TargetPlatform.android:
      case TargetPlatform.fuchsia:
      case TargetPlatform.iOS:
        materialTapTargetSize ??= MaterialTapTargetSize.padded;
      case TargetPlatform.linux:
      case TargetPlatform.macOS:
      case TargetPlatform.windows:
        materialTapTargetSize ??= MaterialTapTargetSize.shrinkWrap;
    }
    pageTransitionsTheme ??= const PageTransitionsTheme();
    scrollbarTheme ??= const ScrollbarThemeData();
    visualDensity ??= VisualDensity.defaultDensityForPlatform(platform);
    useMaterial3 ??= true;
    final bool useInkSparkle = platform == TargetPlatform.android && !kIsWeb;
    splashFactory ??=
        useMaterial3
            ? useInkSparkle
                ? InkSparkle.splashFactory
                : InkRipple.splashFactory
            : InkSplash.splashFactory;

    // COLOR
    assert(
      colorScheme?.brightness == null ||
          brightness == null ||
          colorScheme!.brightness == brightness,
      'ThemeData.brightness does not match ColorScheme.brightness. '
      'Either override ColorScheme.brightness or ThemeData.brightness to '
      'match the other.',
    );
    assert(colorSchemeSeed == null || colorScheme == null);
    assert(colorSchemeSeed == null || primarySwatch == null);
    assert(colorSchemeSeed == null || primaryColor == null);
    final Brightness effectiveBrightness =
        brightness ?? colorScheme?.brightness ?? Brightness.light;
    final bool isDark = effectiveBrightness == Brightness.dark;
    if (colorSchemeSeed != null || useMaterial3) {
      if (colorSchemeSeed != null) {
        colorScheme = ColorScheme.fromSeed(
          seedColor: colorSchemeSeed,
          brightness: effectiveBrightness,
        );
      }
      colorScheme ??= isDark ? _colorSchemeDarkM3 : _colorSchemeLightM3;

      // For surfaces that use primary color in light themes and surface color in dark
      final Color primarySurfaceColor = isDark ? colorScheme.surface : colorScheme.primary;
      final Color onPrimarySurfaceColor = isDark ? colorScheme.onSurface : colorScheme.onPrimary;

      // Default some of the color settings to values from the color scheme
      primaryColor ??= primarySurfaceColor;
      canvasColor ??= colorScheme.surface;
      scaffoldBackgroundColor ??= colorScheme.surface;
      cardColor ??= colorScheme.surface;
      dividerColor ??= colorScheme.outline;
      dialogBackgroundColor ??= colorScheme.surface;
      indicatorColor ??= onPrimarySurfaceColor;
      applyElevationOverlayColor ??= brightness == Brightness.dark;
    }
    applyElevationOverlayColor ??= false;
    primarySwatch ??= Colors.blue;
    primaryColor ??= isDark ? Colors.grey[900]! : primarySwatch;
    final Brightness estimatedPrimaryColorBrightness = estimateBrightnessForColor(primaryColor);
    primaryColorLight ??= isDark ? Colors.grey[500]! : primarySwatch[100]!;
    primaryColorDark ??= isDark ? Colors.black : primarySwatch[700]!;
    final bool primaryIsDark = estimatedPrimaryColorBrightness == Brightness.dark;
    focusColor ??= isDark ? Colors.white.withOpacity(0.12) : Colors.black.withOpacity(0.12);
    hoverColor ??= isDark ? Colors.white.withOpacity(0.04) : Colors.black.withOpacity(0.04);
    shadowColor ??= Colors.black;
    canvasColor ??= isDark ? Colors.grey[850]! : Colors.grey[50]!;
    scaffoldBackgroundColor ??= canvasColor;
    cardColor ??= isDark ? Colors.grey[800]! : Colors.white;
    dividerColor ??= isDark ? const Color(0x1FFFFFFF) : const Color(0x1F000000);
    // Create a ColorScheme that is backwards compatible as possible
    // with the existing default ThemeData color values.
    colorScheme ??= ColorScheme.fromSwatch(
      primarySwatch: primarySwatch,
      accentColor: isDark ? Colors.tealAccent[200]! : primarySwatch[500]!,
      cardColor: cardColor,
      backgroundColor: isDark ? Colors.grey[700]! : primarySwatch[200]!,
      errorColor: Colors.red[700],
      brightness: effectiveBrightness,
    );
    unselectedWidgetColor ??= isDark ? Colors.white70 : Colors.black54;
    // Spec doesn't specify a dark theme secondaryHeaderColor, this is a guess.
    secondaryHeaderColor ??= isDark ? Colors.grey[700]! : primarySwatch[50]!;
    indicatorColor ??= colorScheme.secondary == primaryColor ? Colors.white : colorScheme.secondary;
    hintColor ??= isDark ? Colors.white60 : Colors.black.withOpacity(0.6);
    // The default [buttonTheme] is here because it doesn't use the defaults for
    // [disabledColor], [highlightColor], and [splashColor].
    buttonTheme ??= ButtonThemeData(
      colorScheme: colorScheme,
      buttonColor: isDark ? primarySwatch[600]! : Colors.grey[300]!,
      disabledColor: disabledColor,
      focusColor: focusColor,
      hoverColor: hoverColor,
      highlightColor: highlightColor,
      splashColor: splashColor,
      materialTapTargetSize: materialTapTargetSize,
    );
    disabledColor ??= isDark ? Colors.white38 : Colors.black38;
    highlightColor ??= isDark ? const Color(0x40CCCCCC) : const Color(0x66BCBCBC);
    splashColor ??= isDark ? const Color(0x40CCCCCC) : const Color(0x66C8C8C8);

    // TYPOGRAPHY & ICONOGRAPHY
    typography ??=
        useMaterial3
            ? Typography.material2021(platform: platform, colorScheme: colorScheme)
            : Typography.material2014(platform: platform);
    TextTheme defaultTextTheme = isDark ? typography.white : typography.black;
    TextTheme defaultPrimaryTextTheme = primaryIsDark ? typography.white : typography.black;
    if (fontFamily != null) {
      defaultTextTheme = defaultTextTheme.apply(fontFamily: fontFamily);
      defaultPrimaryTextTheme = defaultPrimaryTextTheme.apply(fontFamily: fontFamily);
    }
    if (fontFamilyFallback != null) {
      defaultTextTheme = defaultTextTheme.apply(fontFamilyFallback: fontFamilyFallback);
      defaultPrimaryTextTheme = defaultPrimaryTextTheme.apply(
        fontFamilyFallback: fontFamilyFallback,
      );
    }
    if (package != null) {
      defaultTextTheme = defaultTextTheme.apply(package: package);
      defaultPrimaryTextTheme = defaultPrimaryTextTheme.apply(package: package);
    }
    textTheme = defaultTextTheme.merge(textTheme);
    primaryTextTheme = defaultPrimaryTextTheme.merge(primaryTextTheme);
    iconTheme ??=
        isDark
            ? IconThemeData(color: kDefaultIconLightColor)
            : IconThemeData(color: kDefaultIconDarkColor);
    primaryIconTheme ??=
        primaryIsDark
            ? const IconThemeData(color: Colors.white)
            : const IconThemeData(color: Colors.black);

    // COMPONENT THEMES
    appBarTheme ??= const AppBarTheme();
    badgeTheme ??= const BadgeThemeData();
    bannerTheme ??= const MaterialBannerThemeData();
    bottomAppBarTheme ??= const BottomAppBarTheme();
    bottomNavigationBarTheme ??= const BottomNavigationBarThemeData();
    bottomSheetTheme ??= const BottomSheetThemeData();
    // TODO(QuncCccccc): Clean it up once the type of `cardTheme` is changed to `CardThemeData`
    if (cardTheme != null) {
      if (cardTheme is CardTheme) {
        cardTheme = cardTheme.data;
      } else if (cardTheme is! CardThemeData) {
        throw ArgumentError('cardTheme must be either a CardThemeData or a CardTheme');
      }
    }
    cardTheme ??= const CardThemeData();
    checkboxTheme ??= const CheckboxThemeData();
    chipTheme ??= const ChipThemeData();
    dataTableTheme ??= const DataTableThemeData();
    datePickerTheme ??= const DatePickerThemeData();
    // TODO(QuncCccccc): Clean this up once the type of `dialogTheme` is changed to `DialogThemeData`
    if (dialogTheme != null) {
      if (dialogTheme is DialogTheme) {
        dialogTheme = dialogTheme.data;
      } else if (dialogTheme is! DialogThemeData) {
        throw ArgumentError('dialogTheme must be either a DialogThemeData or a DialogTheme');
      }
    }
    dialogTheme ??= const DialogThemeData();
    dividerTheme ??= const DividerThemeData();
    drawerTheme ??= const DrawerThemeData();
    dropdownMenuTheme ??= const DropdownMenuThemeData();
    elevatedButtonTheme ??= const ElevatedButtonThemeData();
    expansionTileTheme ??= const ExpansionTileThemeData();
    filledButtonTheme ??= const FilledButtonThemeData();
    floatingActionButtonTheme ??= const FloatingActionButtonThemeData();
    iconButtonTheme ??= const IconButtonThemeData();
    listTileTheme ??= const ListTileThemeData();
    menuBarTheme ??= const MenuBarThemeData();
    menuButtonTheme ??= const MenuButtonThemeData();
    menuTheme ??= const MenuThemeData();
    navigationBarTheme ??= const NavigationBarThemeData();
    navigationDrawerTheme ??= const NavigationDrawerThemeData();
    navigationRailTheme ??= const NavigationRailThemeData();
    outlinedButtonTheme ??= const OutlinedButtonThemeData();
    popupMenuTheme ??= const PopupMenuThemeData();
    progressIndicatorTheme ??= const ProgressIndicatorThemeData();
    radioTheme ??= const RadioThemeData();
    searchBarTheme ??= const SearchBarThemeData();
    searchViewTheme ??= const SearchViewThemeData();
    segmentedButtonTheme ??= const SegmentedButtonThemeData();
    sliderTheme ??= const SliderThemeData();
    snackBarTheme ??= const SnackBarThemeData();
    switchTheme ??= const SwitchThemeData();
    // TODO(QuncCccccc): Clean this up once the type of `tabBarTheme` is changed to `TabBarThemeData`
    if (tabBarTheme != null) {
      if (tabBarTheme is TabBarTheme) {
        tabBarTheme = tabBarTheme.data;
      } else if (tabBarTheme is! TabBarThemeData) {
        throw ArgumentError('tabBarTheme must be either a TabBarThemeData or a TabBarTheme');
      }
    }
    tabBarTheme ??= const TabBarThemeData();
    textButtonTheme ??= const TextButtonThemeData();
    textSelectionTheme ??= const TextSelectionThemeData();
    timePickerTheme ??= const TimePickerThemeData();
    toggleButtonsTheme ??= const ToggleButtonsThemeData();
    tooltipTheme ??= const TooltipThemeData();
    // DEPRECATED (newest deprecations at the bottom)
    buttonBarTheme ??= const ButtonBarThemeData();
    dialogBackgroundColor ??= isDark ? Colors.grey[800]! : Colors.white;
    return ThemeData.raw(
      // For the sanity of the reader, make sure these properties are in the same
      // order in every place that they are separated by section comments (e.g.
      // GENERAL CONFIGURATION). Each section except for deprecations should be
      // alphabetical by symbol name.

      // GENERAL CONFIGURATION
      adaptationMap: _createAdaptationMap(adaptations),
      applyElevationOverlayColor: applyElevationOverlayColor,
      cupertinoOverrideTheme: cupertinoOverrideTheme,
      extensions: _themeExtensionIterableToMap(extensions),
      inputDecorationTheme: inputDecorationTheme,
      materialTapTargetSize: materialTapTargetSize,
      pageTransitionsTheme: pageTransitionsTheme,
      platform: platform,
      scrollbarTheme: scrollbarTheme,
      splashFactory: splashFactory,
      useMaterial3: useMaterial3,
      visualDensity: visualDensity,
      // COLOR
      canvasColor: canvasColor,
      cardColor: cardColor,
      colorScheme: colorScheme,
      disabledColor: disabledColor,
      dividerColor: dividerColor,
      focusColor: focusColor,
      highlightColor: highlightColor,
      hintColor: hintColor,
      hoverColor: hoverColor,
      indicatorColor: indicatorColor,
      primaryColor: primaryColor,
      primaryColorDark: primaryColorDark,
      primaryColorLight: primaryColorLight,
      scaffoldBackgroundColor: scaffoldBackgroundColor,
      secondaryHeaderColor: secondaryHeaderColor,
      shadowColor: shadowColor,
      splashColor: splashColor,
      unselectedWidgetColor: unselectedWidgetColor,
      // TYPOGRAPHY & ICONOGRAPHY
      iconTheme: iconTheme,
      primaryTextTheme: primaryTextTheme,
      textTheme: textTheme,
      typography: typography,
      primaryIconTheme: primaryIconTheme,
      // COMPONENT THEMES
      actionIconTheme: actionIconTheme,
      appBarTheme: appBarTheme,
      badgeTheme: badgeTheme,
      bannerTheme: bannerTheme,
      bottomAppBarTheme: bottomAppBarTheme,
      bottomNavigationBarTheme: bottomNavigationBarTheme,
      bottomSheetTheme: bottomSheetTheme,
      buttonTheme: buttonTheme,
      cardTheme: cardTheme as CardThemeData,
      checkboxTheme: checkboxTheme,
      chipTheme: chipTheme,
      dataTableTheme: dataTableTheme,
      datePickerTheme: datePickerTheme,
      dialogTheme: dialogTheme as DialogThemeData,
      dividerTheme: dividerTheme,
      drawerTheme: drawerTheme,
      dropdownMenuTheme: dropdownMenuTheme,
      elevatedButtonTheme: elevatedButtonTheme,
      expansionTileTheme: expansionTileTheme,
      filledButtonTheme: filledButtonTheme,
      floatingActionButtonTheme: floatingActionButtonTheme,
      iconButtonTheme: iconButtonTheme,
      listTileTheme: listTileTheme,
      menuBarTheme: menuBarTheme,
      menuButtonTheme: menuButtonTheme,
      menuTheme: menuTheme,
      navigationBarTheme: navigationBarTheme,
      navigationDrawerTheme: navigationDrawerTheme,
      navigationRailTheme: navigationRailTheme,
      outlinedButtonTheme: outlinedButtonTheme,
      popupMenuTheme: popupMenuTheme,
      progressIndicatorTheme: progressIndicatorTheme,
      radioTheme: radioTheme,
      searchBarTheme: searchBarTheme,
      searchViewTheme: searchViewTheme,
      segmentedButtonTheme: segmentedButtonTheme,
      sliderTheme: sliderTheme,
      snackBarTheme: snackBarTheme,
      switchTheme: switchTheme,
      tabBarTheme: tabBarTheme as TabBarThemeData,
      textButtonTheme: textButtonTheme,
      textSelectionTheme: textSelectionTheme,
      timePickerTheme: timePickerTheme,
      toggleButtonsTheme: toggleButtonsTheme,
      tooltipTheme: tooltipTheme,
      // DEPRECATED (newest deprecations at the bottom)
      buttonBarTheme: buttonBarTheme,
      dialogBackgroundColor: dialogBackgroundColor,
    );
  }

  /// Create a [ThemeData] given a set of exact values. Most values must be
  /// specified. They all must also be non-null except for
  /// [cupertinoOverrideTheme], and deprecated members.
  ///
  /// This will rarely be used directly. It is used by [lerp] to
  /// create intermediate themes based on two themes created with the
  /// [ThemeData] constructor.
  const ThemeData.raw({
    // For the sanity of the reader, make sure these properties are in the same
    // order in every place that they are separated by section comments (e.g.
    // GENERAL CONFIGURATION). Each section except for deprecations should be
    // alphabetical by symbol name.

    // GENERAL CONFIGURATION
    required this.adaptationMap,
    required this.applyElevationOverlayColor,
    required this.cupertinoOverrideTheme,
    required this.extensions,
    required this.inputDecorationTheme,
    required this.materialTapTargetSize,
    required this.pageTransitionsTheme,
    required this.platform,
    required this.scrollbarTheme,
    required this.splashFactory,
    required this.useMaterial3,
    required this.visualDensity,
    // COLOR
    required this.colorScheme,
    // [colorScheme] is the preferred way to configure colors. The [Color] properties
    // listed below (as well as primarySwatch) will gradually be phased out, see
    // https://github.com/flutter/flutter/issues/91772.
    required this.canvasColor,
    required this.cardColor,
    required this.disabledColor,
    required this.dividerColor,
    required this.focusColor,
    required this.highlightColor,
    required this.hintColor,
    required this.hoverColor,
    required this.indicatorColor,
    required this.primaryColor,
    required this.primaryColorDark,
    required this.primaryColorLight,
    required this.scaffoldBackgroundColor,
    required this.secondaryHeaderColor,
    required this.shadowColor,
    required this.splashColor,
    required this.unselectedWidgetColor,
    // TYPOGRAPHY & ICONOGRAPHY
    required this.iconTheme,
    required this.primaryIconTheme,
    required this.primaryTextTheme,
    required this.textTheme,
    required this.typography,
    // COMPONENT THEMES
    required this.actionIconTheme,
    required this.appBarTheme,
    required this.badgeTheme,
    required this.bannerTheme,
    required this.bottomAppBarTheme,
    required this.bottomNavigationBarTheme,
    required this.bottomSheetTheme,
    required this.buttonTheme,
    required this.cardTheme,
    required this.checkboxTheme,
    required this.chipTheme,
    required this.dataTableTheme,
    required this.datePickerTheme,
    required this.dialogTheme,
    required this.dividerTheme,
    required this.drawerTheme,
    required this.dropdownMenuTheme,
    required this.elevatedButtonTheme,
    required this.expansionTileTheme,
    required this.filledButtonTheme,
    required this.floatingActionButtonTheme,
    required this.iconButtonTheme,
    required this.listTileTheme,
    required this.menuBarTheme,
    required this.menuButtonTheme,
    required this.menuTheme,
    required this.navigationBarTheme,
    required this.navigationDrawerTheme,
    required this.navigationRailTheme,
    required this.outlinedButtonTheme,
    required this.popupMenuTheme,
    required this.progressIndicatorTheme,
    required this.radioTheme,
    required this.searchBarTheme,
    required this.searchViewTheme,
    required this.segmentedButtonTheme,
    required this.sliderTheme,
    required this.snackBarTheme,
    required this.switchTheme,
    required this.tabBarTheme,
    required this.textButtonTheme,
    required this.textSelectionTheme,
    required this.timePickerTheme,
    required this.toggleButtonsTheme,
    required this.tooltipTheme,
    // DEPRECATED (newest deprecations at the bottom)
    @Deprecated(
      'Use OverflowBar instead. '
      'This feature was deprecated after v3.21.0-10.0.pre.',
    )
    ButtonBarThemeData? buttonBarTheme,
    @Deprecated(
      'Use DialogThemeData.backgroundColor instead. '
      'This feature was deprecated after v3.27.0-0.1.pre.',
    )
    required this.dialogBackgroundColor,
  }) : // DEPRECATED (newest deprecations at the bottom)
       // should not be `required`, use getter pattern to avoid breakages.
       _buttonBarTheme = buttonBarTheme,
       assert(buttonBarTheme != null);

  /// Create a [ThemeData] based on the colors in the given [colorScheme] and
  /// text styles of the optional [textTheme].
  ///
  /// If [colorScheme].brightness is [Brightness.dark] then
  /// [ThemeData.applyElevationOverlayColor] will be set to true to support
  /// the Material dark theme method for indicating elevation by applying
  /// a semi-transparent onSurface color on top of the surface color.
  ///
  /// This is the recommended method to theme your application. As we move
  /// forward we will be converting all the widget implementations to only use
  /// colors or colors derived from those in [ColorScheme].
  ///
  /// {@tool snippet}
  /// This example will set up an application to use the baseline Material
  /// Design light and dark themes.
  ///
  /// ```dart
  /// MaterialApp(
  ///   theme: ThemeData.from(colorScheme: const ColorScheme.light()),
  ///   darkTheme: ThemeData.from(colorScheme: const ColorScheme.dark()),
  /// )
  /// ```
  /// {@end-tool}
  ///
  /// See <https://material.io/design/color/> for
  /// more discussion on how to pick the right colors.
  factory ThemeData.from({
    required ColorScheme colorScheme,
    TextTheme? textTheme,
    bool? useMaterial3,
  }) {
    final bool isDark = colorScheme.brightness == Brightness.dark;

    // For surfaces that use primary color in light themes and surface color in dark
    final Color primarySurfaceColor = isDark ? colorScheme.surface : colorScheme.primary;
    final Color onPrimarySurfaceColor = isDark ? colorScheme.onSurface : colorScheme.onPrimary;

    return ThemeData(
      colorScheme: colorScheme,
      brightness: colorScheme.brightness,
      primaryColor: primarySurfaceColor,
      canvasColor: colorScheme.surface,
      scaffoldBackgroundColor: colorScheme.surface,
      cardColor: colorScheme.surface,
      dividerColor: colorScheme.onSurface.withOpacity(0.12),
      dialogBackgroundColor: colorScheme.surface,
      indicatorColor: onPrimarySurfaceColor,
      textTheme: textTheme,
      applyElevationOverlayColor: isDark,
      useMaterial3: useMaterial3,
    );
  }

  /// A default light theme.
  ///
  /// This theme does not contain text geometry. Instead, it is expected that
  /// this theme is localized using text geometry using [ThemeData.localize].
  factory ThemeData.light({bool? useMaterial3}) =>
      ThemeData(brightness: Brightness.light, useMaterial3: useMaterial3);

  /// A default dark theme.
  ///
  /// This theme does not contain text geometry. Instead, it is expected that
  /// this theme is localized using text geometry using [ThemeData.localize].
  factory ThemeData.dark({bool? useMaterial3}) =>
      ThemeData(brightness: Brightness.dark, useMaterial3: useMaterial3);

  /// The default color theme. Same as [ThemeData.light].
  ///
  /// This is used by [Theme.of] when no theme has been specified.
  ///
  /// This theme does not contain text geometry. Instead, it is expected that
  /// this theme is localized using text geometry using [ThemeData.localize].
  ///
  /// Most applications would use [Theme.of], which provides correct localized
  /// text geometry.
  factory ThemeData.fallback({bool? useMaterial3}) => ThemeData.light(useMaterial3: useMaterial3);

  /// Used to obtain a particular [Adaptation] from [adaptationMap].
  ///
  /// To get an adaptation, use `Theme.of(context).getAdaptation<MyAdaptation>()`.
  Adaptation<T>? getAdaptation<T>() => adaptationMap[T] as Adaptation<T>?;

  static Map<Type, Adaptation<Object>> _createAdaptationMap(
    Iterable<Adaptation<Object>> adaptations,
  ) {
    final Map<Type, Adaptation<Object>> adaptationMap = <Type, Adaptation<Object>>{
      for (final Adaptation<Object> adaptation in adaptations) adaptation.type: adaptation,
    };
    return adaptationMap;
  }

  /// The overall theme brightness.
  ///
  /// The default [TextStyle] color for the [textTheme] is black if the
  /// theme is constructed with [Brightness.light] and white if the
  /// theme is constructed with [Brightness.dark].
  Brightness get brightness => colorScheme.brightness;

  // For the sanity of the reader, make sure these properties are in the same
  // order in every place that they are separated by section comments (e.g.
  // GENERAL CONFIGURATION). Each section except for deprecations should be
  // alphabetical by symbol name.

  // GENERAL CONFIGURATION

  /// Apply a semi-transparent overlay color on Material surfaces to indicate
  /// elevation for dark themes.
  ///
  /// If [useMaterial3] is true, then this flag is ignored as there is a new
  /// [Material.surfaceTintColor] used to create an overlay for Material 3.
  /// This flag is meant only for the Material 2 elevation overlay for dark
  /// themes.
  ///
  /// Material drop shadows can be difficult to see in a dark theme, so the
  /// elevation of a surface should be portrayed with an "overlay" in addition
  /// to the shadow. As the elevation of the component increases, the
  /// overlay increases in opacity. [applyElevationOverlayColor] turns the
  /// application of this overlay on or off for dark themes.
  ///
  /// If true and [brightness] is [Brightness.dark], a
  /// semi-transparent version of [ColorScheme.onSurface] will be
  /// applied on top of [Material] widgets that have a [ColorScheme.surface]
  /// color. The level of transparency is based on [Material.elevation] as
  /// per the Material Dark theme specification.
  ///
  /// If false the surface color will be used unmodified.
  ///
  /// Defaults to false in order to maintain backwards compatibility with
  /// apps that were built before the Material Dark theme specification
  /// was published. New apps should set this to true for any themes
  /// where [brightness] is [Brightness.dark].
  ///
  /// See also:
  ///
  ///  * [Material.elevation], which effects the level of transparency of the
  ///    overlay color.
  ///  * [ElevationOverlay.applyOverlay], which is used by [Material] to apply
  ///    the overlay color to its surface color.
  ///  * <https://material.io/design/color/dark-theme.html>, which specifies how
  ///    the overlay should be applied.
  final bool applyElevationOverlayColor;

  /// Components of the [CupertinoThemeData] to override from the Material
  /// [ThemeData] adaptation.
  ///
  /// By default, [cupertinoOverrideTheme] is null and Cupertino widgets
  /// descendant to the Material [Theme] will adhere to a [CupertinoTheme]
  /// derived from the Material [ThemeData]. e.g. [ThemeData]'s [ColorScheme]
  /// will also inform the [CupertinoThemeData]'s `primaryColor` etc.
  ///
  /// This cascading effect for individual attributes of the [CupertinoThemeData]
  /// can be overridden using attributes of this [cupertinoOverrideTheme].
  final NoDefaultCupertinoThemeData? cupertinoOverrideTheme;

  /// Arbitrary additions to this theme.
  ///
  /// To define extensions, pass an [Iterable] containing one or more [ThemeExtension]
  /// subclasses to [ThemeData.new] or [copyWith].
  ///
  /// To obtain an extension, use [extension].
  ///
  /// {@tool dartpad}
  /// This sample shows how to create and use a subclass of [ThemeExtension] that
  /// defines two colors.
  ///
  /// ** See code in examples/api/lib/material/theme/theme_extension.1.dart **
  /// {@end-tool}
  ///
  /// See also:
  ///
  /// * [extension], a convenience function for obtaining a specific extension.
  final Map<Object, ThemeExtension<dynamic>> extensions;

  /// Used to obtain a particular [ThemeExtension] from [extensions].
  ///
  /// Obtain with `Theme.of(context).extension<MyThemeExtension>()`.
  ///
  /// See [extensions] for an interactive example.
  T? extension<T>() => extensions[T] as T?;

  /// A map which contains the adaptations for the theme. The entry's key is the
  /// type of the adaptation; the value is the adaptation itself.
  ///
  /// To obtain an adaptation, use [getAdaptation].
  final Map<Type, Adaptation<Object>> adaptationMap;

  /// The default [InputDecoration] values for [InputDecorator], [TextField],
  /// and [TextFormField] are based on this theme.
  ///
  /// See [InputDecoration.applyDefaults].
  final InputDecorationTheme inputDecorationTheme;

  /// Configures the hit test size of certain Material widgets.
  ///
  /// Defaults to a [platform]-appropriate size: [MaterialTapTargetSize.padded]
  /// on mobile platforms, [MaterialTapTargetSize.shrinkWrap] on desktop
  /// platforms.
  final MaterialTapTargetSize materialTapTargetSize;

  /// Default [MaterialPageRoute] transitions per [TargetPlatform].
  ///
  /// [MaterialPageRoute.buildTransitions] delegates to a [platform] specific
  /// [PageTransitionsBuilder]. If a matching builder is not found, a builder
  /// whose platform is null is used.
  final PageTransitionsTheme pageTransitionsTheme;

  /// The platform the material widgets should adapt to target.
  ///
  /// Defaults to the current platform, as exposed by [defaultTargetPlatform].
  /// This should be used in order to style UI elements according to platform
  /// conventions.
  ///
  /// Widgets from the material library should use this getter (via [Theme.of])
  /// to determine the current platform for the purpose of emulating the
  /// platform behavior (e.g. scrolling or haptic effects). Widgets and render
  /// objects at lower layers that try to emulate the underlying platform
  /// can depend on [defaultTargetPlatform] directly, or may require
  /// that the target platform be provided as an argument. The
  /// [dart:io.Platform] object should only be used directly when it's critical
  /// to actually know the current platform, without any overrides possible (for
  /// example, when a system API is about to be called).
  ///
  /// In a test environment, the platform returned is [TargetPlatform.android]
  /// regardless of the host platform. (Android was chosen because the tests
  /// were originally written assuming Android-like behavior, and we added
  /// platform adaptations for other platforms later). Tests can check behavior
  /// for other platforms by setting the [platform] of the [Theme] explicitly to
  /// another [TargetPlatform] value, or by setting
  /// [debugDefaultTargetPlatformOverride].
  ///
  /// Determines the defaults for [typography] and [materialTapTargetSize].
  final TargetPlatform platform;

  /// A theme for customizing the colors, thickness, and shape of [Scrollbar]s.
  final ScrollbarThemeData scrollbarTheme;

  /// Defines the appearance of ink splashes produces by [InkWell]
  /// and [InkResponse].
  ///
  /// See also:
  ///
  ///  * [InkSplash.splashFactory], which defines the default splash.
  ///  * [InkRipple.splashFactory], which defines a splash that spreads out
  ///    more aggressively than the default.
  ///  * [InkSparkle.splashFactory], which defines a more aggressive and organic
  ///    splash with sparkle effects.
  final InteractiveInkFeatureFactory splashFactory;

  /// A temporary flag that can be used to opt-out of Material 3 features.
  ///
  /// This flag is _true_ by default. If false, then components will
  /// continue to use the colors, typography and other features of
  /// Material 2.
  ///
  /// In the long run this flag will be deprecated and eventually
  /// only Material 3 will be supported. We recommend that applications
  /// migrate to Material 3 as soon as that's practical. Until that migration
  /// is complete, this flag can be set to false.
  ///
  /// ## Defaults
  ///
  /// If a [ThemeData] is _constructed_ with [useMaterial3] set to true, then
  /// some properties will get updated defaults. However, the
  /// [ThemeData.copyWith] method with [useMaterial3] set to true will _not_
  /// change any of these properties in the resulting [ThemeData].
  ///
  /// <style>table,td,th { border-collapse: collapse; padding: 0.45em; } td { border: 1px solid }</style>
  ///
  /// | Property        | Material 3 default             | Material 2 default             |
  /// | :-------------- | :----------------------------- | :----------------------------- |
  /// | [colorScheme]   | M3 baseline light color scheme | M2 baseline light color scheme |
  /// | [typography]    | [Typography.material2021]      | [Typography.material2014]      |
  /// | [splashFactory] | [InkSparkle]* or [InkRipple]   | [InkSplash]                    |
  ///
  /// \* if the target platform is Android and the app is not
  /// running on the web, otherwise it will fallback to [InkRipple].
  ///
  /// If [brightness] is [Brightness.dark] then the default color scheme will
  /// be either the M3 baseline dark color scheme or the M2 baseline dark color
  /// scheme depending on [useMaterial3].
  ///
  /// ## Affected widgets
  ///
  /// This flag affects styles and components.
  ///
  /// ### Styles
  ///   * Color: [ColorScheme], [Material] (see table above)
  ///   * Shape: (see components below)
  ///   * Typography: [Typography] (see table above)
  ///
  /// ### Components
  ///   * Badges: [Badge]
  ///   * Bottom app bar: [BottomAppBar]
  ///   * Bottom sheets: [BottomSheet]
  ///   * Buttons
  ///     - Common buttons: [ElevatedButton], [FilledButton], [FilledButton.tonal], [OutlinedButton], [TextButton]
  ///     - FAB: [FloatingActionButton], [FloatingActionButton.extended]
  ///     - Icon buttons: [IconButton], [IconButton.filled] (*new*), [IconButton.filledTonal], [IconButton.outlined]
  ///     - Segmented buttons: [SegmentedButton] (replacing [ToggleButtons])
  ///   * Cards: [Card]
  ///   * Checkbox: [Checkbox], [CheckboxListTile]
  ///   * Chips:
  ///     - [ActionChip] (used for Assist and Suggestion chips),
  ///     - [FilterChip], [ChoiceChip] (used for single selection filter chips),
  ///     - [InputChip]
  ///   * Date pickers: [showDatePicker], [showDateRangePicker], [DatePickerDialog], [DateRangePickerDialog], [InputDatePickerFormField]
  ///   * Dialogs: [AlertDialog], [Dialog.fullscreen]
  ///   * Divider: [Divider], [VerticalDivider]
  ///   * Lists: [ListTile]
  ///   * Menus: [MenuAnchor], [DropdownMenu], [MenuBar]
  ///   * Navigation bar: [NavigationBar] (replacing [BottomNavigationBar])
  ///   * Navigation drawer: [NavigationDrawer] (replacing [Drawer])
  ///   * Navigation rail: [NavigationRail]
  ///   * Progress indicators: [CircularProgressIndicator], [LinearProgressIndicator]
  ///   * Radio button: [Radio], [RadioListTile]
  ///   * Search: [SearchBar], [SearchAnchor],
  ///   * Snack bar: [SnackBar]
  ///   * Slider: [Slider], [RangeSlider]
  ///   * Switch: [Switch], [SwitchListTile]
  ///   * Tabs: [TabBar], [TabBar.secondary]
  ///   * TextFields: [TextField] together with its [InputDecoration]
  ///   * Time pickers: [showTimePicker], [TimePickerDialog]
  ///   * Top app bar: [AppBar], [SliverAppBar], [SliverAppBar.medium], [SliverAppBar.large]
  ///
  /// In addition, this flag enables features introduced in Android 12.
  ///   * Stretch overscroll: [MaterialScrollBehavior]
  ///   * Ripple: `splashFactory` (see table above)
  ///
  /// See also:
  ///
  ///   * [Material 3 specification](https://m3.material.io/).
  final bool useMaterial3;

  /// The density value for specifying the compactness of various UI components.
  ///
  /// {@template flutter.material.themedata.visualDensity}
  /// Density, in the context of a UI, is the vertical and horizontal
  /// "compactness" of the elements in the UI. It is unitless, since it means
  /// different things to different UI elements. For buttons, it affects the
  /// spacing around the centered label of the button. For lists, it affects the
  /// distance between baselines of entries in the list.
  ///
  /// Typically, density values are integral, but any value in range may be
  /// used. The range includes values from [VisualDensity.minimumDensity] (which
  /// is -4), to [VisualDensity.maximumDensity] (which is 4), inclusive, where
  /// negative values indicate a denser, more compact, UI, and positive values
  /// indicate a less dense, more expanded, UI. If a component doesn't support
  /// the value given, it will clamp to the nearest supported value.
  ///
  /// The default for visual densities is zero for both vertical and horizontal
  /// densities, which corresponds to the default visual density of components
  /// in the Material Design specification.
  ///
  /// As a rule of thumb, a change of 1 or -1 in density corresponds to 4
  /// logical pixels. However, this is not a strict relationship since
  /// components interpret the density values appropriately for their needs.
  ///
  /// A larger value translates to a spacing increase (less dense), and a
  /// smaller value translates to a spacing decrease (more dense).
  ///
  /// In Material Design 3, the [visualDensity] does not override the value of
  /// [IconButton.visualDensity] which defaults to [VisualDensity.standard]
  /// for all platforms. To override the default value of [IconButton.visualDensity],
  /// use [ThemeData.iconButtonTheme] instead.
  /// {@endtemplate}
  final VisualDensity visualDensity;

  // COLOR

  /// The default color of [MaterialType.canvas] [Material].
  final Color canvasColor;

  /// The color of [Material] when it is used as a [Card].
  final Color cardColor;

  /// {@macro flutter.material.color_scheme.ColorScheme}
  ///
  /// This property was added much later than the theme's set of highly specific
  /// colors, like [cardColor], [canvasColor] etc. New components can be defined
  /// exclusively in terms of [colorScheme]. Existing components will gradually
  /// migrate to it, to the extent that is possible without significant
  /// backwards compatibility breaks.
  final ColorScheme colorScheme;

  /// The color used for widgets that are inoperative, regardless of
  /// their state. For example, a disabled checkbox (which may be
  /// checked or unchecked).
  final Color disabledColor;

  /// The color of [Divider]s and [PopupMenuDivider]s, also used
  /// between [ListTile]s, between rows in [DataTable]s, and so forth.
  ///
  /// To create an appropriate [BorderSide] that uses this color, consider
  /// [Divider.createBorderSide].
  final Color dividerColor;

  /// The focus color used indicate that a component has the input focus.
  final Color focusColor;

  /// The highlight color used during ink splash animations or to
  /// indicate an item in a menu is selected.
  final Color highlightColor;

  /// The color to use for hint text or placeholder text, e.g. in
  /// [TextField] fields.
  final Color hintColor;

  /// The hover color used to indicate when a pointer is hovering over a
  /// component.
  final Color hoverColor;

  /// The color of the selected tab indicator in a tab bar.
  final Color indicatorColor;

  /// The background color for major parts of the app (toolbars, tab bars, etc)
  ///
  /// The theme's [colorScheme] property contains [ColorScheme.primary], as
  /// well as a color that contrasts well with the primary color called
  /// [ColorScheme.onPrimary]. It might be simpler to just configure an app's
  /// visuals in terms of the theme's [colorScheme].
  final Color primaryColor;

  /// A darker version of the [primaryColor].
  final Color primaryColorDark;

  /// A lighter version of the [primaryColor].
  final Color primaryColorLight;

  /// The default color of the [Material] that underlies the [Scaffold]. The
  /// background color for a typical material app or a page within the app.
  final Color scaffoldBackgroundColor;

  /// The color of the header of a [PaginatedDataTable] when there are selected rows.
  // According to the spec for data tables:
  // https://material.io/archive/guidelines/components/data-tables.html#data-tables-tables-within-cards
  // ...this should be the "50-value of secondary app color".
  final Color secondaryHeaderColor;

  /// The color that the [Material] widget uses to draw elevation shadows.
  ///
  /// Defaults to fully opaque black.
  ///
  /// Shadows can be difficult to see in a dark theme, so the elevation of a
  /// surface should be rendered with an "overlay" in addition to the shadow.
  /// As the elevation of the component increases, the overlay increases in
  /// opacity. The [applyElevationOverlayColor] property turns the elevation
  /// overlay on or off for dark themes.
  final Color shadowColor;

  /// The color of ink splashes.
  ///
  /// See also:
  ///  * [splashFactory], which defines the appearance of the splash.
  final Color splashColor;

  /// The color used for widgets in their inactive (but enabled)
  /// state. For example, an unchecked checkbox. See also [disabledColor].
  final Color unselectedWidgetColor;

  // TYPOGRAPHY & ICONOGRAPHY

  /// An icon theme that contrasts with the card and canvas colors.
  final IconThemeData iconTheme;

  /// An icon theme that contrasts with the primary color.
  final IconThemeData primaryIconTheme;

  /// A text theme that contrasts with the primary color.
  final TextTheme primaryTextTheme;

  /// Text with a color that contrasts with the card and canvas colors.
  final TextTheme textTheme;

  /// The color and geometry [TextTheme] values used to configure [textTheme].
  ///
  /// Defaults to a [platform]-appropriate typography.
  final Typography typography;

  // COMPONENT THEMES

  /// A theme for customizing icons of [BackButtonIcon], [CloseButtonIcon],
  /// [DrawerButtonIcon], or [EndDrawerButtonIcon].
  final ActionIconThemeData? actionIconTheme;

  /// A theme for customizing the color, elevation, brightness, iconTheme and
  /// textTheme of [AppBar]s.
  final AppBarTheme appBarTheme;

  /// A theme for customizing the color of [Badge]s.
  final BadgeThemeData badgeTheme;

  /// A theme for customizing the color and text style of a [MaterialBanner].
  final MaterialBannerThemeData bannerTheme;

  /// A theme for customizing the shape, elevation, and color of a [BottomAppBar].
  final BottomAppBarTheme bottomAppBarTheme;

  /// A theme for customizing the appearance and layout of [BottomNavigationBar]
  /// widgets.
  final BottomNavigationBarThemeData bottomNavigationBarTheme;

  /// A theme for customizing the color, elevation, and shape of a bottom sheet.
  final BottomSheetThemeData bottomSheetTheme;

  /// Defines the default configuration of button widgets, like [DropdownButton]
  /// and [ButtonBar].
  final ButtonThemeData buttonTheme;

  /// The colors and styles used to render [Card].
  ///
  /// This is the value returned from [CardTheme.of].
  final CardThemeData cardTheme;

  /// A theme for customizing the appearance and layout of [Checkbox] widgets.
  final CheckboxThemeData checkboxTheme;

  /// The colors and styles used to render [Chip]s.
  ///
  /// This is the value returned from [ChipTheme.of].
  final ChipThemeData chipTheme;

  /// A theme for customizing the appearance and layout of [DataTable]
  /// widgets.
  final DataTableThemeData dataTableTheme;

  /// A theme for customizing the appearance and layout of [DatePickerDialog]
  /// widgets.
  final DatePickerThemeData datePickerTheme;

  /// A theme for customizing the shape of a dialog.
  final DialogThemeData dialogTheme;

  /// A theme for customizing the color, thickness, and indents of [Divider]s,
  /// [VerticalDivider]s, etc.
  final DividerThemeData dividerTheme;

  /// A theme for customizing the appearance and layout of [Drawer] widgets.
  final DrawerThemeData drawerTheme;

  /// A theme for customizing the appearance and layout of [DropdownMenu] widgets.
  final DropdownMenuThemeData dropdownMenuTheme;

  /// A theme for customizing the appearance and internal layout of
  /// [ElevatedButton]s.
  final ElevatedButtonThemeData elevatedButtonTheme;

  /// A theme for customizing the visual properties of [ExpansionTile]s.
  final ExpansionTileThemeData expansionTileTheme;

  /// A theme for customizing the appearance and internal layout of
  /// [FilledButton]s.
  final FilledButtonThemeData filledButtonTheme;

  /// A theme for customizing the shape, elevation, and color of a
  /// [FloatingActionButton].
  final FloatingActionButtonThemeData floatingActionButtonTheme;

  /// A theme for customizing the appearance and internal layout of
  /// [IconButton]s.
  final IconButtonThemeData iconButtonTheme;

  /// A theme for customizing the appearance of [ListTile] widgets.
  final ListTileThemeData listTileTheme;

  /// A theme for customizing the color, shape, elevation, and other [MenuStyle]
  /// aspects of the menu bar created by the [MenuBar] widget.
  final MenuBarThemeData menuBarTheme;

  /// A theme for customizing the color, shape, elevation, and text style of
  /// cascading menu buttons created by [SubmenuButton] or [MenuItemButton].
  final MenuButtonThemeData menuButtonTheme;

  /// A theme for customizing the color, shape, elevation, and other [MenuStyle]
  /// attributes of menus created by the [SubmenuButton] widget.
  final MenuThemeData menuTheme;

  /// A theme for customizing the background color, text style, and icon themes
  /// of a [NavigationBar].
  final NavigationBarThemeData navigationBarTheme;

  /// A theme for customizing the background color, text style, and icon themes
  /// of a [NavigationDrawer].
  final NavigationDrawerThemeData navigationDrawerTheme;

  /// A theme for customizing the background color, elevation, text style, and
  /// icon themes of a [NavigationRail].
  final NavigationRailThemeData navigationRailTheme;

  /// A theme for customizing the appearance and internal layout of
  /// [OutlinedButton]s.
  final OutlinedButtonThemeData outlinedButtonTheme;

  /// A theme for customizing the color, shape, elevation, and text style of
  /// popup menus.
  final PopupMenuThemeData popupMenuTheme;

  /// A theme for customizing the appearance and layout of [ProgressIndicator] widgets.
  final ProgressIndicatorThemeData progressIndicatorTheme;

  /// A theme for customizing the appearance and layout of [Radio] widgets.
  final RadioThemeData radioTheme;

  /// A theme for customizing the appearance and layout of [SearchBar] widgets.
  final SearchBarThemeData searchBarTheme;

  /// A theme for customizing the appearance and layout of search views created by [SearchAnchor] widgets.
  final SearchViewThemeData searchViewTheme;

  /// A theme for customizing the appearance and layout of [SegmentedButton] widgets.
  final SegmentedButtonThemeData segmentedButtonTheme;

  /// The colors and shapes used to render [Slider].
  ///
  /// This is the value returned from [SliderTheme.of].
  final SliderThemeData sliderTheme;

  /// A theme for customizing colors, shape, elevation, and behavior of a [SnackBar].
  final SnackBarThemeData snackBarTheme;

  /// A theme for customizing the appearance and layout of [Switch] widgets.
  final SwitchThemeData switchTheme;

  /// A theme for customizing the size, shape, and color of the tab bar indicator.
  final TabBarThemeData tabBarTheme;

  /// A theme for customizing the appearance and internal layout of
  /// [TextButton]s.
  final TextButtonThemeData textButtonTheme;

  /// A theme for customizing the appearance and layout of [TextField] widgets.
  final TextSelectionThemeData textSelectionTheme;

  /// A theme for customizing the appearance and layout of time picker widgets.
  final TimePickerThemeData timePickerTheme;

  /// Defines the default configuration of [ToggleButtons] widgets.
  final ToggleButtonsThemeData toggleButtonsTheme;

  /// A theme for customizing the visual properties of [Tooltip]s.
  ///
  /// This is the value returned from [TooltipTheme.of].
  final TooltipThemeData tooltipTheme;

  /// A theme for customizing the appearance and layout of [ButtonBar] widgets.
  @Deprecated(
    'Use OverflowBar instead. '
    'This feature was deprecated after v3.21.0-10.0.pre.',
  )
  ButtonBarThemeData get buttonBarTheme => _buttonBarTheme!;
  final ButtonBarThemeData? _buttonBarTheme;

  /// The background color of [Dialog] elements.
  @Deprecated(
    'Use DialogThemeData.backgroundColor instead. '
    'This feature was deprecated after v3.27.0-0.1.pre.',
  )
  final Color dialogBackgroundColor;

  /// Creates a copy of this theme but with the given fields replaced with the new values.
  ///
  /// The [brightness] value is applied to the [colorScheme].
  ThemeData copyWith({
    // For the sanity of the reader, make sure these properties are in the same
    // order in every place that they are separated by section comments (e.g.
    // GENERAL CONFIGURATION). Each section except for deprecations should be
    // alphabetical by symbol name.

    // GENERAL CONFIGURATION
    Iterable<Adaptation<Object>>? adaptations,
    bool? applyElevationOverlayColor,
    NoDefaultCupertinoThemeData? cupertinoOverrideTheme,
    Iterable<ThemeExtension<dynamic>>? extensions,
    InputDecorationTheme? inputDecorationTheme,
    MaterialTapTargetSize? materialTapTargetSize,
    PageTransitionsTheme? pageTransitionsTheme,
    TargetPlatform? platform,
    ScrollbarThemeData? scrollbarTheme,
    InteractiveInkFeatureFactory? splashFactory,
    VisualDensity? visualDensity,
    // COLOR
    ColorScheme? colorScheme,
    Brightness? brightness,
    // [colorScheme] is the preferred way to configure colors. The [Color] properties
    // listed below (as well as primarySwatch) will gradually be phased out, see
    // https://github.com/flutter/flutter/issues/91772.
    Color? canvasColor,
    Color? cardColor,
    Color? disabledColor,
    Color? dividerColor,
    Color? focusColor,
    Color? highlightColor,
    Color? hintColor,
    Color? hoverColor,
    Color? indicatorColor,
    Color? primaryColor,
    Color? primaryColorDark,
    Color? primaryColorLight,
    Color? scaffoldBackgroundColor,
    Color? secondaryHeaderColor,
    Color? shadowColor,
    Color? splashColor,
    Color? unselectedWidgetColor,
    // TYPOGRAPHY & ICONOGRAPHY
    IconThemeData? iconTheme,
    IconThemeData? primaryIconTheme,
    TextTheme? primaryTextTheme,
    TextTheme? textTheme,
    Typography? typography,
    // COMPONENT THEMES
    ActionIconThemeData? actionIconTheme,
    AppBarTheme? appBarTheme,
    BadgeThemeData? badgeTheme,
    MaterialBannerThemeData? bannerTheme,
    BottomAppBarTheme? bottomAppBarTheme,
    BottomNavigationBarThemeData? bottomNavigationBarTheme,
    BottomSheetThemeData? bottomSheetTheme,
    ButtonThemeData? buttonTheme,
    Object? cardTheme,
    CheckboxThemeData? checkboxTheme,
    ChipThemeData? chipTheme,
    DataTableThemeData? dataTableTheme,
    DatePickerThemeData? datePickerTheme,
    // TODO(QuncCccccc): Change the parameter type to DialogThemeData
    Object? dialogTheme,
    DividerThemeData? dividerTheme,
    DrawerThemeData? drawerTheme,
    DropdownMenuThemeData? dropdownMenuTheme,
    ElevatedButtonThemeData? elevatedButtonTheme,
    ExpansionTileThemeData? expansionTileTheme,
    FilledButtonThemeData? filledButtonTheme,
    FloatingActionButtonThemeData? floatingActionButtonTheme,
    IconButtonThemeData? iconButtonTheme,
    ListTileThemeData? listTileTheme,
    MenuBarThemeData? menuBarTheme,
    MenuButtonThemeData? menuButtonTheme,
    MenuThemeData? menuTheme,
    NavigationBarThemeData? navigationBarTheme,
    NavigationDrawerThemeData? navigationDrawerTheme,
    NavigationRailThemeData? navigationRailTheme,
    OutlinedButtonThemeData? outlinedButtonTheme,
    PopupMenuThemeData? popupMenuTheme,
    ProgressIndicatorThemeData? progressIndicatorTheme,
    RadioThemeData? radioTheme,
    SearchBarThemeData? searchBarTheme,
    SearchViewThemeData? searchViewTheme,
    SegmentedButtonThemeData? segmentedButtonTheme,
    SliderThemeData? sliderTheme,
    SnackBarThemeData? snackBarTheme,
    SwitchThemeData? switchTheme,
    // TODO(QuncCccccc): Change the parameter type to TabBarThemeData
    Object? tabBarTheme,
    TextButtonThemeData? textButtonTheme,
    TextSelectionThemeData? textSelectionTheme,
    TimePickerThemeData? timePickerTheme,
    ToggleButtonsThemeData? toggleButtonsTheme,
    TooltipThemeData? tooltipTheme,
    // DEPRECATED (newest deprecations at the bottom)
    @Deprecated(
      'Use a ThemeData constructor (.from, .light, or .dark) instead. '
      'These constructors all have a useMaterial3 argument, '
      'and they set appropriate default values based on its value. '
      'See the useMaterial3 API documentation for full details. '
      'This feature was deprecated after v3.13.0-0.2.pre.',
    )
    bool? useMaterial3,
    @Deprecated(
      'Use OverflowBar instead. '
      'This feature was deprecated after v3.21.0-10.0.pre.',
    )
    ButtonBarThemeData? buttonBarTheme,
    @Deprecated(
      'Use DialogThemeData.backgroundColor instead. '
      'This feature was deprecated after v3.27.0-0.1.pre.',
    )
    Color? dialogBackgroundColor,
  }) {
    cupertinoOverrideTheme = cupertinoOverrideTheme?.noDefault();

    // TODO(QuncCccccc): Clean it up once the type of `cardTheme` is changed to `CardThemeData`
    if (cardTheme != null) {
      if (cardTheme is CardTheme) {
        cardTheme = cardTheme.data;
      } else if (cardTheme is! CardThemeData) {
        throw ArgumentError('cardTheme must be either a CardThemeData or a CardTheme');
      }
    }

    // TODO(QuncCccccc): Clean this up once the type of `dialogTheme` is changed to `DialogThemeData`
    if (dialogTheme != null) {
      if (dialogTheme is DialogTheme) {
        dialogTheme = dialogTheme.data;
      } else if (dialogTheme is! DialogThemeData) {
        throw ArgumentError('dialogTheme must be either a DialogThemeData or a DialogTheme');
      }
    }

    // TODO(QuncCccccc): Clean this up once the type of `tabBarTheme` is changed to `TabBarThemeData`
    if (tabBarTheme != null) {
      if (tabBarTheme is TabBarTheme) {
        tabBarTheme = tabBarTheme.data;
      } else if (tabBarTheme is! TabBarThemeData) {
        throw ArgumentError('tabBarTheme must be either a TabBarThemeData or a TabBarTheme');
      }
    }
    return ThemeData.raw(
      // For the sanity of the reader, make sure these properties are in the same
      // order in every place that they are separated by section comments (e.g.
      // GENERAL CONFIGURATION). Each section except for deprecations should be
      // alphabetical by symbol name.

      // GENERAL CONFIGURATION
      adaptationMap: adaptations != null ? _createAdaptationMap(adaptations) : adaptationMap,
      applyElevationOverlayColor: applyElevationOverlayColor ?? this.applyElevationOverlayColor,
      cupertinoOverrideTheme: cupertinoOverrideTheme ?? this.cupertinoOverrideTheme,
      extensions: (extensions != null) ? _themeExtensionIterableToMap(extensions) : this.extensions,
      inputDecorationTheme: inputDecorationTheme ?? this.inputDecorationTheme,
      materialTapTargetSize: materialTapTargetSize ?? this.materialTapTargetSize,
      pageTransitionsTheme: pageTransitionsTheme ?? this.pageTransitionsTheme,
      platform: platform ?? this.platform,
      scrollbarTheme: scrollbarTheme ?? this.scrollbarTheme,
      splashFactory: splashFactory ?? this.splashFactory,
      // When deprecated useMaterial3 removed, maintain `this.useMaterial3` here
      // for == evaluation.
      useMaterial3: useMaterial3 ?? this.useMaterial3,
      visualDensity: visualDensity ?? this.visualDensity,
      // COLOR
      canvasColor: canvasColor ?? this.canvasColor,
      cardColor: cardColor ?? this.cardColor,
      colorScheme: (colorScheme ?? this.colorScheme).copyWith(brightness: brightness),
      disabledColor: disabledColor ?? this.disabledColor,
      dividerColor: dividerColor ?? this.dividerColor,
      focusColor: focusColor ?? this.focusColor,
      highlightColor: highlightColor ?? this.highlightColor,
      hintColor: hintColor ?? this.hintColor,
      hoverColor: hoverColor ?? this.hoverColor,
      indicatorColor: indicatorColor ?? this.indicatorColor,
      primaryColor: primaryColor ?? this.primaryColor,
      primaryColorDark: primaryColorDark ?? this.primaryColorDark,
      primaryColorLight: primaryColorLight ?? this.primaryColorLight,
      scaffoldBackgroundColor: scaffoldBackgroundColor ?? this.scaffoldBackgroundColor,
      secondaryHeaderColor: secondaryHeaderColor ?? this.secondaryHeaderColor,
      shadowColor: shadowColor ?? this.shadowColor,
      splashColor: splashColor ?? this.splashColor,
      unselectedWidgetColor: unselectedWidgetColor ?? this.unselectedWidgetColor,
      // TYPOGRAPHY & ICONOGRAPHY
      iconTheme: iconTheme ?? this.iconTheme,
      primaryIconTheme: primaryIconTheme ?? this.primaryIconTheme,
      primaryTextTheme: primaryTextTheme ?? this.primaryTextTheme,
      textTheme: textTheme ?? this.textTheme,
      typography: typography ?? this.typography,
      // COMPONENT THEMES
      actionIconTheme: actionIconTheme ?? this.actionIconTheme,
      appBarTheme: appBarTheme ?? this.appBarTheme,
      badgeTheme: badgeTheme ?? this.badgeTheme,
      bannerTheme: bannerTheme ?? this.bannerTheme,
      bottomAppBarTheme: bottomAppBarTheme ?? this.bottomAppBarTheme,
      bottomNavigationBarTheme: bottomNavigationBarTheme ?? this.bottomNavigationBarTheme,
      bottomSheetTheme: bottomSheetTheme ?? this.bottomSheetTheme,
      buttonTheme: buttonTheme ?? this.buttonTheme,
      cardTheme: cardTheme as CardThemeData? ?? this.cardTheme,
      checkboxTheme: checkboxTheme ?? this.checkboxTheme,
      chipTheme: chipTheme ?? this.chipTheme,
      dataTableTheme: dataTableTheme ?? this.dataTableTheme,
      datePickerTheme: datePickerTheme ?? this.datePickerTheme,
      dialogTheme: dialogTheme as DialogThemeData? ?? this.dialogTheme,
      dividerTheme: dividerTheme ?? this.dividerTheme,
      drawerTheme: drawerTheme ?? this.drawerTheme,
      dropdownMenuTheme: dropdownMenuTheme ?? this.dropdownMenuTheme,
      elevatedButtonTheme: elevatedButtonTheme ?? this.elevatedButtonTheme,
      expansionTileTheme: expansionTileTheme ?? this.expansionTileTheme,
      filledButtonTheme: filledButtonTheme ?? this.filledButtonTheme,
      floatingActionButtonTheme: floatingActionButtonTheme ?? this.floatingActionButtonTheme,
      iconButtonTheme: iconButtonTheme ?? this.iconButtonTheme,
      listTileTheme: listTileTheme ?? this.listTileTheme,
      menuBarTheme: menuBarTheme ?? this.menuBarTheme,
      menuButtonTheme: menuButtonTheme ?? this.menuButtonTheme,
      menuTheme: menuTheme ?? this.menuTheme,
      navigationBarTheme: navigationBarTheme ?? this.navigationBarTheme,
      navigationDrawerTheme: navigationDrawerTheme ?? this.navigationDrawerTheme,
      navigationRailTheme: navigationRailTheme ?? this.navigationRailTheme,
      outlinedButtonTheme: outlinedButtonTheme ?? this.outlinedButtonTheme,
      popupMenuTheme: popupMenuTheme ?? this.popupMenuTheme,
      progressIndicatorTheme: progressIndicatorTheme ?? this.progressIndicatorTheme,
      radioTheme: radioTheme ?? this.radioTheme,
      searchBarTheme: searchBarTheme ?? this.searchBarTheme,
      searchViewTheme: searchViewTheme ?? this.searchViewTheme,
      segmentedButtonTheme: segmentedButtonTheme ?? this.segmentedButtonTheme,
      sliderTheme: sliderTheme ?? this.sliderTheme,
      snackBarTheme: snackBarTheme ?? this.snackBarTheme,
      switchTheme: switchTheme ?? this.switchTheme,
      tabBarTheme: tabBarTheme as TabBarThemeData? ?? this.tabBarTheme,
      textButtonTheme: textButtonTheme ?? this.textButtonTheme,
      textSelectionTheme: textSelectionTheme ?? this.textSelectionTheme,
      timePickerTheme: timePickerTheme ?? this.timePickerTheme,
      toggleButtonsTheme: toggleButtonsTheme ?? this.toggleButtonsTheme,
      tooltipTheme: tooltipTheme ?? this.tooltipTheme,
      // DEPRECATED (newest deprecations at the bottom)
      buttonBarTheme: buttonBarTheme ?? _buttonBarTheme,
      dialogBackgroundColor: dialogBackgroundColor ?? this.dialogBackgroundColor,
    );
  }

  // The number 5 was chosen without any real science or research behind it. It
  // just seemed like a number that's not too big (we should be able to fit 5
  // copies of ThemeData in memory comfortably) and not too small (most apps
  // shouldn't have more than 5 theme/localization pairs).
  static const int _localizedThemeDataCacheSize = 5;

  /// Caches localized themes to speed up the [localize] method.
  static final _FifoCache<_IdentityThemeDataCacheKey, ThemeData> _localizedThemeDataCache =
      _FifoCache<_IdentityThemeDataCacheKey, ThemeData>(_localizedThemeDataCacheSize);

  /// Returns a new theme built by merging the text geometry provided by the
  /// [localTextGeometry] theme with the [baseTheme].
  ///
  /// For those text styles in the [baseTheme] whose [TextStyle.inherit] is set
  /// to true, the returned theme's text styles inherit the geometric properties
  /// of [localTextGeometry]. The resulting text styles' [TextStyle.inherit] is
  /// set to those provided by [localTextGeometry].
  static ThemeData localize(ThemeData baseTheme, TextTheme localTextGeometry) {
    // WARNING: this method memoizes the result in a cache based on the
    // previously seen baseTheme and localTextGeometry. Memoization is safe
    // because all inputs and outputs of this function are deeply immutable, and
    // the computations are referentially transparent. It only short-circuits
    // the computation if the new inputs are identical() to the previous ones.
    // It does not use the == operator, which performs a costly deep comparison.
    //
    // When changing this method, make sure the memoization logic is correct.
    // Remember:
    //
    // There are only two hard things in Computer Science: cache invalidation
    // and naming things. -- Phil Karlton

    return _localizedThemeDataCache.putIfAbsent(
      _IdentityThemeDataCacheKey(baseTheme, localTextGeometry),
      () {
        return baseTheme.copyWith(
          primaryTextTheme: localTextGeometry.merge(baseTheme.primaryTextTheme),
          textTheme: localTextGeometry.merge(baseTheme.textTheme),
        );
      },
    );
  }

  /// Determines whether the given [Color] is [Brightness.light] or
  /// [Brightness.dark].
  ///
  /// This compares the luminosity of the given color to a threshold value that
  /// matches the Material Design specification.
  static Brightness estimateBrightnessForColor(Color color) {
    final double relativeLuminance = color.computeLuminance();

    // See <https://www.w3.org/TR/WCAG20/#contrast-ratiodef>
    // The spec says to use kThreshold=0.0525, but Material Design appears to bias
    // more towards using light text than WCAG20 recommends. Material Design spec
    // doesn't say what value to use, but 0.15 seemed close to what the Material
    // Design spec shows for its color palette on
    // <https://material.io/go/design-theming#color-color-palette>.
    const double kThreshold = 0.15;
    if ((relativeLuminance + 0.05) * (relativeLuminance + 0.05) > kThreshold) {
      return Brightness.light;
    }
    return Brightness.dark;
  }

  /// Linearly interpolate between two [extensions].
  ///
  /// Includes all theme extensions in [a] and [b].
  ///
  /// {@macro dart.ui.shadow.lerp}
  static Map<Object, ThemeExtension<dynamic>> _lerpThemeExtensions(
    ThemeData a,
    ThemeData b,
    double t,
  ) {
    // Lerp [a].
    final Map<Object, ThemeExtension<dynamic>> newExtensions = a.extensions.map((
      Object id,
      ThemeExtension<dynamic> extensionA,
    ) {
      final ThemeExtension<dynamic>? extensionB = b.extensions[id];
      return MapEntry<Object, ThemeExtension<dynamic>>(id, extensionA.lerp(extensionB, t));
    });
    // Add [b]-only extensions.
    newExtensions.addEntries(
      b.extensions.entries.where(
        (MapEntry<Object, ThemeExtension<dynamic>> entry) => !a.extensions.containsKey(entry.key),
      ),
    );

    return newExtensions;
  }

  /// Convert the [extensionsIterable] passed to [ThemeData.new] or [copyWith]
  /// to the stored [extensions] map, where each entry's key consists of the extension's type.
  static Map<Object, ThemeExtension<dynamic>> _themeExtensionIterableToMap(
    Iterable<ThemeExtension<dynamic>> extensionsIterable,
  ) {
    return Map<Object, ThemeExtension<dynamic>>.unmodifiable(<Object, ThemeExtension<dynamic>>{
      // Strangely, the cast is necessary for tests to run.
      for (final ThemeExtension<dynamic> extension in extensionsIterable)
        extension.type: extension as ThemeExtension<ThemeExtension<dynamic>>,
    });
  }

  /// Linearly interpolate between two themes.
  ///
  /// {@macro dart.ui.shadow.lerp}
  static ThemeData lerp(ThemeData a, ThemeData b, double t) {
    if (identical(a, b)) {
      return a;
    }
    return ThemeData.raw(
      // For the sanity of the reader, make sure these properties are in the same
      // order in every place that they are separated by section comments (e.g.
      // GENERAL CONFIGURATION). Each section except for deprecations should be
      // alphabetical by symbol name.

      // GENERAL CONFIGURATION
      adaptationMap: t < 0.5 ? a.adaptationMap : b.adaptationMap,
      applyElevationOverlayColor:
          t < 0.5 ? a.applyElevationOverlayColor : b.applyElevationOverlayColor,
      cupertinoOverrideTheme: t < 0.5 ? a.cupertinoOverrideTheme : b.cupertinoOverrideTheme,
      extensions: _lerpThemeExtensions(a, b, t),
      inputDecorationTheme: t < 0.5 ? a.inputDecorationTheme : b.inputDecorationTheme,
      materialTapTargetSize: t < 0.5 ? a.materialTapTargetSize : b.materialTapTargetSize,
      pageTransitionsTheme: t < 0.5 ? a.pageTransitionsTheme : b.pageTransitionsTheme,
      platform: t < 0.5 ? a.platform : b.platform,
      scrollbarTheme: ScrollbarThemeData.lerp(a.scrollbarTheme, b.scrollbarTheme, t),
      splashFactory: t < 0.5 ? a.splashFactory : b.splashFactory,
      useMaterial3: t < 0.5 ? a.useMaterial3 : b.useMaterial3,
      visualDensity: VisualDensity.lerp(a.visualDensity, b.visualDensity, t),
      // COLOR
      canvasColor: Color.lerp(a.canvasColor, b.canvasColor, t)!,
      cardColor: Color.lerp(a.cardColor, b.cardColor, t)!,
      colorScheme: ColorScheme.lerp(a.colorScheme, b.colorScheme, t),
      disabledColor: Color.lerp(a.disabledColor, b.disabledColor, t)!,
      dividerColor: Color.lerp(a.dividerColor, b.dividerColor, t)!,
      focusColor: Color.lerp(a.focusColor, b.focusColor, t)!,
      highlightColor: Color.lerp(a.highlightColor, b.highlightColor, t)!,
      hintColor: Color.lerp(a.hintColor, b.hintColor, t)!,
      hoverColor: Color.lerp(a.hoverColor, b.hoverColor, t)!,
      indicatorColor: Color.lerp(a.indicatorColor, b.indicatorColor, t)!,
      primaryColor: Color.lerp(a.primaryColor, b.primaryColor, t)!,
      primaryColorDark: Color.lerp(a.primaryColorDark, b.primaryColorDark, t)!,
      primaryColorLight: Color.lerp(a.primaryColorLight, b.primaryColorLight, t)!,
      scaffoldBackgroundColor: Color.lerp(a.scaffoldBackgroundColor, b.scaffoldBackgroundColor, t)!,
      secondaryHeaderColor: Color.lerp(a.secondaryHeaderColor, b.secondaryHeaderColor, t)!,
      shadowColor: Color.lerp(a.shadowColor, b.shadowColor, t)!,
      splashColor: Color.lerp(a.splashColor, b.splashColor, t)!,
      unselectedWidgetColor: Color.lerp(a.unselectedWidgetColor, b.unselectedWidgetColor, t)!,
      // TYPOGRAPHY & ICONOGRAPHY
      iconTheme: IconThemeData.lerp(a.iconTheme, b.iconTheme, t),
      primaryIconTheme: IconThemeData.lerp(a.primaryIconTheme, b.primaryIconTheme, t),
      primaryTextTheme: TextTheme.lerp(a.primaryTextTheme, b.primaryTextTheme, t),
      textTheme: TextTheme.lerp(a.textTheme, b.textTheme, t),
      typography: Typography.lerp(a.typography, b.typography, t),
      // COMPONENT THEMES
      actionIconTheme: ActionIconThemeData.lerp(a.actionIconTheme, b.actionIconTheme, t),
      appBarTheme: AppBarTheme.lerp(a.appBarTheme, b.appBarTheme, t),
      badgeTheme: BadgeThemeData.lerp(a.badgeTheme, b.badgeTheme, t),
      bannerTheme: MaterialBannerThemeData.lerp(a.bannerTheme, b.bannerTheme, t),
      bottomAppBarTheme: BottomAppBarTheme.lerp(a.bottomAppBarTheme, b.bottomAppBarTheme, t),
      bottomNavigationBarTheme: BottomNavigationBarThemeData.lerp(
        a.bottomNavigationBarTheme,
        b.bottomNavigationBarTheme,
        t,
      ),
      bottomSheetTheme: BottomSheetThemeData.lerp(a.bottomSheetTheme, b.bottomSheetTheme, t)!,
      buttonTheme: t < 0.5 ? a.buttonTheme : b.buttonTheme,
      cardTheme: CardThemeData.lerp(a.cardTheme, b.cardTheme, t),
      checkboxTheme: CheckboxThemeData.lerp(a.checkboxTheme, b.checkboxTheme, t),
      chipTheme: ChipThemeData.lerp(a.chipTheme, b.chipTheme, t)!,
      dataTableTheme: DataTableThemeData.lerp(a.dataTableTheme, b.dataTableTheme, t),
      datePickerTheme: DatePickerThemeData.lerp(a.datePickerTheme, b.datePickerTheme, t),
      dialogTheme: DialogThemeData.lerp(a.dialogTheme, b.dialogTheme, t),
      dividerTheme: DividerThemeData.lerp(a.dividerTheme, b.dividerTheme, t),
      drawerTheme: DrawerThemeData.lerp(a.drawerTheme, b.drawerTheme, t)!,
      dropdownMenuTheme: DropdownMenuThemeData.lerp(a.dropdownMenuTheme, b.dropdownMenuTheme, t),
      elevatedButtonTheme:
          ElevatedButtonThemeData.lerp(a.elevatedButtonTheme, b.elevatedButtonTheme, t)!,
      expansionTileTheme:
          ExpansionTileThemeData.lerp(a.expansionTileTheme, b.expansionTileTheme, t)!,
      filledButtonTheme: FilledButtonThemeData.lerp(a.filledButtonTheme, b.filledButtonTheme, t)!,
      floatingActionButtonTheme:
          FloatingActionButtonThemeData.lerp(
            a.floatingActionButtonTheme,
            b.floatingActionButtonTheme,
            t,
          )!,
      iconButtonTheme: IconButtonThemeData.lerp(a.iconButtonTheme, b.iconButtonTheme, t)!,
      listTileTheme: ListTileThemeData.lerp(a.listTileTheme, b.listTileTheme, t)!,
      menuBarTheme: MenuBarThemeData.lerp(a.menuBarTheme, b.menuBarTheme, t)!,
      menuButtonTheme: MenuButtonThemeData.lerp(a.menuButtonTheme, b.menuButtonTheme, t)!,
      menuTheme: MenuThemeData.lerp(a.menuTheme, b.menuTheme, t)!,
      navigationBarTheme:
          NavigationBarThemeData.lerp(a.navigationBarTheme, b.navigationBarTheme, t)!,
      navigationDrawerTheme:
          NavigationDrawerThemeData.lerp(a.navigationDrawerTheme, b.navigationDrawerTheme, t)!,
      navigationRailTheme:
          NavigationRailThemeData.lerp(a.navigationRailTheme, b.navigationRailTheme, t)!,
      outlinedButtonTheme:
          OutlinedButtonThemeData.lerp(a.outlinedButtonTheme, b.outlinedButtonTheme, t)!,
      popupMenuTheme: PopupMenuThemeData.lerp(a.popupMenuTheme, b.popupMenuTheme, t)!,
      progressIndicatorTheme:
          ProgressIndicatorThemeData.lerp(a.progressIndicatorTheme, b.progressIndicatorTheme, t)!,
      radioTheme: RadioThemeData.lerp(a.radioTheme, b.radioTheme, t),
      searchBarTheme: SearchBarThemeData.lerp(a.searchBarTheme, b.searchBarTheme, t)!,
      searchViewTheme: SearchViewThemeData.lerp(a.searchViewTheme, b.searchViewTheme, t)!,
      segmentedButtonTheme: SegmentedButtonThemeData.lerp(
        a.segmentedButtonTheme,
        b.segmentedButtonTheme,
        t,
      ),
      sliderTheme: SliderThemeData.lerp(a.sliderTheme, b.sliderTheme, t),
      snackBarTheme: SnackBarThemeData.lerp(a.snackBarTheme, b.snackBarTheme, t),
      switchTheme: SwitchThemeData.lerp(a.switchTheme, b.switchTheme, t),
      tabBarTheme: TabBarThemeData.lerp(a.tabBarTheme, b.tabBarTheme, t),
      textButtonTheme: TextButtonThemeData.lerp(a.textButtonTheme, b.textButtonTheme, t)!,
      textSelectionTheme:
          TextSelectionThemeData.lerp(a.textSelectionTheme, b.textSelectionTheme, t)!,
      timePickerTheme: TimePickerThemeData.lerp(a.timePickerTheme, b.timePickerTheme, t),
      toggleButtonsTheme:
          ToggleButtonsThemeData.lerp(a.toggleButtonsTheme, b.toggleButtonsTheme, t)!,
      tooltipTheme: TooltipThemeData.lerp(a.tooltipTheme, b.tooltipTheme, t)!,
      // DEPRECATED (newest deprecations at the bottom)
      buttonBarTheme: ButtonBarThemeData.lerp(a.buttonBarTheme, b.buttonBarTheme, t),
      dialogBackgroundColor: Color.lerp(a.dialogBackgroundColor, b.dialogBackgroundColor, t)!,
    );
  }

  @override
  bool operator ==(Object other) {
    if (other.runtimeType != runtimeType) {
      return false;
    }
    return other is ThemeData &&
        // For the sanity of the reader, make sure these properties are in the same
        // order in every place that they are separated by section comments (e.g.
        // GENERAL CONFIGURATION). Each section except for deprecations should be
        // alphabetical by symbol name.
        // GENERAL CONFIGURATION
        mapEquals(other.adaptationMap, adaptationMap) &&
        other.applyElevationOverlayColor == applyElevationOverlayColor &&
        other.cupertinoOverrideTheme == cupertinoOverrideTheme &&
        mapEquals(other.extensions, extensions) &&
        other.inputDecorationTheme == inputDecorationTheme &&
        other.materialTapTargetSize == materialTapTargetSize &&
        other.pageTransitionsTheme == pageTransitionsTheme &&
        other.platform == platform &&
        other.scrollbarTheme == scrollbarTheme &&
        other.splashFactory == splashFactory &&
        other.useMaterial3 == useMaterial3 &&
        other.visualDensity == visualDensity &&
        // COLOR
        other.canvasColor == canvasColor &&
        other.cardColor == cardColor &&
        other.colorScheme == colorScheme &&
        other.disabledColor == disabledColor &&
        other.dividerColor == dividerColor &&
        other.focusColor == focusColor &&
        other.highlightColor == highlightColor &&
        other.hintColor == hintColor &&
        other.hoverColor == hoverColor &&
        other.indicatorColor == indicatorColor &&
        other.primaryColor == primaryColor &&
        other.primaryColorDark == primaryColorDark &&
        other.primaryColorLight == primaryColorLight &&
        other.scaffoldBackgroundColor == scaffoldBackgroundColor &&
        other.secondaryHeaderColor == secondaryHeaderColor &&
        other.shadowColor == shadowColor &&
        other.splashColor == splashColor &&
        other.unselectedWidgetColor == unselectedWidgetColor &&
        // TYPOGRAPHY & ICONOGRAPHY
        other.iconTheme == iconTheme &&
        other.primaryIconTheme == primaryIconTheme &&
        other.primaryTextTheme == primaryTextTheme &&
        other.textTheme == textTheme &&
        other.typography == typography &&
        // COMPONENT THEMES
        other.actionIconTheme == actionIconTheme &&
        other.appBarTheme == appBarTheme &&
        other.badgeTheme == badgeTheme &&
        other.bannerTheme == bannerTheme &&
        other.bottomAppBarTheme == bottomAppBarTheme &&
        other.bottomNavigationBarTheme == bottomNavigationBarTheme &&
        other.bottomSheetTheme == bottomSheetTheme &&
        other.buttonTheme == buttonTheme &&
        other.cardTheme == cardTheme &&
        other.checkboxTheme == checkboxTheme &&
        other.chipTheme == chipTheme &&
        other.dataTableTheme == dataTableTheme &&
        other.datePickerTheme == datePickerTheme &&
        other.dialogTheme == dialogTheme &&
        other.dividerTheme == dividerTheme &&
        other.drawerTheme == drawerTheme &&
        other.dropdownMenuTheme == dropdownMenuTheme &&
        other.elevatedButtonTheme == elevatedButtonTheme &&
        other.expansionTileTheme == expansionTileTheme &&
        other.filledButtonTheme == filledButtonTheme &&
        other.floatingActionButtonTheme == floatingActionButtonTheme &&
        other.iconButtonTheme == iconButtonTheme &&
        other.listTileTheme == listTileTheme &&
        other.menuBarTheme == menuBarTheme &&
        other.menuButtonTheme == menuButtonTheme &&
        other.menuTheme == menuTheme &&
        other.navigationBarTheme == navigationBarTheme &&
        other.navigationDrawerTheme == navigationDrawerTheme &&
        other.navigationRailTheme == navigationRailTheme &&
        other.outlinedButtonTheme == outlinedButtonTheme &&
        other.popupMenuTheme == popupMenuTheme &&
        other.progressIndicatorTheme == progressIndicatorTheme &&
        other.radioTheme == radioTheme &&
        other.searchBarTheme == searchBarTheme &&
        other.searchViewTheme == searchViewTheme &&
        other.segmentedButtonTheme == segmentedButtonTheme &&
        other.sliderTheme == sliderTheme &&
        other.snackBarTheme == snackBarTheme &&
        other.switchTheme == switchTheme &&
        other.tabBarTheme == tabBarTheme &&
        other.textButtonTheme == textButtonTheme &&
        other.textSelectionTheme == textSelectionTheme &&
        other.timePickerTheme == timePickerTheme &&
        other.toggleButtonsTheme == toggleButtonsTheme &&
        other.tooltipTheme == tooltipTheme &&
        // DEPRECATED (newest deprecations at the bottom)
        other.buttonBarTheme == buttonBarTheme &&
        other.dialogBackgroundColor == dialogBackgroundColor;
  }

  @override
  int get hashCode {
    final List<Object?> values = <Object?>[
      // For the sanity of the reader, make sure these properties are in the same
      // order in every place that they are separated by section comments (e.g.
      // GENERAL CONFIGURATION). Each section except for deprecations should be
      // alphabetical by symbol name.

      // GENERAL CONFIGURATION
      ...adaptationMap.keys,
      ...adaptationMap.values,
      applyElevationOverlayColor,
      cupertinoOverrideTheme,
      ...extensions.keys,
      ...extensions.values,
      inputDecorationTheme,
      materialTapTargetSize,
      pageTransitionsTheme,
      platform,
      scrollbarTheme,
      splashFactory,
      useMaterial3,
      visualDensity,
      // COLOR
      canvasColor,
      cardColor,
      colorScheme,
      disabledColor,
      dividerColor,
      focusColor,
      highlightColor,
      hintColor,
      hoverColor,
      indicatorColor,
      primaryColor,
      primaryColorDark,
      primaryColorLight,
      scaffoldBackgroundColor,
      secondaryHeaderColor,
      shadowColor,
      splashColor,
      unselectedWidgetColor,
      // TYPOGRAPHY & ICONOGRAPHY
      iconTheme,
      primaryIconTheme,
      primaryTextTheme,
      textTheme,
      typography,
      // COMPONENT THEMES
      actionIconTheme,
      appBarTheme,
      badgeTheme,
      bannerTheme,
      bottomAppBarTheme,
      bottomNavigationBarTheme,
      bottomSheetTheme,
      buttonTheme,
      cardTheme,
      checkboxTheme,
      chipTheme,
      dataTableTheme,
      datePickerTheme,
      dialogTheme,
      dividerTheme,
      drawerTheme,
      dropdownMenuTheme,
      elevatedButtonTheme,
      expansionTileTheme,
      filledButtonTheme,
      floatingActionButtonTheme,
      iconButtonTheme,
      listTileTheme,
      menuBarTheme,
      menuButtonTheme,
      menuTheme,
      navigationBarTheme,
      navigationDrawerTheme,
      navigationRailTheme,
      outlinedButtonTheme,
      popupMenuTheme,
      progressIndicatorTheme,
      radioTheme,
      searchBarTheme,
      searchViewTheme,
      segmentedButtonTheme,
      sliderTheme,
      snackBarTheme,
      switchTheme,
      tabBarTheme,
      textButtonTheme,
      textSelectionTheme,
      timePickerTheme,
      toggleButtonsTheme,
      tooltipTheme,
      // DEPRECATED (newest deprecations at the bottom)
      buttonBarTheme,
      dialogBackgroundColor,
    ];
    return Object.hashAll(values);
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    final ThemeData defaultData = ThemeData.fallback();
    // For the sanity of the reader, make sure these properties are in the same
    // order in every place that they are separated by section comments (e.g.
    // GENERAL CONFIGURATION). Each section except for deprecations should be
    // alphabetical by symbol name.

    // GENERAL CONFIGURATION
    properties.add(
      IterableProperty<Adaptation<dynamic>>(
        'adaptations',
        adaptationMap.values,
        defaultValue: defaultData.adaptationMap.values,
        level: DiagnosticLevel.debug,
      ),
    );
    properties.add(
      DiagnosticsProperty<bool>(
        'applyElevationOverlayColor',
        applyElevationOverlayColor,
        level: DiagnosticLevel.debug,
      ),
    );
    properties.add(
      DiagnosticsProperty<NoDefaultCupertinoThemeData>(
        'cupertinoOverrideTheme',
        cupertinoOverrideTheme,
        defaultValue: defaultData.cupertinoOverrideTheme,
        level: DiagnosticLevel.debug,
      ),
    );
    properties.add(
      IterableProperty<ThemeExtension<dynamic>>(
        'extensions',
        extensions.values,
        defaultValue: defaultData.extensions.values,
        level: DiagnosticLevel.debug,
      ),
    );
    properties.add(
      DiagnosticsProperty<InputDecorationTheme>(
        'inputDecorationTheme',
        inputDecorationTheme,
        level: DiagnosticLevel.debug,
      ),
    );
    properties.add(
      DiagnosticsProperty<MaterialTapTargetSize>(
        'materialTapTargetSize',
        materialTapTargetSize,
        level: DiagnosticLevel.debug,
      ),
    );
    properties.add(
      DiagnosticsProperty<PageTransitionsTheme>(
        'pageTransitionsTheme',
        pageTransitionsTheme,
        level: DiagnosticLevel.debug,
      ),
    );
    properties.add(
      EnumProperty<TargetPlatform>(
        'platform',
        platform,
        defaultValue: defaultTargetPlatform,
        level: DiagnosticLevel.debug,
      ),
    );
    properties.add(
      DiagnosticsProperty<ScrollbarThemeData>(
        'scrollbarTheme',
        scrollbarTheme,
        defaultValue: defaultData.scrollbarTheme,
        level: DiagnosticLevel.debug,
      ),
    );
    properties.add(
      DiagnosticsProperty<InteractiveInkFeatureFactory>(
        'splashFactory',
        splashFactory,
        defaultValue: defaultData.splashFactory,
        level: DiagnosticLevel.debug,
      ),
    );
    properties.add(
      DiagnosticsProperty<bool>(
        'useMaterial3',
        useMaterial3,
        defaultValue: defaultData.useMaterial3,
        level: DiagnosticLevel.debug,
      ),
    );
    properties.add(
      DiagnosticsProperty<VisualDensity>(
        'visualDensity',
        visualDensity,
        defaultValue: defaultData.visualDensity,
        level: DiagnosticLevel.debug,
      ),
    );
    // COLORS
    properties.add(
      ColorProperty(
        'canvasColor',
        canvasColor,
        defaultValue: defaultData.canvasColor,
        level: DiagnosticLevel.debug,
      ),
    );
    properties.add(
      ColorProperty(
        'cardColor',
        cardColor,
        defaultValue: defaultData.cardColor,
        level: DiagnosticLevel.debug,
      ),
    );
    properties.add(
      DiagnosticsProperty<ColorScheme>(
        'colorScheme',
        colorScheme,
        defaultValue: defaultData.colorScheme,
        level: DiagnosticLevel.debug,
      ),
    );
    properties.add(
      ColorProperty(
        'disabledColor',
        disabledColor,
        defaultValue: defaultData.disabledColor,
        level: DiagnosticLevel.debug,
      ),
    );
    properties.add(
      ColorProperty(
        'dividerColor',
        dividerColor,
        defaultValue: defaultData.dividerColor,
        level: DiagnosticLevel.debug,
      ),
    );
    properties.add(
      ColorProperty(
        'focusColor',
        focusColor,
        defaultValue: defaultData.focusColor,
        level: DiagnosticLevel.debug,
      ),
    );
    properties.add(
      ColorProperty(
        'highlightColor',
        highlightColor,
        defaultValue: defaultData.highlightColor,
        level: DiagnosticLevel.debug,
      ),
    );
    properties.add(
      ColorProperty(
        'hintColor',
        hintColor,
        defaultValue: defaultData.hintColor,
        level: DiagnosticLevel.debug,
      ),
    );
    properties.add(
      ColorProperty(
        'hoverColor',
        hoverColor,
        defaultValue: defaultData.hoverColor,
        level: DiagnosticLevel.debug,
      ),
    );
    properties.add(
      ColorProperty(
        'indicatorColor',
        indicatorColor,
        defaultValue: defaultData.indicatorColor,
        level: DiagnosticLevel.debug,
      ),
    );
    properties.add(
      ColorProperty(
        'primaryColorDark',
        primaryColorDark,
        defaultValue: defaultData.primaryColorDark,
        level: DiagnosticLevel.debug,
      ),
    );
    properties.add(
      ColorProperty(
        'primaryColorLight',
        primaryColorLight,
        defaultValue: defaultData.primaryColorLight,
        level: DiagnosticLevel.debug,
      ),
    );
    properties.add(
      ColorProperty(
        'primaryColor',
        primaryColor,
        defaultValue: defaultData.primaryColor,
        level: DiagnosticLevel.debug,
      ),
    );
    properties.add(
      ColorProperty(
        'scaffoldBackgroundColor',
        scaffoldBackgroundColor,
        defaultValue: defaultData.scaffoldBackgroundColor,
        level: DiagnosticLevel.debug,
      ),
    );
    properties.add(
      ColorProperty(
        'secondaryHeaderColor',
        secondaryHeaderColor,
        defaultValue: defaultData.secondaryHeaderColor,
        level: DiagnosticLevel.debug,
      ),
    );
    properties.add(
      ColorProperty(
        'shadowColor',
        shadowColor,
        defaultValue: defaultData.shadowColor,
        level: DiagnosticLevel.debug,
      ),
    );
    properties.add(
      ColorProperty(
        'splashColor',
        splashColor,
        defaultValue: defaultData.splashColor,
        level: DiagnosticLevel.debug,
      ),
    );
    properties.add(
      ColorProperty(
        'unselectedWidgetColor',
        unselectedWidgetColor,
        defaultValue: defaultData.unselectedWidgetColor,
        level: DiagnosticLevel.debug,
      ),
    );
    // TYPOGRAPHY & ICONOGRAPHY
    properties.add(
      DiagnosticsProperty<IconThemeData>('iconTheme', iconTheme, level: DiagnosticLevel.debug),
    );
    properties.add(
      DiagnosticsProperty<IconThemeData>(
        'primaryIconTheme',
        primaryIconTheme,
        level: DiagnosticLevel.debug,
      ),
    );
    properties.add(
      DiagnosticsProperty<TextTheme>(
        'primaryTextTheme',
        primaryTextTheme,
        level: DiagnosticLevel.debug,
      ),
    );
    properties.add(
      DiagnosticsProperty<TextTheme>('textTheme', textTheme, level: DiagnosticLevel.debug),
    );
    properties.add(
      DiagnosticsProperty<Typography>(
        'typography',
        typography,
        defaultValue: defaultData.typography,
        level: DiagnosticLevel.debug,
      ),
    );
    // COMPONENT THEMES
    properties.add(
      DiagnosticsProperty<ActionIconThemeData>(
        'actionIconTheme',
        actionIconTheme,
        level: DiagnosticLevel.debug,
      ),
    );
    properties.add(
      DiagnosticsProperty<AppBarTheme>(
        'appBarTheme',
        appBarTheme,
        defaultValue: defaultData.appBarTheme,
        level: DiagnosticLevel.debug,
      ),
    );
    properties.add(
      DiagnosticsProperty<BadgeThemeData>(
        'badgeTheme',
        badgeTheme,
        defaultValue: defaultData.badgeTheme,
        level: DiagnosticLevel.debug,
      ),
    );
    properties.add(
      DiagnosticsProperty<MaterialBannerThemeData>(
        'bannerTheme',
        bannerTheme,
        defaultValue: defaultData.bannerTheme,
        level: DiagnosticLevel.debug,
      ),
    );
    properties.add(
      DiagnosticsProperty<BottomAppBarTheme>(
        'bottomAppBarTheme',
        bottomAppBarTheme,
        defaultValue: defaultData.bottomAppBarTheme,
        level: DiagnosticLevel.debug,
      ),
    );
    properties.add(
      DiagnosticsProperty<BottomNavigationBarThemeData>(
        'bottomNavigationBarTheme',
        bottomNavigationBarTheme,
        defaultValue: defaultData.bottomNavigationBarTheme,
        level: DiagnosticLevel.debug,
      ),
    );
    properties.add(
      DiagnosticsProperty<BottomSheetThemeData>(
        'bottomSheetTheme',
        bottomSheetTheme,
        defaultValue: defaultData.bottomSheetTheme,
        level: DiagnosticLevel.debug,
      ),
    );
    properties.add(
      DiagnosticsProperty<ButtonThemeData>(
        'buttonTheme',
        buttonTheme,
        level: DiagnosticLevel.debug,
      ),
    );
    properties.add(
      DiagnosticsProperty<CardThemeData>('cardTheme', cardTheme, level: DiagnosticLevel.debug),
    );
    properties.add(
      DiagnosticsProperty<CheckboxThemeData>(
        'checkboxTheme',
        checkboxTheme,
        defaultValue: defaultData.checkboxTheme,
        level: DiagnosticLevel.debug,
      ),
    );
    properties.add(
      DiagnosticsProperty<ChipThemeData>('chipTheme', chipTheme, level: DiagnosticLevel.debug),
    );
    properties.add(
      DiagnosticsProperty<DataTableThemeData>(
        'dataTableTheme',
        dataTableTheme,
        defaultValue: defaultData.dataTableTheme,
        level: DiagnosticLevel.debug,
      ),
    );
    properties.add(
      DiagnosticsProperty<DatePickerThemeData>(
        'datePickerTheme',
        datePickerTheme,
        defaultValue: defaultData.datePickerTheme,
        level: DiagnosticLevel.debug,
      ),
    );
    properties.add(
      DiagnosticsProperty<DialogThemeData>(
        'dialogTheme',
        dialogTheme,
        defaultValue: defaultData.dialogTheme,
        level: DiagnosticLevel.debug,
      ),
    );
    properties.add(
      DiagnosticsProperty<DividerThemeData>(
        'dividerTheme',
        dividerTheme,
        defaultValue: defaultData.dividerTheme,
        level: DiagnosticLevel.debug,
      ),
    );
    properties.add(
      DiagnosticsProperty<DrawerThemeData>(
        'drawerTheme',
        drawerTheme,
        defaultValue: defaultData.drawerTheme,
        level: DiagnosticLevel.debug,
      ),
    );
    properties.add(
      DiagnosticsProperty<DropdownMenuThemeData>(
        'dropdownMenuTheme',
        dropdownMenuTheme,
        defaultValue: defaultData.dropdownMenuTheme,
        level: DiagnosticLevel.debug,
      ),
    );
    properties.add(
      DiagnosticsProperty<ElevatedButtonThemeData>(
        'elevatedButtonTheme',
        elevatedButtonTheme,
        defaultValue: defaultData.elevatedButtonTheme,
        level: DiagnosticLevel.debug,
      ),
    );
    properties.add(
      DiagnosticsProperty<ExpansionTileThemeData>(
        'expansionTileTheme',
        expansionTileTheme,
        level: DiagnosticLevel.debug,
      ),
    );
    properties.add(
      DiagnosticsProperty<FilledButtonThemeData>(
        'filledButtonTheme',
        filledButtonTheme,
        defaultValue: defaultData.filledButtonTheme,
        level: DiagnosticLevel.debug,
      ),
    );
    properties.add(
      DiagnosticsProperty<FloatingActionButtonThemeData>(
        'floatingActionButtonTheme',
        floatingActionButtonTheme,
        defaultValue: defaultData.floatingActionButtonTheme,
        level: DiagnosticLevel.debug,
      ),
    );
    properties.add(
      DiagnosticsProperty<IconButtonThemeData>(
        'iconButtonTheme',
        iconButtonTheme,
        defaultValue: defaultData.iconButtonTheme,
        level: DiagnosticLevel.debug,
      ),
    );
    properties.add(
      DiagnosticsProperty<ListTileThemeData>(
        'listTileTheme',
        listTileTheme,
        defaultValue: defaultData.listTileTheme,
        level: DiagnosticLevel.debug,
      ),
    );
    properties.add(
      DiagnosticsProperty<MenuBarThemeData>(
        'menuBarTheme',
        menuBarTheme,
        defaultValue: defaultData.menuBarTheme,
        level: DiagnosticLevel.debug,
      ),
    );
    properties.add(
      DiagnosticsProperty<MenuButtonThemeData>(
        'menuButtonTheme',
        menuButtonTheme,
        defaultValue: defaultData.menuButtonTheme,
        level: DiagnosticLevel.debug,
      ),
    );
    properties.add(
      DiagnosticsProperty<MenuThemeData>(
        'menuTheme',
        menuTheme,
        defaultValue: defaultData.menuTheme,
        level: DiagnosticLevel.debug,
      ),
    );
    properties.add(
      DiagnosticsProperty<NavigationBarThemeData>(
        'navigationBarTheme',
        navigationBarTheme,
        defaultValue: defaultData.navigationBarTheme,
        level: DiagnosticLevel.debug,
      ),
    );
    properties.add(
      DiagnosticsProperty<NavigationDrawerThemeData>(
        'navigationDrawerTheme',
        navigationDrawerTheme,
        defaultValue: defaultData.navigationDrawerTheme,
        level: DiagnosticLevel.debug,
      ),
    );
    properties.add(
      DiagnosticsProperty<NavigationRailThemeData>(
        'navigationRailTheme',
        navigationRailTheme,
        defaultValue: defaultData.navigationRailTheme,
        level: DiagnosticLevel.debug,
      ),
    );
    properties.add(
      DiagnosticsProperty<OutlinedButtonThemeData>(
        'outlinedButtonTheme',
        outlinedButtonTheme,
        defaultValue: defaultData.outlinedButtonTheme,
        level: DiagnosticLevel.debug,
      ),
    );
    properties.add(
      DiagnosticsProperty<PopupMenuThemeData>(
        'popupMenuTheme',
        popupMenuTheme,
        defaultValue: defaultData.popupMenuTheme,
        level: DiagnosticLevel.debug,
      ),
    );
    properties.add(
      DiagnosticsProperty<ProgressIndicatorThemeData>(
        'progressIndicatorTheme',
        progressIndicatorTheme,
        defaultValue: defaultData.progressIndicatorTheme,
        level: DiagnosticLevel.debug,
      ),
    );
    properties.add(
      DiagnosticsProperty<RadioThemeData>(
        'radioTheme',
        radioTheme,
        defaultValue: defaultData.radioTheme,
        level: DiagnosticLevel.debug,
      ),
    );
    properties.add(
      DiagnosticsProperty<SearchBarThemeData>(
        'searchBarTheme',
        searchBarTheme,
        defaultValue: defaultData.searchBarTheme,
        level: DiagnosticLevel.debug,
      ),
    );
    properties.add(
      DiagnosticsProperty<SearchViewThemeData>(
        'searchViewTheme',
        searchViewTheme,
        defaultValue: defaultData.searchViewTheme,
        level: DiagnosticLevel.debug,
      ),
    );
    properties.add(
      DiagnosticsProperty<SegmentedButtonThemeData>(
        'segmentedButtonTheme',
        segmentedButtonTheme,
        defaultValue: defaultData.segmentedButtonTheme,
        level: DiagnosticLevel.debug,
      ),
    );
    properties.add(
      DiagnosticsProperty<SliderThemeData>(
        'sliderTheme',
        sliderTheme,
        level: DiagnosticLevel.debug,
      ),
    );
    properties.add(
      DiagnosticsProperty<SnackBarThemeData>(
        'snackBarTheme',
        snackBarTheme,
        defaultValue: defaultData.snackBarTheme,
        level: DiagnosticLevel.debug,
      ),
    );
    properties.add(
      DiagnosticsProperty<SwitchThemeData>(
        'switchTheme',
        switchTheme,
        defaultValue: defaultData.switchTheme,
        level: DiagnosticLevel.debug,
      ),
    );
    properties.add(
      DiagnosticsProperty<TabBarThemeData>(
        'tabBarTheme',
        tabBarTheme,
        level: DiagnosticLevel.debug,
      ),
    );
    properties.add(
      DiagnosticsProperty<TextButtonThemeData>(
        'textButtonTheme',
        textButtonTheme,
        defaultValue: defaultData.textButtonTheme,
        level: DiagnosticLevel.debug,
      ),
    );
    properties.add(
      DiagnosticsProperty<TextSelectionThemeData>(
        'textSelectionTheme',
        textSelectionTheme,
        defaultValue: defaultData.textSelectionTheme,
        level: DiagnosticLevel.debug,
      ),
    );
    properties.add(
      DiagnosticsProperty<TimePickerThemeData>(
        'timePickerTheme',
        timePickerTheme,
        defaultValue: defaultData.timePickerTheme,
        level: DiagnosticLevel.debug,
      ),
    );
    properties.add(
      DiagnosticsProperty<ToggleButtonsThemeData>(
        'toggleButtonsTheme',
        toggleButtonsTheme,
        level: DiagnosticLevel.debug,
      ),
    );
    properties.add(
      DiagnosticsProperty<TooltipThemeData>(
        'tooltipTheme',
        tooltipTheme,
        level: DiagnosticLevel.debug,
      ),
    );
    // DEPRECATED (newest deprecations at the bottom)
    properties.add(
      DiagnosticsProperty<ButtonBarThemeData>(
        'buttonBarTheme',
        buttonBarTheme,
        defaultValue: defaultData.buttonBarTheme,
        level: DiagnosticLevel.debug,
      ),
    );
    properties.add(
      ColorProperty(
        'dialogBackgroundColor',
        dialogBackgroundColor,
        defaultValue: defaultData.dialogBackgroundColor,
        level: DiagnosticLevel.debug,
      ),
    );
  }
}

/// A [CupertinoThemeData] that defers unspecified theme attributes to an
/// upstream Material [ThemeData].
///
/// This type of [CupertinoThemeData] is used by the Material [Theme] to
/// harmonize the [CupertinoTheme] with the material theme's colors and text
/// styles.
///
/// In the most basic case, [ThemeData]'s `cupertinoOverrideTheme` is null and
/// descendant Cupertino widgets' styling is derived from the Material theme.
///
/// To override individual parts of the Material-derived Cupertino styling,
/// `cupertinoOverrideTheme`'s construction parameters can be used.
///
/// To completely decouple the Cupertino styling from Material theme derivation,
/// another [CupertinoTheme] widget can be inserted as a descendant of the
/// Material [Theme]. On a [MaterialApp], this can be done using the `builder`
/// parameter on the constructor.
///
/// See also:
///
///  * [CupertinoThemeData], whose null constructor parameters default to
///    reasonable iOS styling defaults rather than harmonizing with a Material
///    theme.
///  * [Theme], widget which inserts a [CupertinoTheme] with this
///    [MaterialBasedCupertinoThemeData].
// This class subclasses CupertinoThemeData rather than composes one because it
// _is_ a CupertinoThemeData with partially altered behavior. e.g. its textTheme
// is from the superclass and based on the primaryColor but the primaryColor
// comes from the Material theme unless overridden.
class MaterialBasedCupertinoThemeData extends CupertinoThemeData {
  /// Create a [MaterialBasedCupertinoThemeData] based on a Material [ThemeData]
  /// and its `cupertinoOverrideTheme`.
  MaterialBasedCupertinoThemeData({required ThemeData materialTheme})
    : this._(
        materialTheme,
        (materialTheme.cupertinoOverrideTheme ?? const CupertinoThemeData()).noDefault(),
      );

  MaterialBasedCupertinoThemeData._(this._materialTheme, this._cupertinoOverrideTheme)
    : // Pass all values to the superclass so Material-agnostic properties
      // like barBackgroundColor can still behave like a normal
      // CupertinoThemeData.
      super.raw(
        _cupertinoOverrideTheme.brightness,
        _cupertinoOverrideTheme.primaryColor,
        _cupertinoOverrideTheme.primaryContrastingColor,
        _cupertinoOverrideTheme.textTheme,
        _cupertinoOverrideTheme.barBackgroundColor,
        _cupertinoOverrideTheme.scaffoldBackgroundColor,
        _cupertinoOverrideTheme.applyThemeToAll,
      );

  final ThemeData _materialTheme;
  final NoDefaultCupertinoThemeData _cupertinoOverrideTheme;

  @override
  Brightness get brightness => _cupertinoOverrideTheme.brightness ?? _materialTheme.brightness;

  @override
  Color get primaryColor =>
      _cupertinoOverrideTheme.primaryColor ?? _materialTheme.colorScheme.primary;

  @override
  Color get primaryContrastingColor =>
      _cupertinoOverrideTheme.primaryContrastingColor ?? _materialTheme.colorScheme.onPrimary;

  @override
  Color get scaffoldBackgroundColor =>
      _cupertinoOverrideTheme.scaffoldBackgroundColor ?? _materialTheme.scaffoldBackgroundColor;

  /// Copies the [ThemeData]'s `cupertinoOverrideTheme`.
  ///
  /// Only the specified override attributes of the [ThemeData]'s
  /// `cupertinoOverrideTheme` and the newly specified parameters are in the
  /// returned [CupertinoThemeData]. No derived attributes from iOS defaults or
  /// from cascaded Material theme attributes are copied.
  ///
  /// This [copyWith] cannot change the base Material [ThemeData]. To change the
  /// base Material [ThemeData], create a new Material [Theme] and use
  /// [ThemeData.copyWith] on the Material [ThemeData] instead.
  @override
  MaterialBasedCupertinoThemeData copyWith({
    Brightness? brightness,
    Color? primaryColor,
    Color? primaryContrastingColor,
    CupertinoTextThemeData? textTheme,
    Color? barBackgroundColor,
    Color? scaffoldBackgroundColor,
    bool? applyThemeToAll,
  }) {
    return MaterialBasedCupertinoThemeData._(
      _materialTheme,
      _cupertinoOverrideTheme.copyWith(
        brightness: brightness,
        primaryColor: primaryColor,
        primaryContrastingColor: primaryContrastingColor,
        textTheme: textTheme,
        barBackgroundColor: barBackgroundColor,
        scaffoldBackgroundColor: scaffoldBackgroundColor,
        applyThemeToAll: applyThemeToAll,
      ),
    );
  }

  @override
  CupertinoThemeData resolveFrom(BuildContext context) {
    // Only the cupertino override theme part will be resolved.
    // If the color comes from the material theme it's not resolved.
    return MaterialBasedCupertinoThemeData._(
      _materialTheme,
      _cupertinoOverrideTheme.resolveFrom(context),
    );
  }
}

/// A class for creating a Material theme with a color scheme based off of the
/// colors from a [CupertinoThemeData]. This is intended to be used only in the
/// case when a Material widget is unable to find a Material theme in the tree,
/// but is able to find a Cupertino theme. Most often this will occur when a
/// Material widget is used inside of a [CupertinoApp].
///
/// Besides the colors, this theme will use all the defaults from Material's
/// [ThemeData], so if further customization is needed, it is best to manually
/// add a Material [Theme] above the [CupertinoApp].
class CupertinoBasedMaterialThemeData {
  /// Creates a Material theme with a color scheme based off of the colors from
  /// a [CupertinoThemeData].
  CupertinoBasedMaterialThemeData({required CupertinoThemeData themeData})
    : materialTheme = ThemeData(
        colorScheme: ColorScheme.fromSeed(
          seedColor: themeData.primaryColor,
          brightness: themeData.brightness ?? Brightness.light,
          primary: themeData.primaryColor,
          onPrimary: themeData.primaryContrastingColor,
        ),
      );

  /// The Material theme data with colors based on an existing [CupertinoThemeData].
  final ThemeData materialTheme;
}

@immutable
class _IdentityThemeDataCacheKey {
  const _IdentityThemeDataCacheKey(this.baseTheme, this.localTextGeometry);

  final ThemeData baseTheme;
  final TextTheme localTextGeometry;

  // Using XOR to make the hash function as fast as possible (e.g. Jenkins is
  // noticeably slower).
  @override
  int get hashCode => identityHashCode(baseTheme) ^ identityHashCode(localTextGeometry);

  @override
  bool operator ==(Object other) {
    // We are explicitly ignoring the possibility that the types might not
    // match in the interests of speed.
    return other is _IdentityThemeDataCacheKey &&
        identical(other.baseTheme, baseTheme) &&
        identical(other.localTextGeometry, localTextGeometry);
  }
}

/// Cache of objects of limited size that uses the first in first out eviction
/// strategy (a.k.a least recently inserted).
///
/// The key that was inserted before all other keys is evicted first, i.e. the
/// one inserted least recently.
class _FifoCache<K, V> {
  _FifoCache(this._maximumSize) : assert(_maximumSize > 0);

  /// In Dart the map literal uses a linked hash-map implementation, whose keys
  /// are stored such that [Map.keys] returns them in the order they were
  /// inserted.
  final Map<K, V> _cache = <K, V>{};

  /// Maximum number of entries to store in the cache.
  ///
  /// Once this many entries have been cached, the entry inserted least recently
  /// is evicted when adding a new entry.
  final int _maximumSize;

  /// Returns the previously cached value for the given key, if available;
  /// if not, calls the given callback to obtain it first.
  V putIfAbsent(K key, V Function() loader) {
    assert(key != null);
    final V? result = _cache[key];
    if (result != null) {
      return result;
    }
    if (_cache.length == _maximumSize) {
      _cache.remove(_cache.keys.first);
    }
    return _cache[key] = loader();
  }
}

/// Defines the visual density of user interface components.
///
/// Density, in the context of a UI, is the vertical and horizontal
/// "compactness" of the components in the UI. It is unitless, since it means
/// different things to different UI components.
///
/// The default for visual densities is zero for both vertical and horizontal
/// densities, which corresponds to the default visual density of components in
/// the Material Design specification. It does not affect text sizes, icon
/// sizes, or padding values.
///
/// For example, for buttons, it affects the spacing around the child of the
/// button. For lists, it affects the distance between baselines of entries in
/// the list. For chips, it only affects the vertical size, not the horizontal
/// size.
///
/// Here are some examples of widgets that respond to density changes:
///
///  * [Checkbox]
///  * [Chip]
///  * [ElevatedButton]
///  * [IconButton]
///  * [InputDecorator] (which gives density support to [TextField], etc.)
///  * [ListTile]
///  * [MaterialButton]
///  * [OutlinedButton]
///  * [Radio]
///  * [RawMaterialButton]
///  * [TextButton]
///
/// See also:
///
///  * [ThemeData.visualDensity], where this property is used to specify the base
///    horizontal density of Material components.
///  * [Material design guidance on density](https://material.io/design/layout/applying-density.html).
@immutable
class VisualDensity with Diagnosticable {
  /// A const constructor for [VisualDensity].
  ///
  /// The [horizontal] and [vertical] arguments must be in the interval between
  /// [minimumDensity] and [maximumDensity], inclusive.
  const VisualDensity({this.horizontal = 0.0, this.vertical = 0.0})
    : assert(vertical <= maximumDensity),
      assert(vertical >= minimumDensity),
      assert(horizontal <= maximumDensity),
      assert(horizontal >= minimumDensity);

  /// The minimum allowed density.
  static const double minimumDensity = -4.0;

  /// The maximum allowed density.
  static const double maximumDensity = 4.0;

  /// The default profile for [VisualDensity] in [ThemeData].
  ///
  /// This default value represents a visual density that is less dense than
  /// either [comfortable] or [compact], and corresponds to density values of
  /// zero in both axes.
  static const VisualDensity standard = VisualDensity();

  /// The profile for a "comfortable" interpretation of [VisualDensity].
  ///
  /// Individual components will interpret the density value independently,
  /// making themselves more visually dense than [standard] and less dense than
  /// [compact] to different degrees based on the Material Design specification
  /// of the "comfortable" setting for their particular use case.
  ///
  /// It corresponds to a density value of -1 in both axes.
  static const VisualDensity comfortable = VisualDensity(horizontal: -1.0, vertical: -1.0);

  /// The profile for a "compact" interpretation of [VisualDensity].
  ///
  /// Individual components will interpret the density value independently,
  /// making themselves more visually dense than [standard] and [comfortable] to
  /// different degrees based on the Material Design specification of the
  /// "comfortable" setting for their particular use case.
  ///
  /// It corresponds to a density value of -2 in both axes.
  static const VisualDensity compact = VisualDensity(horizontal: -2.0, vertical: -2.0);

  /// Returns a [VisualDensity] that is adaptive based on the current platform
  /// on which the framework is executing, from [defaultTargetPlatform].
  ///
  /// When [defaultTargetPlatform] is a desktop platform, this returns
  /// [compact], and for other platforms, it returns a default-constructed
  /// [VisualDensity].
  ///
  /// See also:
  ///
  /// * [defaultDensityForPlatform] which returns a [VisualDensity] that is
  ///   adaptive based on the platform given to it.
  /// * [defaultTargetPlatform] which returns the platform on which the
  ///   framework is currently executing.
  static VisualDensity get adaptivePlatformDensity =>
      defaultDensityForPlatform(defaultTargetPlatform);

  /// Returns a [VisualDensity] that is adaptive based on the given [platform].
  ///
  /// For desktop platforms, this returns [compact], and for other platforms, it
  /// returns a default-constructed [VisualDensity].
  ///
  /// See also:
  ///
  /// * [adaptivePlatformDensity] which returns a [VisualDensity] that is
  ///   adaptive based on [defaultTargetPlatform].
  static VisualDensity defaultDensityForPlatform(TargetPlatform platform) {
    return switch (platform) {
      TargetPlatform.android || TargetPlatform.iOS || TargetPlatform.fuchsia => standard,
      TargetPlatform.linux || TargetPlatform.macOS || TargetPlatform.windows => compact,
    };
  }

  /// Copy the current [VisualDensity] with the given values replacing the
  /// current values.
  VisualDensity copyWith({double? horizontal, double? vertical}) {
    return VisualDensity(
      horizontal: horizontal ?? this.horizontal,
      vertical: vertical ?? this.vertical,
    );
  }

  /// The horizontal visual density of UI components.
  ///
  /// This property affects only the horizontal spacing between and within
  /// components, to allow for different UI visual densities. It does not affect
  /// text sizes, icon sizes, or padding values. The default value is 0.0,
  /// corresponding to the metrics specified in the Material Design
  /// specification. The value can range from [minimumDensity] to
  /// [maximumDensity], inclusive.
  ///
  /// See also:
  ///
  ///  * [ThemeData.visualDensity], where this property is used to specify the base
  ///    horizontal density of Material components.
  ///  * [Material design guidance on density](https://material.io/design/layout/applying-density.html).
  final double horizontal;

  /// The vertical visual density of UI components.
  ///
  /// This property affects only the vertical spacing between and within
  /// components, to allow for different UI visual densities. It does not affect
  /// text sizes, icon sizes, or padding values. The default value is 0.0,
  /// corresponding to the metrics specified in the Material Design
  /// specification. The value can range from [minimumDensity] to
  /// [maximumDensity], inclusive.
  ///
  /// See also:
  ///
  ///  * [ThemeData.visualDensity], where this property is used to specify the base
  ///    vertical density of Material components.
  ///  * [Material design guidance on density](https://material.io/design/layout/applying-density.html).
  final double vertical;

  /// The base adjustment in logical pixels of the visual density of UI components.
  ///
  /// The input density values are multiplied by a constant to arrive at a base
  /// size adjustment that fits Material Design guidelines.
  ///
  /// Individual components may adjust this value based upon their own
  /// individual interpretation of density.
  Offset get baseSizeAdjustment {
    // The number of logical pixels represented by an increase or decrease in
    // density by one. The Material Design guidelines say to increment/decrement
    // sizes in terms of four pixel increments.
    const double interval = 4.0;

    return Offset(horizontal, vertical) * interval;
  }

  /// Linearly interpolate between two densities.
  static VisualDensity lerp(VisualDensity a, VisualDensity b, double t) {
    if (identical(a, b)) {
      return a;
    }
    return VisualDensity(
      horizontal: lerpDouble(a.horizontal, b.horizontal, t)!,
      vertical: lerpDouble(a.vertical, b.vertical, t)!,
    );
  }

  /// Return a copy of [constraints] whose minimum width and height have been
  /// updated with the [baseSizeAdjustment].
  ///
  /// The resulting minWidth and minHeight values are clamped to not exceed the
  /// maxWidth and maxHeight values, respectively.
  BoxConstraints effectiveConstraints(BoxConstraints constraints) {
    assert(constraints.debugAssertIsValid());
    return constraints.copyWith(
      minWidth: clampDouble(
        constraints.minWidth + baseSizeAdjustment.dx,
        0.0,
        constraints.maxWidth,
      ),
      minHeight: clampDouble(
        constraints.minHeight + baseSizeAdjustment.dy,
        0.0,
        constraints.maxHeight,
      ),
    );
  }

  @override
  bool operator ==(Object other) {
    if (other.runtimeType != runtimeType) {
      return false;
    }
    return other is VisualDensity && other.horizontal == horizontal && other.vertical == vertical;
  }

  @override
  int get hashCode => Object.hash(horizontal, vertical);

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties.add(DoubleProperty('horizontal', horizontal, defaultValue: 0.0));
    properties.add(DoubleProperty('vertical', vertical, defaultValue: 0.0));
  }

  @override
  String toStringShort() {
    return '${super.toStringShort()}(h: ${debugFormatDouble(horizontal)}, v: ${debugFormatDouble(vertical)})';
  }
}

// BEGIN GENERATED TOKEN PROPERTIES - ColorScheme

// Do not edit by hand. The code between the "BEGIN GENERATED" and
// "END GENERATED" comments are generated from data in the Material
// Design token database by the script:
//   dev/tools/gen_defaults/bin/gen_defaults.dart.

// dart format off
const ColorScheme _colorSchemeLightM3 = ColorScheme(
  brightness: Brightness.light,
  primary: Color(0xFF6750A4),
  onPrimary: Color(0xFFFFFFFF),
  primaryContainer: Color(0xFFEADDFF),
  onPrimaryContainer: Color(0xFF4F378B),
  primaryFixed: Color(0xFFEADDFF),
  primaryFixedDim: Color(0xFFD0BCFF),
  onPrimaryFixed: Color(0xFF21005D),
  onPrimaryFixedVariant: Color(0xFF4F378B),
  secondary: Color(0xFF625B71),
  onSecondary: Color(0xFFFFFFFF),
  secondaryContainer: Color(0xFFE8DEF8),
  onSecondaryContainer: Color(0xFF4A4458),
  secondaryFixed: Color(0xFFE8DEF8),
  secondaryFixedDim: Color(0xFFCCC2DC),
  onSecondaryFixed: Color(0xFF1D192B),
  onSecondaryFixedVariant: Color(0xFF4A4458),
  tertiary: Color(0xFF7D5260),
  onTertiary: Color(0xFFFFFFFF),
  tertiaryContainer: Color(0xFFFFD8E4),
  onTertiaryContainer: Color(0xFF633B48),
  tertiaryFixed: Color(0xFFFFD8E4),
  tertiaryFixedDim: Color(0xFFEFB8C8),
  onTertiaryFixed: Color(0xFF31111D),
  onTertiaryFixedVariant: Color(0xFF633B48),
  error: Color(0xFFB3261E),
  onError: Color(0xFFFFFFFF),
  errorContainer: Color(0xFFF9DEDC),
  onErrorContainer: Color(0xFF8C1D18),
  background: Color(0xFFFEF7FF),
  onBackground: Color(0xFF1D1B20),
  surface: Color(0xFFFEF7FF),
  surfaceBright: Color(0xFFFEF7FF),
  surfaceContainerLowest: Color(0xFFFFFFFF),
  surfaceContainerLow: Color(0xFFF7F2FA),
  surfaceContainer: Color(0xFFF3EDF7),
  surfaceContainerHigh: Color(0xFFECE6F0),
  surfaceContainerHighest: Color(0xFFE6E0E9),
  surfaceDim: Color(0xFFDED8E1),
  onSurface: Color(0xFF1D1B20),
  surfaceVariant: Color(0xFFE7E0EC),
  onSurfaceVariant: Color(0xFF49454F),
  outline: Color(0xFF79747E),
  outlineVariant: Color(0xFFCAC4D0),
  shadow: Color(0xFF000000),
  scrim: Color(0xFF000000),
  inverseSurface: Color(0xFF322F35),
  onInverseSurface: Color(0xFFF5EFF7),
  inversePrimary: Color(0xFFD0BCFF),
  // The surfaceTint color is set to the same color as the primary.
  surfaceTint: Color(0xFF6750A4),
);

const ColorScheme _colorSchemeDarkM3 = ColorScheme(
  brightness: Brightness.dark,
  primary: Color(0xFFD0BCFF),
  onPrimary: Color(0xFF381E72),
  primaryContainer: Color(0xFF4F378B),
  onPrimaryContainer: Color(0xFFEADDFF),
  primaryFixed: Color(0xFFEADDFF),
  primaryFixedDim: Color(0xFFD0BCFF),
  onPrimaryFixed: Color(0xFF21005D),
  onPrimaryFixedVariant: Color(0xFF4F378B),
  secondary: Color(0xFFCCC2DC),
  onSecondary: Color(0xFF332D41),
  secondaryContainer: Color(0xFF4A4458),
  onSecondaryContainer: Color(0xFFE8DEF8),
  secondaryFixed: Color(0xFFE8DEF8),
  secondaryFixedDim: Color(0xFFCCC2DC),
  onSecondaryFixed: Color(0xFF1D192B),
  onSecondaryFixedVariant: Color(0xFF4A4458),
  tertiary: Color(0xFFEFB8C8),
  onTertiary: Color(0xFF492532),
  tertiaryContainer: Color(0xFF633B48),
  onTertiaryContainer: Color(0xFFFFD8E4),
  tertiaryFixed: Color(0xFFFFD8E4),
  tertiaryFixedDim: Color(0xFFEFB8C8),
  onTertiaryFixed: Color(0xFF31111D),
  onTertiaryFixedVariant: Color(0xFF633B48),
  error: Color(0xFFF2B8B5),
  onError: Color(0xFF601410),
  errorContainer: Color(0xFF8C1D18),
  onErrorContainer: Color(0xFFF9DEDC),
  background: Color(0xFF141218),
  onBackground: Color(0xFFE6E0E9),
  surface: Color(0xFF141218),
  surfaceBright: Color(0xFF3B383E),
  surfaceContainerLowest: Color(0xFF0F0D13),
  surfaceContainerLow: Color(0xFF1D1B20),
  surfaceContainer: Color(0xFF211F26),
  surfaceContainerHigh: Color(0xFF2B2930),
  surfaceContainerHighest: Color(0xFF36343B),
  surfaceDim: Color(0xFF141218),
  onSurface: Color(0xFFE6E0E9),
  surfaceVariant: Color(0xFF49454F),
  onSurfaceVariant: Color(0xFFCAC4D0),
  outline: Color(0xFF938F99),
  outlineVariant: Color(0xFF49454F),
  shadow: Color(0xFF000000),
  scrim: Color(0xFF000000),
  inverseSurface: Color(0xFFE6E0E9),
  onInverseSurface: Color(0xFF322F35),
  inversePrimary: Color(0xFF6750A4),
  // The surfaceTint color is set to the same color as the primary.
  surfaceTint: Color(0xFFD0BCFF),
);
// dart format on

// END GENERATED TOKEN PROPERTIES - ColorScheme


--- File: packages/flutter/lib/src/material/theme.dart ---
// Copyright 2014 The Flutter Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

/// @docImport 'app.dart';
/// @docImport 'color_scheme.dart';
/// @docImport 'text_theme.dart';
library;

import 'package:flutter/cupertino.dart';
import 'package:flutter/foundation.dart';

import 'material_localizations.dart';
import 'theme_data.dart';
import 'typography.dart';

export 'theme_data.dart' show Brightness, ThemeData;

/// The duration over which theme changes animate by default.
const Duration kThemeAnimationDuration = Duration(milliseconds: 200);

/// Applies a theme to descendant widgets.
///
/// A theme describes the colors and typographic choices of an application.
///
/// {@youtube 560 315 https://www.youtube.com/watch?v=oTvQDJOBXmM}
///
/// Descendant widgets obtain the current theme's [ThemeData] object using
/// [Theme.of]. When a widget uses [Theme.of], it is automatically rebuilt if
/// the theme later changes, so that the changes can be applied.
///
/// The [Theme] widget implies an [IconTheme] widget, set to the value of the
/// [ThemeData.iconTheme] of the [data] for the [Theme].
///
/// See also:
///
///  * [ThemeData], which describes the actual configuration of a theme.
///  * [AnimatedTheme], which animates the [ThemeData] when it changes rather
///    than changing the theme all at once.
///  * [MaterialApp], which includes an [AnimatedTheme] widget configured via
///    the [MaterialApp.theme] argument.
class Theme extends StatelessWidget {
  /// Applies the given theme [data] to [child].
  const Theme({super.key, required this.data, required this.child});

  /// Specifies the color and typography values for descendant widgets.
  final ThemeData data;

  /// The widget below this widget in the tree.
  ///
  /// {@macro flutter.widgets.ProxyWidget.child}
  final Widget child;

  static final ThemeData _kFallbackTheme = ThemeData.fallback();

  /// The data from the closest [Theme] instance that encloses the given
  /// context.
  ///
  /// If the given context is enclosed in a [Localizations] widget providing
  /// [MaterialLocalizations], the returned data is localized according to the
  /// nearest available [MaterialLocalizations].
  ///
  /// Defaults to [ThemeData.fallback] if there is no [Theme] in the given
  /// build context.
  ///
  /// Typical usage is as follows:
  ///
  /// ```dart
  /// @override
  /// Widget build(BuildContext context) {
  ///   return Text(
  ///     'Example',
  ///     style: Theme.of(context).textTheme.titleLarge,
  ///   );
  /// }
  /// ```
  ///
  /// When the [Theme] is actually created in the same `build` function
  /// (possibly indirectly, e.g. as part of a [MaterialApp]), the `context`
  /// argument to the `build` function can't be used to find the [Theme] (since
  /// it's "above" the widget being returned). In such cases, the following
  /// technique with a [Builder] can be used to provide a new scope with a
  /// [BuildContext] that is "under" the [Theme]:
  ///
  /// ```dart
  /// @override
  /// Widget build(BuildContext context) {
  ///   return MaterialApp(
  ///     theme: ThemeData.light(),
  ///     home: Builder(
  ///       // Create an inner BuildContext so that we can refer to
  ///       // the Theme with Theme.of().
  ///       builder: (BuildContext context) {
  ///         return Center(
  ///           child: Text(
  ///             'Example',
  ///             style: Theme.of(context).textTheme.titleLarge,
  ///           ),
  ///         );
  ///       },
  ///     ),
  ///   );
  /// }
  /// ```
  ///
  /// See also:
  ///
  /// * [ColorScheme.of], a convenience method that returns [ThemeData.colorScheme]
  ///   from the closest [Theme] ancestor. (equivalent to `Theme.of(context).colorScheme`).
  /// * [TextTheme.of], a convenience method that returns [ThemeData.textTheme]
  ///   from the closest [Theme] ancestor. (equivalent to `Theme.of(context).textTheme`).
  /// * [IconTheme.of], that returns [ThemeData.iconTheme] from the closest [Theme] or
  ///   [IconThemeData.fallback] if there is no [IconTheme] ancestor.
  static ThemeData of(BuildContext context) {
    final _InheritedTheme? inheritedTheme =
        context.dependOnInheritedWidgetOfExactType<_InheritedTheme>();
    final MaterialLocalizations? localizations = Localizations.of<MaterialLocalizations>(
      context,
      MaterialLocalizations,
    );
    final ScriptCategory category = localizations?.scriptCategory ?? ScriptCategory.englishLike;
    final InheritedCupertinoTheme? inheritedCupertinoTheme =
        context.dependOnInheritedWidgetOfExactType<InheritedCupertinoTheme>();
    final ThemeData theme =
        inheritedTheme?.theme.data ??
        (inheritedCupertinoTheme != null
            ? CupertinoBasedMaterialThemeData(
              themeData: inheritedCupertinoTheme.theme.data,
            ).materialTheme
            : _kFallbackTheme);
    return ThemeData.localize(theme, theme.typography.geometryThemeFor(category));
  }

  // The inherited themes in widgets library can not infer their values from
  // Theme in material library. Wraps the child with these inherited themes to
  // overrides their values directly.
  Widget _wrapsWidgetThemes(BuildContext context, Widget child) {
    final DefaultSelectionStyle selectionStyle = DefaultSelectionStyle.of(context);
    return IconTheme(
      data: data.iconTheme,
      child: DefaultSelectionStyle(
        selectionColor: data.textSelectionTheme.selectionColor ?? selectionStyle.selectionColor,
        cursorColor: data.textSelectionTheme.cursorColor ?? selectionStyle.cursorColor,
        child: child,
      ),
    );
  }

  CupertinoThemeData _inheritedCupertinoThemeData(BuildContext context) {
    final InheritedCupertinoTheme? inheritedTheme =
        context.dependOnInheritedWidgetOfExactType<InheritedCupertinoTheme>();
    return (inheritedTheme?.theme.data ?? MaterialBasedCupertinoThemeData(materialTheme: data))
        .resolveFrom(context);
  }

  @override
  Widget build(BuildContext context) {
    return _InheritedTheme(
      theme: this,
      child: CupertinoTheme(
        // If a CupertinoThemeData doesn't exist, we're using a
        // MaterialBasedCupertinoThemeData here instead of a CupertinoThemeData
        // because it defers some properties to the Material ThemeData.
        data: _inheritedCupertinoThemeData(context),
        child: _wrapsWidgetThemes(context, child),
      ),
    );
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties.add(DiagnosticsProperty<ThemeData>('data', data, showName: false));
  }
}

class _InheritedTheme extends InheritedTheme {
  const _InheritedTheme({required this.theme, required super.child});

  final Theme theme;

  @override
  Widget wrap(BuildContext context, Widget child) {
    return Theme(data: theme.data, child: child);
  }

  @override
  bool updateShouldNotify(_InheritedTheme old) => theme.data != old.theme.data;
}

/// An interpolation between two [ThemeData]s.
///
/// This class specializes the interpolation of [Tween<ThemeData>] to call the
/// [ThemeData.lerp] method.
///
/// See [Tween] for a discussion on how to use interpolation objects.
class ThemeDataTween extends Tween<ThemeData> {
  /// Creates a [ThemeData] tween.
  ///
  /// The [begin] and [end] properties must be non-null before the tween is
  /// first used, but the arguments can be null if the values are going to be
  /// filled in later.
  ThemeDataTween({super.begin, super.end});

  @override
  ThemeData lerp(double t) => ThemeData.lerp(begin!, end!, t);
}

/// Animated version of [Theme] which automatically transitions the colors,
/// etc, over a given duration whenever the given theme changes.
///
/// Here's an illustration of what using this widget looks like, using a [curve]
/// of [Curves.elasticInOut].
/// {@animation 250 266 https://flutter.github.io/assets-for-api-docs/assets/widgets/animated_theme.mp4}
///
/// See also:
///
///  * [Theme], which [AnimatedTheme] uses to actually apply the interpolated
///    theme.
///  * [ThemeData], which describes the actual configuration of a theme.
///  * [MaterialApp], which includes an [AnimatedTheme] widget configured via
///    the [MaterialApp.theme] argument.
class AnimatedTheme extends ImplicitlyAnimatedWidget {
  /// Creates an animated theme.
  ///
  /// By default, the theme transition uses a linear curve.
  const AnimatedTheme({
    super.key,
    required this.data,
    super.curve,
    super.duration = kThemeAnimationDuration,
    super.onEnd,
    required this.child,
  });

  /// Specifies the color and typography values for descendant widgets.
  final ThemeData data;

  /// The widget below this widget in the tree.
  ///
  /// {@macro flutter.widgets.ProxyWidget.child}
  final Widget child;

  @override
  AnimatedWidgetBaseState<AnimatedTheme> createState() => _AnimatedThemeState();
}

class _AnimatedThemeState extends AnimatedWidgetBaseState<AnimatedTheme> {
  ThemeDataTween? _data;

  @override
  void forEachTween(TweenVisitor<dynamic> visitor) {
    _data =
        visitor(_data, widget.data, (dynamic value) => ThemeDataTween(begin: value as ThemeData))!
            as ThemeDataTween;
  }

  @override
  Widget build(BuildContext context) {
    return Theme(data: _data!.evaluate(animation), child: widget.child);
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder description) {
    super.debugFillProperties(description);
    description.add(
      DiagnosticsProperty<ThemeDataTween>('data', _data, showName: false, defaultValue: null),
    );
  }
}


Instructions for the chapter (Generate content in English unless specified otherwise):
- Start with a clear heading (e.g., `# Chapter 3: ColorScheme
`). Use the provided concept name.

- If this is not the first chapter, begin with a brief transition from the previous chapter, referencing it with a proper Markdown link using its name.

- Begin with a high-level motivation explaining what problem this abstraction solves. Start with a central use case as a concrete example. The whole chapter should guide the reader to understand how to solve this use case. Make it very minimal and friendly to beginners.

- If the abstraction is complex, break it down into key concepts. Explain each concept one-by-one in a very beginner-friendly way.

- Explain how to use this abstraction to solve the use case. Give example inputs and outputs for code snippets (if the output isn't values, describe at a high level what will happen).

- Each code block should be BELOW 10 lines! If longer code blocks are needed, break them down into smaller pieces and walk through them one-by-one. Aggresively simplify the code to make it minimal. Use comments to skip non-important implementation details. Each code block should have a beginner friendly explanation right after it.

- Describe the internal implementation to help understand what's under the hood. First provide a non-code or code-light walkthrough on what happens step-by-step when the abstraction is called. It's recommended to use a simple sequenceDiagram with a dummy example - keep it minimal with at most 5 participants to ensure clarity. If participant name has space, use: `participant QP as Query Processing`. .

- Then dive deeper into code for the internal implementation with references to files. Provide example code blocks, but make them similarly simple and beginner-friendly. Explain.

- IMPORTANT: When you need to refer to other core abstractions covered in other chapters, ALWAYS use proper Markdown links like this: [Chapter Title](filename.md). Use the Complete Tutorial Structure above to find the correct filename and the chapter title. Translate the surrounding text.

- Use mermaid diagrams to illustrate complex concepts (```mermaid``` format). .

- Heavily use analogies and examples throughout to help beginners understand.

- End the chapter with a brief conclusion that summarizes what was learned and provides a transition to the next chapter. If there is a next chapter, use a proper Markdown link: [Next Chapter Title](next_chapter_filename).

- Ensure the tone is welcoming and easy for a newcomer to understand.

- Output *only* the Markdown content for this chapter.

Now, directly provide a super beginner-friendly Markdown output (DON'T need ```markdown``` tags):

2025-05-28 18:22:12,125 - INFO - RESPONSE: # Chapter 3: ColorScheme

Welcome back! In over the last two chapters, we explored `Theme` which is like applying a design plan, and `ThemeData`, which is the blueprint holding all the details of that plan, including colors, fonts, and component styles.

In this chapter, we're going to focus on a crucial part of `ThemeData`: the `ColorScheme`. Think of `ThemeData` as the overall architecture of your house, and `ColorScheme` as the meticulously selected paint palette for each room, ensuring all the colors work together harmoniously.

### What Problem Does `ColorScheme` Solve?

Setting colors for your app can feel like choosing paint for every single wall and ceiling in a large building. There are background colors, text colors, button colors, error colors, and so many more! If you just pick random colors for each part, your app can end up looking messy and inconsistent. Plus, choosing colors that work well for both light and dark modes, and ensuring enough contrast for accessibility, is a complex task.

`ColorScheme` solves this by defining a standard set of color "roles" based on Material Design principles. Instead of just picking a red, you pick an `error` color. Instead of picking a blue, you pick a `primary` color. This structured approach ensures that colors are used consistently throughout your app, that they look good together, and that they meet accessibility standards more easily.

It's like having a named box of crayons with roles: "main color," "accent color," "warning color," etc. When you need to color something, you pick the crayon whose role fits where the color will be used.

### What is `ColorScheme`?

Similar to `ThemeData`, `ColorScheme` is **not** a widget. It's a **Dart class** that's a collection of named `Color` properties. These properties represent different roles that colors play in a user interface according to Material Design. Some key roles include:

*   `primary`: The main color of your app, used for key elements like the AppBar and primary buttons.
*   `secondary`: A contrasting color, often used for less prominent elements like secondary buttons or filter chips.
*   `error`: The color used to indicate errors, typically red.
*   `surface`: The color used for backgrounds of components like cards and sheets.
*   `onPrimary`, `onSecondary`, `onError`, `onSurface`: These are crucial "on" colors. They are designed to have good contrast with their corresponding base color (e.g., `onPrimary` is for text or icons placed *on* a `primary` colored background).

Creating a simple `ColorScheme` might look like this:

```dart
ColorScheme myColorScheme = const ColorScheme(
  brightness: Brightness.light, // Is this a light or dark scheme?
  primary: Colors.blue,
  onPrimary: Colors.white, // White text on blue is easy to read
  secondary: Colors.green,
  onSecondary: Colors.white, // White text on green is easy to read
  error: Colors.red,
  onError: Colors.white, // White text on red is easy to read
  surface: Colors.white,
  onSurface: Colors.black, // Black text on whiteです easy to read
);
```

This example defines a basic light `ColorScheme` with blue as the primary color, green as the secondary, red for errors, and standard black and white for text and surfaces.

### How to Use `ColorScheme`

You usually don't use a `ColorScheme` object directly everywhere in your code. Instead, you include it as part of your `ThemeData`, and then components automatically pick up the colors they need from the theme.

The most common way to set your app's `ColorScheme` is within the `colorScheme` property of your `ThemeData` when creating it:

```dart
import 'package:flutter/material.dart';

void main() {
  runApp(const MyApp());
}

class MyApp extends StatelessWidget {
  const MyApp({super.key});

  @override
  Widget build(BuildContext context) {
    ColorScheme myColorScheme = const ColorScheme(
      brightness: Brightness.light,
      primary: Colors.deepPurple, // Let's use deep purple!
      onPrimary: Colors.white,
      secondary: Colors.teal, // And teal for secondary
      onSecondary: Colors.white,
      error: Colors.redAccent, // A slightly different red
      onError: Colors.black,
      surface: Colors.grey, // A light grey surface
      onSurface: Colors.black87,
    );

    return MaterialApp(
      title: 'ColorScheme App',
      theme: ThemeData(
        colorScheme: myColorScheme, // Using our custom ColorScheme!
        useMaterial3: true, // Make sure to use Material 3 for the full ColorScheme
      ),
      home: Scaffold(
        appBar: AppBar(
          title: const Text('Home Screen'),
          // AppBar often uses the primary color
          backgroundColor: Theme.of(context).colorScheme.primary,
          foregroundColor: Theme.of(context).colorScheme.onPrimary, // Use onPrimary for text/icons
        ),
        body: Center(
          child: Column(
            mainAxisAlignment: MainAxisAlignment.center,
            children: [
              Text(
                'Primary Color Example',
                style: TextStyle(color: Theme.of(context).colorScheme.primary),
              ),
              const SizedBox(height: 20),
              ElevatedButton(
                onPressed: () {
                  // Do something
                },
                // ElevatedButton often uses primary/onPrimary for its default style
                child: const Text('Primary Button'),
              ),
              const SizedBox(height: 20),
              Text(
                'Secondary Color Example',
                style: TextStyle(color: Theme.of(context).colorScheme.secondary),
              ),
              const SizedBox(height: 20),
              FloatingActionButton(
                onPressed: () {
                  // Do something else
                },
                backgroundColor: Theme.of(context).colorScheme.secondary, // FAB often uses secondary
                foregroundColor: Theme.of(context).colorScheme.onSecondary, // Use onSecondary for icon
                child: const Icon(Icons.add),
              ),
              const SizedBox(height: 20),
              Text(
                'Error Color Example',
                style: TextStyle(color: Theme.of(context).colorScheme.error),
              ),
            ],
          ),
        ),
      ),
    );
  }
}
```

In this slightly longer (but broken down) example:

1.  We create a `ColorScheme` object with specific colors for different roles.
2.  We set this `ColorScheme` to the `colorScheme` property of our `ThemeData`. We also set `useMaterial3: true` because Material 3 heavily relies on the detailed `ColorScheme` roles.
3.  Inside the `Scaffold` and its widgets, we access the `ColorScheme` using `Theme.of(context).colorScheme`.
4.  We explicitly show how some widgets (like `AppBar`, `ElevatedButton`, and `FloatingActionButton`) *often* use specific `ColorScheme` roles for their default appearance. You can manually apply these, but often the widgets themselves will pick them up automatically if not overridden.

Using `ColorScheme` this way centralizes your color definitions and makes it easy to understand how colors should be used throughout your UI.

### Generating `ColorScheme` from a Seed Color

Manually picking all those colors can still be a lot! Fortunately, Material Design 3 provides a powerful way to generate an entire `ColorScheme` from just a single "seed" color. This ensures that all the generated colors are harmonious and meet accessibility standards.

You can use the `ColorScheme.fromSeed` factory constructor:

```dart
import 'package:flutter/material.dart';

void main() {
  runApp(const MyApp());
}

class MyApp extends StatelessWidget {
  const MyApp({super.key});

  @override
  Widget build(BuildContext context) {
    return MaterialApp(
      title: 'Generated ColorScheme App',
      theme: ThemeData(
        // Generate a light ColorScheme from a blue seed color
        colorScheme: ColorScheme.fromSeed(
          seedColor: Colors.blue,
          brightness: Brightness.light,
        ),
        useMaterial3: true,
      ),
      darkTheme: ThemeData(
        // Generate a dark ColorScheme from the same blue seed color
        colorScheme: ColorScheme.fromSeed(
          seedColor: Colors.blue,
          brightness: Brightness.dark,
        ),
        useMaterial3: true,
      ),
      home: Scaffold(
        appBar: AppBar(
          title: const Text('Home Screen'),
        ),
        body: Center(
          child: Column(
            mainAxisAlignment: MainAxisAlignment.center,
            children: [
              Text(
                'Text using primary color',
                style: TextStyle(color: Theme.of(context).colorScheme.primary),
              ),
              const SizedBox(height: 20),
              ElevatedButton(
                onPressed: () {},
                child: const Text('Button'),
              ),
              const SizedBox(height: 20),
              FloatingActionButton(
                onPressed: () {},
                child: const Icon(Icons.add),
              ),
            ],
          ),
        ),
      ),
    );
  }
}
```

In this example:

1.  We use `ColorScheme.fromSeed` with `Colors.blue` to generate a complete `ColorScheme` for both the light and dark themes.
2.  Flutter's Material library handles generating all the roles (primary, secondary, surface, etc.) based on that seed color, ensuring they work well together and meet accessibility standards.
3.  We see that the `AppBar`, `ElevatedButton`, and `FloatingActionButton` automatically pick up the colors from the generated `ColorScheme` roles.

This is the recommended and easiest way to get a consistent and accessible color palette for your app using Material Design 3.

### Under the Hood: `ColorScheme` Generation and Interpolation

How does `ColorScheme.fromSeed` work its magic? Flutter uses a library called `material_color_utilities`. This library implements the Material Design 3 color system, which is based on creating "tonal palettes" from a seed color.

Here's a simplified idea of what happens when you use `ColorScheme.fromSeed`:

```mermaid
sequenceDiagram
    participant App as Your App Code
    participant CSSeed as ColorScheme.fromSeed
    participant MCU as material_color_utilities
    participant CS as ColorScheme Object

    App->>CSSeed: Call ColorScheme.fromSeed(seedColor:...)
    CSSeed->>MCU: Pass seed color and brightness
    MCU->>MCU: Generate tonal palettes based on seed color
    MCU->>MCU: Map tonal palette colors to ColorScheme roles (primary, secondary, surface, etc.)
    MCU-->>CSSeed: Return calculated colors for each role
    CSSeed->>CS: Create new ColorScheme object with calculated colors
    CSSeed-->>App: Return the new ColorScheme object

```

This diagram shows that `ColorScheme.fromSeed` delegates the heavy lifting of color generation to the `material_color_utilities` library. This library takes the seed color, analyzes its properties (like hue and chroma), and generates related colors across different tones that form a harmonious palette. It then assigns these generated colors to the various `ColorScheme` roles.

Looking at the code snippet from `colorscheme.dart`, you can see the `_buildDynamicScheme` method being called, which comes from the `material_color_utilities` library:

```dart
// From packages/flutter/lib/src/material/color_scheme.dart
  factory ColorScheme.fromSeed({
    required Color seedColor,
    Brightness brightness = Brightness.light,
    DynamicSchemeVariant dynamicSchemeVariant = DynamicSchemeVariant.tonalSpot,
    double contrastLevel = 0.0,
    // ... other parameters for overrides
  }) {
    final DynamicScheme scheme = _buildDynamicScheme(
      brightness,
      seedColor,
      dynamicSchemeVariant,
      contrastLevel,
    );

    return ColorScheme(
      primary: primary ?? Color(MaterialDynamicColors.primary.getArgb(scheme)),
      onPrimary: onPrimary ?? Color(MaterialDynamicColors.onPrimary.getArgb(scheme)),
      // ... other ColorScheme roles are set here using colors from the scheme
    );
  }

// (Later in the same file)
static DynamicScheme _buildDynamicScheme(
    Brightness brightness,
    Color seedColor,
    DynamicSchemeVariant schemeVariant,
    double contrastLevel,
  ) {
    final bool isDark = brightness == Brightness.dark;
    final Hct sourceColor = Hct.fromInt(seedColor.value);
    return switch (schemeVariant) {
      DynamicSchemeVariant.tonalSpot => SchemeTonalSpot( // One of the generation algorithms
        sourceColorHct: sourceColor,
        isDark: isDark,
        contrastLevel: contrastLevel,
      ),
      // ... other variants
    };
  }
```

This confirms that `fromSeed` uses an external library (`material_color_utilities`, imported at the top as `MaterialDynamicColors`, `DynamicScheme`, `Hct`, etc.) to build the underlying color `scheme` and then uses colors derived from that scheme to populate the `ColorScheme` properties like `primary` and `onPrimary`.

Just like `ThemeData`, `ColorScheme` also supports smooth transitions between different color schemes using the `ColorScheme.lerp` method internally, which is used when animating theme changes (for example, with `AnimatedTheme`).

```dart
// From packages/flutter/lib/src/material/color_scheme.dart
static ColorScheme lerp(ColorScheme a, ColorScheme b, double t) {
  if (identical(a, b)) {
    return a;
  }
  return ColorScheme(
    brightness: t < 0.5 ? a.brightness : b.brightness,
    primary: Color.lerp(a.primary, b.primary, t)!, // Lerping individual colors
    onPrimary: Color.lerp(a.onPrimary, b.onPrimary, t)!,
    // ... other color properties are lerped
  );
}
```

This shows that the interpolation between two `ColorScheme` objects is done by linearly interpolating each individual color property within the scheme.

### Conclusion

`ColorScheme` is a powerful way to manage your app's color palette in a structured, consistent, and accessible manner. It defines named roles for colors, making it easier to apply and update your app's look. The recommended approach in Material Design 3 is to generate your `ColorScheme` from a single seed color using `ColorScheme.fromSeed`, which leverages the `material_color_utilities` library to create a harmonious and accessible palette. `ColorScheme` is a key part of your `ThemeData` and is automatically used by many Flutter Material widgets.

Now that you understand how `ColorScheme` gives structure to your app's colors within the `ThemeData`, we'll look at how you can add your *own* custom data to the theme with [ThemeExtension](04_themeextension_.md).

[ThemeExtension](04_themeextension_.md)
2025-05-28 18:22:12,131 - INFO - PROMPT: 
Write a very beginner-friendly tutorial chapter (in Markdown format) for the project `flutter` about the concept: "ThemeExtension
". This is Chapter 4.

Concept Details:
- Name: ThemeExtension

- Description:
`ThemeExtension` is like adding extra, custom information to your master plan (`ThemeData`). If the default `ThemeData` doesn't cover everything you need to style, you can create your own extension to include specific properties (like custom colors or text styles) that are unique to your app. This is like adding notes to your house blueprint for special features not included in the standard plan.


Complete Tutorial Structure:
1. [Theme
](01_theme_.md)
2. [ThemeData
](02_themedata_.md)
3. [ColorScheme
](03_colorscheme_.md)
4. [ThemeExtension
](04_themeextension_.md)
5. [VisualDensity
](05_visualdensity_.md)
6. [MaterialTapTargetSize
](06_materialtaptargetsize_.md)
7. [DynamicSchemeVariant
](07_dynamicschemevariant_.md)

Context from previous chapters:
# Chapter 1: Theme

Welcome to the very first chapter on how to make your Flutter app look great! In this chapter, we're going to talk about a really important concept called `Theme`.

Imagine you're decorating a room. You pick a color palette, decide on the furniture style, and choose the overall "feel" you want the room to have. In Flutter, `Theme` is kind of like applying that master decoration plan (`ThemeData`) to a specific part of your app's screen.

### What Problem Does `Theme` Solve?

Think about building an app with lots of buttons, text, and other visual elements. If you had to set the color, font size, and style for *each* button and *each* piece of text individually, it would be a lot of work! And if you ever wanted to change your app's look (maybe switch from light mode to dark mode), you'd have to update *everything* manually. That sounds like a nightmare!

`Theme` solves this problem by letting you define a set of styles and colors in one place, and then easily apply those styles to different parts of your app. When you change the `Theme`, all the widgets that use that theme will automatically update their appearance. It's like changing the paint color for a whole room with just one click!

### What is `Theme`?

In Flutter, `Theme` is actually a **widget**. Widgets are the building blocks of Flutter apps. The `Theme` widget is a *special* kind of widget because it doesn't just show something on the screen; it influences how the widgets *below* it in the widget tree look.

When you place a `Theme` widget around other widgets, you're essentially telling all those widgets to follow the style rules defined in the `Theme`.

Here's a super simple peek at what using `Theme` looks like:

```dart
MaterialApp(
  home: Scaffold(
    body: Theme( // Here's the Theme widget!
      data: ThemeData( // We'll learn about this in the next chapter!
        primaryColor: Colors.blue,
        // Other style settings...
      ),
      child: Center(
        child: Text(
          'Hello, Themed Text!',
        ),
      ),
    ),
  ),
);
```

In this example, we're wrapping a `Center` widget (which contains a `Text` widget) with a `Theme` widget. We're giving the `Theme` some `data` (we'll dive deep into `ThemeData` in the next chapter!), and this `data` tells it how things like primary colors should look. Any widgets inside this `Theme` that use primary colors will now use the blue color we specified.

### How `Theme` Works (Under the Hood)

You might be wondering how a widget can "talk" to the widgets below it. Flutter uses a system called "Inherited Widgets" for this. `Theme` is an example of an inherited widget.

Think of an inherited widget like a shop sign that everyone in the building can see and use. When a widget needs some information (like what the theme color should be), it "looks up" the widget tree until it finds the nearest `Theme` widget. Then it uses the `data` from that `Theme` widget to style itself.

Here's a simplified idea of how a `Text` widget might get its color:

```mermaid
sequenceDiagram
    participant T as Text Widget
    participant B as BuildContext
    participant TH as Theme Widget
    participant TD as ThemeData

    T->>B: "Hey BuildContext, what's the current theme data?"
    B->>TH: "Nearest Theme widget, what's your data?"
    TH->>TD: "ThemeData object, what's the text color?"
    TD-->>TH: Returns text color
    TH-->>B: Returns text color
    B-->>T: Returns text color
    T->>T: Displays text with that color
```
This diagram shows a `Text` widget asking its `BuildContext` (which connects it to the widget tree) for the theme information. The `BuildContext` then finds the `Theme` widget, which provides the `ThemeData`. The `Text` widget can then use this `ThemeData` to decide how it should look.

The core of this mechanism is the `Theme.of(BuildContext context)` method. This is the standard way for any widget in Flutter to access the theme information from the nearest `Theme` ancestor in the tree. You'll see `Theme.of(context)` very often in Flutter code!

Looking at the `Theme.of` method in the `theme.dart` file, you can see how it uses `context.dependOnInheritedWidgetOfExactType<_InheritedTheme>()` to find the nearest `_InheritedTheme` (which is the internal widget Flutter uses for the `Theme`).

```dart
// From packages/flutter/lib/src/material/theme.dart
static ThemeData of(BuildContext context) {
  final _InheritedTheme? inheritedTheme =
      context.dependOnInheritedWidgetOfExactType<_InheritedTheme>();
  // ... other logic ...
  final ThemeData theme =
      inheritedTheme?.theme.data ??
      // ... fallback logic ...
      _kFallbackTheme;
  return ThemeData.localize(theme, theme.typography.geometryThemeFor(category));
}
```
Don't worry too much about all the details here; the key is that `dependOnInheritedWidgetOfExactType` is the magic that allows a widget to look up the tree and get information from a parent `Theme` widget.

### Applying `Theme` to a Part of Your App

You can use the `Theme` widget to apply different themes to different parts of your app. For example, you might have a standard theme for most of your app, but a specific section might have a slightly different look, perhaps highlighting a special feature.

```dart
// Imagine this is somewhere inside your app's build method
Column(
  children: [
    Text('Regular Text'), // This uses the main app theme
    Theme( // Applying a different theme here
      data: ThemeData(
        primaryColor: Colors.green, // A different color
      ),
      child: ElevatedButton( // This button will use the green primary color
        onPressed: () {},
        child: Text('Green Button'),
      ),
    ),
    Text('More Regular Text'), // This goes back to the main app theme
  ],
)
```

In this example, the `ElevatedButton` inside the second `Theme` widget will use the specified green color for its primary color, while the `Text` widgets will use the colors from the `ThemeData` higher up in the widget tree (likely from your `MaterialApp`).

This ability to apply themes to specific subtrees of your app gives you a lot of flexibility in designing your UI.

### Conclusion

In this chapter, we learned that `Theme` is a fundamental Flutter widget used to apply styles and visual configurations (`ThemeData`) to parts of your application. It helps you manage your app's look in a consistent and efficient way. We saw how `Theme` works using the concept of inherited widgets and how you can apply different themes to different sections of your app.

Now that you have a basic understanding of `Theme`, the next step is to explore what actually *goes inside* the `Theme` widget: the `ThemeData`.

[ThemeData](02_themedata_.md)
---
# Chapter 2: ThemeData

Welcome back! In the last chapter, we learned about the `Theme` widget, which is like a magical box that applies a design plan to parts of your Flutter app. But what exactly is that design plan? That's where `ThemeData` comes in!

### What Problem Does `ThemeData` Solve?

Imagine you're building a large app with many screens. Each screen has buttons, text, backgrounds, and more. If you had to manually pick colors and font styles for every single item on every single screen, it would be a huge mess! What if your company decided to change the main brand color? You'd have to go through your entire app, finding every place you used the old color and replacing it with the new one. This is time-consuming and prone to errors.

`ThemeData` solves this problem by being a central place where you define the overall look and feel of your app. It's like having a style guide for your entire application. Instead of styling each individual button, you define the *default* style for *all* buttons in your `ThemeData`. Then, every button in your app will automatically follow that default style. If you want to change the button style later, you just update the `ThemeData`, and all your buttons instantly change!

Think of it as choosing all the paint colors, furniture styles, and lighting fixtures for an entire house *before* you start decorating any specific room. `ThemeData` is that master plan.

### What is `ThemeData`?

`ThemeData` is **not** a widget. Unlike the `Theme` widget (which you place in your app's layout), `ThemeData` is simply a **Dart class** that holds a bunch of properties about your app's theme. These properties include things like:

*   **Colors:** The main colors used in your app, like the primary color, accent color, background color, etc. (We'll talk even more about colors in the next chapter on [ColorScheme](03_colorscheme_.md)!).
*   **Text Styles:** The default fonts, sizes, and weights for different types of text (headings, body text, captions).
*   **Component Themes:** Specific default styles for individual widgets like buttons (`ElevatedButtonThemeData`, `TextButtonThemeData`), App Bars (`AppBarTheme`), dialogs (`DialogThemeData`), and many more.

Here's a simple example of creating a basic `ThemeData`:

```dart
ThemeData myCustomTheme = ThemeData(
  primarySwatch: Colors.purple, // A collection of purple shades
  textTheme: TextTheme( // Defining text styles
    bodyMedium: TextStyle(fontSize: 16.0),
  ),
  elevatedButtonTheme: ElevatedButtonThemeData( // Styling the button
    style: ElevatedButton.styleFrom(
      backgroundColor: Colors.deepOrange, // Button color
      foregroundColor: Colors.white, // Text color on the button
    ),
  ),
);
```

In this code snippet, we're creating a `ThemeData` object named `myCustomTheme`. We're setting the `primarySwatch` to purple (which provides different shades of purple), defining a default style for body text, and setting a specific background and text color for `ElevatedButton`s.

### How to Use `ThemeData`

You typically use your `ThemeData` object within a `Theme` widget (like we saw in Chapter 1) or within the `theme` property of your `MaterialApp` (which is the most common way to set the theme for your entire app).

Here's how you'd apply the `myCustomTheme` from the previous example to your whole app using `MaterialApp`:

```dart
import 'package:flutter/material.dart';

void main() {
  runApp(const MyApp());
}

class MyApp extends StatelessWidget {
  const MyApp({super.key});

  @override
  Widget build(BuildContext context) {
    ThemeData myCustomTheme = ThemeData(
      primarySwatch: Colors.purple,
      textTheme: const TextTheme(
        bodyMedium: TextStyle(fontSize: 16.0),
      ),
      elevatedButtonTheme: ElevatedButtonThemeData(
        style: ElevatedButton.styleFrom(
          backgroundColor: Colors.deepOrange,
          foregroundColor: Colors.white,
        ),
      ),
    );

    return MaterialApp(
      title: 'Themed App',
      theme: myCustomTheme, // Applying our custom theme!
      home: Scaffold(
        appBar: AppBar(
          title: const Text('Home Screen'),
        ),
        body: Center(
          child: Column(
            mainAxisAlignment: MainAxisAlignment.center,
            children: [
              Text(
                'This text uses the default bodyMedium style.',
              ),
              const SizedBox(height: 20),
              ElevatedButton(
                onPressed: () {
                  // Do something
                },
                child: const Text('Styled Button'),
              ),
            ],
          ),
        ),
      ),
    );
  }
}
```

In this example, because we set `myCustomTheme` in the `theme` property of `MaterialApp`, the `AppBar` will likely pick colors based on the `primarySwatch` (purple), the first `Text` widget will use the `bodyMedium` style (16.0 font size), and the `ElevatedButton` will have a deep orange background and white text. All these styles are defined just once in our `ThemeData`!

### Default `ThemeData`

Flutter provides default light and dark themes out of the box. You can easily use these by setting the `theme` property of your `MaterialApp` to `ThemeData.light()` or `ThemeData.dark()`.

```dart
MaterialApp(
  title: 'Default Light Theme App',
  theme: ThemeData.light(), // Using the default light theme
  home: Scaffold(
    appBar: AppBar(title: Text('Light Theme')),
    body: Center(child: Text('Default colors and fonts')),
  ),
);
```

You can also start with a default theme and then modify specific parts using `copyWith`:

```dart
ThemeData lightThemeWithRedButtons = ThemeData.light().copyWith(
  elevatedButtonTheme: ElevatedButtonThemeData(
    style: ElevatedButton.styleFrom(
      backgroundColor: Colors.red, // Only change button color
      foregroundColor: Colors.white,
    ),
  ),
);

MaterialApp(
  title: 'Customized Light Theme App',
  theme: lightThemeWithRedButtons, // Using the customized light theme
  home: Scaffold(
    appBar: AppBar(title: Text('Custom Theme')),
    body: Center(
      child: ElevatedButton(
        onPressed: () {},
        child: Text('Red Button'),
      ),
    ),
  ),
);
```

This is a powerful way to quickly customize a few things while keeping the rest of the standard Material Design look.

### Under the Hood: `ThemeData.raw` and Interpolation

While you'll mostly use the main `ThemeData` constructor or `ThemeData.light()/dark()`, it's good to know that there's also a `ThemeData.raw` constructor. This constructor is used internally by Flutter, especially for smoothly transitioning between themes (like when switching from light to dark mode).

The `ThemeData.raw` constructor requires you to provide *every single* theme property. This seems like a lot, because it is! It's not meant for you to use directly very often. Its purpose is to allow for linear interpolation between two `ThemeData` objects when animating theme changes (which happens automatically with `AnimatedTheme`).

Here's a simplified idea of how animating themes might work:

```mermaid
sequenceDiagram
    participant AT as AnimatedTheme
    participant TD1 as ThemeData (Start)
    participant TD2 as ThemeData (End)
    participant TD_lerp as ThemeData (Interpolated)

    AT->>TD1: Get initial ThemeData
    AT->>TD2: Get final ThemeData
    AT->>AT: Start Animation (t from 0 to 1)
    loop For each animation step
        AT->>TD1: Get value (e.g. color)
        AT->>TD2: Get matching value (e.g. color)
        AT->>TD_lerp: Calculate interpolated value (lerpColor(color1, color2, t))
        TD_lerp-->>AT: Return interpolated value
    end
    AT->>AT: Pass interpolated ThemeData down widget tree
```

This diagram shows that when `AnimatedTheme` changes, it doesn't just swap `ThemeData` instantly. It uses the `ThemeData.lerp` method to calculate intermediate `ThemeData` objects based on how far the animation has progressed (`t`). This creates a smooth visual transition, for example, colors fading from one to another. The `ThemeData.raw` constructor is what `ThemeData.lerp` uses to construct these intermediate theme data objects.

Looking at the `ThemeData.lerp` code snippet, you can see it calls `Color.lerp`, `TextTheme.lerp`, and other `lerp` methods for individual theme properties:

```dart
// From packages/flutter/lib/src/material/theme_data.dart
static ThemeData lerp(ThemeData a, ThemeData b, double t) {
  if (identical(a, b)) {
    return a;
  }
  return ThemeData.raw(
    // ... other properties
    canvasColor: Color.lerp(a.canvasColor, b.canvasColor, t)!, // Interpolating colors
    // ... other properties
    textTheme: TextTheme.lerp(a.textTheme, b.textTheme, t), // Interpolating text styles
    // ... other properties
  );
}
```

This shows how `ThemeData.lerp` combines the individual properties from two themes based on the interpolation factor `t` (which goes from 0 to 1 during the animation) and uses `ThemeData.raw` to build the resulting interpolated theme.

### Conclusion

`ThemeData` is the blueprint for your app's visual design. By defining colors, text styles, and component appearances in a single place using `ThemeData`, you make your app's look consistent and easy to manage and update. You can use the default light or dark themes, create your own entirely, or modify existing ones. `ThemeData` also supports animating visual changes smoothly using interpolation, leveraging the `ThemeData.raw` constructor internally.

In the next chapter, we'll dive deeper into the concept of [ColorScheme](03_colorscheme_.md), which is a very important part of `ThemeData` and a modern way to manage your app's colors according to Material Design principles.

[ColorScheme](03_colorscheme_.md)
---
# Chapter 3: ColorScheme

Welcome back! In over the last two chapters, we explored `Theme` which is like applying a design plan, and `ThemeData`, which is the blueprint holding all the details of that plan, including colors, fonts, and component styles.

In this chapter, we're going to focus on a crucial part of `ThemeData`: the `ColorScheme`. Think of `ThemeData` as the overall architecture of your house, and `ColorScheme` as the meticulously selected paint palette for each room, ensuring all the colors work together harmoniously.

### What Problem Does `ColorScheme` Solve?

Setting colors for your app can feel like choosing paint for every single wall and ceiling in a large building. There are background colors, text colors, button colors, error colors, and so many more! If you just pick random colors for each part, your app can end up looking messy and inconsistent. Plus, choosing colors that work well for both light and dark modes, and ensuring enough contrast for accessibility, is a complex task.

`ColorScheme` solves this by defining a standard set of color "roles" based on Material Design principles. Instead of just picking a red, you pick an `error` color. Instead of picking a blue, you pick a `primary` color. This structured approach ensures that colors are used consistently throughout your app, that they look good together, and that they meet accessibility standards more easily.

It's like having a named box of crayons with roles: "main color," "accent color," "warning color," etc. When you need to color something, you pick the crayon whose role fits where the color will be used.

### What is `ColorScheme`?

Similar to `ThemeData`, `ColorScheme` is **not** a widget. It's a **Dart class** that's a collection of named `Color` properties. These properties represent different roles that colors play in a user interface according to Material Design. Some key roles include:

*   `primary`: The main color of your app, used for key elements like the AppBar and primary buttons.
*   `secondary`: A contrasting color, often used for less prominent elements like secondary buttons or filter chips.
*   `error`: The color used to indicate errors, typically red.
*   `surface`: The color used for backgrounds of components like cards and sheets.
*   `onPrimary`, `onSecondary`, `onError`, `onSurface`: These are crucial "on" colors. They are designed to have good contrast with their corresponding base color (e.g., `onPrimary` is for text or icons placed *on* a `primary` colored background).

Creating a simple `ColorScheme` might look like this:

```dart
ColorScheme myColorScheme = const ColorScheme(
  brightness: Brightness.light, // Is this a light or dark scheme?
  primary: Colors.blue,
  onPrimary: Colors.white, // White text on blue is easy to read
  secondary: Colors.green,
  onSecondary: Colors.white, // White text on green is easy to read
  error: Colors.red,
  onError: Colors.white, // White text on red is easy to read
  surface: Colors.white,
  onSurface: Colors.black, // Black text on whiteです easy to read
);
```

This example defines a basic light `ColorScheme` with blue as the primary color, green as the secondary, red for errors, and standard black and white for text and surfaces.

### How to Use `ColorScheme`

You usually don't use a `ColorScheme` object directly everywhere in your code. Instead, you include it as part of your `ThemeData`, and then components automatically pick up the colors they need from the theme.

The most common way to set your app's `ColorScheme` is within the `colorScheme` property of your `ThemeData` when creating it:

```dart
import 'package:flutter/material.dart';

void main() {
  runApp(const MyApp());
}

class MyApp extends StatelessWidget {
  const MyApp({super.key});

  @override
  Widget build(BuildContext context) {
    ColorScheme myColorScheme = const ColorScheme(
      brightness: Brightness.light,
      primary: Colors.deepPurple, // Let's use deep purple!
      onPrimary: Colors.white,
      secondary: Colors.teal, // And teal for secondary
      onSecondary: Colors.white,
      error: Colors.redAccent, // A slightly different red
      onError: Colors.black,
      surface: Colors.grey, // A light grey surface
      onSurface: Colors.black87,
    );

    return MaterialApp(
      title: 'ColorScheme App',
      theme: ThemeData(
        colorScheme: myColorScheme, // Using our custom ColorScheme!
        useMaterial3: true, // Make sure to use Material 3 for the full ColorScheme
      ),
      home: Scaffold(
        appBar: AppBar(
          title: const Text('Home Screen'),
          // AppBar often uses the primary color
          backgroundColor: Theme.of(context).colorScheme.primary,
          foregroundColor: Theme.of(context).colorScheme.onPrimary, // Use onPrimary for text/icons
        ),
        body: Center(
          child: Column(
            mainAxisAlignment: MainAxisAlignment.center,
            children: [
              Text(
                'Primary Color Example',
                style: TextStyle(color: Theme.of(context).colorScheme.primary),
              ),
              const SizedBox(height: 20),
              ElevatedButton(
                onPressed: () {
                  // Do something
                },
                // ElevatedButton often uses primary/onPrimary for its default style
                child: const Text('Primary Button'),
              ),
              const SizedBox(height: 20),
              Text(
                'Secondary Color Example',
                style: TextStyle(color: Theme.of(context).colorScheme.secondary),
              ),
              const SizedBox(height: 20),
              FloatingActionButton(
                onPressed: () {
                  // Do something else
                },
                backgroundColor: Theme.of(context).colorScheme.secondary, // FAB often uses secondary
                foregroundColor: Theme.of(context).colorScheme.onSecondary, // Use onSecondary for icon
                child: const Icon(Icons.add),
              ),
              const SizedBox(height: 20),
              Text(
                'Error Color Example',
                style: TextStyle(color: Theme.of(context).colorScheme.error),
              ),
            ],
          ),
        ),
      ),
    );
  }
}
```

In this slightly longer (but broken down) example:

1.  We create a `ColorScheme` object with specific colors for different roles.
2.  We set this `ColorScheme` to the `colorScheme` property of our `ThemeData`. We also set `useMaterial3: true` because Material 3 heavily relies on the detailed `ColorScheme` roles.
3.  Inside the `Scaffold` and its widgets, we access the `ColorScheme` using `Theme.of(context).colorScheme`.
4.  We explicitly show how some widgets (like `AppBar`, `ElevatedButton`, and `FloatingActionButton`) *often* use specific `ColorScheme` roles for their default appearance. You can manually apply these, but often the widgets themselves will pick them up automatically if not overridden.

Using `ColorScheme` this way centralizes your color definitions and makes it easy to understand how colors should be used throughout your UI.

### Generating `ColorScheme` from a Seed Color

Manually picking all those colors can still be a lot! Fortunately, Material Design 3 provides a powerful way to generate an entire `ColorScheme` from just a single "seed" color. This ensures that all the generated colors are harmonious and meet accessibility standards.

You can use the `ColorScheme.fromSeed` factory constructor:

```dart
import 'package:flutter/material.dart';

void main() {
  runApp(const MyApp());
}

class MyApp extends StatelessWidget {
  const MyApp({super.key});

  @override
  Widget build(BuildContext context) {
    return MaterialApp(
      title: 'Generated ColorScheme App',
      theme: ThemeData(
        // Generate a light ColorScheme from a blue seed color
        colorScheme: ColorScheme.fromSeed(
          seedColor: Colors.blue,
          brightness: Brightness.light,
        ),
        useMaterial3: true,
      ),
      darkTheme: ThemeData(
        // Generate a dark ColorScheme from the same blue seed color
        colorScheme: ColorScheme.fromSeed(
          seedColor: Colors.blue,
          brightness: Brightness.dark,
        ),
        useMaterial3: true,
      ),
      home: Scaffold(
        appBar: AppBar(
          title: const Text('Home Screen'),
        ),
        body: Center(
          child: Column(
            mainAxisAlignment: MainAxisAlignment.center,
            children: [
              Text(
                'Text using primary color',
                style: TextStyle(color: Theme.of(context).colorScheme.primary),
              ),
              const SizedBox(height: 20),
              ElevatedButton(
                onPressed: () {},
                child: const Text('Button'),
              ),
              const SizedBox(height: 20),
              FloatingActionButton(
                onPressed: () {},
                child: const Icon(Icons.add),
              ),
            ],
          ),
        ),
      ),
    );
  }
}
```

In this example:

1.  We use `ColorScheme.fromSeed` with `Colors.blue` to generate a complete `ColorScheme` for both the light and dark themes.
2.  Flutter's Material library handles generating all the roles (primary, secondary, surface, etc.) based on that seed color, ensuring they work well together and meet accessibility standards.
3.  We see that the `AppBar`, `ElevatedButton`, and `FloatingActionButton` automatically pick up the colors from the generated `ColorScheme` roles.

This is the recommended and easiest way to get a consistent and accessible color palette for your app using Material Design 3.

### Under the Hood: `ColorScheme` Generation and Interpolation

How does `ColorScheme.fromSeed` work its magic? Flutter uses a library called `material_color_utilities`. This library implements the Material Design 3 color system, which is based on creating "tonal palettes" from a seed color.

Here's a simplified idea of what happens when you use `ColorScheme.fromSeed`:

```mermaid
sequenceDiagram
    participant App as Your App Code
    participant CSSeed as ColorScheme.fromSeed
    participant MCU as material_color_utilities
    participant CS as ColorScheme Object

    App->>CSSeed: Call ColorScheme.fromSeed(seedColor:...)
    CSSeed->>MCU: Pass seed color and brightness
    MCU->>MCU: Generate tonal palettes based on seed color
    MCU->>MCU: Map tonal palette colors to ColorScheme roles (primary, secondary, surface, etc.)
    MCU-->>CSSeed: Return calculated colors for each role
    CSSeed->>CS: Create new ColorScheme object with calculated colors
    CSSeed-->>App: Return the new ColorScheme object

```

This diagram shows that `ColorScheme.fromSeed` delegates the heavy lifting of color generation to the `material_color_utilities` library. This library takes the seed color, analyzes its properties (like hue and chroma), and generates related colors across different tones that form a harmonious palette. It then assigns these generated colors to the various `ColorScheme` roles.

Looking at the code snippet from `colorscheme.dart`, you can see the `_buildDynamicScheme` method being called, which comes from the `material_color_utilities` library:

```dart
// From packages/flutter/lib/src/material/color_scheme.dart
  factory ColorScheme.fromSeed({
    required Color seedColor,
    Brightness brightness = Brightness.light,
    DynamicSchemeVariant dynamicSchemeVariant = DynamicSchemeVariant.tonalSpot,
    double contrastLevel = 0.0,
    // ... other parameters for overrides
  }) {
    final DynamicScheme scheme = _buildDynamicScheme(
      brightness,
      seedColor,
      dynamicSchemeVariant,
      contrastLevel,
    );

    return ColorScheme(
      primary: primary ?? Color(MaterialDynamicColors.primary.getArgb(scheme)),
      onPrimary: onPrimary ?? Color(MaterialDynamicColors.onPrimary.getArgb(scheme)),
      // ... other ColorScheme roles are set here using colors from the scheme
    );
  }

// (Later in the same file)
static DynamicScheme _buildDynamicScheme(
    Brightness brightness,
    Color seedColor,
    DynamicSchemeVariant schemeVariant,
    double contrastLevel,
  ) {
    final bool isDark = brightness == Brightness.dark;
    final Hct sourceColor = Hct.fromInt(seedColor.value);
    return switch (schemeVariant) {
      DynamicSchemeVariant.tonalSpot => SchemeTonalSpot( // One of the generation algorithms
        sourceColorHct: sourceColor,
        isDark: isDark,
        contrastLevel: contrastLevel,
      ),
      // ... other variants
    };
  }
```

This confirms that `fromSeed` uses an external library (`material_color_utilities`, imported at the top as `MaterialDynamicColors`, `DynamicScheme`, `Hct`, etc.) to build the underlying color `scheme` and then uses colors derived from that scheme to populate the `ColorScheme` properties like `primary` and `onPrimary`.

Just like `ThemeData`, `ColorScheme` also supports smooth transitions between different color schemes using the `ColorScheme.lerp` method internally, which is used when animating theme changes (for example, with `AnimatedTheme`).

```dart
// From packages/flutter/lib/src/material/color_scheme.dart
static ColorScheme lerp(ColorScheme a, ColorScheme b, double t) {
  if (identical(a, b)) {
    return a;
  }
  return ColorScheme(
    brightness: t < 0.5 ? a.brightness : b.brightness,
    primary: Color.lerp(a.primary, b.primary, t)!, // Lerping individual colors
    onPrimary: Color.lerp(a.onPrimary, b.onPrimary, t)!,
    // ... other color properties are lerped
  );
}
```

This shows that the interpolation between two `ColorScheme` objects is done by linearly interpolating each individual color property within the scheme.

### Conclusion

`ColorScheme` is a powerful way to manage your app's color palette in a structured, consistent, and accessible manner. It defines named roles for colors, making it easier to apply and update your app's look. The recommended approach in Material Design 3 is to generate your `ColorScheme` from a single seed color using `ColorScheme.fromSeed`, which leverages the `material_color_utilities` library to create a harmonious and accessible palette. `ColorScheme` is a key part of your `ThemeData` and is automatically used by many Flutter Material widgets.

Now that you understand how `ColorScheme` gives structure to your app's colors within the `ThemeData`, we'll look at how you can add your *own* custom data to the theme with [ThemeExtension](04_themeextension_.md).

[ThemeExtension](04_themeextension_.md)

Relevant Code Snippets (Code itself remains unchanged):
--- File: packages/flutter/lib/src/material/theme_data.dart ---
// Copyright 2014 The Flutter Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

/// @docImport 'package:flutter/material.dart';
library;

import 'dart:ui' show Color, lerpDouble;

import 'package:flutter/cupertino.dart';
import 'package:flutter/foundation.dart';

import 'action_buttons.dart';
import 'action_icons_theme.dart';
import 'app_bar_theme.dart';
import 'badge_theme.dart';
import 'banner_theme.dart';
import 'bottom_app_bar_theme.dart';
import 'bottom_navigation_bar_theme.dart';
import 'bottom_sheet_theme.dart';
import 'button_bar_theme.dart';
import 'button_theme.dart';
import 'card_theme.dart';
import 'checkbox_theme.dart';
import 'chip_theme.dart';
import 'color_scheme.dart';
import 'colors.dart';
import 'constants.dart';
import 'data_table_theme.dart';
import 'date_picker_theme.dart';
import 'dialog_theme.dart';
import 'divider_theme.dart';
import 'drawer_theme.dart';
import 'dropdown_menu_theme.dart';
import 'elevated_button_theme.dart';
import 'expansion_tile_theme.dart';
import 'filled_button_theme.dart';
import 'floating_action_button_theme.dart';
import 'icon_button_theme.dart';
import 'ink_ripple.dart';
import 'ink_sparkle.dart';
import 'ink_splash.dart';
import 'ink_well.dart' show InteractiveInkFeatureFactory;
import 'input_decorator.dart';
import 'list_tile.dart';
import 'list_tile_theme.dart';
import 'menu_bar_theme.dart';
import 'menu_button_theme.dart';
import 'menu_theme.dart';
import 'navigation_bar_theme.dart';
import 'navigation_drawer_theme.dart';
import 'navigation_rail_theme.dart';
import 'outlined_button_theme.dart';
import 'page_transitions_theme.dart';
import 'popup_menu_theme.dart';
import 'progress_indicator_theme.dart';
import 'radio_theme.dart';
import 'scrollbar_theme.dart';
import 'search_bar_theme.dart';
import 'search_view_theme.dart';
import 'segmented_button_theme.dart';
import 'slider_theme.dart';
import 'snack_bar_theme.dart';
import 'switch_theme.dart';
import 'tab_bar_theme.dart';
import 'text_button_theme.dart';
import 'text_selection_theme.dart';
import 'text_theme.dart';
import 'time_picker_theme.dart';
import 'toggle_buttons_theme.dart';
import 'tooltip_theme.dart';
import 'typography.dart';

export 'package:flutter/services.dart' show Brightness;

// Examples can assume:
// late BuildContext context;

/// Defines a customized theme for components with an `adaptive` factory constructor.
///
/// Currently, only [Switch.adaptive] supports this class.
class Adaptation<T> {
  /// Creates an [Adaptation].
  const Adaptation();

  /// The adaptation's type.
  Type get type => T;

  /// Typically, this is overridden to return an instance of a custom component
  /// ThemeData class, like [SwitchThemeData], instead of the defaultValue.
  ///
  /// Factory constructors that support adaptations - currently only
  /// [Switch.adaptive] - look for a type-specific adaptation in
  /// [ThemeData.adaptationMap] when computing their effective default component
  /// theme. If a matching adaptation is not found, the component may choose to
  /// use a default adaptation. For example, the [Switch.adaptive] component
  /// uses an empty [SwitchThemeData] if a matching adaptation is not found, for
  /// the sake of backwards compatibility.
  ///
  /// {@tool dartpad}
  /// This sample shows how to create and use subclasses of [Adaptation] that
  /// define adaptive [SwitchThemeData]s. The [adapt] method in this example is
  /// overridden to only customize cupertino-style switches, but it can also be
  /// used to customize any other platforms.
  ///
  /// ** See code in examples/api/lib/material/switch/switch.4.dart **
  /// {@end-tool}
  T adapt(ThemeData theme, T defaultValue) => defaultValue;
}

/// An interface that defines custom additions to a [ThemeData] object.
///
/// {@youtube 560 315 https://www.youtube.com/watch?v=8-szcYzFVao}
///
/// Typically used for custom colors. To use, subclass [ThemeExtension],
/// define a number of fields (e.g. [Color]s), and implement the [copyWith] and
/// [lerp] methods. The latter will ensure smooth transitions of properties when
/// switching themes.
///
/// {@tool dartpad}
/// This sample shows how to create and use a subclass of [ThemeExtension] that
/// defines two colors.
///
/// ** See code in examples/api/lib/material/theme/theme_extension.1.dart **
/// {@end-tool}
abstract class ThemeExtension<T extends ThemeExtension<T>> {
  /// Enable const constructor for subclasses.
  const ThemeExtension();

  /// The extension's type.
  Object get type => T;

  /// Creates a copy of this theme extension with the given fields
  /// replaced by the non-null parameter values.
  ThemeExtension<T> copyWith();

  /// Linearly interpolate with another [ThemeExtension] object.
  ///
  /// {@macro dart.ui.shadow.lerp}
  ThemeExtension<T> lerp(covariant ThemeExtension<T>? other, double t);
}

/// Configures the tap target and layout size of certain Material widgets.
///
/// Changing the value in [ThemeData.materialTapTargetSize] will affect the
/// accessibility experience.
///
/// Some of the impacted widgets include:
///
///   * [FloatingActionButton], only the mini tap target size is increased.
///   * [MaterialButton]
///   * [OutlinedButton]
///   * [TextButton]
///   * [ElevatedButton]
///   * [IconButton]
///   * The time picker widget ([showTimePicker])
///   * [SnackBar]
///   * [Chip]
///   * [RawChip]
///   * [InputChip]
///   * [ChoiceChip]
///   * [FilterChip]
///   * [ActionChip]
///   * [Radio]
///   * [Switch]
///   * [Checkbox]
enum MaterialTapTargetSize {
  /// Expands the minimum tap target size to 48px by 48px.
  ///
  /// This is the default value of [ThemeData.materialTapTargetSize] and the
  /// recommended size to conform to Android accessibility scanner
  /// recommendations.
  padded,

  /// Shrinks the tap target size to the minimum provided by the Material
  /// specification.
  shrinkWrap,
}

/// Defines the configuration of the overall visual [Theme] for a [MaterialApp]
/// or a widget subtree within the app.
///
/// The [MaterialApp] theme property can be used to configure the appearance
/// of the entire app. Widget subtrees within an app can override the app's
/// theme by including a [Theme] widget at the top of the subtree.
///
/// Widgets whose appearance should align with the overall theme can obtain the
/// current theme's configuration with [Theme.of]. Material components typically
/// depend exclusively on the [colorScheme] and [textTheme]. These properties
/// are guaranteed to have non-null values.
///
/// The static [Theme.of] method finds the [ThemeData] value specified for the
/// nearest [BuildContext] ancestor. This lookup is inexpensive, essentially
/// just a single HashMap access. It can sometimes be a little confusing
/// because [Theme.of] can not see a [Theme] widget that is defined in the
/// current build method's context. To overcome that, create a new custom widget
/// for the subtree that appears below the new [Theme], or insert a widget
/// that creates a new BuildContext, like [Builder].
///
/// {@tool dartpad}
/// This example demonstrates how a typical [MaterialApp] specifies
/// and uses a custom [Theme]. The theme's [ColorScheme] is based on a
/// single "seed" color and configures itself to match the platform's
/// current light or dark color configuration. The theme overrides the
/// default configuration of [FloatingActionButton] to show how to
/// customize the appearance a class of components.
///
/// ** See code in examples/api/lib/material/theme_data/theme_data.0.dart **
/// {@end-tool}
///
/// See <https://material.io/design/color/> for
/// more discussion on how to pick the right colors.

@immutable
class ThemeData with Diagnosticable {
  /// Create a [ThemeData] that's used to configure a [Theme].
  ///
  /// The [colorScheme] and [textTheme] are used by the Material components to
  /// compute default values for visual properties. The API documentation for
  /// each component widget explains exactly how the defaults are computed.
  ///
  /// When providing a [ColorScheme], apps can either provide one directly
  /// with the [colorScheme] parameter, or have one generated for them by
  /// using the [colorSchemeSeed] and [brightness] parameters. A generated
  /// color scheme will be based on the tones of [colorSchemeSeed] and all of
  /// its contrasting color will meet accessibility guidelines for readability.
  /// (See [ColorScheme.fromSeed] for more details.)
  ///
  /// If the app wants to customize a generated color scheme, it can use
  /// [ColorScheme.fromSeed] directly and then [ColorScheme.copyWith] on the
  /// result to override any colors that need to be replaced. The result of
  /// this can be used as the [colorScheme] directly.
  ///
  /// For historical reasons, instead of using a [colorSchemeSeed] or
  /// [colorScheme], you can provide either a [primaryColor] or [primarySwatch]
  /// to construct the [colorScheme], but the results will not be as complete
  /// as when using generation from a seed color.
  ///
  /// If [colorSchemeSeed] is non-null then [colorScheme], [primaryColor] and
  /// [primarySwatch] must all be null.
  ///
  /// The [textTheme] [TextStyle] colors are black if the color scheme's
  /// brightness is [Brightness.light], and white for [Brightness.dark].
  ///
  /// To override the appearance of specific components, provide
  /// a component theme parameter like [sliderTheme], [toggleButtonsTheme],
  /// or [bottomNavigationBarTheme].
  ///
  /// See also:
  ///
  ///  * [ThemeData.from], which creates a ThemeData from a [ColorScheme].
  ///  * [ThemeData.light], which creates the default light theme.
  ///  * [ThemeData.dark], which creates the default dark theme.
  ///  * [ColorScheme.fromSeed], which is used to create a [ColorScheme] from a seed color.
  factory ThemeData({
    // For the sanity of the reader, make sure these properties are in the same
    // order in every place that they are separated by section comments (e.g.
    // GENERAL CONFIGURATION). Each section except for deprecations should be
    // alphabetical by symbol name.

    // GENERAL CONFIGURATION
    Iterable<Adaptation<Object>>? adaptations,
    bool? applyElevationOverlayColor,
    NoDefaultCupertinoThemeData? cupertinoOverrideTheme,
    Iterable<ThemeExtension<dynamic>>? extensions,
    InputDecorationTheme? inputDecorationTheme,
    MaterialTapTargetSize? materialTapTargetSize,
    PageTransitionsTheme? pageTransitionsTheme,
    TargetPlatform? platform,
    ScrollbarThemeData? scrollbarTheme,
    InteractiveInkFeatureFactory? splashFactory,
    bool? useMaterial3,
    VisualDensity? visualDensity,
    // COLOR
    ColorScheme? colorScheme,
    Brightness? brightness,
    Color? colorSchemeSeed,
    // [colorScheme] is the preferred way to configure colors. The [Color] properties
    // listed below (as well as primarySwatch) will gradually be phased out, see
    // https://github.com/flutter/flutter/issues/91772.
    Color? canvasColor,
    Color? cardColor,
    Color? disabledColor,
    Color? dividerColor,
    Color? focusColor,
    Color? highlightColor,
    Color? hintColor,
    Color? hoverColor,
    Color? indicatorColor,
    Color? primaryColor,
    Color? primaryColorDark,
    Color? primaryColorLight,
    MaterialColor? primarySwatch,
    Color? scaffoldBackgroundColor,
    Color? secondaryHeaderColor,
    Color? shadowColor,
    Color? splashColor,
    Color? unselectedWidgetColor,
    // TYPOGRAPHY & ICONOGRAPHY
    String? fontFamily,
    List<String>? fontFamilyFallback,
    String? package,
    IconThemeData? iconTheme,
    IconThemeData? primaryIconTheme,
    TextTheme? primaryTextTheme,
    TextTheme? textTheme,
    Typography? typography,
    // COMPONENT THEMES
    ActionIconThemeData? actionIconTheme,
    AppBarTheme? appBarTheme,
    BadgeThemeData? badgeTheme,
    MaterialBannerThemeData? bannerTheme,
    BottomAppBarTheme? bottomAppBarTheme,
    BottomNavigationBarThemeData? bottomNavigationBarTheme,
    BottomSheetThemeData? bottomSheetTheme,
    ButtonThemeData? buttonTheme,
    // TODO(QuncCccccc): Change the parameter type to CardThemeData
    Object? cardTheme,
    CheckboxThemeData? checkboxTheme,
    ChipThemeData? chipTheme,
    DataTableThemeData? dataTableTheme,
    DatePickerThemeData? datePickerTheme,
    // TODO(QuncCccccc): Change the parameter type to DialogThemeData
    Object? dialogTheme,
    DividerThemeData? dividerTheme,
    DrawerThemeData? drawerTheme,
    DropdownMenuThemeData? dropdownMenuTheme,
    ElevatedButtonThemeData? elevatedButtonTheme,
    ExpansionTileThemeData? expansionTileTheme,
    FilledButtonThemeData? filledButtonTheme,
    FloatingActionButtonThemeData? floatingActionButtonTheme,
    IconButtonThemeData? iconButtonTheme,
    ListTileThemeData? listTileTheme,
    MenuBarThemeData? menuBarTheme,
    MenuButtonThemeData? menuButtonTheme,
    MenuThemeData? menuTheme,
    NavigationBarThemeData? navigationBarTheme,
    NavigationDrawerThemeData? navigationDrawerTheme,
    NavigationRailThemeData? navigationRailTheme,
    OutlinedButtonThemeData? outlinedButtonTheme,
    PopupMenuThemeData? popupMenuTheme,
    ProgressIndicatorThemeData? progressIndicatorTheme,
    RadioThemeData? radioTheme,
    SearchBarThemeData? searchBarTheme,
    SearchViewThemeData? searchViewTheme,
    SegmentedButtonThemeData? segmentedButtonTheme,
    SliderThemeData? sliderTheme,
    SnackBarThemeData? snackBarTheme,
    SwitchThemeData? switchTheme,
    // TODO(QuncCccccc): Change the parameter type to TabBarThemeData
    Object? tabBarTheme,
    TextButtonThemeData? textButtonTheme,
    TextSelectionThemeData? textSelectionTheme,
    TimePickerThemeData? timePickerTheme,
    ToggleButtonsThemeData? toggleButtonsTheme,
    TooltipThemeData? tooltipTheme,
    // DEPRECATED (newest deprecations at the bottom)
    @Deprecated(
      'Use OverflowBar instead. '
      'This feature was deprecated after v3.21.0-10.0.pre.',
    )
    ButtonBarThemeData? buttonBarTheme,
    @Deprecated(
      'Use DialogThemeData.backgroundColor instead. '
      'This feature was deprecated after v3.27.0-0.1.pre.',
    )
    Color? dialogBackgroundColor,
  }) {
    // GENERAL CONFIGURATION
    cupertinoOverrideTheme = cupertinoOverrideTheme?.noDefault();
    extensions ??= <ThemeExtension<dynamic>>[];
    adaptations ??= <Adaptation<Object>>[];
    inputDecorationTheme ??= const InputDecorationTheme();
    platform ??= defaultTargetPlatform;
    switch (platform) {
      case TargetPlatform.android:
      case TargetPlatform.fuchsia:
      case TargetPlatform.iOS:
        materialTapTargetSize ??= MaterialTapTargetSize.padded;
      case TargetPlatform.linux:
      case TargetPlatform.macOS:
      case TargetPlatform.windows:
        materialTapTargetSize ??= MaterialTapTargetSize.shrinkWrap;
    }
    pageTransitionsTheme ??= const PageTransitionsTheme();
    scrollbarTheme ??= const ScrollbarThemeData();
    visualDensity ??= VisualDensity.defaultDensityForPlatform(platform);
    useMaterial3 ??= true;
    final bool useInkSparkle = platform == TargetPlatform.android && !kIsWeb;
    splashFactory ??=
        useMaterial3
            ? useInkSparkle
                ? InkSparkle.splashFactory
                : InkRipple.splashFactory
            : InkSplash.splashFactory;

    // COLOR
    assert(
      colorScheme?.brightness == null ||
          brightness == null ||
          colorScheme!.brightness == brightness,
      'ThemeData.brightness does not match ColorScheme.brightness. '
      'Either override ColorScheme.brightness or ThemeData.brightness to '
      'match the other.',
    );
    assert(colorSchemeSeed == null || colorScheme == null);
    assert(colorSchemeSeed == null || primarySwatch == null);
    assert(colorSchemeSeed == null || primaryColor == null);
    final Brightness effectiveBrightness =
        brightness ?? colorScheme?.brightness ?? Brightness.light;
    final bool isDark = effectiveBrightness == Brightness.dark;
    if (colorSchemeSeed != null || useMaterial3) {
      if (colorSchemeSeed != null) {
        colorScheme = ColorScheme.fromSeed(
          seedColor: colorSchemeSeed,
          brightness: effectiveBrightness,
        );
      }
      colorScheme ??= isDark ? _colorSchemeDarkM3 : _colorSchemeLightM3;

      // For surfaces that use primary color in light themes and surface color in dark
      final Color primarySurfaceColor = isDark ? colorScheme.surface : colorScheme.primary;
      final Color onPrimarySurfaceColor = isDark ? colorScheme.onSurface : colorScheme.onPrimary;

      // Default some of the color settings to values from the color scheme
      primaryColor ??= primarySurfaceColor;
      canvasColor ??= colorScheme.surface;
      scaffoldBackgroundColor ??= colorScheme.surface;
      cardColor ??= colorScheme.surface;
      dividerColor ??= colorScheme.outline;
      dialogBackgroundColor ??= colorScheme.surface;
      indicatorColor ??= onPrimarySurfaceColor;
      applyElevationOverlayColor ??= brightness == Brightness.dark;
    }
    applyElevationOverlayColor ??= false;
    primarySwatch ??= Colors.blue;
    primaryColor ??= isDark ? Colors.grey[900]! : primarySwatch;
    final Brightness estimatedPrimaryColorBrightness = estimateBrightnessForColor(primaryColor);
    primaryColorLight ??= isDark ? Colors.grey[500]! : primarySwatch[100]!;
    primaryColorDark ??= isDark ? Colors.black : primarySwatch[700]!;
    final bool primaryIsDark = estimatedPrimaryColorBrightness == Brightness.dark;
    focusColor ??= isDark ? Colors.white.withOpacity(0.12) : Colors.black.withOpacity(0.12);
    hoverColor ??= isDark ? Colors.white.withOpacity(0.04) : Colors.black.withOpacity(0.04);
    shadowColor ??= Colors.black;
    canvasColor ??= isDark ? Colors.grey[850]! : Colors.grey[50]!;
    scaffoldBackgroundColor ??= canvasColor;
    cardColor ??= isDark ? Colors.grey[800]! : Colors.white;
    dividerColor ??= isDark ? const Color(0x1FFFFFFF) : const Color(0x1F000000);
    // Create a ColorScheme that is backwards compatible as possible
    // with the existing default ThemeData color values.
    colorScheme ??= ColorScheme.fromSwatch(
      primarySwatch: primarySwatch,
      accentColor: isDark ? Colors.tealAccent[200]! : primarySwatch[500]!,
      cardColor: cardColor,
      backgroundColor: isDark ? Colors.grey[700]! : primarySwatch[200]!,
      errorColor: Colors.red[700],
      brightness: effectiveBrightness,
    );
    unselectedWidgetColor ??= isDark ? Colors.white70 : Colors.black54;
    // Spec doesn't specify a dark theme secondaryHeaderColor, this is a guess.
    secondaryHeaderColor ??= isDark ? Colors.grey[700]! : primarySwatch[50]!;
    indicatorColor ??= colorScheme.secondary == primaryColor ? Colors.white : colorScheme.secondary;
    hintColor ??= isDark ? Colors.white60 : Colors.black.withOpacity(0.6);
    // The default [buttonTheme] is here because it doesn't use the defaults for
    // [disabledColor], [highlightColor], and [splashColor].
    buttonTheme ??= ButtonThemeData(
      colorScheme: colorScheme,
      buttonColor: isDark ? primarySwatch[600]! : Colors.grey[300]!,
      disabledColor: disabledColor,
      focusColor: focusColor,
      hoverColor: hoverColor,
      highlightColor: highlightColor,
      splashColor: splashColor,
      materialTapTargetSize: materialTapTargetSize,
    );
    disabledColor ??= isDark ? Colors.white38 : Colors.black38;
    highlightColor ??= isDark ? const Color(0x40CCCCCC) : const Color(0x66BCBCBC);
    splashColor ??= isDark ? const Color(0x40CCCCCC) : const Color(0x66C8C8C8);

    // TYPOGRAPHY & ICONOGRAPHY
    typography ??=
        useMaterial3
            ? Typography.material2021(platform: platform, colorScheme: colorScheme)
            : Typography.material2014(platform: platform);
    TextTheme defaultTextTheme = isDark ? typography.white : typography.black;
    TextTheme defaultPrimaryTextTheme = primaryIsDark ? typography.white : typography.black;
    if (fontFamily != null) {
      defaultTextTheme = defaultTextTheme.apply(fontFamily: fontFamily);
      defaultPrimaryTextTheme = defaultPrimaryTextTheme.apply(fontFamily: fontFamily);
    }
    if (fontFamilyFallback != null) {
      defaultTextTheme = defaultTextTheme.apply(fontFamilyFallback: fontFamilyFallback);
      defaultPrimaryTextTheme = defaultPrimaryTextTheme.apply(
        fontFamilyFallback: fontFamilyFallback,
      );
    }
    if (package != null) {
      defaultTextTheme = defaultTextTheme.apply(package: package);
      defaultPrimaryTextTheme = defaultPrimaryTextTheme.apply(package: package);
    }
    textTheme = defaultTextTheme.merge(textTheme);
    primaryTextTheme = defaultPrimaryTextTheme.merge(primaryTextTheme);
    iconTheme ??=
        isDark
            ? IconThemeData(color: kDefaultIconLightColor)
            : IconThemeData(color: kDefaultIconDarkColor);
    primaryIconTheme ??=
        primaryIsDark
            ? const IconThemeData(color: Colors.white)
            : const IconThemeData(color: Colors.black);

    // COMPONENT THEMES
    appBarTheme ??= const AppBarTheme();
    badgeTheme ??= const BadgeThemeData();
    bannerTheme ??= const MaterialBannerThemeData();
    bottomAppBarTheme ??= const BottomAppBarTheme();
    bottomNavigationBarTheme ??= const BottomNavigationBarThemeData();
    bottomSheetTheme ??= const BottomSheetThemeData();
    // TODO(QuncCccccc): Clean it up once the type of `cardTheme` is changed to `CardThemeData`
    if (cardTheme != null) {
      if (cardTheme is CardTheme) {
        cardTheme = cardTheme.data;
      } else if (cardTheme is! CardThemeData) {
        throw ArgumentError('cardTheme must be either a CardThemeData or a CardTheme');
      }
    }
    cardTheme ??= const CardThemeData();
    checkboxTheme ??= const CheckboxThemeData();
    chipTheme ??= const ChipThemeData();
    dataTableTheme ??= const DataTableThemeData();
    datePickerTheme ??= const DatePickerThemeData();
    // TODO(QuncCccccc): Clean this up once the type of `dialogTheme` is changed to `DialogThemeData`
    if (dialogTheme != null) {
      if (dialogTheme is DialogTheme) {
        dialogTheme = dialogTheme.data;
      } else if (dialogTheme is! DialogThemeData) {
        throw ArgumentError('dialogTheme must be either a DialogThemeData or a DialogTheme');
      }
    }
    dialogTheme ??= const DialogThemeData();
    dividerTheme ??= const DividerThemeData();
    drawerTheme ??= const DrawerThemeData();
    dropdownMenuTheme ??= const DropdownMenuThemeData();
    elevatedButtonTheme ??= const ElevatedButtonThemeData();
    expansionTileTheme ??= const ExpansionTileThemeData();
    filledButtonTheme ??= const FilledButtonThemeData();
    floatingActionButtonTheme ??= const FloatingActionButtonThemeData();
    iconButtonTheme ??= const IconButtonThemeData();
    listTileTheme ??= const ListTileThemeData();
    menuBarTheme ??= const MenuBarThemeData();
    menuButtonTheme ??= const MenuButtonThemeData();
    menuTheme ??= const MenuThemeData();
    navigationBarTheme ??= const NavigationBarThemeData();
    navigationDrawerTheme ??= const NavigationDrawerThemeData();
    navigationRailTheme ??= const NavigationRailThemeData();
    outlinedButtonTheme ??= const OutlinedButtonThemeData();
    popupMenuTheme ??= const PopupMenuThemeData();
    progressIndicatorTheme ??= const ProgressIndicatorThemeData();
    radioTheme ??= const RadioThemeData();
    searchBarTheme ??= const SearchBarThemeData();
    searchViewTheme ??= const SearchViewThemeData();
    segmentedButtonTheme ??= const SegmentedButtonThemeData();
    sliderTheme ??= const SliderThemeData();
    snackBarTheme ??= const SnackBarThemeData();
    switchTheme ??= const SwitchThemeData();
    // TODO(QuncCccccc): Clean this up once the type of `tabBarTheme` is changed to `TabBarThemeData`
    if (tabBarTheme != null) {
      if (tabBarTheme is TabBarTheme) {
        tabBarTheme = tabBarTheme.data;
      } else if (tabBarTheme is! TabBarThemeData) {
        throw ArgumentError('tabBarTheme must be either a TabBarThemeData or a TabBarTheme');
      }
    }
    tabBarTheme ??= const TabBarThemeData();
    textButtonTheme ??= const TextButtonThemeData();
    textSelectionTheme ??= const TextSelectionThemeData();
    timePickerTheme ??= const TimePickerThemeData();
    toggleButtonsTheme ??= const ToggleButtonsThemeData();
    tooltipTheme ??= const TooltipThemeData();
    // DEPRECATED (newest deprecations at the bottom)
    buttonBarTheme ??= const ButtonBarThemeData();
    dialogBackgroundColor ??= isDark ? Colors.grey[800]! : Colors.white;
    return ThemeData.raw(
      // For the sanity of the reader, make sure these properties are in the same
      // order in every place that they are separated by section comments (e.g.
      // GENERAL CONFIGURATION). Each section except for deprecations should be
      // alphabetical by symbol name.

      // GENERAL CONFIGURATION
      adaptationMap: _createAdaptationMap(adaptations),
      applyElevationOverlayColor: applyElevationOverlayColor,
      cupertinoOverrideTheme: cupertinoOverrideTheme,
      extensions: _themeExtensionIterableToMap(extensions),
      inputDecorationTheme: inputDecorationTheme,
      materialTapTargetSize: materialTapTargetSize,
      pageTransitionsTheme: pageTransitionsTheme,
      platform: platform,
      scrollbarTheme: scrollbarTheme,
      splashFactory: splashFactory,
      useMaterial3: useMaterial3,
      visualDensity: visualDensity,
      // COLOR
      canvasColor: canvasColor,
      cardColor: cardColor,
      colorScheme: colorScheme,
      disabledColor: disabledColor,
      dividerColor: dividerColor,
      focusColor: focusColor,
      highlightColor: highlightColor,
      hintColor: hintColor,
      hoverColor: hoverColor,
      indicatorColor: indicatorColor,
      primaryColor: primaryColor,
      primaryColorDark: primaryColorDark,
      primaryColorLight: primaryColorLight,
      scaffoldBackgroundColor: scaffoldBackgroundColor,
      secondaryHeaderColor: secondaryHeaderColor,
      shadowColor: shadowColor,
      splashColor: splashColor,
      unselectedWidgetColor: unselectedWidgetColor,
      // TYPOGRAPHY & ICONOGRAPHY
      iconTheme: iconTheme,
      primaryTextTheme: primaryTextTheme,
      textTheme: textTheme,
      typography: typography,
      primaryIconTheme: primaryIconTheme,
      // COMPONENT THEMES
      actionIconTheme: actionIconTheme,
      appBarTheme: appBarTheme,
      badgeTheme: badgeTheme,
      bannerTheme: bannerTheme,
      bottomAppBarTheme: bottomAppBarTheme,
      bottomNavigationBarTheme: bottomNavigationBarTheme,
      bottomSheetTheme: bottomSheetTheme,
      buttonTheme: buttonTheme,
      cardTheme: cardTheme as CardThemeData,
      checkboxTheme: checkboxTheme,
      chipTheme: chipTheme,
      dataTableTheme: dataTableTheme,
      datePickerTheme: datePickerTheme,
      dialogTheme: dialogTheme as DialogThemeData,
      dividerTheme: dividerTheme,
      drawerTheme: drawerTheme,
      dropdownMenuTheme: dropdownMenuTheme,
      elevatedButtonTheme: elevatedButtonTheme,
      expansionTileTheme: expansionTileTheme,
      filledButtonTheme: filledButtonTheme,
      floatingActionButtonTheme: floatingActionButtonTheme,
      iconButtonTheme: iconButtonTheme,
      listTileTheme: listTileTheme,
      menuBarTheme: menuBarTheme,
      menuButtonTheme: menuButtonTheme,
      menuTheme: menuTheme,
      navigationBarTheme: navigationBarTheme,
      navigationDrawerTheme: navigationDrawerTheme,
      navigationRailTheme: navigationRailTheme,
      outlinedButtonTheme: outlinedButtonTheme,
      popupMenuTheme: popupMenuTheme,
      progressIndicatorTheme: progressIndicatorTheme,
      radioTheme: radioTheme,
      searchBarTheme: searchBarTheme,
      searchViewTheme: searchViewTheme,
      segmentedButtonTheme: segmentedButtonTheme,
      sliderTheme: sliderTheme,
      snackBarTheme: snackBarTheme,
      switchTheme: switchTheme,
      tabBarTheme: tabBarTheme as TabBarThemeData,
      textButtonTheme: textButtonTheme,
      textSelectionTheme: textSelectionTheme,
      timePickerTheme: timePickerTheme,
      toggleButtonsTheme: toggleButtonsTheme,
      tooltipTheme: tooltipTheme,
      // DEPRECATED (newest deprecations at the bottom)
      buttonBarTheme: buttonBarTheme,
      dialogBackgroundColor: dialogBackgroundColor,
    );
  }

  /// Create a [ThemeData] given a set of exact values. Most values must be
  /// specified. They all must also be non-null except for
  /// [cupertinoOverrideTheme], and deprecated members.
  ///
  /// This will rarely be used directly. It is used by [lerp] to
  /// create intermediate themes based on two themes created with the
  /// [ThemeData] constructor.
  const ThemeData.raw({
    // For the sanity of the reader, make sure these properties are in the same
    // order in every place that they are separated by section comments (e.g.
    // GENERAL CONFIGURATION). Each section except for deprecations should be
    // alphabetical by symbol name.

    // GENERAL CONFIGURATION
    required this.adaptationMap,
    required this.applyElevationOverlayColor,
    required this.cupertinoOverrideTheme,
    required this.extensions,
    required this.inputDecorationTheme,
    required this.materialTapTargetSize,
    required this.pageTransitionsTheme,
    required this.platform,
    required this.scrollbarTheme,
    required this.splashFactory,
    required this.useMaterial3,
    required this.visualDensity,
    // COLOR
    required this.colorScheme,
    // [colorScheme] is the preferred way to configure colors. The [Color] properties
    // listed below (as well as primarySwatch) will gradually be phased out, see
    // https://github.com/flutter/flutter/issues/91772.
    required this.canvasColor,
    required this.cardColor,
    required this.disabledColor,
    required this.dividerColor,
    required this.focusColor,
    required this.highlightColor,
    required this.hintColor,
    required this.hoverColor,
    required this.indicatorColor,
    required this.primaryColor,
    required this.primaryColorDark,
    required this.primaryColorLight,
    required this.scaffoldBackgroundColor,
    required this.secondaryHeaderColor,
    required this.shadowColor,
    required this.splashColor,
    required this.unselectedWidgetColor,
    // TYPOGRAPHY & ICONOGRAPHY
    required this.iconTheme,
    required this.primaryIconTheme,
    required this.primaryTextTheme,
    required this.textTheme,
    required this.typography,
    // COMPONENT THEMES
    required this.actionIconTheme,
    required this.appBarTheme,
    required this.badgeTheme,
    required this.bannerTheme,
    required this.bottomAppBarTheme,
    required this.bottomNavigationBarTheme,
    required this.bottomSheetTheme,
    required this.buttonTheme,
    required this.cardTheme,
    required this.checkboxTheme,
    required this.chipTheme,
    required this.dataTableTheme,
    required this.datePickerTheme,
    required this.dialogTheme,
    required this.dividerTheme,
    required this.drawerTheme,
    required this.dropdownMenuTheme,
    required this.elevatedButtonTheme,
    required this.expansionTileTheme,
    required this.filledButtonTheme,
    required this.floatingActionButtonTheme,
    required this.iconButtonTheme,
    required this.listTileTheme,
    required this.menuBarTheme,
    required this.menuButtonTheme,
    required this.menuTheme,
    required this.navigationBarTheme,
    required this.navigationDrawerTheme,
    required this.navigationRailTheme,
    required this.outlinedButtonTheme,
    required this.popupMenuTheme,
    required this.progressIndicatorTheme,
    required this.radioTheme,
    required this.searchBarTheme,
    required this.searchViewTheme,
    required this.segmentedButtonTheme,
    required this.sliderTheme,
    required this.snackBarTheme,
    required this.switchTheme,
    required this.tabBarTheme,
    required this.textButtonTheme,
    required this.textSelectionTheme,
    required this.timePickerTheme,
    required this.toggleButtonsTheme,
    required this.tooltipTheme,
    // DEPRECATED (newest deprecations at the bottom)
    @Deprecated(
      'Use OverflowBar instead. '
      'This feature was deprecated after v3.21.0-10.0.pre.',
    )
    ButtonBarThemeData? buttonBarTheme,
    @Deprecated(
      'Use DialogThemeData.backgroundColor instead. '
      'This feature was deprecated after v3.27.0-0.1.pre.',
    )
    required this.dialogBackgroundColor,
  }) : // DEPRECATED (newest deprecations at the bottom)
       // should not be `required`, use getter pattern to avoid breakages.
       _buttonBarTheme = buttonBarTheme,
       assert(buttonBarTheme != null);

  /// Create a [ThemeData] based on the colors in the given [colorScheme] and
  /// text styles of the optional [textTheme].
  ///
  /// If [colorScheme].brightness is [Brightness.dark] then
  /// [ThemeData.applyElevationOverlayColor] will be set to true to support
  /// the Material dark theme method for indicating elevation by applying
  /// a semi-transparent onSurface color on top of the surface color.
  ///
  /// This is the recommended method to theme your application. As we move
  /// forward we will be converting all the widget implementations to only use
  /// colors or colors derived from those in [ColorScheme].
  ///
  /// {@tool snippet}
  /// This example will set up an application to use the baseline Material
  /// Design light and dark themes.
  ///
  /// ```dart
  /// MaterialApp(
  ///   theme: ThemeData.from(colorScheme: const ColorScheme.light()),
  ///   darkTheme: ThemeData.from(colorScheme: const ColorScheme.dark()),
  /// )
  /// ```
  /// {@end-tool}
  ///
  /// See <https://material.io/design/color/> for
  /// more discussion on how to pick the right colors.
  factory ThemeData.from({
    required ColorScheme colorScheme,
    TextTheme? textTheme,
    bool? useMaterial3,
  }) {
    final bool isDark = colorScheme.brightness == Brightness.dark;

    // For surfaces that use primary color in light themes and surface color in dark
    final Color primarySurfaceColor = isDark ? colorScheme.surface : colorScheme.primary;
    final Color onPrimarySurfaceColor = isDark ? colorScheme.onSurface : colorScheme.onPrimary;

    return ThemeData(
      colorScheme: colorScheme,
      brightness: colorScheme.brightness,
      primaryColor: primarySurfaceColor,
      canvasColor: colorScheme.surface,
      scaffoldBackgroundColor: colorScheme.surface,
      cardColor: colorScheme.surface,
      dividerColor: colorScheme.onSurface.withOpacity(0.12),
      dialogBackgroundColor: colorScheme.surface,
      indicatorColor: onPrimarySurfaceColor,
      textTheme: textTheme,
      applyElevationOverlayColor: isDark,
      useMaterial3: useMaterial3,
    );
  }

  /// A default light theme.
  ///
  /// This theme does not contain text geometry. Instead, it is expected that
  /// this theme is localized using text geometry using [ThemeData.localize].
  factory ThemeData.light({bool? useMaterial3}) =>
      ThemeData(brightness: Brightness.light, useMaterial3: useMaterial3);

  /// A default dark theme.
  ///
  /// This theme does not contain text geometry. Instead, it is expected that
  /// this theme is localized using text geometry using [ThemeData.localize].
  factory ThemeData.dark({bool? useMaterial3}) =>
      ThemeData(brightness: Brightness.dark, useMaterial3: useMaterial3);

  /// The default color theme. Same as [ThemeData.light].
  ///
  /// This is used by [Theme.of] when no theme has been specified.
  ///
  /// This theme does not contain text geometry. Instead, it is expected that
  /// this theme is localized using text geometry using [ThemeData.localize].
  ///
  /// Most applications would use [Theme.of], which provides correct localized
  /// text geometry.
  factory ThemeData.fallback({bool? useMaterial3}) => ThemeData.light(useMaterial3: useMaterial3);

  /// Used to obtain a particular [Adaptation] from [adaptationMap].
  ///
  /// To get an adaptation, use `Theme.of(context).getAdaptation<MyAdaptation>()`.
  Adaptation<T>? getAdaptation<T>() => adaptationMap[T] as Adaptation<T>?;

  static Map<Type, Adaptation<Object>> _createAdaptationMap(
    Iterable<Adaptation<Object>> adaptations,
  ) {
    final Map<Type, Adaptation<Object>> adaptationMap = <Type, Adaptation<Object>>{
      for (final Adaptation<Object> adaptation in adaptations) adaptation.type: adaptation,
    };
    return adaptationMap;
  }

  /// The overall theme brightness.
  ///
  /// The default [TextStyle] color for the [textTheme] is black if the
  /// theme is constructed with [Brightness.light] and white if the
  /// theme is constructed with [Brightness.dark].
  Brightness get brightness => colorScheme.brightness;

  // For the sanity of the reader, make sure these properties are in the same
  // order in every place that they are separated by section comments (e.g.
  // GENERAL CONFIGURATION). Each section except for deprecations should be
  // alphabetical by symbol name.

  // GENERAL CONFIGURATION

  /// Apply a semi-transparent overlay color on Material surfaces to indicate
  /// elevation for dark themes.
  ///
  /// If [useMaterial3] is true, then this flag is ignored as there is a new
  /// [Material.surfaceTintColor] used to create an overlay for Material 3.
  /// This flag is meant only for the Material 2 elevation overlay for dark
  /// themes.
  ///
  /// Material drop shadows can be difficult to see in a dark theme, so the
  /// elevation of a surface should be portrayed with an "overlay" in addition
  /// to the shadow. As the elevation of the component increases, the
  /// overlay increases in opacity. [applyElevationOverlayColor] turns the
  /// application of this overlay on or off for dark themes.
  ///
  /// If true and [brightness] is [Brightness.dark], a
  /// semi-transparent version of [ColorScheme.onSurface] will be
  /// applied on top of [Material] widgets that have a [ColorScheme.surface]
  /// color. The level of transparency is based on [Material.elevation] as
  /// per the Material Dark theme specification.
  ///
  /// If false the surface color will be used unmodified.
  ///
  /// Defaults to false in order to maintain backwards compatibility with
  /// apps that were built before the Material Dark theme specification
  /// was published. New apps should set this to true for any themes
  /// where [brightness] is [Brightness.dark].
  ///
  /// See also:
  ///
  ///  * [Material.elevation], which effects the level of transparency of the
  ///    overlay color.
  ///  * [ElevationOverlay.applyOverlay], which is used by [Material] to apply
  ///    the overlay color to its surface color.
  ///  * <https://material.io/design/color/dark-theme.html>, which specifies how
  ///    the overlay should be applied.
  final bool applyElevationOverlayColor;

  /// Components of the [CupertinoThemeData] to override from the Material
  /// [ThemeData] adaptation.
  ///
  /// By default, [cupertinoOverrideTheme] is null and Cupertino widgets
  /// descendant to the Material [Theme] will adhere to a [CupertinoTheme]
  /// derived from the Material [ThemeData]. e.g. [ThemeData]'s [ColorScheme]
  /// will also inform the [CupertinoThemeData]'s `primaryColor` etc.
  ///
  /// This cascading effect for individual attributes of the [CupertinoThemeData]
  /// can be overridden using attributes of this [cupertinoOverrideTheme].
  final NoDefaultCupertinoThemeData? cupertinoOverrideTheme;

  /// Arbitrary additions to this theme.
  ///
  /// To define extensions, pass an [Iterable] containing one or more [ThemeExtension]
  /// subclasses to [ThemeData.new] or [copyWith].
  ///
  /// To obtain an extension, use [extension].
  ///
  /// {@tool dartpad}
  /// This sample shows how to create and use a subclass of [ThemeExtension] that
  /// defines two colors.
  ///
  /// ** See code in examples/api/lib/material/theme/theme_extension.1.dart **
  /// {@end-tool}
  ///
  /// See also:
  ///
  /// * [extension], a convenience function for obtaining a specific extension.
  final Map<Object, ThemeExtension<dynamic>> extensions;

  /// Used to obtain a particular [ThemeExtension] from [extensions].
  ///
  /// Obtain with `Theme.of(context).extension<MyThemeExtension>()`.
  ///
  /// See [extensions] for an interactive example.
  T? extension<T>() => extensions[T] as T?;

  /// A map which contains the adaptations for the theme. The entry's key is the
  /// type of the adaptation; the value is the adaptation itself.
  ///
  /// To obtain an adaptation, use [getAdaptation].
  final Map<Type, Adaptation<Object>> adaptationMap;

  /// The default [InputDecoration] values for [InputDecorator], [TextField],
  /// and [TextFormField] are based on this theme.
  ///
  /// See [InputDecoration.applyDefaults].
  final InputDecorationTheme inputDecorationTheme;

  /// Configures the hit test size of certain Material widgets.
  ///
  /// Defaults to a [platform]-appropriate size: [MaterialTapTargetSize.padded]
  /// on mobile platforms, [MaterialTapTargetSize.shrinkWrap] on desktop
  /// platforms.
  final MaterialTapTargetSize materialTapTargetSize;

  /// Default [MaterialPageRoute] transitions per [TargetPlatform].
  ///
  /// [MaterialPageRoute.buildTransitions] delegates to a [platform] specific
  /// [PageTransitionsBuilder]. If a matching builder is not found, a builder
  /// whose platform is null is used.
  final PageTransitionsTheme pageTransitionsTheme;

  /// The platform the material widgets should adapt to target.
  ///
  /// Defaults to the current platform, as exposed by [defaultTargetPlatform].
  /// This should be used in order to style UI elements according to platform
  /// conventions.
  ///
  /// Widgets from the material library should use this getter (via [Theme.of])
  /// to determine the current platform for the purpose of emulating the
  /// platform behavior (e.g. scrolling or haptic effects). Widgets and render
  /// objects at lower layers that try to emulate the underlying platform
  /// can depend on [defaultTargetPlatform] directly, or may require
  /// that the target platform be provided as an argument. The
  /// [dart:io.Platform] object should only be used directly when it's critical
  /// to actually know the current platform, without any overrides possible (for
  /// example, when a system API is about to be called).
  ///
  /// In a test environment, the platform returned is [TargetPlatform.android]
  /// regardless of the host platform. (Android was chosen because the tests
  /// were originally written assuming Android-like behavior, and we added
  /// platform adaptations for other platforms later). Tests can check behavior
  /// for other platforms by setting the [platform] of the [Theme] explicitly to
  /// another [TargetPlatform] value, or by setting
  /// [debugDefaultTargetPlatformOverride].
  ///
  /// Determines the defaults for [typography] and [materialTapTargetSize].
  final TargetPlatform platform;

  /// A theme for customizing the colors, thickness, and shape of [Scrollbar]s.
  final ScrollbarThemeData scrollbarTheme;

  /// Defines the appearance of ink splashes produces by [InkWell]
  /// and [InkResponse].
  ///
  /// See also:
  ///
  ///  * [InkSplash.splashFactory], which defines the default splash.
  ///  * [InkRipple.splashFactory], which defines a splash that spreads out
  ///    more aggressively than the default.
  ///  * [InkSparkle.splashFactory], which defines a more aggressive and organic
  ///    splash with sparkle effects.
  final InteractiveInkFeatureFactory splashFactory;

  /// A temporary flag that can be used to opt-out of Material 3 features.
  ///
  /// This flag is _true_ by default. If false, then components will
  /// continue to use the colors, typography and other features of
  /// Material 2.
  ///
  /// In the long run this flag will be deprecated and eventually
  /// only Material 3 will be supported. We recommend that applications
  /// migrate to Material 3 as soon as that's practical. Until that migration
  /// is complete, this flag can be set to false.
  ///
  /// ## Defaults
  ///
  /// If a [ThemeData] is _constructed_ with [useMaterial3] set to true, then
  /// some properties will get updated defaults. However, the
  /// [ThemeData.copyWith] method with [useMaterial3] set to true will _not_
  /// change any of these properties in the resulting [ThemeData].
  ///
  /// <style>table,td,th { border-collapse: collapse; padding: 0.45em; } td { border: 1px solid }</style>
  ///
  /// | Property        | Material 3 default             | Material 2 default             |
  /// | :-------------- | :----------------------------- | :----------------------------- |
  /// | [colorScheme]   | M3 baseline light color scheme | M2 baseline light color scheme |
  /// | [typography]    | [Typography.material2021]      | [Typography.material2014]      |
  /// | [splashFactory] | [InkSparkle]* or [InkRipple]   | [InkSplash]                    |
  ///
  /// \* if the target platform is Android and the app is not
  /// running on the web, otherwise it will fallback to [InkRipple].
  ///
  /// If [brightness] is [Brightness.dark] then the default color scheme will
  /// be either the M3 baseline dark color scheme or the M2 baseline dark color
  /// scheme depending on [useMaterial3].
  ///
  /// ## Affected widgets
  ///
  /// This flag affects styles and components.
  ///
  /// ### Styles
  ///   * Color: [ColorScheme], [Material] (see table above)
  ///   * Shape: (see components below)
  ///   * Typography: [Typography] (see table above)
  ///
  /// ### Components
  ///   * Badges: [Badge]
  ///   * Bottom app bar: [BottomAppBar]
  ///   * Bottom sheets: [BottomSheet]
  ///   * Buttons
  ///     - Common buttons: [ElevatedButton], [FilledButton], [FilledButton.tonal], [OutlinedButton], [TextButton]
  ///     - FAB: [FloatingActionButton], [FloatingActionButton.extended]
  ///     - Icon buttons: [IconButton], [IconButton.filled] (*new*), [IconButton.filledTonal], [IconButton.outlined]
  ///     - Segmented buttons: [SegmentedButton] (replacing [ToggleButtons])
  ///   * Cards: [Card]
  ///   * Checkbox: [Checkbox], [CheckboxListTile]
  ///   * Chips:
  ///     - [ActionChip] (used for Assist and Suggestion chips),
  ///     - [FilterChip], [ChoiceChip] (used for single selection filter chips),
  ///     - [InputChip]
  ///   * Date pickers: [showDatePicker], [showDateRangePicker], [DatePickerDialog], [DateRangePickerDialog], [InputDatePickerFormField]
  ///   * Dialogs: [AlertDialog], [Dialog.fullscreen]
  ///   * Divider: [Divider], [VerticalDivider]
  ///   * Lists: [ListTile]
  ///   * Menus: [MenuAnchor], [DropdownMenu], [MenuBar]
  ///   * Navigation bar: [NavigationBar] (replacing [BottomNavigationBar])
  ///   * Navigation drawer: [NavigationDrawer] (replacing [Drawer])
  ///   * Navigation rail: [NavigationRail]
  ///   * Progress indicators: [CircularProgressIndicator], [LinearProgressIndicator]
  ///   * Radio button: [Radio], [RadioListTile]
  ///   * Search: [SearchBar], [SearchAnchor],
  ///   * Snack bar: [SnackBar]
  ///   * Slider: [Slider], [RangeSlider]
  ///   * Switch: [Switch], [SwitchListTile]
  ///   * Tabs: [TabBar], [TabBar.secondary]
  ///   * TextFields: [TextField] together with its [InputDecoration]
  ///   * Time pickers: [showTimePicker], [TimePickerDialog]
  ///   * Top app bar: [AppBar], [SliverAppBar], [SliverAppBar.medium], [SliverAppBar.large]
  ///
  /// In addition, this flag enables features introduced in Android 12.
  ///   * Stretch overscroll: [MaterialScrollBehavior]
  ///   * Ripple: `splashFactory` (see table above)
  ///
  /// See also:
  ///
  ///   * [Material 3 specification](https://m3.material.io/).
  final bool useMaterial3;

  /// The density value for specifying the compactness of various UI components.
  ///
  /// {@template flutter.material.themedata.visualDensity}
  /// Density, in the context of a UI, is the vertical and horizontal
  /// "compactness" of the elements in the UI. It is unitless, since it means
  /// different things to different UI elements. For buttons, it affects the
  /// spacing around the centered label of the button. For lists, it affects the
  /// distance between baselines of entries in the list.
  ///
  /// Typically, density values are integral, but any value in range may be
  /// used. The range includes values from [VisualDensity.minimumDensity] (which
  /// is -4), to [VisualDensity.maximumDensity] (which is 4), inclusive, where
  /// negative values indicate a denser, more compact, UI, and positive values
  /// indicate a less dense, more expanded, UI. If a component doesn't support
  /// the value given, it will clamp to the nearest supported value.
  ///
  /// The default for visual densities is zero for both vertical and horizontal
  /// densities, which corresponds to the default visual density of components
  /// in the Material Design specification.
  ///
  /// As a rule of thumb, a change of 1 or -1 in density corresponds to 4
  /// logical pixels. However, this is not a strict relationship since
  /// components interpret the density values appropriately for their needs.
  ///
  /// A larger value translates to a spacing increase (less dense), and a
  /// smaller value translates to a spacing decrease (more dense).
  ///
  /// In Material Design 3, the [visualDensity] does not override the value of
  /// [IconButton.visualDensity] which defaults to [VisualDensity.standard]
  /// for all platforms. To override the default value of [IconButton.visualDensity],
  /// use [ThemeData.iconButtonTheme] instead.
  /// {@endtemplate}
  final VisualDensity visualDensity;

  // COLOR

  /// The default color of [MaterialType.canvas] [Material].
  final Color canvasColor;

  /// The color of [Material] when it is used as a [Card].
  final Color cardColor;

  /// {@macro flutter.material.color_scheme.ColorScheme}
  ///
  /// This property was added much later than the theme's set of highly specific
  /// colors, like [cardColor], [canvasColor] etc. New components can be defined
  /// exclusively in terms of [colorScheme]. Existing components will gradually
  /// migrate to it, to the extent that is possible without significant
  /// backwards compatibility breaks.
  final ColorScheme colorScheme;

  /// The color used for widgets that are inoperative, regardless of
  /// their state. For example, a disabled checkbox (which may be
  /// checked or unchecked).
  final Color disabledColor;

  /// The color of [Divider]s and [PopupMenuDivider]s, also used
  /// between [ListTile]s, between rows in [DataTable]s, and so forth.
  ///
  /// To create an appropriate [BorderSide] that uses this color, consider
  /// [Divider.createBorderSide].
  final Color dividerColor;

  /// The focus color used indicate that a component has the input focus.
  final Color focusColor;

  /// The highlight color used during ink splash animations or to
  /// indicate an item in a menu is selected.
  final Color highlightColor;

  /// The color to use for hint text or placeholder text, e.g. in
  /// [TextField] fields.
  final Color hintColor;

  /// The hover color used to indicate when a pointer is hovering over a
  /// component.
  final Color hoverColor;

  /// The color of the selected tab indicator in a tab bar.
  final Color indicatorColor;

  /// The background color for major parts of the app (toolbars, tab bars, etc)
  ///
  /// The theme's [colorScheme] property contains [ColorScheme.primary], as
  /// well as a color that contrasts well with the primary color called
  /// [ColorScheme.onPrimary]. It might be simpler to just configure an app's
  /// visuals in terms of the theme's [colorScheme].
  final Color primaryColor;

  /// A darker version of the [primaryColor].
  final Color primaryColorDark;

  /// A lighter version of the [primaryColor].
  final Color primaryColorLight;

  /// The default color of the [Material] that underlies the [Scaffold]. The
  /// background color for a typical material app or a page within the app.
  final Color scaffoldBackgroundColor;

  /// The color of the header of a [PaginatedDataTable] when there are selected rows.
  // According to the spec for data tables:
  // https://material.io/archive/guidelines/components/data-tables.html#data-tables-tables-within-cards
  // ...this should be the "50-value of secondary app color".
  final Color secondaryHeaderColor;

  /// The color that the [Material] widget uses to draw elevation shadows.
  ///
  /// Defaults to fully opaque black.
  ///
  /// Shadows can be difficult to see in a dark theme, so the elevation of a
  /// surface should be rendered with an "overlay" in addition to the shadow.
  /// As the elevation of the component increases, the overlay increases in
  /// opacity. The [applyElevationOverlayColor] property turns the elevation
  /// overlay on or off for dark themes.
  final Color shadowColor;

  /// The color of ink splashes.
  ///
  /// See also:
  ///  * [splashFactory], which defines the appearance of the splash.
  final Color splashColor;

  /// The color used for widgets in their inactive (but enabled)
  /// state. For example, an unchecked checkbox. See also [disabledColor].
  final Color unselectedWidgetColor;

  // TYPOGRAPHY & ICONOGRAPHY

  /// An icon theme that contrasts with the card and canvas colors.
  final IconThemeData iconTheme;

  /// An icon theme that contrasts with the primary color.
  final IconThemeData primaryIconTheme;

  /// A text theme that contrasts with the primary color.
  final TextTheme primaryTextTheme;

  /// Text with a color that contrasts with the card and canvas colors.
  final TextTheme textTheme;

  /// The color and geometry [TextTheme] values used to configure [textTheme].
  ///
  /// Defaults to a [platform]-appropriate typography.
  final Typography typography;

  // COMPONENT THEMES

  /// A theme for customizing icons of [BackButtonIcon], [CloseButtonIcon],
  /// [DrawerButtonIcon], or [EndDrawerButtonIcon].
  final ActionIconThemeData? actionIconTheme;

  /// A theme for customizing the color, elevation, brightness, iconTheme and
  /// textTheme of [AppBar]s.
  final AppBarTheme appBarTheme;

  /// A theme for customizing the color of [Badge]s.
  final BadgeThemeData badgeTheme;

  /// A theme for customizing the color and text style of a [MaterialBanner].
  final MaterialBannerThemeData bannerTheme;

  /// A theme for customizing the shape, elevation, and color of a [BottomAppBar].
  final BottomAppBarTheme bottomAppBarTheme;

  /// A theme for customizing the appearance and layout of [BottomNavigationBar]
  /// widgets.
  final BottomNavigationBarThemeData bottomNavigationBarTheme;

  /// A theme for customizing the color, elevation, and shape of a bottom sheet.
  final BottomSheetThemeData bottomSheetTheme;

  /// Defines the default configuration of button widgets, like [DropdownButton]
  /// and [ButtonBar].
  final ButtonThemeData buttonTheme;

  /// The colors and styles used to render [Card].
  ///
  /// This is the value returned from [CardTheme.of].
  final CardThemeData cardTheme;

  /// A theme for customizing the appearance and layout of [Checkbox] widgets.
  final CheckboxThemeData checkboxTheme;

  /// The colors and styles used to render [Chip]s.
  ///
  /// This is the value returned from [ChipTheme.of].
  final ChipThemeData chipTheme;

  /// A theme for customizing the appearance and layout of [DataTable]
  /// widgets.
  final DataTableThemeData dataTableTheme;

  /// A theme for customizing the appearance and layout of [DatePickerDialog]
  /// widgets.
  final DatePickerThemeData datePickerTheme;

  /// A theme for customizing the shape of a dialog.
  final DialogThemeData dialogTheme;

  /// A theme for customizing the color, thickness, and indents of [Divider]s,
  /// [VerticalDivider]s, etc.
  final DividerThemeData dividerTheme;

  /// A theme for customizing the appearance and layout of [Drawer] widgets.
  final DrawerThemeData drawerTheme;

  /// A theme for customizing the appearance and layout of [DropdownMenu] widgets.
  final DropdownMenuThemeData dropdownMenuTheme;

  /// A theme for customizing the appearance and internal layout of
  /// [ElevatedButton]s.
  final ElevatedButtonThemeData elevatedButtonTheme;

  /// A theme for customizing the visual properties of [ExpansionTile]s.
  final ExpansionTileThemeData expansionTileTheme;

  /// A theme for customizing the appearance and internal layout of
  /// [FilledButton]s.
  final FilledButtonThemeData filledButtonTheme;

  /// A theme for customizing the shape, elevation, and color of a
  /// [FloatingActionButton].
  final FloatingActionButtonThemeData floatingActionButtonTheme;

  /// A theme for customizing the appearance and internal layout of
  /// [IconButton]s.
  final IconButtonThemeData iconButtonTheme;

  /// A theme for customizing the appearance of [ListTile] widgets.
  final ListTileThemeData listTileTheme;

  /// A theme for customizing the color, shape, elevation, and other [MenuStyle]
  /// aspects of the menu bar created by the [MenuBar] widget.
  final MenuBarThemeData menuBarTheme;

  /// A theme for customizing the color, shape, elevation, and text style of
  /// cascading menu buttons created by [SubmenuButton] or [MenuItemButton].
  final MenuButtonThemeData menuButtonTheme;

  /// A theme for customizing the color, shape, elevation, and other [MenuStyle]
  /// attributes of menus created by the [SubmenuButton] widget.
  final MenuThemeData menuTheme;

  /// A theme for customizing the background color, text style, and icon themes
  /// of a [NavigationBar].
  final NavigationBarThemeData navigationBarTheme;

  /// A theme for customizing the background color, text style, and icon themes
  /// of a [NavigationDrawer].
  final NavigationDrawerThemeData navigationDrawerTheme;

  /// A theme for customizing the background color, elevation, text style, and
  /// icon themes of a [NavigationRail].
  final NavigationRailThemeData navigationRailTheme;

  /// A theme for customizing the appearance and internal layout of
  /// [OutlinedButton]s.
  final OutlinedButtonThemeData outlinedButtonTheme;

  /// A theme for customizing the color, shape, elevation, and text style of
  /// popup menus.
  final PopupMenuThemeData popupMenuTheme;

  /// A theme for customizing the appearance and layout of [ProgressIndicator] widgets.
  final ProgressIndicatorThemeData progressIndicatorTheme;

  /// A theme for customizing the appearance and layout of [Radio] widgets.
  final RadioThemeData radioTheme;

  /// A theme for customizing the appearance and layout of [SearchBar] widgets.
  final SearchBarThemeData searchBarTheme;

  /// A theme for customizing the appearance and layout of search views created by [SearchAnchor] widgets.
  final SearchViewThemeData searchViewTheme;

  /// A theme for customizing the appearance and layout of [SegmentedButton] widgets.
  final SegmentedButtonThemeData segmentedButtonTheme;

  /// The colors and shapes used to render [Slider].
  ///
  /// This is the value returned from [SliderTheme.of].
  final SliderThemeData sliderTheme;

  /// A theme for customizing colors, shape, elevation, and behavior of a [SnackBar].
  final SnackBarThemeData snackBarTheme;

  /// A theme for customizing the appearance and layout of [Switch] widgets.
  final SwitchThemeData switchTheme;

  /// A theme for customizing the size, shape, and color of the tab bar indicator.
  final TabBarThemeData tabBarTheme;

  /// A theme for customizing the appearance and internal layout of
  /// [TextButton]s.
  final TextButtonThemeData textButtonTheme;

  /// A theme for customizing the appearance and layout of [TextField] widgets.
  final TextSelectionThemeData textSelectionTheme;

  /// A theme for customizing the appearance and layout of time picker widgets.
  final TimePickerThemeData timePickerTheme;

  /// Defines the default configuration of [ToggleButtons] widgets.
  final ToggleButtonsThemeData toggleButtonsTheme;

  /// A theme for customizing the visual properties of [Tooltip]s.
  ///
  /// This is the value returned from [TooltipTheme.of].
  final TooltipThemeData tooltipTheme;

  /// A theme for customizing the appearance and layout of [ButtonBar] widgets.
  @Deprecated(
    'Use OverflowBar instead. '
    'This feature was deprecated after v3.21.0-10.0.pre.',
  )
  ButtonBarThemeData get buttonBarTheme => _buttonBarTheme!;
  final ButtonBarThemeData? _buttonBarTheme;

  /// The background color of [Dialog] elements.
  @Deprecated(
    'Use DialogThemeData.backgroundColor instead. '
    'This feature was deprecated after v3.27.0-0.1.pre.',
  )
  final Color dialogBackgroundColor;

  /// Creates a copy of this theme but with the given fields replaced with the new values.
  ///
  /// The [brightness] value is applied to the [colorScheme].
  ThemeData copyWith({
    // For the sanity of the reader, make sure these properties are in the same
    // order in every place that they are separated by section comments (e.g.
    // GENERAL CONFIGURATION). Each section except for deprecations should be
    // alphabetical by symbol name.

    // GENERAL CONFIGURATION
    Iterable<Adaptation<Object>>? adaptations,
    bool? applyElevationOverlayColor,
    NoDefaultCupertinoThemeData? cupertinoOverrideTheme,
    Iterable<ThemeExtension<dynamic>>? extensions,
    InputDecorationTheme? inputDecorationTheme,
    MaterialTapTargetSize? materialTapTargetSize,
    PageTransitionsTheme? pageTransitionsTheme,
    TargetPlatform? platform,
    ScrollbarThemeData? scrollbarTheme,
    InteractiveInkFeatureFactory? splashFactory,
    VisualDensity? visualDensity,
    // COLOR
    ColorScheme? colorScheme,
    Brightness? brightness,
    // [colorScheme] is the preferred way to configure colors. The [Color] properties
    // listed below (as well as primarySwatch) will gradually be phased out, see
    // https://github.com/flutter/flutter/issues/91772.
    Color? canvasColor,
    Color? cardColor,
    Color? disabledColor,
    Color? dividerColor,
    Color? focusColor,
    Color? highlightColor,
    Color? hintColor,
    Color? hoverColor,
    Color? indicatorColor,
    Color? primaryColor,
    Color? primaryColorDark,
    Color? primaryColorLight,
    Color? scaffoldBackgroundColor,
    Color? secondaryHeaderColor,
    Color? shadowColor,
    Color? splashColor,
    Color? unselectedWidgetColor,
    // TYPOGRAPHY & ICONOGRAPHY
    IconThemeData? iconTheme,
    IconThemeData? primaryIconTheme,
    TextTheme? primaryTextTheme,
    TextTheme? textTheme,
    Typography? typography,
    // COMPONENT THEMES
    ActionIconThemeData? actionIconTheme,
    AppBarTheme? appBarTheme,
    BadgeThemeData? badgeTheme,
    MaterialBannerThemeData? bannerTheme,
    BottomAppBarTheme? bottomAppBarTheme,
    BottomNavigationBarThemeData? bottomNavigationBarTheme,
    BottomSheetThemeData? bottomSheetTheme,
    ButtonThemeData? buttonTheme,
    Object? cardTheme,
    CheckboxThemeData? checkboxTheme,
    ChipThemeData? chipTheme,
    DataTableThemeData? dataTableTheme,
    DatePickerThemeData? datePickerTheme,
    // TODO(QuncCccccc): Change the parameter type to DialogThemeData
    Object? dialogTheme,
    DividerThemeData? dividerTheme,
    DrawerThemeData? drawerTheme,
    DropdownMenuThemeData? dropdownMenuTheme,
    ElevatedButtonThemeData? elevatedButtonTheme,
    ExpansionTileThemeData? expansionTileTheme,
    FilledButtonThemeData? filledButtonTheme,
    FloatingActionButtonThemeData? floatingActionButtonTheme,
    IconButtonThemeData? iconButtonTheme,
    ListTileThemeData? listTileTheme,
    MenuBarThemeData? menuBarTheme,
    MenuButtonThemeData? menuButtonTheme,
    MenuThemeData? menuTheme,
    NavigationBarThemeData? navigationBarTheme,
    NavigationDrawerThemeData? navigationDrawerTheme,
    NavigationRailThemeData? navigationRailTheme,
    OutlinedButtonThemeData? outlinedButtonTheme,
    PopupMenuThemeData? popupMenuTheme,
    ProgressIndicatorThemeData? progressIndicatorTheme,
    RadioThemeData? radioTheme,
    SearchBarThemeData? searchBarTheme,
    SearchViewThemeData? searchViewTheme,
    SegmentedButtonThemeData? segmentedButtonTheme,
    SliderThemeData? sliderTheme,
    SnackBarThemeData? snackBarTheme,
    SwitchThemeData? switchTheme,
    // TODO(QuncCccccc): Change the parameter type to TabBarThemeData
    Object? tabBarTheme,
    TextButtonThemeData? textButtonTheme,
    TextSelectionThemeData? textSelectionTheme,
    TimePickerThemeData? timePickerTheme,
    ToggleButtonsThemeData? toggleButtonsTheme,
    TooltipThemeData? tooltipTheme,
    // DEPRECATED (newest deprecations at the bottom)
    @Deprecated(
      'Use a ThemeData constructor (.from, .light, or .dark) instead. '
      'These constructors all have a useMaterial3 argument, '
      'and they set appropriate default values based on its value. '
      'See the useMaterial3 API documentation for full details. '
      'This feature was deprecated after v3.13.0-0.2.pre.',
    )
    bool? useMaterial3,
    @Deprecated(
      'Use OverflowBar instead. '
      'This feature was deprecated after v3.21.0-10.0.pre.',
    )
    ButtonBarThemeData? buttonBarTheme,
    @Deprecated(
      'Use DialogThemeData.backgroundColor instead. '
      'This feature was deprecated after v3.27.0-0.1.pre.',
    )
    Color? dialogBackgroundColor,
  }) {
    cupertinoOverrideTheme = cupertinoOverrideTheme?.noDefault();

    // TODO(QuncCccccc): Clean it up once the type of `cardTheme` is changed to `CardThemeData`
    if (cardTheme != null) {
      if (cardTheme is CardTheme) {
        cardTheme = cardTheme.data;
      } else if (cardTheme is! CardThemeData) {
        throw ArgumentError('cardTheme must be either a CardThemeData or a CardTheme');
      }
    }

    // TODO(QuncCccccc): Clean this up once the type of `dialogTheme` is changed to `DialogThemeData`
    if (dialogTheme != null) {
      if (dialogTheme is DialogTheme) {
        dialogTheme = dialogTheme.data;
      } else if (dialogTheme is! DialogThemeData) {
        throw ArgumentError('dialogTheme must be either a DialogThemeData or a DialogTheme');
      }
    }

    // TODO(QuncCccccc): Clean this up once the type of `tabBarTheme` is changed to `TabBarThemeData`
    if (tabBarTheme != null) {
      if (tabBarTheme is TabBarTheme) {
        tabBarTheme = tabBarTheme.data;
      } else if (tabBarTheme is! TabBarThemeData) {
        throw ArgumentError('tabBarTheme must be either a TabBarThemeData or a TabBarTheme');
      }
    }
    return ThemeData.raw(
      // For the sanity of the reader, make sure these properties are in the same
      // order in every place that they are separated by section comments (e.g.
      // GENERAL CONFIGURATION). Each section except for deprecations should be
      // alphabetical by symbol name.

      // GENERAL CONFIGURATION
      adaptationMap: adaptations != null ? _createAdaptationMap(adaptations) : adaptationMap,
      applyElevationOverlayColor: applyElevationOverlayColor ?? this.applyElevationOverlayColor,
      cupertinoOverrideTheme: cupertinoOverrideTheme ?? this.cupertinoOverrideTheme,
      extensions: (extensions != null) ? _themeExtensionIterableToMap(extensions) : this.extensions,
      inputDecorationTheme: inputDecorationTheme ?? this.inputDecorationTheme,
      materialTapTargetSize: materialTapTargetSize ?? this.materialTapTargetSize,
      pageTransitionsTheme: pageTransitionsTheme ?? this.pageTransitionsTheme,
      platform: platform ?? this.platform,
      scrollbarTheme: scrollbarTheme ?? this.scrollbarTheme,
      splashFactory: splashFactory ?? this.splashFactory,
      // When deprecated useMaterial3 removed, maintain `this.useMaterial3` here
      // for == evaluation.
      useMaterial3: useMaterial3 ?? this.useMaterial3,
      visualDensity: visualDensity ?? this.visualDensity,
      // COLOR
      canvasColor: canvasColor ?? this.canvasColor,
      cardColor: cardColor ?? this.cardColor,
      colorScheme: (colorScheme ?? this.colorScheme).copyWith(brightness: brightness),
      disabledColor: disabledColor ?? this.disabledColor,
      dividerColor: dividerColor ?? this.dividerColor,
      focusColor: focusColor ?? this.focusColor,
      highlightColor: highlightColor ?? this.highlightColor,
      hintColor: hintColor ?? this.hintColor,
      hoverColor: hoverColor ?? this.hoverColor,
      indicatorColor: indicatorColor ?? this.indicatorColor,
      primaryColor: primaryColor ?? this.primaryColor,
      primaryColorDark: primaryColorDark ?? this.primaryColorDark,
      primaryColorLight: primaryColorLight ?? this.primaryColorLight,
      scaffoldBackgroundColor: scaffoldBackgroundColor ?? this.scaffoldBackgroundColor,
      secondaryHeaderColor: secondaryHeaderColor ?? this.secondaryHeaderColor,
      shadowColor: shadowColor ?? this.shadowColor,
      splashColor: splashColor ?? this.splashColor,
      unselectedWidgetColor: unselectedWidgetColor ?? this.unselectedWidgetColor,
      // TYPOGRAPHY & ICONOGRAPHY
      iconTheme: iconTheme ?? this.iconTheme,
      primaryIconTheme: primaryIconTheme ?? this.primaryIconTheme,
      primaryTextTheme: primaryTextTheme ?? this.primaryTextTheme,
      textTheme: textTheme ?? this.textTheme,
      typography: typography ?? this.typography,
      // COMPONENT THEMES
      actionIconTheme: actionIconTheme ?? this.actionIconTheme,
      appBarTheme: appBarTheme ?? this.appBarTheme,
      badgeTheme: badgeTheme ?? this.badgeTheme,
      bannerTheme: bannerTheme ?? this.bannerTheme,
      bottomAppBarTheme: bottomAppBarTheme ?? this.bottomAppBarTheme,
      bottomNavigationBarTheme: bottomNavigationBarTheme ?? this.bottomNavigationBarTheme,
      bottomSheetTheme: bottomSheetTheme ?? this.bottomSheetTheme,
      buttonTheme: buttonTheme ?? this.buttonTheme,
      cardTheme: cardTheme as CardThemeData? ?? this.cardTheme,
      checkboxTheme: checkboxTheme ?? this.checkboxTheme,
      chipTheme: chipTheme ?? this.chipTheme,
      dataTableTheme: dataTableTheme ?? this.dataTableTheme,
      datePickerTheme: datePickerTheme ?? this.datePickerTheme,
      dialogTheme: dialogTheme as DialogThemeData? ?? this.dialogTheme,
      dividerTheme: dividerTheme ?? this.dividerTheme,
      drawerTheme: drawerTheme ?? this.drawerTheme,
      dropdownMenuTheme: dropdownMenuTheme ?? this.dropdownMenuTheme,
      elevatedButtonTheme: elevatedButtonTheme ?? this.elevatedButtonTheme,
      expansionTileTheme: expansionTileTheme ?? this.expansionTileTheme,
      filledButtonTheme: filledButtonTheme ?? this.filledButtonTheme,
      floatingActionButtonTheme: floatingActionButtonTheme ?? this.floatingActionButtonTheme,
      iconButtonTheme: iconButtonTheme ?? this.iconButtonTheme,
      listTileTheme: listTileTheme ?? this.listTileTheme,
      menuBarTheme: menuBarTheme ?? this.menuBarTheme,
      menuButtonTheme: menuButtonTheme ?? this.menuButtonTheme,
      menuTheme: menuTheme ?? this.menuTheme,
      navigationBarTheme: navigationBarTheme ?? this.navigationBarTheme,
      navigationDrawerTheme: navigationDrawerTheme ?? this.navigationDrawerTheme,
      navigationRailTheme: navigationRailTheme ?? this.navigationRailTheme,
      outlinedButtonTheme: outlinedButtonTheme ?? this.outlinedButtonTheme,
      popupMenuTheme: popupMenuTheme ?? this.popupMenuTheme,
      progressIndicatorTheme: progressIndicatorTheme ?? this.progressIndicatorTheme,
      radioTheme: radioTheme ?? this.radioTheme,
      searchBarTheme: searchBarTheme ?? this.searchBarTheme,
      searchViewTheme: searchViewTheme ?? this.searchViewTheme,
      segmentedButtonTheme: segmentedButtonTheme ?? this.segmentedButtonTheme,
      sliderTheme: sliderTheme ?? this.sliderTheme,
      snackBarTheme: snackBarTheme ?? this.snackBarTheme,
      switchTheme: switchTheme ?? this.switchTheme,
      tabBarTheme: tabBarTheme as TabBarThemeData? ?? this.tabBarTheme,
      textButtonTheme: textButtonTheme ?? this.textButtonTheme,
      textSelectionTheme: textSelectionTheme ?? this.textSelectionTheme,
      timePickerTheme: timePickerTheme ?? this.timePickerTheme,
      toggleButtonsTheme: toggleButtonsTheme ?? this.toggleButtonsTheme,
      tooltipTheme: tooltipTheme ?? this.tooltipTheme,
      // DEPRECATED (newest deprecations at the bottom)
      buttonBarTheme: buttonBarTheme ?? _buttonBarTheme,
      dialogBackgroundColor: dialogBackgroundColor ?? this.dialogBackgroundColor,
    );
  }

  // The number 5 was chosen without any real science or research behind it. It
  // just seemed like a number that's not too big (we should be able to fit 5
  // copies of ThemeData in memory comfortably) and not too small (most apps
  // shouldn't have more than 5 theme/localization pairs).
  static const int _localizedThemeDataCacheSize = 5;

  /// Caches localized themes to speed up the [localize] method.
  static final _FifoCache<_IdentityThemeDataCacheKey, ThemeData> _localizedThemeDataCache =
      _FifoCache<_IdentityThemeDataCacheKey, ThemeData>(_localizedThemeDataCacheSize);

  /// Returns a new theme built by merging the text geometry provided by the
  /// [localTextGeometry] theme with the [baseTheme].
  ///
  /// For those text styles in the [baseTheme] whose [TextStyle.inherit] is set
  /// to true, the returned theme's text styles inherit the geometric properties
  /// of [localTextGeometry]. The resulting text styles' [TextStyle.inherit] is
  /// set to those provided by [localTextGeometry].
  static ThemeData localize(ThemeData baseTheme, TextTheme localTextGeometry) {
    // WARNING: this method memoizes the result in a cache based on the
    // previously seen baseTheme and localTextGeometry. Memoization is safe
    // because all inputs and outputs of this function are deeply immutable, and
    // the computations are referentially transparent. It only short-circuits
    // the computation if the new inputs are identical() to the previous ones.
    // It does not use the == operator, which performs a costly deep comparison.
    //
    // When changing this method, make sure the memoization logic is correct.
    // Remember:
    //
    // There are only two hard things in Computer Science: cache invalidation
    // and naming things. -- Phil Karlton

    return _localizedThemeDataCache.putIfAbsent(
      _IdentityThemeDataCacheKey(baseTheme, localTextGeometry),
      () {
        return baseTheme.copyWith(
          primaryTextTheme: localTextGeometry.merge(baseTheme.primaryTextTheme),
          textTheme: localTextGeometry.merge(baseTheme.textTheme),
        );
      },
    );
  }

  /// Determines whether the given [Color] is [Brightness.light] or
  /// [Brightness.dark].
  ///
  /// This compares the luminosity of the given color to a threshold value that
  /// matches the Material Design specification.
  static Brightness estimateBrightnessForColor(Color color) {
    final double relativeLuminance = color.computeLuminance();

    // See <https://www.w3.org/TR/WCAG20/#contrast-ratiodef>
    // The spec says to use kThreshold=0.0525, but Material Design appears to bias
    // more towards using light text than WCAG20 recommends. Material Design spec
    // doesn't say what value to use, but 0.15 seemed close to what the Material
    // Design spec shows for its color palette on
    // <https://material.io/go/design-theming#color-color-palette>.
    const double kThreshold = 0.15;
    if ((relativeLuminance + 0.05) * (relativeLuminance + 0.05) > kThreshold) {
      return Brightness.light;
    }
    return Brightness.dark;
  }

  /// Linearly interpolate between two [extensions].
  ///
  /// Includes all theme extensions in [a] and [b].
  ///
  /// {@macro dart.ui.shadow.lerp}
  static Map<Object, ThemeExtension<dynamic>> _lerpThemeExtensions(
    ThemeData a,
    ThemeData b,
    double t,
  ) {
    // Lerp [a].
    final Map<Object, ThemeExtension<dynamic>> newExtensions = a.extensions.map((
      Object id,
      ThemeExtension<dynamic> extensionA,
    ) {
      final ThemeExtension<dynamic>? extensionB = b.extensions[id];
      return MapEntry<Object, ThemeExtension<dynamic>>(id, extensionA.lerp(extensionB, t));
    });
    // Add [b]-only extensions.
    newExtensions.addEntries(
      b.extensions.entries.where(
        (MapEntry<Object, ThemeExtension<dynamic>> entry) => !a.extensions.containsKey(entry.key),
      ),
    );

    return newExtensions;
  }

  /// Convert the [extensionsIterable] passed to [ThemeData.new] or [copyWith]
  /// to the stored [extensions] map, where each entry's key consists of the extension's type.
  static Map<Object, ThemeExtension<dynamic>> _themeExtensionIterableToMap(
    Iterable<ThemeExtension<dynamic>> extensionsIterable,
  ) {
    return Map<Object, ThemeExtension<dynamic>>.unmodifiable(<Object, ThemeExtension<dynamic>>{
      // Strangely, the cast is necessary for tests to run.
      for (final ThemeExtension<dynamic> extension in extensionsIterable)
        extension.type: extension as ThemeExtension<ThemeExtension<dynamic>>,
    });
  }

  /// Linearly interpolate between two themes.
  ///
  /// {@macro dart.ui.shadow.lerp}
  static ThemeData lerp(ThemeData a, ThemeData b, double t) {
    if (identical(a, b)) {
      return a;
    }
    return ThemeData.raw(
      // For the sanity of the reader, make sure these properties are in the same
      // order in every place that they are separated by section comments (e.g.
      // GENERAL CONFIGURATION). Each section except for deprecations should be
      // alphabetical by symbol name.

      // GENERAL CONFIGURATION
      adaptationMap: t < 0.5 ? a.adaptationMap : b.adaptationMap,
      applyElevationOverlayColor:
          t < 0.5 ? a.applyElevationOverlayColor : b.applyElevationOverlayColor,
      cupertinoOverrideTheme: t < 0.5 ? a.cupertinoOverrideTheme : b.cupertinoOverrideTheme,
      extensions: _lerpThemeExtensions(a, b, t),
      inputDecorationTheme: t < 0.5 ? a.inputDecorationTheme : b.inputDecorationTheme,
      materialTapTargetSize: t < 0.5 ? a.materialTapTargetSize : b.materialTapTargetSize,
      pageTransitionsTheme: t < 0.5 ? a.pageTransitionsTheme : b.pageTransitionsTheme,
      platform: t < 0.5 ? a.platform : b.platform,
      scrollbarTheme: ScrollbarThemeData.lerp(a.scrollbarTheme, b.scrollbarTheme, t),
      splashFactory: t < 0.5 ? a.splashFactory : b.splashFactory,
      useMaterial3: t < 0.5 ? a.useMaterial3 : b.useMaterial3,
      visualDensity: VisualDensity.lerp(a.visualDensity, b.visualDensity, t),
      // COLOR
      canvasColor: Color.lerp(a.canvasColor, b.canvasColor, t)!,
      cardColor: Color.lerp(a.cardColor, b.cardColor, t)!,
      colorScheme: ColorScheme.lerp(a.colorScheme, b.colorScheme, t),
      disabledColor: Color.lerp(a.disabledColor, b.disabledColor, t)!,
      dividerColor: Color.lerp(a.dividerColor, b.dividerColor, t)!,
      focusColor: Color.lerp(a.focusColor, b.focusColor, t)!,
      highlightColor: Color.lerp(a.highlightColor, b.highlightColor, t)!,
      hintColor: Color.lerp(a.hintColor, b.hintColor, t)!,
      hoverColor: Color.lerp(a.hoverColor, b.hoverColor, t)!,
      indicatorColor: Color.lerp(a.indicatorColor, b.indicatorColor, t)!,
      primaryColor: Color.lerp(a.primaryColor, b.primaryColor, t)!,
      primaryColorDark: Color.lerp(a.primaryColorDark, b.primaryColorDark, t)!,
      primaryColorLight: Color.lerp(a.primaryColorLight, b.primaryColorLight, t)!,
      scaffoldBackgroundColor: Color.lerp(a.scaffoldBackgroundColor, b.scaffoldBackgroundColor, t)!,
      secondaryHeaderColor: Color.lerp(a.secondaryHeaderColor, b.secondaryHeaderColor, t)!,
      shadowColor: Color.lerp(a.shadowColor, b.shadowColor, t)!,
      splashColor: Color.lerp(a.splashColor, b.splashColor, t)!,
      unselectedWidgetColor: Color.lerp(a.unselectedWidgetColor, b.unselectedWidgetColor, t)!,
      // TYPOGRAPHY & ICONOGRAPHY
      iconTheme: IconThemeData.lerp(a.iconTheme, b.iconTheme, t),
      primaryIconTheme: IconThemeData.lerp(a.primaryIconTheme, b.primaryIconTheme, t),
      primaryTextTheme: TextTheme.lerp(a.primaryTextTheme, b.primaryTextTheme, t),
      textTheme: TextTheme.lerp(a.textTheme, b.textTheme, t),
      typography: Typography.lerp(a.typography, b.typography, t),
      // COMPONENT THEMES
      actionIconTheme: ActionIconThemeData.lerp(a.actionIconTheme, b.actionIconTheme, t),
      appBarTheme: AppBarTheme.lerp(a.appBarTheme, b.appBarTheme, t),
      badgeTheme: BadgeThemeData.lerp(a.badgeTheme, b.badgeTheme, t),
      bannerTheme: MaterialBannerThemeData.lerp(a.bannerTheme, b.bannerTheme, t),
      bottomAppBarTheme: BottomAppBarTheme.lerp(a.bottomAppBarTheme, b.bottomAppBarTheme, t),
      bottomNavigationBarTheme: BottomNavigationBarThemeData.lerp(
        a.bottomNavigationBarTheme,
        b.bottomNavigationBarTheme,
        t,
      ),
      bottomSheetTheme: BottomSheetThemeData.lerp(a.bottomSheetTheme, b.bottomSheetTheme, t)!,
      buttonTheme: t < 0.5 ? a.buttonTheme : b.buttonTheme,
      cardTheme: CardThemeData.lerp(a.cardTheme, b.cardTheme, t),
      checkboxTheme: CheckboxThemeData.lerp(a.checkboxTheme, b.checkboxTheme, t),
      chipTheme: ChipThemeData.lerp(a.chipTheme, b.chipTheme, t)!,
      dataTableTheme: DataTableThemeData.lerp(a.dataTableTheme, b.dataTableTheme, t),
      datePickerTheme: DatePickerThemeData.lerp(a.datePickerTheme, b.datePickerTheme, t),
      dialogTheme: DialogThemeData.lerp(a.dialogTheme, b.dialogTheme, t),
      dividerTheme: DividerThemeData.lerp(a.dividerTheme, b.dividerTheme, t),
      drawerTheme: DrawerThemeData.lerp(a.drawerTheme, b.drawerTheme, t)!,
      dropdownMenuTheme: DropdownMenuThemeData.lerp(a.dropdownMenuTheme, b.dropdownMenuTheme, t),
      elevatedButtonTheme:
          ElevatedButtonThemeData.lerp(a.elevatedButtonTheme, b.elevatedButtonTheme, t)!,
      expansionTileTheme:
          ExpansionTileThemeData.lerp(a.expansionTileTheme, b.expansionTileTheme, t)!,
      filledButtonTheme: FilledButtonThemeData.lerp(a.filledButtonTheme, b.filledButtonTheme, t)!,
      floatingActionButtonTheme:
          FloatingActionButtonThemeData.lerp(
            a.floatingActionButtonTheme,
            b.floatingActionButtonTheme,
            t,
          )!,
      iconButtonTheme: IconButtonThemeData.lerp(a.iconButtonTheme, b.iconButtonTheme, t)!,
      listTileTheme: ListTileThemeData.lerp(a.listTileTheme, b.listTileTheme, t)!,
      menuBarTheme: MenuBarThemeData.lerp(a.menuBarTheme, b.menuBarTheme, t)!,
      menuButtonTheme: MenuButtonThemeData.lerp(a.menuButtonTheme, b.menuButtonTheme, t)!,
      menuTheme: MenuThemeData.lerp(a.menuTheme, b.menuTheme, t)!,
      navigationBarTheme:
          NavigationBarThemeData.lerp(a.navigationBarTheme, b.navigationBarTheme, t)!,
      navigationDrawerTheme:
          NavigationDrawerThemeData.lerp(a.navigationDrawerTheme, b.navigationDrawerTheme, t)!,
      navigationRailTheme:
          NavigationRailThemeData.lerp(a.navigationRailTheme, b.navigationRailTheme, t)!,
      outlinedButtonTheme:
          OutlinedButtonThemeData.lerp(a.outlinedButtonTheme, b.outlinedButtonTheme, t)!,
      popupMenuTheme: PopupMenuThemeData.lerp(a.popupMenuTheme, b.popupMenuTheme, t)!,
      progressIndicatorTheme:
          ProgressIndicatorThemeData.lerp(a.progressIndicatorTheme, b.progressIndicatorTheme, t)!,
      radioTheme: RadioThemeData.lerp(a.radioTheme, b.radioTheme, t),
      searchBarTheme: SearchBarThemeData.lerp(a.searchBarTheme, b.searchBarTheme, t)!,
      searchViewTheme: SearchViewThemeData.lerp(a.searchViewTheme, b.searchViewTheme, t)!,
      segmentedButtonTheme: SegmentedButtonThemeData.lerp(
        a.segmentedButtonTheme,
        b.segmentedButtonTheme,
        t,
      ),
      sliderTheme: SliderThemeData.lerp(a.sliderTheme, b.sliderTheme, t),
      snackBarTheme: SnackBarThemeData.lerp(a.snackBarTheme, b.snackBarTheme, t),
      switchTheme: SwitchThemeData.lerp(a.switchTheme, b.switchTheme, t),
      tabBarTheme: TabBarThemeData.lerp(a.tabBarTheme, b.tabBarTheme, t),
      textButtonTheme: TextButtonThemeData.lerp(a.textButtonTheme, b.textButtonTheme, t)!,
      textSelectionTheme:
          TextSelectionThemeData.lerp(a.textSelectionTheme, b.textSelectionTheme, t)!,
      timePickerTheme: TimePickerThemeData.lerp(a.timePickerTheme, b.timePickerTheme, t),
      toggleButtonsTheme:
          ToggleButtonsThemeData.lerp(a.toggleButtonsTheme, b.toggleButtonsTheme, t)!,
      tooltipTheme: TooltipThemeData.lerp(a.tooltipTheme, b.tooltipTheme, t)!,
      // DEPRECATED (newest deprecations at the bottom)
      buttonBarTheme: ButtonBarThemeData.lerp(a.buttonBarTheme, b.buttonBarTheme, t),
      dialogBackgroundColor: Color.lerp(a.dialogBackgroundColor, b.dialogBackgroundColor, t)!,
    );
  }

  @override
  bool operator ==(Object other) {
    if (other.runtimeType != runtimeType) {
      return false;
    }
    return other is ThemeData &&
        // For the sanity of the reader, make sure these properties are in the same
        // order in every place that they are separated by section comments (e.g.
        // GENERAL CONFIGURATION). Each section except for deprecations should be
        // alphabetical by symbol name.
        // GENERAL CONFIGURATION
        mapEquals(other.adaptationMap, adaptationMap) &&
        other.applyElevationOverlayColor == applyElevationOverlayColor &&
        other.cupertinoOverrideTheme == cupertinoOverrideTheme &&
        mapEquals(other.extensions, extensions) &&
        other.inputDecorationTheme == inputDecorationTheme &&
        other.materialTapTargetSize == materialTapTargetSize &&
        other.pageTransitionsTheme == pageTransitionsTheme &&
        other.platform == platform &&
        other.scrollbarTheme == scrollbarTheme &&
        other.splashFactory == splashFactory &&
        other.useMaterial3 == useMaterial3 &&
        other.visualDensity == visualDensity &&
        // COLOR
        other.canvasColor == canvasColor &&
        other.cardColor == cardColor &&
        other.colorScheme == colorScheme &&
        other.disabledColor == disabledColor &&
        other.dividerColor == dividerColor &&
        other.focusColor == focusColor &&
        other.highlightColor == highlightColor &&
        other.hintColor == hintColor &&
        other.hoverColor == hoverColor &&
        other.indicatorColor == indicatorColor &&
        other.primaryColor == primaryColor &&
        other.primaryColorDark == primaryColorDark &&
        other.primaryColorLight == primaryColorLight &&
        other.scaffoldBackgroundColor == scaffoldBackgroundColor &&
        other.secondaryHeaderColor == secondaryHeaderColor &&
        other.shadowColor == shadowColor &&
        other.splashColor == splashColor &&
        other.unselectedWidgetColor == unselectedWidgetColor &&
        // TYPOGRAPHY & ICONOGRAPHY
        other.iconTheme == iconTheme &&
        other.primaryIconTheme == primaryIconTheme &&
        other.primaryTextTheme == primaryTextTheme &&
        other.textTheme == textTheme &&
        other.typography == typography &&
        // COMPONENT THEMES
        other.actionIconTheme == actionIconTheme &&
        other.appBarTheme == appBarTheme &&
        other.badgeTheme == badgeTheme &&
        other.bannerTheme == bannerTheme &&
        other.bottomAppBarTheme == bottomAppBarTheme &&
        other.bottomNavigationBarTheme == bottomNavigationBarTheme &&
        other.bottomSheetTheme == bottomSheetTheme &&
        other.buttonTheme == buttonTheme &&
        other.cardTheme == cardTheme &&
        other.checkboxTheme == checkboxTheme &&
        other.chipTheme == chipTheme &&
        other.dataTableTheme == dataTableTheme &&
        other.datePickerTheme == datePickerTheme &&
        other.dialogTheme == dialogTheme &&
        other.dividerTheme == dividerTheme &&
        other.drawerTheme == drawerTheme &&
        other.dropdownMenuTheme == dropdownMenuTheme &&
        other.elevatedButtonTheme == elevatedButtonTheme &&
        other.expansionTileTheme == expansionTileTheme &&
        other.filledButtonTheme == filledButtonTheme &&
        other.floatingActionButtonTheme == floatingActionButtonTheme &&
        other.iconButtonTheme == iconButtonTheme &&
        other.listTileTheme == listTileTheme &&
        other.menuBarTheme == menuBarTheme &&
        other.menuButtonTheme == menuButtonTheme &&
        other.menuTheme == menuTheme &&
        other.navigationBarTheme == navigationBarTheme &&
        other.navigationDrawerTheme == navigationDrawerTheme &&
        other.navigationRailTheme == navigationRailTheme &&
        other.outlinedButtonTheme == outlinedButtonTheme &&
        other.popupMenuTheme == popupMenuTheme &&
        other.progressIndicatorTheme == progressIndicatorTheme &&
        other.radioTheme == radioTheme &&
        other.searchBarTheme == searchBarTheme &&
        other.searchViewTheme == searchViewTheme &&
        other.segmentedButtonTheme == segmentedButtonTheme &&
        other.sliderTheme == sliderTheme &&
        other.snackBarTheme == snackBarTheme &&
        other.switchTheme == switchTheme &&
        other.tabBarTheme == tabBarTheme &&
        other.textButtonTheme == textButtonTheme &&
        other.textSelectionTheme == textSelectionTheme &&
        other.timePickerTheme == timePickerTheme &&
        other.toggleButtonsTheme == toggleButtonsTheme &&
        other.tooltipTheme == tooltipTheme &&
        // DEPRECATED (newest deprecations at the bottom)
        other.buttonBarTheme == buttonBarTheme &&
        other.dialogBackgroundColor == dialogBackgroundColor;
  }

  @override
  int get hashCode {
    final List<Object?> values = <Object?>[
      // For the sanity of the reader, make sure these properties are in the same
      // order in every place that they are separated by section comments (e.g.
      // GENERAL CONFIGURATION). Each section except for deprecations should be
      // alphabetical by symbol name.

      // GENERAL CONFIGURATION
      ...adaptationMap.keys,
      ...adaptationMap.values,
      applyElevationOverlayColor,
      cupertinoOverrideTheme,
      ...extensions.keys,
      ...extensions.values,
      inputDecorationTheme,
      materialTapTargetSize,
      pageTransitionsTheme,
      platform,
      scrollbarTheme,
      splashFactory,
      useMaterial3,
      visualDensity,
      // COLOR
      canvasColor,
      cardColor,
      colorScheme,
      disabledColor,
      dividerColor,
      focusColor,
      highlightColor,
      hintColor,
      hoverColor,
      indicatorColor,
      primaryColor,
      primaryColorDark,
      primaryColorLight,
      scaffoldBackgroundColor,
      secondaryHeaderColor,
      shadowColor,
      splashColor,
      unselectedWidgetColor,
      // TYPOGRAPHY & ICONOGRAPHY
      iconTheme,
      primaryIconTheme,
      primaryTextTheme,
      textTheme,
      typography,
      // COMPONENT THEMES
      actionIconTheme,
      appBarTheme,
      badgeTheme,
      bannerTheme,
      bottomAppBarTheme,
      bottomNavigationBarTheme,
      bottomSheetTheme,
      buttonTheme,
      cardTheme,
      checkboxTheme,
      chipTheme,
      dataTableTheme,
      datePickerTheme,
      dialogTheme,
      dividerTheme,
      drawerTheme,
      dropdownMenuTheme,
      elevatedButtonTheme,
      expansionTileTheme,
      filledButtonTheme,
      floatingActionButtonTheme,
      iconButtonTheme,
      listTileTheme,
      menuBarTheme,
      menuButtonTheme,
      menuTheme,
      navigationBarTheme,
      navigationDrawerTheme,
      navigationRailTheme,
      outlinedButtonTheme,
      popupMenuTheme,
      progressIndicatorTheme,
      radioTheme,
      searchBarTheme,
      searchViewTheme,
      segmentedButtonTheme,
      sliderTheme,
      snackBarTheme,
      switchTheme,
      tabBarTheme,
      textButtonTheme,
      textSelectionTheme,
      timePickerTheme,
      toggleButtonsTheme,
      tooltipTheme,
      // DEPRECATED (newest deprecations at the bottom)
      buttonBarTheme,
      dialogBackgroundColor,
    ];
    return Object.hashAll(values);
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    final ThemeData defaultData = ThemeData.fallback();
    // For the sanity of the reader, make sure these properties are in the same
    // order in every place that they are separated by section comments (e.g.
    // GENERAL CONFIGURATION). Each section except for deprecations should be
    // alphabetical by symbol name.

    // GENERAL CONFIGURATION
    properties.add(
      IterableProperty<Adaptation<dynamic>>(
        'adaptations',
        adaptationMap.values,
        defaultValue: defaultData.adaptationMap.values,
        level: DiagnosticLevel.debug,
      ),
    );
    properties.add(
      DiagnosticsProperty<bool>(
        'applyElevationOverlayColor',
        applyElevationOverlayColor,
        level: DiagnosticLevel.debug,
      ),
    );
    properties.add(
      DiagnosticsProperty<NoDefaultCupertinoThemeData>(
        'cupertinoOverrideTheme',
        cupertinoOverrideTheme,
        defaultValue: defaultData.cupertinoOverrideTheme,
        level: DiagnosticLevel.debug,
      ),
    );
    properties.add(
      IterableProperty<ThemeExtension<dynamic>>(
        'extensions',
        extensions.values,
        defaultValue: defaultData.extensions.values,
        level: DiagnosticLevel.debug,
      ),
    );
    properties.add(
      DiagnosticsProperty<InputDecorationTheme>(
        'inputDecorationTheme',
        inputDecorationTheme,
        level: DiagnosticLevel.debug,
      ),
    );
    properties.add(
      DiagnosticsProperty<MaterialTapTargetSize>(
        'materialTapTargetSize',
        materialTapTargetSize,
        level: DiagnosticLevel.debug,
      ),
    );
    properties.add(
      DiagnosticsProperty<PageTransitionsTheme>(
        'pageTransitionsTheme',
        pageTransitionsTheme,
        level: DiagnosticLevel.debug,
      ),
    );
    properties.add(
      EnumProperty<TargetPlatform>(
        'platform',
        platform,
        defaultValue: defaultTargetPlatform,
        level: DiagnosticLevel.debug,
      ),
    );
    properties.add(
      DiagnosticsProperty<ScrollbarThemeData>(
        'scrollbarTheme',
        scrollbarTheme,
        defaultValue: defaultData.scrollbarTheme,
        level: DiagnosticLevel.debug,
      ),
    );
    properties.add(
      DiagnosticsProperty<InteractiveInkFeatureFactory>(
        'splashFactory',
        splashFactory,
        defaultValue: defaultData.splashFactory,
        level: DiagnosticLevel.debug,
      ),
    );
    properties.add(
      DiagnosticsProperty<bool>(
        'useMaterial3',
        useMaterial3,
        defaultValue: defaultData.useMaterial3,
        level: DiagnosticLevel.debug,
      ),
    );
    properties.add(
      DiagnosticsProperty<VisualDensity>(
        'visualDensity',
        visualDensity,
        defaultValue: defaultData.visualDensity,
        level: DiagnosticLevel.debug,
      ),
    );
    // COLORS
    properties.add(
      ColorProperty(
        'canvasColor',
        canvasColor,
        defaultValue: defaultData.canvasColor,
        level: DiagnosticLevel.debug,
      ),
    );
    properties.add(
      ColorProperty(
        'cardColor',
        cardColor,
        defaultValue: defaultData.cardColor,
        level: DiagnosticLevel.debug,
      ),
    );
    properties.add(
      DiagnosticsProperty<ColorScheme>(
        'colorScheme',
        colorScheme,
        defaultValue: defaultData.colorScheme,
        level: DiagnosticLevel.debug,
      ),
    );
    properties.add(
      ColorProperty(
        'disabledColor',
        disabledColor,
        defaultValue: defaultData.disabledColor,
        level: DiagnosticLevel.debug,
      ),
    );
    properties.add(
      ColorProperty(
        'dividerColor',
        dividerColor,
        defaultValue: defaultData.dividerColor,
        level: DiagnosticLevel.debug,
      ),
    );
    properties.add(
      ColorProperty(
        'focusColor',
        focusColor,
        defaultValue: defaultData.focusColor,
        level: DiagnosticLevel.debug,
      ),
    );
    properties.add(
      ColorProperty(
        'highlightColor',
        highlightColor,
        defaultValue: defaultData.highlightColor,
        level: DiagnosticLevel.debug,
      ),
    );
    properties.add(
      ColorProperty(
        'hintColor',
        hintColor,
        defaultValue: defaultData.hintColor,
        level: DiagnosticLevel.debug,
      ),
    );
    properties.add(
      ColorProperty(
        'hoverColor',
        hoverColor,
        defaultValue: defaultData.hoverColor,
        level: DiagnosticLevel.debug,
      ),
    );
    properties.add(
      ColorProperty(
        'indicatorColor',
        indicatorColor,
        defaultValue: defaultData.indicatorColor,
        level: DiagnosticLevel.debug,
      ),
    );
    properties.add(
      ColorProperty(
        'primaryColorDark',
        primaryColorDark,
        defaultValue: defaultData.primaryColorDark,
        level: DiagnosticLevel.debug,
      ),
    );
    properties.add(
      ColorProperty(
        'primaryColorLight',
        primaryColorLight,
        defaultValue: defaultData.primaryColorLight,
        level: DiagnosticLevel.debug,
      ),
    );
    properties.add(
      ColorProperty(
        'primaryColor',
        primaryColor,
        defaultValue: defaultData.primaryColor,
        level: DiagnosticLevel.debug,
      ),
    );
    properties.add(
      ColorProperty(
        'scaffoldBackgroundColor',
        scaffoldBackgroundColor,
        defaultValue: defaultData.scaffoldBackgroundColor,
        level: DiagnosticLevel.debug,
      ),
    );
    properties.add(
      ColorProperty(
        'secondaryHeaderColor',
        secondaryHeaderColor,
        defaultValue: defaultData.secondaryHeaderColor,
        level: DiagnosticLevel.debug,
      ),
    );
    properties.add(
      ColorProperty(
        'shadowColor',
        shadowColor,
        defaultValue: defaultData.shadowColor,
        level: DiagnosticLevel.debug,
      ),
    );
    properties.add(
      ColorProperty(
        'splashColor',
        splashColor,
        defaultValue: defaultData.splashColor,
        level: DiagnosticLevel.debug,
      ),
    );
    properties.add(
      ColorProperty(
        'unselectedWidgetColor',
        unselectedWidgetColor,
        defaultValue: defaultData.unselectedWidgetColor,
        level: DiagnosticLevel.debug,
      ),
    );
    // TYPOGRAPHY & ICONOGRAPHY
    properties.add(
      DiagnosticsProperty<IconThemeData>('iconTheme', iconTheme, level: DiagnosticLevel.debug),
    );
    properties.add(
      DiagnosticsProperty<IconThemeData>(
        'primaryIconTheme',
        primaryIconTheme,
        level: DiagnosticLevel.debug,
      ),
    );
    properties.add(
      DiagnosticsProperty<TextTheme>(
        'primaryTextTheme',
        primaryTextTheme,
        level: DiagnosticLevel.debug,
      ),
    );
    properties.add(
      DiagnosticsProperty<TextTheme>('textTheme', textTheme, level: DiagnosticLevel.debug),
    );
    properties.add(
      DiagnosticsProperty<Typography>(
        'typography',
        typography,
        defaultValue: defaultData.typography,
        level: DiagnosticLevel.debug,
      ),
    );
    // COMPONENT THEMES
    properties.add(
      DiagnosticsProperty<ActionIconThemeData>(
        'actionIconTheme',
        actionIconTheme,
        level: DiagnosticLevel.debug,
      ),
    );
    properties.add(
      DiagnosticsProperty<AppBarTheme>(
        'appBarTheme',
        appBarTheme,
        defaultValue: defaultData.appBarTheme,
        level: DiagnosticLevel.debug,
      ),
    );
    properties.add(
      DiagnosticsProperty<BadgeThemeData>(
        'badgeTheme',
        badgeTheme,
        defaultValue: defaultData.badgeTheme,
        level: DiagnosticLevel.debug,
      ),
    );
    properties.add(
      DiagnosticsProperty<MaterialBannerThemeData>(
        'bannerTheme',
        bannerTheme,
        defaultValue: defaultData.bannerTheme,
        level: DiagnosticLevel.debug,
      ),
    );
    properties.add(
      DiagnosticsProperty<BottomAppBarTheme>(
        'bottomAppBarTheme',
        bottomAppBarTheme,
        defaultValue: defaultData.bottomAppBarTheme,
        level: DiagnosticLevel.debug,
      ),
    );
    properties.add(
      DiagnosticsProperty<BottomNavigationBarThemeData>(
        'bottomNavigationBarTheme',
        bottomNavigationBarTheme,
        defaultValue: defaultData.bottomNavigationBarTheme,
        level: DiagnosticLevel.debug,
      ),
    );
    properties.add(
      DiagnosticsProperty<BottomSheetThemeData>(
        'bottomSheetTheme',
        bottomSheetTheme,
        defaultValue: defaultData.bottomSheetTheme,
        level: DiagnosticLevel.debug,
      ),
    );
    properties.add(
      DiagnosticsProperty<ButtonThemeData>(
        'buttonTheme',
        buttonTheme,
        level: DiagnosticLevel.debug,
      ),
    );
    properties.add(
      DiagnosticsProperty<CardThemeData>('cardTheme', cardTheme, level: DiagnosticLevel.debug),
    );
    properties.add(
      DiagnosticsProperty<CheckboxThemeData>(
        'checkboxTheme',
        checkboxTheme,
        defaultValue: defaultData.checkboxTheme,
        level: DiagnosticLevel.debug,
      ),
    );
    properties.add(
      DiagnosticsProperty<ChipThemeData>('chipTheme', chipTheme, level: DiagnosticLevel.debug),
    );
    properties.add(
      DiagnosticsProperty<DataTableThemeData>(
        'dataTableTheme',
        dataTableTheme,
        defaultValue: defaultData.dataTableTheme,
        level: DiagnosticLevel.debug,
      ),
    );
    properties.add(
      DiagnosticsProperty<DatePickerThemeData>(
        'datePickerTheme',
        datePickerTheme,
        defaultValue: defaultData.datePickerTheme,
        level: DiagnosticLevel.debug,
      ),
    );
    properties.add(
      DiagnosticsProperty<DialogThemeData>(
        'dialogTheme',
        dialogTheme,
        defaultValue: defaultData.dialogTheme,
        level: DiagnosticLevel.debug,
      ),
    );
    properties.add(
      DiagnosticsProperty<DividerThemeData>(
        'dividerTheme',
        dividerTheme,
        defaultValue: defaultData.dividerTheme,
        level: DiagnosticLevel.debug,
      ),
    );
    properties.add(
      DiagnosticsProperty<DrawerThemeData>(
        'drawerTheme',
        drawerTheme,
        defaultValue: defaultData.drawerTheme,
        level: DiagnosticLevel.debug,
      ),
    );
    properties.add(
      DiagnosticsProperty<DropdownMenuThemeData>(
        'dropdownMenuTheme',
        dropdownMenuTheme,
        defaultValue: defaultData.dropdownMenuTheme,
        level: DiagnosticLevel.debug,
      ),
    );
    properties.add(
      DiagnosticsProperty<ElevatedButtonThemeData>(
        'elevatedButtonTheme',
        elevatedButtonTheme,
        defaultValue: defaultData.elevatedButtonTheme,
        level: DiagnosticLevel.debug,
      ),
    );
    properties.add(
      DiagnosticsProperty<ExpansionTileThemeData>(
        'expansionTileTheme',
        expansionTileTheme,
        level: DiagnosticLevel.debug,
      ),
    );
    properties.add(
      DiagnosticsProperty<FilledButtonThemeData>(
        'filledButtonTheme',
        filledButtonTheme,
        defaultValue: defaultData.filledButtonTheme,
        level: DiagnosticLevel.debug,
      ),
    );
    properties.add(
      DiagnosticsProperty<FloatingActionButtonThemeData>(
        'floatingActionButtonTheme',
        floatingActionButtonTheme,
        defaultValue: defaultData.floatingActionButtonTheme,
        level: DiagnosticLevel.debug,
      ),
    );
    properties.add(
      DiagnosticsProperty<IconButtonThemeData>(
        'iconButtonTheme',
        iconButtonTheme,
        defaultValue: defaultData.iconButtonTheme,
        level: DiagnosticLevel.debug,
      ),
    );
    properties.add(
      DiagnosticsProperty<ListTileThemeData>(
        'listTileTheme',
        listTileTheme,
        defaultValue: defaultData.listTileTheme,
        level: DiagnosticLevel.debug,
      ),
    );
    properties.add(
      DiagnosticsProperty<MenuBarThemeData>(
        'menuBarTheme',
        menuBarTheme,
        defaultValue: defaultData.menuBarTheme,
        level: DiagnosticLevel.debug,
      ),
    );
    properties.add(
      DiagnosticsProperty<MenuButtonThemeData>(
        'menuButtonTheme',
        menuButtonTheme,
        defaultValue: defaultData.menuButtonTheme,
        level: DiagnosticLevel.debug,
      ),
    );
    properties.add(
      DiagnosticsProperty<MenuThemeData>(
        'menuTheme',
        menuTheme,
        defaultValue: defaultData.menuTheme,
        level: DiagnosticLevel.debug,
      ),
    );
    properties.add(
      DiagnosticsProperty<NavigationBarThemeData>(
        'navigationBarTheme',
        navigationBarTheme,
        defaultValue: defaultData.navigationBarTheme,
        level: DiagnosticLevel.debug,
      ),
    );
    properties.add(
      DiagnosticsProperty<NavigationDrawerThemeData>(
        'navigationDrawerTheme',
        navigationDrawerTheme,
        defaultValue: defaultData.navigationDrawerTheme,
        level: DiagnosticLevel.debug,
      ),
    );
    properties.add(
      DiagnosticsProperty<NavigationRailThemeData>(
        'navigationRailTheme',
        navigationRailTheme,
        defaultValue: defaultData.navigationRailTheme,
        level: DiagnosticLevel.debug,
      ),
    );
    properties.add(
      DiagnosticsProperty<OutlinedButtonThemeData>(
        'outlinedButtonTheme',
        outlinedButtonTheme,
        defaultValue: defaultData.outlinedButtonTheme,
        level: DiagnosticLevel.debug,
      ),
    );
    properties.add(
      DiagnosticsProperty<PopupMenuThemeData>(
        'popupMenuTheme',
        popupMenuTheme,
        defaultValue: defaultData.popupMenuTheme,
        level: DiagnosticLevel.debug,
      ),
    );
    properties.add(
      DiagnosticsProperty<ProgressIndicatorThemeData>(
        'progressIndicatorTheme',
        progressIndicatorTheme,
        defaultValue: defaultData.progressIndicatorTheme,
        level: DiagnosticLevel.debug,
      ),
    );
    properties.add(
      DiagnosticsProperty<RadioThemeData>(
        'radioTheme',
        radioTheme,
        defaultValue: defaultData.radioTheme,
        level: DiagnosticLevel.debug,
      ),
    );
    properties.add(
      DiagnosticsProperty<SearchBarThemeData>(
        'searchBarTheme',
        searchBarTheme,
        defaultValue: defaultData.searchBarTheme,
        level: DiagnosticLevel.debug,
      ),
    );
    properties.add(
      DiagnosticsProperty<SearchViewThemeData>(
        'searchViewTheme',
        searchViewTheme,
        defaultValue: defaultData.searchViewTheme,
        level: DiagnosticLevel.debug,
      ),
    );
    properties.add(
      DiagnosticsProperty<SegmentedButtonThemeData>(
        'segmentedButtonTheme',
        segmentedButtonTheme,
        defaultValue: defaultData.segmentedButtonTheme,
        level: DiagnosticLevel.debug,
      ),
    );
    properties.add(
      DiagnosticsProperty<SliderThemeData>(
        'sliderTheme',
        sliderTheme,
        level: DiagnosticLevel.debug,
      ),
    );
    properties.add(
      DiagnosticsProperty<SnackBarThemeData>(
        'snackBarTheme',
        snackBarTheme,
        defaultValue: defaultData.snackBarTheme,
        level: DiagnosticLevel.debug,
      ),
    );
    properties.add(
      DiagnosticsProperty<SwitchThemeData>(
        'switchTheme',
        switchTheme,
        defaultValue: defaultData.switchTheme,
        level: DiagnosticLevel.debug,
      ),
    );
    properties.add(
      DiagnosticsProperty<TabBarThemeData>(
        'tabBarTheme',
        tabBarTheme,
        level: DiagnosticLevel.debug,
      ),
    );
    properties.add(
      DiagnosticsProperty<TextButtonThemeData>(
        'textButtonTheme',
        textButtonTheme,
        defaultValue: defaultData.textButtonTheme,
        level: DiagnosticLevel.debug,
      ),
    );
    properties.add(
      DiagnosticsProperty<TextSelectionThemeData>(
        'textSelectionTheme',
        textSelectionTheme,
        defaultValue: defaultData.textSelectionTheme,
        level: DiagnosticLevel.debug,
      ),
    );
    properties.add(
      DiagnosticsProperty<TimePickerThemeData>(
        'timePickerTheme',
        timePickerTheme,
        defaultValue: defaultData.timePickerTheme,
        level: DiagnosticLevel.debug,
      ),
    );
    properties.add(
      DiagnosticsProperty<ToggleButtonsThemeData>(
        'toggleButtonsTheme',
        toggleButtonsTheme,
        level: DiagnosticLevel.debug,
      ),
    );
    properties.add(
      DiagnosticsProperty<TooltipThemeData>(
        'tooltipTheme',
        tooltipTheme,
        level: DiagnosticLevel.debug,
      ),
    );
    // DEPRECATED (newest deprecations at the bottom)
    properties.add(
      DiagnosticsProperty<ButtonBarThemeData>(
        'buttonBarTheme',
        buttonBarTheme,
        defaultValue: defaultData.buttonBarTheme,
        level: DiagnosticLevel.debug,
      ),
    );
    properties.add(
      ColorProperty(
        'dialogBackgroundColor',
        dialogBackgroundColor,
        defaultValue: defaultData.dialogBackgroundColor,
        level: DiagnosticLevel.debug,
      ),
    );
  }
}

/// A [CupertinoThemeData] that defers unspecified theme attributes to an
/// upstream Material [ThemeData].
///
/// This type of [CupertinoThemeData] is used by the Material [Theme] to
/// harmonize the [CupertinoTheme] with the material theme's colors and text
/// styles.
///
/// In the most basic case, [ThemeData]'s `cupertinoOverrideTheme` is null and
/// descendant Cupertino widgets' styling is derived from the Material theme.
///
/// To override individual parts of the Material-derived Cupertino styling,
/// `cupertinoOverrideTheme`'s construction parameters can be used.
///
/// To completely decouple the Cupertino styling from Material theme derivation,
/// another [CupertinoTheme] widget can be inserted as a descendant of the
/// Material [Theme]. On a [MaterialApp], this can be done using the `builder`
/// parameter on the constructor.
///
/// See also:
///
///  * [CupertinoThemeData], whose null constructor parameters default to
///    reasonable iOS styling defaults rather than harmonizing with a Material
///    theme.
///  * [Theme], widget which inserts a [CupertinoTheme] with this
///    [MaterialBasedCupertinoThemeData].
// This class subclasses CupertinoThemeData rather than composes one because it
// _is_ a CupertinoThemeData with partially altered behavior. e.g. its textTheme
// is from the superclass and based on the primaryColor but the primaryColor
// comes from the Material theme unless overridden.
class MaterialBasedCupertinoThemeData extends CupertinoThemeData {
  /// Create a [MaterialBasedCupertinoThemeData] based on a Material [ThemeData]
  /// and its `cupertinoOverrideTheme`.
  MaterialBasedCupertinoThemeData({required ThemeData materialTheme})
    : this._(
        materialTheme,
        (materialTheme.cupertinoOverrideTheme ?? const CupertinoThemeData()).noDefault(),
      );

  MaterialBasedCupertinoThemeData._(this._materialTheme, this._cupertinoOverrideTheme)
    : // Pass all values to the superclass so Material-agnostic properties
      // like barBackgroundColor can still behave like a normal
      // CupertinoThemeData.
      super.raw(
        _cupertinoOverrideTheme.brightness,
        _cupertinoOverrideTheme.primaryColor,
        _cupertinoOverrideTheme.primaryContrastingColor,
        _cupertinoOverrideTheme.textTheme,
        _cupertinoOverrideTheme.barBackgroundColor,
        _cupertinoOverrideTheme.scaffoldBackgroundColor,
        _cupertinoOverrideTheme.applyThemeToAll,
      );

  final ThemeData _materialTheme;
  final NoDefaultCupertinoThemeData _cupertinoOverrideTheme;

  @override
  Brightness get brightness => _cupertinoOverrideTheme.brightness ?? _materialTheme.brightness;

  @override
  Color get primaryColor =>
      _cupertinoOverrideTheme.primaryColor ?? _materialTheme.colorScheme.primary;

  @override
  Color get primaryContrastingColor =>
      _cupertinoOverrideTheme.primaryContrastingColor ?? _materialTheme.colorScheme.onPrimary;

  @override
  Color get scaffoldBackgroundColor =>
      _cupertinoOverrideTheme.scaffoldBackgroundColor ?? _materialTheme.scaffoldBackgroundColor;

  /// Copies the [ThemeData]'s `cupertinoOverrideTheme`.
  ///
  /// Only the specified override attributes of the [ThemeData]'s
  /// `cupertinoOverrideTheme` and the newly specified parameters are in the
  /// returned [CupertinoThemeData]. No derived attributes from iOS defaults or
  /// from cascaded Material theme attributes are copied.
  ///
  /// This [copyWith] cannot change the base Material [ThemeData]. To change the
  /// base Material [ThemeData], create a new Material [Theme] and use
  /// [ThemeData.copyWith] on the Material [ThemeData] instead.
  @override
  MaterialBasedCupertinoThemeData copyWith({
    Brightness? brightness,
    Color? primaryColor,
    Color? primaryContrastingColor,
    CupertinoTextThemeData? textTheme,
    Color? barBackgroundColor,
    Color? scaffoldBackgroundColor,
    bool? applyThemeToAll,
  }) {
    return MaterialBasedCupertinoThemeData._(
      _materialTheme,
      _cupertinoOverrideTheme.copyWith(
        brightness: brightness,
        primaryColor: primaryColor,
        primaryContrastingColor: primaryContrastingColor,
        textTheme: textTheme,
        barBackgroundColor: barBackgroundColor,
        scaffoldBackgroundColor: scaffoldBackgroundColor,
        applyThemeToAll: applyThemeToAll,
      ),
    );
  }

  @override
  CupertinoThemeData resolveFrom(BuildContext context) {
    // Only the cupertino override theme part will be resolved.
    // If the color comes from the material theme it's not resolved.
    return MaterialBasedCupertinoThemeData._(
      _materialTheme,
      _cupertinoOverrideTheme.resolveFrom(context),
    );
  }
}

/// A class for creating a Material theme with a color scheme based off of the
/// colors from a [CupertinoThemeData]. This is intended to be used only in the
/// case when a Material widget is unable to find a Material theme in the tree,
/// but is able to find a Cupertino theme. Most often this will occur when a
/// Material widget is used inside of a [CupertinoApp].
///
/// Besides the colors, this theme will use all the defaults from Material's
/// [ThemeData], so if further customization is needed, it is best to manually
/// add a Material [Theme] above the [CupertinoApp].
class CupertinoBasedMaterialThemeData {
  /// Creates a Material theme with a color scheme based off of the colors from
  /// a [CupertinoThemeData].
  CupertinoBasedMaterialThemeData({required CupertinoThemeData themeData})
    : materialTheme = ThemeData(
        colorScheme: ColorScheme.fromSeed(
          seedColor: themeData.primaryColor,
          brightness: themeData.brightness ?? Brightness.light,
          primary: themeData.primaryColor,
          onPrimary: themeData.primaryContrastingColor,
        ),
      );

  /// The Material theme data with colors based on an existing [CupertinoThemeData].
  final ThemeData materialTheme;
}

@immutable
class _IdentityThemeDataCacheKey {
  const _IdentityThemeDataCacheKey(this.baseTheme, this.localTextGeometry);

  final ThemeData baseTheme;
  final TextTheme localTextGeometry;

  // Using XOR to make the hash function as fast as possible (e.g. Jenkins is
  // noticeably slower).
  @override
  int get hashCode => identityHashCode(baseTheme) ^ identityHashCode(localTextGeometry);

  @override
  bool operator ==(Object other) {
    // We are explicitly ignoring the possibility that the types might not
    // match in the interests of speed.
    return other is _IdentityThemeDataCacheKey &&
        identical(other.baseTheme, baseTheme) &&
        identical(other.localTextGeometry, localTextGeometry);
  }
}

/// Cache of objects of limited size that uses the first in first out eviction
/// strategy (a.k.a least recently inserted).
///
/// The key that was inserted before all other keys is evicted first, i.e. the
/// one inserted least recently.
class _FifoCache<K, V> {
  _FifoCache(this._maximumSize) : assert(_maximumSize > 0);

  /// In Dart the map literal uses a linked hash-map implementation, whose keys
  /// are stored such that [Map.keys] returns them in the order they were
  /// inserted.
  final Map<K, V> _cache = <K, V>{};

  /// Maximum number of entries to store in the cache.
  ///
  /// Once this many entries have been cached, the entry inserted least recently
  /// is evicted when adding a new entry.
  final int _maximumSize;

  /// Returns the previously cached value for the given key, if available;
  /// if not, calls the given callback to obtain it first.
  V putIfAbsent(K key, V Function() loader) {
    assert(key != null);
    final V? result = _cache[key];
    if (result != null) {
      return result;
    }
    if (_cache.length == _maximumSize) {
      _cache.remove(_cache.keys.first);
    }
    return _cache[key] = loader();
  }
}

/// Defines the visual density of user interface components.
///
/// Density, in the context of a UI, is the vertical and horizontal
/// "compactness" of the components in the UI. It is unitless, since it means
/// different things to different UI components.
///
/// The default for visual densities is zero for both vertical and horizontal
/// densities, which corresponds to the default visual density of components in
/// the Material Design specification. It does not affect text sizes, icon
/// sizes, or padding values.
///
/// For example, for buttons, it affects the spacing around the child of the
/// button. For lists, it affects the distance between baselines of entries in
/// the list. For chips, it only affects the vertical size, not the horizontal
/// size.
///
/// Here are some examples of widgets that respond to density changes:
///
///  * [Checkbox]
///  * [Chip]
///  * [ElevatedButton]
///  * [IconButton]
///  * [InputDecorator] (which gives density support to [TextField], etc.)
///  * [ListTile]
///  * [MaterialButton]
///  * [OutlinedButton]
///  * [Radio]
///  * [RawMaterialButton]
///  * [TextButton]
///
/// See also:
///
///  * [ThemeData.visualDensity], where this property is used to specify the base
///    horizontal density of Material components.
///  * [Material design guidance on density](https://material.io/design/layout/applying-density.html).
@immutable
class VisualDensity with Diagnosticable {
  /// A const constructor for [VisualDensity].
  ///
  /// The [horizontal] and [vertical] arguments must be in the interval between
  /// [minimumDensity] and [maximumDensity], inclusive.
  const VisualDensity({this.horizontal = 0.0, this.vertical = 0.0})
    : assert(vertical <= maximumDensity),
      assert(vertical >= minimumDensity),
      assert(horizontal <= maximumDensity),
      assert(horizontal >= minimumDensity);

  /// The minimum allowed density.
  static const double minimumDensity = -4.0;

  /// The maximum allowed density.
  static const double maximumDensity = 4.0;

  /// The default profile for [VisualDensity] in [ThemeData].
  ///
  /// This default value represents a visual density that is less dense than
  /// either [comfortable] or [compact], and corresponds to density values of
  /// zero in both axes.
  static const VisualDensity standard = VisualDensity();

  /// The profile for a "comfortable" interpretation of [VisualDensity].
  ///
  /// Individual components will interpret the density value independently,
  /// making themselves more visually dense than [standard] and less dense than
  /// [compact] to different degrees based on the Material Design specification
  /// of the "comfortable" setting for their particular use case.
  ///
  /// It corresponds to a density value of -1 in both axes.
  static const VisualDensity comfortable = VisualDensity(horizontal: -1.0, vertical: -1.0);

  /// The profile for a "compact" interpretation of [VisualDensity].
  ///
  /// Individual components will interpret the density value independently,
  /// making themselves more visually dense than [standard] and [comfortable] to
  /// different degrees based on the Material Design specification of the
  /// "comfortable" setting for their particular use case.
  ///
  /// It corresponds to a density value of -2 in both axes.
  static const VisualDensity compact = VisualDensity(horizontal: -2.0, vertical: -2.0);

  /// Returns a [VisualDensity] that is adaptive based on the current platform
  /// on which the framework is executing, from [defaultTargetPlatform].
  ///
  /// When [defaultTargetPlatform] is a desktop platform, this returns
  /// [compact], and for other platforms, it returns a default-constructed
  /// [VisualDensity].
  ///
  /// See also:
  ///
  /// * [defaultDensityForPlatform] which returns a [VisualDensity] that is
  ///   adaptive based on the platform given to it.
  /// * [defaultTargetPlatform] which returns the platform on which the
  ///   framework is currently executing.
  static VisualDensity get adaptivePlatformDensity =>
      defaultDensityForPlatform(defaultTargetPlatform);

  /// Returns a [VisualDensity] that is adaptive based on the given [platform].
  ///
  /// For desktop platforms, this returns [compact], and for other platforms, it
  /// returns a default-constructed [VisualDensity].
  ///
  /// See also:
  ///
  /// * [adaptivePlatformDensity] which returns a [VisualDensity] that is
  ///   adaptive based on [defaultTargetPlatform].
  static VisualDensity defaultDensityForPlatform(TargetPlatform platform) {
    return switch (platform) {
      TargetPlatform.android || TargetPlatform.iOS || TargetPlatform.fuchsia => standard,
      TargetPlatform.linux || TargetPlatform.macOS || TargetPlatform.windows => compact,
    };
  }

  /// Copy the current [VisualDensity] with the given values replacing the
  /// current values.
  VisualDensity copyWith({double? horizontal, double? vertical}) {
    return VisualDensity(
      horizontal: horizontal ?? this.horizontal,
      vertical: vertical ?? this.vertical,
    );
  }

  /// The horizontal visual density of UI components.
  ///
  /// This property affects only the horizontal spacing between and within
  /// components, to allow for different UI visual densities. It does not affect
  /// text sizes, icon sizes, or padding values. The default value is 0.0,
  /// corresponding to the metrics specified in the Material Design
  /// specification. The value can range from [minimumDensity] to
  /// [maximumDensity], inclusive.
  ///
  /// See also:
  ///
  ///  * [ThemeData.visualDensity], where this property is used to specify the base
  ///    horizontal density of Material components.
  ///  * [Material design guidance on density](https://material.io/design/layout/applying-density.html).
  final double horizontal;

  /// The vertical visual density of UI components.
  ///
  /// This property affects only the vertical spacing between and within
  /// components, to allow for different UI visual densities. It does not affect
  /// text sizes, icon sizes, or padding values. The default value is 0.0,
  /// corresponding to the metrics specified in the Material Design
  /// specification. The value can range from [minimumDensity] to
  /// [maximumDensity], inclusive.
  ///
  /// See also:
  ///
  ///  * [ThemeData.visualDensity], where this property is used to specify the base
  ///    vertical density of Material components.
  ///  * [Material design guidance on density](https://material.io/design/layout/applying-density.html).
  final double vertical;

  /// The base adjustment in logical pixels of the visual density of UI components.
  ///
  /// The input density values are multiplied by a constant to arrive at a base
  /// size adjustment that fits Material Design guidelines.
  ///
  /// Individual components may adjust this value based upon their own
  /// individual interpretation of density.
  Offset get baseSizeAdjustment {
    // The number of logical pixels represented by an increase or decrease in
    // density by one. The Material Design guidelines say to increment/decrement
    // sizes in terms of four pixel increments.
    const double interval = 4.0;

    return Offset(horizontal, vertical) * interval;
  }

  /// Linearly interpolate between two densities.
  static VisualDensity lerp(VisualDensity a, VisualDensity b, double t) {
    if (identical(a, b)) {
      return a;
    }
    return VisualDensity(
      horizontal: lerpDouble(a.horizontal, b.horizontal, t)!,
      vertical: lerpDouble(a.vertical, b.vertical, t)!,
    );
  }

  /// Return a copy of [constraints] whose minimum width and height have been
  /// updated with the [baseSizeAdjustment].
  ///
  /// The resulting minWidth and minHeight values are clamped to not exceed the
  /// maxWidth and maxHeight values, respectively.
  BoxConstraints effectiveConstraints(BoxConstraints constraints) {
    assert(constraints.debugAssertIsValid());
    return constraints.copyWith(
      minWidth: clampDouble(
        constraints.minWidth + baseSizeAdjustment.dx,
        0.0,
        constraints.maxWidth,
      ),
      minHeight: clampDouble(
        constraints.minHeight + baseSizeAdjustment.dy,
        0.0,
        constraints.maxHeight,
      ),
    );
  }

  @override
  bool operator ==(Object other) {
    if (other.runtimeType != runtimeType) {
      return false;
    }
    return other is VisualDensity && other.horizontal == horizontal && other.vertical == vertical;
  }

  @override
  int get hashCode => Object.hash(horizontal, vertical);

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties.add(DoubleProperty('horizontal', horizontal, defaultValue: 0.0));
    properties.add(DoubleProperty('vertical', vertical, defaultValue: 0.0));
  }

  @override
  String toStringShort() {
    return '${super.toStringShort()}(h: ${debugFormatDouble(horizontal)}, v: ${debugFormatDouble(vertical)})';
  }
}

// BEGIN GENERATED TOKEN PROPERTIES - ColorScheme

// Do not edit by hand. The code between the "BEGIN GENERATED" and
// "END GENERATED" comments are generated from data in the Material
// Design token database by the script:
//   dev/tools/gen_defaults/bin/gen_defaults.dart.

// dart format off
const ColorScheme _colorSchemeLightM3 = ColorScheme(
  brightness: Brightness.light,
  primary: Color(0xFF6750A4),
  onPrimary: Color(0xFFFFFFFF),
  primaryContainer: Color(0xFFEADDFF),
  onPrimaryContainer: Color(0xFF4F378B),
  primaryFixed: Color(0xFFEADDFF),
  primaryFixedDim: Color(0xFFD0BCFF),
  onPrimaryFixed: Color(0xFF21005D),
  onPrimaryFixedVariant: Color(0xFF4F378B),
  secondary: Color(0xFF625B71),
  onSecondary: Color(0xFFFFFFFF),
  secondaryContainer: Color(0xFFE8DEF8),
  onSecondaryContainer: Color(0xFF4A4458),
  secondaryFixed: Color(0xFFE8DEF8),
  secondaryFixedDim: Color(0xFFCCC2DC),
  onSecondaryFixed: Color(0xFF1D192B),
  onSecondaryFixedVariant: Color(0xFF4A4458),
  tertiary: Color(0xFF7D5260),
  onTertiary: Color(0xFFFFFFFF),
  tertiaryContainer: Color(0xFFFFD8E4),
  onTertiaryContainer: Color(0xFF633B48),
  tertiaryFixed: Color(0xFFFFD8E4),
  tertiaryFixedDim: Color(0xFFEFB8C8),
  onTertiaryFixed: Color(0xFF31111D),
  onTertiaryFixedVariant: Color(0xFF633B48),
  error: Color(0xFFB3261E),
  onError: Color(0xFFFFFFFF),
  errorContainer: Color(0xFFF9DEDC),
  onErrorContainer: Color(0xFF8C1D18),
  background: Color(0xFFFEF7FF),
  onBackground: Color(0xFF1D1B20),
  surface: Color(0xFFFEF7FF),
  surfaceBright: Color(0xFFFEF7FF),
  surfaceContainerLowest: Color(0xFFFFFFFF),
  surfaceContainerLow: Color(0xFFF7F2FA),
  surfaceContainer: Color(0xFFF3EDF7),
  surfaceContainerHigh: Color(0xFFECE6F0),
  surfaceContainerHighest: Color(0xFFE6E0E9),
  surfaceDim: Color(0xFFDED8E1),
  onSurface: Color(0xFF1D1B20),
  surfaceVariant: Color(0xFFE7E0EC),
  onSurfaceVariant: Color(0xFF49454F),
  outline: Color(0xFF79747E),
  outlineVariant: Color(0xFFCAC4D0),
  shadow: Color(0xFF000000),
  scrim: Color(0xFF000000),
  inverseSurface: Color(0xFF322F35),
  onInverseSurface: Color(0xFFF5EFF7),
  inversePrimary: Color(0xFFD0BCFF),
  // The surfaceTint color is set to the same color as the primary.
  surfaceTint: Color(0xFF6750A4),
);

const ColorScheme _colorSchemeDarkM3 = ColorScheme(
  brightness: Brightness.dark,
  primary: Color(0xFFD0BCFF),
  onPrimary: Color(0xFF381E72),
  primaryContainer: Color(0xFF4F378B),
  onPrimaryContainer: Color(0xFFEADDFF),
  primaryFixed: Color(0xFFEADDFF),
  primaryFixedDim: Color(0xFFD0BCFF),
  onPrimaryFixed: Color(0xFF21005D),
  onPrimaryFixedVariant: Color(0xFF4F378B),
  secondary: Color(0xFFCCC2DC),
  onSecondary: Color(0xFF332D41),
  secondaryContainer: Color(0xFF4A4458),
  onSecondaryContainer: Color(0xFFE8DEF8),
  secondaryFixed: Color(0xFFE8DEF8),
  secondaryFixedDim: Color(0xFFCCC2DC),
  onSecondaryFixed: Color(0xFF1D192B),
  onSecondaryFixedVariant: Color(0xFF4A4458),
  tertiary: Color(0xFFEFB8C8),
  onTertiary: Color(0xFF492532),
  tertiaryContainer: Color(0xFF633B48),
  onTertiaryContainer: Color(0xFFFFD8E4),
  tertiaryFixed: Color(0xFFFFD8E4),
  tertiaryFixedDim: Color(0xFFEFB8C8),
  onTertiaryFixed: Color(0xFF31111D),
  onTertiaryFixedVariant: Color(0xFF633B48),
  error: Color(0xFFF2B8B5),
  onError: Color(0xFF601410),
  errorContainer: Color(0xFF8C1D18),
  onErrorContainer: Color(0xFFF9DEDC),
  background: Color(0xFF141218),
  onBackground: Color(0xFFE6E0E9),
  surface: Color(0xFF141218),
  surfaceBright: Color(0xFF3B383E),
  surfaceContainerLowest: Color(0xFF0F0D13),
  surfaceContainerLow: Color(0xFF1D1B20),
  surfaceContainer: Color(0xFF211F26),
  surfaceContainerHigh: Color(0xFF2B2930),
  surfaceContainerHighest: Color(0xFF36343B),
  surfaceDim: Color(0xFF141218),
  onSurface: Color(0xFFE6E0E9),
  surfaceVariant: Color(0xFF49454F),
  onSurfaceVariant: Color(0xFFCAC4D0),
  outline: Color(0xFF938F99),
  outlineVariant: Color(0xFF49454F),
  shadow: Color(0xFF000000),
  scrim: Color(0xFF000000),
  inverseSurface: Color(0xFFE6E0E9),
  onInverseSurface: Color(0xFF322F35),
  inversePrimary: Color(0xFF6750A4),
  // The surfaceTint color is set to the same color as the primary.
  surfaceTint: Color(0xFFD0BCFF),
);
// dart format on

// END GENERATED TOKEN PROPERTIES - ColorScheme


--- File: packages/flutter/lib/src/material/theme.dart ---
// Copyright 2014 The Flutter Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

/// @docImport 'app.dart';
/// @docImport 'color_scheme.dart';
/// @docImport 'text_theme.dart';
library;

import 'package:flutter/cupertino.dart';
import 'package:flutter/foundation.dart';

import 'material_localizations.dart';
import 'theme_data.dart';
import 'typography.dart';

export 'theme_data.dart' show Brightness, ThemeData;

/// The duration over which theme changes animate by default.
const Duration kThemeAnimationDuration = Duration(milliseconds: 200);

/// Applies a theme to descendant widgets.
///
/// A theme describes the colors and typographic choices of an application.
///
/// {@youtube 560 315 https://www.youtube.com/watch?v=oTvQDJOBXmM}
///
/// Descendant widgets obtain the current theme's [ThemeData] object using
/// [Theme.of]. When a widget uses [Theme.of], it is automatically rebuilt if
/// the theme later changes, so that the changes can be applied.
///
/// The [Theme] widget implies an [IconTheme] widget, set to the value of the
/// [ThemeData.iconTheme] of the [data] for the [Theme].
///
/// See also:
///
///  * [ThemeData], which describes the actual configuration of a theme.
///  * [AnimatedTheme], which animates the [ThemeData] when it changes rather
///    than changing the theme all at once.
///  * [MaterialApp], which includes an [AnimatedTheme] widget configured via
///    the [MaterialApp.theme] argument.
class Theme extends StatelessWidget {
  /// Applies the given theme [data] to [child].
  const Theme({super.key, required this.data, required this.child});

  /// Specifies the color and typography values for descendant widgets.
  final ThemeData data;

  /// The widget below this widget in the tree.
  ///
  /// {@macro flutter.widgets.ProxyWidget.child}
  final Widget child;

  static final ThemeData _kFallbackTheme = ThemeData.fallback();

  /// The data from the closest [Theme] instance that encloses the given
  /// context.
  ///
  /// If the given context is enclosed in a [Localizations] widget providing
  /// [MaterialLocalizations], the returned data is localized according to the
  /// nearest available [MaterialLocalizations].
  ///
  /// Defaults to [ThemeData.fallback] if there is no [Theme] in the given
  /// build context.
  ///
  /// Typical usage is as follows:
  ///
  /// ```dart
  /// @override
  /// Widget build(BuildContext context) {
  ///   return Text(
  ///     'Example',
  ///     style: Theme.of(context).textTheme.titleLarge,
  ///   );
  /// }
  /// ```
  ///
  /// When the [Theme] is actually created in the same `build` function
  /// (possibly indirectly, e.g. as part of a [MaterialApp]), the `context`
  /// argument to the `build` function can't be used to find the [Theme] (since
  /// it's "above" the widget being returned). In such cases, the following
  /// technique with a [Builder] can be used to provide a new scope with a
  /// [BuildContext] that is "under" the [Theme]:
  ///
  /// ```dart
  /// @override
  /// Widget build(BuildContext context) {
  ///   return MaterialApp(
  ///     theme: ThemeData.light(),
  ///     home: Builder(
  ///       // Create an inner BuildContext so that we can refer to
  ///       // the Theme with Theme.of().
  ///       builder: (BuildContext context) {
  ///         return Center(
  ///           child: Text(
  ///             'Example',
  ///             style: Theme.of(context).textTheme.titleLarge,
  ///           ),
  ///         );
  ///       },
  ///     ),
  ///   );
  /// }
  /// ```
  ///
  /// See also:
  ///
  /// * [ColorScheme.of], a convenience method that returns [ThemeData.colorScheme]
  ///   from the closest [Theme] ancestor. (equivalent to `Theme.of(context).colorScheme`).
  /// * [TextTheme.of], a convenience method that returns [ThemeData.textTheme]
  ///   from the closest [Theme] ancestor. (equivalent to `Theme.of(context).textTheme`).
  /// * [IconTheme.of], that returns [ThemeData.iconTheme] from the closest [Theme] or
  ///   [IconThemeData.fallback] if there is no [IconTheme] ancestor.
  static ThemeData of(BuildContext context) {
    final _InheritedTheme? inheritedTheme =
        context.dependOnInheritedWidgetOfExactType<_InheritedTheme>();
    final MaterialLocalizations? localizations = Localizations.of<MaterialLocalizations>(
      context,
      MaterialLocalizations,
    );
    final ScriptCategory category = localizations?.scriptCategory ?? ScriptCategory.englishLike;
    final InheritedCupertinoTheme? inheritedCupertinoTheme =
        context.dependOnInheritedWidgetOfExactType<InheritedCupertinoTheme>();
    final ThemeData theme =
        inheritedTheme?.theme.data ??
        (inheritedCupertinoTheme != null
            ? CupertinoBasedMaterialThemeData(
              themeData: inheritedCupertinoTheme.theme.data,
            ).materialTheme
            : _kFallbackTheme);
    return ThemeData.localize(theme, theme.typography.geometryThemeFor(category));
  }

  // The inherited themes in widgets library can not infer their values from
  // Theme in material library. Wraps the child with these inherited themes to
  // overrides their values directly.
  Widget _wrapsWidgetThemes(BuildContext context, Widget child) {
    final DefaultSelectionStyle selectionStyle = DefaultSelectionStyle.of(context);
    return IconTheme(
      data: data.iconTheme,
      child: DefaultSelectionStyle(
        selectionColor: data.textSelectionTheme.selectionColor ?? selectionStyle.selectionColor,
        cursorColor: data.textSelectionTheme.cursorColor ?? selectionStyle.cursorColor,
        child: child,
      ),
    );
  }

  CupertinoThemeData _inheritedCupertinoThemeData(BuildContext context) {
    final InheritedCupertinoTheme? inheritedTheme =
        context.dependOnInheritedWidgetOfExactType<InheritedCupertinoTheme>();
    return (inheritedTheme?.theme.data ?? MaterialBasedCupertinoThemeData(materialTheme: data))
        .resolveFrom(context);
  }

  @override
  Widget build(BuildContext context) {
    return _InheritedTheme(
      theme: this,
      child: CupertinoTheme(
        // If a CupertinoThemeData doesn't exist, we're using a
        // MaterialBasedCupertinoThemeData here instead of a CupertinoThemeData
        // because it defers some properties to the Material ThemeData.
        data: _inheritedCupertinoThemeData(context),
        child: _wrapsWidgetThemes(context, child),
      ),
    );
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties.add(DiagnosticsProperty<ThemeData>('data', data, showName: false));
  }
}

class _InheritedTheme extends InheritedTheme {
  const _InheritedTheme({required this.theme, required super.child});

  final Theme theme;

  @override
  Widget wrap(BuildContext context, Widget child) {
    return Theme(data: theme.data, child: child);
  }

  @override
  bool updateShouldNotify(_InheritedTheme old) => theme.data != old.theme.data;
}

/// An interpolation between two [ThemeData]s.
///
/// This class specializes the interpolation of [Tween<ThemeData>] to call the
/// [ThemeData.lerp] method.
///
/// See [Tween] for a discussion on how to use interpolation objects.
class ThemeDataTween extends Tween<ThemeData> {
  /// Creates a [ThemeData] tween.
  ///
  /// The [begin] and [end] properties must be non-null before the tween is
  /// first used, but the arguments can be null if the values are going to be
  /// filled in later.
  ThemeDataTween({super.begin, super.end});

  @override
  ThemeData lerp(double t) => ThemeData.lerp(begin!, end!, t);
}

/// Animated version of [Theme] which automatically transitions the colors,
/// etc, over a given duration whenever the given theme changes.
///
/// Here's an illustration of what using this widget looks like, using a [curve]
/// of [Curves.elasticInOut].
/// {@animation 250 266 https://flutter.github.io/assets-for-api-docs/assets/widgets/animated_theme.mp4}
///
/// See also:
///
///  * [Theme], which [AnimatedTheme] uses to actually apply the interpolated
///    theme.
///  * [ThemeData], which describes the actual configuration of a theme.
///  * [MaterialApp], which includes an [AnimatedTheme] widget configured via
///    the [MaterialApp.theme] argument.
class AnimatedTheme extends ImplicitlyAnimatedWidget {
  /// Creates an animated theme.
  ///
  /// By default, the theme transition uses a linear curve.
  const AnimatedTheme({
    super.key,
    required this.data,
    super.curve,
    super.duration = kThemeAnimationDuration,
    super.onEnd,
    required this.child,
  });

  /// Specifies the color and typography values for descendant widgets.
  final ThemeData data;

  /// The widget below this widget in the tree.
  ///
  /// {@macro flutter.widgets.ProxyWidget.child}
  final Widget child;

  @override
  AnimatedWidgetBaseState<AnimatedTheme> createState() => _AnimatedThemeState();
}

class _AnimatedThemeState extends AnimatedWidgetBaseState<AnimatedTheme> {
  ThemeDataTween? _data;

  @override
  void forEachTween(TweenVisitor<dynamic> visitor) {
    _data =
        visitor(_data, widget.data, (dynamic value) => ThemeDataTween(begin: value as ThemeData))!
            as ThemeDataTween;
  }

  @override
  Widget build(BuildContext context) {
    return Theme(data: _data!.evaluate(animation), child: widget.child);
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder description) {
    super.debugFillProperties(description);
    description.add(
      DiagnosticsProperty<ThemeDataTween>('data', _data, showName: false, defaultValue: null),
    );
  }
}


Instructions for the chapter (Generate content in English unless specified otherwise):
- Start with a clear heading (e.g., `# Chapter 4: ThemeExtension
`). Use the provided concept name.

- If this is not the first chapter, begin with a brief transition from the previous chapter, referencing it with a proper Markdown link using its name.

- Begin with a high-level motivation explaining what problem this abstraction solves. Start with a central use case as a concrete example. The whole chapter should guide the reader to understand how to solve this use case. Make it very minimal and friendly to beginners.

- If the abstraction is complex, break it down into key concepts. Explain each concept one-by-one in a very beginner-friendly way.

- Explain how to use this abstraction to solve the use case. Give example inputs and outputs for code snippets (if the output isn't values, describe at a high level what will happen).

- Each code block should be BELOW 10 lines! If longer code blocks are needed, break them down into smaller pieces and walk through them one-by-one. Aggresively simplify the code to make it minimal. Use comments to skip non-important implementation details. Each code block should have a beginner friendly explanation right after it.

- Describe the internal implementation to help understand what's under the hood. First provide a non-code or code-light walkthrough on what happens step-by-step when the abstraction is called. It's recommended to use a simple sequenceDiagram with a dummy example - keep it minimal with at most 5 participants to ensure clarity. If participant name has space, use: `participant QP as Query Processing`. .

- Then dive deeper into code for the internal implementation with references to files. Provide example code blocks, but make them similarly simple and beginner-friendly. Explain.

- IMPORTANT: When you need to refer to other core abstractions covered in other chapters, ALWAYS use proper Markdown links like this: [Chapter Title](filename.md). Use the Complete Tutorial Structure above to find the correct filename and the chapter title. Translate the surrounding text.

- Use mermaid diagrams to illustrate complex concepts (```mermaid``` format). .

- Heavily use analogies and examples throughout to help beginners understand.

- End the chapter with a brief conclusion that summarizes what was learned and provides a transition to the next chapter. If there is a next chapter, use a proper Markdown link: [Next Chapter Title](next_chapter_filename).

- Ensure the tone is welcoming and easy for a newcomer to understand.

- Output *only* the Markdown content for this chapter.

Now, directly provide a super beginner-friendly Markdown output (DON'T need ```markdown``` tags):

2025-05-28 18:22:30,454 - INFO - RESPONSE: # Chapter 4: ThemeExtension

Welcome back! In our previous chapters, we learned that the [Theme](01_theme_.md) widget applies a design plan, [ThemeData](02_themedata_.md) is that detailed plan holding all the standard styling information (like fonts and component styles), and [ColorScheme](03_colorscheme_.md) helps us manage colors for different UI roles within that plan.

But what if your app needs some custom styling information that isn't covered by the standard `ThemeData` properties or `ColorScheme` roles? Imagine you have a specific type of card in your app that always needs a unique gradient background and a particular size setting, and you want to define this rule in your theme so all these special cards use the same style consistently. The standard `ThemeData` doesn't have a specific property for "my special card's gradient."

That's where `ThemeExtension` comes in!

### What Problem Does `ThemeExtension` Solve?

The standard `ThemeData` comes with a lot of properties to cover common styling needs for Material Design. However, every app is unique, and you might have custom visual elements or specific styling rules that don't fit neatly into the predefined categories like `primaryColor`, `textTheme.bodyMedium`, or `cardTheme`.

If you couldn't add custom properties to your theme, you'd have to define these unique styles manually every time you used that special element throughout your app. This leads to code duplication, makes it difficult to maintain consistency, and makes changing that special style a tedious process (just like changing the brand color without using `ThemeData`!).

`ThemeExtension` solves this by allowing you to add **your own custom data** to the existing `ThemeData` object. It's like adding a dedicated section to your house blueprint for unique features like a custom-designed mailbox color or a specific pattern for floor tiles in one area, features that aren't in the standard building code or typical house plans.

### What is `ThemeExtension`?

`ThemeExtension` is an **abstract class** that you **subclass** (create your own version of) to define your custom theme properties. You create your own class that `extends ThemeExtension` and put whatever properties you need inside it – like `Color`s, `TextStyle`s, `double`s, or even other simple data types.

Your custom `ThemeExtension` class must implement two methods:

1.  `copyWith`: This method is used to create a copy of your extension, optionally changing some properties. This is similar to how `ThemeData` has a `copyWith` method.
2.  `lerp`: This method is crucial for smoothly animating between two different versions of your custom theme data. It stands for "linear interpolation," a common technique in animation. It takes another `ThemeExtension` of the same type and a `double t` (which goes from 0 to 1 during the animation) and calculates an intermediate state of your custom properties.

Let's create a simple custom theme extension for that "special card":

```dart
import 'package:flutter/material.dart';

// 1. Create your own class that extends ThemeExtension
class SpecialCardTheme extends ThemeExtension<SpecialCardTheme> {
  // 2. Define your custom properties
  const SpecialCardTheme({
    required this.gradientColors,
    required this.borderCurve,
  });

  final List<Color> gradientColors;
  final double borderCurve; // Just a simplified example for radius

  // 3. Implement copyWith - copy all properties
  @override
  SpecialCardTheme copyWith({
    List<Color>? gradientColors,
    double? borderCurve,
  }) {
    return SpecialCardTheme(
      gradientColors: gradientColors ?? this.gradientColors,
      borderCurve: borderCurve ?? this.borderCurve,
    );
  }

  // 4. Implement lerp - interpolate between values
  @override
  SpecialCardTheme lerp(ThemeExtension<SpecialCardTheme>? other, double t) {
    if (other is! SpecialCardTheme) {
      return this; // Return this if 'other' is not the same type or is null
    }
    return SpecialCardTheme(
      // Here we smoothly transition the gradient colors using Color.lerp
      // Interpolating a list of colors requires interpolating each color
      gradientColors: List.generate(
        gradientColors.length,
        (index) => Color.lerp(
              gradientColors[index],
              other.gradientColors[index],
              t,
            ) ?? // Provide a fallback if lerp is null (unlikely with non-null colors)
            gradientColors[index],
      ),
      // Here we smoothly transition the double value
      borderCurve: t < 0.5 ? borderCurve : other.borderCurve, // Simplified lerp for double
      // For a real double interpolation, use lerpDouble from dart:ui
      // borderCurve: lerpDouble(borderCurve, other.borderCurve, t)!,
    );
  }

  // Optional: Add operator == and hashCode for equality checks
  // This is good practice but not strictly required by ThemeExtension interface
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is SpecialCardTheme &&
          runtimeType == other.runtimeType &&
          listEquals(gradientColors, other.gradientColors) && // Need listEquals for list
          borderCurve == other.borderCurve;

  @override
  int get hashCode => hashValues(hashList(gradientColors), borderCurve); // Need hashList for list
}
```

This is our custom `ThemeExtension` class, `SpecialCardTheme`. It defines a list of colors for a gradient and a double for a border curvature. We've added the necessary `copyWith` and `lerp` methods.

### How to Use `ThemeExtension`

Once you've defined your custom `ThemeExtension` class, you need to add it to your `ThemeData`. You do this using the `extensions` property when creating or copying a `ThemeData`. The `extensions` property takes an `Iterable` (like a `List`) of your custom theme extension objects.

Here's how you'd add `SpecialCardTheme` to your app's `ThemeData`:

```dart
import 'package:flutter/material.dart';
// Assuming your SpecialCardTheme class is in 'special_card_theme.dart'
import 'special_card_theme.dart';

void main() {
  runApp(const MyApp());
}

class MyApp extends StatelessWidget {
  const MyApp({super.key});

  @override
  Widget build(BuildContext context) {
    // Define your custom theme extension instance
    const SpecialCardTheme specialTheme = SpecialCardTheme(
      gradientColors: [Colors.orange, Colors.red],
      borderCurve: 16.0,
    );

    return MaterialApp(
      title: 'Theme Extension App',
      theme: ThemeData(
        primarySwatch: Colors.blue,
        useMaterial3: true,
        // Add your custom extension to the extensions list
        extensions: <ThemeExtension<dynamic>>[
          specialTheme,
        ],
      ),
      home: const HomeScreen(),
    );
  }
}

class HomeScreen extends StatelessWidget {
  const HomeScreen({super.key});

  @override
  Widget build(BuildContext context) {
    // Access the custom theme extension using Theme.of(context).extension<YourClassName>()
    final specialCardTheme = Theme.of(context).extension<SpecialCardTheme>()!;

    return Scaffold(
      appBar: AppBar(
        title: const Text('Home with Custom Theme'),
      ),
      body: Center(
        child: Column(
          mainAxisAlignment: MainAxisAlignment.center,
          children: [
            Text(
              'Standard Text based on ThemeData',
              style: Theme.of(context).textTheme.bodyMedium,
            ),
            const SizedBox(height: 20),
            // Use the properties from your custom extension
            Container(
              width: 200,
              height: 100,
              decoration: BoxDecoration(
                // Accessing custom gradient colors
                gradient: LinearGradient(colors: specialCardTheme.gradientColors),
                borderRadius: BorderRadius.circular(specialCardTheme.borderCurve), // Accessing custom curve
              ),
              child: const Center(
                child: Text(
                  'This is the Special Card!',
                  style: TextStyle(color: Colors.white),
                ),
              ),
            ),
          ],
        ),
      ),
    );
  }
}
```

In this example:

1.  We create an instance of our `SpecialCardTheme` with specific values.
2.  We add this instance to the `extensions` list in our `ThemeData`.
3.  In a widget (`HomeScreen`), we access the theme using `Theme.of(context)`.
4.  We retrieve our specific custom extension using `.extension<SpecialCardTheme>()`. Note the `<SpecialCardTheme>` part – this tells Flutter *which* type of extension to look for. The `!` at the end asserts that we expect it to exist.
5.  We then use the properties (`gradientColors` and `borderCurve`) from the retrieved `specialCardTheme` object to style our `Container` (representing the special card).

Now, if you wanted to change the gradient or border curvature of *all* your "special cards," you just need to update the `SpecialCardTheme` instance provided in your `MaterialApp`'s `ThemeData`.

### Under the Hood: Adding and Retrieving Extensions

When you add your custom `ThemeExtension`s to the `extensions` list in `ThemeData`, Flutter stores them internally in a `Map`. The key of this map is the **type** of your `ThemeExtension` (like `SpecialCardTheme`), and the value is the instance of your extension.

When you call `Theme.of(context).extension<YourCustomExtension>()`, Flutter does the following:

1.  It finds the nearest `ThemeData` in the widget tree (as we saw in Chapter 1).
2.  It looks inside that `ThemeData`'s internal `extensions` map.
3.  It uses the `Type` of your custom extension (`YourCustomExtension`) as the key to find the corresponding instance in the map.
4.  It returns that instance (or `null` if no extension of that type is found).

Here's a super simplified sequence diagram showing the process of retrieving a `ThemeExtension`:

```mermaid
sequenceDiagram
    participant Widget as Your Custom Widget
    participant BuildContext as BuildContext
    participant ThemeWidget as Theme Widget
    participant ThemeData as ThemeData
    participant ExtMap as Internal Extensions Map
    participant CustomExt as Your Custom Extension Object

    Widget->>BuildContext: "Hey, I need the theme extension of type MyCustomExt!"
    BuildContext->>ThemeWidget: "Nearest Theme, what's your data?"
    ThemeWidget->>ThemeData: Get ThemeData object
    ThemeData->>ExtMap: "Is there an extension with key 'MyCustomExt'?"
    ExtMap-->>ThemeData: Yes, here's the MyCustomExt object.
    ThemeData-->>Widget: Return the MyCustomExt object.
    Widget->>Widget: Use the custom properties from the object.
```

This shows how your custom extension objects are stored within the `ThemeData` and retrieved using their type as the identifier.

Looking at the `ThemeData` code snippet provided in the context, you can see the `extensions` property is a `Map<Object, ThemeExtension<dynamic>>`:

```dart
/// Arbitrary additions to this theme.
///
/// To define extensions, pass an [Iterable] containing one or more [ThemeExtension]
/// subclasses to [ThemeData.new] or [copyWith].
///
/// To obtain an extension, use [extension].
/// ...
final Map<Object, ThemeExtension<dynamic>> extensions;

/// Used to obtain a particular [ThemeExtension] from [extensions].
///
/// Obtain with `Theme.of(context).extension<MyThemeExtension>()`.
/// ...
T? extension<T>() => extensions[T] as T?; // This is where it looks up by type T
```

The `extension<T>()` method directly accesses the `extensions` map using `T` as the key. The `<dynamic>` in the map definition just means it can hold any type of `ThemeExtension`.

The `lerp` method in `ThemeData` also handles interpolating themes that have extensions. It calls the `lerp` method **you defined** on each corresponding extension in the two themes being interpolated:

```dart
// From packages/flutter/lib/src/material/theme_data.dart
  static Map<Object, ThemeExtension<dynamic>> _lerpThemeExtensions(
    ThemeData a,
    ThemeData b,
    double t,
  ) {
    // Lerp [a].
    final Map<Object, ThemeExtension<dynamic>> newExtensions = a.extensions.map((
      Object id,
      ThemeExtension<dynamic> extensionA,
    ) {
      final ThemeExtension<dynamic>? extensionB = b.extensions[id];
      // Calls the lerp method you implemented in your custom class!
      return MapEntry<Object, ThemeExtension<dynamic>>(id, extensionA.lerp(extensionB, t));
    });
    // Add [b]-only extensions.
    newExtensions.addEntries(
      b.extensions.entries.where(
        (MapEntry<Object, ThemeExtension<dynamic>> entry) => !a.extensions.containsKey(entry.key),
      ),
    );

    return newExtensions;
  }
```

This snippet shows that `ThemeData.lerp` iterates through the extensions in the first theme (`a`), finds the matching extension in the second theme (`b`), and calls **your** `lerp` method on that pair (`extensionA.lerp(extensionB, t)`). This is why correctly implementing `lerp` in your `ThemeExtension` subclass is essential for enabling smooth theme transitions.

### Conclusion

`ThemeExtension` is a powerful mechanism that allows you to extend `ThemeData` with your own custom properties, going beyond the standard Material Design configurations. By defining your properties in a custom `ThemeExtension` subclass and adding it to your `ThemeData`, you create a central source of truth for unique styling rules in your app, promoting consistency, maintainability, and enabling smooth animations between different versions of your custom theme data.

With your understanding of `Theme`, `ThemeData`, `ColorScheme`, and now `ThemeExtension`, you're well on your way to creating beautifully consistent and well-structured Flutter UIs! Next, we'll briefly touch upon [VisualDensity](05_visualdensity_.md), which controls the compactness of interactive elements.

[VisualDensity](05_visualdensity_.md)
2025-05-28 18:22:30,472 - INFO - PROMPT: 
Write a very beginner-friendly tutorial chapter (in Markdown format) for the project `flutter` about the concept: "VisualDensity
". This is Chapter 5.

Concept Details:
- Name: VisualDensity

- Description:
`VisualDensity` controls the "compactness" of some UI elements. It subtly adjusts spacing to make things feel more dense or spread out, without changing text or icon sizes directly. This is like having a setting in your blueprint for how closely furniture should be placed in certain rooms to achieve a specific feel.


Complete Tutorial Structure:
1. [Theme
](01_theme_.md)
2. [ThemeData
](02_themedata_.md)
3. [ColorScheme
](03_colorscheme_.md)
4. [ThemeExtension
](04_themeextension_.md)
5. [VisualDensity
](05_visualdensity_.md)
6. [MaterialTapTargetSize
](06_materialtaptargetsize_.md)
7. [DynamicSchemeVariant
](07_dynamicschemevariant_.md)

Context from previous chapters:
# Chapter 1: Theme

Welcome to the very first chapter on how to make your Flutter app look great! In this chapter, we're going to talk about a really important concept called `Theme`.

Imagine you're decorating a room. You pick a color palette, decide on the furniture style, and choose the overall "feel" you want the room to have. In Flutter, `Theme` is kind of like applying that master decoration plan (`ThemeData`) to a specific part of your app's screen.

### What Problem Does `Theme` Solve?

Think about building an app with lots of buttons, text, and other visual elements. If you had to set the color, font size, and style for *each* button and *each* piece of text individually, it would be a lot of work! And if you ever wanted to change your app's look (maybe switch from light mode to dark mode), you'd have to update *everything* manually. That sounds like a nightmare!

`Theme` solves this problem by letting you define a set of styles and colors in one place, and then easily apply those styles to different parts of your app. When you change the `Theme`, all the widgets that use that theme will automatically update their appearance. It's like changing the paint color for a whole room with just one click!

### What is `Theme`?

In Flutter, `Theme` is actually a **widget**. Widgets are the building blocks of Flutter apps. The `Theme` widget is a *special* kind of widget because it doesn't just show something on the screen; it influences how the widgets *below* it in the widget tree look.

When you place a `Theme` widget around other widgets, you're essentially telling all those widgets to follow the style rules defined in the `Theme`.

Here's a super simple peek at what using `Theme` looks like:

```dart
MaterialApp(
  home: Scaffold(
    body: Theme( // Here's the Theme widget!
      data: ThemeData( // We'll learn about this in the next chapter!
        primaryColor: Colors.blue,
        // Other style settings...
      ),
      child: Center(
        child: Text(
          'Hello, Themed Text!',
        ),
      ),
    ),
  ),
);
```

In this example, we're wrapping a `Center` widget (which contains a `Text` widget) with a `Theme` widget. We're giving the `Theme` some `data` (we'll dive deep into `ThemeData` in the next chapter!), and this `data` tells it how things like primary colors should look. Any widgets inside this `Theme` that use primary colors will now use the blue color we specified.

### How `Theme` Works (Under the Hood)

You might be wondering how a widget can "talk" to the widgets below it. Flutter uses a system called "Inherited Widgets" for this. `Theme` is an example of an inherited widget.

Think of an inherited widget like a shop sign that everyone in the building can see and use. When a widget needs some information (like what the theme color should be), it "looks up" the widget tree until it finds the nearest `Theme` widget. Then it uses the `data` from that `Theme` widget to style itself.

Here's a simplified idea of how a `Text` widget might get its color:

```mermaid
sequenceDiagram
    participant T as Text Widget
    participant B as BuildContext
    participant TH as Theme Widget
    participant TD as ThemeData

    T->>B: "Hey BuildContext, what's the current theme data?"
    B->>TH: "Nearest Theme widget, what's your data?"
    TH->>TD: "ThemeData object, what's the text color?"
    TD-->>TH: Returns text color
    TH-->>B: Returns text color
    B-->>T: Returns text color
    T->>T: Displays text with that color
```
This diagram shows a `Text` widget asking its `BuildContext` (which connects it to the widget tree) for the theme information. The `BuildContext` then finds the `Theme` widget, which provides the `ThemeData`. The `Text` widget can then use this `ThemeData` to decide how it should look.

The core of this mechanism is the `Theme.of(BuildContext context)` method. This is the standard way for any widget in Flutter to access the theme information from the nearest `Theme` ancestor in the tree. You'll see `Theme.of(context)` very often in Flutter code!

Looking at the `Theme.of` method in the `theme.dart` file, you can see how it uses `context.dependOnInheritedWidgetOfExactType<_InheritedTheme>()` to find the nearest `_InheritedTheme` (which is the internal widget Flutter uses for the `Theme`).

```dart
// From packages/flutter/lib/src/material/theme.dart
static ThemeData of(BuildContext context) {
  final _InheritedTheme? inheritedTheme =
      context.dependOnInheritedWidgetOfExactType<_InheritedTheme>();
  // ... other logic ...
  final ThemeData theme =
      inheritedTheme?.theme.data ??
      // ... fallback logic ...
      _kFallbackTheme;
  return ThemeData.localize(theme, theme.typography.geometryThemeFor(category));
}
```
Don't worry too much about all the details here; the key is that `dependOnInheritedWidgetOfExactType` is the magic that allows a widget to look up the tree and get information from a parent `Theme` widget.

### Applying `Theme` to a Part of Your App

You can use the `Theme` widget to apply different themes to different parts of your app. For example, you might have a standard theme for most of your app, but a specific section might have a slightly different look, perhaps highlighting a special feature.

```dart
// Imagine this is somewhere inside your app's build method
Column(
  children: [
    Text('Regular Text'), // This uses the main app theme
    Theme( // Applying a different theme here
      data: ThemeData(
        primaryColor: Colors.green, // A different color
      ),
      child: ElevatedButton( // This button will use the green primary color
        onPressed: () {},
        child: Text('Green Button'),
      ),
    ),
    Text('More Regular Text'), // This goes back to the main app theme
  ],
)
```

In this example, the `ElevatedButton` inside the second `Theme` widget will use the specified green color for its primary color, while the `Text` widgets will use the colors from the `ThemeData` higher up in the widget tree (likely from your `MaterialApp`).

This ability to apply themes to specific subtrees of your app gives you a lot of flexibility in designing your UI.

### Conclusion

In this chapter, we learned that `Theme` is a fundamental Flutter widget used to apply styles and visual configurations (`ThemeData`) to parts of your application. It helps you manage your app's look in a consistent and efficient way. We saw how `Theme` works using the concept of inherited widgets and how you can apply different themes to different sections of your app.

Now that you have a basic understanding of `Theme`, the next step is to explore what actually *goes inside* the `Theme` widget: the `ThemeData`.

[ThemeData](02_themedata_.md)
---
# Chapter 2: ThemeData

Welcome back! In the last chapter, we learned about the `Theme` widget, which is like a magical box that applies a design plan to parts of your Flutter app. But what exactly is that design plan? That's where `ThemeData` comes in!

### What Problem Does `ThemeData` Solve?

Imagine you're building a large app with many screens. Each screen has buttons, text, backgrounds, and more. If you had to manually pick colors and font styles for every single item on every single screen, it would be a huge mess! What if your company decided to change the main brand color? You'd have to go through your entire app, finding every place you used the old color and replacing it with the new one. This is time-consuming and prone to errors.

`ThemeData` solves this problem by being a central place where you define the overall look and feel of your app. It's like having a style guide for your entire application. Instead of styling each individual button, you define the *default* style for *all* buttons in your `ThemeData`. Then, every button in your app will automatically follow that default style. If you want to change the button style later, you just update the `ThemeData`, and all your buttons instantly change!

Think of it as choosing all the paint colors, furniture styles, and lighting fixtures for an entire house *before* you start decorating any specific room. `ThemeData` is that master plan.

### What is `ThemeData`?

`ThemeData` is **not** a widget. Unlike the `Theme` widget (which you place in your app's layout), `ThemeData` is simply a **Dart class** that holds a bunch of properties about your app's theme. These properties include things like:

*   **Colors:** The main colors used in your app, like the primary color, accent color, background color, etc. (We'll talk even more about colors in the next chapter on [ColorScheme](03_colorscheme_.md)!).
*   **Text Styles:** The default fonts, sizes, and weights for different types of text (headings, body text, captions).
*   **Component Themes:** Specific default styles for individual widgets like buttons (`ElevatedButtonThemeData`, `TextButtonThemeData`), App Bars (`AppBarTheme`), dialogs (`DialogThemeData`), and many more.

Here's a simple example of creating a basic `ThemeData`:

```dart
ThemeData myCustomTheme = ThemeData(
  primarySwatch: Colors.purple, // A collection of purple shades
  textTheme: TextTheme( // Defining text styles
    bodyMedium: TextStyle(fontSize: 16.0),
  ),
  elevatedButtonTheme: ElevatedButtonThemeData( // Styling the button
    style: ElevatedButton.styleFrom(
      backgroundColor: Colors.deepOrange, // Button color
      foregroundColor: Colors.white, // Text color on the button
    ),
  ),
);
```

In this code snippet, we're creating a `ThemeData` object named `myCustomTheme`. We're setting the `primarySwatch` to purple (which provides different shades of purple), defining a default style for body text, and setting a specific background and text color for `ElevatedButton`s.

### How to Use `ThemeData`

You typically use your `ThemeData` object within a `Theme` widget (like we saw in Chapter 1) or within the `theme` property of your `MaterialApp` (which is the most common way to set the theme for your entire app).

Here's how you'd apply the `myCustomTheme` from the previous example to your whole app using `MaterialApp`:

```dart
import 'package:flutter/material.dart';

void main() {
  runApp(const MyApp());
}

class MyApp extends StatelessWidget {
  const MyApp({super.key});

  @override
  Widget build(BuildContext context) {
    ThemeData myCustomTheme = ThemeData(
      primarySwatch: Colors.purple,
      textTheme: const TextTheme(
        bodyMedium: TextStyle(fontSize: 16.0),
      ),
      elevatedButtonTheme: ElevatedButtonThemeData(
        style: ElevatedButton.styleFrom(
          backgroundColor: Colors.deepOrange,
          foregroundColor: Colors.white,
        ),
      ),
    );

    return MaterialApp(
      title: 'Themed App',
      theme: myCustomTheme, // Applying our custom theme!
      home: Scaffold(
        appBar: AppBar(
          title: const Text('Home Screen'),
        ),
        body: Center(
          child: Column(
            mainAxisAlignment: MainAxisAlignment.center,
            children: [
              Text(
                'This text uses the default bodyMedium style.',
              ),
              const SizedBox(height: 20),
              ElevatedButton(
                onPressed: () {
                  // Do something
                },
                child: const Text('Styled Button'),
              ),
            ],
          ),
        ),
      ),
    );
  }
}
```

In this example, because we set `myCustomTheme` in the `theme` property of `MaterialApp`, the `AppBar` will likely pick colors based on the `primarySwatch` (purple), the first `Text` widget will use the `bodyMedium` style (16.0 font size), and the `ElevatedButton` will have a deep orange background and white text. All these styles are defined just once in our `ThemeData`!

### Default `ThemeData`

Flutter provides default light and dark themes out of the box. You can easily use these by setting the `theme` property of your `MaterialApp` to `ThemeData.light()` or `ThemeData.dark()`.

```dart
MaterialApp(
  title: 'Default Light Theme App',
  theme: ThemeData.light(), // Using the default light theme
  home: Scaffold(
    appBar: AppBar(title: Text('Light Theme')),
    body: Center(child: Text('Default colors and fonts')),
  ),
);
```

You can also start with a default theme and then modify specific parts using `copyWith`:

```dart
ThemeData lightThemeWithRedButtons = ThemeData.light().copyWith(
  elevatedButtonTheme: ElevatedButtonThemeData(
    style: ElevatedButton.styleFrom(
      backgroundColor: Colors.red, // Only change button color
      foregroundColor: Colors.white,
    ),
  ),
);

MaterialApp(
  title: 'Customized Light Theme App',
  theme: lightThemeWithRedButtons, // Using the customized light theme
  home: Scaffold(
    appBar: AppBar(title: Text('Custom Theme')),
    body: Center(
      child: ElevatedButton(
        onPressed: () {},
        child: Text('Red Button'),
      ),
    ),
  ),
);
```

This is a powerful way to quickly customize a few things while keeping the rest of the standard Material Design look.

### Under the Hood: `ThemeData.raw` and Interpolation

While you'll mostly use the main `ThemeData` constructor or `ThemeData.light()/dark()`, it's good to know that there's also a `ThemeData.raw` constructor. This constructor is used internally by Flutter, especially for smoothly transitioning between themes (like when switching from light to dark mode).

The `ThemeData.raw` constructor requires you to provide *every single* theme property. This seems like a lot, because it is! It's not meant for you to use directly very often. Its purpose is to allow for linear interpolation between two `ThemeData` objects when animating theme changes (which happens automatically with `AnimatedTheme`).

Here's a simplified idea of how animating themes might work:

```mermaid
sequenceDiagram
    participant AT as AnimatedTheme
    participant TD1 as ThemeData (Start)
    participant TD2 as ThemeData (End)
    participant TD_lerp as ThemeData (Interpolated)

    AT->>TD1: Get initial ThemeData
    AT->>TD2: Get final ThemeData
    AT->>AT: Start Animation (t from 0 to 1)
    loop For each animation step
        AT->>TD1: Get value (e.g. color)
        AT->>TD2: Get matching value (e.g. color)
        AT->>TD_lerp: Calculate interpolated value (lerpColor(color1, color2, t))
        TD_lerp-->>AT: Return interpolated value
    end
    AT->>AT: Pass interpolated ThemeData down widget tree
```

This diagram shows that when `AnimatedTheme` changes, it doesn't just swap `ThemeData` instantly. It uses the `ThemeData.lerp` method to calculate intermediate `ThemeData` objects based on how far the animation has progressed (`t`). This creates a smooth visual transition, for example, colors fading from one to another. The `ThemeData.raw` constructor is what `ThemeData.lerp` uses to construct these intermediate theme data objects.

Looking at the `ThemeData.lerp` code snippet, you can see it calls `Color.lerp`, `TextTheme.lerp`, and other `lerp` methods for individual theme properties:

```dart
// From packages/flutter/lib/src/material/theme_data.dart
static ThemeData lerp(ThemeData a, ThemeData b, double t) {
  if (identical(a, b)) {
    return a;
  }
  return ThemeData.raw(
    // ... other properties
    canvasColor: Color.lerp(a.canvasColor, b.canvasColor, t)!, // Interpolating colors
    // ... other properties
    textTheme: TextTheme.lerp(a.textTheme, b.textTheme, t), // Interpolating text styles
    // ... other properties
  );
}
```

This shows how `ThemeData.lerp` combines the individual properties from two themes based on the interpolation factor `t` (which goes from 0 to 1 during the animation) and uses `ThemeData.raw` to build the resulting interpolated theme.

### Conclusion

`ThemeData` is the blueprint for your app's visual design. By defining colors, text styles, and component appearances in a single place using `ThemeData`, you make your app's look consistent and easy to manage and update. You can use the default light or dark themes, create your own entirely, or modify existing ones. `ThemeData` also supports animating visual changes smoothly using interpolation, leveraging the `ThemeData.raw` constructor internally.

In the next chapter, we'll dive deeper into the concept of [ColorScheme](03_colorscheme_.md), which is a very important part of `ThemeData` and a modern way to manage your app's colors according to Material Design principles.

[ColorScheme](03_colorscheme_.md)
---
# Chapter 3: ColorScheme

Welcome back! In over the last two chapters, we explored `Theme` which is like applying a design plan, and `ThemeData`, which is the blueprint holding all the details of that plan, including colors, fonts, and component styles.

In this chapter, we're going to focus on a crucial part of `ThemeData`: the `ColorScheme`. Think of `ThemeData` as the overall architecture of your house, and `ColorScheme` as the meticulously selected paint palette for each room, ensuring all the colors work together harmoniously.

### What Problem Does `ColorScheme` Solve?

Setting colors for your app can feel like choosing paint for every single wall and ceiling in a large building. There are background colors, text colors, button colors, error colors, and so many more! If you just pick random colors for each part, your app can end up looking messy and inconsistent. Plus, choosing colors that work well for both light and dark modes, and ensuring enough contrast for accessibility, is a complex task.

`ColorScheme` solves this by defining a standard set of color "roles" based on Material Design principles. Instead of just picking a red, you pick an `error` color. Instead of picking a blue, you pick a `primary` color. This structured approach ensures that colors are used consistently throughout your app, that they look good together, and that they meet accessibility standards more easily.

It's like having a named box of crayons with roles: "main color," "accent color," "warning color," etc. When you need to color something, you pick the crayon whose role fits where the color will be used.

### What is `ColorScheme`?

Similar to `ThemeData`, `ColorScheme` is **not** a widget. It's a **Dart class** that's a collection of named `Color` properties. These properties represent different roles that colors play in a user interface according to Material Design. Some key roles include:

*   `primary`: The main color of your app, used for key elements like the AppBar and primary buttons.
*   `secondary`: A contrasting color, often used for less prominent elements like secondary buttons or filter chips.
*   `error`: The color used to indicate errors, typically red.
*   `surface`: The color used for backgrounds of components like cards and sheets.
*   `onPrimary`, `onSecondary`, `onError`, `onSurface`: These are crucial "on" colors. They are designed to have good contrast with their corresponding base color (e.g., `onPrimary` is for text or icons placed *on* a `primary` colored background).

Creating a simple `ColorScheme` might look like this:

```dart
ColorScheme myColorScheme = const ColorScheme(
  brightness: Brightness.light, // Is this a light or dark scheme?
  primary: Colors.blue,
  onPrimary: Colors.white, // White text on blue is easy to read
  secondary: Colors.green,
  onSecondary: Colors.white, // White text on green is easy to read
  error: Colors.red,
  onError: Colors.white, // White text on red is easy to read
  surface: Colors.white,
  onSurface: Colors.black, // Black text on whiteです easy to read
);
```

This example defines a basic light `ColorScheme` with blue as the primary color, green as the secondary, red for errors, and standard black and white for text and surfaces.

### How to Use `ColorScheme`

You usually don't use a `ColorScheme` object directly everywhere in your code. Instead, you include it as part of your `ThemeData`, and then components automatically pick up the colors they need from the theme.

The most common way to set your app's `ColorScheme` is within the `colorScheme` property of your `ThemeData` when creating it:

```dart
import 'package:flutter/material.dart';

void main() {
  runApp(const MyApp());
}

class MyApp extends StatelessWidget {
  const MyApp({super.key});

  @override
  Widget build(BuildContext context) {
    ColorScheme myColorScheme = const ColorScheme(
      brightness: Brightness.light,
      primary: Colors.deepPurple, // Let's use deep purple!
      onPrimary: Colors.white,
      secondary: Colors.teal, // And teal for secondary
      onSecondary: Colors.white,
      error: Colors.redAccent, // A slightly different red
      onError: Colors.black,
      surface: Colors.grey, // A light grey surface
      onSurface: Colors.black87,
    );

    return MaterialApp(
      title: 'ColorScheme App',
      theme: ThemeData(
        colorScheme: myColorScheme, // Using our custom ColorScheme!
        useMaterial3: true, // Make sure to use Material 3 for the full ColorScheme
      ),
      home: Scaffold(
        appBar: AppBar(
          title: const Text('Home Screen'),
          // AppBar often uses the primary color
          backgroundColor: Theme.of(context).colorScheme.primary,
          foregroundColor: Theme.of(context).colorScheme.onPrimary, // Use onPrimary for text/icons
        ),
        body: Center(
          child: Column(
            mainAxisAlignment: MainAxisAlignment.center,
            children: [
              Text(
                'Primary Color Example',
                style: TextStyle(color: Theme.of(context).colorScheme.primary),
              ),
              const SizedBox(height: 20),
              ElevatedButton(
                onPressed: () {
                  // Do something
                },
                // ElevatedButton often uses primary/onPrimary for its default style
                child: const Text('Primary Button'),
              ),
              const SizedBox(height: 20),
              Text(
                'Secondary Color Example',
                style: TextStyle(color: Theme.of(context).colorScheme.secondary),
              ),
              const SizedBox(height: 20),
              FloatingActionButton(
                onPressed: () {
                  // Do something else
                },
                backgroundColor: Theme.of(context).colorScheme.secondary, // FAB often uses secondary
                foregroundColor: Theme.of(context).colorScheme.onSecondary, // Use onSecondary for icon
                child: const Icon(Icons.add),
              ),
              const SizedBox(height: 20),
              Text(
                'Error Color Example',
                style: TextStyle(color: Theme.of(context).colorScheme.error),
              ),
            ],
          ),
        ),
      ),
    );
  }
}
```

In this slightly longer (but broken down) example:

1.  We create a `ColorScheme` object with specific colors for different roles.
2.  We set this `ColorScheme` to the `colorScheme` property of our `ThemeData`. We also set `useMaterial3: true` because Material 3 heavily relies on the detailed `ColorScheme` roles.
3.  Inside the `Scaffold` and its widgets, we access the `ColorScheme` using `Theme.of(context).colorScheme`.
4.  We explicitly show how some widgets (like `AppBar`, `ElevatedButton`, and `FloatingActionButton`) *often* use specific `ColorScheme` roles for their default appearance. You can manually apply these, but often the widgets themselves will pick them up automatically if not overridden.

Using `ColorScheme` this way centralizes your color definitions and makes it easy to understand how colors should be used throughout your UI.

### Generating `ColorScheme` from a Seed Color

Manually picking all those colors can still be a lot! Fortunately, Material Design 3 provides a powerful way to generate an entire `ColorScheme` from just a single "seed" color. This ensures that all the generated colors are harmonious and meet accessibility standards.

You can use the `ColorScheme.fromSeed` factory constructor:

```dart
import 'package:flutter/material.dart';

void main() {
  runApp(const MyApp());
}

class MyApp extends StatelessWidget {
  const MyApp({super.key});

  @override
  Widget build(BuildContext context) {
    return MaterialApp(
      title: 'Generated ColorScheme App',
      theme: ThemeData(
        // Generate a light ColorScheme from a blue seed color
        colorScheme: ColorScheme.fromSeed(
          seedColor: Colors.blue,
          brightness: Brightness.light,
        ),
        useMaterial3: true,
      ),
      darkTheme: ThemeData(
        // Generate a dark ColorScheme from the same blue seed color
        colorScheme: ColorScheme.fromSeed(
          seedColor: Colors.blue,
          brightness: Brightness.dark,
        ),
        useMaterial3: true,
      ),
      home: Scaffold(
        appBar: AppBar(
          title: const Text('Home Screen'),
        ),
        body: Center(
          child: Column(
            mainAxisAlignment: MainAxisAlignment.center,
            children: [
              Text(
                'Text using primary color',
                style: TextStyle(color: Theme.of(context).colorScheme.primary),
              ),
              const SizedBox(height: 20),
              ElevatedButton(
                onPressed: () {},
                child: const Text('Button'),
              ),
              const SizedBox(height: 20),
              FloatingActionButton(
                onPressed: () {},
                child: const Icon(Icons.add),
              ),
            ],
          ),
        ),
      ),
    );
  }
}
```

In this example:

1.  We use `ColorScheme.fromSeed` with `Colors.blue` to generate a complete `ColorScheme` for both the light and dark themes.
2.  Flutter's Material library handles generating all the roles (primary, secondary, surface, etc.) based on that seed color, ensuring they work well together and meet accessibility standards.
3.  We see that the `AppBar`, `ElevatedButton`, and `FloatingActionButton` automatically pick up the colors from the generated `ColorScheme` roles.

This is the recommended and easiest way to get a consistent and accessible color palette for your app using Material Design 3.

### Under the Hood: `ColorScheme` Generation and Interpolation

How does `ColorScheme.fromSeed` work its magic? Flutter uses a library called `material_color_utilities`. This library implements the Material Design 3 color system, which is based on creating "tonal palettes" from a seed color.

Here's a simplified idea of what happens when you use `ColorScheme.fromSeed`:

```mermaid
sequenceDiagram
    participant App as Your App Code
    participant CSSeed as ColorScheme.fromSeed
    participant MCU as material_color_utilities
    participant CS as ColorScheme Object

    App->>CSSeed: Call ColorScheme.fromSeed(seedColor:...)
    CSSeed->>MCU: Pass seed color and brightness
    MCU->>MCU: Generate tonal palettes based on seed color
    MCU->>MCU: Map tonal palette colors to ColorScheme roles (primary, secondary, surface, etc.)
    MCU-->>CSSeed: Return calculated colors for each role
    CSSeed->>CS: Create new ColorScheme object with calculated colors
    CSSeed-->>App: Return the new ColorScheme object

```

This diagram shows that `ColorScheme.fromSeed` delegates the heavy lifting of color generation to the `material_color_utilities` library. This library takes the seed color, analyzes its properties (like hue and chroma), and generates related colors across different tones that form a harmonious palette. It then assigns these generated colors to the various `ColorScheme` roles.

Looking at the code snippet from `colorscheme.dart`, you can see the `_buildDynamicScheme` method being called, which comes from the `material_color_utilities` library:

```dart
// From packages/flutter/lib/src/material/color_scheme.dart
  factory ColorScheme.fromSeed({
    required Color seedColor,
    Brightness brightness = Brightness.light,
    DynamicSchemeVariant dynamicSchemeVariant = DynamicSchemeVariant.tonalSpot,
    double contrastLevel = 0.0,
    // ... other parameters for overrides
  }) {
    final DynamicScheme scheme = _buildDynamicScheme(
      brightness,
      seedColor,
      dynamicSchemeVariant,
      contrastLevel,
    );

    return ColorScheme(
      primary: primary ?? Color(MaterialDynamicColors.primary.getArgb(scheme)),
      onPrimary: onPrimary ?? Color(MaterialDynamicColors.onPrimary.getArgb(scheme)),
      // ... other ColorScheme roles are set here using colors from the scheme
    );
  }

// (Later in the same file)
static DynamicScheme _buildDynamicScheme(
    Brightness brightness,
    Color seedColor,
    DynamicSchemeVariant schemeVariant,
    double contrastLevel,
  ) {
    final bool isDark = brightness == Brightness.dark;
    final Hct sourceColor = Hct.fromInt(seedColor.value);
    return switch (schemeVariant) {
      DynamicSchemeVariant.tonalSpot => SchemeTonalSpot( // One of the generation algorithms
        sourceColorHct: sourceColor,
        isDark: isDark,
        contrastLevel: contrastLevel,
      ),
      // ... other variants
    };
  }
```

This confirms that `fromSeed` uses an external library (`material_color_utilities`, imported at the top as `MaterialDynamicColors`, `DynamicScheme`, `Hct`, etc.) to build the underlying color `scheme` and then uses colors derived from that scheme to populate the `ColorScheme` properties like `primary` and `onPrimary`.

Just like `ThemeData`, `ColorScheme` also supports smooth transitions between different color schemes using the `ColorScheme.lerp` method internally, which is used when animating theme changes (for example, with `AnimatedTheme`).

```dart
// From packages/flutter/lib/src/material/color_scheme.dart
static ColorScheme lerp(ColorScheme a, ColorScheme b, double t) {
  if (identical(a, b)) {
    return a;
  }
  return ColorScheme(
    brightness: t < 0.5 ? a.brightness : b.brightness,
    primary: Color.lerp(a.primary, b.primary, t)!, // Lerping individual colors
    onPrimary: Color.lerp(a.onPrimary, b.onPrimary, t)!,
    // ... other color properties are lerped
  );
}
```

This shows that the interpolation between two `ColorScheme` objects is done by linearly interpolating each individual color property within the scheme.

### Conclusion

`ColorScheme` is a powerful way to manage your app's color palette in a structured, consistent, and accessible manner. It defines named roles for colors, making it easier to apply and update your app's look. The recommended approach in Material Design 3 is to generate your `ColorScheme` from a single seed color using `ColorScheme.fromSeed`, which leverages the `material_color_utilities` library to create a harmonious and accessible palette. `ColorScheme` is a key part of your `ThemeData` and is automatically used by many Flutter Material widgets.

Now that you understand how `ColorScheme` gives structure to your app's colors within the `ThemeData`, we'll look at how you can add your *own* custom data to the theme with [ThemeExtension](04_themeextension_.md).

[ThemeExtension](04_themeextension_.md)
---
# Chapter 4: ThemeExtension

Welcome back! In our previous chapters, we learned that the [Theme](01_theme_.md) widget applies a design plan, [ThemeData](02_themedata_.md) is that detailed plan holding all the standard styling information (like fonts and component styles), and [ColorScheme](03_colorscheme_.md) helps us manage colors for different UI roles within that plan.

But what if your app needs some custom styling information that isn't covered by the standard `ThemeData` properties or `ColorScheme` roles? Imagine you have a specific type of card in your app that always needs a unique gradient background and a particular size setting, and you want to define this rule in your theme so all these special cards use the same style consistently. The standard `ThemeData` doesn't have a specific property for "my special card's gradient."

That's where `ThemeExtension` comes in!

### What Problem Does `ThemeExtension` Solve?

The standard `ThemeData` comes with a lot of properties to cover common styling needs for Material Design. However, every app is unique, and you might have custom visual elements or specific styling rules that don't fit neatly into the predefined categories like `primaryColor`, `textTheme.bodyMedium`, or `cardTheme`.

If you couldn't add custom properties to your theme, you'd have to define these unique styles manually every time you used that special element throughout your app. This leads to code duplication, makes it difficult to maintain consistency, and makes changing that special style a tedious process (just like changing the brand color without using `ThemeData`!).

`ThemeExtension` solves this by allowing you to add **your own custom data** to the existing `ThemeData` object. It's like adding a dedicated section to your house blueprint for unique features like a custom-designed mailbox color or a specific pattern for floor tiles in one area, features that aren't in the standard building code or typical house plans.

### What is `ThemeExtension`?

`ThemeExtension` is an **abstract class** that you **subclass** (create your own version of) to define your custom theme properties. You create your own class that `extends ThemeExtension` and put whatever properties you need inside it – like `Color`s, `TextStyle`s, `double`s, or even other simple data types.

Your custom `ThemeExtension` class must implement two methods:

1.  `copyWith`: This method is used to create a copy of your extension, optionally changing some properties. This is similar to how `ThemeData` has a `copyWith` method.
2.  `lerp`: This method is crucial for smoothly animating between two different versions of your custom theme data. It stands for "linear interpolation," a common technique in animation. It takes another `ThemeExtension` of the same type and a `double t` (which goes from 0 to 1 during the animation) and calculates an intermediate state of your custom properties.

Let's create a simple custom theme extension for that "special card":

```dart
import 'package:flutter/material.dart';

// 1. Create your own class that extends ThemeExtension
class SpecialCardTheme extends ThemeExtension<SpecialCardTheme> {
  // 2. Define your custom properties
  const SpecialCardTheme({
    required this.gradientColors,
    required this.borderCurve,
  });

  final List<Color> gradientColors;
  final double borderCurve; // Just a simplified example for radius

  // 3. Implement copyWith - copy all properties
  @override
  SpecialCardTheme copyWith({
    List<Color>? gradientColors,
    double? borderCurve,
  }) {
    return SpecialCardTheme(
      gradientColors: gradientColors ?? this.gradientColors,
      borderCurve: borderCurve ?? this.borderCurve,
    );
  }

  // 4. Implement lerp - interpolate between values
  @override
  SpecialCardTheme lerp(ThemeExtension<SpecialCardTheme>? other, double t) {
    if (other is! SpecialCardTheme) {
      return this; // Return this if 'other' is not the same type or is null
    }
    return SpecialCardTheme(
      // Here we smoothly transition the gradient colors using Color.lerp
      // Interpolating a list of colors requires interpolating each color
      gradientColors: List.generate(
        gradientColors.length,
        (index) => Color.lerp(
              gradientColors[index],
              other.gradientColors[index],
              t,
            ) ?? // Provide a fallback if lerp is null (unlikely with non-null colors)
            gradientColors[index],
      ),
      // Here we smoothly transition the double value
      borderCurve: t < 0.5 ? borderCurve : other.borderCurve, // Simplified lerp for double
      // For a real double interpolation, use lerpDouble from dart:ui
      // borderCurve: lerpDouble(borderCurve, other.borderCurve, t)!,
    );
  }

  // Optional: Add operator == and hashCode for equality checks
  // This is good practice but not strictly required by ThemeExtension interface
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is SpecialCardTheme &&
          runtimeType == other.runtimeType &&
          listEquals(gradientColors, other.gradientColors) && // Need listEquals for list
          borderCurve == other.borderCurve;

  @override
  int get hashCode => hashValues(hashList(gradientColors), borderCurve); // Need hashList for list
}
```

This is our custom `ThemeExtension` class, `SpecialCardTheme`. It defines a list of colors for a gradient and a double for a border curvature. We've added the necessary `copyWith` and `lerp` methods.

### How to Use `ThemeExtension`

Once you've defined your custom `ThemeExtension` class, you need to add it to your `ThemeData`. You do this using the `extensions` property when creating or copying a `ThemeData`. The `extensions` property takes an `Iterable` (like a `List`) of your custom theme extension objects.

Here's how you'd add `SpecialCardTheme` to your app's `ThemeData`:

```dart
import 'package:flutter/material.dart';
// Assuming your SpecialCardTheme class is in 'special_card_theme.dart'
import 'special_card_theme.dart';

void main() {
  runApp(const MyApp());
}

class MyApp extends StatelessWidget {
  const MyApp({super.key});

  @override
  Widget build(BuildContext context) {
    // Define your custom theme extension instance
    const SpecialCardTheme specialTheme = SpecialCardTheme(
      gradientColors: [Colors.orange, Colors.red],
      borderCurve: 16.0,
    );

    return MaterialApp(
      title: 'Theme Extension App',
      theme: ThemeData(
        primarySwatch: Colors.blue,
        useMaterial3: true,
        // Add your custom extension to the extensions list
        extensions: <ThemeExtension<dynamic>>[
          specialTheme,
        ],
      ),
      home: const HomeScreen(),
    );
  }
}

class HomeScreen extends StatelessWidget {
  const HomeScreen({super.key});

  @override
  Widget build(BuildContext context) {
    // Access the custom theme extension using Theme.of(context).extension<YourClassName>()
    final specialCardTheme = Theme.of(context).extension<SpecialCardTheme>()!;

    return Scaffold(
      appBar: AppBar(
        title: const Text('Home with Custom Theme'),
      ),
      body: Center(
        child: Column(
          mainAxisAlignment: MainAxisAlignment.center,
          children: [
            Text(
              'Standard Text based on ThemeData',
              style: Theme.of(context).textTheme.bodyMedium,
            ),
            const SizedBox(height: 20),
            // Use the properties from your custom extension
            Container(
              width: 200,
              height: 100,
              decoration: BoxDecoration(
                // Accessing custom gradient colors
                gradient: LinearGradient(colors: specialCardTheme.gradientColors),
                borderRadius: BorderRadius.circular(specialCardTheme.borderCurve), // Accessing custom curve
              ),
              child: const Center(
                child: Text(
                  'This is the Special Card!',
                  style: TextStyle(color: Colors.white),
                ),
              ),
            ),
          ],
        ),
      ),
    );
  }
}
```

In this example:

1.  We create an instance of our `SpecialCardTheme` with specific values.
2.  We add this instance to the `extensions` list in our `ThemeData`.
3.  In a widget (`HomeScreen`), we access the theme using `Theme.of(context)`.
4.  We retrieve our specific custom extension using `.extension<SpecialCardTheme>()`. Note the `<SpecialCardTheme>` part – this tells Flutter *which* type of extension to look for. The `!` at the end asserts that we expect it to exist.
5.  We then use the properties (`gradientColors` and `borderCurve`) from the retrieved `specialCardTheme` object to style our `Container` (representing the special card).

Now, if you wanted to change the gradient or border curvature of *all* your "special cards," you just need to update the `SpecialCardTheme` instance provided in your `MaterialApp`'s `ThemeData`.

### Under the Hood: Adding and Retrieving Extensions

When you add your custom `ThemeExtension`s to the `extensions` list in `ThemeData`, Flutter stores them internally in a `Map`. The key of this map is the **type** of your `ThemeExtension` (like `SpecialCardTheme`), and the value is the instance of your extension.

When you call `Theme.of(context).extension<YourCustomExtension>()`, Flutter does the following:

1.  It finds the nearest `ThemeData` in the widget tree (as we saw in Chapter 1).
2.  It looks inside that `ThemeData`'s internal `extensions` map.
3.  It uses the `Type` of your custom extension (`YourCustomExtension`) as the key to find the corresponding instance in the map.
4.  It returns that instance (or `null` if no extension of that type is found).

Here's a super simplified sequence diagram showing the process of retrieving a `ThemeExtension`:

```mermaid
sequenceDiagram
    participant Widget as Your Custom Widget
    participant BuildContext as BuildContext
    participant ThemeWidget as Theme Widget
    participant ThemeData as ThemeData
    participant ExtMap as Internal Extensions Map
    participant CustomExt as Your Custom Extension Object

    Widget->>BuildContext: "Hey, I need the theme extension of type MyCustomExt!"
    BuildContext->>ThemeWidget: "Nearest Theme, what's your data?"
    ThemeWidget->>ThemeData: Get ThemeData object
    ThemeData->>ExtMap: "Is there an extension with key 'MyCustomExt'?"
    ExtMap-->>ThemeData: Yes, here's the MyCustomExt object.
    ThemeData-->>Widget: Return the MyCustomExt object.
    Widget->>Widget: Use the custom properties from the object.
```

This shows how your custom extension objects are stored within the `ThemeData` and retrieved using their type as the identifier.

Looking at the `ThemeData` code snippet provided in the context, you can see the `extensions` property is a `Map<Object, ThemeExtension<dynamic>>`:

```dart
/// Arbitrary additions to this theme.
///
/// To define extensions, pass an [Iterable] containing one or more [ThemeExtension]
/// subclasses to [ThemeData.new] or [copyWith].
///
/// To obtain an extension, use [extension].
/// ...
final Map<Object, ThemeExtension<dynamic>> extensions;

/// Used to obtain a particular [ThemeExtension] from [extensions].
///
/// Obtain with `Theme.of(context).extension<MyThemeExtension>()`.
/// ...
T? extension<T>() => extensions[T] as T?; // This is where it looks up by type T
```

The `extension<T>()` method directly accesses the `extensions` map using `T` as the key. The `<dynamic>` in the map definition just means it can hold any type of `ThemeExtension`.

The `lerp` method in `ThemeData` also handles interpolating themes that have extensions. It calls the `lerp` method **you defined** on each corresponding extension in the two themes being interpolated:

```dart
// From packages/flutter/lib/src/material/theme_data.dart
  static Map<Object, ThemeExtension<dynamic>> _lerpThemeExtensions(
    ThemeData a,
    ThemeData b,
    double t,
  ) {
    // Lerp [a].
    final Map<Object, ThemeExtension<dynamic>> newExtensions = a.extensions.map((
      Object id,
      ThemeExtension<dynamic> extensionA,
    ) {
      final ThemeExtension<dynamic>? extensionB = b.extensions[id];
      // Calls the lerp method you implemented in your custom class!
      return MapEntry<Object, ThemeExtension<dynamic>>(id, extensionA.lerp(extensionB, t));
    });
    // Add [b]-only extensions.
    newExtensions.addEntries(
      b.extensions.entries.where(
        (MapEntry<Object, ThemeExtension<dynamic>> entry) => !a.extensions.containsKey(entry.key),
      ),
    );

    return newExtensions;
  }
```

This snippet shows that `ThemeData.lerp` iterates through the extensions in the first theme (`a`), finds the matching extension in the second theme (`b`), and calls **your** `lerp` method on that pair (`extensionA.lerp(extensionB, t)`). This is why correctly implementing `lerp` in your `ThemeExtension` subclass is essential for enabling smooth theme transitions.

### Conclusion

`ThemeExtension` is a powerful mechanism that allows you to extend `ThemeData` with your own custom properties, going beyond the standard Material Design configurations. By defining your properties in a custom `ThemeExtension` subclass and adding it to your `ThemeData`, you create a central source of truth for unique styling rules in your app, promoting consistency, maintainability, and enabling smooth animations between different versions of your custom theme data.

With your understanding of `Theme`, `ThemeData`, `ColorScheme`, and now `ThemeExtension`, you're well on your way to creating beautifully consistent and well-structured Flutter UIs! Next, we'll briefly touch upon [VisualDensity](05_visualdensity_.md), which controls the compactness of interactive elements.

[VisualDensity](05_visualdensity_.md)

Relevant Code Snippets (Code itself remains unchanged):
--- File: packages/flutter/lib/src/material/theme_data.dart ---
// Copyright 2014 The Flutter Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

/// @docImport 'package:flutter/material.dart';
library;

import 'dart:ui' show Color, lerpDouble;

import 'package:flutter/cupertino.dart';
import 'package:flutter/foundation.dart';

import 'action_buttons.dart';
import 'action_icons_theme.dart';
import 'app_bar_theme.dart';
import 'badge_theme.dart';
import 'banner_theme.dart';
import 'bottom_app_bar_theme.dart';
import 'bottom_navigation_bar_theme.dart';
import 'bottom_sheet_theme.dart';
import 'button_bar_theme.dart';
import 'button_theme.dart';
import 'card_theme.dart';
import 'checkbox_theme.dart';
import 'chip_theme.dart';
import 'color_scheme.dart';
import 'colors.dart';
import 'constants.dart';
import 'data_table_theme.dart';
import 'date_picker_theme.dart';
import 'dialog_theme.dart';
import 'divider_theme.dart';
import 'drawer_theme.dart';
import 'dropdown_menu_theme.dart';
import 'elevated_button_theme.dart';
import 'expansion_tile_theme.dart';
import 'filled_button_theme.dart';
import 'floating_action_button_theme.dart';
import 'icon_button_theme.dart';
import 'ink_ripple.dart';
import 'ink_sparkle.dart';
import 'ink_splash.dart';
import 'ink_well.dart' show InteractiveInkFeatureFactory;
import 'input_decorator.dart';
import 'list_tile.dart';
import 'list_tile_theme.dart';
import 'menu_bar_theme.dart';
import 'menu_button_theme.dart';
import 'menu_theme.dart';
import 'navigation_bar_theme.dart';
import 'navigation_drawer_theme.dart';
import 'navigation_rail_theme.dart';
import 'outlined_button_theme.dart';
import 'page_transitions_theme.dart';
import 'popup_menu_theme.dart';
import 'progress_indicator_theme.dart';
import 'radio_theme.dart';
import 'scrollbar_theme.dart';
import 'search_bar_theme.dart';
import 'search_view_theme.dart';
import 'segmented_button_theme.dart';
import 'slider_theme.dart';
import 'snack_bar_theme.dart';
import 'switch_theme.dart';
import 'tab_bar_theme.dart';
import 'text_button_theme.dart';
import 'text_selection_theme.dart';
import 'text_theme.dart';
import 'time_picker_theme.dart';
import 'toggle_buttons_theme.dart';
import 'tooltip_theme.dart';
import 'typography.dart';

export 'package:flutter/services.dart' show Brightness;

// Examples can assume:
// late BuildContext context;

/// Defines a customized theme for components with an `adaptive` factory constructor.
///
/// Currently, only [Switch.adaptive] supports this class.
class Adaptation<T> {
  /// Creates an [Adaptation].
  const Adaptation();

  /// The adaptation's type.
  Type get type => T;

  /// Typically, this is overridden to return an instance of a custom component
  /// ThemeData class, like [SwitchThemeData], instead of the defaultValue.
  ///
  /// Factory constructors that support adaptations - currently only
  /// [Switch.adaptive] - look for a type-specific adaptation in
  /// [ThemeData.adaptationMap] when computing their effective default component
  /// theme. If a matching adaptation is not found, the component may choose to
  /// use a default adaptation. For example, the [Switch.adaptive] component
  /// uses an empty [SwitchThemeData] if a matching adaptation is not found, for
  /// the sake of backwards compatibility.
  ///
  /// {@tool dartpad}
  /// This sample shows how to create and use subclasses of [Adaptation] that
  /// define adaptive [SwitchThemeData]s. The [adapt] method in this example is
  /// overridden to only customize cupertino-style switches, but it can also be
  /// used to customize any other platforms.
  ///
  /// ** See code in examples/api/lib/material/switch/switch.4.dart **
  /// {@end-tool}
  T adapt(ThemeData theme, T defaultValue) => defaultValue;
}

/// An interface that defines custom additions to a [ThemeData] object.
///
/// {@youtube 560 315 https://www.youtube.com/watch?v=8-szcYzFVao}
///
/// Typically used for custom colors. To use, subclass [ThemeExtension],
/// define a number of fields (e.g. [Color]s), and implement the [copyWith] and
/// [lerp] methods. The latter will ensure smooth transitions of properties when
/// switching themes.
///
/// {@tool dartpad}
/// This sample shows how to create and use a subclass of [ThemeExtension] that
/// defines two colors.
///
/// ** See code in examples/api/lib/material/theme/theme_extension.1.dart **
/// {@end-tool}
abstract class ThemeExtension<T extends ThemeExtension<T>> {
  /// Enable const constructor for subclasses.
  const ThemeExtension();

  /// The extension's type.
  Object get type => T;

  /// Creates a copy of this theme extension with the given fields
  /// replaced by the non-null parameter values.
  ThemeExtension<T> copyWith();

  /// Linearly interpolate with another [ThemeExtension] object.
  ///
  /// {@macro dart.ui.shadow.lerp}
  ThemeExtension<T> lerp(covariant ThemeExtension<T>? other, double t);
}

/// Configures the tap target and layout size of certain Material widgets.
///
/// Changing the value in [ThemeData.materialTapTargetSize] will affect the
/// accessibility experience.
///
/// Some of the impacted widgets include:
///
///   * [FloatingActionButton], only the mini tap target size is increased.
///   * [MaterialButton]
///   * [OutlinedButton]
///   * [TextButton]
///   * [ElevatedButton]
///   * [IconButton]
///   * The time picker widget ([showTimePicker])
///   * [SnackBar]
///   * [Chip]
///   * [RawChip]
///   * [InputChip]
///   * [ChoiceChip]
///   * [FilterChip]
///   * [ActionChip]
///   * [Radio]
///   * [Switch]
///   * [Checkbox]
enum MaterialTapTargetSize {
  /// Expands the minimum tap target size to 48px by 48px.
  ///
  /// This is the default value of [ThemeData.materialTapTargetSize] and the
  /// recommended size to conform to Android accessibility scanner
  /// recommendations.
  padded,

  /// Shrinks the tap target size to the minimum provided by the Material
  /// specification.
  shrinkWrap,
}

/// Defines the configuration of the overall visual [Theme] for a [MaterialApp]
/// or a widget subtree within the app.
///
/// The [MaterialApp] theme property can be used to configure the appearance
/// of the entire app. Widget subtrees within an app can override the app's
/// theme by including a [Theme] widget at the top of the subtree.
///
/// Widgets whose appearance should align with the overall theme can obtain the
/// current theme's configuration with [Theme.of]. Material components typically
/// depend exclusively on the [colorScheme] and [textTheme]. These properties
/// are guaranteed to have non-null values.
///
/// The static [Theme.of] method finds the [ThemeData] value specified for the
/// nearest [BuildContext] ancestor. This lookup is inexpensive, essentially
/// just a single HashMap access. It can sometimes be a little confusing
/// because [Theme.of] can not see a [Theme] widget that is defined in the
/// current build method's context. To overcome that, create a new custom widget
/// for the subtree that appears below the new [Theme], or insert a widget
/// that creates a new BuildContext, like [Builder].
///
/// {@tool dartpad}
/// This example demonstrates how a typical [MaterialApp] specifies
/// and uses a custom [Theme]. The theme's [ColorScheme] is based on a
/// single "seed" color and configures itself to match the platform's
/// current light or dark color configuration. The theme overrides the
/// default configuration of [FloatingActionButton] to show how to
/// customize the appearance a class of components.
///
/// ** See code in examples/api/lib/material/theme_data/theme_data.0.dart **
/// {@end-tool}
///
/// See <https://material.io/design/color/> for
/// more discussion on how to pick the right colors.

@immutable
class ThemeData with Diagnosticable {
  /// Create a [ThemeData] that's used to configure a [Theme].
  ///
  /// The [colorScheme] and [textTheme] are used by the Material components to
  /// compute default values for visual properties. The API documentation for
  /// each component widget explains exactly how the defaults are computed.
  ///
  /// When providing a [ColorScheme], apps can either provide one directly
  /// with the [colorScheme] parameter, or have one generated for them by
  /// using the [colorSchemeSeed] and [brightness] parameters. A generated
  /// color scheme will be based on the tones of [colorSchemeSeed] and all of
  /// its contrasting color will meet accessibility guidelines for readability.
  /// (See [ColorScheme.fromSeed] for more details.)
  ///
  /// If the app wants to customize a generated color scheme, it can use
  /// [ColorScheme.fromSeed] directly and then [ColorScheme.copyWith] on the
  /// result to override any colors that need to be replaced. The result of
  /// this can be used as the [colorScheme] directly.
  ///
  /// For historical reasons, instead of using a [colorSchemeSeed] or
  /// [colorScheme], you can provide either a [primaryColor] or [primarySwatch]
  /// to construct the [colorScheme], but the results will not be as complete
  /// as when using generation from a seed color.
  ///
  /// If [colorSchemeSeed] is non-null then [colorScheme], [primaryColor] and
  /// [primarySwatch] must all be null.
  ///
  /// The [textTheme] [TextStyle] colors are black if the color scheme's
  /// brightness is [Brightness.light], and white for [Brightness.dark].
  ///
  /// To override the appearance of specific components, provide
  /// a component theme parameter like [sliderTheme], [toggleButtonsTheme],
  /// or [bottomNavigationBarTheme].
  ///
  /// See also:
  ///
  ///  * [ThemeData.from], which creates a ThemeData from a [ColorScheme].
  ///  * [ThemeData.light], which creates the default light theme.
  ///  * [ThemeData.dark], which creates the default dark theme.
  ///  * [ColorScheme.fromSeed], which is used to create a [ColorScheme] from a seed color.
  factory ThemeData({
    // For the sanity of the reader, make sure these properties are in the same
    // order in every place that they are separated by section comments (e.g.
    // GENERAL CONFIGURATION). Each section except for deprecations should be
    // alphabetical by symbol name.

    // GENERAL CONFIGURATION
    Iterable<Adaptation<Object>>? adaptations,
    bool? applyElevationOverlayColor,
    NoDefaultCupertinoThemeData? cupertinoOverrideTheme,
    Iterable<ThemeExtension<dynamic>>? extensions,
    InputDecorationTheme? inputDecorationTheme,
    MaterialTapTargetSize? materialTapTargetSize,
    PageTransitionsTheme? pageTransitionsTheme,
    TargetPlatform? platform,
    ScrollbarThemeData? scrollbarTheme,
    InteractiveInkFeatureFactory? splashFactory,
    bool? useMaterial3,
    VisualDensity? visualDensity,
    // COLOR
    ColorScheme? colorScheme,
    Brightness? brightness,
    Color? colorSchemeSeed,
    // [colorScheme] is the preferred way to configure colors. The [Color] properties
    // listed below (as well as primarySwatch) will gradually be phased out, see
    // https://github.com/flutter/flutter/issues/91772.
    Color? canvasColor,
    Color? cardColor,
    Color? disabledColor,
    Color? dividerColor,
    Color? focusColor,
    Color? highlightColor,
    Color? hintColor,
    Color? hoverColor,
    Color? indicatorColor,
    Color? primaryColor,
    Color? primaryColorDark,
    Color? primaryColorLight,
    MaterialColor? primarySwatch,
    Color? scaffoldBackgroundColor,
    Color? secondaryHeaderColor,
    Color? shadowColor,
    Color? splashColor,
    Color? unselectedWidgetColor,
    // TYPOGRAPHY & ICONOGRAPHY
    String? fontFamily,
    List<String>? fontFamilyFallback,
    String? package,
    IconThemeData? iconTheme,
    IconThemeData? primaryIconTheme,
    TextTheme? primaryTextTheme,
    TextTheme? textTheme,
    Typography? typography,
    // COMPONENT THEMES
    ActionIconThemeData? actionIconTheme,
    AppBarTheme? appBarTheme,
    BadgeThemeData? badgeTheme,
    MaterialBannerThemeData? bannerTheme,
    BottomAppBarTheme? bottomAppBarTheme,
    BottomNavigationBarThemeData? bottomNavigationBarTheme,
    BottomSheetThemeData? bottomSheetTheme,
    ButtonThemeData? buttonTheme,
    // TODO(QuncCccccc): Change the parameter type to CardThemeData
    Object? cardTheme,
    CheckboxThemeData? checkboxTheme,
    ChipThemeData? chipTheme,
    DataTableThemeData? dataTableTheme,
    DatePickerThemeData? datePickerTheme,
    // TODO(QuncCccccc): Change the parameter type to DialogThemeData
    Object? dialogTheme,
    DividerThemeData? dividerTheme,
    DrawerThemeData? drawerTheme,
    DropdownMenuThemeData? dropdownMenuTheme,
    ElevatedButtonThemeData? elevatedButtonTheme,
    ExpansionTileThemeData? expansionTileTheme,
    FilledButtonThemeData? filledButtonTheme,
    FloatingActionButtonThemeData? floatingActionButtonTheme,
    IconButtonThemeData? iconButtonTheme,
    ListTileThemeData? listTileTheme,
    MenuBarThemeData? menuBarTheme,
    MenuButtonThemeData? menuButtonTheme,
    MenuThemeData? menuTheme,
    NavigationBarThemeData? navigationBarTheme,
    NavigationDrawerThemeData? navigationDrawerTheme,
    NavigationRailThemeData? navigationRailTheme,
    OutlinedButtonThemeData? outlinedButtonTheme,
    PopupMenuThemeData? popupMenuTheme,
    ProgressIndicatorThemeData? progressIndicatorTheme,
    RadioThemeData? radioTheme,
    SearchBarThemeData? searchBarTheme,
    SearchViewThemeData? searchViewTheme,
    SegmentedButtonThemeData? segmentedButtonTheme,
    SliderThemeData? sliderTheme,
    SnackBarThemeData? snackBarTheme,
    SwitchThemeData? switchTheme,
    // TODO(QuncCccccc): Change the parameter type to TabBarThemeData
    Object? tabBarTheme,
    TextButtonThemeData? textButtonTheme,
    TextSelectionThemeData? textSelectionTheme,
    TimePickerThemeData? timePickerTheme,
    ToggleButtonsThemeData? toggleButtonsTheme,
    TooltipThemeData? tooltipTheme,
    // DEPRECATED (newest deprecations at the bottom)
    @Deprecated(
      'Use OverflowBar instead. '
      'This feature was deprecated after v3.21.0-10.0.pre.',
    )
    ButtonBarThemeData? buttonBarTheme,
    @Deprecated(
      'Use DialogThemeData.backgroundColor instead. '
      'This feature was deprecated after v3.27.0-0.1.pre.',
    )
    Color? dialogBackgroundColor,
  }) {
    // GENERAL CONFIGURATION
    cupertinoOverrideTheme = cupertinoOverrideTheme?.noDefault();
    extensions ??= <ThemeExtension<dynamic>>[];
    adaptations ??= <Adaptation<Object>>[];
    inputDecorationTheme ??= const InputDecorationTheme();
    platform ??= defaultTargetPlatform;
    switch (platform) {
      case TargetPlatform.android:
      case TargetPlatform.fuchsia:
      case TargetPlatform.iOS:
        materialTapTargetSize ??= MaterialTapTargetSize.padded;
      case TargetPlatform.linux:
      case TargetPlatform.macOS:
      case TargetPlatform.windows:
        materialTapTargetSize ??= MaterialTapTargetSize.shrinkWrap;
    }
    pageTransitionsTheme ??= const PageTransitionsTheme();
    scrollbarTheme ??= const ScrollbarThemeData();
    visualDensity ??= VisualDensity.defaultDensityForPlatform(platform);
    useMaterial3 ??= true;
    final bool useInkSparkle = platform == TargetPlatform.android && !kIsWeb;
    splashFactory ??=
        useMaterial3
            ? useInkSparkle
                ? InkSparkle.splashFactory
                : InkRipple.splashFactory
            : InkSplash.splashFactory;

    // COLOR
    assert(
      colorScheme?.brightness == null ||
          brightness == null ||
          colorScheme!.brightness == brightness,
      'ThemeData.brightness does not match ColorScheme.brightness. '
      'Either override ColorScheme.brightness or ThemeData.brightness to '
      'match the other.',
    );
    assert(colorSchemeSeed == null || colorScheme == null);
    assert(colorSchemeSeed == null || primarySwatch == null);
    assert(colorSchemeSeed == null || primaryColor == null);
    final Brightness effectiveBrightness =
        brightness ?? colorScheme?.brightness ?? Brightness.light;
    final bool isDark = effectiveBrightness == Brightness.dark;
    if (colorSchemeSeed != null || useMaterial3) {
      if (colorSchemeSeed != null) {
        colorScheme = ColorScheme.fromSeed(
          seedColor: colorSchemeSeed,
          brightness: effectiveBrightness,
        );
      }
      colorScheme ??= isDark ? _colorSchemeDarkM3 : _colorSchemeLightM3;

      // For surfaces that use primary color in light themes and surface color in dark
      final Color primarySurfaceColor = isDark ? colorScheme.surface : colorScheme.primary;
      final Color onPrimarySurfaceColor = isDark ? colorScheme.onSurface : colorScheme.onPrimary;

      // Default some of the color settings to values from the color scheme
      primaryColor ??= primarySurfaceColor;
      canvasColor ??= colorScheme.surface;
      scaffoldBackgroundColor ??= colorScheme.surface;
      cardColor ??= colorScheme.surface;
      dividerColor ??= colorScheme.outline;
      dialogBackgroundColor ??= colorScheme.surface;
      indicatorColor ??= onPrimarySurfaceColor;
      applyElevationOverlayColor ??= brightness == Brightness.dark;
    }
    applyElevationOverlayColor ??= false;
    primarySwatch ??= Colors.blue;
    primaryColor ??= isDark ? Colors.grey[900]! : primarySwatch;
    final Brightness estimatedPrimaryColorBrightness = estimateBrightnessForColor(primaryColor);
    primaryColorLight ??= isDark ? Colors.grey[500]! : primarySwatch[100]!;
    primaryColorDark ??= isDark ? Colors.black : primarySwatch[700]!;
    final bool primaryIsDark = estimatedPrimaryColorBrightness == Brightness.dark;
    focusColor ??= isDark ? Colors.white.withOpacity(0.12) : Colors.black.withOpacity(0.12);
    hoverColor ??= isDark ? Colors.white.withOpacity(0.04) : Colors.black.withOpacity(0.04);
    shadowColor ??= Colors.black;
    canvasColor ??= isDark ? Colors.grey[850]! : Colors.grey[50]!;
    scaffoldBackgroundColor ??= canvasColor;
    cardColor ??= isDark ? Colors.grey[800]! : Colors.white;
    dividerColor ??= isDark ? const Color(0x1FFFFFFF) : const Color(0x1F000000);
    // Create a ColorScheme that is backwards compatible as possible
    // with the existing default ThemeData color values.
    colorScheme ??= ColorScheme.fromSwatch(
      primarySwatch: primarySwatch,
      accentColor: isDark ? Colors.tealAccent[200]! : primarySwatch[500]!,
      cardColor: cardColor,
      backgroundColor: isDark ? Colors.grey[700]! : primarySwatch[200]!,
      errorColor: Colors.red[700],
      brightness: effectiveBrightness,
    );
    unselectedWidgetColor ??= isDark ? Colors.white70 : Colors.black54;
    // Spec doesn't specify a dark theme secondaryHeaderColor, this is a guess.
    secondaryHeaderColor ??= isDark ? Colors.grey[700]! : primarySwatch[50]!;
    indicatorColor ??= colorScheme.secondary == primaryColor ? Colors.white : colorScheme.secondary;
    hintColor ??= isDark ? Colors.white60 : Colors.black.withOpacity(0.6);
    // The default [buttonTheme] is here because it doesn't use the defaults for
    // [disabledColor], [highlightColor], and [splashColor].
    buttonTheme ??= ButtonThemeData(
      colorScheme: colorScheme,
      buttonColor: isDark ? primarySwatch[600]! : Colors.grey[300]!,
      disabledColor: disabledColor,
      focusColor: focusColor,
      hoverColor: hoverColor,
      highlightColor: highlightColor,
      splashColor: splashColor,
      materialTapTargetSize: materialTapTargetSize,
    );
    disabledColor ??= isDark ? Colors.white38 : Colors.black38;
    highlightColor ??= isDark ? const Color(0x40CCCCCC) : const Color(0x66BCBCBC);
    splashColor ??= isDark ? const Color(0x40CCCCCC) : const Color(0x66C8C8C8);

    // TYPOGRAPHY & ICONOGRAPHY
    typography ??=
        useMaterial3
            ? Typography.material2021(platform: platform, colorScheme: colorScheme)
            : Typography.material2014(platform: platform);
    TextTheme defaultTextTheme = isDark ? typography.white : typography.black;
    TextTheme defaultPrimaryTextTheme = primaryIsDark ? typography.white : typography.black;
    if (fontFamily != null) {
      defaultTextTheme = defaultTextTheme.apply(fontFamily: fontFamily);
      defaultPrimaryTextTheme = defaultPrimaryTextTheme.apply(fontFamily: fontFamily);
    }
    if (fontFamilyFallback != null) {
      defaultTextTheme = defaultTextTheme.apply(fontFamilyFallback: fontFamilyFallback);
      defaultPrimaryTextTheme = defaultPrimaryTextTheme.apply(
        fontFamilyFallback: fontFamilyFallback,
      );
    }
    if (package != null) {
      defaultTextTheme = defaultTextTheme.apply(package: package);
      defaultPrimaryTextTheme = defaultPrimaryTextTheme.apply(package: package);
    }
    textTheme = defaultTextTheme.merge(textTheme);
    primaryTextTheme = defaultPrimaryTextTheme.merge(primaryTextTheme);
    iconTheme ??=
        isDark
            ? IconThemeData(color: kDefaultIconLightColor)
            : IconThemeData(color: kDefaultIconDarkColor);
    primaryIconTheme ??=
        primaryIsDark
            ? const IconThemeData(color: Colors.white)
            : const IconThemeData(color: Colors.black);

    // COMPONENT THEMES
    appBarTheme ??= const AppBarTheme();
    badgeTheme ??= const BadgeThemeData();
    bannerTheme ??= const MaterialBannerThemeData();
    bottomAppBarTheme ??= const BottomAppBarTheme();
    bottomNavigationBarTheme ??= const BottomNavigationBarThemeData();
    bottomSheetTheme ??= const BottomSheetThemeData();
    // TODO(QuncCccccc): Clean it up once the type of `cardTheme` is changed to `CardThemeData`
    if (cardTheme != null) {
      if (cardTheme is CardTheme) {
        cardTheme = cardTheme.data;
      } else if (cardTheme is! CardThemeData) {
        throw ArgumentError('cardTheme must be either a CardThemeData or a CardTheme');
      }
    }
    cardTheme ??= const CardThemeData();
    checkboxTheme ??= const CheckboxThemeData();
    chipTheme ??= const ChipThemeData();
    dataTableTheme ??= const DataTableThemeData();
    datePickerTheme ??= const DatePickerThemeData();
    // TODO(QuncCccccc): Clean this up once the type of `dialogTheme` is changed to `DialogThemeData`
    if (dialogTheme != null) {
      if (dialogTheme is DialogTheme) {
        dialogTheme = dialogTheme.data;
      } else if (dialogTheme is! DialogThemeData) {
        throw ArgumentError('dialogTheme must be either a DialogThemeData or a DialogTheme');
      }
    }
    dialogTheme ??= const DialogThemeData();
    dividerTheme ??= const DividerThemeData();
    drawerTheme ??= const DrawerThemeData();
    dropdownMenuTheme ??= const DropdownMenuThemeData();
    elevatedButtonTheme ??= const ElevatedButtonThemeData();
    expansionTileTheme ??= const ExpansionTileThemeData();
    filledButtonTheme ??= const FilledButtonThemeData();
    floatingActionButtonTheme ??= const FloatingActionButtonThemeData();
    iconButtonTheme ??= const IconButtonThemeData();
    listTileTheme ??= const ListTileThemeData();
    menuBarTheme ??= const MenuBarThemeData();
    menuButtonTheme ??= const MenuButtonThemeData();
    menuTheme ??= const MenuThemeData();
    navigationBarTheme ??= const NavigationBarThemeData();
    navigationDrawerTheme ??= const NavigationDrawerThemeData();
    navigationRailTheme ??= const NavigationRailThemeData();
    outlinedButtonTheme ??= const OutlinedButtonThemeData();
    popupMenuTheme ??= const PopupMenuThemeData();
    progressIndicatorTheme ??= const ProgressIndicatorThemeData();
    radioTheme ??= const RadioThemeData();
    searchBarTheme ??= const SearchBarThemeData();
    searchViewTheme ??= const SearchViewThemeData();
    segmentedButtonTheme ??= const SegmentedButtonThemeData();
    sliderTheme ??= const SliderThemeData();
    snackBarTheme ??= const SnackBarThemeData();
    switchTheme ??= const SwitchThemeData();
    // TODO(QuncCccccc): Clean this up once the type of `tabBarTheme` is changed to `TabBarThemeData`
    if (tabBarTheme != null) {
      if (tabBarTheme is TabBarTheme) {
        tabBarTheme = tabBarTheme.data;
      } else if (tabBarTheme is! TabBarThemeData) {
        throw ArgumentError('tabBarTheme must be either a TabBarThemeData or a TabBarTheme');
      }
    }
    tabBarTheme ??= const TabBarThemeData();
    textButtonTheme ??= const TextButtonThemeData();
    textSelectionTheme ??= const TextSelectionThemeData();
    timePickerTheme ??= const TimePickerThemeData();
    toggleButtonsTheme ??= const ToggleButtonsThemeData();
    tooltipTheme ??= const TooltipThemeData();
    // DEPRECATED (newest deprecations at the bottom)
    buttonBarTheme ??= const ButtonBarThemeData();
    dialogBackgroundColor ??= isDark ? Colors.grey[800]! : Colors.white;
    return ThemeData.raw(
      // For the sanity of the reader, make sure these properties are in the same
      // order in every place that they are separated by section comments (e.g.
      // GENERAL CONFIGURATION). Each section except for deprecations should be
      // alphabetical by symbol name.

      // GENERAL CONFIGURATION
      adaptationMap: _createAdaptationMap(adaptations),
      applyElevationOverlayColor: applyElevationOverlayColor,
      cupertinoOverrideTheme: cupertinoOverrideTheme,
      extensions: _themeExtensionIterableToMap(extensions),
      inputDecorationTheme: inputDecorationTheme,
      materialTapTargetSize: materialTapTargetSize,
      pageTransitionsTheme: pageTransitionsTheme,
      platform: platform,
      scrollbarTheme: scrollbarTheme,
      splashFactory: splashFactory,
      useMaterial3: useMaterial3,
      visualDensity: visualDensity,
      // COLOR
      canvasColor: canvasColor,
      cardColor: cardColor,
      colorScheme: colorScheme,
      disabledColor: disabledColor,
      dividerColor: dividerColor,
      focusColor: focusColor,
      highlightColor: highlightColor,
      hintColor: hintColor,
      hoverColor: hoverColor,
      indicatorColor: indicatorColor,
      primaryColor: primaryColor,
      primaryColorDark: primaryColorDark,
      primaryColorLight: primaryColorLight,
      scaffoldBackgroundColor: scaffoldBackgroundColor,
      secondaryHeaderColor: secondaryHeaderColor,
      shadowColor: shadowColor,
      splashColor: splashColor,
      unselectedWidgetColor: unselectedWidgetColor,
      // TYPOGRAPHY & ICONOGRAPHY
      iconTheme: iconTheme,
      primaryTextTheme: primaryTextTheme,
      textTheme: textTheme,
      typography: typography,
      primaryIconTheme: primaryIconTheme,
      // COMPONENT THEMES
      actionIconTheme: actionIconTheme,
      appBarTheme: appBarTheme,
      badgeTheme: badgeTheme,
      bannerTheme: bannerTheme,
      bottomAppBarTheme: bottomAppBarTheme,
      bottomNavigationBarTheme: bottomNavigationBarTheme,
      bottomSheetTheme: bottomSheetTheme,
      buttonTheme: buttonTheme,
      cardTheme: cardTheme as CardThemeData,
      checkboxTheme: checkboxTheme,
      chipTheme: chipTheme,
      dataTableTheme: dataTableTheme,
      datePickerTheme: datePickerTheme,
      dialogTheme: dialogTheme as DialogThemeData,
      dividerTheme: dividerTheme,
      drawerTheme: drawerTheme,
      dropdownMenuTheme: dropdownMenuTheme,
      elevatedButtonTheme: elevatedButtonTheme,
      expansionTileTheme: expansionTileTheme,
      filledButtonTheme: filledButtonTheme,
      floatingActionButtonTheme: floatingActionButtonTheme,
      iconButtonTheme: iconButtonTheme,
      listTileTheme: listTileTheme,
      menuBarTheme: menuBarTheme,
      menuButtonTheme: menuButtonTheme,
      menuTheme: menuTheme,
      navigationBarTheme: navigationBarTheme,
      navigationDrawerTheme: navigationDrawerTheme,
      navigationRailTheme: navigationRailTheme,
      outlinedButtonTheme: outlinedButtonTheme,
      popupMenuTheme: popupMenuTheme,
      progressIndicatorTheme: progressIndicatorTheme,
      radioTheme: radioTheme,
      searchBarTheme: searchBarTheme,
      searchViewTheme: searchViewTheme,
      segmentedButtonTheme: segmentedButtonTheme,
      sliderTheme: sliderTheme,
      snackBarTheme: snackBarTheme,
      switchTheme: switchTheme,
      tabBarTheme: tabBarTheme as TabBarThemeData,
      textButtonTheme: textButtonTheme,
      textSelectionTheme: textSelectionTheme,
      timePickerTheme: timePickerTheme,
      toggleButtonsTheme: toggleButtonsTheme,
      tooltipTheme: tooltipTheme,
      // DEPRECATED (newest deprecations at the bottom)
      buttonBarTheme: buttonBarTheme,
      dialogBackgroundColor: dialogBackgroundColor,
    );
  }

  /// Create a [ThemeData] given a set of exact values. Most values must be
  /// specified. They all must also be non-null except for
  /// [cupertinoOverrideTheme], and deprecated members.
  ///
  /// This will rarely be used directly. It is used by [lerp] to
  /// create intermediate themes based on two themes created with the
  /// [ThemeData] constructor.
  const ThemeData.raw({
    // For the sanity of the reader, make sure these properties are in the same
    // order in every place that they are separated by section comments (e.g.
    // GENERAL CONFIGURATION). Each section except for deprecations should be
    // alphabetical by symbol name.

    // GENERAL CONFIGURATION
    required this.adaptationMap,
    required this.applyElevationOverlayColor,
    required this.cupertinoOverrideTheme,
    required this.extensions,
    required this.inputDecorationTheme,
    required this.materialTapTargetSize,
    required this.pageTransitionsTheme,
    required this.platform,
    required this.scrollbarTheme,
    required this.splashFactory,
    required this.useMaterial3,
    required this.visualDensity,
    // COLOR
    required this.colorScheme,
    // [colorScheme] is the preferred way to configure colors. The [Color] properties
    // listed below (as well as primarySwatch) will gradually be phased out, see
    // https://github.com/flutter/flutter/issues/91772.
    required this.canvasColor,
    required this.cardColor,
    required this.disabledColor,
    required this.dividerColor,
    required this.focusColor,
    required this.highlightColor,
    required this.hintColor,
    required this.hoverColor,
    required this.indicatorColor,
    required this.primaryColor,
    required this.primaryColorDark,
    required this.primaryColorLight,
    required this.scaffoldBackgroundColor,
    required this.secondaryHeaderColor,
    required this.shadowColor,
    required this.splashColor,
    required this.unselectedWidgetColor,
    // TYPOGRAPHY & ICONOGRAPHY
    required this.iconTheme,
    required this.primaryIconTheme,
    required this.primaryTextTheme,
    required this.textTheme,
    required this.typography,
    // COMPONENT THEMES
    required this.actionIconTheme,
    required this.appBarTheme,
    required this.badgeTheme,
    required this.bannerTheme,
    required this.bottomAppBarTheme,
    required this.bottomNavigationBarTheme,
    required this.bottomSheetTheme,
    required this.buttonTheme,
    required this.cardTheme,
    required this.checkboxTheme,
    required this.chipTheme,
    required this.dataTableTheme,
    required this.datePickerTheme,
    required this.dialogTheme,
    required this.dividerTheme,
    required this.drawerTheme,
    required this.dropdownMenuTheme,
    required this.elevatedButtonTheme,
    required this.expansionTileTheme,
    required this.filledButtonTheme,
    required this.floatingActionButtonTheme,
    required this.iconButtonTheme,
    required this.listTileTheme,
    required this.menuBarTheme,
    required this.menuButtonTheme,
    required this.menuTheme,
    required this.navigationBarTheme,
    required this.navigationDrawerTheme,
    required this.navigationRailTheme,
    required this.outlinedButtonTheme,
    required this.popupMenuTheme,
    required this.progressIndicatorTheme,
    required this.radioTheme,
    required this.searchBarTheme,
    required this.searchViewTheme,
    required this.segmentedButtonTheme,
    required this.sliderTheme,
    required this.snackBarTheme,
    required this.switchTheme,
    required this.tabBarTheme,
    required this.textButtonTheme,
    required this.textSelectionTheme,
    required this.timePickerTheme,
    required this.toggleButtonsTheme,
    required this.tooltipTheme,
    // DEPRECATED (newest deprecations at the bottom)
    @Deprecated(
      'Use OverflowBar instead. '
      'This feature was deprecated after v3.21.0-10.0.pre.',
    )
    ButtonBarThemeData? buttonBarTheme,
    @Deprecated(
      'Use DialogThemeData.backgroundColor instead. '
      'This feature was deprecated after v3.27.0-0.1.pre.',
    )
    required this.dialogBackgroundColor,
  }) : // DEPRECATED (newest deprecations at the bottom)
       // should not be `required`, use getter pattern to avoid breakages.
       _buttonBarTheme = buttonBarTheme,
       assert(buttonBarTheme != null);

  /// Create a [ThemeData] based on the colors in the given [colorScheme] and
  /// text styles of the optional [textTheme].
  ///
  /// If [colorScheme].brightness is [Brightness.dark] then
  /// [ThemeData.applyElevationOverlayColor] will be set to true to support
  /// the Material dark theme method for indicating elevation by applying
  /// a semi-transparent onSurface color on top of the surface color.
  ///
  /// This is the recommended method to theme your application. As we move
  /// forward we will be converting all the widget implementations to only use
  /// colors or colors derived from those in [ColorScheme].
  ///
  /// {@tool snippet}
  /// This example will set up an application to use the baseline Material
  /// Design light and dark themes.
  ///
  /// ```dart
  /// MaterialApp(
  ///   theme: ThemeData.from(colorScheme: const ColorScheme.light()),
  ///   darkTheme: ThemeData.from(colorScheme: const ColorScheme.dark()),
  /// )
  /// ```
  /// {@end-tool}
  ///
  /// See <https://material.io/design/color/> for
  /// more discussion on how to pick the right colors.
  factory ThemeData.from({
    required ColorScheme colorScheme,
    TextTheme? textTheme,
    bool? useMaterial3,
  }) {
    final bool isDark = colorScheme.brightness == Brightness.dark;

    // For surfaces that use primary color in light themes and surface color in dark
    final Color primarySurfaceColor = isDark ? colorScheme.surface : colorScheme.primary;
    final Color onPrimarySurfaceColor = isDark ? colorScheme.onSurface : colorScheme.onPrimary;

    return ThemeData(
      colorScheme: colorScheme,
      brightness: colorScheme.brightness,
      primaryColor: primarySurfaceColor,
      canvasColor: colorScheme.surface,
      scaffoldBackgroundColor: colorScheme.surface,
      cardColor: colorScheme.surface,
      dividerColor: colorScheme.onSurface.withOpacity(0.12),
      dialogBackgroundColor: colorScheme.surface,
      indicatorColor: onPrimarySurfaceColor,
      textTheme: textTheme,
      applyElevationOverlayColor: isDark,
      useMaterial3: useMaterial3,
    );
  }

  /// A default light theme.
  ///
  /// This theme does not contain text geometry. Instead, it is expected that
  /// this theme is localized using text geometry using [ThemeData.localize].
  factory ThemeData.light({bool? useMaterial3}) =>
      ThemeData(brightness: Brightness.light, useMaterial3: useMaterial3);

  /// A default dark theme.
  ///
  /// This theme does not contain text geometry. Instead, it is expected that
  /// this theme is localized using text geometry using [ThemeData.localize].
  factory ThemeData.dark({bool? useMaterial3}) =>
      ThemeData(brightness: Brightness.dark, useMaterial3: useMaterial3);

  /// The default color theme. Same as [ThemeData.light].
  ///
  /// This is used by [Theme.of] when no theme has been specified.
  ///
  /// This theme does not contain text geometry. Instead, it is expected that
  /// this theme is localized using text geometry using [ThemeData.localize].
  ///
  /// Most applications would use [Theme.of], which provides correct localized
  /// text geometry.
  factory ThemeData.fallback({bool? useMaterial3}) => ThemeData.light(useMaterial3: useMaterial3);

  /// Used to obtain a particular [Adaptation] from [adaptationMap].
  ///
  /// To get an adaptation, use `Theme.of(context).getAdaptation<MyAdaptation>()`.
  Adaptation<T>? getAdaptation<T>() => adaptationMap[T] as Adaptation<T>?;

  static Map<Type, Adaptation<Object>> _createAdaptationMap(
    Iterable<Adaptation<Object>> adaptations,
  ) {
    final Map<Type, Adaptation<Object>> adaptationMap = <Type, Adaptation<Object>>{
      for (final Adaptation<Object> adaptation in adaptations) adaptation.type: adaptation,
    };
    return adaptationMap;
  }

  /// The overall theme brightness.
  ///
  /// The default [TextStyle] color for the [textTheme] is black if the
  /// theme is constructed with [Brightness.light] and white if the
  /// theme is constructed with [Brightness.dark].
  Brightness get brightness => colorScheme.brightness;

  // For the sanity of the reader, make sure these properties are in the same
  // order in every place that they are separated by section comments (e.g.
  // GENERAL CONFIGURATION). Each section except for deprecations should be
  // alphabetical by symbol name.

  // GENERAL CONFIGURATION

  /// Apply a semi-transparent overlay color on Material surfaces to indicate
  /// elevation for dark themes.
  ///
  /// If [useMaterial3] is true, then this flag is ignored as there is a new
  /// [Material.surfaceTintColor] used to create an overlay for Material 3.
  /// This flag is meant only for the Material 2 elevation overlay for dark
  /// themes.
  ///
  /// Material drop shadows can be difficult to see in a dark theme, so the
  /// elevation of a surface should be portrayed with an "overlay" in addition
  /// to the shadow. As the elevation of the component increases, the
  /// overlay increases in opacity. [applyElevationOverlayColor] turns the
  /// application of this overlay on or off for dark themes.
  ///
  /// If true and [brightness] is [Brightness.dark], a
  /// semi-transparent version of [ColorScheme.onSurface] will be
  /// applied on top of [Material] widgets that have a [ColorScheme.surface]
  /// color. The level of transparency is based on [Material.elevation] as
  /// per the Material Dark theme specification.
  ///
  /// If false the surface color will be used unmodified.
  ///
  /// Defaults to false in order to maintain backwards compatibility with
  /// apps that were built before the Material Dark theme specification
  /// was published. New apps should set this to true for any themes
  /// where [brightness] is [Brightness.dark].
  ///
  /// See also:
  ///
  ///  * [Material.elevation], which effects the level of transparency of the
  ///    overlay color.
  ///  * [ElevationOverlay.applyOverlay], which is used by [Material] to apply
  ///    the overlay color to its surface color.
  ///  * <https://material.io/design/color/dark-theme.html>, which specifies how
  ///    the overlay should be applied.
  final bool applyElevationOverlayColor;

  /// Components of the [CupertinoThemeData] to override from the Material
  /// [ThemeData] adaptation.
  ///
  /// By default, [cupertinoOverrideTheme] is null and Cupertino widgets
  /// descendant to the Material [Theme] will adhere to a [CupertinoTheme]
  /// derived from the Material [ThemeData]. e.g. [ThemeData]'s [ColorScheme]
  /// will also inform the [CupertinoThemeData]'s `primaryColor` etc.
  ///
  /// This cascading effect for individual attributes of the [CupertinoThemeData]
  /// can be overridden using attributes of this [cupertinoOverrideTheme].
  final NoDefaultCupertinoThemeData? cupertinoOverrideTheme;

  /// Arbitrary additions to this theme.
  ///
  /// To define extensions, pass an [Iterable] containing one or more [ThemeExtension]
  /// subclasses to [ThemeData.new] or [copyWith].
  ///
  /// To obtain an extension, use [extension].
  ///
  /// {@tool dartpad}
  /// This sample shows how to create and use a subclass of [ThemeExtension] that
  /// defines two colors.
  ///
  /// ** See code in examples/api/lib/material/theme/theme_extension.1.dart **
  /// {@end-tool}
  ///
  /// See also:
  ///
  /// * [extension], a convenience function for obtaining a specific extension.
  final Map<Object, ThemeExtension<dynamic>> extensions;

  /// Used to obtain a particular [ThemeExtension] from [extensions].
  ///
  /// Obtain with `Theme.of(context).extension<MyThemeExtension>()`.
  ///
  /// See [extensions] for an interactive example.
  T? extension<T>() => extensions[T] as T?;

  /// A map which contains the adaptations for the theme. The entry's key is the
  /// type of the adaptation; the value is the adaptation itself.
  ///
  /// To obtain an adaptation, use [getAdaptation].
  final Map<Type, Adaptation<Object>> adaptationMap;

  /// The default [InputDecoration] values for [InputDecorator], [TextField],
  /// and [TextFormField] are based on this theme.
  ///
  /// See [InputDecoration.applyDefaults].
  final InputDecorationTheme inputDecorationTheme;

  /// Configures the hit test size of certain Material widgets.
  ///
  /// Defaults to a [platform]-appropriate size: [MaterialTapTargetSize.padded]
  /// on mobile platforms, [MaterialTapTargetSize.shrinkWrap] on desktop
  /// platforms.
  final MaterialTapTargetSize materialTapTargetSize;

  /// Default [MaterialPageRoute] transitions per [TargetPlatform].
  ///
  /// [MaterialPageRoute.buildTransitions] delegates to a [platform] specific
  /// [PageTransitionsBuilder]. If a matching builder is not found, a builder
  /// whose platform is null is used.
  final PageTransitionsTheme pageTransitionsTheme;

  /// The platform the material widgets should adapt to target.
  ///
  /// Defaults to the current platform, as exposed by [defaultTargetPlatform].
  /// This should be used in order to style UI elements according to platform
  /// conventions.
  ///
  /// Widgets from the material library should use this getter (via [Theme.of])
  /// to determine the current platform for the purpose of emulating the
  /// platform behavior (e.g. scrolling or haptic effects). Widgets and render
  /// objects at lower layers that try to emulate the underlying platform
  /// can depend on [defaultTargetPlatform] directly, or may require
  /// that the target platform be provided as an argument. The
  /// [dart:io.Platform] object should only be used directly when it's critical
  /// to actually know the current platform, without any overrides possible (for
  /// example, when a system API is about to be called).
  ///
  /// In a test environment, the platform returned is [TargetPlatform.android]
  /// regardless of the host platform. (Android was chosen because the tests
  /// were originally written assuming Android-like behavior, and we added
  /// platform adaptations for other platforms later). Tests can check behavior
  /// for other platforms by setting the [platform] of the [Theme] explicitly to
  /// another [TargetPlatform] value, or by setting
  /// [debugDefaultTargetPlatformOverride].
  ///
  /// Determines the defaults for [typography] and [materialTapTargetSize].
  final TargetPlatform platform;

  /// A theme for customizing the colors, thickness, and shape of [Scrollbar]s.
  final ScrollbarThemeData scrollbarTheme;

  /// Defines the appearance of ink splashes produces by [InkWell]
  /// and [InkResponse].
  ///
  /// See also:
  ///
  ///  * [InkSplash.splashFactory], which defines the default splash.
  ///  * [InkRipple.splashFactory], which defines a splash that spreads out
  ///    more aggressively than the default.
  ///  * [InkSparkle.splashFactory], which defines a more aggressive and organic
  ///    splash with sparkle effects.
  final InteractiveInkFeatureFactory splashFactory;

  /// A temporary flag that can be used to opt-out of Material 3 features.
  ///
  /// This flag is _true_ by default. If false, then components will
  /// continue to use the colors, typography and other features of
  /// Material 2.
  ///
  /// In the long run this flag will be deprecated and eventually
  /// only Material 3 will be supported. We recommend that applications
  /// migrate to Material 3 as soon as that's practical. Until that migration
  /// is complete, this flag can be set to false.
  ///
  /// ## Defaults
  ///
  /// If a [ThemeData] is _constructed_ with [useMaterial3] set to true, then
  /// some properties will get updated defaults. However, the
  /// [ThemeData.copyWith] method with [useMaterial3] set to true will _not_
  /// change any of these properties in the resulting [ThemeData].
  ///
  /// <style>table,td,th { border-collapse: collapse; padding: 0.45em; } td { border: 1px solid }</style>
  ///
  /// | Property        | Material 3 default             | Material 2 default             |
  /// | :-------------- | :----------------------------- | :----------------------------- |
  /// | [colorScheme]   | M3 baseline light color scheme | M2 baseline light color scheme |
  /// | [typography]    | [Typography.material2021]      | [Typography.material2014]      |
  /// | [splashFactory] | [InkSparkle]* or [InkRipple]   | [InkSplash]                    |
  ///
  /// \* if the target platform is Android and the app is not
  /// running on the web, otherwise it will fallback to [InkRipple].
  ///
  /// If [brightness] is [Brightness.dark] then the default color scheme will
  /// be either the M3 baseline dark color scheme or the M2 baseline dark color
  /// scheme depending on [useMaterial3].
  ///
  /// ## Affected widgets
  ///
  /// This flag affects styles and components.
  ///
  /// ### Styles
  ///   * Color: [ColorScheme], [Material] (see table above)
  ///   * Shape: (see components below)
  ///   * Typography: [Typography] (see table above)
  ///
  /// ### Components
  ///   * Badges: [Badge]
  ///   * Bottom app bar: [BottomAppBar]
  ///   * Bottom sheets: [BottomSheet]
  ///   * Buttons
  ///     - Common buttons: [ElevatedButton], [FilledButton], [FilledButton.tonal], [OutlinedButton], [TextButton]
  ///     - FAB: [FloatingActionButton], [FloatingActionButton.extended]
  ///     - Icon buttons: [IconButton], [IconButton.filled] (*new*), [IconButton.filledTonal], [IconButton.outlined]
  ///     - Segmented buttons: [SegmentedButton] (replacing [ToggleButtons])
  ///   * Cards: [Card]
  ///   * Checkbox: [Checkbox], [CheckboxListTile]
  ///   * Chips:
  ///     - [ActionChip] (used for Assist and Suggestion chips),
  ///     - [FilterChip], [ChoiceChip] (used for single selection filter chips),
  ///     - [InputChip]
  ///   * Date pickers: [showDatePicker], [showDateRangePicker], [DatePickerDialog], [DateRangePickerDialog], [InputDatePickerFormField]
  ///   * Dialogs: [AlertDialog], [Dialog.fullscreen]
  ///   * Divider: [Divider], [VerticalDivider]
  ///   * Lists: [ListTile]
  ///   * Menus: [MenuAnchor], [DropdownMenu], [MenuBar]
  ///   * Navigation bar: [NavigationBar] (replacing [BottomNavigationBar])
  ///   * Navigation drawer: [NavigationDrawer] (replacing [Drawer])
  ///   * Navigation rail: [NavigationRail]
  ///   * Progress indicators: [CircularProgressIndicator], [LinearProgressIndicator]
  ///   * Radio button: [Radio], [RadioListTile]
  ///   * Search: [SearchBar], [SearchAnchor],
  ///   * Snack bar: [SnackBar]
  ///   * Slider: [Slider], [RangeSlider]
  ///   * Switch: [Switch], [SwitchListTile]
  ///   * Tabs: [TabBar], [TabBar.secondary]
  ///   * TextFields: [TextField] together with its [InputDecoration]
  ///   * Time pickers: [showTimePicker], [TimePickerDialog]
  ///   * Top app bar: [AppBar], [SliverAppBar], [SliverAppBar.medium], [SliverAppBar.large]
  ///
  /// In addition, this flag enables features introduced in Android 12.
  ///   * Stretch overscroll: [MaterialScrollBehavior]
  ///   * Ripple: `splashFactory` (see table above)
  ///
  /// See also:
  ///
  ///   * [Material 3 specification](https://m3.material.io/).
  final bool useMaterial3;

  /// The density value for specifying the compactness of various UI components.
  ///
  /// {@template flutter.material.themedata.visualDensity}
  /// Density, in the context of a UI, is the vertical and horizontal
  /// "compactness" of the elements in the UI. It is unitless, since it means
  /// different things to different UI elements. For buttons, it affects the
  /// spacing around the centered label of the button. For lists, it affects the
  /// distance between baselines of entries in the list.
  ///
  /// Typically, density values are integral, but any value in range may be
  /// used. The range includes values from [VisualDensity.minimumDensity] (which
  /// is -4), to [VisualDensity.maximumDensity] (which is 4), inclusive, where
  /// negative values indicate a denser, more compact, UI, and positive values
  /// indicate a less dense, more expanded, UI. If a component doesn't support
  /// the value given, it will clamp to the nearest supported value.
  ///
  /// The default for visual densities is zero for both vertical and horizontal
  /// densities, which corresponds to the default visual density of components
  /// in the Material Design specification.
  ///
  /// As a rule of thumb, a change of 1 or -1 in density corresponds to 4
  /// logical pixels. However, this is not a strict relationship since
  /// components interpret the density values appropriately for their needs.
  ///
  /// A larger value translates to a spacing increase (less dense), and a
  /// smaller value translates to a spacing decrease (more dense).
  ///
  /// In Material Design 3, the [visualDensity] does not override the value of
  /// [IconButton.visualDensity] which defaults to [VisualDensity.standard]
  /// for all platforms. To override the default value of [IconButton.visualDensity],
  /// use [ThemeData.iconButtonTheme] instead.
  /// {@endtemplate}
  final VisualDensity visualDensity;

  // COLOR

  /// The default color of [MaterialType.canvas] [Material].
  final Color canvasColor;

  /// The color of [Material] when it is used as a [Card].
  final Color cardColor;

  /// {@macro flutter.material.color_scheme.ColorScheme}
  ///
  /// This property was added much later than the theme's set of highly specific
  /// colors, like [cardColor], [canvasColor] etc. New components can be defined
  /// exclusively in terms of [colorScheme]. Existing components will gradually
  /// migrate to it, to the extent that is possible without significant
  /// backwards compatibility breaks.
  final ColorScheme colorScheme;

  /// The color used for widgets that are inoperative, regardless of
  /// their state. For example, a disabled checkbox (which may be
  /// checked or unchecked).
  final Color disabledColor;

  /// The color of [Divider]s and [PopupMenuDivider]s, also used
  /// between [ListTile]s, between rows in [DataTable]s, and so forth.
  ///
  /// To create an appropriate [BorderSide] that uses this color, consider
  /// [Divider.createBorderSide].
  final Color dividerColor;

  /// The focus color used indicate that a component has the input focus.
  final Color focusColor;

  /// The highlight color used during ink splash animations or to
  /// indicate an item in a menu is selected.
  final Color highlightColor;

  /// The color to use for hint text or placeholder text, e.g. in
  /// [TextField] fields.
  final Color hintColor;

  /// The hover color used to indicate when a pointer is hovering over a
  /// component.
  final Color hoverColor;

  /// The color of the selected tab indicator in a tab bar.
  final Color indicatorColor;

  /// The background color for major parts of the app (toolbars, tab bars, etc)
  ///
  /// The theme's [colorScheme] property contains [ColorScheme.primary], as
  /// well as a color that contrasts well with the primary color called
  /// [ColorScheme.onPrimary]. It might be simpler to just configure an app's
  /// visuals in terms of the theme's [colorScheme].
  final Color primaryColor;

  /// A darker version of the [primaryColor].
  final Color primaryColorDark;

  /// A lighter version of the [primaryColor].
  final Color primaryColorLight;

  /// The default color of the [Material] that underlies the [Scaffold]. The
  /// background color for a typical material app or a page within the app.
  final Color scaffoldBackgroundColor;

  /// The color of the header of a [PaginatedDataTable] when there are selected rows.
  // According to the spec for data tables:
  // https://material.io/archive/guidelines/components/data-tables.html#data-tables-tables-within-cards
  // ...this should be the "50-value of secondary app color".
  final Color secondaryHeaderColor;

  /// The color that the [Material] widget uses to draw elevation shadows.
  ///
  /// Defaults to fully opaque black.
  ///
  /// Shadows can be difficult to see in a dark theme, so the elevation of a
  /// surface should be rendered with an "overlay" in addition to the shadow.
  /// As the elevation of the component increases, the overlay increases in
  /// opacity. The [applyElevationOverlayColor] property turns the elevation
  /// overlay on or off for dark themes.
  final Color shadowColor;

  /// The color of ink splashes.
  ///
  /// See also:
  ///  * [splashFactory], which defines the appearance of the splash.
  final Color splashColor;

  /// The color used for widgets in their inactive (but enabled)
  /// state. For example, an unchecked checkbox. See also [disabledColor].
  final Color unselectedWidgetColor;

  // TYPOGRAPHY & ICONOGRAPHY

  /// An icon theme that contrasts with the card and canvas colors.
  final IconThemeData iconTheme;

  /// An icon theme that contrasts with the primary color.
  final IconThemeData primaryIconTheme;

  /// A text theme that contrasts with the primary color.
  final TextTheme primaryTextTheme;

  /// Text with a color that contrasts with the card and canvas colors.
  final TextTheme textTheme;

  /// The color and geometry [TextTheme] values used to configure [textTheme].
  ///
  /// Defaults to a [platform]-appropriate typography.
  final Typography typography;

  // COMPONENT THEMES

  /// A theme for customizing icons of [BackButtonIcon], [CloseButtonIcon],
  /// [DrawerButtonIcon], or [EndDrawerButtonIcon].
  final ActionIconThemeData? actionIconTheme;

  /// A theme for customizing the color, elevation, brightness, iconTheme and
  /// textTheme of [AppBar]s.
  final AppBarTheme appBarTheme;

  /// A theme for customizing the color of [Badge]s.
  final BadgeThemeData badgeTheme;

  /// A theme for customizing the color and text style of a [MaterialBanner].
  final MaterialBannerThemeData bannerTheme;

  /// A theme for customizing the shape, elevation, and color of a [BottomAppBar].
  final BottomAppBarTheme bottomAppBarTheme;

  /// A theme for customizing the appearance and layout of [BottomNavigationBar]
  /// widgets.
  final BottomNavigationBarThemeData bottomNavigationBarTheme;

  /// A theme for customizing the color, elevation, and shape of a bottom sheet.
  final BottomSheetThemeData bottomSheetTheme;

  /// Defines the default configuration of button widgets, like [DropdownButton]
  /// and [ButtonBar].
  final ButtonThemeData buttonTheme;

  /// The colors and styles used to render [Card].
  ///
  /// This is the value returned from [CardTheme.of].
  final CardThemeData cardTheme;

  /// A theme for customizing the appearance and layout of [Checkbox] widgets.
  final CheckboxThemeData checkboxTheme;

  /// The colors and styles used to render [Chip]s.
  ///
  /// This is the value returned from [ChipTheme.of].
  final ChipThemeData chipTheme;

  /// A theme for customizing the appearance and layout of [DataTable]
  /// widgets.
  final DataTableThemeData dataTableTheme;

  /// A theme for customizing the appearance and layout of [DatePickerDialog]
  /// widgets.
  final DatePickerThemeData datePickerTheme;

  /// A theme for customizing the shape of a dialog.
  final DialogThemeData dialogTheme;

  /// A theme for customizing the color, thickness, and indents of [Divider]s,
  /// [VerticalDivider]s, etc.
  final DividerThemeData dividerTheme;

  /// A theme for customizing the appearance and layout of [Drawer] widgets.
  final DrawerThemeData drawerTheme;

  /// A theme for customizing the appearance and layout of [DropdownMenu] widgets.
  final DropdownMenuThemeData dropdownMenuTheme;

  /// A theme for customizing the appearance and internal layout of
  /// [ElevatedButton]s.
  final ElevatedButtonThemeData elevatedButtonTheme;

  /// A theme for customizing the visual properties of [ExpansionTile]s.
  final ExpansionTileThemeData expansionTileTheme;

  /// A theme for customizing the appearance and internal layout of
  /// [FilledButton]s.
  final FilledButtonThemeData filledButtonTheme;

  /// A theme for customizing the shape, elevation, and color of a
  /// [FloatingActionButton].
  final FloatingActionButtonThemeData floatingActionButtonTheme;

  /// A theme for customizing the appearance and internal layout of
  /// [IconButton]s.
  final IconButtonThemeData iconButtonTheme;

  /// A theme for customizing the appearance of [ListTile] widgets.
  final ListTileThemeData listTileTheme;

  /// A theme for customizing the color, shape, elevation, and other [MenuStyle]
  /// aspects of the menu bar created by the [MenuBar] widget.
  final MenuBarThemeData menuBarTheme;

  /// A theme for customizing the color, shape, elevation, and text style of
  /// cascading menu buttons created by [SubmenuButton] or [MenuItemButton].
  final MenuButtonThemeData menuButtonTheme;

  /// A theme for customizing the color, shape, elevation, and other [MenuStyle]
  /// attributes of menus created by the [SubmenuButton] widget.
  final MenuThemeData menuTheme;

  /// A theme for customizing the background color, text style, and icon themes
  /// of a [NavigationBar].
  final NavigationBarThemeData navigationBarTheme;

  /// A theme for customizing the background color, text style, and icon themes
  /// of a [NavigationDrawer].
  final NavigationDrawerThemeData navigationDrawerTheme;

  /// A theme for customizing the background color, elevation, text style, and
  /// icon themes of a [NavigationRail].
  final NavigationRailThemeData navigationRailTheme;

  /// A theme for customizing the appearance and internal layout of
  /// [OutlinedButton]s.
  final OutlinedButtonThemeData outlinedButtonTheme;

  /// A theme for customizing the color, shape, elevation, and text style of
  /// popup menus.
  final PopupMenuThemeData popupMenuTheme;

  /// A theme for customizing the appearance and layout of [ProgressIndicator] widgets.
  final ProgressIndicatorThemeData progressIndicatorTheme;

  /// A theme for customizing the appearance and layout of [Radio] widgets.
  final RadioThemeData radioTheme;

  /// A theme for customizing the appearance and layout of [SearchBar] widgets.
  final SearchBarThemeData searchBarTheme;

  /// A theme for customizing the appearance and layout of search views created by [SearchAnchor] widgets.
  final SearchViewThemeData searchViewTheme;

  /// A theme for customizing the appearance and layout of [SegmentedButton] widgets.
  final SegmentedButtonThemeData segmentedButtonTheme;

  /// The colors and shapes used to render [Slider].
  ///
  /// This is the value returned from [SliderTheme.of].
  final SliderThemeData sliderTheme;

  /// A theme for customizing colors, shape, elevation, and behavior of a [SnackBar].
  final SnackBarThemeData snackBarTheme;

  /// A theme for customizing the appearance and layout of [Switch] widgets.
  final SwitchThemeData switchTheme;

  /// A theme for customizing the size, shape, and color of the tab bar indicator.
  final TabBarThemeData tabBarTheme;

  /// A theme for customizing the appearance and internal layout of
  /// [TextButton]s.
  final TextButtonThemeData textButtonTheme;

  /// A theme for customizing the appearance and layout of [TextField] widgets.
  final TextSelectionThemeData textSelectionTheme;

  /// A theme for customizing the appearance and layout of time picker widgets.
  final TimePickerThemeData timePickerTheme;

  /// Defines the default configuration of [ToggleButtons] widgets.
  final ToggleButtonsThemeData toggleButtonsTheme;

  /// A theme for customizing the visual properties of [Tooltip]s.
  ///
  /// This is the value returned from [TooltipTheme.of].
  final TooltipThemeData tooltipTheme;

  /// A theme for customizing the appearance and layout of [ButtonBar] widgets.
  @Deprecated(
    'Use OverflowBar instead. '
    'This feature was deprecated after v3.21.0-10.0.pre.',
  )
  ButtonBarThemeData get buttonBarTheme => _buttonBarTheme!;
  final ButtonBarThemeData? _buttonBarTheme;

  /// The background color of [Dialog] elements.
  @Deprecated(
    'Use DialogThemeData.backgroundColor instead. '
    'This feature was deprecated after v3.27.0-0.1.pre.',
  )
  final Color dialogBackgroundColor;

  /// Creates a copy of this theme but with the given fields replaced with the new values.
  ///
  /// The [brightness] value is applied to the [colorScheme].
  ThemeData copyWith({
    // For the sanity of the reader, make sure these properties are in the same
    // order in every place that they are separated by section comments (e.g.
    // GENERAL CONFIGURATION). Each section except for deprecations should be
    // alphabetical by symbol name.

    // GENERAL CONFIGURATION
    Iterable<Adaptation<Object>>? adaptations,
    bool? applyElevationOverlayColor,
    NoDefaultCupertinoThemeData? cupertinoOverrideTheme,
    Iterable<ThemeExtension<dynamic>>? extensions,
    InputDecorationTheme? inputDecorationTheme,
    MaterialTapTargetSize? materialTapTargetSize,
    PageTransitionsTheme? pageTransitionsTheme,
    TargetPlatform? platform,
    ScrollbarThemeData? scrollbarTheme,
    InteractiveInkFeatureFactory? splashFactory,
    VisualDensity? visualDensity,
    // COLOR
    ColorScheme? colorScheme,
    Brightness? brightness,
    // [colorScheme] is the preferred way to configure colors. The [Color] properties
    // listed below (as well as primarySwatch) will gradually be phased out, see
    // https://github.com/flutter/flutter/issues/91772.
    Color? canvasColor,
    Color? cardColor,
    Color? disabledColor,
    Color? dividerColor,
    Color? focusColor,
    Color? highlightColor,
    Color? hintColor,
    Color? hoverColor,
    Color? indicatorColor,
    Color? primaryColor,
    Color? primaryColorDark,
    Color? primaryColorLight,
    Color? scaffoldBackgroundColor,
    Color? secondaryHeaderColor,
    Color? shadowColor,
    Color? splashColor,
    Color? unselectedWidgetColor,
    // TYPOGRAPHY & ICONOGRAPHY
    IconThemeData? iconTheme,
    IconThemeData? primaryIconTheme,
    TextTheme? primaryTextTheme,
    TextTheme? textTheme,
    Typography? typography,
    // COMPONENT THEMES
    ActionIconThemeData? actionIconTheme,
    AppBarTheme? appBarTheme,
    BadgeThemeData? badgeTheme,
    MaterialBannerThemeData? bannerTheme,
    BottomAppBarTheme? bottomAppBarTheme,
    BottomNavigationBarThemeData? bottomNavigationBarTheme,
    BottomSheetThemeData? bottomSheetTheme,
    ButtonThemeData? buttonTheme,
    Object? cardTheme,
    CheckboxThemeData? checkboxTheme,
    ChipThemeData? chipTheme,
    DataTableThemeData? dataTableTheme,
    DatePickerThemeData? datePickerTheme,
    // TODO(QuncCccccc): Change the parameter type to DialogThemeData
    Object? dialogTheme,
    DividerThemeData? dividerTheme,
    DrawerThemeData? drawerTheme,
    DropdownMenuThemeData? dropdownMenuTheme,
    ElevatedButtonThemeData? elevatedButtonTheme,
    ExpansionTileThemeData? expansionTileTheme,
    FilledButtonThemeData? filledButtonTheme,
    FloatingActionButtonThemeData? floatingActionButtonTheme,
    IconButtonThemeData? iconButtonTheme,
    ListTileThemeData? listTileTheme,
    MenuBarThemeData? menuBarTheme,
    MenuButtonThemeData? menuButtonTheme,
    MenuThemeData? menuTheme,
    NavigationBarThemeData? navigationBarTheme,
    NavigationDrawerThemeData? navigationDrawerTheme,
    NavigationRailThemeData? navigationRailTheme,
    OutlinedButtonThemeData? outlinedButtonTheme,
    PopupMenuThemeData? popupMenuTheme,
    ProgressIndicatorThemeData? progressIndicatorTheme,
    RadioThemeData? radioTheme,
    SearchBarThemeData? searchBarTheme,
    SearchViewThemeData? searchViewTheme,
    SegmentedButtonThemeData? segmentedButtonTheme,
    SliderThemeData? sliderTheme,
    SnackBarThemeData? snackBarTheme,
    SwitchThemeData? switchTheme,
    // TODO(QuncCccccc): Change the parameter type to TabBarThemeData
    Object? tabBarTheme,
    TextButtonThemeData? textButtonTheme,
    TextSelectionThemeData? textSelectionTheme,
    TimePickerThemeData? timePickerTheme,
    ToggleButtonsThemeData? toggleButtonsTheme,
    TooltipThemeData? tooltipTheme,
    // DEPRECATED (newest deprecations at the bottom)
    @Deprecated(
      'Use a ThemeData constructor (.from, .light, or .dark) instead. '
      'These constructors all have a useMaterial3 argument, '
      'and they set appropriate default values based on its value. '
      'See the useMaterial3 API documentation for full details. '
      'This feature was deprecated after v3.13.0-0.2.pre.',
    )
    bool? useMaterial3,
    @Deprecated(
      'Use OverflowBar instead. '
      'This feature was deprecated after v3.21.0-10.0.pre.',
    )
    ButtonBarThemeData? buttonBarTheme,
    @Deprecated(
      'Use DialogThemeData.backgroundColor instead. '
      'This feature was deprecated after v3.27.0-0.1.pre.',
    )
    Color? dialogBackgroundColor,
  }) {
    cupertinoOverrideTheme = cupertinoOverrideTheme?.noDefault();

    // TODO(QuncCccccc): Clean it up once the type of `cardTheme` is changed to `CardThemeData`
    if (cardTheme != null) {
      if (cardTheme is CardTheme) {
        cardTheme = cardTheme.data;
      } else if (cardTheme is! CardThemeData) {
        throw ArgumentError('cardTheme must be either a CardThemeData or a CardTheme');
      }
    }

    // TODO(QuncCccccc): Clean this up once the type of `dialogTheme` is changed to `DialogThemeData`
    if (dialogTheme != null) {
      if (dialogTheme is DialogTheme) {
        dialogTheme = dialogTheme.data;
      } else if (dialogTheme is! DialogThemeData) {
        throw ArgumentError('dialogTheme must be either a DialogThemeData or a DialogTheme');
      }
    }

    // TODO(QuncCccccc): Clean this up once the type of `tabBarTheme` is changed to `TabBarThemeData`
    if (tabBarTheme != null) {
      if (tabBarTheme is TabBarTheme) {
        tabBarTheme = tabBarTheme.data;
      } else if (tabBarTheme is! TabBarThemeData) {
        throw ArgumentError('tabBarTheme must be either a TabBarThemeData or a TabBarTheme');
      }
    }
    return ThemeData.raw(
      // For the sanity of the reader, make sure these properties are in the same
      // order in every place that they are separated by section comments (e.g.
      // GENERAL CONFIGURATION). Each section except for deprecations should be
      // alphabetical by symbol name.

      // GENERAL CONFIGURATION
      adaptationMap: adaptations != null ? _createAdaptationMap(adaptations) : adaptationMap,
      applyElevationOverlayColor: applyElevationOverlayColor ?? this.applyElevationOverlayColor,
      cupertinoOverrideTheme: cupertinoOverrideTheme ?? this.cupertinoOverrideTheme,
      extensions: (extensions != null) ? _themeExtensionIterableToMap(extensions) : this.extensions,
      inputDecorationTheme: inputDecorationTheme ?? this.inputDecorationTheme,
      materialTapTargetSize: materialTapTargetSize ?? this.materialTapTargetSize,
      pageTransitionsTheme: pageTransitionsTheme ?? this.pageTransitionsTheme,
      platform: platform ?? this.platform,
      scrollbarTheme: scrollbarTheme ?? this.scrollbarTheme,
      splashFactory: splashFactory ?? this.splashFactory,
      // When deprecated useMaterial3 removed, maintain `this.useMaterial3` here
      // for == evaluation.
      useMaterial3: useMaterial3 ?? this.useMaterial3,
      visualDensity: visualDensity ?? this.visualDensity,
      // COLOR
      canvasColor: canvasColor ?? this.canvasColor,
      cardColor: cardColor ?? this.cardColor,
      colorScheme: (colorScheme ?? this.colorScheme).copyWith(brightness: brightness),
      disabledColor: disabledColor ?? this.disabledColor,
      dividerColor: dividerColor ?? this.dividerColor,
      focusColor: focusColor ?? this.focusColor,
      highlightColor: highlightColor ?? this.highlightColor,
      hintColor: hintColor ?? this.hintColor,
      hoverColor: hoverColor ?? this.hoverColor,
      indicatorColor: indicatorColor ?? this.indicatorColor,
      primaryColor: primaryColor ?? this.primaryColor,
      primaryColorDark: primaryColorDark ?? this.primaryColorDark,
      primaryColorLight: primaryColorLight ?? this.primaryColorLight,
      scaffoldBackgroundColor: scaffoldBackgroundColor ?? this.scaffoldBackgroundColor,
      secondaryHeaderColor: secondaryHeaderColor ?? this.secondaryHeaderColor,
      shadowColor: shadowColor ?? this.shadowColor,
      splashColor: splashColor ?? this.splashColor,
      unselectedWidgetColor: unselectedWidgetColor ?? this.unselectedWidgetColor,
      // TYPOGRAPHY & ICONOGRAPHY
      iconTheme: iconTheme ?? this.iconTheme,
      primaryIconTheme: primaryIconTheme ?? this.primaryIconTheme,
      primaryTextTheme: primaryTextTheme ?? this.primaryTextTheme,
      textTheme: textTheme ?? this.textTheme,
      typography: typography ?? this.typography,
      // COMPONENT THEMES
      actionIconTheme: actionIconTheme ?? this.actionIconTheme,
      appBarTheme: appBarTheme ?? this.appBarTheme,
      badgeTheme: badgeTheme ?? this.badgeTheme,
      bannerTheme: bannerTheme ?? this.bannerTheme,
      bottomAppBarTheme: bottomAppBarTheme ?? this.bottomAppBarTheme,
      bottomNavigationBarTheme: bottomNavigationBarTheme ?? this.bottomNavigationBarTheme,
      bottomSheetTheme: bottomSheetTheme ?? this.bottomSheetTheme,
      buttonTheme: buttonTheme ?? this.buttonTheme,
      cardTheme: cardTheme as CardThemeData? ?? this.cardTheme,
      checkboxTheme: checkboxTheme ?? this.checkboxTheme,
      chipTheme: chipTheme ?? this.chipTheme,
      dataTableTheme: dataTableTheme ?? this.dataTableTheme,
      datePickerTheme: datePickerTheme ?? this.datePickerTheme,
      dialogTheme: dialogTheme as DialogThemeData? ?? this.dialogTheme,
      dividerTheme: dividerTheme ?? this.dividerTheme,
      drawerTheme: drawerTheme ?? this.drawerTheme,
      dropdownMenuTheme: dropdownMenuTheme ?? this.dropdownMenuTheme,
      elevatedButtonTheme: elevatedButtonTheme ?? this.elevatedButtonTheme,
      expansionTileTheme: expansionTileTheme ?? this.expansionTileTheme,
      filledButtonTheme: filledButtonTheme ?? this.filledButtonTheme,
      floatingActionButtonTheme: floatingActionButtonTheme ?? this.floatingActionButtonTheme,
      iconButtonTheme: iconButtonTheme ?? this.iconButtonTheme,
      listTileTheme: listTileTheme ?? this.listTileTheme,
      menuBarTheme: menuBarTheme ?? this.menuBarTheme,
      menuButtonTheme: menuButtonTheme ?? this.menuButtonTheme,
      menuTheme: menuTheme ?? this.menuTheme,
      navigationBarTheme: navigationBarTheme ?? this.navigationBarTheme,
      navigationDrawerTheme: navigationDrawerTheme ?? this.navigationDrawerTheme,
      navigationRailTheme: navigationRailTheme ?? this.navigationRailTheme,
      outlinedButtonTheme: outlinedButtonTheme ?? this.outlinedButtonTheme,
      popupMenuTheme: popupMenuTheme ?? this.popupMenuTheme,
      progressIndicatorTheme: progressIndicatorTheme ?? this.progressIndicatorTheme,
      radioTheme: radioTheme ?? this.radioTheme,
      searchBarTheme: searchBarTheme ?? this.searchBarTheme,
      searchViewTheme: searchViewTheme ?? this.searchViewTheme,
      segmentedButtonTheme: segmentedButtonTheme ?? this.segmentedButtonTheme,
      sliderTheme: sliderTheme ?? this.sliderTheme,
      snackBarTheme: snackBarTheme ?? this.snackBarTheme,
      switchTheme: switchTheme ?? this.switchTheme,
      tabBarTheme: tabBarTheme as TabBarThemeData? ?? this.tabBarTheme,
      textButtonTheme: textButtonTheme ?? this.textButtonTheme,
      textSelectionTheme: textSelectionTheme ?? this.textSelectionTheme,
      timePickerTheme: timePickerTheme ?? this.timePickerTheme,
      toggleButtonsTheme: toggleButtonsTheme ?? this.toggleButtonsTheme,
      tooltipTheme: tooltipTheme ?? this.tooltipTheme,
      // DEPRECATED (newest deprecations at the bottom)
      buttonBarTheme: buttonBarTheme ?? _buttonBarTheme,
      dialogBackgroundColor: dialogBackgroundColor ?? this.dialogBackgroundColor,
    );
  }

  // The number 5 was chosen without any real science or research behind it. It
  // just seemed like a number that's not too big (we should be able to fit 5
  // copies of ThemeData in memory comfortably) and not too small (most apps
  // shouldn't have more than 5 theme/localization pairs).
  static const int _localizedThemeDataCacheSize = 5;

  /// Caches localized themes to speed up the [localize] method.
  static final _FifoCache<_IdentityThemeDataCacheKey, ThemeData> _localizedThemeDataCache =
      _FifoCache<_IdentityThemeDataCacheKey, ThemeData>(_localizedThemeDataCacheSize);

  /// Returns a new theme built by merging the text geometry provided by the
  /// [localTextGeometry] theme with the [baseTheme].
  ///
  /// For those text styles in the [baseTheme] whose [TextStyle.inherit] is set
  /// to true, the returned theme's text styles inherit the geometric properties
  /// of [localTextGeometry]. The resulting text styles' [TextStyle.inherit] is
  /// set to those provided by [localTextGeometry].
  static ThemeData localize(ThemeData baseTheme, TextTheme localTextGeometry) {
    // WARNING: this method memoizes the result in a cache based on the
    // previously seen baseTheme and localTextGeometry. Memoization is safe
    // because all inputs and outputs of this function are deeply immutable, and
    // the computations are referentially transparent. It only short-circuits
    // the computation if the new inputs are identical() to the previous ones.
    // It does not use the == operator, which performs a costly deep comparison.
    //
    // When changing this method, make sure the memoization logic is correct.
    // Remember:
    //
    // There are only two hard things in Computer Science: cache invalidation
    // and naming things. -- Phil Karlton

    return _localizedThemeDataCache.putIfAbsent(
      _IdentityThemeDataCacheKey(baseTheme, localTextGeometry),
      () {
        return baseTheme.copyWith(
          primaryTextTheme: localTextGeometry.merge(baseTheme.primaryTextTheme),
          textTheme: localTextGeometry.merge(baseTheme.textTheme),
        );
      },
    );
  }

  /// Determines whether the given [Color] is [Brightness.light] or
  /// [Brightness.dark].
  ///
  /// This compares the luminosity of the given color to a threshold value that
  /// matches the Material Design specification.
  static Brightness estimateBrightnessForColor(Color color) {
    final double relativeLuminance = color.computeLuminance();

    // See <https://www.w3.org/TR/WCAG20/#contrast-ratiodef>
    // The spec says to use kThreshold=0.0525, but Material Design appears to bias
    // more towards using light text than WCAG20 recommends. Material Design spec
    // doesn't say what value to use, but 0.15 seemed close to what the Material
    // Design spec shows for its color palette on
    // <https://material.io/go/design-theming#color-color-palette>.
    const double kThreshold = 0.15;
    if ((relativeLuminance + 0.05) * (relativeLuminance + 0.05) > kThreshold) {
      return Brightness.light;
    }
    return Brightness.dark;
  }

  /// Linearly interpolate between two [extensions].
  ///
  /// Includes all theme extensions in [a] and [b].
  ///
  /// {@macro dart.ui.shadow.lerp}
  static Map<Object, ThemeExtension<dynamic>> _lerpThemeExtensions(
    ThemeData a,
    ThemeData b,
    double t,
  ) {
    // Lerp [a].
    final Map<Object, ThemeExtension<dynamic>> newExtensions = a.extensions.map((
      Object id,
      ThemeExtension<dynamic> extensionA,
    ) {
      final ThemeExtension<dynamic>? extensionB = b.extensions[id];
      return MapEntry<Object, ThemeExtension<dynamic>>(id, extensionA.lerp(extensionB, t));
    });
    // Add [b]-only extensions.
    newExtensions.addEntries(
      b.extensions.entries.where(
        (MapEntry<Object, ThemeExtension<dynamic>> entry) => !a.extensions.containsKey(entry.key),
      ),
    );

    return newExtensions;
  }

  /// Convert the [extensionsIterable] passed to [ThemeData.new] or [copyWith]
  /// to the stored [extensions] map, where each entry's key consists of the extension's type.
  static Map<Object, ThemeExtension<dynamic>> _themeExtensionIterableToMap(
    Iterable<ThemeExtension<dynamic>> extensionsIterable,
  ) {
    return Map<Object, ThemeExtension<dynamic>>.unmodifiable(<Object, ThemeExtension<dynamic>>{
      // Strangely, the cast is necessary for tests to run.
      for (final ThemeExtension<dynamic> extension in extensionsIterable)
        extension.type: extension as ThemeExtension<ThemeExtension<dynamic>>,
    });
  }

  /// Linearly interpolate between two themes.
  ///
  /// {@macro dart.ui.shadow.lerp}
  static ThemeData lerp(ThemeData a, ThemeData b, double t) {
    if (identical(a, b)) {
      return a;
    }
    return ThemeData.raw(
      // For the sanity of the reader, make sure these properties are in the same
      // order in every place that they are separated by section comments (e.g.
      // GENERAL CONFIGURATION). Each section except for deprecations should be
      // alphabetical by symbol name.

      // GENERAL CONFIGURATION
      adaptationMap: t < 0.5 ? a.adaptationMap : b.adaptationMap,
      applyElevationOverlayColor:
          t < 0.5 ? a.applyElevationOverlayColor : b.applyElevationOverlayColor,
      cupertinoOverrideTheme: t < 0.5 ? a.cupertinoOverrideTheme : b.cupertinoOverrideTheme,
      extensions: _lerpThemeExtensions(a, b, t),
      inputDecorationTheme: t < 0.5 ? a.inputDecorationTheme : b.inputDecorationTheme,
      materialTapTargetSize: t < 0.5 ? a.materialTapTargetSize : b.materialTapTargetSize,
      pageTransitionsTheme: t < 0.5 ? a.pageTransitionsTheme : b.pageTransitionsTheme,
      platform: t < 0.5 ? a.platform : b.platform,
      scrollbarTheme: ScrollbarThemeData.lerp(a.scrollbarTheme, b.scrollbarTheme, t),
      splashFactory: t < 0.5 ? a.splashFactory : b.splashFactory,
      useMaterial3: t < 0.5 ? a.useMaterial3 : b.useMaterial3,
      visualDensity: VisualDensity.lerp(a.visualDensity, b.visualDensity, t),
      // COLOR
      canvasColor: Color.lerp(a.canvasColor, b.canvasColor, t)!,
      cardColor: Color.lerp(a.cardColor, b.cardColor, t)!,
      colorScheme: ColorScheme.lerp(a.colorScheme, b.colorScheme, t),
      disabledColor: Color.lerp(a.disabledColor, b.disabledColor, t)!,
      dividerColor: Color.lerp(a.dividerColor, b.dividerColor, t)!,
      focusColor: Color.lerp(a.focusColor, b.focusColor, t)!,
      highlightColor: Color.lerp(a.highlightColor, b.highlightColor, t)!,
      hintColor: Color.lerp(a.hintColor, b.hintColor, t)!,
      hoverColor: Color.lerp(a.hoverColor, b.hoverColor, t)!,
      indicatorColor: Color.lerp(a.indicatorColor, b.indicatorColor, t)!,
      primaryColor: Color.lerp(a.primaryColor, b.primaryColor, t)!,
      primaryColorDark: Color.lerp(a.primaryColorDark, b.primaryColorDark, t)!,
      primaryColorLight: Color.lerp(a.primaryColorLight, b.primaryColorLight, t)!,
      scaffoldBackgroundColor: Color.lerp(a.scaffoldBackgroundColor, b.scaffoldBackgroundColor, t)!,
      secondaryHeaderColor: Color.lerp(a.secondaryHeaderColor, b.secondaryHeaderColor, t)!,
      shadowColor: Color.lerp(a.shadowColor, b.shadowColor, t)!,
      splashColor: Color.lerp(a.splashColor, b.splashColor, t)!,
      unselectedWidgetColor: Color.lerp(a.unselectedWidgetColor, b.unselectedWidgetColor, t)!,
      // TYPOGRAPHY & ICONOGRAPHY
      iconTheme: IconThemeData.lerp(a.iconTheme, b.iconTheme, t),
      primaryIconTheme: IconThemeData.lerp(a.primaryIconTheme, b.primaryIconTheme, t),
      primaryTextTheme: TextTheme.lerp(a.primaryTextTheme, b.primaryTextTheme, t),
      textTheme: TextTheme.lerp(a.textTheme, b.textTheme, t),
      typography: Typography.lerp(a.typography, b.typography, t),
      // COMPONENT THEMES
      actionIconTheme: ActionIconThemeData.lerp(a.actionIconTheme, b.actionIconTheme, t),
      appBarTheme: AppBarTheme.lerp(a.appBarTheme, b.appBarTheme, t),
      badgeTheme: BadgeThemeData.lerp(a.badgeTheme, b.badgeTheme, t),
      bannerTheme: MaterialBannerThemeData.lerp(a.bannerTheme, b.bannerTheme, t),
      bottomAppBarTheme: BottomAppBarTheme.lerp(a.bottomAppBarTheme, b.bottomAppBarTheme, t),
      bottomNavigationBarTheme: BottomNavigationBarThemeData.lerp(
        a.bottomNavigationBarTheme,
        b.bottomNavigationBarTheme,
        t,
      ),
      bottomSheetTheme: BottomSheetThemeData.lerp(a.bottomSheetTheme, b.bottomSheetTheme, t)!,
      buttonTheme: t < 0.5 ? a.buttonTheme : b.buttonTheme,
      cardTheme: CardThemeData.lerp(a.cardTheme, b.cardTheme, t),
      checkboxTheme: CheckboxThemeData.lerp(a.checkboxTheme, b.checkboxTheme, t),
      chipTheme: ChipThemeData.lerp(a.chipTheme, b.chipTheme, t)!,
      dataTableTheme: DataTableThemeData.lerp(a.dataTableTheme, b.dataTableTheme, t),
      datePickerTheme: DatePickerThemeData.lerp(a.datePickerTheme, b.datePickerTheme, t),
      dialogTheme: DialogThemeData.lerp(a.dialogTheme, b.dialogTheme, t),
      dividerTheme: DividerThemeData.lerp(a.dividerTheme, b.dividerTheme, t),
      drawerTheme: DrawerThemeData.lerp(a.drawerTheme, b.drawerTheme, t)!,
      dropdownMenuTheme: DropdownMenuThemeData.lerp(a.dropdownMenuTheme, b.dropdownMenuTheme, t),
      elevatedButtonTheme:
          ElevatedButtonThemeData.lerp(a.elevatedButtonTheme, b.elevatedButtonTheme, t)!,
      expansionTileTheme:
          ExpansionTileThemeData.lerp(a.expansionTileTheme, b.expansionTileTheme, t)!,
      filledButtonTheme: FilledButtonThemeData.lerp(a.filledButtonTheme, b.filledButtonTheme, t)!,
      floatingActionButtonTheme:
          FloatingActionButtonThemeData.lerp(
            a.floatingActionButtonTheme,
            b.floatingActionButtonTheme,
            t,
          )!,
      iconButtonTheme: IconButtonThemeData.lerp(a.iconButtonTheme, b.iconButtonTheme, t)!,
      listTileTheme: ListTileThemeData.lerp(a.listTileTheme, b.listTileTheme, t)!,
      menuBarTheme: MenuBarThemeData.lerp(a.menuBarTheme, b.menuBarTheme, t)!,
      menuButtonTheme: MenuButtonThemeData.lerp(a.menuButtonTheme, b.menuButtonTheme, t)!,
      menuTheme: MenuThemeData.lerp(a.menuTheme, b.menuTheme, t)!,
      navigationBarTheme:
          NavigationBarThemeData.lerp(a.navigationBarTheme, b.navigationBarTheme, t)!,
      navigationDrawerTheme:
          NavigationDrawerThemeData.lerp(a.navigationDrawerTheme, b.navigationDrawerTheme, t)!,
      navigationRailTheme:
          NavigationRailThemeData.lerp(a.navigationRailTheme, b.navigationRailTheme, t)!,
      outlinedButtonTheme:
          OutlinedButtonThemeData.lerp(a.outlinedButtonTheme, b.outlinedButtonTheme, t)!,
      popupMenuTheme: PopupMenuThemeData.lerp(a.popupMenuTheme, b.popupMenuTheme, t)!,
      progressIndicatorTheme:
          ProgressIndicatorThemeData.lerp(a.progressIndicatorTheme, b.progressIndicatorTheme, t)!,
      radioTheme: RadioThemeData.lerp(a.radioTheme, b.radioTheme, t),
      searchBarTheme: SearchBarThemeData.lerp(a.searchBarTheme, b.searchBarTheme, t)!,
      searchViewTheme: SearchViewThemeData.lerp(a.searchViewTheme, b.searchViewTheme, t)!,
      segmentedButtonTheme: SegmentedButtonThemeData.lerp(
        a.segmentedButtonTheme,
        b.segmentedButtonTheme,
        t,
      ),
      sliderTheme: SliderThemeData.lerp(a.sliderTheme, b.sliderTheme, t),
      snackBarTheme: SnackBarThemeData.lerp(a.snackBarTheme, b.snackBarTheme, t),
      switchTheme: SwitchThemeData.lerp(a.switchTheme, b.switchTheme, t),
      tabBarTheme: TabBarThemeData.lerp(a.tabBarTheme, b.tabBarTheme, t),
      textButtonTheme: TextButtonThemeData.lerp(a.textButtonTheme, b.textButtonTheme, t)!,
      textSelectionTheme:
          TextSelectionThemeData.lerp(a.textSelectionTheme, b.textSelectionTheme, t)!,
      timePickerTheme: TimePickerThemeData.lerp(a.timePickerTheme, b.timePickerTheme, t),
      toggleButtonsTheme:
          ToggleButtonsThemeData.lerp(a.toggleButtonsTheme, b.toggleButtonsTheme, t)!,
      tooltipTheme: TooltipThemeData.lerp(a.tooltipTheme, b.tooltipTheme, t)!,
      // DEPRECATED (newest deprecations at the bottom)
      buttonBarTheme: ButtonBarThemeData.lerp(a.buttonBarTheme, b.buttonBarTheme, t),
      dialogBackgroundColor: Color.lerp(a.dialogBackgroundColor, b.dialogBackgroundColor, t)!,
    );
  }

  @override
  bool operator ==(Object other) {
    if (other.runtimeType != runtimeType) {
      return false;
    }
    return other is ThemeData &&
        // For the sanity of the reader, make sure these properties are in the same
        // order in every place that they are separated by section comments (e.g.
        // GENERAL CONFIGURATION). Each section except for deprecations should be
        // alphabetical by symbol name.
        // GENERAL CONFIGURATION
        mapEquals(other.adaptationMap, adaptationMap) &&
        other.applyElevationOverlayColor == applyElevationOverlayColor &&
        other.cupertinoOverrideTheme == cupertinoOverrideTheme &&
        mapEquals(other.extensions, extensions) &&
        other.inputDecorationTheme == inputDecorationTheme &&
        other.materialTapTargetSize == materialTapTargetSize &&
        other.pageTransitionsTheme == pageTransitionsTheme &&
        other.platform == platform &&
        other.scrollbarTheme == scrollbarTheme &&
        other.splashFactory == splashFactory &&
        other.useMaterial3 == useMaterial3 &&
        other.visualDensity == visualDensity &&
        // COLOR
        other.canvasColor == canvasColor &&
        other.cardColor == cardColor &&
        other.colorScheme == colorScheme &&
        other.disabledColor == disabledColor &&
        other.dividerColor == dividerColor &&
        other.focusColor == focusColor &&
        other.highlightColor == highlightColor &&
        other.hintColor == hintColor &&
        other.hoverColor == hoverColor &&
        other.indicatorColor == indicatorColor &&
        other.primaryColor == primaryColor &&
        other.primaryColorDark == primaryColorDark &&
        other.primaryColorLight == primaryColorLight &&
        other.scaffoldBackgroundColor == scaffoldBackgroundColor &&
        other.secondaryHeaderColor == secondaryHeaderColor &&
        other.shadowColor == shadowColor &&
        other.splashColor == splashColor &&
        other.unselectedWidgetColor == unselectedWidgetColor &&
        // TYPOGRAPHY & ICONOGRAPHY
        other.iconTheme == iconTheme &&
        other.primaryIconTheme == primaryIconTheme &&
        other.primaryTextTheme == primaryTextTheme &&
        other.textTheme == textTheme &&
        other.typography == typography &&
        // COMPONENT THEMES
        other.actionIconTheme == actionIconTheme &&
        other.appBarTheme == appBarTheme &&
        other.badgeTheme == badgeTheme &&
        other.bannerTheme == bannerTheme &&
        other.bottomAppBarTheme == bottomAppBarTheme &&
        other.bottomNavigationBarTheme == bottomNavigationBarTheme &&
        other.bottomSheetTheme == bottomSheetTheme &&
        other.buttonTheme == buttonTheme &&
        other.cardTheme == cardTheme &&
        other.checkboxTheme == checkboxTheme &&
        other.chipTheme == chipTheme &&
        other.dataTableTheme == dataTableTheme &&
        other.datePickerTheme == datePickerTheme &&
        other.dialogTheme == dialogTheme &&
        other.dividerTheme == dividerTheme &&
        other.drawerTheme == drawerTheme &&
        other.dropdownMenuTheme == dropdownMenuTheme &&
        other.elevatedButtonTheme == elevatedButtonTheme &&
        other.expansionTileTheme == expansionTileTheme &&
        other.filledButtonTheme == filledButtonTheme &&
        other.floatingActionButtonTheme == floatingActionButtonTheme &&
        other.iconButtonTheme == iconButtonTheme &&
        other.listTileTheme == listTileTheme &&
        other.menuBarTheme == menuBarTheme &&
        other.menuButtonTheme == menuButtonTheme &&
        other.menuTheme == menuTheme &&
        other.navigationBarTheme == navigationBarTheme &&
        other.navigationDrawerTheme == navigationDrawerTheme &&
        other.navigationRailTheme == navigationRailTheme &&
        other.outlinedButtonTheme == outlinedButtonTheme &&
        other.popupMenuTheme == popupMenuTheme &&
        other.progressIndicatorTheme == progressIndicatorTheme &&
        other.radioTheme == radioTheme &&
        other.searchBarTheme == searchBarTheme &&
        other.searchViewTheme == searchViewTheme &&
        other.segmentedButtonTheme == segmentedButtonTheme &&
        other.sliderTheme == sliderTheme &&
        other.snackBarTheme == snackBarTheme &&
        other.switchTheme == switchTheme &&
        other.tabBarTheme == tabBarTheme &&
        other.textButtonTheme == textButtonTheme &&
        other.textSelectionTheme == textSelectionTheme &&
        other.timePickerTheme == timePickerTheme &&
        other.toggleButtonsTheme == toggleButtonsTheme &&
        other.tooltipTheme == tooltipTheme &&
        // DEPRECATED (newest deprecations at the bottom)
        other.buttonBarTheme == buttonBarTheme &&
        other.dialogBackgroundColor == dialogBackgroundColor;
  }

  @override
  int get hashCode {
    final List<Object?> values = <Object?>[
      // For the sanity of the reader, make sure these properties are in the same
      // order in every place that they are separated by section comments (e.g.
      // GENERAL CONFIGURATION). Each section except for deprecations should be
      // alphabetical by symbol name.

      // GENERAL CONFIGURATION
      ...adaptationMap.keys,
      ...adaptationMap.values,
      applyElevationOverlayColor,
      cupertinoOverrideTheme,
      ...extensions.keys,
      ...extensions.values,
      inputDecorationTheme,
      materialTapTargetSize,
      pageTransitionsTheme,
      platform,
      scrollbarTheme,
      splashFactory,
      useMaterial3,
      visualDensity,
      // COLOR
      canvasColor,
      cardColor,
      colorScheme,
      disabledColor,
      dividerColor,
      focusColor,
      highlightColor,
      hintColor,
      hoverColor,
      indicatorColor,
      primaryColor,
      primaryColorDark,
      primaryColorLight,
      scaffoldBackgroundColor,
      secondaryHeaderColor,
      shadowColor,
      splashColor,
      unselectedWidgetColor,
      // TYPOGRAPHY & ICONOGRAPHY
      iconTheme,
      primaryIconTheme,
      primaryTextTheme,
      textTheme,
      typography,
      // COMPONENT THEMES
      actionIconTheme,
      appBarTheme,
      badgeTheme,
      bannerTheme,
      bottomAppBarTheme,
      bottomNavigationBarTheme,
      bottomSheetTheme,
      buttonTheme,
      cardTheme,
      checkboxTheme,
      chipTheme,
      dataTableTheme,
      datePickerTheme,
      dialogTheme,
      dividerTheme,
      drawerTheme,
      dropdownMenuTheme,
      elevatedButtonTheme,
      expansionTileTheme,
      filledButtonTheme,
      floatingActionButtonTheme,
      iconButtonTheme,
      listTileTheme,
      menuBarTheme,
      menuButtonTheme,
      menuTheme,
      navigationBarTheme,
      navigationDrawerTheme,
      navigationRailTheme,
      outlinedButtonTheme,
      popupMenuTheme,
      progressIndicatorTheme,
      radioTheme,
      searchBarTheme,
      searchViewTheme,
      segmentedButtonTheme,
      sliderTheme,
      snackBarTheme,
      switchTheme,
      tabBarTheme,
      textButtonTheme,
      textSelectionTheme,
      timePickerTheme,
      toggleButtonsTheme,
      tooltipTheme,
      // DEPRECATED (newest deprecations at the bottom)
      buttonBarTheme,
      dialogBackgroundColor,
    ];
    return Object.hashAll(values);
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    final ThemeData defaultData = ThemeData.fallback();
    // For the sanity of the reader, make sure these properties are in the same
    // order in every place that they are separated by section comments (e.g.
    // GENERAL CONFIGURATION). Each section except for deprecations should be
    // alphabetical by symbol name.

    // GENERAL CONFIGURATION
    properties.add(
      IterableProperty<Adaptation<dynamic>>(
        'adaptations',
        adaptationMap.values,
        defaultValue: defaultData.adaptationMap.values,
        level: DiagnosticLevel.debug,
      ),
    );
    properties.add(
      DiagnosticsProperty<bool>(
        'applyElevationOverlayColor',
        applyElevationOverlayColor,
        level: DiagnosticLevel.debug,
      ),
    );
    properties.add(
      DiagnosticsProperty<NoDefaultCupertinoThemeData>(
        'cupertinoOverrideTheme',
        cupertinoOverrideTheme,
        defaultValue: defaultData.cupertinoOverrideTheme,
        level: DiagnosticLevel.debug,
      ),
    );
    properties.add(
      IterableProperty<ThemeExtension<dynamic>>(
        'extensions',
        extensions.values,
        defaultValue: defaultData.extensions.values,
        level: DiagnosticLevel.debug,
      ),
    );
    properties.add(
      DiagnosticsProperty<InputDecorationTheme>(
        'inputDecorationTheme',
        inputDecorationTheme,
        level: DiagnosticLevel.debug,
      ),
    );
    properties.add(
      DiagnosticsProperty<MaterialTapTargetSize>(
        'materialTapTargetSize',
        materialTapTargetSize,
        level: DiagnosticLevel.debug,
      ),
    );
    properties.add(
      DiagnosticsProperty<PageTransitionsTheme>(
        'pageTransitionsTheme',
        pageTransitionsTheme,
        level: DiagnosticLevel.debug,
      ),
    );
    properties.add(
      EnumProperty<TargetPlatform>(
        'platform',
        platform,
        defaultValue: defaultTargetPlatform,
        level: DiagnosticLevel.debug,
      ),
    );
    properties.add(
      DiagnosticsProperty<ScrollbarThemeData>(
        'scrollbarTheme',
        scrollbarTheme,
        defaultValue: defaultData.scrollbarTheme,
        level: DiagnosticLevel.debug,
      ),
    );
    properties.add(
      DiagnosticsProperty<InteractiveInkFeatureFactory>(
        'splashFactory',
        splashFactory,
        defaultValue: defaultData.splashFactory,
        level: DiagnosticLevel.debug,
      ),
    );
    properties.add(
      DiagnosticsProperty<bool>(
        'useMaterial3',
        useMaterial3,
        defaultValue: defaultData.useMaterial3,
        level: DiagnosticLevel.debug,
      ),
    );
    properties.add(
      DiagnosticsProperty<VisualDensity>(
        'visualDensity',
        visualDensity,
        defaultValue: defaultData.visualDensity,
        level: DiagnosticLevel.debug,
      ),
    );
    // COLORS
    properties.add(
      ColorProperty(
        'canvasColor',
        canvasColor,
        defaultValue: defaultData.canvasColor,
        level: DiagnosticLevel.debug,
      ),
    );
    properties.add(
      ColorProperty(
        'cardColor',
        cardColor,
        defaultValue: defaultData.cardColor,
        level: DiagnosticLevel.debug,
      ),
    );
    properties.add(
      DiagnosticsProperty<ColorScheme>(
        'colorScheme',
        colorScheme,
        defaultValue: defaultData.colorScheme,
        level: DiagnosticLevel.debug,
      ),
    );
    properties.add(
      ColorProperty(
        'disabledColor',
        disabledColor,
        defaultValue: defaultData.disabledColor,
        level: DiagnosticLevel.debug,
      ),
    );
    properties.add(
      ColorProperty(
        'dividerColor',
        dividerColor,
        defaultValue: defaultData.dividerColor,
        level: DiagnosticLevel.debug,
      ),
    );
    properties.add(
      ColorProperty(
        'focusColor',
        focusColor,
        defaultValue: defaultData.focusColor,
        level: DiagnosticLevel.debug,
      ),
    );
    properties.add(
      ColorProperty(
        'highlightColor',
        highlightColor,
        defaultValue: defaultData.highlightColor,
        level: DiagnosticLevel.debug,
      ),
    );
    properties.add(
      ColorProperty(
        'hintColor',
        hintColor,
        defaultValue: defaultData.hintColor,
        level: DiagnosticLevel.debug,
      ),
    );
    properties.add(
      ColorProperty(
        'hoverColor',
        hoverColor,
        defaultValue: defaultData.hoverColor,
        level: DiagnosticLevel.debug,
      ),
    );
    properties.add(
      ColorProperty(
        'indicatorColor',
        indicatorColor,
        defaultValue: defaultData.indicatorColor,
        level: DiagnosticLevel.debug,
      ),
    );
    properties.add(
      ColorProperty(
        'primaryColorDark',
        primaryColorDark,
        defaultValue: defaultData.primaryColorDark,
        level: DiagnosticLevel.debug,
      ),
    );
    properties.add(
      ColorProperty(
        'primaryColorLight',
        primaryColorLight,
        defaultValue: defaultData.primaryColorLight,
        level: DiagnosticLevel.debug,
      ),
    );
    properties.add(
      ColorProperty(
        'primaryColor',
        primaryColor,
        defaultValue: defaultData.primaryColor,
        level: DiagnosticLevel.debug,
      ),
    );
    properties.add(
      ColorProperty(
        'scaffoldBackgroundColor',
        scaffoldBackgroundColor,
        defaultValue: defaultData.scaffoldBackgroundColor,
        level: DiagnosticLevel.debug,
      ),
    );
    properties.add(
      ColorProperty(
        'secondaryHeaderColor',
        secondaryHeaderColor,
        defaultValue: defaultData.secondaryHeaderColor,
        level: DiagnosticLevel.debug,
      ),
    );
    properties.add(
      ColorProperty(
        'shadowColor',
        shadowColor,
        defaultValue: defaultData.shadowColor,
        level: DiagnosticLevel.debug,
      ),
    );
    properties.add(
      ColorProperty(
        'splashColor',
        splashColor,
        defaultValue: defaultData.splashColor,
        level: DiagnosticLevel.debug,
      ),
    );
    properties.add(
      ColorProperty(
        'unselectedWidgetColor',
        unselectedWidgetColor,
        defaultValue: defaultData.unselectedWidgetColor,
        level: DiagnosticLevel.debug,
      ),
    );
    // TYPOGRAPHY & ICONOGRAPHY
    properties.add(
      DiagnosticsProperty<IconThemeData>('iconTheme', iconTheme, level: DiagnosticLevel.debug),
    );
    properties.add(
      DiagnosticsProperty<IconThemeData>(
        'primaryIconTheme',
        primaryIconTheme,
        level: DiagnosticLevel.debug,
      ),
    );
    properties.add(
      DiagnosticsProperty<TextTheme>(
        'primaryTextTheme',
        primaryTextTheme,
        level: DiagnosticLevel.debug,
      ),
    );
    properties.add(
      DiagnosticsProperty<TextTheme>('textTheme', textTheme, level: DiagnosticLevel.debug),
    );
    properties.add(
      DiagnosticsProperty<Typography>(
        'typography',
        typography,
        defaultValue: defaultData.typography,
        level: DiagnosticLevel.debug,
      ),
    );
    // COMPONENT THEMES
    properties.add(
      DiagnosticsProperty<ActionIconThemeData>(
        'actionIconTheme',
        actionIconTheme,
        level: DiagnosticLevel.debug,
      ),
    );
    properties.add(
      DiagnosticsProperty<AppBarTheme>(
        'appBarTheme',
        appBarTheme,
        defaultValue: defaultData.appBarTheme,
        level: DiagnosticLevel.debug,
      ),
    );
    properties.add(
      DiagnosticsProperty<BadgeThemeData>(
        'badgeTheme',
        badgeTheme,
        defaultValue: defaultData.badgeTheme,
        level: DiagnosticLevel.debug,
      ),
    );
    properties.add(
      DiagnosticsProperty<MaterialBannerThemeData>(
        'bannerTheme',
        bannerTheme,
        defaultValue: defaultData.bannerTheme,
        level: DiagnosticLevel.debug,
      ),
    );
    properties.add(
      DiagnosticsProperty<BottomAppBarTheme>(
        'bottomAppBarTheme',
        bottomAppBarTheme,
        defaultValue: defaultData.bottomAppBarTheme,
        level: DiagnosticLevel.debug,
      ),
    );
    properties.add(
      DiagnosticsProperty<BottomNavigationBarThemeData>(
        'bottomNavigationBarTheme',
        bottomNavigationBarTheme,
        defaultValue: defaultData.bottomNavigationBarTheme,
        level: DiagnosticLevel.debug,
      ),
    );
    properties.add(
      DiagnosticsProperty<BottomSheetThemeData>(
        'bottomSheetTheme',
        bottomSheetTheme,
        defaultValue: defaultData.bottomSheetTheme,
        level: DiagnosticLevel.debug,
      ),
    );
    properties.add(
      DiagnosticsProperty<ButtonThemeData>(
        'buttonTheme',
        buttonTheme,
        level: DiagnosticLevel.debug,
      ),
    );
    properties.add(
      DiagnosticsProperty<CardThemeData>('cardTheme', cardTheme, level: DiagnosticLevel.debug),
    );
    properties.add(
      DiagnosticsProperty<CheckboxThemeData>(
        'checkboxTheme',
        checkboxTheme,
        defaultValue: defaultData.checkboxTheme,
        level: DiagnosticLevel.debug,
      ),
    );
    properties.add(
      DiagnosticsProperty<ChipThemeData>('chipTheme', chipTheme, level: DiagnosticLevel.debug),
    );
    properties.add(
      DiagnosticsProperty<DataTableThemeData>(
        'dataTableTheme',
        dataTableTheme,
        defaultValue: defaultData.dataTableTheme,
        level: DiagnosticLevel.debug,
      ),
    );
    properties.add(
      DiagnosticsProperty<DatePickerThemeData>(
        'datePickerTheme',
        datePickerTheme,
        defaultValue: defaultData.datePickerTheme,
        level: DiagnosticLevel.debug,
      ),
    );
    properties.add(
      DiagnosticsProperty<DialogThemeData>(
        'dialogTheme',
        dialogTheme,
        defaultValue: defaultData.dialogTheme,
        level: DiagnosticLevel.debug,
      ),
    );
    properties.add(
      DiagnosticsProperty<DividerThemeData>(
        'dividerTheme',
        dividerTheme,
        defaultValue: defaultData.dividerTheme,
        level: DiagnosticLevel.debug,
      ),
    );
    properties.add(
      DiagnosticsProperty<DrawerThemeData>(
        'drawerTheme',
        drawerTheme,
        defaultValue: defaultData.drawerTheme,
        level: DiagnosticLevel.debug,
      ),
    );
    properties.add(
      DiagnosticsProperty<DropdownMenuThemeData>(
        'dropdownMenuTheme',
        dropdownMenuTheme,
        defaultValue: defaultData.dropdownMenuTheme,
        level: DiagnosticLevel.debug,
      ),
    );
    properties.add(
      DiagnosticsProperty<ElevatedButtonThemeData>(
        'elevatedButtonTheme',
        elevatedButtonTheme,
        defaultValue: defaultData.elevatedButtonTheme,
        level: DiagnosticLevel.debug,
      ),
    );
    properties.add(
      DiagnosticsProperty<ExpansionTileThemeData>(
        'expansionTileTheme',
        expansionTileTheme,
        level: DiagnosticLevel.debug,
      ),
    );
    properties.add(
      DiagnosticsProperty<FilledButtonThemeData>(
        'filledButtonTheme',
        filledButtonTheme,
        defaultValue: defaultData.filledButtonTheme,
        level: DiagnosticLevel.debug,
      ),
    );
    properties.add(
      DiagnosticsProperty<FloatingActionButtonThemeData>(
        'floatingActionButtonTheme',
        floatingActionButtonTheme,
        defaultValue: defaultData.floatingActionButtonTheme,
        level: DiagnosticLevel.debug,
      ),
    );
    properties.add(
      DiagnosticsProperty<IconButtonThemeData>(
        'iconButtonTheme',
        iconButtonTheme,
        defaultValue: defaultData.iconButtonTheme,
        level: DiagnosticLevel.debug,
      ),
    );
    properties.add(
      DiagnosticsProperty<ListTileThemeData>(
        'listTileTheme',
        listTileTheme,
        defaultValue: defaultData.listTileTheme,
        level: DiagnosticLevel.debug,
      ),
    );
    properties.add(
      DiagnosticsProperty<MenuBarThemeData>(
        'menuBarTheme',
        menuBarTheme,
        defaultValue: defaultData.menuBarTheme,
        level: DiagnosticLevel.debug,
      ),
    );
    properties.add(
      DiagnosticsProperty<MenuButtonThemeData>(
        'menuButtonTheme',
        menuButtonTheme,
        defaultValue: defaultData.menuButtonTheme,
        level: DiagnosticLevel.debug,
      ),
    );
    properties.add(
      DiagnosticsProperty<MenuThemeData>(
        'menuTheme',
        menuTheme,
        defaultValue: defaultData.menuTheme,
        level: DiagnosticLevel.debug,
      ),
    );
    properties.add(
      DiagnosticsProperty<NavigationBarThemeData>(
        'navigationBarTheme',
        navigationBarTheme,
        defaultValue: defaultData.navigationBarTheme,
        level: DiagnosticLevel.debug,
      ),
    );
    properties.add(
      DiagnosticsProperty<NavigationDrawerThemeData>(
        'navigationDrawerTheme',
        navigationDrawerTheme,
        defaultValue: defaultData.navigationDrawerTheme,
        level: DiagnosticLevel.debug,
      ),
    );
    properties.add(
      DiagnosticsProperty<NavigationRailThemeData>(
        'navigationRailTheme',
        navigationRailTheme,
        defaultValue: defaultData.navigationRailTheme,
        level: DiagnosticLevel.debug,
      ),
    );
    properties.add(
      DiagnosticsProperty<OutlinedButtonThemeData>(
        'outlinedButtonTheme',
        outlinedButtonTheme,
        defaultValue: defaultData.outlinedButtonTheme,
        level: DiagnosticLevel.debug,
      ),
    );
    properties.add(
      DiagnosticsProperty<PopupMenuThemeData>(
        'popupMenuTheme',
        popupMenuTheme,
        defaultValue: defaultData.popupMenuTheme,
        level: DiagnosticLevel.debug,
      ),
    );
    properties.add(
      DiagnosticsProperty<ProgressIndicatorThemeData>(
        'progressIndicatorTheme',
        progressIndicatorTheme,
        defaultValue: defaultData.progressIndicatorTheme,
        level: DiagnosticLevel.debug,
      ),
    );
    properties.add(
      DiagnosticsProperty<RadioThemeData>(
        'radioTheme',
        radioTheme,
        defaultValue: defaultData.radioTheme,
        level: DiagnosticLevel.debug,
      ),
    );
    properties.add(
      DiagnosticsProperty<SearchBarThemeData>(
        'searchBarTheme',
        searchBarTheme,
        defaultValue: defaultData.searchBarTheme,
        level: DiagnosticLevel.debug,
      ),
    );
    properties.add(
      DiagnosticsProperty<SearchViewThemeData>(
        'searchViewTheme',
        searchViewTheme,
        defaultValue: defaultData.searchViewTheme,
        level: DiagnosticLevel.debug,
      ),
    );
    properties.add(
      DiagnosticsProperty<SegmentedButtonThemeData>(
        'segmentedButtonTheme',
        segmentedButtonTheme,
        defaultValue: defaultData.segmentedButtonTheme,
        level: DiagnosticLevel.debug,
      ),
    );
    properties.add(
      DiagnosticsProperty<SliderThemeData>(
        'sliderTheme',
        sliderTheme,
        level: DiagnosticLevel.debug,
      ),
    );
    properties.add(
      DiagnosticsProperty<SnackBarThemeData>(
        'snackBarTheme',
        snackBarTheme,
        defaultValue: defaultData.snackBarTheme,
        level: DiagnosticLevel.debug,
      ),
    );
    properties.add(
      DiagnosticsProperty<SwitchThemeData>(
        'switchTheme',
        switchTheme,
        defaultValue: defaultData.switchTheme,
        level: DiagnosticLevel.debug,
      ),
    );
    properties.add(
      DiagnosticsProperty<TabBarThemeData>(
        'tabBarTheme',
        tabBarTheme,
        level: DiagnosticLevel.debug,
      ),
    );
    properties.add(
      DiagnosticsProperty<TextButtonThemeData>(
        'textButtonTheme',
        textButtonTheme,
        defaultValue: defaultData.textButtonTheme,
        level: DiagnosticLevel.debug,
      ),
    );
    properties.add(
      DiagnosticsProperty<TextSelectionThemeData>(
        'textSelectionTheme',
        textSelectionTheme,
        defaultValue: defaultData.textSelectionTheme,
        level: DiagnosticLevel.debug,
      ),
    );
    properties.add(
      DiagnosticsProperty<TimePickerThemeData>(
        'timePickerTheme',
        timePickerTheme,
        defaultValue: defaultData.timePickerTheme,
        level: DiagnosticLevel.debug,
      ),
    );
    properties.add(
      DiagnosticsProperty<ToggleButtonsThemeData>(
        'toggleButtonsTheme',
        toggleButtonsTheme,
        level: DiagnosticLevel.debug,
      ),
    );
    properties.add(
      DiagnosticsProperty<TooltipThemeData>(
        'tooltipTheme',
        tooltipTheme,
        level: DiagnosticLevel.debug,
      ),
    );
    // DEPRECATED (newest deprecations at the bottom)
    properties.add(
      DiagnosticsProperty<ButtonBarThemeData>(
        'buttonBarTheme',
        buttonBarTheme,
        defaultValue: defaultData.buttonBarTheme,
        level: DiagnosticLevel.debug,
      ),
    );
    properties.add(
      ColorProperty(
        'dialogBackgroundColor',
        dialogBackgroundColor,
        defaultValue: defaultData.dialogBackgroundColor,
        level: DiagnosticLevel.debug,
      ),
    );
  }
}

/// A [CupertinoThemeData] that defers unspecified theme attributes to an
/// upstream Material [ThemeData].
///
/// This type of [CupertinoThemeData] is used by the Material [Theme] to
/// harmonize the [CupertinoTheme] with the material theme's colors and text
/// styles.
///
/// In the most basic case, [ThemeData]'s `cupertinoOverrideTheme` is null and
/// descendant Cupertino widgets' styling is derived from the Material theme.
///
/// To override individual parts of the Material-derived Cupertino styling,
/// `cupertinoOverrideTheme`'s construction parameters can be used.
///
/// To completely decouple the Cupertino styling from Material theme derivation,
/// another [CupertinoTheme] widget can be inserted as a descendant of the
/// Material [Theme]. On a [MaterialApp], this can be done using the `builder`
/// parameter on the constructor.
///
/// See also:
///
///  * [CupertinoThemeData], whose null constructor parameters default to
///    reasonable iOS styling defaults rather than harmonizing with a Material
///    theme.
///  * [Theme], widget which inserts a [CupertinoTheme] with this
///    [MaterialBasedCupertinoThemeData].
// This class subclasses CupertinoThemeData rather than composes one because it
// _is_ a CupertinoThemeData with partially altered behavior. e.g. its textTheme
// is from the superclass and based on the primaryColor but the primaryColor
// comes from the Material theme unless overridden.
class MaterialBasedCupertinoThemeData extends CupertinoThemeData {
  /// Create a [MaterialBasedCupertinoThemeData] based on a Material [ThemeData]
  /// and its `cupertinoOverrideTheme`.
  MaterialBasedCupertinoThemeData({required ThemeData materialTheme})
    : this._(
        materialTheme,
        (materialTheme.cupertinoOverrideTheme ?? const CupertinoThemeData()).noDefault(),
      );

  MaterialBasedCupertinoThemeData._(this._materialTheme, this._cupertinoOverrideTheme)
    : // Pass all values to the superclass so Material-agnostic properties
      // like barBackgroundColor can still behave like a normal
      // CupertinoThemeData.
      super.raw(
        _cupertinoOverrideTheme.brightness,
        _cupertinoOverrideTheme.primaryColor,
        _cupertinoOverrideTheme.primaryContrastingColor,
        _cupertinoOverrideTheme.textTheme,
        _cupertinoOverrideTheme.barBackgroundColor,
        _cupertinoOverrideTheme.scaffoldBackgroundColor,
        _cupertinoOverrideTheme.applyThemeToAll,
      );

  final ThemeData _materialTheme;
  final NoDefaultCupertinoThemeData _cupertinoOverrideTheme;

  @override
  Brightness get brightness => _cupertinoOverrideTheme.brightness ?? _materialTheme.brightness;

  @override
  Color get primaryColor =>
      _cupertinoOverrideTheme.primaryColor ?? _materialTheme.colorScheme.primary;

  @override
  Color get primaryContrastingColor =>
      _cupertinoOverrideTheme.primaryContrastingColor ?? _materialTheme.colorScheme.onPrimary;

  @override
  Color get scaffoldBackgroundColor =>
      _cupertinoOverrideTheme.scaffoldBackgroundColor ?? _materialTheme.scaffoldBackgroundColor;

  /// Copies the [ThemeData]'s `cupertinoOverrideTheme`.
  ///
  /// Only the specified override attributes of the [ThemeData]'s
  /// `cupertinoOverrideTheme` and the newly specified parameters are in the
  /// returned [CupertinoThemeData]. No derived attributes from iOS defaults or
  /// from cascaded Material theme attributes are copied.
  ///
  /// This [copyWith] cannot change the base Material [ThemeData]. To change the
  /// base Material [ThemeData], create a new Material [Theme] and use
  /// [ThemeData.copyWith] on the Material [ThemeData] instead.
  @override
  MaterialBasedCupertinoThemeData copyWith({
    Brightness? brightness,
    Color? primaryColor,
    Color? primaryContrastingColor,
    CupertinoTextThemeData? textTheme,
    Color? barBackgroundColor,
    Color? scaffoldBackgroundColor,
    bool? applyThemeToAll,
  }) {
    return MaterialBasedCupertinoThemeData._(
      _materialTheme,
      _cupertinoOverrideTheme.copyWith(
        brightness: brightness,
        primaryColor: primaryColor,
        primaryContrastingColor: primaryContrastingColor,
        textTheme: textTheme,
        barBackgroundColor: barBackgroundColor,
        scaffoldBackgroundColor: scaffoldBackgroundColor,
        applyThemeToAll: applyThemeToAll,
      ),
    );
  }

  @override
  CupertinoThemeData resolveFrom(BuildContext context) {
    // Only the cupertino override theme part will be resolved.
    // If the color comes from the material theme it's not resolved.
    return MaterialBasedCupertinoThemeData._(
      _materialTheme,
      _cupertinoOverrideTheme.resolveFrom(context),
    );
  }
}

/// A class for creating a Material theme with a color scheme based off of the
/// colors from a [CupertinoThemeData]. This is intended to be used only in the
/// case when a Material widget is unable to find a Material theme in the tree,
/// but is able to find a Cupertino theme. Most often this will occur when a
/// Material widget is used inside of a [CupertinoApp].
///
/// Besides the colors, this theme will use all the defaults from Material's
/// [ThemeData], so if further customization is needed, it is best to manually
/// add a Material [Theme] above the [CupertinoApp].
class CupertinoBasedMaterialThemeData {
  /// Creates a Material theme with a color scheme based off of the colors from
  /// a [CupertinoThemeData].
  CupertinoBasedMaterialThemeData({required CupertinoThemeData themeData})
    : materialTheme = ThemeData(
        colorScheme: ColorScheme.fromSeed(
          seedColor: themeData.primaryColor,
          brightness: themeData.brightness ?? Brightness.light,
          primary: themeData.primaryColor,
          onPrimary: themeData.primaryContrastingColor,
        ),
      );

  /// The Material theme data with colors based on an existing [CupertinoThemeData].
  final ThemeData materialTheme;
}

@immutable
class _IdentityThemeDataCacheKey {
  const _IdentityThemeDataCacheKey(this.baseTheme, this.localTextGeometry);

  final ThemeData baseTheme;
  final TextTheme localTextGeometry;

  // Using XOR to make the hash function as fast as possible (e.g. Jenkins is
  // noticeably slower).
  @override
  int get hashCode => identityHashCode(baseTheme) ^ identityHashCode(localTextGeometry);

  @override
  bool operator ==(Object other) {
    // We are explicitly ignoring the possibility that the types might not
    // match in the interests of speed.
    return other is _IdentityThemeDataCacheKey &&
        identical(other.baseTheme, baseTheme) &&
        identical(other.localTextGeometry, localTextGeometry);
  }
}

/// Cache of objects of limited size that uses the first in first out eviction
/// strategy (a.k.a least recently inserted).
///
/// The key that was inserted before all other keys is evicted first, i.e. the
/// one inserted least recently.
class _FifoCache<K, V> {
  _FifoCache(this._maximumSize) : assert(_maximumSize > 0);

  /// In Dart the map literal uses a linked hash-map implementation, whose keys
  /// are stored such that [Map.keys] returns them in the order they were
  /// inserted.
  final Map<K, V> _cache = <K, V>{};

  /// Maximum number of entries to store in the cache.
  ///
  /// Once this many entries have been cached, the entry inserted least recently
  /// is evicted when adding a new entry.
  final int _maximumSize;

  /// Returns the previously cached value for the given key, if available;
  /// if not, calls the given callback to obtain it first.
  V putIfAbsent(K key, V Function() loader) {
    assert(key != null);
    final V? result = _cache[key];
    if (result != null) {
      return result;
    }
    if (_cache.length == _maximumSize) {
      _cache.remove(_cache.keys.first);
    }
    return _cache[key] = loader();
  }
}

/// Defines the visual density of user interface components.
///
/// Density, in the context of a UI, is the vertical and horizontal
/// "compactness" of the components in the UI. It is unitless, since it means
/// different things to different UI components.
///
/// The default for visual densities is zero for both vertical and horizontal
/// densities, which corresponds to the default visual density of components in
/// the Material Design specification. It does not affect text sizes, icon
/// sizes, or padding values.
///
/// For example, for buttons, it affects the spacing around the child of the
/// button. For lists, it affects the distance between baselines of entries in
/// the list. For chips, it only affects the vertical size, not the horizontal
/// size.
///
/// Here are some examples of widgets that respond to density changes:
///
///  * [Checkbox]
///  * [Chip]
///  * [ElevatedButton]
///  * [IconButton]
///  * [InputDecorator] (which gives density support to [TextField], etc.)
///  * [ListTile]
///  * [MaterialButton]
///  * [OutlinedButton]
///  * [Radio]
///  * [RawMaterialButton]
///  * [TextButton]
///
/// See also:
///
///  * [ThemeData.visualDensity], where this property is used to specify the base
///    horizontal density of Material components.
///  * [Material design guidance on density](https://material.io/design/layout/applying-density.html).
@immutable
class VisualDensity with Diagnosticable {
  /// A const constructor for [VisualDensity].
  ///
  /// The [horizontal] and [vertical] arguments must be in the interval between
  /// [minimumDensity] and [maximumDensity], inclusive.
  const VisualDensity({this.horizontal = 0.0, this.vertical = 0.0})
    : assert(vertical <= maximumDensity),
      assert(vertical >= minimumDensity),
      assert(horizontal <= maximumDensity),
      assert(horizontal >= minimumDensity);

  /// The minimum allowed density.
  static const double minimumDensity = -4.0;

  /// The maximum allowed density.
  static const double maximumDensity = 4.0;

  /// The default profile for [VisualDensity] in [ThemeData].
  ///
  /// This default value represents a visual density that is less dense than
  /// either [comfortable] or [compact], and corresponds to density values of
  /// zero in both axes.
  static const VisualDensity standard = VisualDensity();

  /// The profile for a "comfortable" interpretation of [VisualDensity].
  ///
  /// Individual components will interpret the density value independently,
  /// making themselves more visually dense than [standard] and less dense than
  /// [compact] to different degrees based on the Material Design specification
  /// of the "comfortable" setting for their particular use case.
  ///
  /// It corresponds to a density value of -1 in both axes.
  static const VisualDensity comfortable = VisualDensity(horizontal: -1.0, vertical: -1.0);

  /// The profile for a "compact" interpretation of [VisualDensity].
  ///
  /// Individual components will interpret the density value independently,
  /// making themselves more visually dense than [standard] and [comfortable] to
  /// different degrees based on the Material Design specification of the
  /// "comfortable" setting for their particular use case.
  ///
  /// It corresponds to a density value of -2 in both axes.
  static const VisualDensity compact = VisualDensity(horizontal: -2.0, vertical: -2.0);

  /// Returns a [VisualDensity] that is adaptive based on the current platform
  /// on which the framework is executing, from [defaultTargetPlatform].
  ///
  /// When [defaultTargetPlatform] is a desktop platform, this returns
  /// [compact], and for other platforms, it returns a default-constructed
  /// [VisualDensity].
  ///
  /// See also:
  ///
  /// * [defaultDensityForPlatform] which returns a [VisualDensity] that is
  ///   adaptive based on the platform given to it.
  /// * [defaultTargetPlatform] which returns the platform on which the
  ///   framework is currently executing.
  static VisualDensity get adaptivePlatformDensity =>
      defaultDensityForPlatform(defaultTargetPlatform);

  /// Returns a [VisualDensity] that is adaptive based on the given [platform].
  ///
  /// For desktop platforms, this returns [compact], and for other platforms, it
  /// returns a default-constructed [VisualDensity].
  ///
  /// See also:
  ///
  /// * [adaptivePlatformDensity] which returns a [VisualDensity] that is
  ///   adaptive based on [defaultTargetPlatform].
  static VisualDensity defaultDensityForPlatform(TargetPlatform platform) {
    return switch (platform) {
      TargetPlatform.android || TargetPlatform.iOS || TargetPlatform.fuchsia => standard,
      TargetPlatform.linux || TargetPlatform.macOS || TargetPlatform.windows => compact,
    };
  }

  /// Copy the current [VisualDensity] with the given values replacing the
  /// current values.
  VisualDensity copyWith({double? horizontal, double? vertical}) {
    return VisualDensity(
      horizontal: horizontal ?? this.horizontal,
      vertical: vertical ?? this.vertical,
    );
  }

  /// The horizontal visual density of UI components.
  ///
  /// This property affects only the horizontal spacing between and within
  /// components, to allow for different UI visual densities. It does not affect
  /// text sizes, icon sizes, or padding values. The default value is 0.0,
  /// corresponding to the metrics specified in the Material Design
  /// specification. The value can range from [minimumDensity] to
  /// [maximumDensity], inclusive.
  ///
  /// See also:
  ///
  ///  * [ThemeData.visualDensity], where this property is used to specify the base
  ///    horizontal density of Material components.
  ///  * [Material design guidance on density](https://material.io/design/layout/applying-density.html).
  final double horizontal;

  /// The vertical visual density of UI components.
  ///
  /// This property affects only the vertical spacing between and within
  /// components, to allow for different UI visual densities. It does not affect
  /// text sizes, icon sizes, or padding values. The default value is 0.0,
  /// corresponding to the metrics specified in the Material Design
  /// specification. The value can range from [minimumDensity] to
  /// [maximumDensity], inclusive.
  ///
  /// See also:
  ///
  ///  * [ThemeData.visualDensity], where this property is used to specify the base
  ///    vertical density of Material components.
  ///  * [Material design guidance on density](https://material.io/design/layout/applying-density.html).
  final double vertical;

  /// The base adjustment in logical pixels of the visual density of UI components.
  ///
  /// The input density values are multiplied by a constant to arrive at a base
  /// size adjustment that fits Material Design guidelines.
  ///
  /// Individual components may adjust this value based upon their own
  /// individual interpretation of density.
  Offset get baseSizeAdjustment {
    // The number of logical pixels represented by an increase or decrease in
    // density by one. The Material Design guidelines say to increment/decrement
    // sizes in terms of four pixel increments.
    const double interval = 4.0;

    return Offset(horizontal, vertical) * interval;
  }

  /// Linearly interpolate between two densities.
  static VisualDensity lerp(VisualDensity a, VisualDensity b, double t) {
    if (identical(a, b)) {
      return a;
    }
    return VisualDensity(
      horizontal: lerpDouble(a.horizontal, b.horizontal, t)!,
      vertical: lerpDouble(a.vertical, b.vertical, t)!,
    );
  }

  /// Return a copy of [constraints] whose minimum width and height have been
  /// updated with the [baseSizeAdjustment].
  ///
  /// The resulting minWidth and minHeight values are clamped to not exceed the
  /// maxWidth and maxHeight values, respectively.
  BoxConstraints effectiveConstraints(BoxConstraints constraints) {
    assert(constraints.debugAssertIsValid());
    return constraints.copyWith(
      minWidth: clampDouble(
        constraints.minWidth + baseSizeAdjustment.dx,
        0.0,
        constraints.maxWidth,
      ),
      minHeight: clampDouble(
        constraints.minHeight + baseSizeAdjustment.dy,
        0.0,
        constraints.maxHeight,
      ),
    );
  }

  @override
  bool operator ==(Object other) {
    if (other.runtimeType != runtimeType) {
      return false;
    }
    return other is VisualDensity && other.horizontal == horizontal && other.vertical == vertical;
  }

  @override
  int get hashCode => Object.hash(horizontal, vertical);

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties.add(DoubleProperty('horizontal', horizontal, defaultValue: 0.0));
    properties.add(DoubleProperty('vertical', vertical, defaultValue: 0.0));
  }

  @override
  String toStringShort() {
    return '${super.toStringShort()}(h: ${debugFormatDouble(horizontal)}, v: ${debugFormatDouble(vertical)})';
  }
}

// BEGIN GENERATED TOKEN PROPERTIES - ColorScheme

// Do not edit by hand. The code between the "BEGIN GENERATED" and
// "END GENERATED" comments are generated from data in the Material
// Design token database by the script:
//   dev/tools/gen_defaults/bin/gen_defaults.dart.

// dart format off
const ColorScheme _colorSchemeLightM3 = ColorScheme(
  brightness: Brightness.light,
  primary: Color(0xFF6750A4),
  onPrimary: Color(0xFFFFFFFF),
  primaryContainer: Color(0xFFEADDFF),
  onPrimaryContainer: Color(0xFF4F378B),
  primaryFixed: Color(0xFFEADDFF),
  primaryFixedDim: Color(0xFFD0BCFF),
  onPrimaryFixed: Color(0xFF21005D),
  onPrimaryFixedVariant: Color(0xFF4F378B),
  secondary: Color(0xFF625B71),
  onSecondary: Color(0xFFFFFFFF),
  secondaryContainer: Color(0xFFE8DEF8),
  onSecondaryContainer: Color(0xFF4A4458),
  secondaryFixed: Color(0xFFE8DEF8),
  secondaryFixedDim: Color(0xFFCCC2DC),
  onSecondaryFixed: Color(0xFF1D192B),
  onSecondaryFixedVariant: Color(0xFF4A4458),
  tertiary: Color(0xFF7D5260),
  onTertiary: Color(0xFFFFFFFF),
  tertiaryContainer: Color(0xFFFFD8E4),
  onTertiaryContainer: Color(0xFF633B48),
  tertiaryFixed: Color(0xFFFFD8E4),
  tertiaryFixedDim: Color(0xFFEFB8C8),
  onTertiaryFixed: Color(0xFF31111D),
  onTertiaryFixedVariant: Color(0xFF633B48),
  error: Color(0xFFB3261E),
  onError: Color(0xFFFFFFFF),
  errorContainer: Color(0xFFF9DEDC),
  onErrorContainer: Color(0xFF8C1D18),
  background: Color(0xFFFEF7FF),
  onBackground: Color(0xFF1D1B20),
  surface: Color(0xFFFEF7FF),
  surfaceBright: Color(0xFFFEF7FF),
  surfaceContainerLowest: Color(0xFFFFFFFF),
  surfaceContainerLow: Color(0xFFF7F2FA),
  surfaceContainer: Color(0xFFF3EDF7),
  surfaceContainerHigh: Color(0xFFECE6F0),
  surfaceContainerHighest: Color(0xFFE6E0E9),
  surfaceDim: Color(0xFFDED8E1),
  onSurface: Color(0xFF1D1B20),
  surfaceVariant: Color(0xFFE7E0EC),
  onSurfaceVariant: Color(0xFF49454F),
  outline: Color(0xFF79747E),
  outlineVariant: Color(0xFFCAC4D0),
  shadow: Color(0xFF000000),
  scrim: Color(0xFF000000),
  inverseSurface: Color(0xFF322F35),
  onInverseSurface: Color(0xFFF5EFF7),
  inversePrimary: Color(0xFFD0BCFF),
  // The surfaceTint color is set to the same color as the primary.
  surfaceTint: Color(0xFF6750A4),
);

const ColorScheme _colorSchemeDarkM3 = ColorScheme(
  brightness: Brightness.dark,
  primary: Color(0xFFD0BCFF),
  onPrimary: Color(0xFF381E72),
  primaryContainer: Color(0xFF4F378B),
  onPrimaryContainer: Color(0xFFEADDFF),
  primaryFixed: Color(0xFFEADDFF),
  primaryFixedDim: Color(0xFFD0BCFF),
  onPrimaryFixed: Color(0xFF21005D),
  onPrimaryFixedVariant: Color(0xFF4F378B),
  secondary: Color(0xFFCCC2DC),
  onSecondary: Color(0xFF332D41),
  secondaryContainer: Color(0xFF4A4458),
  onSecondaryContainer: Color(0xFFE8DEF8),
  secondaryFixed: Color(0xFFE8DEF8),
  secondaryFixedDim: Color(0xFFCCC2DC),
  onSecondaryFixed: Color(0xFF1D192B),
  onSecondaryFixedVariant: Color(0xFF4A4458),
  tertiary: Color(0xFFEFB8C8),
  onTertiary: Color(0xFF492532),
  tertiaryContainer: Color(0xFF633B48),
  onTertiaryContainer: Color(0xFFFFD8E4),
  tertiaryFixed: Color(0xFFFFD8E4),
  tertiaryFixedDim: Color(0xFFEFB8C8),
  onTertiaryFixed: Color(0xFF31111D),
  onTertiaryFixedVariant: Color(0xFF633B48),
  error: Color(0xFFF2B8B5),
  onError: Color(0xFF601410),
  errorContainer: Color(0xFF8C1D18),
  onErrorContainer: Color(0xFFF9DEDC),
  background: Color(0xFF141218),
  onBackground: Color(0xFFE6E0E9),
  surface: Color(0xFF141218),
  surfaceBright: Color(0xFF3B383E),
  surfaceContainerLowest: Color(0xFF0F0D13),
  surfaceContainerLow: Color(0xFF1D1B20),
  surfaceContainer: Color(0xFF211F26),
  surfaceContainerHigh: Color(0xFF2B2930),
  surfaceContainerHighest: Color(0xFF36343B),
  surfaceDim: Color(0xFF141218),
  onSurface: Color(0xFFE6E0E9),
  surfaceVariant: Color(0xFF49454F),
  onSurfaceVariant: Color(0xFFCAC4D0),
  outline: Color(0xFF938F99),
  outlineVariant: Color(0xFF49454F),
  shadow: Color(0xFF000000),
  scrim: Color(0xFF000000),
  inverseSurface: Color(0xFFE6E0E9),
  onInverseSurface: Color(0xFF322F35),
  inversePrimary: Color(0xFF6750A4),
  // The surfaceTint color is set to the same color as the primary.
  surfaceTint: Color(0xFFD0BCFF),
);
// dart format on

// END GENERATED TOKEN PROPERTIES - ColorScheme


Instructions for the chapter (Generate content in English unless specified otherwise):
- Start with a clear heading (e.g., `# Chapter 5: VisualDensity
`). Use the provided concept name.

- If this is not the first chapter, begin with a brief transition from the previous chapter, referencing it with a proper Markdown link using its name.

- Begin with a high-level motivation explaining what problem this abstraction solves. Start with a central use case as a concrete example. The whole chapter should guide the reader to understand how to solve this use case. Make it very minimal and friendly to beginners.

- If the abstraction is complex, break it down into key concepts. Explain each concept one-by-one in a very beginner-friendly way.

- Explain how to use this abstraction to solve the use case. Give example inputs and outputs for code snippets (if the output isn't values, describe at a high level what will happen).

- Each code block should be BELOW 10 lines! If longer code blocks are needed, break them down into smaller pieces and walk through them one-by-one. Aggresively simplify the code to make it minimal. Use comments to skip non-important implementation details. Each code block should have a beginner friendly explanation right after it.

- Describe the internal implementation to help understand what's under the hood. First provide a non-code or code-light walkthrough on what happens step-by-step when the abstraction is called. It's recommended to use a simple sequenceDiagram with a dummy example - keep it minimal with at most 5 participants to ensure clarity. If participant name has space, use: `participant QP as Query Processing`. .

- Then dive deeper into code for the internal implementation with references to files. Provide example code blocks, but make them similarly simple and beginner-friendly. Explain.

- IMPORTANT: When you need to refer to other core abstractions covered in other chapters, ALWAYS use proper Markdown links like this: [Chapter Title](filename.md). Use the Complete Tutorial Structure above to find the correct filename and the chapter title. Translate the surrounding text.

- Use mermaid diagrams to illustrate complex concepts (```mermaid``` format). .

- Heavily use analogies and examples throughout to help beginners understand.

- End the chapter with a brief conclusion that summarizes what was learned and provides a transition to the next chapter. If there is a next chapter, use a proper Markdown link: [Next Chapter Title](next_chapter_filename).

- Ensure the tone is welcoming and easy for a newcomer to understand.

- Output *only* the Markdown content for this chapter.

Now, directly provide a super beginner-friendly Markdown output (DON'T need ```markdown``` tags):

2025-05-28 18:22:48,479 - INFO - RESPONSE: # Chapter 5: VisualDensity

Welcome back! In our previous chapters, we learned about [Theme](01_theme_.md) for applying design plans, [ThemeData](02_themedata_.md) as the detailed blueprint with standard styling, [ColorScheme](03_colorscheme_.md) for managing colors in a structured way, and [ThemeExtension](04_themeextension_.md) for adding your own custom styling data to the theme.

Now, let's talk about a concept that subtly affects the physical layout and spacing of some interactive UI elements: `VisualDensity`.

### What Problem Does `VisualDensity` Solve?

Imagine you're designing a screen with a list of items, each with a button next to it. On a large screen, you might want a bit more space between these list items and buttons so they feel less crowded. On a small phone screen, you might want them to be a little closer together to fit more information without making the text or icons smaller.

If you had to go into every list item, and every button, and manually adjust padding or margins based on the screen size or your desired "feel," that would be a lot of work!

`VisualDensity` solves this by providing a way to subtly adjust the spacing of certain interactive widgets (like buttons, checkboxes, input fields, and list tiles) without changing their core size or the size of the text and icons within them. It's like having a master setting that controls how "spacious" or "compact" interactive controls are throughout your app.

Think of it like adjusting the spacing between rows in a spreadsheet – the text in each cell stays the same size, but the row height changes to make the sheet feel more or less dense.

### What is `VisualDensity`?

`VisualDensity` is a **class** included in `ThemeData`. It holds two main properties:

*   `horizontal`: Controls the horizontal spacing.
*   `vertical`: Controls the vertical spacing.

These properties are typically `double` values that range from a minimum density (usually `-4.0` for very compact) to a maximum density (usually `4.0` for very spacious), with `0.0` being the default or "standard" density according to Material Design.

`VisualDensity` itself is **not** a widget or something you apply directly to a single button. You set it in your app's main [ThemeData](02_themedata_.md), and then compatible widgets within your app automatically adjust their spacing based on that setting.

Here are the few predefined `VisualDensity` settings you'll often use:

*   `VisualDensity.standard`: The default (`horizontal: 0.0`, `vertical: 0.0`).
*   `VisualDensity.compact`: A more compact setting (`horizontal: -2.0`, `vertical: -2.0`).
*   `VisualDensity.comfortable`: Somewhere between standard and compact (`horizontal: -1.0`, `vertical: -1.0`).
*   `VisualDensity.adaptivePlatformDensity`: Automatically chooses `compact` for desktop platforms (Linux, macOS, Windows) and `standard` for mobile platforms (Android, iOS, Fuchsia). This is often a good default to use.

### How to Use `VisualDensity`

You apply a `VisualDensity` setting by setting the `visualDensity` property in your app's `ThemeData`.

Here's a simple example demonstrating different `VisualDensity` settings:

```dart
import 'package:flutter/material.dart';

void main() {
  runApp(const MyApp());
}

class MyApp extends StatelessWidget {
  const MyApp({super.key});

  @override
  Widget build(BuildContext context) {
    return MaterialApp(
      title: 'Visual Density Demo',
      theme: ThemeData(
        primarySwatch: Colors.blue,
        // --- SET THE VISUAL DENSITY HERE ---
        visualDensity: VisualDensity.adaptivePlatformDensity,
        // visualDensity: VisualDensity.comfortable, // Try this one too!
        // visualDensity: VisualDensity.compact, // And this one!
        // visualDensity: VisualDensity.standard, // And the default
        useMaterial3: true,
      ),
      home: const HomeScreen(),
    );
  }
}

class HomeScreen extends StatelessWidget {
  const HomeScreen({super.key});

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        title: const Text('Visual Density Demo'),
      ),
      body: Center(
        child: Column(
          mainAxisAlignment: MainAxisAlignment.center,
          children: <Widget>[
            // These widgets are affected by VisualDensity:
            ElevatedButton(
              onPressed: () {},
              child: const Text('Elevated Button'),
            ),
            const SizedBox(height: 10),
            OutlinedButton(
              onPressed: () {},
              child: const Text('Outlined Button'),
            ),
            const SizedBox(height: 10),
            TextButton(
              onPressed: () {},
              child: const Text('Text Button'),
            ),
            const SizedBox(height: 10),
            Checkbox(value: true, onChanged: (bool? newValue) {}),
            const SizedBox(height: 10),
            Radio<int>(value: 1, groupValue: 1, onChanged: (int? newValue) {}),
            const SizedBox(height: 10),
            ListTile(
              leading: const Icon(Icons.star),
              title: const Text('List Tile Example'),
              onTap: () {},
            ),
            const SizedBox(height: 10),
            // NOTE: VisualDensity with TextFields primarily affects the padding
            // within the InputDecoration.
            const TextField(
              decoration: InputDecoration(
                labelText: 'Input Field',
                border: OutlineInputBorder(),
              ),
            ),
          ],
        ),
      ),
    );
  }
}

```

Run this code and try changing the `visualDensity` line in `ThemeData` to `VisualDensity.comfortable`, `VisualDensity.compact`, or `VisualDensity.standard`. You'll see how the spacing around the buttons, the list tile, and even the padding inside the text field changes subtly, making the UI feel more or less "spread out." Notice that the text and icon sizes don't change.

Using `VisualDensity.adaptivePlatformDensity` is a great way to make your app feel more natural on different devices right from the start. On a phone, interactive elements will have standard spacing (making them easier to tap with a finger), while on a desktop, they will be more compact (better mouse/keyboard interaction and fitting more on screen).

### Under the Hood: How Widgets Use `VisualDensity`

When you set `visualDensity` in `ThemeData`, it gets stored within the theme information that is available using `Theme.of(context)`. Compatible widgets, when they build themselves, look up the current theme's `visualDensity`.

These widgets then translate the `horizontal` and `vertical` density values into actual pixel adjustments. The conversion isn't a simple 1-to-1 mapping for every widget. As the documentation states, "a change of 1 or -1 in density corresponds to 4 logical pixels" as a rule of thumb, but widgets can interpret this differently based on their design.

Let's imagine how a simple button might use the `vertical` density:

```mermaid
sequenceDiagram
    participant Button as ElevatedButton
    participant BuildContext as BuildContext
    participant ThemeWidget as Theme Widget
    participant ThemeData as ThemeData
    participant VisualDensity as VisualDensity Object

    Button->>BuildContext: "Hey, I need the theme's visual density!"
    BuildContext->>ThemeWidget: "Nearest Theme, what's your data?"
    ThemeWidget->>ThemeData: Get ThemeData object
    ThemeData->>VisualDensity: Get VisualDensity object
    VisualDensity-->>ThemeData: Return VisualDensity object (e.g., v: -1.0)
    ThemeData-->>Button: Return VisualDensity object
    Button->>Button: Calculate vertical padding baseado em VisualDensity.vertical
    Button->>Button: Render button with calculated padding
```

This diagram shows the button checking the theme for the `VisualDensity` object. Once it gets it, it uses the `vertical` property (and possibly `horizontal`) to calculate how much extra space (padding) it should add or remove around its content.

Looking at the `ThemeData` code snippet you provided, you can see `visualDensity` is a property stored directly in `ThemeData`:

```dart
/// The density value for specifying the compactness of various UI components.
///
/// {@template flutter.material.themedata.visualDensity}
/// ... (documentation for VisualDensity) ...
/// {@endtemplate}
final VisualDensity visualDensity;
```

Then, in the `ThemeData.lerp` method, you can see that `VisualDensity` is interpolated when animating between themes:

```dart
// From packages/flutter/lib/src/material/theme_data.dart
static ThemeData lerp(ThemeData a, ThemeData b, double t) {
  // ... other properties ...
  return ThemeData.raw(
    // ... other properties ...
    visualDensity: VisualDensity.lerp(a.visualDensity, b.visualDensity, t),
    // ... other properties ...
  );
}
```

And if you were to look at the source code for, say, `ElevatedButton`, you would eventually find where it uses the `VisualDensity` from the theme (often through a MaterialButton parent class or a component theme) to adjust its internal layout constraints or padding. The `VisualDensity` class itself has an `baseSizeAdjustment` getter that provides a base offset in pixels based on the density values, and widgets can use this offset (or a modified version of it) when calculating their size. Here's the snippet from `VisualDensity` class provided:

```dart
/// The base adjustment in logical pixels of the visual density of UI components.
///
/// The input density values are multiplied by a constant to arrive at a base
/// size adjustment that fits Material Design guidelines.
/// ...
  Offset get baseSizeAdjustment {
    // The number of logical pixels represented by an increase or decrease in
    // density by one. The Material Design guidelines say to increment/decrement
    // sizes in terms of four pixel increments.
    const double interval = 4.0;

    return Offset(horizontal, vertical) * interval;
  }

/// Return a copy of [constraints] whose minimum width and height have been
  /// updated with the [baseSizeAdjustment].
  /// ...
  BoxConstraints effectiveConstraints(BoxConstraints constraints) {
    assert(constraints.debugAssertIsValid());
    return constraints.copyWith(
      minWidth: clampDouble(
        constraints.minWidth + baseSizeAdjustment.dx,
        0.0,
        constraints.maxWidth,
      ),
      minHeight: clampDouble(
        constraints.minHeight + baseSizeAdjustment.dy,
        0.0,
        constraints.maxHeight,
      ),
    );
  }
```
This shows how the `horizontal` and `vertical` values are converted into a pixel `Offset` and how that offset can be used to modify the minimum size constraints of a widget.

### Conclusion

`VisualDensity` is a simple but effective way to control the overall "compactness" of interactive UI elements in your Flutter app. By setting this property in your `ThemeData`, you can subtly adjust the spacing of compatible widgets globally, without changing their text or icon sizes. Using `VisualDensity.adaptivePlatformDensity` is a recommended practice for creating apps that feel at home on both mobile and desktop platforms.

Now that we've looked at `VisualDensity`, let's dive into another related concept that affects the size of interactive areas: [MaterialTapTargetSize](06_materialtaptargetsize_.md).

[MaterialTapTargetSize](06_materialtaptargetsize_.md)
2025-05-28 18:22:48,500 - INFO - PROMPT: 
Write a very beginner-friendly tutorial chapter (in Markdown format) for the project `flutter` about the concept: "MaterialTapTargetSize
". This is Chapter 6.

Concept Details:
- Name: MaterialTapTargetSize

- Description:
`MaterialTapTargetSize` is a simple setting within the `ThemeData` master plan that affects how interactive elements like buttons and checkboxes respond to taps. It helps ensure that these elements are easy to press, especially for users with accessibility needs. Think of it as a rule in the house blueprint that dictates how big light switches should be to make them easy to use.


Complete Tutorial Structure:
1. [Theme
](01_theme_.md)
2. [ThemeData
](02_themedata_.md)
3. [ColorScheme
](03_colorscheme_.md)
4. [ThemeExtension
](04_themeextension_.md)
5. [VisualDensity
](05_visualdensity_.md)
6. [MaterialTapTargetSize
](06_materialtaptargetsize_.md)
7. [DynamicSchemeVariant
](07_dynamicschemevariant_.md)

Context from previous chapters:
# Chapter 1: Theme

Welcome to the very first chapter on how to make your Flutter app look great! In this chapter, we're going to talk about a really important concept called `Theme`.

Imagine you're decorating a room. You pick a color palette, decide on the furniture style, and choose the overall "feel" you want the room to have. In Flutter, `Theme` is kind of like applying that master decoration plan (`ThemeData`) to a specific part of your app's screen.

### What Problem Does `Theme` Solve?

Think about building an app with lots of buttons, text, and other visual elements. If you had to set the color, font size, and style for *each* button and *each* piece of text individually, it would be a lot of work! And if you ever wanted to change your app's look (maybe switch from light mode to dark mode), you'd have to update *everything* manually. That sounds like a nightmare!

`Theme` solves this problem by letting you define a set of styles and colors in one place, and then easily apply those styles to different parts of your app. When you change the `Theme`, all the widgets that use that theme will automatically update their appearance. It's like changing the paint color for a whole room with just one click!

### What is `Theme`?

In Flutter, `Theme` is actually a **widget**. Widgets are the building blocks of Flutter apps. The `Theme` widget is a *special* kind of widget because it doesn't just show something on the screen; it influences how the widgets *below* it in the widget tree look.

When you place a `Theme` widget around other widgets, you're essentially telling all those widgets to follow the style rules defined in the `Theme`.

Here's a super simple peek at what using `Theme` looks like:

```dart
MaterialApp(
  home: Scaffold(
    body: Theme( // Here's the Theme widget!
      data: ThemeData( // We'll learn about this in the next chapter!
        primaryColor: Colors.blue,
        // Other style settings...
      ),
      child: Center(
        child: Text(
          'Hello, Themed Text!',
        ),
      ),
    ),
  ),
);
```

In this example, we're wrapping a `Center` widget (which contains a `Text` widget) with a `Theme` widget. We're giving the `Theme` some `data` (we'll dive deep into `ThemeData` in the next chapter!), and this `data` tells it how things like primary colors should look. Any widgets inside this `Theme` that use primary colors will now use the blue color we specified.

### How `Theme` Works (Under the Hood)

You might be wondering how a widget can "talk" to the widgets below it. Flutter uses a system called "Inherited Widgets" for this. `Theme` is an example of an inherited widget.

Think of an inherited widget like a shop sign that everyone in the building can see and use. When a widget needs some information (like what the theme color should be), it "looks up" the widget tree until it finds the nearest `Theme` widget. Then it uses the `data` from that `Theme` widget to style itself.

Here's a simplified idea of how a `Text` widget might get its color:

```mermaid
sequenceDiagram
    participant T as Text Widget
    participant B as BuildContext
    participant TH as Theme Widget
    participant TD as ThemeData

    T->>B: "Hey BuildContext, what's the current theme data?"
    B->>TH: "Nearest Theme widget, what's your data?"
    TH->>TD: "ThemeData object, what's the text color?"
    TD-->>TH: Returns text color
    TH-->>B: Returns text color
    B-->>T: Returns text color
    T->>T: Displays text with that color
```
This diagram shows a `Text` widget asking its `BuildContext` (which connects it to the widget tree) for the theme information. The `BuildContext` then finds the `Theme` widget, which provides the `ThemeData`. The `Text` widget can then use this `ThemeData` to decide how it should look.

The core of this mechanism is the `Theme.of(BuildContext context)` method. This is the standard way for any widget in Flutter to access the theme information from the nearest `Theme` ancestor in the tree. You'll see `Theme.of(context)` very often in Flutter code!

Looking at the `Theme.of` method in the `theme.dart` file, you can see how it uses `context.dependOnInheritedWidgetOfExactType<_InheritedTheme>()` to find the nearest `_InheritedTheme` (which is the internal widget Flutter uses for the `Theme`).

```dart
// From packages/flutter/lib/src/material/theme.dart
static ThemeData of(BuildContext context) {
  final _InheritedTheme? inheritedTheme =
      context.dependOnInheritedWidgetOfExactType<_InheritedTheme>();
  // ... other logic ...
  final ThemeData theme =
      inheritedTheme?.theme.data ??
      // ... fallback logic ...
      _kFallbackTheme;
  return ThemeData.localize(theme, theme.typography.geometryThemeFor(category));
}
```
Don't worry too much about all the details here; the key is that `dependOnInheritedWidgetOfExactType` is the magic that allows a widget to look up the tree and get information from a parent `Theme` widget.

### Applying `Theme` to a Part of Your App

You can use the `Theme` widget to apply different themes to different parts of your app. For example, you might have a standard theme for most of your app, but a specific section might have a slightly different look, perhaps highlighting a special feature.

```dart
// Imagine this is somewhere inside your app's build method
Column(
  children: [
    Text('Regular Text'), // This uses the main app theme
    Theme( // Applying a different theme here
      data: ThemeData(
        primaryColor: Colors.green, // A different color
      ),
      child: ElevatedButton( // This button will use the green primary color
        onPressed: () {},
        child: Text('Green Button'),
      ),
    ),
    Text('More Regular Text'), // This goes back to the main app theme
  ],
)
```

In this example, the `ElevatedButton` inside the second `Theme` widget will use the specified green color for its primary color, while the `Text` widgets will use the colors from the `ThemeData` higher up in the widget tree (likely from your `MaterialApp`).

This ability to apply themes to specific subtrees of your app gives you a lot of flexibility in designing your UI.

### Conclusion

In this chapter, we learned that `Theme` is a fundamental Flutter widget used to apply styles and visual configurations (`ThemeData`) to parts of your application. It helps you manage your app's look in a consistent and efficient way. We saw how `Theme` works using the concept of inherited widgets and how you can apply different themes to different sections of your app.

Now that you have a basic understanding of `Theme`, the next step is to explore what actually *goes inside* the `Theme` widget: the `ThemeData`.

[ThemeData](02_themedata_.md)
---
# Chapter 2: ThemeData

Welcome back! In the last chapter, we learned about the `Theme` widget, which is like a magical box that applies a design plan to parts of your Flutter app. But what exactly is that design plan? That's where `ThemeData` comes in!

### What Problem Does `ThemeData` Solve?

Imagine you're building a large app with many screens. Each screen has buttons, text, backgrounds, and more. If you had to manually pick colors and font styles for every single item on every single screen, it would be a huge mess! What if your company decided to change the main brand color? You'd have to go through your entire app, finding every place you used the old color and replacing it with the new one. This is time-consuming and prone to errors.

`ThemeData` solves this problem by being a central place where you define the overall look and feel of your app. It's like having a style guide for your entire application. Instead of styling each individual button, you define the *default* style for *all* buttons in your `ThemeData`. Then, every button in your app will automatically follow that default style. If you want to change the button style later, you just update the `ThemeData`, and all your buttons instantly change!

Think of it as choosing all the paint colors, furniture styles, and lighting fixtures for an entire house *before* you start decorating any specific room. `ThemeData` is that master plan.

### What is `ThemeData`?

`ThemeData` is **not** a widget. Unlike the `Theme` widget (which you place in your app's layout), `ThemeData` is simply a **Dart class** that holds a bunch of properties about your app's theme. These properties include things like:

*   **Colors:** The main colors used in your app, like the primary color, accent color, background color, etc. (We'll talk even more about colors in the next chapter on [ColorScheme](03_colorscheme_.md)!).
*   **Text Styles:** The default fonts, sizes, and weights for different types of text (headings, body text, captions).
*   **Component Themes:** Specific default styles for individual widgets like buttons (`ElevatedButtonThemeData`, `TextButtonThemeData`), App Bars (`AppBarTheme`), dialogs (`DialogThemeData`), and many more.

Here's a simple example of creating a basic `ThemeData`:

```dart
ThemeData myCustomTheme = ThemeData(
  primarySwatch: Colors.purple, // A collection of purple shades
  textTheme: TextTheme( // Defining text styles
    bodyMedium: TextStyle(fontSize: 16.0),
  ),
  elevatedButtonTheme: ElevatedButtonThemeData( // Styling the button
    style: ElevatedButton.styleFrom(
      backgroundColor: Colors.deepOrange, // Button color
      foregroundColor: Colors.white, // Text color on the button
    ),
  ),
);
```

In this code snippet, we're creating a `ThemeData` object named `myCustomTheme`. We're setting the `primarySwatch` to purple (which provides different shades of purple), defining a default style for body text, and setting a specific background and text color for `ElevatedButton`s.

### How to Use `ThemeData`

You typically use your `ThemeData` object within a `Theme` widget (like we saw in Chapter 1) or within the `theme` property of your `MaterialApp` (which is the most common way to set the theme for your entire app).

Here's how you'd apply the `myCustomTheme` from the previous example to your whole app using `MaterialApp`:

```dart
import 'package:flutter/material.dart';

void main() {
  runApp(const MyApp());
}

class MyApp extends StatelessWidget {
  const MyApp({super.key});

  @override
  Widget build(BuildContext context) {
    ThemeData myCustomTheme = ThemeData(
      primarySwatch: Colors.purple,
      textTheme: const TextTheme(
        bodyMedium: TextStyle(fontSize: 16.0),
      ),
      elevatedButtonTheme: ElevatedButtonThemeData(
        style: ElevatedButton.styleFrom(
          backgroundColor: Colors.deepOrange,
          foregroundColor: Colors.white,
        ),
      ),
    );

    return MaterialApp(
      title: 'Themed App',
      theme: myCustomTheme, // Applying our custom theme!
      home: Scaffold(
        appBar: AppBar(
          title: const Text('Home Screen'),
        ),
        body: Center(
          child: Column(
            mainAxisAlignment: MainAxisAlignment.center,
            children: [
              Text(
                'This text uses the default bodyMedium style.',
              ),
              const SizedBox(height: 20),
              ElevatedButton(
                onPressed: () {
                  // Do something
                },
                child: const Text('Styled Button'),
              ),
            ],
          ),
        ),
      ),
    );
  }
}
```

In this example, because we set `myCustomTheme` in the `theme` property of `MaterialApp`, the `AppBar` will likely pick colors based on the `primarySwatch` (purple), the first `Text` widget will use the `bodyMedium` style (16.0 font size), and the `ElevatedButton` will have a deep orange background and white text. All these styles are defined just once in our `ThemeData`!

### Default `ThemeData`

Flutter provides default light and dark themes out of the box. You can easily use these by setting the `theme` property of your `MaterialApp` to `ThemeData.light()` or `ThemeData.dark()`.

```dart
MaterialApp(
  title: 'Default Light Theme App',
  theme: ThemeData.light(), // Using the default light theme
  home: Scaffold(
    appBar: AppBar(title: Text('Light Theme')),
    body: Center(child: Text('Default colors and fonts')),
  ),
);
```

You can also start with a default theme and then modify specific parts using `copyWith`:

```dart
ThemeData lightThemeWithRedButtons = ThemeData.light().copyWith(
  elevatedButtonTheme: ElevatedButtonThemeData(
    style: ElevatedButton.styleFrom(
      backgroundColor: Colors.red, // Only change button color
      foregroundColor: Colors.white,
    ),
  ),
);

MaterialApp(
  title: 'Customized Light Theme App',
  theme: lightThemeWithRedButtons, // Using the customized light theme
  home: Scaffold(
    appBar: AppBar(title: Text('Custom Theme')),
    body: Center(
      child: ElevatedButton(
        onPressed: () {},
        child: Text('Red Button'),
      ),
    ),
  ),
);
```

This is a powerful way to quickly customize a few things while keeping the rest of the standard Material Design look.

### Under the Hood: `ThemeData.raw` and Interpolation

While you'll mostly use the main `ThemeData` constructor or `ThemeData.light()/dark()`, it's good to know that there's also a `ThemeData.raw` constructor. This constructor is used internally by Flutter, especially for smoothly transitioning between themes (like when switching from light to dark mode).

The `ThemeData.raw` constructor requires you to provide *every single* theme property. This seems like a lot, because it is! It's not meant for you to use directly very often. Its purpose is to allow for linear interpolation between two `ThemeData` objects when animating theme changes (which happens automatically with `AnimatedTheme`).

Here's a simplified idea of how animating themes might work:

```mermaid
sequenceDiagram
    participant AT as AnimatedTheme
    participant TD1 as ThemeData (Start)
    participant TD2 as ThemeData (End)
    participant TD_lerp as ThemeData (Interpolated)

    AT->>TD1: Get initial ThemeData
    AT->>TD2: Get final ThemeData
    AT->>AT: Start Animation (t from 0 to 1)
    loop For each animation step
        AT->>TD1: Get value (e.g. color)
        AT->>TD2: Get matching value (e.g. color)
        AT->>TD_lerp: Calculate interpolated value (lerpColor(color1, color2, t))
        TD_lerp-->>AT: Return interpolated value
    end
    AT->>AT: Pass interpolated ThemeData down widget tree
```

This diagram shows that when `AnimatedTheme` changes, it doesn't just swap `ThemeData` instantly. It uses the `ThemeData.lerp` method to calculate intermediate `ThemeData` objects based on how far the animation has progressed (`t`). This creates a smooth visual transition, for example, colors fading from one to another. The `ThemeData.raw` constructor is what `ThemeData.lerp` uses to construct these intermediate theme data objects.

Looking at the `ThemeData.lerp` code snippet, you can see it calls `Color.lerp`, `TextTheme.lerp`, and other `lerp` methods for individual theme properties:

```dart
// From packages/flutter/lib/src/material/theme_data.dart
static ThemeData lerp(ThemeData a, ThemeData b, double t) {
  if (identical(a, b)) {
    return a;
  }
  return ThemeData.raw(
    // ... other properties
    canvasColor: Color.lerp(a.canvasColor, b.canvasColor, t)!, // Interpolating colors
    // ... other properties
    textTheme: TextTheme.lerp(a.textTheme, b.textTheme, t), // Interpolating text styles
    // ... other properties
  );
}
```

This shows how `ThemeData.lerp` combines the individual properties from two themes based on the interpolation factor `t` (which goes from 0 to 1 during the animation) and uses `ThemeData.raw` to build the resulting interpolated theme.

### Conclusion

`ThemeData` is the blueprint for your app's visual design. By defining colors, text styles, and component appearances in a single place using `ThemeData`, you make your app's look consistent and easy to manage and update. You can use the default light or dark themes, create your own entirely, or modify existing ones. `ThemeData` also supports animating visual changes smoothly using interpolation, leveraging the `ThemeData.raw` constructor internally.

In the next chapter, we'll dive deeper into the concept of [ColorScheme](03_colorscheme_.md), which is a very important part of `ThemeData` and a modern way to manage your app's colors according to Material Design principles.

[ColorScheme](03_colorscheme_.md)
---
# Chapter 3: ColorScheme

Welcome back! In over the last two chapters, we explored `Theme` which is like applying a design plan, and `ThemeData`, which is the blueprint holding all the details of that plan, including colors, fonts, and component styles.

In this chapter, we're going to focus on a crucial part of `ThemeData`: the `ColorScheme`. Think of `ThemeData` as the overall architecture of your house, and `ColorScheme` as the meticulously selected paint palette for each room, ensuring all the colors work together harmoniously.

### What Problem Does `ColorScheme` Solve?

Setting colors for your app can feel like choosing paint for every single wall and ceiling in a large building. There are background colors, text colors, button colors, error colors, and so many more! If you just pick random colors for each part, your app can end up looking messy and inconsistent. Plus, choosing colors that work well for both light and dark modes, and ensuring enough contrast for accessibility, is a complex task.

`ColorScheme` solves this by defining a standard set of color "roles" based on Material Design principles. Instead of just picking a red, you pick an `error` color. Instead of picking a blue, you pick a `primary` color. This structured approach ensures that colors are used consistently throughout your app, that they look good together, and that they meet accessibility standards more easily.

It's like having a named box of crayons with roles: "main color," "accent color," "warning color," etc. When you need to color something, you pick the crayon whose role fits where the color will be used.

### What is `ColorScheme`?

Similar to `ThemeData`, `ColorScheme` is **not** a widget. It's a **Dart class** that's a collection of named `Color` properties. These properties represent different roles that colors play in a user interface according to Material Design. Some key roles include:

*   `primary`: The main color of your app, used for key elements like the AppBar and primary buttons.
*   `secondary`: A contrasting color, often used for less prominent elements like secondary buttons or filter chips.
*   `error`: The color used to indicate errors, typically red.
*   `surface`: The color used for backgrounds of components like cards and sheets.
*   `onPrimary`, `onSecondary`, `onError`, `onSurface`: These are crucial "on" colors. They are designed to have good contrast with their corresponding base color (e.g., `onPrimary` is for text or icons placed *on* a `primary` colored background).

Creating a simple `ColorScheme` might look like this:

```dart
ColorScheme myColorScheme = const ColorScheme(
  brightness: Brightness.light, // Is this a light or dark scheme?
  primary: Colors.blue,
  onPrimary: Colors.white, // White text on blue is easy to read
  secondary: Colors.green,
  onSecondary: Colors.white, // White text on green is easy to read
  error: Colors.red,
  onError: Colors.white, // White text on red is easy to read
  surface: Colors.white,
  onSurface: Colors.black, // Black text on whiteです easy to read
);
```

This example defines a basic light `ColorScheme` with blue as the primary color, green as the secondary, red for errors, and standard black and white for text and surfaces.

### How to Use `ColorScheme`

You usually don't use a `ColorScheme` object directly everywhere in your code. Instead, you include it as part of your `ThemeData`, and then components automatically pick up the colors they need from the theme.

The most common way to set your app's `ColorScheme` is within the `colorScheme` property of your `ThemeData` when creating it:

```dart
import 'package:flutter/material.dart';

void main() {
  runApp(const MyApp());
}

class MyApp extends StatelessWidget {
  const MyApp({super.key});

  @override
  Widget build(BuildContext context) {
    ColorScheme myColorScheme = const ColorScheme(
      brightness: Brightness.light,
      primary: Colors.deepPurple, // Let's use deep purple!
      onPrimary: Colors.white,
      secondary: Colors.teal, // And teal for secondary
      onSecondary: Colors.white,
      error: Colors.redAccent, // A slightly different red
      onError: Colors.black,
      surface: Colors.grey, // A light grey surface
      onSurface: Colors.black87,
    );

    return MaterialApp(
      title: 'ColorScheme App',
      theme: ThemeData(
        colorScheme: myColorScheme, // Using our custom ColorScheme!
        useMaterial3: true, // Make sure to use Material 3 for the full ColorScheme
      ),
      home: Scaffold(
        appBar: AppBar(
          title: const Text('Home Screen'),
          // AppBar often uses the primary color
          backgroundColor: Theme.of(context).colorScheme.primary,
          foregroundColor: Theme.of(context).colorScheme.onPrimary, // Use onPrimary for text/icons
        ),
        body: Center(
          child: Column(
            mainAxisAlignment: MainAxisAlignment.center,
            children: [
              Text(
                'Primary Color Example',
                style: TextStyle(color: Theme.of(context).colorScheme.primary),
              ),
              const SizedBox(height: 20),
              ElevatedButton(
                onPressed: () {
                  // Do something
                },
                // ElevatedButton often uses primary/onPrimary for its default style
                child: const Text('Primary Button'),
              ),
              const SizedBox(height: 20),
              Text(
                'Secondary Color Example',
                style: TextStyle(color: Theme.of(context).colorScheme.secondary),
              ),
              const SizedBox(height: 20),
              FloatingActionButton(
                onPressed: () {
                  // Do something else
                },
                backgroundColor: Theme.of(context).colorScheme.secondary, // FAB often uses secondary
                foregroundColor: Theme.of(context).colorScheme.onSecondary, // Use onSecondary for icon
                child: const Icon(Icons.add),
              ),
              const SizedBox(height: 20),
              Text(
                'Error Color Example',
                style: TextStyle(color: Theme.of(context).colorScheme.error),
              ),
            ],
          ),
        ),
      ),
    );
  }
}
```

In this slightly longer (but broken down) example:

1.  We create a `ColorScheme` object with specific colors for different roles.
2.  We set this `ColorScheme` to the `colorScheme` property of our `ThemeData`. We also set `useMaterial3: true` because Material 3 heavily relies on the detailed `ColorScheme` roles.
3.  Inside the `Scaffold` and its widgets, we access the `ColorScheme` using `Theme.of(context).colorScheme`.
4.  We explicitly show how some widgets (like `AppBar`, `ElevatedButton`, and `FloatingActionButton`) *often* use specific `ColorScheme` roles for their default appearance. You can manually apply these, but often the widgets themselves will pick them up automatically if not overridden.

Using `ColorScheme` this way centralizes your color definitions and makes it easy to understand how colors should be used throughout your UI.

### Generating `ColorScheme` from a Seed Color

Manually picking all those colors can still be a lot! Fortunately, Material Design 3 provides a powerful way to generate an entire `ColorScheme` from just a single "seed" color. This ensures that all the generated colors are harmonious and meet accessibility standards.

You can use the `ColorScheme.fromSeed` factory constructor:

```dart
import 'package:flutter/material.dart';

void main() {
  runApp(const MyApp());
}

class MyApp extends StatelessWidget {
  const MyApp({super.key});

  @override
  Widget build(BuildContext context) {
    return MaterialApp(
      title: 'Generated ColorScheme App',
      theme: ThemeData(
        // Generate a light ColorScheme from a blue seed color
        colorScheme: ColorScheme.fromSeed(
          seedColor: Colors.blue,
          brightness: Brightness.light,
        ),
        useMaterial3: true,
      ),
      darkTheme: ThemeData(
        // Generate a dark ColorScheme from the same blue seed color
        colorScheme: ColorScheme.fromSeed(
          seedColor: Colors.blue,
          brightness: Brightness.dark,
        ),
        useMaterial3: true,
      ),
      home: Scaffold(
        appBar: AppBar(
          title: const Text('Home Screen'),
        ),
        body: Center(
          child: Column(
            mainAxisAlignment: MainAxisAlignment.center,
            children: [
              Text(
                'Text using primary color',
                style: TextStyle(color: Theme.of(context).colorScheme.primary),
              ),
              const SizedBox(height: 20),
              ElevatedButton(
                onPressed: () {},
                child: const Text('Button'),
              ),
              const SizedBox(height: 20),
              FloatingActionButton(
                onPressed: () {},
                child: const Icon(Icons.add),
              ),
            ],
          ),
        ),
      ),
    );
  }
}
```

In this example:

1.  We use `ColorScheme.fromSeed` with `Colors.blue` to generate a complete `ColorScheme` for both the light and dark themes.
2.  Flutter's Material library handles generating all the roles (primary, secondary, surface, etc.) based on that seed color, ensuring they work well together and meet accessibility standards.
3.  We see that the `AppBar`, `ElevatedButton`, and `FloatingActionButton` automatically pick up the colors from the generated `ColorScheme` roles.

This is the recommended and easiest way to get a consistent and accessible color palette for your app using Material Design 3.

### Under the Hood: `ColorScheme` Generation and Interpolation

How does `ColorScheme.fromSeed` work its magic? Flutter uses a library called `material_color_utilities`. This library implements the Material Design 3 color system, which is based on creating "tonal palettes" from a seed color.

Here's a simplified idea of what happens when you use `ColorScheme.fromSeed`:

```mermaid
sequenceDiagram
    participant App as Your App Code
    participant CSSeed as ColorScheme.fromSeed
    participant MCU as material_color_utilities
    participant CS as ColorScheme Object

    App->>CSSeed: Call ColorScheme.fromSeed(seedColor:...)
    CSSeed->>MCU: Pass seed color and brightness
    MCU->>MCU: Generate tonal palettes based on seed color
    MCU->>MCU: Map tonal palette colors to ColorScheme roles (primary, secondary, surface, etc.)
    MCU-->>CSSeed: Return calculated colors for each role
    CSSeed->>CS: Create new ColorScheme object with calculated colors
    CSSeed-->>App: Return the new ColorScheme object

```

This diagram shows that `ColorScheme.fromSeed` delegates the heavy lifting of color generation to the `material_color_utilities` library. This library takes the seed color, analyzes its properties (like hue and chroma), and generates related colors across different tones that form a harmonious palette. It then assigns these generated colors to the various `ColorScheme` roles.

Looking at the code snippet from `colorscheme.dart`, you can see the `_buildDynamicScheme` method being called, which comes from the `material_color_utilities` library:

```dart
// From packages/flutter/lib/src/material/color_scheme.dart
  factory ColorScheme.fromSeed({
    required Color seedColor,
    Brightness brightness = Brightness.light,
    DynamicSchemeVariant dynamicSchemeVariant = DynamicSchemeVariant.tonalSpot,
    double contrastLevel = 0.0,
    // ... other parameters for overrides
  }) {
    final DynamicScheme scheme = _buildDynamicScheme(
      brightness,
      seedColor,
      dynamicSchemeVariant,
      contrastLevel,
    );

    return ColorScheme(
      primary: primary ?? Color(MaterialDynamicColors.primary.getArgb(scheme)),
      onPrimary: onPrimary ?? Color(MaterialDynamicColors.onPrimary.getArgb(scheme)),
      // ... other ColorScheme roles are set here using colors from the scheme
    );
  }

// (Later in the same file)
static DynamicScheme _buildDynamicScheme(
    Brightness brightness,
    Color seedColor,
    DynamicSchemeVariant schemeVariant,
    double contrastLevel,
  ) {
    final bool isDark = brightness == Brightness.dark;
    final Hct sourceColor = Hct.fromInt(seedColor.value);
    return switch (schemeVariant) {
      DynamicSchemeVariant.tonalSpot => SchemeTonalSpot( // One of the generation algorithms
        sourceColorHct: sourceColor,
        isDark: isDark,
        contrastLevel: contrastLevel,
      ),
      // ... other variants
    };
  }
```

This confirms that `fromSeed` uses an external library (`material_color_utilities`, imported at the top as `MaterialDynamicColors`, `DynamicScheme`, `Hct`, etc.) to build the underlying color `scheme` and then uses colors derived from that scheme to populate the `ColorScheme` properties like `primary` and `onPrimary`.

Just like `ThemeData`, `ColorScheme` also supports smooth transitions between different color schemes using the `ColorScheme.lerp` method internally, which is used when animating theme changes (for example, with `AnimatedTheme`).

```dart
// From packages/flutter/lib/src/material/color_scheme.dart
static ColorScheme lerp(ColorScheme a, ColorScheme b, double t) {
  if (identical(a, b)) {
    return a;
  }
  return ColorScheme(
    brightness: t < 0.5 ? a.brightness : b.brightness,
    primary: Color.lerp(a.primary, b.primary, t)!, // Lerping individual colors
    onPrimary: Color.lerp(a.onPrimary, b.onPrimary, t)!,
    // ... other color properties are lerped
  );
}
```

This shows that the interpolation between two `ColorScheme` objects is done by linearly interpolating each individual color property within the scheme.

### Conclusion

`ColorScheme` is a powerful way to manage your app's color palette in a structured, consistent, and accessible manner. It defines named roles for colors, making it easier to apply and update your app's look. The recommended approach in Material Design 3 is to generate your `ColorScheme` from a single seed color using `ColorScheme.fromSeed`, which leverages the `material_color_utilities` library to create a harmonious and accessible palette. `ColorScheme` is a key part of your `ThemeData` and is automatically used by many Flutter Material widgets.

Now that you understand how `ColorScheme` gives structure to your app's colors within the `ThemeData`, we'll look at how you can add your *own* custom data to the theme with [ThemeExtension](04_themeextension_.md).

[ThemeExtension](04_themeextension_.md)
---
# Chapter 4: ThemeExtension

Welcome back! In our previous chapters, we learned that the [Theme](01_theme_.md) widget applies a design plan, [ThemeData](02_themedata_.md) is that detailed plan holding all the standard styling information (like fonts and component styles), and [ColorScheme](03_colorscheme_.md) helps us manage colors for different UI roles within that plan.

But what if your app needs some custom styling information that isn't covered by the standard `ThemeData` properties or `ColorScheme` roles? Imagine you have a specific type of card in your app that always needs a unique gradient background and a particular size setting, and you want to define this rule in your theme so all these special cards use the same style consistently. The standard `ThemeData` doesn't have a specific property for "my special card's gradient."

That's where `ThemeExtension` comes in!

### What Problem Does `ThemeExtension` Solve?

The standard `ThemeData` comes with a lot of properties to cover common styling needs for Material Design. However, every app is unique, and you might have custom visual elements or specific styling rules that don't fit neatly into the predefined categories like `primaryColor`, `textTheme.bodyMedium`, or `cardTheme`.

If you couldn't add custom properties to your theme, you'd have to define these unique styles manually every time you used that special element throughout your app. This leads to code duplication, makes it difficult to maintain consistency, and makes changing that special style a tedious process (just like changing the brand color without using `ThemeData`!).

`ThemeExtension` solves this by allowing you to add **your own custom data** to the existing `ThemeData` object. It's like adding a dedicated section to your house blueprint for unique features like a custom-designed mailbox color or a specific pattern for floor tiles in one area, features that aren't in the standard building code or typical house plans.

### What is `ThemeExtension`?

`ThemeExtension` is an **abstract class** that you **subclass** (create your own version of) to define your custom theme properties. You create your own class that `extends ThemeExtension` and put whatever properties you need inside it – like `Color`s, `TextStyle`s, `double`s, or even other simple data types.

Your custom `ThemeExtension` class must implement two methods:

1.  `copyWith`: This method is used to create a copy of your extension, optionally changing some properties. This is similar to how `ThemeData` has a `copyWith` method.
2.  `lerp`: This method is crucial for smoothly animating between two different versions of your custom theme data. It stands for "linear interpolation," a common technique in animation. It takes another `ThemeExtension` of the same type and a `double t` (which goes from 0 to 1 during the animation) and calculates an intermediate state of your custom properties.

Let's create a simple custom theme extension for that "special card":

```dart
import 'package:flutter/material.dart';

// 1. Create your own class that extends ThemeExtension
class SpecialCardTheme extends ThemeExtension<SpecialCardTheme> {
  // 2. Define your custom properties
  const SpecialCardTheme({
    required this.gradientColors,
    required this.borderCurve,
  });

  final List<Color> gradientColors;
  final double borderCurve; // Just a simplified example for radius

  // 3. Implement copyWith - copy all properties
  @override
  SpecialCardTheme copyWith({
    List<Color>? gradientColors,
    double? borderCurve,
  }) {
    return SpecialCardTheme(
      gradientColors: gradientColors ?? this.gradientColors,
      borderCurve: borderCurve ?? this.borderCurve,
    );
  }

  // 4. Implement lerp - interpolate between values
  @override
  SpecialCardTheme lerp(ThemeExtension<SpecialCardTheme>? other, double t) {
    if (other is! SpecialCardTheme) {
      return this; // Return this if 'other' is not the same type or is null
    }
    return SpecialCardTheme(
      // Here we smoothly transition the gradient colors using Color.lerp
      // Interpolating a list of colors requires interpolating each color
      gradientColors: List.generate(
        gradientColors.length,
        (index) => Color.lerp(
              gradientColors[index],
              other.gradientColors[index],
              t,
            ) ?? // Provide a fallback if lerp is null (unlikely with non-null colors)
            gradientColors[index],
      ),
      // Here we smoothly transition the double value
      borderCurve: t < 0.5 ? borderCurve : other.borderCurve, // Simplified lerp for double
      // For a real double interpolation, use lerpDouble from dart:ui
      // borderCurve: lerpDouble(borderCurve, other.borderCurve, t)!,
    );
  }

  // Optional: Add operator == and hashCode for equality checks
  // This is good practice but not strictly required by ThemeExtension interface
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is SpecialCardTheme &&
          runtimeType == other.runtimeType &&
          listEquals(gradientColors, other.gradientColors) && // Need listEquals for list
          borderCurve == other.borderCurve;

  @override
  int get hashCode => hashValues(hashList(gradientColors), borderCurve); // Need hashList for list
}
```

This is our custom `ThemeExtension` class, `SpecialCardTheme`. It defines a list of colors for a gradient and a double for a border curvature. We've added the necessary `copyWith` and `lerp` methods.

### How to Use `ThemeExtension`

Once you've defined your custom `ThemeExtension` class, you need to add it to your `ThemeData`. You do this using the `extensions` property when creating or copying a `ThemeData`. The `extensions` property takes an `Iterable` (like a `List`) of your custom theme extension objects.

Here's how you'd add `SpecialCardTheme` to your app's `ThemeData`:

```dart
import 'package:flutter/material.dart';
// Assuming your SpecialCardTheme class is in 'special_card_theme.dart'
import 'special_card_theme.dart';

void main() {
  runApp(const MyApp());
}

class MyApp extends StatelessWidget {
  const MyApp({super.key});

  @override
  Widget build(BuildContext context) {
    // Define your custom theme extension instance
    const SpecialCardTheme specialTheme = SpecialCardTheme(
      gradientColors: [Colors.orange, Colors.red],
      borderCurve: 16.0,
    );

    return MaterialApp(
      title: 'Theme Extension App',
      theme: ThemeData(
        primarySwatch: Colors.blue,
        useMaterial3: true,
        // Add your custom extension to the extensions list
        extensions: <ThemeExtension<dynamic>>[
          specialTheme,
        ],
      ),
      home: const HomeScreen(),
    );
  }
}

class HomeScreen extends StatelessWidget {
  const HomeScreen({super.key});

  @override
  Widget build(BuildContext context) {
    // Access the custom theme extension using Theme.of(context).extension<YourClassName>()
    final specialCardTheme = Theme.of(context).extension<SpecialCardTheme>()!;

    return Scaffold(
      appBar: AppBar(
        title: const Text('Home with Custom Theme'),
      ),
      body: Center(
        child: Column(
          mainAxisAlignment: MainAxisAlignment.center,
          children: [
            Text(
              'Standard Text based on ThemeData',
              style: Theme.of(context).textTheme.bodyMedium,
            ),
            const SizedBox(height: 20),
            // Use the properties from your custom extension
            Container(
              width: 200,
              height: 100,
              decoration: BoxDecoration(
                // Accessing custom gradient colors
                gradient: LinearGradient(colors: specialCardTheme.gradientColors),
                borderRadius: BorderRadius.circular(specialCardTheme.borderCurve), // Accessing custom curve
              ),
              child: const Center(
                child: Text(
                  'This is the Special Card!',
                  style: TextStyle(color: Colors.white),
                ),
              ),
            ),
          ],
        ),
      ),
    );
  }
}
```

In this example:

1.  We create an instance of our `SpecialCardTheme` with specific values.
2.  We add this instance to the `extensions` list in our `ThemeData`.
3.  In a widget (`HomeScreen`), we access the theme using `Theme.of(context)`.
4.  We retrieve our specific custom extension using `.extension<SpecialCardTheme>()`. Note the `<SpecialCardTheme>` part – this tells Flutter *which* type of extension to look for. The `!` at the end asserts that we expect it to exist.
5.  We then use the properties (`gradientColors` and `borderCurve`) from the retrieved `specialCardTheme` object to style our `Container` (representing the special card).

Now, if you wanted to change the gradient or border curvature of *all* your "special cards," you just need to update the `SpecialCardTheme` instance provided in your `MaterialApp`'s `ThemeData`.

### Under the Hood: Adding and Retrieving Extensions

When you add your custom `ThemeExtension`s to the `extensions` list in `ThemeData`, Flutter stores them internally in a `Map`. The key of this map is the **type** of your `ThemeExtension` (like `SpecialCardTheme`), and the value is the instance of your extension.

When you call `Theme.of(context).extension<YourCustomExtension>()`, Flutter does the following:

1.  It finds the nearest `ThemeData` in the widget tree (as we saw in Chapter 1).
2.  It looks inside that `ThemeData`'s internal `extensions` map.
3.  It uses the `Type` of your custom extension (`YourCustomExtension`) as the key to find the corresponding instance in the map.
4.  It returns that instance (or `null` if no extension of that type is found).

Here's a super simplified sequence diagram showing the process of retrieving a `ThemeExtension`:

```mermaid
sequenceDiagram
    participant Widget as Your Custom Widget
    participant BuildContext as BuildContext
    participant ThemeWidget as Theme Widget
    participant ThemeData as ThemeData
    participant ExtMap as Internal Extensions Map
    participant CustomExt as Your Custom Extension Object

    Widget->>BuildContext: "Hey, I need the theme extension of type MyCustomExt!"
    BuildContext->>ThemeWidget: "Nearest Theme, what's your data?"
    ThemeWidget->>ThemeData: Get ThemeData object
    ThemeData->>ExtMap: "Is there an extension with key 'MyCustomExt'?"
    ExtMap-->>ThemeData: Yes, here's the MyCustomExt object.
    ThemeData-->>Widget: Return the MyCustomExt object.
    Widget->>Widget: Use the custom properties from the object.
```

This shows how your custom extension objects are stored within the `ThemeData` and retrieved using their type as the identifier.

Looking at the `ThemeData` code snippet provided in the context, you can see the `extensions` property is a `Map<Object, ThemeExtension<dynamic>>`:

```dart
/// Arbitrary additions to this theme.
///
/// To define extensions, pass an [Iterable] containing one or more [ThemeExtension]
/// subclasses to [ThemeData.new] or [copyWith].
///
/// To obtain an extension, use [extension].
/// ...
final Map<Object, ThemeExtension<dynamic>> extensions;

/// Used to obtain a particular [ThemeExtension] from [extensions].
///
/// Obtain with `Theme.of(context).extension<MyThemeExtension>()`.
/// ...
T? extension<T>() => extensions[T] as T?; // This is where it looks up by type T
```

The `extension<T>()` method directly accesses the `extensions` map using `T` as the key. The `<dynamic>` in the map definition just means it can hold any type of `ThemeExtension`.

The `lerp` method in `ThemeData` also handles interpolating themes that have extensions. It calls the `lerp` method **you defined** on each corresponding extension in the two themes being interpolated:

```dart
// From packages/flutter/lib/src/material/theme_data.dart
  static Map<Object, ThemeExtension<dynamic>> _lerpThemeExtensions(
    ThemeData a,
    ThemeData b,
    double t,
  ) {
    // Lerp [a].
    final Map<Object, ThemeExtension<dynamic>> newExtensions = a.extensions.map((
      Object id,
      ThemeExtension<dynamic> extensionA,
    ) {
      final ThemeExtension<dynamic>? extensionB = b.extensions[id];
      // Calls the lerp method you implemented in your custom class!
      return MapEntry<Object, ThemeExtension<dynamic>>(id, extensionA.lerp(extensionB, t));
    });
    // Add [b]-only extensions.
    newExtensions.addEntries(
      b.extensions.entries.where(
        (MapEntry<Object, ThemeExtension<dynamic>> entry) => !a.extensions.containsKey(entry.key),
      ),
    );

    return newExtensions;
  }
```

This snippet shows that `ThemeData.lerp` iterates through the extensions in the first theme (`a`), finds the matching extension in the second theme (`b`), and calls **your** `lerp` method on that pair (`extensionA.lerp(extensionB, t)`). This is why correctly implementing `lerp` in your `ThemeExtension` subclass is essential for enabling smooth theme transitions.

### Conclusion

`ThemeExtension` is a powerful mechanism that allows you to extend `ThemeData` with your own custom properties, going beyond the standard Material Design configurations. By defining your properties in a custom `ThemeExtension` subclass and adding it to your `ThemeData`, you create a central source of truth for unique styling rules in your app, promoting consistency, maintainability, and enabling smooth animations between different versions of your custom theme data.

With your understanding of `Theme`, `ThemeData`, `ColorScheme`, and now `ThemeExtension`, you're well on your way to creating beautifully consistent and well-structured Flutter UIs! Next, we'll briefly touch upon [VisualDensity](05_visualdensity_.md), which controls the compactness of interactive elements.

[VisualDensity](05_visualdensity_.md)
---
# Chapter 5: VisualDensity

Welcome back! In our previous chapters, we learned about [Theme](01_theme_.md) for applying design plans, [ThemeData](02_themedata_.md) as the detailed blueprint with standard styling, [ColorScheme](03_colorscheme_.md) for managing colors in a structured way, and [ThemeExtension](04_themeextension_.md) for adding your own custom styling data to the theme.

Now, let's talk about a concept that subtly affects the physical layout and spacing of some interactive UI elements: `VisualDensity`.

### What Problem Does `VisualDensity` Solve?

Imagine you're designing a screen with a list of items, each with a button next to it. On a large screen, you might want a bit more space between these list items and buttons so they feel less crowded. On a small phone screen, you might want them to be a little closer together to fit more information without making the text or icons smaller.

If you had to go into every list item, and every button, and manually adjust padding or margins based on the screen size or your desired "feel," that would be a lot of work!

`VisualDensity` solves this by providing a way to subtly adjust the spacing of certain interactive widgets (like buttons, checkboxes, input fields, and list tiles) without changing their core size or the size of the text and icons within them. It's like having a master setting that controls how "spacious" or "compact" interactive controls are throughout your app.

Think of it like adjusting the spacing between rows in a spreadsheet – the text in each cell stays the same size, but the row height changes to make the sheet feel more or less dense.

### What is `VisualDensity`?

`VisualDensity` is a **class** included in `ThemeData`. It holds two main properties:

*   `horizontal`: Controls the horizontal spacing.
*   `vertical`: Controls the vertical spacing.

These properties are typically `double` values that range from a minimum density (usually `-4.0` for very compact) to a maximum density (usually `4.0` for very spacious), with `0.0` being the default or "standard" density according to Material Design.

`VisualDensity` itself is **not** a widget or something you apply directly to a single button. You set it in your app's main [ThemeData](02_themedata_.md), and then compatible widgets within your app automatically adjust their spacing based on that setting.

Here are the few predefined `VisualDensity` settings you'll often use:

*   `VisualDensity.standard`: The default (`horizontal: 0.0`, `vertical: 0.0`).
*   `VisualDensity.compact`: A more compact setting (`horizontal: -2.0`, `vertical: -2.0`).
*   `VisualDensity.comfortable`: Somewhere between standard and compact (`horizontal: -1.0`, `vertical: -1.0`).
*   `VisualDensity.adaptivePlatformDensity`: Automatically chooses `compact` for desktop platforms (Linux, macOS, Windows) and `standard` for mobile platforms (Android, iOS, Fuchsia). This is often a good default to use.

### How to Use `VisualDensity`

You apply a `VisualDensity` setting by setting the `visualDensity` property in your app's `ThemeData`.

Here's a simple example demonstrating different `VisualDensity` settings:

```dart
import 'package:flutter/material.dart';

void main() {
  runApp(const MyApp());
}

class MyApp extends StatelessWidget {
  const MyApp({super.key});

  @override
  Widget build(BuildContext context) {
    return MaterialApp(
      title: 'Visual Density Demo',
      theme: ThemeData(
        primarySwatch: Colors.blue,
        // --- SET THE VISUAL DENSITY HERE ---
        visualDensity: VisualDensity.adaptivePlatformDensity,
        // visualDensity: VisualDensity.comfortable, // Try this one too!
        // visualDensity: VisualDensity.compact, // And this one!
        // visualDensity: VisualDensity.standard, // And the default
        useMaterial3: true,
      ),
      home: const HomeScreen(),
    );
  }
}

class HomeScreen extends StatelessWidget {
  const HomeScreen({super.key});

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        title: const Text('Visual Density Demo'),
      ),
      body: Center(
        child: Column(
          mainAxisAlignment: MainAxisAlignment.center,
          children: <Widget>[
            // These widgets are affected by VisualDensity:
            ElevatedButton(
              onPressed: () {},
              child: const Text('Elevated Button'),
            ),
            const SizedBox(height: 10),
            OutlinedButton(
              onPressed: () {},
              child: const Text('Outlined Button'),
            ),
            const SizedBox(height: 10),
            TextButton(
              onPressed: () {},
              child: const Text('Text Button'),
            ),
            const SizedBox(height: 10),
            Checkbox(value: true, onChanged: (bool? newValue) {}),
            const SizedBox(height: 10),
            Radio<int>(value: 1, groupValue: 1, onChanged: (int? newValue) {}),
            const SizedBox(height: 10),
            ListTile(
              leading: const Icon(Icons.star),
              title: const Text('List Tile Example'),
              onTap: () {},
            ),
            const SizedBox(height: 10),
            // NOTE: VisualDensity with TextFields primarily affects the padding
            // within the InputDecoration.
            const TextField(
              decoration: InputDecoration(
                labelText: 'Input Field',
                border: OutlineInputBorder(),
              ),
            ),
          ],
        ),
      ),
    );
  }
}

```

Run this code and try changing the `visualDensity` line in `ThemeData` to `VisualDensity.comfortable`, `VisualDensity.compact`, or `VisualDensity.standard`. You'll see how the spacing around the buttons, the list tile, and even the padding inside the text field changes subtly, making the UI feel more or less "spread out." Notice that the text and icon sizes don't change.

Using `VisualDensity.adaptivePlatformDensity` is a great way to make your app feel more natural on different devices right from the start. On a phone, interactive elements will have standard spacing (making them easier to tap with a finger), while on a desktop, they will be more compact (better mouse/keyboard interaction and fitting more on screen).

### Under the Hood: How Widgets Use `VisualDensity`

When you set `visualDensity` in `ThemeData`, it gets stored within the theme information that is available using `Theme.of(context)`. Compatible widgets, when they build themselves, look up the current theme's `visualDensity`.

These widgets then translate the `horizontal` and `vertical` density values into actual pixel adjustments. The conversion isn't a simple 1-to-1 mapping for every widget. As the documentation states, "a change of 1 or -1 in density corresponds to 4 logical pixels" as a rule of thumb, but widgets can interpret this differently based on their design.

Let's imagine how a simple button might use the `vertical` density:

```mermaid
sequenceDiagram
    participant Button as ElevatedButton
    participant BuildContext as BuildContext
    participant ThemeWidget as Theme Widget
    participant ThemeData as ThemeData
    participant VisualDensity as VisualDensity Object

    Button->>BuildContext: "Hey, I need the theme's visual density!"
    BuildContext->>ThemeWidget: "Nearest Theme, what's your data?"
    ThemeWidget->>ThemeData: Get ThemeData object
    ThemeData->>VisualDensity: Get VisualDensity object
    VisualDensity-->>ThemeData: Return VisualDensity object (e.g., v: -1.0)
    ThemeData-->>Button: Return VisualDensity object
    Button->>Button: Calculate vertical padding baseado em VisualDensity.vertical
    Button->>Button: Render button with calculated padding
```

This diagram shows the button checking the theme for the `VisualDensity` object. Once it gets it, it uses the `vertical` property (and possibly `horizontal`) to calculate how much extra space (padding) it should add or remove around its content.

Looking at the `ThemeData` code snippet you provided, you can see `visualDensity` is a property stored directly in `ThemeData`:

```dart
/// The density value for specifying the compactness of various UI components.
///
/// {@template flutter.material.themedata.visualDensity}
/// ... (documentation for VisualDensity) ...
/// {@endtemplate}
final VisualDensity visualDensity;
```

Then, in the `ThemeData.lerp` method, you can see that `VisualDensity` is interpolated when animating between themes:

```dart
// From packages/flutter/lib/src/material/theme_data.dart
static ThemeData lerp(ThemeData a, ThemeData b, double t) {
  // ... other properties ...
  return ThemeData.raw(
    // ... other properties ...
    visualDensity: VisualDensity.lerp(a.visualDensity, b.visualDensity, t),
    // ... other properties ...
  );
}
```

And if you were to look at the source code for, say, `ElevatedButton`, you would eventually find where it uses the `VisualDensity` from the theme (often through a MaterialButton parent class or a component theme) to adjust its internal layout constraints or padding. The `VisualDensity` class itself has an `baseSizeAdjustment` getter that provides a base offset in pixels based on the density values, and widgets can use this offset (or a modified version of it) when calculating their size. Here's the snippet from `VisualDensity` class provided:

```dart
/// The base adjustment in logical pixels of the visual density of UI components.
///
/// The input density values are multiplied by a constant to arrive at a base
/// size adjustment that fits Material Design guidelines.
/// ...
  Offset get baseSizeAdjustment {
    // The number of logical pixels represented by an increase or decrease in
    // density by one. The Material Design guidelines say to increment/decrement
    // sizes in terms of four pixel increments.
    const double interval = 4.0;

    return Offset(horizontal, vertical) * interval;
  }

/// Return a copy of [constraints] whose minimum width and height have been
  /// updated with the [baseSizeAdjustment].
  /// ...
  BoxConstraints effectiveConstraints(BoxConstraints constraints) {
    assert(constraints.debugAssertIsValid());
    return constraints.copyWith(
      minWidth: clampDouble(
        constraints.minWidth + baseSizeAdjustment.dx,
        0.0,
        constraints.maxWidth,
      ),
      minHeight: clampDouble(
        constraints.minHeight + baseSizeAdjustment.dy,
        0.0,
        constraints.maxHeight,
      ),
    );
  }
```
This shows how the `horizontal` and `vertical` values are converted into a pixel `Offset` and how that offset can be used to modify the minimum size constraints of a widget.

### Conclusion

`VisualDensity` is a simple but effective way to control the overall "compactness" of interactive UI elements in your Flutter app. By setting this property in your `ThemeData`, you can subtly adjust the spacing of compatible widgets globally, without changing their text or icon sizes. Using `VisualDensity.adaptivePlatformDensity` is a recommended practice for creating apps that feel at home on both mobile and desktop platforms.

Now that we've looked at `VisualDensity`, let's dive into another related concept that affects the size of interactive areas: [MaterialTapTargetSize](06_materialtaptargetsize_.md).

[MaterialTapTargetSize](06_materialtaptargetsize_.md)

Relevant Code Snippets (Code itself remains unchanged):
--- File: packages/flutter/lib/src/material/theme_data.dart ---
// Copyright 2014 The Flutter Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

/// @docImport 'package:flutter/material.dart';
library;

import 'dart:ui' show Color, lerpDouble;

import 'package:flutter/cupertino.dart';
import 'package:flutter/foundation.dart';

import 'action_buttons.dart';
import 'action_icons_theme.dart';
import 'app_bar_theme.dart';
import 'badge_theme.dart';
import 'banner_theme.dart';
import 'bottom_app_bar_theme.dart';
import 'bottom_navigation_bar_theme.dart';
import 'bottom_sheet_theme.dart';
import 'button_bar_theme.dart';
import 'button_theme.dart';
import 'card_theme.dart';
import 'checkbox_theme.dart';
import 'chip_theme.dart';
import 'color_scheme.dart';
import 'colors.dart';
import 'constants.dart';
import 'data_table_theme.dart';
import 'date_picker_theme.dart';
import 'dialog_theme.dart';
import 'divider_theme.dart';
import 'drawer_theme.dart';
import 'dropdown_menu_theme.dart';
import 'elevated_button_theme.dart';
import 'expansion_tile_theme.dart';
import 'filled_button_theme.dart';
import 'floating_action_button_theme.dart';
import 'icon_button_theme.dart';
import 'ink_ripple.dart';
import 'ink_sparkle.dart';
import 'ink_splash.dart';
import 'ink_well.dart' show InteractiveInkFeatureFactory;
import 'input_decorator.dart';
import 'list_tile.dart';
import 'list_tile_theme.dart';
import 'menu_bar_theme.dart';
import 'menu_button_theme.dart';
import 'menu_theme.dart';
import 'navigation_bar_theme.dart';
import 'navigation_drawer_theme.dart';
import 'navigation_rail_theme.dart';
import 'outlined_button_theme.dart';
import 'page_transitions_theme.dart';
import 'popup_menu_theme.dart';
import 'progress_indicator_theme.dart';
import 'radio_theme.dart';
import 'scrollbar_theme.dart';
import 'search_bar_theme.dart';
import 'search_view_theme.dart';
import 'segmented_button_theme.dart';
import 'slider_theme.dart';
import 'snack_bar_theme.dart';
import 'switch_theme.dart';
import 'tab_bar_theme.dart';
import 'text_button_theme.dart';
import 'text_selection_theme.dart';
import 'text_theme.dart';
import 'time_picker_theme.dart';
import 'toggle_buttons_theme.dart';
import 'tooltip_theme.dart';
import 'typography.dart';

export 'package:flutter/services.dart' show Brightness;

// Examples can assume:
// late BuildContext context;

/// Defines a customized theme for components with an `adaptive` factory constructor.
///
/// Currently, only [Switch.adaptive] supports this class.
class Adaptation<T> {
  /// Creates an [Adaptation].
  const Adaptation();

  /// The adaptation's type.
  Type get type => T;

  /// Typically, this is overridden to return an instance of a custom component
  /// ThemeData class, like [SwitchThemeData], instead of the defaultValue.
  ///
  /// Factory constructors that support adaptations - currently only
  /// [Switch.adaptive] - look for a type-specific adaptation in
  /// [ThemeData.adaptationMap] when computing their effective default component
  /// theme. If a matching adaptation is not found, the component may choose to
  /// use a default adaptation. For example, the [Switch.adaptive] component
  /// uses an empty [SwitchThemeData] if a matching adaptation is not found, for
  /// the sake of backwards compatibility.
  ///
  /// {@tool dartpad}
  /// This sample shows how to create and use subclasses of [Adaptation] that
  /// define adaptive [SwitchThemeData]s. The [adapt] method in this example is
  /// overridden to only customize cupertino-style switches, but it can also be
  /// used to customize any other platforms.
  ///
  /// ** See code in examples/api/lib/material/switch/switch.4.dart **
  /// {@end-tool}
  T adapt(ThemeData theme, T defaultValue) => defaultValue;
}

/// An interface that defines custom additions to a [ThemeData] object.
///
/// {@youtube 560 315 https://www.youtube.com/watch?v=8-szcYzFVao}
///
/// Typically used for custom colors. To use, subclass [ThemeExtension],
/// define a number of fields (e.g. [Color]s), and implement the [copyWith] and
/// [lerp] methods. The latter will ensure smooth transitions of properties when
/// switching themes.
///
/// {@tool dartpad}
/// This sample shows how to create and use a subclass of [ThemeExtension] that
/// defines two colors.
///
/// ** See code in examples/api/lib/material/theme/theme_extension.1.dart **
/// {@end-tool}
abstract class ThemeExtension<T extends ThemeExtension<T>> {
  /// Enable const constructor for subclasses.
  const ThemeExtension();

  /// The extension's type.
  Object get type => T;

  /// Creates a copy of this theme extension with the given fields
  /// replaced by the non-null parameter values.
  ThemeExtension<T> copyWith();

  /// Linearly interpolate with another [ThemeExtension] object.
  ///
  /// {@macro dart.ui.shadow.lerp}
  ThemeExtension<T> lerp(covariant ThemeExtension<T>? other, double t);
}

/// Configures the tap target and layout size of certain Material widgets.
///
/// Changing the value in [ThemeData.materialTapTargetSize] will affect the
/// accessibility experience.
///
/// Some of the impacted widgets include:
///
///   * [FloatingActionButton], only the mini tap target size is increased.
///   * [MaterialButton]
///   * [OutlinedButton]
///   * [TextButton]
///   * [ElevatedButton]
///   * [IconButton]
///   * The time picker widget ([showTimePicker])
///   * [SnackBar]
///   * [Chip]
///   * [RawChip]
///   * [InputChip]
///   * [ChoiceChip]
///   * [FilterChip]
///   * [ActionChip]
///   * [Radio]
///   * [Switch]
///   * [Checkbox]
enum MaterialTapTargetSize {
  /// Expands the minimum tap target size to 48px by 48px.
  ///
  /// This is the default value of [ThemeData.materialTapTargetSize] and the
  /// recommended size to conform to Android accessibility scanner
  /// recommendations.
  padded,

  /// Shrinks the tap target size to the minimum provided by the Material
  /// specification.
  shrinkWrap,
}

/// Defines the configuration of the overall visual [Theme] for a [MaterialApp]
/// or a widget subtree within the app.
///
/// The [MaterialApp] theme property can be used to configure the appearance
/// of the entire app. Widget subtrees within an app can override the app's
/// theme by including a [Theme] widget at the top of the subtree.
///
/// Widgets whose appearance should align with the overall theme can obtain the
/// current theme's configuration with [Theme.of]. Material components typically
/// depend exclusively on the [colorScheme] and [textTheme]. These properties
/// are guaranteed to have non-null values.
///
/// The static [Theme.of] method finds the [ThemeData] value specified for the
/// nearest [BuildContext] ancestor. This lookup is inexpensive, essentially
/// just a single HashMap access. It can sometimes be a little confusing
/// because [Theme.of] can not see a [Theme] widget that is defined in the
/// current build method's context. To overcome that, create a new custom widget
/// for the subtree that appears below the new [Theme], or insert a widget
/// that creates a new BuildContext, like [Builder].
///
/// {@tool dartpad}
/// This example demonstrates how a typical [MaterialApp] specifies
/// and uses a custom [Theme]. The theme's [ColorScheme] is based on a
/// single "seed" color and configures itself to match the platform's
/// current light or dark color configuration. The theme overrides the
/// default configuration of [FloatingActionButton] to show how to
/// customize the appearance a class of components.
///
/// ** See code in examples/api/lib/material/theme_data/theme_data.0.dart **
/// {@end-tool}
///
/// See <https://material.io/design/color/> for
/// more discussion on how to pick the right colors.

@immutable
class ThemeData with Diagnosticable {
  /// Create a [ThemeData] that's used to configure a [Theme].
  ///
  /// The [colorScheme] and [textTheme] are used by the Material components to
  /// compute default values for visual properties. The API documentation for
  /// each component widget explains exactly how the defaults are computed.
  ///
  /// When providing a [ColorScheme], apps can either provide one directly
  /// with the [colorScheme] parameter, or have one generated for them by
  /// using the [colorSchemeSeed] and [brightness] parameters. A generated
  /// color scheme will be based on the tones of [colorSchemeSeed] and all of
  /// its contrasting color will meet accessibility guidelines for readability.
  /// (See [ColorScheme.fromSeed] for more details.)
  ///
  /// If the app wants to customize a generated color scheme, it can use
  /// [ColorScheme.fromSeed] directly and then [ColorScheme.copyWith] on the
  /// result to override any colors that need to be replaced. The result of
  /// this can be used as the [colorScheme] directly.
  ///
  /// For historical reasons, instead of using a [colorSchemeSeed] or
  /// [colorScheme], you can provide either a [primaryColor] or [primarySwatch]
  /// to construct the [colorScheme], but the results will not be as complete
  /// as when using generation from a seed color.
  ///
  /// If [colorSchemeSeed] is non-null then [colorScheme], [primaryColor] and
  /// [primarySwatch] must all be null.
  ///
  /// The [textTheme] [TextStyle] colors are black if the color scheme's
  /// brightness is [Brightness.light], and white for [Brightness.dark].
  ///
  /// To override the appearance of specific components, provide
  /// a component theme parameter like [sliderTheme], [toggleButtonsTheme],
  /// or [bottomNavigationBarTheme].
  ///
  /// See also:
  ///
  ///  * [ThemeData.from], which creates a ThemeData from a [ColorScheme].
  ///  * [ThemeData.light], which creates the default light theme.
  ///  * [ThemeData.dark], which creates the default dark theme.
  ///  * [ColorScheme.fromSeed], which is used to create a [ColorScheme] from a seed color.
  factory ThemeData({
    // For the sanity of the reader, make sure these properties are in the same
    // order in every place that they are separated by section comments (e.g.
    // GENERAL CONFIGURATION). Each section except for deprecations should be
    // alphabetical by symbol name.

    // GENERAL CONFIGURATION
    Iterable<Adaptation<Object>>? adaptations,
    bool? applyElevationOverlayColor,
    NoDefaultCupertinoThemeData? cupertinoOverrideTheme,
    Iterable<ThemeExtension<dynamic>>? extensions,
    InputDecorationTheme? inputDecorationTheme,
    MaterialTapTargetSize? materialTapTargetSize,
    PageTransitionsTheme? pageTransitionsTheme,
    TargetPlatform? platform,
    ScrollbarThemeData? scrollbarTheme,
    InteractiveInkFeatureFactory? splashFactory,
    bool? useMaterial3,
    VisualDensity? visualDensity,
    // COLOR
    ColorScheme? colorScheme,
    Brightness? brightness,
    Color? colorSchemeSeed,
    // [colorScheme] is the preferred way to configure colors. The [Color] properties
    // listed below (as well as primarySwatch) will gradually be phased out, see
    // https://github.com/flutter/flutter/issues/91772.
    Color? canvasColor,
    Color? cardColor,
    Color? disabledColor,
    Color? dividerColor,
    Color? focusColor,
    Color? highlightColor,
    Color? hintColor,
    Color? hoverColor,
    Color? indicatorColor,
    Color? primaryColor,
    Color? primaryColorDark,
    Color? primaryColorLight,
    MaterialColor? primarySwatch,
    Color? scaffoldBackgroundColor,
    Color? secondaryHeaderColor,
    Color? shadowColor,
    Color? splashColor,
    Color? unselectedWidgetColor,
    // TYPOGRAPHY & ICONOGRAPHY
    String? fontFamily,
    List<String>? fontFamilyFallback,
    String? package,
    IconThemeData? iconTheme,
    IconThemeData? primaryIconTheme,
    TextTheme? primaryTextTheme,
    TextTheme? textTheme,
    Typography? typography,
    // COMPONENT THEMES
    ActionIconThemeData? actionIconTheme,
    AppBarTheme? appBarTheme,
    BadgeThemeData? badgeTheme,
    MaterialBannerThemeData? bannerTheme,
    BottomAppBarTheme? bottomAppBarTheme,
    BottomNavigationBarThemeData? bottomNavigationBarTheme,
    BottomSheetThemeData? bottomSheetTheme,
    ButtonThemeData? buttonTheme,
    // TODO(QuncCccccc): Change the parameter type to CardThemeData
    Object? cardTheme,
    CheckboxThemeData? checkboxTheme,
    ChipThemeData? chipTheme,
    DataTableThemeData? dataTableTheme,
    DatePickerThemeData? datePickerTheme,
    // TODO(QuncCccccc): Change the parameter type to DialogThemeData
    Object? dialogTheme,
    DividerThemeData? dividerTheme,
    DrawerThemeData? drawerTheme,
    DropdownMenuThemeData? dropdownMenuTheme,
    ElevatedButtonThemeData? elevatedButtonTheme,
    ExpansionTileThemeData? expansionTileTheme,
    FilledButtonThemeData? filledButtonTheme,
    FloatingActionButtonThemeData? floatingActionButtonTheme,
    IconButtonThemeData? iconButtonTheme,
    ListTileThemeData? listTileTheme,
    MenuBarThemeData? menuBarTheme,
    MenuButtonThemeData? menuButtonTheme,
    MenuThemeData? menuTheme,
    NavigationBarThemeData? navigationBarTheme,
    NavigationDrawerThemeData? navigationDrawerTheme,
    NavigationRailThemeData? navigationRailTheme,
    OutlinedButtonThemeData? outlinedButtonTheme,
    PopupMenuThemeData? popupMenuTheme,
    ProgressIndicatorThemeData? progressIndicatorTheme,
    RadioThemeData? radioTheme,
    SearchBarThemeData? searchBarTheme,
    SearchViewThemeData? searchViewTheme,
    SegmentedButtonThemeData? segmentedButtonTheme,
    SliderThemeData? sliderTheme,
    SnackBarThemeData? snackBarTheme,
    SwitchThemeData? switchTheme,
    // TODO(QuncCccccc): Change the parameter type to TabBarThemeData
    Object? tabBarTheme,
    TextButtonThemeData? textButtonTheme,
    TextSelectionThemeData? textSelectionTheme,
    TimePickerThemeData? timePickerTheme,
    ToggleButtonsThemeData? toggleButtonsTheme,
    TooltipThemeData? tooltipTheme,
    // DEPRECATED (newest deprecations at the bottom)
    @Deprecated(
      'Use OverflowBar instead. '
      'This feature was deprecated after v3.21.0-10.0.pre.',
    )
    ButtonBarThemeData? buttonBarTheme,
    @Deprecated(
      'Use DialogThemeData.backgroundColor instead. '
      'This feature was deprecated after v3.27.0-0.1.pre.',
    )
    Color? dialogBackgroundColor,
  }) {
    // GENERAL CONFIGURATION
    cupertinoOverrideTheme = cupertinoOverrideTheme?.noDefault();
    extensions ??= <ThemeExtension<dynamic>>[];
    adaptations ??= <Adaptation<Object>>[];
    inputDecorationTheme ??= const InputDecorationTheme();
    platform ??= defaultTargetPlatform;
    switch (platform) {
      case TargetPlatform.android:
      case TargetPlatform.fuchsia:
      case TargetPlatform.iOS:
        materialTapTargetSize ??= MaterialTapTargetSize.padded;
      case TargetPlatform.linux:
      case TargetPlatform.macOS:
      case TargetPlatform.windows:
        materialTapTargetSize ??= MaterialTapTargetSize.shrinkWrap;
    }
    pageTransitionsTheme ??= const PageTransitionsTheme();
    scrollbarTheme ??= const ScrollbarThemeData();
    visualDensity ??= VisualDensity.defaultDensityForPlatform(platform);
    useMaterial3 ??= true;
    final bool useInkSparkle = platform == TargetPlatform.android && !kIsWeb;
    splashFactory ??=
        useMaterial3
            ? useInkSparkle
                ? InkSparkle.splashFactory
                : InkRipple.splashFactory
            : InkSplash.splashFactory;

    // COLOR
    assert(
      colorScheme?.brightness == null ||
          brightness == null ||
          colorScheme!.brightness == brightness,
      'ThemeData.brightness does not match ColorScheme.brightness. '
      'Either override ColorScheme.brightness or ThemeData.brightness to '
      'match the other.',
    );
    assert(colorSchemeSeed == null || colorScheme == null);
    assert(colorSchemeSeed == null || primarySwatch == null);
    assert(colorSchemeSeed == null || primaryColor == null);
    final Brightness effectiveBrightness =
        brightness ?? colorScheme?.brightness ?? Brightness.light;
    final bool isDark = effectiveBrightness == Brightness.dark;
    if (colorSchemeSeed != null || useMaterial3) {
      if (colorSchemeSeed != null) {
        colorScheme = ColorScheme.fromSeed(
          seedColor: colorSchemeSeed,
          brightness: effectiveBrightness,
        );
      }
      colorScheme ??= isDark ? _colorSchemeDarkM3 : _colorSchemeLightM3;

      // For surfaces that use primary color in light themes and surface color in dark
      final Color primarySurfaceColor = isDark ? colorScheme.surface : colorScheme.primary;
      final Color onPrimarySurfaceColor = isDark ? colorScheme.onSurface : colorScheme.onPrimary;

      // Default some of the color settings to values from the color scheme
      primaryColor ??= primarySurfaceColor;
      canvasColor ??= colorScheme.surface;
      scaffoldBackgroundColor ??= colorScheme.surface;
      cardColor ??= colorScheme.surface;
      dividerColor ??= colorScheme.outline;
      dialogBackgroundColor ??= colorScheme.surface;
      indicatorColor ??= onPrimarySurfaceColor;
      applyElevationOverlayColor ??= brightness == Brightness.dark;
    }
    applyElevationOverlayColor ??= false;
    primarySwatch ??= Colors.blue;
    primaryColor ??= isDark ? Colors.grey[900]! : primarySwatch;
    final Brightness estimatedPrimaryColorBrightness = estimateBrightnessForColor(primaryColor);
    primaryColorLight ??= isDark ? Colors.grey[500]! : primarySwatch[100]!;
    primaryColorDark ??= isDark ? Colors.black : primarySwatch[700]!;
    final bool primaryIsDark = estimatedPrimaryColorBrightness == Brightness.dark;
    focusColor ??= isDark ? Colors.white.withOpacity(0.12) : Colors.black.withOpacity(0.12);
    hoverColor ??= isDark ? Colors.white.withOpacity(0.04) : Colors.black.withOpacity(0.04);
    shadowColor ??= Colors.black;
    canvasColor ??= isDark ? Colors.grey[850]! : Colors.grey[50]!;
    scaffoldBackgroundColor ??= canvasColor;
    cardColor ??= isDark ? Colors.grey[800]! : Colors.white;
    dividerColor ??= isDark ? const Color(0x1FFFFFFF) : const Color(0x1F000000);
    // Create a ColorScheme that is backwards compatible as possible
    // with the existing default ThemeData color values.
    colorScheme ??= ColorScheme.fromSwatch(
      primarySwatch: primarySwatch,
      accentColor: isDark ? Colors.tealAccent[200]! : primarySwatch[500]!,
      cardColor: cardColor,
      backgroundColor: isDark ? Colors.grey[700]! : primarySwatch[200]!,
      errorColor: Colors.red[700],
      brightness: effectiveBrightness,
    );
    unselectedWidgetColor ??= isDark ? Colors.white70 : Colors.black54;
    // Spec doesn't specify a dark theme secondaryHeaderColor, this is a guess.
    secondaryHeaderColor ??= isDark ? Colors.grey[700]! : primarySwatch[50]!;
    indicatorColor ??= colorScheme.secondary == primaryColor ? Colors.white : colorScheme.secondary;
    hintColor ??= isDark ? Colors.white60 : Colors.black.withOpacity(0.6);
    // The default [buttonTheme] is here because it doesn't use the defaults for
    // [disabledColor], [highlightColor], and [splashColor].
    buttonTheme ??= ButtonThemeData(
      colorScheme: colorScheme,
      buttonColor: isDark ? primarySwatch[600]! : Colors.grey[300]!,
      disabledColor: disabledColor,
      focusColor: focusColor,
      hoverColor: hoverColor,
      highlightColor: highlightColor,
      splashColor: splashColor,
      materialTapTargetSize: materialTapTargetSize,
    );
    disabledColor ??= isDark ? Colors.white38 : Colors.black38;
    highlightColor ??= isDark ? const Color(0x40CCCCCC) : const Color(0x66BCBCBC);
    splashColor ??= isDark ? const Color(0x40CCCCCC) : const Color(0x66C8C8C8);

    // TYPOGRAPHY & ICONOGRAPHY
    typography ??=
        useMaterial3
            ? Typography.material2021(platform: platform, colorScheme: colorScheme)
            : Typography.material2014(platform: platform);
    TextTheme defaultTextTheme = isDark ? typography.white : typography.black;
    TextTheme defaultPrimaryTextTheme = primaryIsDark ? typography.white : typography.black;
    if (fontFamily != null) {
      defaultTextTheme = defaultTextTheme.apply(fontFamily: fontFamily);
      defaultPrimaryTextTheme = defaultPrimaryTextTheme.apply(fontFamily: fontFamily);
    }
    if (fontFamilyFallback != null) {
      defaultTextTheme = defaultTextTheme.apply(fontFamilyFallback: fontFamilyFallback);
      defaultPrimaryTextTheme = defaultPrimaryTextTheme.apply(
        fontFamilyFallback: fontFamilyFallback,
      );
    }
    if (package != null) {
      defaultTextTheme = defaultTextTheme.apply(package: package);
      defaultPrimaryTextTheme = defaultPrimaryTextTheme.apply(package: package);
    }
    textTheme = defaultTextTheme.merge(textTheme);
    primaryTextTheme = defaultPrimaryTextTheme.merge(primaryTextTheme);
    iconTheme ??=
        isDark
            ? IconThemeData(color: kDefaultIconLightColor)
            : IconThemeData(color: kDefaultIconDarkColor);
    primaryIconTheme ??=
        primaryIsDark
            ? const IconThemeData(color: Colors.white)
            : const IconThemeData(color: Colors.black);

    // COMPONENT THEMES
    appBarTheme ??= const AppBarTheme();
    badgeTheme ??= const BadgeThemeData();
    bannerTheme ??= const MaterialBannerThemeData();
    bottomAppBarTheme ??= const BottomAppBarTheme();
    bottomNavigationBarTheme ??= const BottomNavigationBarThemeData();
    bottomSheetTheme ??= const BottomSheetThemeData();
    // TODO(QuncCccccc): Clean it up once the type of `cardTheme` is changed to `CardThemeData`
    if (cardTheme != null) {
      if (cardTheme is CardTheme) {
        cardTheme = cardTheme.data;
      } else if (cardTheme is! CardThemeData) {
        throw ArgumentError('cardTheme must be either a CardThemeData or a CardTheme');
      }
    }
    cardTheme ??= const CardThemeData();
    checkboxTheme ??= const CheckboxThemeData();
    chipTheme ??= const ChipThemeData();
    dataTableTheme ??= const DataTableThemeData();
    datePickerTheme ??= const DatePickerThemeData();
    // TODO(QuncCccccc): Clean this up once the type of `dialogTheme` is changed to `DialogThemeData`
    if (dialogTheme != null) {
      if (dialogTheme is DialogTheme) {
        dialogTheme = dialogTheme.data;
      } else if (dialogTheme is! DialogThemeData) {
        throw ArgumentError('dialogTheme must be either a DialogThemeData or a DialogTheme');
      }
    }
    dialogTheme ??= const DialogThemeData();
    dividerTheme ??= const DividerThemeData();
    drawerTheme ??= const DrawerThemeData();
    dropdownMenuTheme ??= const DropdownMenuThemeData();
    elevatedButtonTheme ??= const ElevatedButtonThemeData();
    expansionTileTheme ??= const ExpansionTileThemeData();
    filledButtonTheme ??= const FilledButtonThemeData();
    floatingActionButtonTheme ??= const FloatingActionButtonThemeData();
    iconButtonTheme ??= const IconButtonThemeData();
    listTileTheme ??= const ListTileThemeData();
    menuBarTheme ??= const MenuBarThemeData();
    menuButtonTheme ??= const MenuButtonThemeData();
    menuTheme ??= const MenuThemeData();
    navigationBarTheme ??= const NavigationBarThemeData();
    navigationDrawerTheme ??= const NavigationDrawerThemeData();
    navigationRailTheme ??= const NavigationRailThemeData();
    outlinedButtonTheme ??= const OutlinedButtonThemeData();
    popupMenuTheme ??= const PopupMenuThemeData();
    progressIndicatorTheme ??= const ProgressIndicatorThemeData();
    radioTheme ??= const RadioThemeData();
    searchBarTheme ??= const SearchBarThemeData();
    searchViewTheme ??= const SearchViewThemeData();
    segmentedButtonTheme ??= const SegmentedButtonThemeData();
    sliderTheme ??= const SliderThemeData();
    snackBarTheme ??= const SnackBarThemeData();
    switchTheme ??= const SwitchThemeData();
    // TODO(QuncCccccc): Clean this up once the type of `tabBarTheme` is changed to `TabBarThemeData`
    if (tabBarTheme != null) {
      if (tabBarTheme is TabBarTheme) {
        tabBarTheme = tabBarTheme.data;
      } else if (tabBarTheme is! TabBarThemeData) {
        throw ArgumentError('tabBarTheme must be either a TabBarThemeData or a TabBarTheme');
      }
    }
    tabBarTheme ??= const TabBarThemeData();
    textButtonTheme ??= const TextButtonThemeData();
    textSelectionTheme ??= const TextSelectionThemeData();
    timePickerTheme ??= const TimePickerThemeData();
    toggleButtonsTheme ??= const ToggleButtonsThemeData();
    tooltipTheme ??= const TooltipThemeData();
    // DEPRECATED (newest deprecations at the bottom)
    buttonBarTheme ??= const ButtonBarThemeData();
    dialogBackgroundColor ??= isDark ? Colors.grey[800]! : Colors.white;
    return ThemeData.raw(
      // For the sanity of the reader, make sure these properties are in the same
      // order in every place that they are separated by section comments (e.g.
      // GENERAL CONFIGURATION). Each section except for deprecations should be
      // alphabetical by symbol name.

      // GENERAL CONFIGURATION
      adaptationMap: _createAdaptationMap(adaptations),
      applyElevationOverlayColor: applyElevationOverlayColor,
      cupertinoOverrideTheme: cupertinoOverrideTheme,
      extensions: _themeExtensionIterableToMap(extensions),
      inputDecorationTheme: inputDecorationTheme,
      materialTapTargetSize: materialTapTargetSize,
      pageTransitionsTheme: pageTransitionsTheme,
      platform: platform,
      scrollbarTheme: scrollbarTheme,
      splashFactory: splashFactory,
      useMaterial3: useMaterial3,
      visualDensity: visualDensity,
      // COLOR
      canvasColor: canvasColor,
      cardColor: cardColor,
      colorScheme: colorScheme,
      disabledColor: disabledColor,
      dividerColor: dividerColor,
      focusColor: focusColor,
      highlightColor: highlightColor,
      hintColor: hintColor,
      hoverColor: hoverColor,
      indicatorColor: indicatorColor,
      primaryColor: primaryColor,
      primaryColorDark: primaryColorDark,
      primaryColorLight: primaryColorLight,
      scaffoldBackgroundColor: scaffoldBackgroundColor,
      secondaryHeaderColor: secondaryHeaderColor,
      shadowColor: shadowColor,
      splashColor: splashColor,
      unselectedWidgetColor: unselectedWidgetColor,
      // TYPOGRAPHY & ICONOGRAPHY
      iconTheme: iconTheme,
      primaryTextTheme: primaryTextTheme,
      textTheme: textTheme,
      typography: typography,
      primaryIconTheme: primaryIconTheme,
      // COMPONENT THEMES
      actionIconTheme: actionIconTheme,
      appBarTheme: appBarTheme,
      badgeTheme: badgeTheme,
      bannerTheme: bannerTheme,
      bottomAppBarTheme: bottomAppBarTheme,
      bottomNavigationBarTheme: bottomNavigationBarTheme,
      bottomSheetTheme: bottomSheetTheme,
      buttonTheme: buttonTheme,
      cardTheme: cardTheme as CardThemeData,
      checkboxTheme: checkboxTheme,
      chipTheme: chipTheme,
      dataTableTheme: dataTableTheme,
      datePickerTheme: datePickerTheme,
      dialogTheme: dialogTheme as DialogThemeData,
      dividerTheme: dividerTheme,
      drawerTheme: drawerTheme,
      dropdownMenuTheme: dropdownMenuTheme,
      elevatedButtonTheme: elevatedButtonTheme,
      expansionTileTheme: expansionTileTheme,
      filledButtonTheme: filledButtonTheme,
      floatingActionButtonTheme: floatingActionButtonTheme,
      iconButtonTheme: iconButtonTheme,
      listTileTheme: listTileTheme,
      menuBarTheme: menuBarTheme,
      menuButtonTheme: menuButtonTheme,
      menuTheme: menuTheme,
      navigationBarTheme: navigationBarTheme,
      navigationDrawerTheme: navigationDrawerTheme,
      navigationRailTheme: navigationRailTheme,
      outlinedButtonTheme: outlinedButtonTheme,
      popupMenuTheme: popupMenuTheme,
      progressIndicatorTheme: progressIndicatorTheme,
      radioTheme: radioTheme,
      searchBarTheme: searchBarTheme,
      searchViewTheme: searchViewTheme,
      segmentedButtonTheme: segmentedButtonTheme,
      sliderTheme: sliderTheme,
      snackBarTheme: snackBarTheme,
      switchTheme: switchTheme,
      tabBarTheme: tabBarTheme as TabBarThemeData,
      textButtonTheme: textButtonTheme,
      textSelectionTheme: textSelectionTheme,
      timePickerTheme: timePickerTheme,
      toggleButtonsTheme: toggleButtonsTheme,
      tooltipTheme: tooltipTheme,
      // DEPRECATED (newest deprecations at the bottom)
      buttonBarTheme: buttonBarTheme,
      dialogBackgroundColor: dialogBackgroundColor,
    );
  }

  /// Create a [ThemeData] given a set of exact values. Most values must be
  /// specified. They all must also be non-null except for
  /// [cupertinoOverrideTheme], and deprecated members.
  ///
  /// This will rarely be used directly. It is used by [lerp] to
  /// create intermediate themes based on two themes created with the
  /// [ThemeData] constructor.
  const ThemeData.raw({
    // For the sanity of the reader, make sure these properties are in the same
    // order in every place that they are separated by section comments (e.g.
    // GENERAL CONFIGURATION). Each section except for deprecations should be
    // alphabetical by symbol name.

    // GENERAL CONFIGURATION
    required this.adaptationMap,
    required this.applyElevationOverlayColor,
    required this.cupertinoOverrideTheme,
    required this.extensions,
    required this.inputDecorationTheme,
    required this.materialTapTargetSize,
    required this.pageTransitionsTheme,
    required this.platform,
    required this.scrollbarTheme,
    required this.splashFactory,
    required this.useMaterial3,
    required this.visualDensity,
    // COLOR
    required this.colorScheme,
    // [colorScheme] is the preferred way to configure colors. The [Color] properties
    // listed below (as well as primarySwatch) will gradually be phased out, see
    // https://github.com/flutter/flutter/issues/91772.
    required this.canvasColor,
    required this.cardColor,
    required this.disabledColor,
    required this.dividerColor,
    required this.focusColor,
    required this.highlightColor,
    required this.hintColor,
    required this.hoverColor,
    required this.indicatorColor,
    required this.primaryColor,
    required this.primaryColorDark,
    required this.primaryColorLight,
    required this.scaffoldBackgroundColor,
    required this.secondaryHeaderColor,
    required this.shadowColor,
    required this.splashColor,
    required this.unselectedWidgetColor,
    // TYPOGRAPHY & ICONOGRAPHY
    required this.iconTheme,
    required this.primaryIconTheme,
    required this.primaryTextTheme,
    required this.textTheme,
    required this.typography,
    // COMPONENT THEMES
    required this.actionIconTheme,
    required this.appBarTheme,
    required this.badgeTheme,
    required this.bannerTheme,
    required this.bottomAppBarTheme,
    required this.bottomNavigationBarTheme,
    required this.bottomSheetTheme,
    required this.buttonTheme,
    required this.cardTheme,
    required this.checkboxTheme,
    required this.chipTheme,
    required this.dataTableTheme,
    required this.datePickerTheme,
    required this.dialogTheme,
    required this.dividerTheme,
    required this.drawerTheme,
    required this.dropdownMenuTheme,
    required this.elevatedButtonTheme,
    required this.expansionTileTheme,
    required this.filledButtonTheme,
    required this.floatingActionButtonTheme,
    required this.iconButtonTheme,
    required this.listTileTheme,
    required this.menuBarTheme,
    required this.menuButtonTheme,
    required this.menuTheme,
    required this.navigationBarTheme,
    required this.navigationDrawerTheme,
    required this.navigationRailTheme,
    required this.outlinedButtonTheme,
    required this.popupMenuTheme,
    required this.progressIndicatorTheme,
    required this.radioTheme,
    required this.searchBarTheme,
    required this.searchViewTheme,
    required this.segmentedButtonTheme,
    required this.sliderTheme,
    required this.snackBarTheme,
    required this.switchTheme,
    required this.tabBarTheme,
    required this.textButtonTheme,
    required this.textSelectionTheme,
    required this.timePickerTheme,
    required this.toggleButtonsTheme,
    required this.tooltipTheme,
    // DEPRECATED (newest deprecations at the bottom)
    @Deprecated(
      'Use OverflowBar instead. '
      'This feature was deprecated after v3.21.0-10.0.pre.',
    )
    ButtonBarThemeData? buttonBarTheme,
    @Deprecated(
      'Use DialogThemeData.backgroundColor instead. '
      'This feature was deprecated after v3.27.0-0.1.pre.',
    )
    required this.dialogBackgroundColor,
  }) : // DEPRECATED (newest deprecations at the bottom)
       // should not be `required`, use getter pattern to avoid breakages.
       _buttonBarTheme = buttonBarTheme,
       assert(buttonBarTheme != null);

  /// Create a [ThemeData] based on the colors in the given [colorScheme] and
  /// text styles of the optional [textTheme].
  ///
  /// If [colorScheme].brightness is [Brightness.dark] then
  /// [ThemeData.applyElevationOverlayColor] will be set to true to support
  /// the Material dark theme method for indicating elevation by applying
  /// a semi-transparent onSurface color on top of the surface color.
  ///
  /// This is the recommended method to theme your application. As we move
  /// forward we will be converting all the widget implementations to only use
  /// colors or colors derived from those in [ColorScheme].
  ///
  /// {@tool snippet}
  /// This example will set up an application to use the baseline Material
  /// Design light and dark themes.
  ///
  /// ```dart
  /// MaterialApp(
  ///   theme: ThemeData.from(colorScheme: const ColorScheme.light()),
  ///   darkTheme: ThemeData.from(colorScheme: const ColorScheme.dark()),
  /// )
  /// ```
  /// {@end-tool}
  ///
  /// See <https://material.io/design/color/> for
  /// more discussion on how to pick the right colors.
  factory ThemeData.from({
    required ColorScheme colorScheme,
    TextTheme? textTheme,
    bool? useMaterial3,
  }) {
    final bool isDark = colorScheme.brightness == Brightness.dark;

    // For surfaces that use primary color in light themes and surface color in dark
    final Color primarySurfaceColor = isDark ? colorScheme.surface : colorScheme.primary;
    final Color onPrimarySurfaceColor = isDark ? colorScheme.onSurface : colorScheme.onPrimary;

    return ThemeData(
      colorScheme: colorScheme,
      brightness: colorScheme.brightness,
      primaryColor: primarySurfaceColor,
      canvasColor: colorScheme.surface,
      scaffoldBackgroundColor: colorScheme.surface,
      cardColor: colorScheme.surface,
      dividerColor: colorScheme.onSurface.withOpacity(0.12),
      dialogBackgroundColor: colorScheme.surface,
      indicatorColor: onPrimarySurfaceColor,
      textTheme: textTheme,
      applyElevationOverlayColor: isDark,
      useMaterial3: useMaterial3,
    );
  }

  /// A default light theme.
  ///
  /// This theme does not contain text geometry. Instead, it is expected that
  /// this theme is localized using text geometry using [ThemeData.localize].
  factory ThemeData.light({bool? useMaterial3}) =>
      ThemeData(brightness: Brightness.light, useMaterial3: useMaterial3);

  /// A default dark theme.
  ///
  /// This theme does not contain text geometry. Instead, it is expected that
  /// this theme is localized using text geometry using [ThemeData.localize].
  factory ThemeData.dark({bool? useMaterial3}) =>
      ThemeData(brightness: Brightness.dark, useMaterial3: useMaterial3);

  /// The default color theme. Same as [ThemeData.light].
  ///
  /// This is used by [Theme.of] when no theme has been specified.
  ///
  /// This theme does not contain text geometry. Instead, it is expected that
  /// this theme is localized using text geometry using [ThemeData.localize].
  ///
  /// Most applications would use [Theme.of], which provides correct localized
  /// text geometry.
  factory ThemeData.fallback({bool? useMaterial3}) => ThemeData.light(useMaterial3: useMaterial3);

  /// Used to obtain a particular [Adaptation] from [adaptationMap].
  ///
  /// To get an adaptation, use `Theme.of(context).getAdaptation<MyAdaptation>()`.
  Adaptation<T>? getAdaptation<T>() => adaptationMap[T] as Adaptation<T>?;

  static Map<Type, Adaptation<Object>> _createAdaptationMap(
    Iterable<Adaptation<Object>> adaptations,
  ) {
    final Map<Type, Adaptation<Object>> adaptationMap = <Type, Adaptation<Object>>{
      for (final Adaptation<Object> adaptation in adaptations) adaptation.type: adaptation,
    };
    return adaptationMap;
  }

  /// The overall theme brightness.
  ///
  /// The default [TextStyle] color for the [textTheme] is black if the
  /// theme is constructed with [Brightness.light] and white if the
  /// theme is constructed with [Brightness.dark].
  Brightness get brightness => colorScheme.brightness;

  // For the sanity of the reader, make sure these properties are in the same
  // order in every place that they are separated by section comments (e.g.
  // GENERAL CONFIGURATION). Each section except for deprecations should be
  // alphabetical by symbol name.

  // GENERAL CONFIGURATION

  /// Apply a semi-transparent overlay color on Material surfaces to indicate
  /// elevation for dark themes.
  ///
  /// If [useMaterial3] is true, then this flag is ignored as there is a new
  /// [Material.surfaceTintColor] used to create an overlay for Material 3.
  /// This flag is meant only for the Material 2 elevation overlay for dark
  /// themes.
  ///
  /// Material drop shadows can be difficult to see in a dark theme, so the
  /// elevation of a surface should be portrayed with an "overlay" in addition
  /// to the shadow. As the elevation of the component increases, the
  /// overlay increases in opacity. [applyElevationOverlayColor] turns the
  /// application of this overlay on or off for dark themes.
  ///
  /// If true and [brightness] is [Brightness.dark], a
  /// semi-transparent version of [ColorScheme.onSurface] will be
  /// applied on top of [Material] widgets that have a [ColorScheme.surface]
  /// color. The level of transparency is based on [Material.elevation] as
  /// per the Material Dark theme specification.
  ///
  /// If false the surface color will be used unmodified.
  ///
  /// Defaults to false in order to maintain backwards compatibility with
  /// apps that were built before the Material Dark theme specification
  /// was published. New apps should set this to true for any themes
  /// where [brightness] is [Brightness.dark].
  ///
  /// See also:
  ///
  ///  * [Material.elevation], which effects the level of transparency of the
  ///    overlay color.
  ///  * [ElevationOverlay.applyOverlay], which is used by [Material] to apply
  ///    the overlay color to its surface color.
  ///  * <https://material.io/design/color/dark-theme.html>, which specifies how
  ///    the overlay should be applied.
  final bool applyElevationOverlayColor;

  /// Components of the [CupertinoThemeData] to override from the Material
  /// [ThemeData] adaptation.
  ///
  /// By default, [cupertinoOverrideTheme] is null and Cupertino widgets
  /// descendant to the Material [Theme] will adhere to a [CupertinoTheme]
  /// derived from the Material [ThemeData]. e.g. [ThemeData]'s [ColorScheme]
  /// will also inform the [CupertinoThemeData]'s `primaryColor` etc.
  ///
  /// This cascading effect for individual attributes of the [CupertinoThemeData]
  /// can be overridden using attributes of this [cupertinoOverrideTheme].
  final NoDefaultCupertinoThemeData? cupertinoOverrideTheme;

  /// Arbitrary additions to this theme.
  ///
  /// To define extensions, pass an [Iterable] containing one or more [ThemeExtension]
  /// subclasses to [ThemeData.new] or [copyWith].
  ///
  /// To obtain an extension, use [extension].
  ///
  /// {@tool dartpad}
  /// This sample shows how to create and use a subclass of [ThemeExtension] that
  /// defines two colors.
  ///
  /// ** See code in examples/api/lib/material/theme/theme_extension.1.dart **
  /// {@end-tool}
  ///
  /// See also:
  ///
  /// * [extension], a convenience function for obtaining a specific extension.
  final Map<Object, ThemeExtension<dynamic>> extensions;

  /// Used to obtain a particular [ThemeExtension] from [extensions].
  ///
  /// Obtain with `Theme.of(context).extension<MyThemeExtension>()`.
  ///
  /// See [extensions] for an interactive example.
  T? extension<T>() => extensions[T] as T?;

  /// A map which contains the adaptations for the theme. The entry's key is the
  /// type of the adaptation; the value is the adaptation itself.
  ///
  /// To obtain an adaptation, use [getAdaptation].
  final Map<Type, Adaptation<Object>> adaptationMap;

  /// The default [InputDecoration] values for [InputDecorator], [TextField],
  /// and [TextFormField] are based on this theme.
  ///
  /// See [InputDecoration.applyDefaults].
  final InputDecorationTheme inputDecorationTheme;

  /// Configures the hit test size of certain Material widgets.
  ///
  /// Defaults to a [platform]-appropriate size: [MaterialTapTargetSize.padded]
  /// on mobile platforms, [MaterialTapTargetSize.shrinkWrap] on desktop
  /// platforms.
  final MaterialTapTargetSize materialTapTargetSize;

  /// Default [MaterialPageRoute] transitions per [TargetPlatform].
  ///
  /// [MaterialPageRoute.buildTransitions] delegates to a [platform] specific
  /// [PageTransitionsBuilder]. If a matching builder is not found, a builder
  /// whose platform is null is used.
  final PageTransitionsTheme pageTransitionsTheme;

  /// The platform the material widgets should adapt to target.
  ///
  /// Defaults to the current platform, as exposed by [defaultTargetPlatform].
  /// This should be used in order to style UI elements according to platform
  /// conventions.
  ///
  /// Widgets from the material library should use this getter (via [Theme.of])
  /// to determine the current platform for the purpose of emulating the
  /// platform behavior (e.g. scrolling or haptic effects). Widgets and render
  /// objects at lower layers that try to emulate the underlying platform
  /// can depend on [defaultTargetPlatform] directly, or may require
  /// that the target platform be provided as an argument. The
  /// [dart:io.Platform] object should only be used directly when it's critical
  /// to actually know the current platform, without any overrides possible (for
  /// example, when a system API is about to be called).
  ///
  /// In a test environment, the platform returned is [TargetPlatform.android]
  /// regardless of the host platform. (Android was chosen because the tests
  /// were originally written assuming Android-like behavior, and we added
  /// platform adaptations for other platforms later). Tests can check behavior
  /// for other platforms by setting the [platform] of the [Theme] explicitly to
  /// another [TargetPlatform] value, or by setting
  /// [debugDefaultTargetPlatformOverride].
  ///
  /// Determines the defaults for [typography] and [materialTapTargetSize].
  final TargetPlatform platform;

  /// A theme for customizing the colors, thickness, and shape of [Scrollbar]s.
  final ScrollbarThemeData scrollbarTheme;

  /// Defines the appearance of ink splashes produces by [InkWell]
  /// and [InkResponse].
  ///
  /// See also:
  ///
  ///  * [InkSplash.splashFactory], which defines the default splash.
  ///  * [InkRipple.splashFactory], which defines a splash that spreads out
  ///    more aggressively than the default.
  ///  * [InkSparkle.splashFactory], which defines a more aggressive and organic
  ///    splash with sparkle effects.
  final InteractiveInkFeatureFactory splashFactory;

  /// A temporary flag that can be used to opt-out of Material 3 features.
  ///
  /// This flag is _true_ by default. If false, then components will
  /// continue to use the colors, typography and other features of
  /// Material 2.
  ///
  /// In the long run this flag will be deprecated and eventually
  /// only Material 3 will be supported. We recommend that applications
  /// migrate to Material 3 as soon as that's practical. Until that migration
  /// is complete, this flag can be set to false.
  ///
  /// ## Defaults
  ///
  /// If a [ThemeData] is _constructed_ with [useMaterial3] set to true, then
  /// some properties will get updated defaults. However, the
  /// [ThemeData.copyWith] method with [useMaterial3] set to true will _not_
  /// change any of these properties in the resulting [ThemeData].
  ///
  /// <style>table,td,th { border-collapse: collapse; padding: 0.45em; } td { border: 1px solid }</style>
  ///
  /// | Property        | Material 3 default             | Material 2 default             |
  /// | :-------------- | :----------------------------- | :----------------------------- |
  /// | [colorScheme]   | M3 baseline light color scheme | M2 baseline light color scheme |
  /// | [typography]    | [Typography.material2021]      | [Typography.material2014]      |
  /// | [splashFactory] | [InkSparkle]* or [InkRipple]   | [InkSplash]                    |
  ///
  /// \* if the target platform is Android and the app is not
  /// running on the web, otherwise it will fallback to [InkRipple].
  ///
  /// If [brightness] is [Brightness.dark] then the default color scheme will
  /// be either the M3 baseline dark color scheme or the M2 baseline dark color
  /// scheme depending on [useMaterial3].
  ///
  /// ## Affected widgets
  ///
  /// This flag affects styles and components.
  ///
  /// ### Styles
  ///   * Color: [ColorScheme], [Material] (see table above)
  ///   * Shape: (see components below)
  ///   * Typography: [Typography] (see table above)
  ///
  /// ### Components
  ///   * Badges: [Badge]
  ///   * Bottom app bar: [BottomAppBar]
  ///   * Bottom sheets: [BottomSheet]
  ///   * Buttons
  ///     - Common buttons: [ElevatedButton], [FilledButton], [FilledButton.tonal], [OutlinedButton], [TextButton]
  ///     - FAB: [FloatingActionButton], [FloatingActionButton.extended]
  ///     - Icon buttons: [IconButton], [IconButton.filled] (*new*), [IconButton.filledTonal], [IconButton.outlined]
  ///     - Segmented buttons: [SegmentedButton] (replacing [ToggleButtons])
  ///   * Cards: [Card]
  ///   * Checkbox: [Checkbox], [CheckboxListTile]
  ///   * Chips:
  ///     - [ActionChip] (used for Assist and Suggestion chips),
  ///     - [FilterChip], [ChoiceChip] (used for single selection filter chips),
  ///     - [InputChip]
  ///   * Date pickers: [showDatePicker], [showDateRangePicker], [DatePickerDialog], [DateRangePickerDialog], [InputDatePickerFormField]
  ///   * Dialogs: [AlertDialog], [Dialog.fullscreen]
  ///   * Divider: [Divider], [VerticalDivider]
  ///   * Lists: [ListTile]
  ///   * Menus: [MenuAnchor], [DropdownMenu], [MenuBar]
  ///   * Navigation bar: [NavigationBar] (replacing [BottomNavigationBar])
  ///   * Navigation drawer: [NavigationDrawer] (replacing [Drawer])
  ///   * Navigation rail: [NavigationRail]
  ///   * Progress indicators: [CircularProgressIndicator], [LinearProgressIndicator]
  ///   * Radio button: [Radio], [RadioListTile]
  ///   * Search: [SearchBar], [SearchAnchor],
  ///   * Snack bar: [SnackBar]
  ///   * Slider: [Slider], [RangeSlider]
  ///   * Switch: [Switch], [SwitchListTile]
  ///   * Tabs: [TabBar], [TabBar.secondary]
  ///   * TextFields: [TextField] together with its [InputDecoration]
  ///   * Time pickers: [showTimePicker], [TimePickerDialog]
  ///   * Top app bar: [AppBar], [SliverAppBar], [SliverAppBar.medium], [SliverAppBar.large]
  ///
  /// In addition, this flag enables features introduced in Android 12.
  ///   * Stretch overscroll: [MaterialScrollBehavior]
  ///   * Ripple: `splashFactory` (see table above)
  ///
  /// See also:
  ///
  ///   * [Material 3 specification](https://m3.material.io/).
  final bool useMaterial3;

  /// The density value for specifying the compactness of various UI components.
  ///
  /// {@template flutter.material.themedata.visualDensity}
  /// Density, in the context of a UI, is the vertical and horizontal
  /// "compactness" of the elements in the UI. It is unitless, since it means
  /// different things to different UI elements. For buttons, it affects the
  /// spacing around the centered label of the button. For lists, it affects the
  /// distance between baselines of entries in the list.
  ///
  /// Typically, density values are integral, but any value in range may be
  /// used. The range includes values from [VisualDensity.minimumDensity] (which
  /// is -4), to [VisualDensity.maximumDensity] (which is 4), inclusive, where
  /// negative values indicate a denser, more compact, UI, and positive values
  /// indicate a less dense, more expanded, UI. If a component doesn't support
  /// the value given, it will clamp to the nearest supported value.
  ///
  /// The default for visual densities is zero for both vertical and horizontal
  /// densities, which corresponds to the default visual density of components
  /// in the Material Design specification.
  ///
  /// As a rule of thumb, a change of 1 or -1 in density corresponds to 4
  /// logical pixels. However, this is not a strict relationship since
  /// components interpret the density values appropriately for their needs.
  ///
  /// A larger value translates to a spacing increase (less dense), and a
  /// smaller value translates to a spacing decrease (more dense).
  ///
  /// In Material Design 3, the [visualDensity] does not override the value of
  /// [IconButton.visualDensity] which defaults to [VisualDensity.standard]
  /// for all platforms. To override the default value of [IconButton.visualDensity],
  /// use [ThemeData.iconButtonTheme] instead.
  /// {@endtemplate}
  final VisualDensity visualDensity;

  // COLOR

  /// The default color of [MaterialType.canvas] [Material].
  final Color canvasColor;

  /// The color of [Material] when it is used as a [Card].
  final Color cardColor;

  /// {@macro flutter.material.color_scheme.ColorScheme}
  ///
  /// This property was added much later than the theme's set of highly specific
  /// colors, like [cardColor], [canvasColor] etc. New components can be defined
  /// exclusively in terms of [colorScheme]. Existing components will gradually
  /// migrate to it, to the extent that is possible without significant
  /// backwards compatibility breaks.
  final ColorScheme colorScheme;

  /// The color used for widgets that are inoperative, regardless of
  /// their state. For example, a disabled checkbox (which may be
  /// checked or unchecked).
  final Color disabledColor;

  /// The color of [Divider]s and [PopupMenuDivider]s, also used
  /// between [ListTile]s, between rows in [DataTable]s, and so forth.
  ///
  /// To create an appropriate [BorderSide] that uses this color, consider
  /// [Divider.createBorderSide].
  final Color dividerColor;

  /// The focus color used indicate that a component has the input focus.
  final Color focusColor;

  /// The highlight color used during ink splash animations or to
  /// indicate an item in a menu is selected.
  final Color highlightColor;

  /// The color to use for hint text or placeholder text, e.g. in
  /// [TextField] fields.
  final Color hintColor;

  /// The hover color used to indicate when a pointer is hovering over a
  /// component.
  final Color hoverColor;

  /// The color of the selected tab indicator in a tab bar.
  final Color indicatorColor;

  /// The background color for major parts of the app (toolbars, tab bars, etc)
  ///
  /// The theme's [colorScheme] property contains [ColorScheme.primary], as
  /// well as a color that contrasts well with the primary color called
  /// [ColorScheme.onPrimary]. It might be simpler to just configure an app's
  /// visuals in terms of the theme's [colorScheme].
  final Color primaryColor;

  /// A darker version of the [primaryColor].
  final Color primaryColorDark;

  /// A lighter version of the [primaryColor].
  final Color primaryColorLight;

  /// The default color of the [Material] that underlies the [Scaffold]. The
  /// background color for a typical material app or a page within the app.
  final Color scaffoldBackgroundColor;

  /// The color of the header of a [PaginatedDataTable] when there are selected rows.
  // According to the spec for data tables:
  // https://material.io/archive/guidelines/components/data-tables.html#data-tables-tables-within-cards
  // ...this should be the "50-value of secondary app color".
  final Color secondaryHeaderColor;

  /// The color that the [Material] widget uses to draw elevation shadows.
  ///
  /// Defaults to fully opaque black.
  ///
  /// Shadows can be difficult to see in a dark theme, so the elevation of a
  /// surface should be rendered with an "overlay" in addition to the shadow.
  /// As the elevation of the component increases, the overlay increases in
  /// opacity. The [applyElevationOverlayColor] property turns the elevation
  /// overlay on or off for dark themes.
  final Color shadowColor;

  /// The color of ink splashes.
  ///
  /// See also:
  ///  * [splashFactory], which defines the appearance of the splash.
  final Color splashColor;

  /// The color used for widgets in their inactive (but enabled)
  /// state. For example, an unchecked checkbox. See also [disabledColor].
  final Color unselectedWidgetColor;

  // TYPOGRAPHY & ICONOGRAPHY

  /// An icon theme that contrasts with the card and canvas colors.
  final IconThemeData iconTheme;

  /// An icon theme that contrasts with the primary color.
  final IconThemeData primaryIconTheme;

  /// A text theme that contrasts with the primary color.
  final TextTheme primaryTextTheme;

  /// Text with a color that contrasts with the card and canvas colors.
  final TextTheme textTheme;

  /// The color and geometry [TextTheme] values used to configure [textTheme].
  ///
  /// Defaults to a [platform]-appropriate typography.
  final Typography typography;

  // COMPONENT THEMES

  /// A theme for customizing icons of [BackButtonIcon], [CloseButtonIcon],
  /// [DrawerButtonIcon], or [EndDrawerButtonIcon].
  final ActionIconThemeData? actionIconTheme;

  /// A theme for customizing the color, elevation, brightness, iconTheme and
  /// textTheme of [AppBar]s.
  final AppBarTheme appBarTheme;

  /// A theme for customizing the color of [Badge]s.
  final BadgeThemeData badgeTheme;

  /// A theme for customizing the color and text style of a [MaterialBanner].
  final MaterialBannerThemeData bannerTheme;

  /// A theme for customizing the shape, elevation, and color of a [BottomAppBar].
  final BottomAppBarTheme bottomAppBarTheme;

  /// A theme for customizing the appearance and layout of [BottomNavigationBar]
  /// widgets.
  final BottomNavigationBarThemeData bottomNavigationBarTheme;

  /// A theme for customizing the color, elevation, and shape of a bottom sheet.
  final BottomSheetThemeData bottomSheetTheme;

  /// Defines the default configuration of button widgets, like [DropdownButton]
  /// and [ButtonBar].
  final ButtonThemeData buttonTheme;

  /// The colors and styles used to render [Card].
  ///
  /// This is the value returned from [CardTheme.of].
  final CardThemeData cardTheme;

  /// A theme for customizing the appearance and layout of [Checkbox] widgets.
  final CheckboxThemeData checkboxTheme;

  /// The colors and styles used to render [Chip]s.
  ///
  /// This is the value returned from [ChipTheme.of].
  final ChipThemeData chipTheme;

  /// A theme for customizing the appearance and layout of [DataTable]
  /// widgets.
  final DataTableThemeData dataTableTheme;

  /// A theme for customizing the appearance and layout of [DatePickerDialog]
  /// widgets.
  final DatePickerThemeData datePickerTheme;

  /// A theme for customizing the shape of a dialog.
  final DialogThemeData dialogTheme;

  /// A theme for customizing the color, thickness, and indents of [Divider]s,
  /// [VerticalDivider]s, etc.
  final DividerThemeData dividerTheme;

  /// A theme for customizing the appearance and layout of [Drawer] widgets.
  final DrawerThemeData drawerTheme;

  /// A theme for customizing the appearance and layout of [DropdownMenu] widgets.
  final DropdownMenuThemeData dropdownMenuTheme;

  /// A theme for customizing the appearance and internal layout of
  /// [ElevatedButton]s.
  final ElevatedButtonThemeData elevatedButtonTheme;

  /// A theme for customizing the visual properties of [ExpansionTile]s.
  final ExpansionTileThemeData expansionTileTheme;

  /// A theme for customizing the appearance and internal layout of
  /// [FilledButton]s.
  final FilledButtonThemeData filledButtonTheme;

  /// A theme for customizing the shape, elevation, and color of a
  /// [FloatingActionButton].
  final FloatingActionButtonThemeData floatingActionButtonTheme;

  /// A theme for customizing the appearance and internal layout of
  /// [IconButton]s.
  final IconButtonThemeData iconButtonTheme;

  /// A theme for customizing the appearance of [ListTile] widgets.
  final ListTileThemeData listTileTheme;

  /// A theme for customizing the color, shape, elevation, and other [MenuStyle]
  /// aspects of the menu bar created by the [MenuBar] widget.
  final MenuBarThemeData menuBarTheme;

  /// A theme for customizing the color, shape, elevation, and text style of
  /// cascading menu buttons created by [SubmenuButton] or [MenuItemButton].
  final MenuButtonThemeData menuButtonTheme;

  /// A theme for customizing the color, shape, elevation, and other [MenuStyle]
  /// attributes of menus created by the [SubmenuButton] widget.
  final MenuThemeData menuTheme;

  /// A theme for customizing the background color, text style, and icon themes
  /// of a [NavigationBar].
  final NavigationBarThemeData navigationBarTheme;

  /// A theme for customizing the background color, text style, and icon themes
  /// of a [NavigationDrawer].
  final NavigationDrawerThemeData navigationDrawerTheme;

  /// A theme for customizing the background color, elevation, text style, and
  /// icon themes of a [NavigationRail].
  final NavigationRailThemeData navigationRailTheme;

  /// A theme for customizing the appearance and internal layout of
  /// [OutlinedButton]s.
  final OutlinedButtonThemeData outlinedButtonTheme;

  /// A theme for customizing the color, shape, elevation, and text style of
  /// popup menus.
  final PopupMenuThemeData popupMenuTheme;

  /// A theme for customizing the appearance and layout of [ProgressIndicator] widgets.
  final ProgressIndicatorThemeData progressIndicatorTheme;

  /// A theme for customizing the appearance and layout of [Radio] widgets.
  final RadioThemeData radioTheme;

  /// A theme for customizing the appearance and layout of [SearchBar] widgets.
  final SearchBarThemeData searchBarTheme;

  /// A theme for customizing the appearance and layout of search views created by [SearchAnchor] widgets.
  final SearchViewThemeData searchViewTheme;

  /// A theme for customizing the appearance and layout of [SegmentedButton] widgets.
  final SegmentedButtonThemeData segmentedButtonTheme;

  /// The colors and shapes used to render [Slider].
  ///
  /// This is the value returned from [SliderTheme.of].
  final SliderThemeData sliderTheme;

  /// A theme for customizing colors, shape, elevation, and behavior of a [SnackBar].
  final SnackBarThemeData snackBarTheme;

  /// A theme for customizing the appearance and layout of [Switch] widgets.
  final SwitchThemeData switchTheme;

  /// A theme for customizing the size, shape, and color of the tab bar indicator.
  final TabBarThemeData tabBarTheme;

  /// A theme for customizing the appearance and internal layout of
  /// [TextButton]s.
  final TextButtonThemeData textButtonTheme;

  /// A theme for customizing the appearance and layout of [TextField] widgets.
  final TextSelectionThemeData textSelectionTheme;

  /// A theme for customizing the appearance and layout of time picker widgets.
  final TimePickerThemeData timePickerTheme;

  /// Defines the default configuration of [ToggleButtons] widgets.
  final ToggleButtonsThemeData toggleButtonsTheme;

  /// A theme for customizing the visual properties of [Tooltip]s.
  ///
  /// This is the value returned from [TooltipTheme.of].
  final TooltipThemeData tooltipTheme;

  /// A theme for customizing the appearance and layout of [ButtonBar] widgets.
  @Deprecated(
    'Use OverflowBar instead. '
    'This feature was deprecated after v3.21.0-10.0.pre.',
  )
  ButtonBarThemeData get buttonBarTheme => _buttonBarTheme!;
  final ButtonBarThemeData? _buttonBarTheme;

  /// The background color of [Dialog] elements.
  @Deprecated(
    'Use DialogThemeData.backgroundColor instead. '
    'This feature was deprecated after v3.27.0-0.1.pre.',
  )
  final Color dialogBackgroundColor;

  /// Creates a copy of this theme but with the given fields replaced with the new values.
  ///
  /// The [brightness] value is applied to the [colorScheme].
  ThemeData copyWith({
    // For the sanity of the reader, make sure these properties are in the same
    // order in every place that they are separated by section comments (e.g.
    // GENERAL CONFIGURATION). Each section except for deprecations should be
    // alphabetical by symbol name.

    // GENERAL CONFIGURATION
    Iterable<Adaptation<Object>>? adaptations,
    bool? applyElevationOverlayColor,
    NoDefaultCupertinoThemeData? cupertinoOverrideTheme,
    Iterable<ThemeExtension<dynamic>>? extensions,
    InputDecorationTheme? inputDecorationTheme,
    MaterialTapTargetSize? materialTapTargetSize,
    PageTransitionsTheme? pageTransitionsTheme,
    TargetPlatform? platform,
    ScrollbarThemeData? scrollbarTheme,
    InteractiveInkFeatureFactory? splashFactory,
    VisualDensity? visualDensity,
    // COLOR
    ColorScheme? colorScheme,
    Brightness? brightness,
    // [colorScheme] is the preferred way to configure colors. The [Color] properties
    // listed below (as well as primarySwatch) will gradually be phased out, see
    // https://github.com/flutter/flutter/issues/91772.
    Color? canvasColor,
    Color? cardColor,
    Color? disabledColor,
    Color? dividerColor,
    Color? focusColor,
    Color? highlightColor,
    Color? hintColor,
    Color? hoverColor,
    Color? indicatorColor,
    Color? primaryColor,
    Color? primaryColorDark,
    Color? primaryColorLight,
    Color? scaffoldBackgroundColor,
    Color? secondaryHeaderColor,
    Color? shadowColor,
    Color? splashColor,
    Color? unselectedWidgetColor,
    // TYPOGRAPHY & ICONOGRAPHY
    IconThemeData? iconTheme,
    IconThemeData? primaryIconTheme,
    TextTheme? primaryTextTheme,
    TextTheme? textTheme,
    Typography? typography,
    // COMPONENT THEMES
    ActionIconThemeData? actionIconTheme,
    AppBarTheme? appBarTheme,
    BadgeThemeData? badgeTheme,
    MaterialBannerThemeData? bannerTheme,
    BottomAppBarTheme? bottomAppBarTheme,
    BottomNavigationBarThemeData? bottomNavigationBarTheme,
    BottomSheetThemeData? bottomSheetTheme,
    ButtonThemeData? buttonTheme,
    Object? cardTheme,
    CheckboxThemeData? checkboxTheme,
    ChipThemeData? chipTheme,
    DataTableThemeData? dataTableTheme,
    DatePickerThemeData? datePickerTheme,
    // TODO(QuncCccccc): Change the parameter type to DialogThemeData
    Object? dialogTheme,
    DividerThemeData? dividerTheme,
    DrawerThemeData? drawerTheme,
    DropdownMenuThemeData? dropdownMenuTheme,
    ElevatedButtonThemeData? elevatedButtonTheme,
    ExpansionTileThemeData? expansionTileTheme,
    FilledButtonThemeData? filledButtonTheme,
    FloatingActionButtonThemeData? floatingActionButtonTheme,
    IconButtonThemeData? iconButtonTheme,
    ListTileThemeData? listTileTheme,
    MenuBarThemeData? menuBarTheme,
    MenuButtonThemeData? menuButtonTheme,
    MenuThemeData? menuTheme,
    NavigationBarThemeData? navigationBarTheme,
    NavigationDrawerThemeData? navigationDrawerTheme,
    NavigationRailThemeData? navigationRailTheme,
    OutlinedButtonThemeData? outlinedButtonTheme,
    PopupMenuThemeData? popupMenuTheme,
    ProgressIndicatorThemeData? progressIndicatorTheme,
    RadioThemeData? radioTheme,
    SearchBarThemeData? searchBarTheme,
    SearchViewThemeData? searchViewTheme,
    SegmentedButtonThemeData? segmentedButtonTheme,
    SliderThemeData? sliderTheme,
    SnackBarThemeData? snackBarTheme,
    SwitchThemeData? switchTheme,
    // TODO(QuncCccccc): Change the parameter type to TabBarThemeData
    Object? tabBarTheme,
    TextButtonThemeData? textButtonTheme,
    TextSelectionThemeData? textSelectionTheme,
    TimePickerThemeData? timePickerTheme,
    ToggleButtonsThemeData? toggleButtonsTheme,
    TooltipThemeData? tooltipTheme,
    // DEPRECATED (newest deprecations at the bottom)
    @Deprecated(
      'Use a ThemeData constructor (.from, .light, or .dark) instead. '
      'These constructors all have a useMaterial3 argument, '
      'and they set appropriate default values based on its value. '
      'See the useMaterial3 API documentation for full details. '
      'This feature was deprecated after v3.13.0-0.2.pre.',
    )
    bool? useMaterial3,
    @Deprecated(
      'Use OverflowBar instead. '
      'This feature was deprecated after v3.21.0-10.0.pre.',
    )
    ButtonBarThemeData? buttonBarTheme,
    @Deprecated(
      'Use DialogThemeData.backgroundColor instead. '
      'This feature was deprecated after v3.27.0-0.1.pre.',
    )
    Color? dialogBackgroundColor,
  }) {
    cupertinoOverrideTheme = cupertinoOverrideTheme?.noDefault();

    // TODO(QuncCccccc): Clean it up once the type of `cardTheme` is changed to `CardThemeData`
    if (cardTheme != null) {
      if (cardTheme is CardTheme) {
        cardTheme = cardTheme.data;
      } else if (cardTheme is! CardThemeData) {
        throw ArgumentError('cardTheme must be either a CardThemeData or a CardTheme');
      }
    }

    // TODO(QuncCccccc): Clean this up once the type of `dialogTheme` is changed to `DialogThemeData`
    if (dialogTheme != null) {
      if (dialogTheme is DialogTheme) {
        dialogTheme = dialogTheme.data;
      } else if (dialogTheme is! DialogThemeData) {
        throw ArgumentError('dialogTheme must be either a DialogThemeData or a DialogTheme');
      }
    }

    // TODO(QuncCccccc): Clean this up once the type of `tabBarTheme` is changed to `TabBarThemeData`
    if (tabBarTheme != null) {
      if (tabBarTheme is TabBarTheme) {
        tabBarTheme = tabBarTheme.data;
      } else if (tabBarTheme is! TabBarThemeData) {
        throw ArgumentError('tabBarTheme must be either a TabBarThemeData or a TabBarTheme');
      }
    }
    return ThemeData.raw(
      // For the sanity of the reader, make sure these properties are in the same
      // order in every place that they are separated by section comments (e.g.
      // GENERAL CONFIGURATION). Each section except for deprecations should be
      // alphabetical by symbol name.

      // GENERAL CONFIGURATION
      adaptationMap: adaptations != null ? _createAdaptationMap(adaptations) : adaptationMap,
      applyElevationOverlayColor: applyElevationOverlayColor ?? this.applyElevationOverlayColor,
      cupertinoOverrideTheme: cupertinoOverrideTheme ?? this.cupertinoOverrideTheme,
      extensions: (extensions != null) ? _themeExtensionIterableToMap(extensions) : this.extensions,
      inputDecorationTheme: inputDecorationTheme ?? this.inputDecorationTheme,
      materialTapTargetSize: materialTapTargetSize ?? this.materialTapTargetSize,
      pageTransitionsTheme: pageTransitionsTheme ?? this.pageTransitionsTheme,
      platform: platform ?? this.platform,
      scrollbarTheme: scrollbarTheme ?? this.scrollbarTheme,
      splashFactory: splashFactory ?? this.splashFactory,
      // When deprecated useMaterial3 removed, maintain `this.useMaterial3` here
      // for == evaluation.
      useMaterial3: useMaterial3 ?? this.useMaterial3,
      visualDensity: visualDensity ?? this.visualDensity,
      // COLOR
      canvasColor: canvasColor ?? this.canvasColor,
      cardColor: cardColor ?? this.cardColor,
      colorScheme: (colorScheme ?? this.colorScheme).copyWith(brightness: brightness),
      disabledColor: disabledColor ?? this.disabledColor,
      dividerColor: dividerColor ?? this.dividerColor,
      focusColor: focusColor ?? this.focusColor,
      highlightColor: highlightColor ?? this.highlightColor,
      hintColor: hintColor ?? this.hintColor,
      hoverColor: hoverColor ?? this.hoverColor,
      indicatorColor: indicatorColor ?? this.indicatorColor,
      primaryColor: primaryColor ?? this.primaryColor,
      primaryColorDark: primaryColorDark ?? this.primaryColorDark,
      primaryColorLight: primaryColorLight ?? this.primaryColorLight,
      scaffoldBackgroundColor: scaffoldBackgroundColor ?? this.scaffoldBackgroundColor,
      secondaryHeaderColor: secondaryHeaderColor ?? this.secondaryHeaderColor,
      shadowColor: shadowColor ?? this.shadowColor,
      splashColor: splashColor ?? this.splashColor,
      unselectedWidgetColor: unselectedWidgetColor ?? this.unselectedWidgetColor,
      // TYPOGRAPHY & ICONOGRAPHY
      iconTheme: iconTheme ?? this.iconTheme,
      primaryIconTheme: primaryIconTheme ?? this.primaryIconTheme,
      primaryTextTheme: primaryTextTheme ?? this.primaryTextTheme,
      textTheme: textTheme ?? this.textTheme,
      typography: typography ?? this.typography,
      // COMPONENT THEMES
      actionIconTheme: actionIconTheme ?? this.actionIconTheme,
      appBarTheme: appBarTheme ?? this.appBarTheme,
      badgeTheme: badgeTheme ?? this.badgeTheme,
      bannerTheme: bannerTheme ?? this.bannerTheme,
      bottomAppBarTheme: bottomAppBarTheme ?? this.bottomAppBarTheme,
      bottomNavigationBarTheme: bottomNavigationBarTheme ?? this.bottomNavigationBarTheme,
      bottomSheetTheme: bottomSheetTheme ?? this.bottomSheetTheme,
      buttonTheme: buttonTheme ?? this.buttonTheme,
      cardTheme: cardTheme as CardThemeData? ?? this.cardTheme,
      checkboxTheme: checkboxTheme ?? this.checkboxTheme,
      chipTheme: chipTheme ?? this.chipTheme,
      dataTableTheme: dataTableTheme ?? this.dataTableTheme,
      datePickerTheme: datePickerTheme ?? this.datePickerTheme,
      dialogTheme: dialogTheme as DialogThemeData? ?? this.dialogTheme,
      dividerTheme: dividerTheme ?? this.dividerTheme,
      drawerTheme: drawerTheme ?? this.drawerTheme,
      dropdownMenuTheme: dropdownMenuTheme ?? this.dropdownMenuTheme,
      elevatedButtonTheme: elevatedButtonTheme ?? this.elevatedButtonTheme,
      expansionTileTheme: expansionTileTheme ?? this.expansionTileTheme,
      filledButtonTheme: filledButtonTheme ?? this.filledButtonTheme,
      floatingActionButtonTheme: floatingActionButtonTheme ?? this.floatingActionButtonTheme,
      iconButtonTheme: iconButtonTheme ?? this.iconButtonTheme,
      listTileTheme: listTileTheme ?? this.listTileTheme,
      menuBarTheme: menuBarTheme ?? this.menuBarTheme,
      menuButtonTheme: menuButtonTheme ?? this.menuButtonTheme,
      menuTheme: menuTheme ?? this.menuTheme,
      navigationBarTheme: navigationBarTheme ?? this.navigationBarTheme,
      navigationDrawerTheme: navigationDrawerTheme ?? this.navigationDrawerTheme,
      navigationRailTheme: navigationRailTheme ?? this.navigationRailTheme,
      outlinedButtonTheme: outlinedButtonTheme ?? this.outlinedButtonTheme,
      popupMenuTheme: popupMenuTheme ?? this.popupMenuTheme,
      progressIndicatorTheme: progressIndicatorTheme ?? this.progressIndicatorTheme,
      radioTheme: radioTheme ?? this.radioTheme,
      searchBarTheme: searchBarTheme ?? this.searchBarTheme,
      searchViewTheme: searchViewTheme ?? this.searchViewTheme,
      segmentedButtonTheme: segmentedButtonTheme ?? this.segmentedButtonTheme,
      sliderTheme: sliderTheme ?? this.sliderTheme,
      snackBarTheme: snackBarTheme ?? this.snackBarTheme,
      switchTheme: switchTheme ?? this.switchTheme,
      tabBarTheme: tabBarTheme as TabBarThemeData? ?? this.tabBarTheme,
      textButtonTheme: textButtonTheme ?? this.textButtonTheme,
      textSelectionTheme: textSelectionTheme ?? this.textSelectionTheme,
      timePickerTheme: timePickerTheme ?? this.timePickerTheme,
      toggleButtonsTheme: toggleButtonsTheme ?? this.toggleButtonsTheme,
      tooltipTheme: tooltipTheme ?? this.tooltipTheme,
      // DEPRECATED (newest deprecations at the bottom)
      buttonBarTheme: buttonBarTheme ?? _buttonBarTheme,
      dialogBackgroundColor: dialogBackgroundColor ?? this.dialogBackgroundColor,
    );
  }

  // The number 5 was chosen without any real science or research behind it. It
  // just seemed like a number that's not too big (we should be able to fit 5
  // copies of ThemeData in memory comfortably) and not too small (most apps
  // shouldn't have more than 5 theme/localization pairs).
  static const int _localizedThemeDataCacheSize = 5;

  /// Caches localized themes to speed up the [localize] method.
  static final _FifoCache<_IdentityThemeDataCacheKey, ThemeData> _localizedThemeDataCache =
      _FifoCache<_IdentityThemeDataCacheKey, ThemeData>(_localizedThemeDataCacheSize);

  /// Returns a new theme built by merging the text geometry provided by the
  /// [localTextGeometry] theme with the [baseTheme].
  ///
  /// For those text styles in the [baseTheme] whose [TextStyle.inherit] is set
  /// to true, the returned theme's text styles inherit the geometric properties
  /// of [localTextGeometry]. The resulting text styles' [TextStyle.inherit] is
  /// set to those provided by [localTextGeometry].
  static ThemeData localize(ThemeData baseTheme, TextTheme localTextGeometry) {
    // WARNING: this method memoizes the result in a cache based on the
    // previously seen baseTheme and localTextGeometry. Memoization is safe
    // because all inputs and outputs of this function are deeply immutable, and
    // the computations are referentially transparent. It only short-circuits
    // the computation if the new inputs are identical() to the previous ones.
    // It does not use the == operator, which performs a costly deep comparison.
    //
    // When changing this method, make sure the memoization logic is correct.
    // Remember:
    //
    // There are only two hard things in Computer Science: cache invalidation
    // and naming things. -- Phil Karlton

    return _localizedThemeDataCache.putIfAbsent(
      _IdentityThemeDataCacheKey(baseTheme, localTextGeometry),
      () {
        return baseTheme.copyWith(
          primaryTextTheme: localTextGeometry.merge(baseTheme.primaryTextTheme),
          textTheme: localTextGeometry.merge(baseTheme.textTheme),
        );
      },
    );
  }

  /// Determines whether the given [Color] is [Brightness.light] or
  /// [Brightness.dark].
  ///
  /// This compares the luminosity of the given color to a threshold value that
  /// matches the Material Design specification.
  static Brightness estimateBrightnessForColor(Color color) {
    final double relativeLuminance = color.computeLuminance();

    // See <https://www.w3.org/TR/WCAG20/#contrast-ratiodef>
    // The spec says to use kThreshold=0.0525, but Material Design appears to bias
    // more towards using light text than WCAG20 recommends. Material Design spec
    // doesn't say what value to use, but 0.15 seemed close to what the Material
    // Design spec shows for its color palette on
    // <https://material.io/go/design-theming#color-color-palette>.
    const double kThreshold = 0.15;
    if ((relativeLuminance + 0.05) * (relativeLuminance + 0.05) > kThreshold) {
      return Brightness.light;
    }
    return Brightness.dark;
  }

  /// Linearly interpolate between two [extensions].
  ///
  /// Includes all theme extensions in [a] and [b].
  ///
  /// {@macro dart.ui.shadow.lerp}
  static Map<Object, ThemeExtension<dynamic>> _lerpThemeExtensions(
    ThemeData a,
    ThemeData b,
    double t,
  ) {
    // Lerp [a].
    final Map<Object, ThemeExtension<dynamic>> newExtensions = a.extensions.map((
      Object id,
      ThemeExtension<dynamic> extensionA,
    ) {
      final ThemeExtension<dynamic>? extensionB = b.extensions[id];
      return MapEntry<Object, ThemeExtension<dynamic>>(id, extensionA.lerp(extensionB, t));
    });
    // Add [b]-only extensions.
    newExtensions.addEntries(
      b.extensions.entries.where(
        (MapEntry<Object, ThemeExtension<dynamic>> entry) => !a.extensions.containsKey(entry.key),
      ),
    );

    return newExtensions;
  }

  /// Convert the [extensionsIterable] passed to [ThemeData.new] or [copyWith]
  /// to the stored [extensions] map, where each entry's key consists of the extension's type.
  static Map<Object, ThemeExtension<dynamic>> _themeExtensionIterableToMap(
    Iterable<ThemeExtension<dynamic>> extensionsIterable,
  ) {
    return Map<Object, ThemeExtension<dynamic>>.unmodifiable(<Object, ThemeExtension<dynamic>>{
      // Strangely, the cast is necessary for tests to run.
      for (final ThemeExtension<dynamic> extension in extensionsIterable)
        extension.type: extension as ThemeExtension<ThemeExtension<dynamic>>,
    });
  }

  /// Linearly interpolate between two themes.
  ///
  /// {@macro dart.ui.shadow.lerp}
  static ThemeData lerp(ThemeData a, ThemeData b, double t) {
    if (identical(a, b)) {
      return a;
    }
    return ThemeData.raw(
      // For the sanity of the reader, make sure these properties are in the same
      // order in every place that they are separated by section comments (e.g.
      // GENERAL CONFIGURATION). Each section except for deprecations should be
      // alphabetical by symbol name.

      // GENERAL CONFIGURATION
      adaptationMap: t < 0.5 ? a.adaptationMap : b.adaptationMap,
      applyElevationOverlayColor:
          t < 0.5 ? a.applyElevationOverlayColor : b.applyElevationOverlayColor,
      cupertinoOverrideTheme: t < 0.5 ? a.cupertinoOverrideTheme : b.cupertinoOverrideTheme,
      extensions: _lerpThemeExtensions(a, b, t),
      inputDecorationTheme: t < 0.5 ? a.inputDecorationTheme : b.inputDecorationTheme,
      materialTapTargetSize: t < 0.5 ? a.materialTapTargetSize : b.materialTapTargetSize,
      pageTransitionsTheme: t < 0.5 ? a.pageTransitionsTheme : b.pageTransitionsTheme,
      platform: t < 0.5 ? a.platform : b.platform,
      scrollbarTheme: ScrollbarThemeData.lerp(a.scrollbarTheme, b.scrollbarTheme, t),
      splashFactory: t < 0.5 ? a.splashFactory : b.splashFactory,
      useMaterial3: t < 0.5 ? a.useMaterial3 : b.useMaterial3,
      visualDensity: VisualDensity.lerp(a.visualDensity, b.visualDensity, t),
      // COLOR
      canvasColor: Color.lerp(a.canvasColor, b.canvasColor, t)!,
      cardColor: Color.lerp(a.cardColor, b.cardColor, t)!,
      colorScheme: ColorScheme.lerp(a.colorScheme, b.colorScheme, t),
      disabledColor: Color.lerp(a.disabledColor, b.disabledColor, t)!,
      dividerColor: Color.lerp(a.dividerColor, b.dividerColor, t)!,
      focusColor: Color.lerp(a.focusColor, b.focusColor, t)!,
      highlightColor: Color.lerp(a.highlightColor, b.highlightColor, t)!,
      hintColor: Color.lerp(a.hintColor, b.hintColor, t)!,
      hoverColor: Color.lerp(a.hoverColor, b.hoverColor, t)!,
      indicatorColor: Color.lerp(a.indicatorColor, b.indicatorColor, t)!,
      primaryColor: Color.lerp(a.primaryColor, b.primaryColor, t)!,
      primaryColorDark: Color.lerp(a.primaryColorDark, b.primaryColorDark, t)!,
      primaryColorLight: Color.lerp(a.primaryColorLight, b.primaryColorLight, t)!,
      scaffoldBackgroundColor: Color.lerp(a.scaffoldBackgroundColor, b.scaffoldBackgroundColor, t)!,
      secondaryHeaderColor: Color.lerp(a.secondaryHeaderColor, b.secondaryHeaderColor, t)!,
      shadowColor: Color.lerp(a.shadowColor, b.shadowColor, t)!,
      splashColor: Color.lerp(a.splashColor, b.splashColor, t)!,
      unselectedWidgetColor: Color.lerp(a.unselectedWidgetColor, b.unselectedWidgetColor, t)!,
      // TYPOGRAPHY & ICONOGRAPHY
      iconTheme: IconThemeData.lerp(a.iconTheme, b.iconTheme, t),
      primaryIconTheme: IconThemeData.lerp(a.primaryIconTheme, b.primaryIconTheme, t),
      primaryTextTheme: TextTheme.lerp(a.primaryTextTheme, b.primaryTextTheme, t),
      textTheme: TextTheme.lerp(a.textTheme, b.textTheme, t),
      typography: Typography.lerp(a.typography, b.typography, t),
      // COMPONENT THEMES
      actionIconTheme: ActionIconThemeData.lerp(a.actionIconTheme, b.actionIconTheme, t),
      appBarTheme: AppBarTheme.lerp(a.appBarTheme, b.appBarTheme, t),
      badgeTheme: BadgeThemeData.lerp(a.badgeTheme, b.badgeTheme, t),
      bannerTheme: MaterialBannerThemeData.lerp(a.bannerTheme, b.bannerTheme, t),
      bottomAppBarTheme: BottomAppBarTheme.lerp(a.bottomAppBarTheme, b.bottomAppBarTheme, t),
      bottomNavigationBarTheme: BottomNavigationBarThemeData.lerp(
        a.bottomNavigationBarTheme,
        b.bottomNavigationBarTheme,
        t,
      ),
      bottomSheetTheme: BottomSheetThemeData.lerp(a.bottomSheetTheme, b.bottomSheetTheme, t)!,
      buttonTheme: t < 0.5 ? a.buttonTheme : b.buttonTheme,
      cardTheme: CardThemeData.lerp(a.cardTheme, b.cardTheme, t),
      checkboxTheme: CheckboxThemeData.lerp(a.checkboxTheme, b.checkboxTheme, t),
      chipTheme: ChipThemeData.lerp(a.chipTheme, b.chipTheme, t)!,
      dataTableTheme: DataTableThemeData.lerp(a.dataTableTheme, b.dataTableTheme, t),
      datePickerTheme: DatePickerThemeData.lerp(a.datePickerTheme, b.datePickerTheme, t),
      dialogTheme: DialogThemeData.lerp(a.dialogTheme, b.dialogTheme, t),
      dividerTheme: DividerThemeData.lerp(a.dividerTheme, b.dividerTheme, t),
      drawerTheme: DrawerThemeData.lerp(a.drawerTheme, b.drawerTheme, t)!,
      dropdownMenuTheme: DropdownMenuThemeData.lerp(a.dropdownMenuTheme, b.dropdownMenuTheme, t),
      elevatedButtonTheme:
          ElevatedButtonThemeData.lerp(a.elevatedButtonTheme, b.elevatedButtonTheme, t)!,
      expansionTileTheme:
          ExpansionTileThemeData.lerp(a.expansionTileTheme, b.expansionTileTheme, t)!,
      filledButtonTheme: FilledButtonThemeData.lerp(a.filledButtonTheme, b.filledButtonTheme, t)!,
      floatingActionButtonTheme:
          FloatingActionButtonThemeData.lerp(
            a.floatingActionButtonTheme,
            b.floatingActionButtonTheme,
            t,
          )!,
      iconButtonTheme: IconButtonThemeData.lerp(a.iconButtonTheme, b.iconButtonTheme, t)!,
      listTileTheme: ListTileThemeData.lerp(a.listTileTheme, b.listTileTheme, t)!,
      menuBarTheme: MenuBarThemeData.lerp(a.menuBarTheme, b.menuBarTheme, t)!,
      menuButtonTheme: MenuButtonThemeData.lerp(a.menuButtonTheme, b.menuButtonTheme, t)!,
      menuTheme: MenuThemeData.lerp(a.menuTheme, b.menuTheme, t)!,
      navigationBarTheme:
          NavigationBarThemeData.lerp(a.navigationBarTheme, b.navigationBarTheme, t)!,
      navigationDrawerTheme:
          NavigationDrawerThemeData.lerp(a.navigationDrawerTheme, b.navigationDrawerTheme, t)!,
      navigationRailTheme:
          NavigationRailThemeData.lerp(a.navigationRailTheme, b.navigationRailTheme, t)!,
      outlinedButtonTheme:
          OutlinedButtonThemeData.lerp(a.outlinedButtonTheme, b.outlinedButtonTheme, t)!,
      popupMenuTheme: PopupMenuThemeData.lerp(a.popupMenuTheme, b.popupMenuTheme, t)!,
      progressIndicatorTheme:
          ProgressIndicatorThemeData.lerp(a.progressIndicatorTheme, b.progressIndicatorTheme, t)!,
      radioTheme: RadioThemeData.lerp(a.radioTheme, b.radioTheme, t),
      searchBarTheme: SearchBarThemeData.lerp(a.searchBarTheme, b.searchBarTheme, t)!,
      searchViewTheme: SearchViewThemeData.lerp(a.searchViewTheme, b.searchViewTheme, t)!,
      segmentedButtonTheme: SegmentedButtonThemeData.lerp(
        a.segmentedButtonTheme,
        b.segmentedButtonTheme,
        t,
      ),
      sliderTheme: SliderThemeData.lerp(a.sliderTheme, b.sliderTheme, t),
      snackBarTheme: SnackBarThemeData.lerp(a.snackBarTheme, b.snackBarTheme, t),
      switchTheme: SwitchThemeData.lerp(a.switchTheme, b.switchTheme, t),
      tabBarTheme: TabBarThemeData.lerp(a.tabBarTheme, b.tabBarTheme, t),
      textButtonTheme: TextButtonThemeData.lerp(a.textButtonTheme, b.textButtonTheme, t)!,
      textSelectionTheme:
          TextSelectionThemeData.lerp(a.textSelectionTheme, b.textSelectionTheme, t)!,
      timePickerTheme: TimePickerThemeData.lerp(a.timePickerTheme, b.timePickerTheme, t),
      toggleButtonsTheme:
          ToggleButtonsThemeData.lerp(a.toggleButtonsTheme, b.toggleButtonsTheme, t)!,
      tooltipTheme: TooltipThemeData.lerp(a.tooltipTheme, b.tooltipTheme, t)!,
      // DEPRECATED (newest deprecations at the bottom)
      buttonBarTheme: ButtonBarThemeData.lerp(a.buttonBarTheme, b.buttonBarTheme, t),
      dialogBackgroundColor: Color.lerp(a.dialogBackgroundColor, b.dialogBackgroundColor, t)!,
    );
  }

  @override
  bool operator ==(Object other) {
    if (other.runtimeType != runtimeType) {
      return false;
    }
    return other is ThemeData &&
        // For the sanity of the reader, make sure these properties are in the same
        // order in every place that they are separated by section comments (e.g.
        // GENERAL CONFIGURATION). Each section except for deprecations should be
        // alphabetical by symbol name.
        // GENERAL CONFIGURATION
        mapEquals(other.adaptationMap, adaptationMap) &&
        other.applyElevationOverlayColor == applyElevationOverlayColor &&
        other.cupertinoOverrideTheme == cupertinoOverrideTheme &&
        mapEquals(other.extensions, extensions) &&
        other.inputDecorationTheme == inputDecorationTheme &&
        other.materialTapTargetSize == materialTapTargetSize &&
        other.pageTransitionsTheme == pageTransitionsTheme &&
        other.platform == platform &&
        other.scrollbarTheme == scrollbarTheme &&
        other.splashFactory == splashFactory &&
        other.useMaterial3 == useMaterial3 &&
        other.visualDensity == visualDensity &&
        // COLOR
        other.canvasColor == canvasColor &&
        other.cardColor == cardColor &&
        other.colorScheme == colorScheme &&
        other.disabledColor == disabledColor &&
        other.dividerColor == dividerColor &&
        other.focusColor == focusColor &&
        other.highlightColor == highlightColor &&
        other.hintColor == hintColor &&
        other.hoverColor == hoverColor &&
        other.indicatorColor == indicatorColor &&
        other.primaryColor == primaryColor &&
        other.primaryColorDark == primaryColorDark &&
        other.primaryColorLight == primaryColorLight &&
        other.scaffoldBackgroundColor == scaffoldBackgroundColor &&
        other.secondaryHeaderColor == secondaryHeaderColor &&
        other.shadowColor == shadowColor &&
        other.splashColor == splashColor &&
        other.unselectedWidgetColor == unselectedWidgetColor &&
        // TYPOGRAPHY & ICONOGRAPHY
        other.iconTheme == iconTheme &&
        other.primaryIconTheme == primaryIconTheme &&
        other.primaryTextTheme == primaryTextTheme &&
        other.textTheme == textTheme &&
        other.typography == typography &&
        // COMPONENT THEMES
        other.actionIconTheme == actionIconTheme &&
        other.appBarTheme == appBarTheme &&
        other.badgeTheme == badgeTheme &&
        other.bannerTheme == bannerTheme &&
        other.bottomAppBarTheme == bottomAppBarTheme &&
        other.bottomNavigationBarTheme == bottomNavigationBarTheme &&
        other.bottomSheetTheme == bottomSheetTheme &&
        other.buttonTheme == buttonTheme &&
        other.cardTheme == cardTheme &&
        other.checkboxTheme == checkboxTheme &&
        other.chipTheme == chipTheme &&
        other.dataTableTheme == dataTableTheme &&
        other.datePickerTheme == datePickerTheme &&
        other.dialogTheme == dialogTheme &&
        other.dividerTheme == dividerTheme &&
        other.drawerTheme == drawerTheme &&
        other.dropdownMenuTheme == dropdownMenuTheme &&
        other.elevatedButtonTheme == elevatedButtonTheme &&
        other.expansionTileTheme == expansionTileTheme &&
        other.filledButtonTheme == filledButtonTheme &&
        other.floatingActionButtonTheme == floatingActionButtonTheme &&
        other.iconButtonTheme == iconButtonTheme &&
        other.listTileTheme == listTileTheme &&
        other.menuBarTheme == menuBarTheme &&
        other.menuButtonTheme == menuButtonTheme &&
        other.menuTheme == menuTheme &&
        other.navigationBarTheme == navigationBarTheme &&
        other.navigationDrawerTheme == navigationDrawerTheme &&
        other.navigationRailTheme == navigationRailTheme &&
        other.outlinedButtonTheme == outlinedButtonTheme &&
        other.popupMenuTheme == popupMenuTheme &&
        other.progressIndicatorTheme == progressIndicatorTheme &&
        other.radioTheme == radioTheme &&
        other.searchBarTheme == searchBarTheme &&
        other.searchViewTheme == searchViewTheme &&
        other.segmentedButtonTheme == segmentedButtonTheme &&
        other.sliderTheme == sliderTheme &&
        other.snackBarTheme == snackBarTheme &&
        other.switchTheme == switchTheme &&
        other.tabBarTheme == tabBarTheme &&
        other.textButtonTheme == textButtonTheme &&
        other.textSelectionTheme == textSelectionTheme &&
        other.timePickerTheme == timePickerTheme &&
        other.toggleButtonsTheme == toggleButtonsTheme &&
        other.tooltipTheme == tooltipTheme &&
        // DEPRECATED (newest deprecations at the bottom)
        other.buttonBarTheme == buttonBarTheme &&
        other.dialogBackgroundColor == dialogBackgroundColor;
  }

  @override
  int get hashCode {
    final List<Object?> values = <Object?>[
      // For the sanity of the reader, make sure these properties are in the same
      // order in every place that they are separated by section comments (e.g.
      // GENERAL CONFIGURATION). Each section except for deprecations should be
      // alphabetical by symbol name.

      // GENERAL CONFIGURATION
      ...adaptationMap.keys,
      ...adaptationMap.values,
      applyElevationOverlayColor,
      cupertinoOverrideTheme,
      ...extensions.keys,
      ...extensions.values,
      inputDecorationTheme,
      materialTapTargetSize,
      pageTransitionsTheme,
      platform,
      scrollbarTheme,
      splashFactory,
      useMaterial3,
      visualDensity,
      // COLOR
      canvasColor,
      cardColor,
      colorScheme,
      disabledColor,
      dividerColor,
      focusColor,
      highlightColor,
      hintColor,
      hoverColor,
      indicatorColor,
      primaryColor,
      primaryColorDark,
      primaryColorLight,
      scaffoldBackgroundColor,
      secondaryHeaderColor,
      shadowColor,
      splashColor,
      unselectedWidgetColor,
      // TYPOGRAPHY & ICONOGRAPHY
      iconTheme,
      primaryIconTheme,
      primaryTextTheme,
      textTheme,
      typography,
      // COMPONENT THEMES
      actionIconTheme,
      appBarTheme,
      badgeTheme,
      bannerTheme,
      bottomAppBarTheme,
      bottomNavigationBarTheme,
      bottomSheetTheme,
      buttonTheme,
      cardTheme,
      checkboxTheme,
      chipTheme,
      dataTableTheme,
      datePickerTheme,
      dialogTheme,
      dividerTheme,
      drawerTheme,
      dropdownMenuTheme,
      elevatedButtonTheme,
      expansionTileTheme,
      filledButtonTheme,
      floatingActionButtonTheme,
      iconButtonTheme,
      listTileTheme,
      menuBarTheme,
      menuButtonTheme,
      menuTheme,
      navigationBarTheme,
      navigationDrawerTheme,
      navigationRailTheme,
      outlinedButtonTheme,
      popupMenuTheme,
      progressIndicatorTheme,
      radioTheme,
      searchBarTheme,
      searchViewTheme,
      segmentedButtonTheme,
      sliderTheme,
      snackBarTheme,
      switchTheme,
      tabBarTheme,
      textButtonTheme,
      textSelectionTheme,
      timePickerTheme,
      toggleButtonsTheme,
      tooltipTheme,
      // DEPRECATED (newest deprecations at the bottom)
      buttonBarTheme,
      dialogBackgroundColor,
    ];
    return Object.hashAll(values);
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    final ThemeData defaultData = ThemeData.fallback();
    // For the sanity of the reader, make sure these properties are in the same
    // order in every place that they are separated by section comments (e.g.
    // GENERAL CONFIGURATION). Each section except for deprecations should be
    // alphabetical by symbol name.

    // GENERAL CONFIGURATION
    properties.add(
      IterableProperty<Adaptation<dynamic>>(
        'adaptations',
        adaptationMap.values,
        defaultValue: defaultData.adaptationMap.values,
        level: DiagnosticLevel.debug,
      ),
    );
    properties.add(
      DiagnosticsProperty<bool>(
        'applyElevationOverlayColor',
        applyElevationOverlayColor,
        level: DiagnosticLevel.debug,
      ),
    );
    properties.add(
      DiagnosticsProperty<NoDefaultCupertinoThemeData>(
        'cupertinoOverrideTheme',
        cupertinoOverrideTheme,
        defaultValue: defaultData.cupertinoOverrideTheme,
        level: DiagnosticLevel.debug,
      ),
    );
    properties.add(
      IterableProperty<ThemeExtension<dynamic>>(
        'extensions',
        extensions.values,
        defaultValue: defaultData.extensions.values,
        level: DiagnosticLevel.debug,
      ),
    );
    properties.add(
      DiagnosticsProperty<InputDecorationTheme>(
        'inputDecorationTheme',
        inputDecorationTheme,
        level: DiagnosticLevel.debug,
      ),
    );
    properties.add(
      DiagnosticsProperty<MaterialTapTargetSize>(
        'materialTapTargetSize',
        materialTapTargetSize,
        level: DiagnosticLevel.debug,
      ),
    );
    properties.add(
      DiagnosticsProperty<PageTransitionsTheme>(
        'pageTransitionsTheme',
        pageTransitionsTheme,
        level: DiagnosticLevel.debug,
      ),
    );
    properties.add(
      EnumProperty<TargetPlatform>(
        'platform',
        platform,
        defaultValue: defaultTargetPlatform,
        level: DiagnosticLevel.debug,
      ),
    );
    properties.add(
      DiagnosticsProperty<ScrollbarThemeData>(
        'scrollbarTheme',
        scrollbarTheme,
        defaultValue: defaultData.scrollbarTheme,
        level: DiagnosticLevel.debug,
      ),
    );
    properties.add(
      DiagnosticsProperty<InteractiveInkFeatureFactory>(
        'splashFactory',
        splashFactory,
        defaultValue: defaultData.splashFactory,
        level: DiagnosticLevel.debug,
      ),
    );
    properties.add(
      DiagnosticsProperty<bool>(
        'useMaterial3',
        useMaterial3,
        defaultValue: defaultData.useMaterial3,
        level: DiagnosticLevel.debug,
      ),
    );
    properties.add(
      DiagnosticsProperty<VisualDensity>(
        'visualDensity',
        visualDensity,
        defaultValue: defaultData.visualDensity,
        level: DiagnosticLevel.debug,
      ),
    );
    // COLORS
    properties.add(
      ColorProperty(
        'canvasColor',
        canvasColor,
        defaultValue: defaultData.canvasColor,
        level: DiagnosticLevel.debug,
      ),
    );
    properties.add(
      ColorProperty(
        'cardColor',
        cardColor,
        defaultValue: defaultData.cardColor,
        level: DiagnosticLevel.debug,
      ),
    );
    properties.add(
      DiagnosticsProperty<ColorScheme>(
        'colorScheme',
        colorScheme,
        defaultValue: defaultData.colorScheme,
        level: DiagnosticLevel.debug,
      ),
    );
    properties.add(
      ColorProperty(
        'disabledColor',
        disabledColor,
        defaultValue: defaultData.disabledColor,
        level: DiagnosticLevel.debug,
      ),
    );
    properties.add(
      ColorProperty(
        'dividerColor',
        dividerColor,
        defaultValue: defaultData.dividerColor,
        level: DiagnosticLevel.debug,
      ),
    );
    properties.add(
      ColorProperty(
        'focusColor',
        focusColor,
        defaultValue: defaultData.focusColor,
        level: DiagnosticLevel.debug,
      ),
    );
    properties.add(
      ColorProperty(
        'highlightColor',
        highlightColor,
        defaultValue: defaultData.highlightColor,
        level: DiagnosticLevel.debug,
      ),
    );
    properties.add(
      ColorProperty(
        'hintColor',
        hintColor,
        defaultValue: defaultData.hintColor,
        level: DiagnosticLevel.debug,
      ),
    );
    properties.add(
      ColorProperty(
        'hoverColor',
        hoverColor,
        defaultValue: defaultData.hoverColor,
        level: DiagnosticLevel.debug,
      ),
    );
    properties.add(
      ColorProperty(
        'indicatorColor',
        indicatorColor,
        defaultValue: defaultData.indicatorColor,
        level: DiagnosticLevel.debug,
      ),
    );
    properties.add(
      ColorProperty(
        'primaryColorDark',
        primaryColorDark,
        defaultValue: defaultData.primaryColorDark,
        level: DiagnosticLevel.debug,
      ),
    );
    properties.add(
      ColorProperty(
        'primaryColorLight',
        primaryColorLight,
        defaultValue: defaultData.primaryColorLight,
        level: DiagnosticLevel.debug,
      ),
    );
    properties.add(
      ColorProperty(
        'primaryColor',
        primaryColor,
        defaultValue: defaultData.primaryColor,
        level: DiagnosticLevel.debug,
      ),
    );
    properties.add(
      ColorProperty(
        'scaffoldBackgroundColor',
        scaffoldBackgroundColor,
        defaultValue: defaultData.scaffoldBackgroundColor,
        level: DiagnosticLevel.debug,
      ),
    );
    properties.add(
      ColorProperty(
        'secondaryHeaderColor',
        secondaryHeaderColor,
        defaultValue: defaultData.secondaryHeaderColor,
        level: DiagnosticLevel.debug,
      ),
    );
    properties.add(
      ColorProperty(
        'shadowColor',
        shadowColor,
        defaultValue: defaultData.shadowColor,
        level: DiagnosticLevel.debug,
      ),
    );
    properties.add(
      ColorProperty(
        'splashColor',
        splashColor,
        defaultValue: defaultData.splashColor,
        level: DiagnosticLevel.debug,
      ),
    );
    properties.add(
      ColorProperty(
        'unselectedWidgetColor',
        unselectedWidgetColor,
        defaultValue: defaultData.unselectedWidgetColor,
        level: DiagnosticLevel.debug,
      ),
    );
    // TYPOGRAPHY & ICONOGRAPHY
    properties.add(
      DiagnosticsProperty<IconThemeData>('iconTheme', iconTheme, level: DiagnosticLevel.debug),
    );
    properties.add(
      DiagnosticsProperty<IconThemeData>(
        'primaryIconTheme',
        primaryIconTheme,
        level: DiagnosticLevel.debug,
      ),
    );
    properties.add(
      DiagnosticsProperty<TextTheme>(
        'primaryTextTheme',
        primaryTextTheme,
        level: DiagnosticLevel.debug,
      ),
    );
    properties.add(
      DiagnosticsProperty<TextTheme>('textTheme', textTheme, level: DiagnosticLevel.debug),
    );
    properties.add(
      DiagnosticsProperty<Typography>(
        'typography',
        typography,
        defaultValue: defaultData.typography,
        level: DiagnosticLevel.debug,
      ),
    );
    // COMPONENT THEMES
    properties.add(
      DiagnosticsProperty<ActionIconThemeData>(
        'actionIconTheme',
        actionIconTheme,
        level: DiagnosticLevel.debug,
      ),
    );
    properties.add(
      DiagnosticsProperty<AppBarTheme>(
        'appBarTheme',
        appBarTheme,
        defaultValue: defaultData.appBarTheme,
        level: DiagnosticLevel.debug,
      ),
    );
    properties.add(
      DiagnosticsProperty<BadgeThemeData>(
        'badgeTheme',
        badgeTheme,
        defaultValue: defaultData.badgeTheme,
        level: DiagnosticLevel.debug,
      ),
    );
    properties.add(
      DiagnosticsProperty<MaterialBannerThemeData>(
        'bannerTheme',
        bannerTheme,
        defaultValue: defaultData.bannerTheme,
        level: DiagnosticLevel.debug,
      ),
    );
    properties.add(
      DiagnosticsProperty<BottomAppBarTheme>(
        'bottomAppBarTheme',
        bottomAppBarTheme,
        defaultValue: defaultData.bottomAppBarTheme,
        level: DiagnosticLevel.debug,
      ),
    );
    properties.add(
      DiagnosticsProperty<BottomNavigationBarThemeData>(
        'bottomNavigationBarTheme',
        bottomNavigationBarTheme,
        defaultValue: defaultData.bottomNavigationBarTheme,
        level: DiagnosticLevel.debug,
      ),
    );
    properties.add(
      DiagnosticsProperty<BottomSheetThemeData>(
        'bottomSheetTheme',
        bottomSheetTheme,
        defaultValue: defaultData.bottomSheetTheme,
        level: DiagnosticLevel.debug,
      ),
    );
    properties.add(
      DiagnosticsProperty<ButtonThemeData>(
        'buttonTheme',
        buttonTheme,
        level: DiagnosticLevel.debug,
      ),
    );
    properties.add(
      DiagnosticsProperty<CardThemeData>('cardTheme', cardTheme, level: DiagnosticLevel.debug),
    );
    properties.add(
      DiagnosticsProperty<CheckboxThemeData>(
        'checkboxTheme',
        checkboxTheme,
        defaultValue: defaultData.checkboxTheme,
        level: DiagnosticLevel.debug,
      ),
    );
    properties.add(
      DiagnosticsProperty<ChipThemeData>('chipTheme', chipTheme, level: DiagnosticLevel.debug),
    );
    properties.add(
      DiagnosticsProperty<DataTableThemeData>(
        'dataTableTheme',
        dataTableTheme,
        defaultValue: defaultData.dataTableTheme,
        level: DiagnosticLevel.debug,
      ),
    );
    properties.add(
      DiagnosticsProperty<DatePickerThemeData>(
        'datePickerTheme',
        datePickerTheme,
        defaultValue: defaultData.datePickerTheme,
        level: DiagnosticLevel.debug,
      ),
    );
    properties.add(
      DiagnosticsProperty<DialogThemeData>(
        'dialogTheme',
        dialogTheme,
        defaultValue: defaultData.dialogTheme,
        level: DiagnosticLevel.debug,
      ),
    );
    properties.add(
      DiagnosticsProperty<DividerThemeData>(
        'dividerTheme',
        dividerTheme,
        defaultValue: defaultData.dividerTheme,
        level: DiagnosticLevel.debug,
      ),
    );
    properties.add(
      DiagnosticsProperty<DrawerThemeData>(
        'drawerTheme',
        drawerTheme,
        defaultValue: defaultData.drawerTheme,
        level: DiagnosticLevel.debug,
      ),
    );
    properties.add(
      DiagnosticsProperty<DropdownMenuThemeData>(
        'dropdownMenuTheme',
        dropdownMenuTheme,
        defaultValue: defaultData.dropdownMenuTheme,
        level: DiagnosticLevel.debug,
      ),
    );
    properties.add(
      DiagnosticsProperty<ElevatedButtonThemeData>(
        'elevatedButtonTheme',
        elevatedButtonTheme,
        defaultValue: defaultData.elevatedButtonTheme,
        level: DiagnosticLevel.debug,
      ),
    );
    properties.add(
      DiagnosticsProperty<ExpansionTileThemeData>(
        'expansionTileTheme',
        expansionTileTheme,
        level: DiagnosticLevel.debug,
      ),
    );
    properties.add(
      DiagnosticsProperty<FilledButtonThemeData>(
        'filledButtonTheme',
        filledButtonTheme,
        defaultValue: defaultData.filledButtonTheme,
        level: DiagnosticLevel.debug,
      ),
    );
    properties.add(
      DiagnosticsProperty<FloatingActionButtonThemeData>(
        'floatingActionButtonTheme',
        floatingActionButtonTheme,
        defaultValue: defaultData.floatingActionButtonTheme,
        level: DiagnosticLevel.debug,
      ),
    );
    properties.add(
      DiagnosticsProperty<IconButtonThemeData>(
        'iconButtonTheme',
        iconButtonTheme,
        defaultValue: defaultData.iconButtonTheme,
        level: DiagnosticLevel.debug,
      ),
    );
    properties.add(
      DiagnosticsProperty<ListTileThemeData>(
        'listTileTheme',
        listTileTheme,
        defaultValue: defaultData.listTileTheme,
        level: DiagnosticLevel.debug,
      ),
    );
    properties.add(
      DiagnosticsProperty<MenuBarThemeData>(
        'menuBarTheme',
        menuBarTheme,
        defaultValue: defaultData.menuBarTheme,
        level: DiagnosticLevel.debug,
      ),
    );
    properties.add(
      DiagnosticsProperty<MenuButtonThemeData>(
        'menuButtonTheme',
        menuButtonTheme,
        defaultValue: defaultData.menuButtonTheme,
        level: DiagnosticLevel.debug,
      ),
    );
    properties.add(
      DiagnosticsProperty<MenuThemeData>(
        'menuTheme',
        menuTheme,
        defaultValue: defaultData.menuTheme,
        level: DiagnosticLevel.debug,
      ),
    );
    properties.add(
      DiagnosticsProperty<NavigationBarThemeData>(
        'navigationBarTheme',
        navigationBarTheme,
        defaultValue: defaultData.navigationBarTheme,
        level: DiagnosticLevel.debug,
      ),
    );
    properties.add(
      DiagnosticsProperty<NavigationDrawerThemeData>(
        'navigationDrawerTheme',
        navigationDrawerTheme,
        defaultValue: defaultData.navigationDrawerTheme,
        level: DiagnosticLevel.debug,
      ),
    );
    properties.add(
      DiagnosticsProperty<NavigationRailThemeData>(
        'navigationRailTheme',
        navigationRailTheme,
        defaultValue: defaultData.navigationRailTheme,
        level: DiagnosticLevel.debug,
      ),
    );
    properties.add(
      DiagnosticsProperty<OutlinedButtonThemeData>(
        'outlinedButtonTheme',
        outlinedButtonTheme,
        defaultValue: defaultData.outlinedButtonTheme,
        level: DiagnosticLevel.debug,
      ),
    );
    properties.add(
      DiagnosticsProperty<PopupMenuThemeData>(
        'popupMenuTheme',
        popupMenuTheme,
        defaultValue: defaultData.popupMenuTheme,
        level: DiagnosticLevel.debug,
      ),
    );
    properties.add(
      DiagnosticsProperty<ProgressIndicatorThemeData>(
        'progressIndicatorTheme',
        progressIndicatorTheme,
        defaultValue: defaultData.progressIndicatorTheme,
        level: DiagnosticLevel.debug,
      ),
    );
    properties.add(
      DiagnosticsProperty<RadioThemeData>(
        'radioTheme',
        radioTheme,
        defaultValue: defaultData.radioTheme,
        level: DiagnosticLevel.debug,
      ),
    );
    properties.add(
      DiagnosticsProperty<SearchBarThemeData>(
        'searchBarTheme',
        searchBarTheme,
        defaultValue: defaultData.searchBarTheme,
        level: DiagnosticLevel.debug,
      ),
    );
    properties.add(
      DiagnosticsProperty<SearchViewThemeData>(
        'searchViewTheme',
        searchViewTheme,
        defaultValue: defaultData.searchViewTheme,
        level: DiagnosticLevel.debug,
      ),
    );
    properties.add(
      DiagnosticsProperty<SegmentedButtonThemeData>(
        'segmentedButtonTheme',
        segmentedButtonTheme,
        defaultValue: defaultData.segmentedButtonTheme,
        level: DiagnosticLevel.debug,
      ),
    );
    properties.add(
      DiagnosticsProperty<SliderThemeData>(
        'sliderTheme',
        sliderTheme,
        level: DiagnosticLevel.debug,
      ),
    );
    properties.add(
      DiagnosticsProperty<SnackBarThemeData>(
        'snackBarTheme',
        snackBarTheme,
        defaultValue: defaultData.snackBarTheme,
        level: DiagnosticLevel.debug,
      ),
    );
    properties.add(
      DiagnosticsProperty<SwitchThemeData>(
        'switchTheme',
        switchTheme,
        defaultValue: defaultData.switchTheme,
        level: DiagnosticLevel.debug,
      ),
    );
    properties.add(
      DiagnosticsProperty<TabBarThemeData>(
        'tabBarTheme',
        tabBarTheme,
        level: DiagnosticLevel.debug,
      ),
    );
    properties.add(
      DiagnosticsProperty<TextButtonThemeData>(
        'textButtonTheme',
        textButtonTheme,
        defaultValue: defaultData.textButtonTheme,
        level: DiagnosticLevel.debug,
      ),
    );
    properties.add(
      DiagnosticsProperty<TextSelectionThemeData>(
        'textSelectionTheme',
        textSelectionTheme,
        defaultValue: defaultData.textSelectionTheme,
        level: DiagnosticLevel.debug,
      ),
    );
    properties.add(
      DiagnosticsProperty<TimePickerThemeData>(
        'timePickerTheme',
        timePickerTheme,
        defaultValue: defaultData.timePickerTheme,
        level: DiagnosticLevel.debug,
      ),
    );
    properties.add(
      DiagnosticsProperty<ToggleButtonsThemeData>(
        'toggleButtonsTheme',
        toggleButtonsTheme,
        level: DiagnosticLevel.debug,
      ),
    );
    properties.add(
      DiagnosticsProperty<TooltipThemeData>(
        'tooltipTheme',
        tooltipTheme,
        level: DiagnosticLevel.debug,
      ),
    );
    // DEPRECATED (newest deprecations at the bottom)
    properties.add(
      DiagnosticsProperty<ButtonBarThemeData>(
        'buttonBarTheme',
        buttonBarTheme,
        defaultValue: defaultData.buttonBarTheme,
        level: DiagnosticLevel.debug,
      ),
    );
    properties.add(
      ColorProperty(
        'dialogBackgroundColor',
        dialogBackgroundColor,
        defaultValue: defaultData.dialogBackgroundColor,
        level: DiagnosticLevel.debug,
      ),
    );
  }
}

/// A [CupertinoThemeData] that defers unspecified theme attributes to an
/// upstream Material [ThemeData].
///
/// This type of [CupertinoThemeData] is used by the Material [Theme] to
/// harmonize the [CupertinoTheme] with the material theme's colors and text
/// styles.
///
/// In the most basic case, [ThemeData]'s `cupertinoOverrideTheme` is null and
/// descendant Cupertino widgets' styling is derived from the Material theme.
///
/// To override individual parts of the Material-derived Cupertino styling,
/// `cupertinoOverrideTheme`'s construction parameters can be used.
///
/// To completely decouple the Cupertino styling from Material theme derivation,
/// another [CupertinoTheme] widget can be inserted as a descendant of the
/// Material [Theme]. On a [MaterialApp], this can be done using the `builder`
/// parameter on the constructor.
///
/// See also:
///
///  * [CupertinoThemeData], whose null constructor parameters default to
///    reasonable iOS styling defaults rather than harmonizing with a Material
///    theme.
///  * [Theme], widget which inserts a [CupertinoTheme] with this
///    [MaterialBasedCupertinoThemeData].
// This class subclasses CupertinoThemeData rather than composes one because it
// _is_ a CupertinoThemeData with partially altered behavior. e.g. its textTheme
// is from the superclass and based on the primaryColor but the primaryColor
// comes from the Material theme unless overridden.
class MaterialBasedCupertinoThemeData extends CupertinoThemeData {
  /// Create a [MaterialBasedCupertinoThemeData] based on a Material [ThemeData]
  /// and its `cupertinoOverrideTheme`.
  MaterialBasedCupertinoThemeData({required ThemeData materialTheme})
    : this._(
        materialTheme,
        (materialTheme.cupertinoOverrideTheme ?? const CupertinoThemeData()).noDefault(),
      );

  MaterialBasedCupertinoThemeData._(this._materialTheme, this._cupertinoOverrideTheme)
    : // Pass all values to the superclass so Material-agnostic properties
      // like barBackgroundColor can still behave like a normal
      // CupertinoThemeData.
      super.raw(
        _cupertinoOverrideTheme.brightness,
        _cupertinoOverrideTheme.primaryColor,
        _cupertinoOverrideTheme.primaryContrastingColor,
        _cupertinoOverrideTheme.textTheme,
        _cupertinoOverrideTheme.barBackgroundColor,
        _cupertinoOverrideTheme.scaffoldBackgroundColor,
        _cupertinoOverrideTheme.applyThemeToAll,
      );

  final ThemeData _materialTheme;
  final NoDefaultCupertinoThemeData _cupertinoOverrideTheme;

  @override
  Brightness get brightness => _cupertinoOverrideTheme.brightness ?? _materialTheme.brightness;

  @override
  Color get primaryColor =>
      _cupertinoOverrideTheme.primaryColor ?? _materialTheme.colorScheme.primary;

  @override
  Color get primaryContrastingColor =>
      _cupertinoOverrideTheme.primaryContrastingColor ?? _materialTheme.colorScheme.onPrimary;

  @override
  Color get scaffoldBackgroundColor =>
      _cupertinoOverrideTheme.scaffoldBackgroundColor ?? _materialTheme.scaffoldBackgroundColor;

  /// Copies the [ThemeData]'s `cupertinoOverrideTheme`.
  ///
  /// Only the specified override attributes of the [ThemeData]'s
  /// `cupertinoOverrideTheme` and the newly specified parameters are in the
  /// returned [CupertinoThemeData]. No derived attributes from iOS defaults or
  /// from cascaded Material theme attributes are copied.
  ///
  /// This [copyWith] cannot change the base Material [ThemeData]. To change the
  /// base Material [ThemeData], create a new Material [Theme] and use
  /// [ThemeData.copyWith] on the Material [ThemeData] instead.
  @override
  MaterialBasedCupertinoThemeData copyWith({
    Brightness? brightness,
    Color? primaryColor,
    Color? primaryContrastingColor,
    CupertinoTextThemeData? textTheme,
    Color? barBackgroundColor,
    Color? scaffoldBackgroundColor,
    bool? applyThemeToAll,
  }) {
    return MaterialBasedCupertinoThemeData._(
      _materialTheme,
      _cupertinoOverrideTheme.copyWith(
        brightness: brightness,
        primaryColor: primaryColor,
        primaryContrastingColor: primaryContrastingColor,
        textTheme: textTheme,
        barBackgroundColor: barBackgroundColor,
        scaffoldBackgroundColor: scaffoldBackgroundColor,
        applyThemeToAll: applyThemeToAll,
      ),
    );
  }

  @override
  CupertinoThemeData resolveFrom(BuildContext context) {
    // Only the cupertino override theme part will be resolved.
    // If the color comes from the material theme it's not resolved.
    return MaterialBasedCupertinoThemeData._(
      _materialTheme,
      _cupertinoOverrideTheme.resolveFrom(context),
    );
  }
}

/// A class for creating a Material theme with a color scheme based off of the
/// colors from a [CupertinoThemeData]. This is intended to be used only in the
/// case when a Material widget is unable to find a Material theme in the tree,
/// but is able to find a Cupertino theme. Most often this will occur when a
/// Material widget is used inside of a [CupertinoApp].
///
/// Besides the colors, this theme will use all the defaults from Material's
/// [ThemeData], so if further customization is needed, it is best to manually
/// add a Material [Theme] above the [CupertinoApp].
class CupertinoBasedMaterialThemeData {
  /// Creates a Material theme with a color scheme based off of the colors from
  /// a [CupertinoThemeData].
  CupertinoBasedMaterialThemeData({required CupertinoThemeData themeData})
    : materialTheme = ThemeData(
        colorScheme: ColorScheme.fromSeed(
          seedColor: themeData.primaryColor,
          brightness: themeData.brightness ?? Brightness.light,
          primary: themeData.primaryColor,
          onPrimary: themeData.primaryContrastingColor,
        ),
      );

  /// The Material theme data with colors based on an existing [CupertinoThemeData].
  final ThemeData materialTheme;
}

@immutable
class _IdentityThemeDataCacheKey {
  const _IdentityThemeDataCacheKey(this.baseTheme, this.localTextGeometry);

  final ThemeData baseTheme;
  final TextTheme localTextGeometry;

  // Using XOR to make the hash function as fast as possible (e.g. Jenkins is
  // noticeably slower).
  @override
  int get hashCode => identityHashCode(baseTheme) ^ identityHashCode(localTextGeometry);

  @override
  bool operator ==(Object other) {
    // We are explicitly ignoring the possibility that the types might not
    // match in the interests of speed.
    return other is _IdentityThemeDataCacheKey &&
        identical(other.baseTheme, baseTheme) &&
        identical(other.localTextGeometry, localTextGeometry);
  }
}

/// Cache of objects of limited size that uses the first in first out eviction
/// strategy (a.k.a least recently inserted).
///
/// The key that was inserted before all other keys is evicted first, i.e. the
/// one inserted least recently.
class _FifoCache<K, V> {
  _FifoCache(this._maximumSize) : assert(_maximumSize > 0);

  /// In Dart the map literal uses a linked hash-map implementation, whose keys
  /// are stored such that [Map.keys] returns them in the order they were
  /// inserted.
  final Map<K, V> _cache = <K, V>{};

  /// Maximum number of entries to store in the cache.
  ///
  /// Once this many entries have been cached, the entry inserted least recently
  /// is evicted when adding a new entry.
  final int _maximumSize;

  /// Returns the previously cached value for the given key, if available;
  /// if not, calls the given callback to obtain it first.
  V putIfAbsent(K key, V Function() loader) {
    assert(key != null);
    final V? result = _cache[key];
    if (result != null) {
      return result;
    }
    if (_cache.length == _maximumSize) {
      _cache.remove(_cache.keys.first);
    }
    return _cache[key] = loader();
  }
}

/// Defines the visual density of user interface components.
///
/// Density, in the context of a UI, is the vertical and horizontal
/// "compactness" of the components in the UI. It is unitless, since it means
/// different things to different UI components.
///
/// The default for visual densities is zero for both vertical and horizontal
/// densities, which corresponds to the default visual density of components in
/// the Material Design specification. It does not affect text sizes, icon
/// sizes, or padding values.
///
/// For example, for buttons, it affects the spacing around the child of the
/// button. For lists, it affects the distance between baselines of entries in
/// the list. For chips, it only affects the vertical size, not the horizontal
/// size.
///
/// Here are some examples of widgets that respond to density changes:
///
///  * [Checkbox]
///  * [Chip]
///  * [ElevatedButton]
///  * [IconButton]
///  * [InputDecorator] (which gives density support to [TextField], etc.)
///  * [ListTile]
///  * [MaterialButton]
///  * [OutlinedButton]
///  * [Radio]
///  * [RawMaterialButton]
///  * [TextButton]
///
/// See also:
///
///  * [ThemeData.visualDensity], where this property is used to specify the base
///    horizontal density of Material components.
///  * [Material design guidance on density](https://material.io/design/layout/applying-density.html).
@immutable
class VisualDensity with Diagnosticable {
  /// A const constructor for [VisualDensity].
  ///
  /// The [horizontal] and [vertical] arguments must be in the interval between
  /// [minimumDensity] and [maximumDensity], inclusive.
  const VisualDensity({this.horizontal = 0.0, this.vertical = 0.0})
    : assert(vertical <= maximumDensity),
      assert(vertical >= minimumDensity),
      assert(horizontal <= maximumDensity),
      assert(horizontal >= minimumDensity);

  /// The minimum allowed density.
  static const double minimumDensity = -4.0;

  /// The maximum allowed density.
  static const double maximumDensity = 4.0;

  /// The default profile for [VisualDensity] in [ThemeData].
  ///
  /// This default value represents a visual density that is less dense than
  /// either [comfortable] or [compact], and corresponds to density values of
  /// zero in both axes.
  static const VisualDensity standard = VisualDensity();

  /// The profile for a "comfortable" interpretation of [VisualDensity].
  ///
  /// Individual components will interpret the density value independently,
  /// making themselves more visually dense than [standard] and less dense than
  /// [compact] to different degrees based on the Material Design specification
  /// of the "comfortable" setting for their particular use case.
  ///
  /// It corresponds to a density value of -1 in both axes.
  static const VisualDensity comfortable = VisualDensity(horizontal: -1.0, vertical: -1.0);

  /// The profile for a "compact" interpretation of [VisualDensity].
  ///
  /// Individual components will interpret the density value independently,
  /// making themselves more visually dense than [standard] and [comfortable] to
  /// different degrees based on the Material Design specification of the
  /// "comfortable" setting for their particular use case.
  ///
  /// It corresponds to a density value of -2 in both axes.
  static const VisualDensity compact = VisualDensity(horizontal: -2.0, vertical: -2.0);

  /// Returns a [VisualDensity] that is adaptive based on the current platform
  /// on which the framework is executing, from [defaultTargetPlatform].
  ///
  /// When [defaultTargetPlatform] is a desktop platform, this returns
  /// [compact], and for other platforms, it returns a default-constructed
  /// [VisualDensity].
  ///
  /// See also:
  ///
  /// * [defaultDensityForPlatform] which returns a [VisualDensity] that is
  ///   adaptive based on the platform given to it.
  /// * [defaultTargetPlatform] which returns the platform on which the
  ///   framework is currently executing.
  static VisualDensity get adaptivePlatformDensity =>
      defaultDensityForPlatform(defaultTargetPlatform);

  /// Returns a [VisualDensity] that is adaptive based on the given [platform].
  ///
  /// For desktop platforms, this returns [compact], and for other platforms, it
  /// returns a default-constructed [VisualDensity].
  ///
  /// See also:
  ///
  /// * [adaptivePlatformDensity] which returns a [VisualDensity] that is
  ///   adaptive based on [defaultTargetPlatform].
  static VisualDensity defaultDensityForPlatform(TargetPlatform platform) {
    return switch (platform) {
      TargetPlatform.android || TargetPlatform.iOS || TargetPlatform.fuchsia => standard,
      TargetPlatform.linux || TargetPlatform.macOS || TargetPlatform.windows => compact,
    };
  }

  /// Copy the current [VisualDensity] with the given values replacing the
  /// current values.
  VisualDensity copyWith({double? horizontal, double? vertical}) {
    return VisualDensity(
      horizontal: horizontal ?? this.horizontal,
      vertical: vertical ?? this.vertical,
    );
  }

  /// The horizontal visual density of UI components.
  ///
  /// This property affects only the horizontal spacing between and within
  /// components, to allow for different UI visual densities. It does not affect
  /// text sizes, icon sizes, or padding values. The default value is 0.0,
  /// corresponding to the metrics specified in the Material Design
  /// specification. The value can range from [minimumDensity] to
  /// [maximumDensity], inclusive.
  ///
  /// See also:
  ///
  ///  * [ThemeData.visualDensity], where this property is used to specify the base
  ///    horizontal density of Material components.
  ///  * [Material design guidance on density](https://material.io/design/layout/applying-density.html).
  final double horizontal;

  /// The vertical visual density of UI components.
  ///
  /// This property affects only the vertical spacing between and within
  /// components, to allow for different UI visual densities. It does not affect
  /// text sizes, icon sizes, or padding values. The default value is 0.0,
  /// corresponding to the metrics specified in the Material Design
  /// specification. The value can range from [minimumDensity] to
  /// [maximumDensity], inclusive.
  ///
  /// See also:
  ///
  ///  * [ThemeData.visualDensity], where this property is used to specify the base
  ///    vertical density of Material components.
  ///  * [Material design guidance on density](https://material.io/design/layout/applying-density.html).
  final double vertical;

  /// The base adjustment in logical pixels of the visual density of UI components.
  ///
  /// The input density values are multiplied by a constant to arrive at a base
  /// size adjustment that fits Material Design guidelines.
  ///
  /// Individual components may adjust this value based upon their own
  /// individual interpretation of density.
  Offset get baseSizeAdjustment {
    // The number of logical pixels represented by an increase or decrease in
    // density by one. The Material Design guidelines say to increment/decrement
    // sizes in terms of four pixel increments.
    const double interval = 4.0;

    return Offset(horizontal, vertical) * interval;
  }

  /// Linearly interpolate between two densities.
  static VisualDensity lerp(VisualDensity a, VisualDensity b, double t) {
    if (identical(a, b)) {
      return a;
    }
    return VisualDensity(
      horizontal: lerpDouble(a.horizontal, b.horizontal, t)!,
      vertical: lerpDouble(a.vertical, b.vertical, t)!,
    );
  }

  /// Return a copy of [constraints] whose minimum width and height have been
  /// updated with the [baseSizeAdjustment].
  ///
  /// The resulting minWidth and minHeight values are clamped to not exceed the
  /// maxWidth and maxHeight values, respectively.
  BoxConstraints effectiveConstraints(BoxConstraints constraints) {
    assert(constraints.debugAssertIsValid());
    return constraints.copyWith(
      minWidth: clampDouble(
        constraints.minWidth + baseSizeAdjustment.dx,
        0.0,
        constraints.maxWidth,
      ),
      minHeight: clampDouble(
        constraints.minHeight + baseSizeAdjustment.dy,
        0.0,
        constraints.maxHeight,
      ),
    );
  }

  @override
  bool operator ==(Object other) {
    if (other.runtimeType != runtimeType) {
      return false;
    }
    return other is VisualDensity && other.horizontal == horizontal && other.vertical == vertical;
  }

  @override
  int get hashCode => Object.hash(horizontal, vertical);

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties.add(DoubleProperty('horizontal', horizontal, defaultValue: 0.0));
    properties.add(DoubleProperty('vertical', vertical, defaultValue: 0.0));
  }

  @override
  String toStringShort() {
    return '${super.toStringShort()}(h: ${debugFormatDouble(horizontal)}, v: ${debugFormatDouble(vertical)})';
  }
}

// BEGIN GENERATED TOKEN PROPERTIES - ColorScheme

// Do not edit by hand. The code between the "BEGIN GENERATED" and
// "END GENERATED" comments are generated from data in the Material
// Design token database by the script:
//   dev/tools/gen_defaults/bin/gen_defaults.dart.

// dart format off
const ColorScheme _colorSchemeLightM3 = ColorScheme(
  brightness: Brightness.light,
  primary: Color(0xFF6750A4),
  onPrimary: Color(0xFFFFFFFF),
  primaryContainer: Color(0xFFEADDFF),
  onPrimaryContainer: Color(0xFF4F378B),
  primaryFixed: Color(0xFFEADDFF),
  primaryFixedDim: Color(0xFFD0BCFF),
  onPrimaryFixed: Color(0xFF21005D),
  onPrimaryFixedVariant: Color(0xFF4F378B),
  secondary: Color(0xFF625B71),
  onSecondary: Color(0xFFFFFFFF),
  secondaryContainer: Color(0xFFE8DEF8),
  onSecondaryContainer: Color(0xFF4A4458),
  secondaryFixed: Color(0xFFE8DEF8),
  secondaryFixedDim: Color(0xFFCCC2DC),
  onSecondaryFixed: Color(0xFF1D192B),
  onSecondaryFixedVariant: Color(0xFF4A4458),
  tertiary: Color(0xFF7D5260),
  onTertiary: Color(0xFFFFFFFF),
  tertiaryContainer: Color(0xFFFFD8E4),
  onTertiaryContainer: Color(0xFF633B48),
  tertiaryFixed: Color(0xFFFFD8E4),
  tertiaryFixedDim: Color(0xFFEFB8C8),
  onTertiaryFixed: Color(0xFF31111D),
  onTertiaryFixedVariant: Color(0xFF633B48),
  error: Color(0xFFB3261E),
  onError: Color(0xFFFFFFFF),
  errorContainer: Color(0xFFF9DEDC),
  onErrorContainer: Color(0xFF8C1D18),
  background: Color(0xFFFEF7FF),
  onBackground: Color(0xFF1D1B20),
  surface: Color(0xFFFEF7FF),
  surfaceBright: Color(0xFFFEF7FF),
  surfaceContainerLowest: Color(0xFFFFFFFF),
  surfaceContainerLow: Color(0xFFF7F2FA),
  surfaceContainer: Color(0xFFF3EDF7),
  surfaceContainerHigh: Color(0xFFECE6F0),
  surfaceContainerHighest: Color(0xFFE6E0E9),
  surfaceDim: Color(0xFFDED8E1),
  onSurface: Color(0xFF1D1B20),
  surfaceVariant: Color(0xFFE7E0EC),
  onSurfaceVariant: Color(0xFF49454F),
  outline: Color(0xFF79747E),
  outlineVariant: Color(0xFFCAC4D0),
  shadow: Color(0xFF000000),
  scrim: Color(0xFF000000),
  inverseSurface: Color(0xFF322F35),
  onInverseSurface: Color(0xFFF5EFF7),
  inversePrimary: Color(0xFFD0BCFF),
  // The surfaceTint color is set to the same color as the primary.
  surfaceTint: Color(0xFF6750A4),
);

const ColorScheme _colorSchemeDarkM3 = ColorScheme(
  brightness: Brightness.dark,
  primary: Color(0xFFD0BCFF),
  onPrimary: Color(0xFF381E72),
  primaryContainer: Color(0xFF4F378B),
  onPrimaryContainer: Color(0xFFEADDFF),
  primaryFixed: Color(0xFFEADDFF),
  primaryFixedDim: Color(0xFFD0BCFF),
  onPrimaryFixed: Color(0xFF21005D),
  onPrimaryFixedVariant: Color(0xFF4F378B),
  secondary: Color(0xFFCCC2DC),
  onSecondary: Color(0xFF332D41),
  secondaryContainer: Color(0xFF4A4458),
  onSecondaryContainer: Color(0xFFE8DEF8),
  secondaryFixed: Color(0xFFE8DEF8),
  secondaryFixedDim: Color(0xFFCCC2DC),
  onSecondaryFixed: Color(0xFF1D192B),
  onSecondaryFixedVariant: Color(0xFF4A4458),
  tertiary: Color(0xFFEFB8C8),
  onTertiary: Color(0xFF492532),
  tertiaryContainer: Color(0xFF633B48),
  onTertiaryContainer: Color(0xFFFFD8E4),
  tertiaryFixed: Color(0xFFFFD8E4),
  tertiaryFixedDim: Color(0xFFEFB8C8),
  onTertiaryFixed: Color(0xFF31111D),
  onTertiaryFixedVariant: Color(0xFF633B48),
  error: Color(0xFFF2B8B5),
  onError: Color(0xFF601410),
  errorContainer: Color(0xFF8C1D18),
  onErrorContainer: Color(0xFFF9DEDC),
  background: Color(0xFF141218),
  onBackground: Color(0xFFE6E0E9),
  surface: Color(0xFF141218),
  surfaceBright: Color(0xFF3B383E),
  surfaceContainerLowest: Color(0xFF0F0D13),
  surfaceContainerLow: Color(0xFF1D1B20),
  surfaceContainer: Color(0xFF211F26),
  surfaceContainerHigh: Color(0xFF2B2930),
  surfaceContainerHighest: Color(0xFF36343B),
  surfaceDim: Color(0xFF141218),
  onSurface: Color(0xFFE6E0E9),
  surfaceVariant: Color(0xFF49454F),
  onSurfaceVariant: Color(0xFFCAC4D0),
  outline: Color(0xFF938F99),
  outlineVariant: Color(0xFF49454F),
  shadow: Color(0xFF000000),
  scrim: Color(0xFF000000),
  inverseSurface: Color(0xFFE6E0E9),
  onInverseSurface: Color(0xFF322F35),
  inversePrimary: Color(0xFF6750A4),
  // The surfaceTint color is set to the same color as the primary.
  surfaceTint: Color(0xFFD0BCFF),
);
// dart format on

// END GENERATED TOKEN PROPERTIES - ColorScheme


Instructions for the chapter (Generate content in English unless specified otherwise):
- Start with a clear heading (e.g., `# Chapter 6: MaterialTapTargetSize
`). Use the provided concept name.

- If this is not the first chapter, begin with a brief transition from the previous chapter, referencing it with a proper Markdown link using its name.

- Begin with a high-level motivation explaining what problem this abstraction solves. Start with a central use case as a concrete example. The whole chapter should guide the reader to understand how to solve this use case. Make it very minimal and friendly to beginners.

- If the abstraction is complex, break it down into key concepts. Explain each concept one-by-one in a very beginner-friendly way.

- Explain how to use this abstraction to solve the use case. Give example inputs and outputs for code snippets (if the output isn't values, describe at a high level what will happen).

- Each code block should be BELOW 10 lines! If longer code blocks are needed, break them down into smaller pieces and walk through them one-by-one. Aggresively simplify the code to make it minimal. Use comments to skip non-important implementation details. Each code block should have a beginner friendly explanation right after it.

- Describe the internal implementation to help understand what's under the hood. First provide a non-code or code-light walkthrough on what happens step-by-step when the abstraction is called. It's recommended to use a simple sequenceDiagram with a dummy example - keep it minimal with at most 5 participants to ensure clarity. If participant name has space, use: `participant QP as Query Processing`. .

- Then dive deeper into code for the internal implementation with references to files. Provide example code blocks, but make them similarly simple and beginner-friendly. Explain.

- IMPORTANT: When you need to refer to other core abstractions covered in other chapters, ALWAYS use proper Markdown links like this: [Chapter Title](filename.md). Use the Complete Tutorial Structure above to find the correct filename and the chapter title. Translate the surrounding text.

- Use mermaid diagrams to illustrate complex concepts (```mermaid``` format). .

- Heavily use analogies and examples throughout to help beginners understand.

- End the chapter with a brief conclusion that summarizes what was learned and provides a transition to the next chapter. If there is a next chapter, use a proper Markdown link: [Next Chapter Title](next_chapter_filename).

- Ensure the tone is welcoming and easy for a newcomer to understand.

- Output *only* the Markdown content for this chapter.

Now, directly provide a super beginner-friendly Markdown output (DON'T need ```markdown``` tags):

2025-05-28 18:23:01,213 - INFO - RESPONSE: # Chapter 6: MaterialTapTargetSize

Welcome back! Over the last few chapters, we've explored how to style our Flutter app with [Theme](01_theme_.md) and [ThemeData](02_themedata_.md), managed colors using [ColorScheme](03_colorscheme_.md), added our own custom styles with [ThemeExtension](04_themeextension_.md), and subtly adjusted spacing with [VisualDensity](05_visualdensity_.md).

Now let's look at another setting in `ThemeData` that focuses on making interactive elements easier to touch or click: `MaterialTapTargetSize`.

### What Problem Does `MaterialTapTargetSize` Solve?

Imagine you have a small checkbox on the screen. The visual box of the checkbox might be quite small. If a user, especially someone with a motor impairment or using a touch device, tries to tap that tiny visual area, it can be difficult! They might miss the checkbox and nothing happens, which is frustrating.

Material Design guidelines recommend that interactive elements should have a tap target size of at least 48x48 logical pixels, even if the visual part of the element is smaller. This larger invisible area makes it much easier and more reliable for users to interact with your app.

`MaterialTapTargetSize` is a setting within your [ThemeData](02_themedata_.md) that tells Flutter to automatically ensure that certain interactive widgets have this minimum tap target size, even if their visible display is smaller. It's like putting a larger, invisible button pad around a small light switch to make sure you can easily hit it with your hand, without changing the size of the light switch itself.

### What is `MaterialTapTargetSize`?

`MaterialTapTargetSize` is a simple **enum** (a fixed set of named values) available as a property in [ThemeData](02_themedata_.md). It has just two settings:

*   `MaterialTapTargetSize.padded`: This is the **default** setting for mobile platforms. It tells compatible widgets to increase their tap target size to at least 48x48 logical pixels. This is the recommended setting for accessibility.
*   `MaterialTapTargetSize.shrinkWrap`: This setting tells compatible widgets to make their tap target size just big enough to contain their visual display, with no extra padding for easier tapping. This is the default for desktop platforms where precise mouse interaction is more common.

Like [VisualDensity](05_visualdensity_.md), `MaterialTapTargetSize` is **not** a widget. You set it once in your [ThemeData](02_themedata_.md), and then compatible widgets throughout your app will use that setting to determine their tap target size.

### How to Use `MaterialTapTargetSize`

You set the `materialTapTargetSize` property in your app's [ThemeData](02_themedata_.md).

Here's how you'd use it:

```dart
import 'package:flutter/material.dart';

void main() {
  runApp(const MyApp());
}

class MyApp extends StatelessWidget {
  const MyApp({super.key});

  @override
  Widget build(BuildContext context) {
    return MaterialApp(
      title: 'Tap Target Size Demo',
      theme: ThemeData(
        primarySwatch: Colors.blue,
        // --- SET THE TAP TARGET SIZE HERE ---
        materialTapTargetSize: MaterialTapTargetSize.padded, // Or .shrinkWrap
        useMaterial3: true,
      ),
      home: const HomeScreen(),
    );
  }
}

class HomeScreen extends StatelessWidget {
  const HomeScreen({super.key});

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        title: const Text('Tap Target Size Demo'),
      ),
      body: Center(
        child: Column(
          mainAxisAlignment: MainAxisAlignment.center,
          children: <Widget>[
            // Notice how these smaller elements are easier to tap with padded size:
            Checkbox(value: true, onChanged: (bool? newValue) {}),
            const SizedBox(height: 10),
            Radio<int>(value: 1, groupValue: 1, onChanged: (int? newValue) {}),
            const SizedBox(height: 10),
            IconButton(
              icon: const Icon(Icons.settings),
              onPressed: () {},
            ),
            const SizedBox(height: 10),
            Chip(
              label: const Text('Example Chip'),
              onPressed: () {},
            ),
          ],
        ),
      ),
    );
  }
}
```

Run this code on a mobile emulator or device and observe how easy it is to tap or check the small elements like the `Checkbox` or `Radio` button. Then, try changing `materialTapTargetSize: MaterialTapTargetSize.padded` to `materialTapTargetSize: MaterialTapTargetSize.shrinkWrap` in your `ThemeData`. Re-run the app and you'll likely find it harder to accurately tap those smaller items, especially on a touch screen. The visual appearance of the checkmark, radio button circle, or chip label doesn't change, but the invisible area around it that responds to taps does.

Using `MaterialTapTargetSize.padded` is generally important for ensuring your app is accessible and easy to use for everyone, especially on mobile devices.

### Under the Hood: How Widgets Use `MaterialTapTargetSize`

Similar to [VisualDensity](05_visualdensity_.md), widgets that are affected by `MaterialTapTargetSize` look up this setting in the theme. When they are calculating their size or how they respond to taps, they check the value of `materialTapTargetSize`.

If the setting is `padded`, the widget ensures that its minimum size is at least 48x48 logical pixels, or adds internal padding to its content to achieve this, without causing overflows. If the setting is `shrinkWrap`, the widget doesn't add this extra minimum size constraint and simply sizes itself based on its content.

Here's a simplified idea of how a `Checkbox` might use the `MaterialTapTargetSize`:

```mermaid
sequenceDiagram
    participant CheckboxW as Checkbox Widget
    participant BuildContext as BuildContext
    participant ThemeWidget as Theme Widget
    participant ThemeData as ThemeData
    participant MTS as MaterialTapTargetSize Enum

    CheckboxW->>BuildContext: "Hey, what's the theme's tap target size?"
    BuildContext->>ThemeWidget: "Nearest Theme, what's your data?"
    ThemeWidget->>ThemeData: Get ThemeData object
    ThemeData->>MTS: Get materialTapTargetSize value
    MTS-->>ThemeData: Return enum value (e.g., padded)
    ThemeData-->>CheckboxW: Return enum value
    CheckboxW->>CheckboxW: If padded, ensure minimum size is 48x48 or add padding.
    CheckboxW->>CheckboxW: Respond to taps within the calculated target area.
```

This diagram shows the `Checkbox` widget querying the theme for the `materialTapTargetSize`. Based on the returned value, it adjusts its internal behavior to ensure the tap target area is large enough when needed.

Looking at the `ThemeData` code snippet provided in the context, you can see `materialTapTargetSize` is a property stored directly in `ThemeData`:

```dart
/// Configures the hit test size of certain Material widgets.
///
/// Defaults to a [platform]-appropriate size: [MaterialTapTargetSize.padded]
/// on mobile platforms, [MaterialTapTargetSize.shrinkWrap] on desktop
/// platforms.
final MaterialTapTargetSize materialTapTargetSize;
```

And in the `ThemeData.lerp` method, you can see that `MaterialTapTargetSize` is *not* interpolated smoothly. Since it's an enum (a discrete choice), the interpolation simply picks one of the two values based on the interpolation factor `t`:

```dart
// From packages/flutter/lib/src/material/theme_data.dart
static ThemeData lerp(ThemeData a, ThemeData b, double t) {
  // ... other properties ...
  return ThemeData.raw(
    // ... other properties ...
    materialTapTargetSize: t < 0.5 ? a.materialTapTargetSize : b.materialTapTargetSize, // Picks one value
    // ... other properties ...
  );
}
```

This means that when animating between two themes with different `materialTapTargetSize` values, the change will happen instantly (or based on the `t < 0.5` threshold) rather than smoothly transitioning. This makes sense as it's a behavioral setting, not a visual property like color or size that can be partially between two states.

### Conclusion

`MaterialTapTargetSize` is a straightforward but important setting in `ThemeData` that directly impacts the accessibility and usability of interactive elements in your app. By controlling the minimum size of the tap target area, you make it easier for users to interact with widgets like buttons, checkboxes, and chips. Using `MaterialTapTargetSize.padded` (the default for mobile) is recommended for a better user experience and improved accessibility.

Now that you understand `MaterialTapTargetSize`, we'll move on to explore [DynamicSchemeVariant](07_dynamicschemevariant_.md), which ties into the more advanced color generation features introduced with Material Design 3.

[DynamicSchemeVariant](07_dynamicschemevariant_.md)
2025-05-28 18:23:01,238 - INFO - PROMPT: 
Write a very beginner-friendly tutorial chapter (in Markdown format) for the project `flutter` about the concept: "DynamicSchemeVariant
". This is Chapter 7.

Concept Details:
- Name: DynamicSchemeVariant

- Description:
This is a fancy way to describe different styles of color palettes you can generate automatically from a single "seed" color. It allows you to create variations like vibrant, muted, or even monochrome schemes based on one initial color. It's like having different pre-set filters you can apply to your main paint color to get a variety of coordinating looks.


Complete Tutorial Structure:
1. [Theme
](01_theme_.md)
2. [ThemeData
](02_themedata_.md)
3. [ColorScheme
](03_colorscheme_.md)
4. [ThemeExtension
](04_themeextension_.md)
5. [VisualDensity
](05_visualdensity_.md)
6. [MaterialTapTargetSize
](06_materialtaptargetsize_.md)
7. [DynamicSchemeVariant
](07_dynamicschemevariant_.md)

Context from previous chapters:
# Chapter 1: Theme

Welcome to the very first chapter on how to make your Flutter app look great! In this chapter, we're going to talk about a really important concept called `Theme`.

Imagine you're decorating a room. You pick a color palette, decide on the furniture style, and choose the overall "feel" you want the room to have. In Flutter, `Theme` is kind of like applying that master decoration plan (`ThemeData`) to a specific part of your app's screen.

### What Problem Does `Theme` Solve?

Think about building an app with lots of buttons, text, and other visual elements. If you had to set the color, font size, and style for *each* button and *each* piece of text individually, it would be a lot of work! And if you ever wanted to change your app's look (maybe switch from light mode to dark mode), you'd have to update *everything* manually. That sounds like a nightmare!

`Theme` solves this problem by letting you define a set of styles and colors in one place, and then easily apply those styles to different parts of your app. When you change the `Theme`, all the widgets that use that theme will automatically update their appearance. It's like changing the paint color for a whole room with just one click!

### What is `Theme`?

In Flutter, `Theme` is actually a **widget**. Widgets are the building blocks of Flutter apps. The `Theme` widget is a *special* kind of widget because it doesn't just show something on the screen; it influences how the widgets *below* it in the widget tree look.

When you place a `Theme` widget around other widgets, you're essentially telling all those widgets to follow the style rules defined in the `Theme`.

Here's a super simple peek at what using `Theme` looks like:

```dart
MaterialApp(
  home: Scaffold(
    body: Theme( // Here's the Theme widget!
      data: ThemeData( // We'll learn about this in the next chapter!
        primaryColor: Colors.blue,
        // Other style settings...
      ),
      child: Center(
        child: Text(
          'Hello, Themed Text!',
        ),
      ),
    ),
  ),
);
```

In this example, we're wrapping a `Center` widget (which contains a `Text` widget) with a `Theme` widget. We're giving the `Theme` some `data` (we'll dive deep into `ThemeData` in the next chapter!), and this `data` tells it how things like primary colors should look. Any widgets inside this `Theme` that use primary colors will now use the blue color we specified.

### How `Theme` Works (Under the Hood)

You might be wondering how a widget can "talk" to the widgets below it. Flutter uses a system called "Inherited Widgets" for this. `Theme` is an example of an inherited widget.

Think of an inherited widget like a shop sign that everyone in the building can see and use. When a widget needs some information (like what the theme color should be), it "looks up" the widget tree until it finds the nearest `Theme` widget. Then it uses the `data` from that `Theme` widget to style itself.

Here's a simplified idea of how a `Text` widget might get its color:

```mermaid
sequenceDiagram
    participant T as Text Widget
    participant B as BuildContext
    participant TH as Theme Widget
    participant TD as ThemeData

    T->>B: "Hey BuildContext, what's the current theme data?"
    B->>TH: "Nearest Theme widget, what's your data?"
    TH->>TD: "ThemeData object, what's the text color?"
    TD-->>TH: Returns text color
    TH-->>B: Returns text color
    B-->>T: Returns text color
    T->>T: Displays text with that color
```
This diagram shows a `Text` widget asking its `BuildContext` (which connects it to the widget tree) for the theme information. The `BuildContext` then finds the `Theme` widget, which provides the `ThemeData`. The `Text` widget can then use this `ThemeData` to decide how it should look.

The core of this mechanism is the `Theme.of(BuildContext context)` method. This is the standard way for any widget in Flutter to access the theme information from the nearest `Theme` ancestor in the tree. You'll see `Theme.of(context)` very often in Flutter code!

Looking at the `Theme.of` method in the `theme.dart` file, you can see how it uses `context.dependOnInheritedWidgetOfExactType<_InheritedTheme>()` to find the nearest `_InheritedTheme` (which is the internal widget Flutter uses for the `Theme`).

```dart
// From packages/flutter/lib/src/material/theme.dart
static ThemeData of(BuildContext context) {
  final _InheritedTheme? inheritedTheme =
      context.dependOnInheritedWidgetOfExactType<_InheritedTheme>();
  // ... other logic ...
  final ThemeData theme =
      inheritedTheme?.theme.data ??
      // ... fallback logic ...
      _kFallbackTheme;
  return ThemeData.localize(theme, theme.typography.geometryThemeFor(category));
}
```
Don't worry too much about all the details here; the key is that `dependOnInheritedWidgetOfExactType` is the magic that allows a widget to look up the tree and get information from a parent `Theme` widget.

### Applying `Theme` to a Part of Your App

You can use the `Theme` widget to apply different themes to different parts of your app. For example, you might have a standard theme for most of your app, but a specific section might have a slightly different look, perhaps highlighting a special feature.

```dart
// Imagine this is somewhere inside your app's build method
Column(
  children: [
    Text('Regular Text'), // This uses the main app theme
    Theme( // Applying a different theme here
      data: ThemeData(
        primaryColor: Colors.green, // A different color
      ),
      child: ElevatedButton( // This button will use the green primary color
        onPressed: () {},
        child: Text('Green Button'),
      ),
    ),
    Text('More Regular Text'), // This goes back to the main app theme
  ],
)
```

In this example, the `ElevatedButton` inside the second `Theme` widget will use the specified green color for its primary color, while the `Text` widgets will use the colors from the `ThemeData` higher up in the widget tree (likely from your `MaterialApp`).

This ability to apply themes to specific subtrees of your app gives you a lot of flexibility in designing your UI.

### Conclusion

In this chapter, we learned that `Theme` is a fundamental Flutter widget used to apply styles and visual configurations (`ThemeData`) to parts of your application. It helps you manage your app's look in a consistent and efficient way. We saw how `Theme` works using the concept of inherited widgets and how you can apply different themes to different sections of your app.

Now that you have a basic understanding of `Theme`, the next step is to explore what actually *goes inside* the `Theme` widget: the `ThemeData`.

[ThemeData](02_themedata_.md)
---
# Chapter 2: ThemeData

Welcome back! In the last chapter, we learned about the `Theme` widget, which is like a magical box that applies a design plan to parts of your Flutter app. But what exactly is that design plan? That's where `ThemeData` comes in!

### What Problem Does `ThemeData` Solve?

Imagine you're building a large app with many screens. Each screen has buttons, text, backgrounds, and more. If you had to manually pick colors and font styles for every single item on every single screen, it would be a huge mess! What if your company decided to change the main brand color? You'd have to go through your entire app, finding every place you used the old color and replacing it with the new one. This is time-consuming and prone to errors.

`ThemeData` solves this problem by being a central place where you define the overall look and feel of your app. It's like having a style guide for your entire application. Instead of styling each individual button, you define the *default* style for *all* buttons in your `ThemeData`. Then, every button in your app will automatically follow that default style. If you want to change the button style later, you just update the `ThemeData`, and all your buttons instantly change!

Think of it as choosing all the paint colors, furniture styles, and lighting fixtures for an entire house *before* you start decorating any specific room. `ThemeData` is that master plan.

### What is `ThemeData`?

`ThemeData` is **not** a widget. Unlike the `Theme` widget (which you place in your app's layout), `ThemeData` is simply a **Dart class** that holds a bunch of properties about your app's theme. These properties include things like:

*   **Colors:** The main colors used in your app, like the primary color, accent color, background color, etc. (We'll talk even more about colors in the next chapter on [ColorScheme](03_colorscheme_.md)!).
*   **Text Styles:** The default fonts, sizes, and weights for different types of text (headings, body text, captions).
*   **Component Themes:** Specific default styles for individual widgets like buttons (`ElevatedButtonThemeData`, `TextButtonThemeData`), App Bars (`AppBarTheme`), dialogs (`DialogThemeData`), and many more.

Here's a simple example of creating a basic `ThemeData`:

```dart
ThemeData myCustomTheme = ThemeData(
  primarySwatch: Colors.purple, // A collection of purple shades
  textTheme: TextTheme( // Defining text styles
    bodyMedium: TextStyle(fontSize: 16.0),
  ),
  elevatedButtonTheme: ElevatedButtonThemeData( // Styling the button
    style: ElevatedButton.styleFrom(
      backgroundColor: Colors.deepOrange, // Button color
      foregroundColor: Colors.white, // Text color on the button
    ),
  ),
);
```

In this code snippet, we're creating a `ThemeData` object named `myCustomTheme`. We're setting the `primarySwatch` to purple (which provides different shades of purple), defining a default style for body text, and setting a specific background and text color for `ElevatedButton`s.

### How to Use `ThemeData`

You typically use your `ThemeData` object within a `Theme` widget (like we saw in Chapter 1) or within the `theme` property of your `MaterialApp` (which is the most common way to set the theme for your entire app).

Here's how you'd apply the `myCustomTheme` from the previous example to your whole app using `MaterialApp`:

```dart
import 'package:flutter/material.dart';

void main() {
  runApp(const MyApp());
}

class MyApp extends StatelessWidget {
  const MyApp({super.key});

  @override
  Widget build(BuildContext context) {
    ThemeData myCustomTheme = ThemeData(
      primarySwatch: Colors.purple,
      textTheme: const TextTheme(
        bodyMedium: TextStyle(fontSize: 16.0),
      ),
      elevatedButtonTheme: ElevatedButtonThemeData(
        style: ElevatedButton.styleFrom(
          backgroundColor: Colors.deepOrange,
          foregroundColor: Colors.white,
        ),
      ),
    );

    return MaterialApp(
      title: 'Themed App',
      theme: myCustomTheme, // Applying our custom theme!
      home: Scaffold(
        appBar: AppBar(
          title: const Text('Home Screen'),
        ),
        body: Center(
          child: Column(
            mainAxisAlignment: MainAxisAlignment.center,
            children: [
              Text(
                'This text uses the default bodyMedium style.',
              ),
              const SizedBox(height: 20),
              ElevatedButton(
                onPressed: () {
                  // Do something
                },
                child: const Text('Styled Button'),
              ),
            ],
          ),
        ),
      ),
    );
  }
}
```

In this example, because we set `myCustomTheme` in the `theme` property of `MaterialApp`, the `AppBar` will likely pick colors based on the `primarySwatch` (purple), the first `Text` widget will use the `bodyMedium` style (16.0 font size), and the `ElevatedButton` will have a deep orange background and white text. All these styles are defined just once in our `ThemeData`!

### Default `ThemeData`

Flutter provides default light and dark themes out of the box. You can easily use these by setting the `theme` property of your `MaterialApp` to `ThemeData.light()` or `ThemeData.dark()`.

```dart
MaterialApp(
  title: 'Default Light Theme App',
  theme: ThemeData.light(), // Using the default light theme
  home: Scaffold(
    appBar: AppBar(title: Text('Light Theme')),
    body: Center(child: Text('Default colors and fonts')),
  ),
);
```

You can also start with a default theme and then modify specific parts using `copyWith`:

```dart
ThemeData lightThemeWithRedButtons = ThemeData.light().copyWith(
  elevatedButtonTheme: ElevatedButtonThemeData(
    style: ElevatedButton.styleFrom(
      backgroundColor: Colors.red, // Only change button color
      foregroundColor: Colors.white,
    ),
  ),
);

MaterialApp(
  title: 'Customized Light Theme App',
  theme: lightThemeWithRedButtons, // Using the customized light theme
  home: Scaffold(
    appBar: AppBar(title: Text('Custom Theme')),
    body: Center(
      child: ElevatedButton(
        onPressed: () {},
        child: Text('Red Button'),
      ),
    ),
  ),
);
```

This is a powerful way to quickly customize a few things while keeping the rest of the standard Material Design look.

### Under the Hood: `ThemeData.raw` and Interpolation

While you'll mostly use the main `ThemeData` constructor or `ThemeData.light()/dark()`, it's good to know that there's also a `ThemeData.raw` constructor. This constructor is used internally by Flutter, especially for smoothly transitioning between themes (like when switching from light to dark mode).

The `ThemeData.raw` constructor requires you to provide *every single* theme property. This seems like a lot, because it is! It's not meant for you to use directly very often. Its purpose is to allow for linear interpolation between two `ThemeData` objects when animating theme changes (which happens automatically with `AnimatedTheme`).

Here's a simplified idea of how animating themes might work:

```mermaid
sequenceDiagram
    participant AT as AnimatedTheme
    participant TD1 as ThemeData (Start)
    participant TD2 as ThemeData (End)
    participant TD_lerp as ThemeData (Interpolated)

    AT->>TD1: Get initial ThemeData
    AT->>TD2: Get final ThemeData
    AT->>AT: Start Animation (t from 0 to 1)
    loop For each animation step
        AT->>TD1: Get value (e.g. color)
        AT->>TD2: Get matching value (e.g. color)
        AT->>TD_lerp: Calculate interpolated value (lerpColor(color1, color2, t))
        TD_lerp-->>AT: Return interpolated value
    end
    AT->>AT: Pass interpolated ThemeData down widget tree
```

This diagram shows that when `AnimatedTheme` changes, it doesn't just swap `ThemeData` instantly. It uses the `ThemeData.lerp` method to calculate intermediate `ThemeData` objects based on how far the animation has progressed (`t`). This creates a smooth visual transition, for example, colors fading from one to another. The `ThemeData.raw` constructor is what `ThemeData.lerp` uses to construct these intermediate theme data objects.

Looking at the `ThemeData.lerp` code snippet, you can see it calls `Color.lerp`, `TextTheme.lerp`, and other `lerp` methods for individual theme properties:

```dart
// From packages/flutter/lib/src/material/theme_data.dart
static ThemeData lerp(ThemeData a, ThemeData b, double t) {
  if (identical(a, b)) {
    return a;
  }
  return ThemeData.raw(
    // ... other properties
    canvasColor: Color.lerp(a.canvasColor, b.canvasColor, t)!, // Interpolating colors
    // ... other properties
    textTheme: TextTheme.lerp(a.textTheme, b.textTheme, t), // Interpolating text styles
    // ... other properties
  );
}
```

This shows how `ThemeData.lerp` combines the individual properties from two themes based on the interpolation factor `t` (which goes from 0 to 1 during the animation) and uses `ThemeData.raw` to build the resulting interpolated theme.

### Conclusion

`ThemeData` is the blueprint for your app's visual design. By defining colors, text styles, and component appearances in a single place using `ThemeData`, you make your app's look consistent and easy to manage and update. You can use the default light or dark themes, create your own entirely, or modify existing ones. `ThemeData` also supports animating visual changes smoothly using interpolation, leveraging the `ThemeData.raw` constructor internally.

In the next chapter, we'll dive deeper into the concept of [ColorScheme](03_colorscheme_.md), which is a very important part of `ThemeData` and a modern way to manage your app's colors according to Material Design principles.

[ColorScheme](03_colorscheme_.md)
---
# Chapter 3: ColorScheme

Welcome back! In over the last two chapters, we explored `Theme` which is like applying a design plan, and `ThemeData`, which is the blueprint holding all the details of that plan, including colors, fonts, and component styles.

In this chapter, we're going to focus on a crucial part of `ThemeData`: the `ColorScheme`. Think of `ThemeData` as the overall architecture of your house, and `ColorScheme` as the meticulously selected paint palette for each room, ensuring all the colors work together harmoniously.

### What Problem Does `ColorScheme` Solve?

Setting colors for your app can feel like choosing paint for every single wall and ceiling in a large building. There are background colors, text colors, button colors, error colors, and so many more! If you just pick random colors for each part, your app can end up looking messy and inconsistent. Plus, choosing colors that work well for both light and dark modes, and ensuring enough contrast for accessibility, is a complex task.

`ColorScheme` solves this by defining a standard set of color "roles" based on Material Design principles. Instead of just picking a red, you pick an `error` color. Instead of picking a blue, you pick a `primary` color. This structured approach ensures that colors are used consistently throughout your app, that they look good together, and that they meet accessibility standards more easily.

It's like having a named box of crayons with roles: "main color," "accent color," "warning color," etc. When you need to color something, you pick the crayon whose role fits where the color will be used.

### What is `ColorScheme`?

Similar to `ThemeData`, `ColorScheme` is **not** a widget. It's a **Dart class** that's a collection of named `Color` properties. These properties represent different roles that colors play in a user interface according to Material Design. Some key roles include:

*   `primary`: The main color of your app, used for key elements like the AppBar and primary buttons.
*   `secondary`: A contrasting color, often used for less prominent elements like secondary buttons or filter chips.
*   `error`: The color used to indicate errors, typically red.
*   `surface`: The color used for backgrounds of components like cards and sheets.
*   `onPrimary`, `onSecondary`, `onError`, `onSurface`: These are crucial "on" colors. They are designed to have good contrast with their corresponding base color (e.g., `onPrimary` is for text or icons placed *on* a `primary` colored background).

Creating a simple `ColorScheme` might look like this:

```dart
ColorScheme myColorScheme = const ColorScheme(
  brightness: Brightness.light, // Is this a light or dark scheme?
  primary: Colors.blue,
  onPrimary: Colors.white, // White text on blue is easy to read
  secondary: Colors.green,
  onSecondary: Colors.white, // White text on green is easy to read
  error: Colors.red,
  onError: Colors.white, // White text on red is easy to read
  surface: Colors.white,
  onSurface: Colors.black, // Black text on whiteです easy to read
);
```

This example defines a basic light `ColorScheme` with blue as the primary color, green as the secondary, red for errors, and standard black and white for text and surfaces.

### How to Use `ColorScheme`

You usually don't use a `ColorScheme` object directly everywhere in your code. Instead, you include it as part of your `ThemeData`, and then components automatically pick up the colors they need from the theme.

The most common way to set your app's `ColorScheme` is within the `colorScheme` property of your `ThemeData` when creating it:

```dart
import 'package:flutter/material.dart';

void main() {
  runApp(const MyApp());
}

class MyApp extends StatelessWidget {
  const MyApp({super.key});

  @override
  Widget build(BuildContext context) {
    ColorScheme myColorScheme = const ColorScheme(
      brightness: Brightness.light,
      primary: Colors.deepPurple, // Let's use deep purple!
      onPrimary: Colors.white,
      secondary: Colors.teal, // And teal for secondary
      onSecondary: Colors.white,
      error: Colors.redAccent, // A slightly different red
      onError: Colors.black,
      surface: Colors.grey, // A light grey surface
      onSurface: Colors.black87,
    );

    return MaterialApp(
      title: 'ColorScheme App',
      theme: ThemeData(
        colorScheme: myColorScheme, // Using our custom ColorScheme!
        useMaterial3: true, // Make sure to use Material 3 for the full ColorScheme
      ),
      home: Scaffold(
        appBar: AppBar(
          title: const Text('Home Screen'),
          // AppBar often uses the primary color
          backgroundColor: Theme.of(context).colorScheme.primary,
          foregroundColor: Theme.of(context).colorScheme.onPrimary, // Use onPrimary for text/icons
        ),
        body: Center(
          child: Column(
            mainAxisAlignment: MainAxisAlignment.center,
            children: [
              Text(
                'Primary Color Example',
                style: TextStyle(color: Theme.of(context).colorScheme.primary),
              ),
              const SizedBox(height: 20),
              ElevatedButton(
                onPressed: () {
                  // Do something
                },
                // ElevatedButton often uses primary/onPrimary for its default style
                child: const Text('Primary Button'),
              ),
              const SizedBox(height: 20),
              Text(
                'Secondary Color Example',
                style: TextStyle(color: Theme.of(context).colorScheme.secondary),
              ),
              const SizedBox(height: 20),
              FloatingActionButton(
                onPressed: () {
                  // Do something else
                },
                backgroundColor: Theme.of(context).colorScheme.secondary, // FAB often uses secondary
                foregroundColor: Theme.of(context).colorScheme.onSecondary, // Use onSecondary for icon
                child: const Icon(Icons.add),
              ),
              const SizedBox(height: 20),
              Text(
                'Error Color Example',
                style: TextStyle(color: Theme.of(context).colorScheme.error),
              ),
            ],
          ),
        ),
      ),
    );
  }
}
```

In this slightly longer (but broken down) example:

1.  We create a `ColorScheme` object with specific colors for different roles.
2.  We set this `ColorScheme` to the `colorScheme` property of our `ThemeData`. We also set `useMaterial3: true` because Material 3 heavily relies on the detailed `ColorScheme` roles.
3.  Inside the `Scaffold` and its widgets, we access the `ColorScheme` using `Theme.of(context).colorScheme`.
4.  We explicitly show how some widgets (like `AppBar`, `ElevatedButton`, and `FloatingActionButton`) *often* use specific `ColorScheme` roles for their default appearance. You can manually apply these, but often the widgets themselves will pick them up automatically if not overridden.

Using `ColorScheme` this way centralizes your color definitions and makes it easy to understand how colors should be used throughout your UI.

### Generating `ColorScheme` from a Seed Color

Manually picking all those colors can still be a lot! Fortunately, Material Design 3 provides a powerful way to generate an entire `ColorScheme` from just a single "seed" color. This ensures that all the generated colors are harmonious and meet accessibility standards.

You can use the `ColorScheme.fromSeed` factory constructor:

```dart
import 'package:flutter/material.dart';

void main() {
  runApp(const MyApp());
}

class MyApp extends StatelessWidget {
  const MyApp({super.key});

  @override
  Widget build(BuildContext context) {
    return MaterialApp(
      title: 'Generated ColorScheme App',
      theme: ThemeData(
        // Generate a light ColorScheme from a blue seed color
        colorScheme: ColorScheme.fromSeed(
          seedColor: Colors.blue,
          brightness: Brightness.light,
        ),
        useMaterial3: true,
      ),
      darkTheme: ThemeData(
        // Generate a dark ColorScheme from the same blue seed color
        colorScheme: ColorScheme.fromSeed(
          seedColor: Colors.blue,
          brightness: Brightness.dark,
        ),
        useMaterial3: true,
      ),
      home: Scaffold(
        appBar: AppBar(
          title: const Text('Home Screen'),
        ),
        body: Center(
          child: Column(
            mainAxisAlignment: MainAxisAlignment.center,
            children: [
              Text(
                'Text using primary color',
                style: TextStyle(color: Theme.of(context).colorScheme.primary),
              ),
              const SizedBox(height: 20),
              ElevatedButton(
                onPressed: () {},
                child: const Text('Button'),
              ),
              const SizedBox(height: 20),
              FloatingActionButton(
                onPressed: () {},
                child: const Icon(Icons.add),
              ),
            ],
          ),
        ),
      ),
    );
  }
}
```

In this example:

1.  We use `ColorScheme.fromSeed` with `Colors.blue` to generate a complete `ColorScheme` for both the light and dark themes.
2.  Flutter's Material library handles generating all the roles (primary, secondary, surface, etc.) based on that seed color, ensuring they work well together and meet accessibility standards.
3.  We see that the `AppBar`, `ElevatedButton`, and `FloatingActionButton` automatically pick up the colors from the generated `ColorScheme` roles.

This is the recommended and easiest way to get a consistent and accessible color palette for your app using Material Design 3.

### Under the Hood: `ColorScheme` Generation and Interpolation

How does `ColorScheme.fromSeed` work its magic? Flutter uses a library called `material_color_utilities`. This library implements the Material Design 3 color system, which is based on creating "tonal palettes" from a seed color.

Here's a simplified idea of what happens when you use `ColorScheme.fromSeed`:

```mermaid
sequenceDiagram
    participant App as Your App Code
    participant CSSeed as ColorScheme.fromSeed
    participant MCU as material_color_utilities
    participant CS as ColorScheme Object

    App->>CSSeed: Call ColorScheme.fromSeed(seedColor:...)
    CSSeed->>MCU: Pass seed color and brightness
    MCU->>MCU: Generate tonal palettes based on seed color
    MCU->>MCU: Map tonal palette colors to ColorScheme roles (primary, secondary, surface, etc.)
    MCU-->>CSSeed: Return calculated colors for each role
    CSSeed->>CS: Create new ColorScheme object with calculated colors
    CSSeed-->>App: Return the new ColorScheme object

```

This diagram shows that `ColorScheme.fromSeed` delegates the heavy lifting of color generation to the `material_color_utilities` library. This library takes the seed color, analyzes its properties (like hue and chroma), and generates related colors across different tones that form a harmonious palette. It then assigns these generated colors to the various `ColorScheme` roles.

Looking at the code snippet from `colorscheme.dart`, you can see the `_buildDynamicScheme` method being called, which comes from the `material_color_utilities` library:

```dart
// From packages/flutter/lib/src/material/color_scheme.dart
  factory ColorScheme.fromSeed({
    required Color seedColor,
    Brightness brightness = Brightness.light,
    DynamicSchemeVariant dynamicSchemeVariant = DynamicSchemeVariant.tonalSpot,
    double contrastLevel = 0.0,
    // ... other parameters for overrides
  }) {
    final DynamicScheme scheme = _buildDynamicScheme(
      brightness,
      seedColor,
      dynamicSchemeVariant,
      contrastLevel,
    );

    return ColorScheme(
      primary: primary ?? Color(MaterialDynamicColors.primary.getArgb(scheme)),
      onPrimary: onPrimary ?? Color(MaterialDynamicColors.onPrimary.getArgb(scheme)),
      // ... other ColorScheme roles are set here using colors from the scheme
    );
  }

// (Later in the same file)
static DynamicScheme _buildDynamicScheme(
    Brightness brightness,
    Color seedColor,
    DynamicSchemeVariant schemeVariant,
    double contrastLevel,
  ) {
    final bool isDark = brightness == Brightness.dark;
    final Hct sourceColor = Hct.fromInt(seedColor.value);
    return switch (schemeVariant) {
      DynamicSchemeVariant.tonalSpot => SchemeTonalSpot( // One of the generation algorithms
        sourceColorHct: sourceColor,
        isDark: isDark,
        contrastLevel: contrastLevel,
      ),
      // ... other variants
    };
  }
```

This confirms that `fromSeed` uses an external library (`material_color_utilities`, imported at the top as `MaterialDynamicColors`, `DynamicScheme`, `Hct`, etc.) to build the underlying color `scheme` and then uses colors derived from that scheme to populate the `ColorScheme` properties like `primary` and `onPrimary`.

Just like `ThemeData`, `ColorScheme` also supports smooth transitions between different color schemes using the `ColorScheme.lerp` method internally, which is used when animating theme changes (for example, with `AnimatedTheme`).

```dart
// From packages/flutter/lib/src/material/color_scheme.dart
static ColorScheme lerp(ColorScheme a, ColorScheme b, double t) {
  if (identical(a, b)) {
    return a;
  }
  return ColorScheme(
    brightness: t < 0.5 ? a.brightness : b.brightness,
    primary: Color.lerp(a.primary, b.primary, t)!, // Lerping individual colors
    onPrimary: Color.lerp(a.onPrimary, b.onPrimary, t)!,
    // ... other color properties are lerped
  );
}
```

This shows that the interpolation between two `ColorScheme` objects is done by linearly interpolating each individual color property within the scheme.

### Conclusion

`ColorScheme` is a powerful way to manage your app's color palette in a structured, consistent, and accessible manner. It defines named roles for colors, making it easier to apply and update your app's look. The recommended approach in Material Design 3 is to generate your `ColorScheme` from a single seed color using `ColorScheme.fromSeed`, which leverages the `material_color_utilities` library to create a harmonious and accessible palette. `ColorScheme` is a key part of your `ThemeData` and is automatically used by many Flutter Material widgets.

Now that you understand how `ColorScheme` gives structure to your app's colors within the `ThemeData`, we'll look at how you can add your *own* custom data to the theme with [ThemeExtension](04_themeextension_.md).

[ThemeExtension](04_themeextension_.md)
---
# Chapter 4: ThemeExtension

Welcome back! In our previous chapters, we learned that the [Theme](01_theme_.md) widget applies a design plan, [ThemeData](02_themedata_.md) is that detailed plan holding all the standard styling information (like fonts and component styles), and [ColorScheme](03_colorscheme_.md) helps us manage colors for different UI roles within that plan.

But what if your app needs some custom styling information that isn't covered by the standard `ThemeData` properties or `ColorScheme` roles? Imagine you have a specific type of card in your app that always needs a unique gradient background and a particular size setting, and you want to define this rule in your theme so all these special cards use the same style consistently. The standard `ThemeData` doesn't have a specific property for "my special card's gradient."

That's where `ThemeExtension` comes in!

### What Problem Does `ThemeExtension` Solve?

The standard `ThemeData` comes with a lot of properties to cover common styling needs for Material Design. However, every app is unique, and you might have custom visual elements or specific styling rules that don't fit neatly into the predefined categories like `primaryColor`, `textTheme.bodyMedium`, or `cardTheme`.

If you couldn't add custom properties to your theme, you'd have to define these unique styles manually every time you used that special element throughout your app. This leads to code duplication, makes it difficult to maintain consistency, and makes changing that special style a tedious process (just like changing the brand color without using `ThemeData`!).

`ThemeExtension` solves this by allowing you to add **your own custom data** to the existing `ThemeData` object. It's like adding a dedicated section to your house blueprint for unique features like a custom-designed mailbox color or a specific pattern for floor tiles in one area, features that aren't in the standard building code or typical house plans.

### What is `ThemeExtension`?

`ThemeExtension` is an **abstract class** that you **subclass** (create your own version of) to define your custom theme properties. You create your own class that `extends ThemeExtension` and put whatever properties you need inside it – like `Color`s, `TextStyle`s, `double`s, or even other simple data types.

Your custom `ThemeExtension` class must implement two methods:

1.  `copyWith`: This method is used to create a copy of your extension, optionally changing some properties. This is similar to how `ThemeData` has a `copyWith` method.
2.  `lerp`: This method is crucial for smoothly animating between two different versions of your custom theme data. It stands for "linear interpolation," a common technique in animation. It takes another `ThemeExtension` of the same type and a `double t` (which goes from 0 to 1 during the animation) and calculates an intermediate state of your custom properties.

Let's create a simple custom theme extension for that "special card":

```dart
import 'package:flutter/material.dart';

// 1. Create your own class that extends ThemeExtension
class SpecialCardTheme extends ThemeExtension<SpecialCardTheme> {
  // 2. Define your custom properties
  const SpecialCardTheme({
    required this.gradientColors,
    required this.borderCurve,
  });

  final List<Color> gradientColors;
  final double borderCurve; // Just a simplified example for radius

  // 3. Implement copyWith - copy all properties
  @override
  SpecialCardTheme copyWith({
    List<Color>? gradientColors,
    double? borderCurve,
  }) {
    return SpecialCardTheme(
      gradientColors: gradientColors ?? this.gradientColors,
      borderCurve: borderCurve ?? this.borderCurve,
    );
  }

  // 4. Implement lerp - interpolate between values
  @override
  SpecialCardTheme lerp(ThemeExtension<SpecialCardTheme>? other, double t) {
    if (other is! SpecialCardTheme) {
      return this; // Return this if 'other' is not the same type or is null
    }
    return SpecialCardTheme(
      // Here we smoothly transition the gradient colors using Color.lerp
      // Interpolating a list of colors requires interpolating each color
      gradientColors: List.generate(
        gradientColors.length,
        (index) => Color.lerp(
              gradientColors[index],
              other.gradientColors[index],
              t,
            ) ?? // Provide a fallback if lerp is null (unlikely with non-null colors)
            gradientColors[index],
      ),
      // Here we smoothly transition the double value
      borderCurve: t < 0.5 ? borderCurve : other.borderCurve, // Simplified lerp for double
      // For a real double interpolation, use lerpDouble from dart:ui
      // borderCurve: lerpDouble(borderCurve, other.borderCurve, t)!,
    );
  }

  // Optional: Add operator == and hashCode for equality checks
  // This is good practice but not strictly required by ThemeExtension interface
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is SpecialCardTheme &&
          runtimeType == other.runtimeType &&
          listEquals(gradientColors, other.gradientColors) && // Need listEquals for list
          borderCurve == other.borderCurve;

  @override
  int get hashCode => hashValues(hashList(gradientColors), borderCurve); // Need hashList for list
}
```

This is our custom `ThemeExtension` class, `SpecialCardTheme`. It defines a list of colors for a gradient and a double for a border curvature. We've added the necessary `copyWith` and `lerp` methods.

### How to Use `ThemeExtension`

Once you've defined your custom `ThemeExtension` class, you need to add it to your `ThemeData`. You do this using the `extensions` property when creating or copying a `ThemeData`. The `extensions` property takes an `Iterable` (like a `List`) of your custom theme extension objects.

Here's how you'd add `SpecialCardTheme` to your app's `ThemeData`:

```dart
import 'package:flutter/material.dart';
// Assuming your SpecialCardTheme class is in 'special_card_theme.dart'
import 'special_card_theme.dart';

void main() {
  runApp(const MyApp());
}

class MyApp extends StatelessWidget {
  const MyApp({super.key});

  @override
  Widget build(BuildContext context) {
    // Define your custom theme extension instance
    const SpecialCardTheme specialTheme = SpecialCardTheme(
      gradientColors: [Colors.orange, Colors.red],
      borderCurve: 16.0,
    );

    return MaterialApp(
      title: 'Theme Extension App',
      theme: ThemeData(
        primarySwatch: Colors.blue,
        useMaterial3: true,
        // Add your custom extension to the extensions list
        extensions: <ThemeExtension<dynamic>>[
          specialTheme,
        ],
      ),
      home: const HomeScreen(),
    );
  }
}

class HomeScreen extends StatelessWidget {
  const HomeScreen({super.key});

  @override
  Widget build(BuildContext context) {
    // Access the custom theme extension using Theme.of(context).extension<YourClassName>()
    final specialCardTheme = Theme.of(context).extension<SpecialCardTheme>()!;

    return Scaffold(
      appBar: AppBar(
        title: const Text('Home with Custom Theme'),
      ),
      body: Center(
        child: Column(
          mainAxisAlignment: MainAxisAlignment.center,
          children: [
            Text(
              'Standard Text based on ThemeData',
              style: Theme.of(context).textTheme.bodyMedium,
            ),
            const SizedBox(height: 20),
            // Use the properties from your custom extension
            Container(
              width: 200,
              height: 100,
              decoration: BoxDecoration(
                // Accessing custom gradient colors
                gradient: LinearGradient(colors: specialCardTheme.gradientColors),
                borderRadius: BorderRadius.circular(specialCardTheme.borderCurve), // Accessing custom curve
              ),
              child: const Center(
                child: Text(
                  'This is the Special Card!',
                  style: TextStyle(color: Colors.white),
                ),
              ),
            ),
          ],
        ),
      ),
    );
  }
}
```

In this example:

1.  We create an instance of our `SpecialCardTheme` with specific values.
2.  We add this instance to the `extensions` list in our `ThemeData`.
3.  In a widget (`HomeScreen`), we access the theme using `Theme.of(context)`.
4.  We retrieve our specific custom extension using `.extension<SpecialCardTheme>()`. Note the `<SpecialCardTheme>` part – this tells Flutter *which* type of extension to look for. The `!` at the end asserts that we expect it to exist.
5.  We then use the properties (`gradientColors` and `borderCurve`) from the retrieved `specialCardTheme` object to style our `Container` (representing the special card).

Now, if you wanted to change the gradient or border curvature of *all* your "special cards," you just need to update the `SpecialCardTheme` instance provided in your `MaterialApp`'s `ThemeData`.

### Under the Hood: Adding and Retrieving Extensions

When you add your custom `ThemeExtension`s to the `extensions` list in `ThemeData`, Flutter stores them internally in a `Map`. The key of this map is the **type** of your `ThemeExtension` (like `SpecialCardTheme`), and the value is the instance of your extension.

When you call `Theme.of(context).extension<YourCustomExtension>()`, Flutter does the following:

1.  It finds the nearest `ThemeData` in the widget tree (as we saw in Chapter 1).
2.  It looks inside that `ThemeData`'s internal `extensions` map.
3.  It uses the `Type` of your custom extension (`YourCustomExtension`) as the key to find the corresponding instance in the map.
4.  It returns that instance (or `null` if no extension of that type is found).

Here's a super simplified sequence diagram showing the process of retrieving a `ThemeExtension`:

```mermaid
sequenceDiagram
    participant Widget as Your Custom Widget
    participant BuildContext as BuildContext
    participant ThemeWidget as Theme Widget
    participant ThemeData as ThemeData
    participant ExtMap as Internal Extensions Map
    participant CustomExt as Your Custom Extension Object

    Widget->>BuildContext: "Hey, I need the theme extension of type MyCustomExt!"
    BuildContext->>ThemeWidget: "Nearest Theme, what's your data?"
    ThemeWidget->>ThemeData: Get ThemeData object
    ThemeData->>ExtMap: "Is there an extension with key 'MyCustomExt'?"
    ExtMap-->>ThemeData: Yes, here's the MyCustomExt object.
    ThemeData-->>Widget: Return the MyCustomExt object.
    Widget->>Widget: Use the custom properties from the object.
```

This shows how your custom extension objects are stored within the `ThemeData` and retrieved using their type as the identifier.

Looking at the `ThemeData` code snippet provided in the context, you can see the `extensions` property is a `Map<Object, ThemeExtension<dynamic>>`:

```dart
/// Arbitrary additions to this theme.
///
/// To define extensions, pass an [Iterable] containing one or more [ThemeExtension]
/// subclasses to [ThemeData.new] or [copyWith].
///
/// To obtain an extension, use [extension].
/// ...
final Map<Object, ThemeExtension<dynamic>> extensions;

/// Used to obtain a particular [ThemeExtension] from [extensions].
///
/// Obtain with `Theme.of(context).extension<MyThemeExtension>()`.
/// ...
T? extension<T>() => extensions[T] as T?; // This is where it looks up by type T
```

The `extension<T>()` method directly accesses the `extensions` map using `T` as the key. The `<dynamic>` in the map definition just means it can hold any type of `ThemeExtension`.

The `lerp` method in `ThemeData` also handles interpolating themes that have extensions. It calls the `lerp` method **you defined** on each corresponding extension in the two themes being interpolated:

```dart
// From packages/flutter/lib/src/material/theme_data.dart
  static Map<Object, ThemeExtension<dynamic>> _lerpThemeExtensions(
    ThemeData a,
    ThemeData b,
    double t,
  ) {
    // Lerp [a].
    final Map<Object, ThemeExtension<dynamic>> newExtensions = a.extensions.map((
      Object id,
      ThemeExtension<dynamic> extensionA,
    ) {
      final ThemeExtension<dynamic>? extensionB = b.extensions[id];
      // Calls the lerp method you implemented in your custom class!
      return MapEntry<Object, ThemeExtension<dynamic>>(id, extensionA.lerp(extensionB, t));
    });
    // Add [b]-only extensions.
    newExtensions.addEntries(
      b.extensions.entries.where(
        (MapEntry<Object, ThemeExtension<dynamic>> entry) => !a.extensions.containsKey(entry.key),
      ),
    );

    return newExtensions;
  }
```

This snippet shows that `ThemeData.lerp` iterates through the extensions in the first theme (`a`), finds the matching extension in the second theme (`b`), and calls **your** `lerp` method on that pair (`extensionA.lerp(extensionB, t)`). This is why correctly implementing `lerp` in your `ThemeExtension` subclass is essential for enabling smooth theme transitions.

### Conclusion

`ThemeExtension` is a powerful mechanism that allows you to extend `ThemeData` with your own custom properties, going beyond the standard Material Design configurations. By defining your properties in a custom `ThemeExtension` subclass and adding it to your `ThemeData`, you create a central source of truth for unique styling rules in your app, promoting consistency, maintainability, and enabling smooth animations between different versions of your custom theme data.

With your understanding of `Theme`, `ThemeData`, `ColorScheme`, and now `ThemeExtension`, you're well on your way to creating beautifully consistent and well-structured Flutter UIs! Next, we'll briefly touch upon [VisualDensity](05_visualdensity_.md), which controls the compactness of interactive elements.

[VisualDensity](05_visualdensity_.md)
---
# Chapter 5: VisualDensity

Welcome back! In our previous chapters, we learned about [Theme](01_theme_.md) for applying design plans, [ThemeData](02_themedata_.md) as the detailed blueprint with standard styling, [ColorScheme](03_colorscheme_.md) for managing colors in a structured way, and [ThemeExtension](04_themeextension_.md) for adding your own custom styling data to the theme.

Now, let's talk about a concept that subtly affects the physical layout and spacing of some interactive UI elements: `VisualDensity`.

### What Problem Does `VisualDensity` Solve?

Imagine you're designing a screen with a list of items, each with a button next to it. On a large screen, you might want a bit more space between these list items and buttons so they feel less crowded. On a small phone screen, you might want them to be a little closer together to fit more information without making the text or icons smaller.

If you had to go into every list item, and every button, and manually adjust padding or margins based on the screen size or your desired "feel," that would be a lot of work!

`VisualDensity` solves this by providing a way to subtly adjust the spacing of certain interactive widgets (like buttons, checkboxes, input fields, and list tiles) without changing their core size or the size of the text and icons within them. It's like having a master setting that controls how "spacious" or "compact" interactive controls are throughout your app.

Think of it like adjusting the spacing between rows in a spreadsheet – the text in each cell stays the same size, but the row height changes to make the sheet feel more or less dense.

### What is `VisualDensity`?

`VisualDensity` is a **class** included in `ThemeData`. It holds two main properties:

*   `horizontal`: Controls the horizontal spacing.
*   `vertical`: Controls the vertical spacing.

These properties are typically `double` values that range from a minimum density (usually `-4.0` for very compact) to a maximum density (usually `4.0` for very spacious), with `0.0` being the default or "standard" density according to Material Design.

`VisualDensity` itself is **not** a widget or something you apply directly to a single button. You set it in your app's main [ThemeData](02_themedata_.md), and then compatible widgets within your app automatically adjust their spacing based on that setting.

Here are the few predefined `VisualDensity` settings you'll often use:

*   `VisualDensity.standard`: The default (`horizontal: 0.0`, `vertical: 0.0`).
*   `VisualDensity.compact`: A more compact setting (`horizontal: -2.0`, `vertical: -2.0`).
*   `VisualDensity.comfortable`: Somewhere between standard and compact (`horizontal: -1.0`, `vertical: -1.0`).
*   `VisualDensity.adaptivePlatformDensity`: Automatically chooses `compact` for desktop platforms (Linux, macOS, Windows) and `standard` for mobile platforms (Android, iOS, Fuchsia). This is often a good default to use.

### How to Use `VisualDensity`

You apply a `VisualDensity` setting by setting the `visualDensity` property in your app's `ThemeData`.

Here's a simple example demonstrating different `VisualDensity` settings:

```dart
import 'package:flutter/material.dart';

void main() {
  runApp(const MyApp());
}

class MyApp extends StatelessWidget {
  const MyApp({super.key});

  @override
  Widget build(BuildContext context) {
    return MaterialApp(
      title: 'Visual Density Demo',
      theme: ThemeData(
        primarySwatch: Colors.blue,
        // --- SET THE VISUAL DENSITY HERE ---
        visualDensity: VisualDensity.adaptivePlatformDensity,
        // visualDensity: VisualDensity.comfortable, // Try this one too!
        // visualDensity: VisualDensity.compact, // And this one!
        // visualDensity: VisualDensity.standard, // And the default
        useMaterial3: true,
      ),
      home: const HomeScreen(),
    );
  }
}

class HomeScreen extends StatelessWidget {
  const HomeScreen({super.key});

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        title: const Text('Visual Density Demo'),
      ),
      body: Center(
        child: Column(
          mainAxisAlignment: MainAxisAlignment.center,
          children: <Widget>[
            // These widgets are affected by VisualDensity:
            ElevatedButton(
              onPressed: () {},
              child: const Text('Elevated Button'),
            ),
            const SizedBox(height: 10),
            OutlinedButton(
              onPressed: () {},
              child: const Text('Outlined Button'),
            ),
            const SizedBox(height: 10),
            TextButton(
              onPressed: () {},
              child: const Text('Text Button'),
            ),
            const SizedBox(height: 10),
            Checkbox(value: true, onChanged: (bool? newValue) {}),
            const SizedBox(height: 10),
            Radio<int>(value: 1, groupValue: 1, onChanged: (int? newValue) {}),
            const SizedBox(height: 10),
            ListTile(
              leading: const Icon(Icons.star),
              title: const Text('List Tile Example'),
              onTap: () {},
            ),
            const SizedBox(height: 10),
            // NOTE: VisualDensity with TextFields primarily affects the padding
            // within the InputDecoration.
            const TextField(
              decoration: InputDecoration(
                labelText: 'Input Field',
                border: OutlineInputBorder(),
              ),
            ),
          ],
        ),
      ),
    );
  }
}

```

Run this code and try changing the `visualDensity` line in `ThemeData` to `VisualDensity.comfortable`, `VisualDensity.compact`, or `VisualDensity.standard`. You'll see how the spacing around the buttons, the list tile, and even the padding inside the text field changes subtly, making the UI feel more or less "spread out." Notice that the text and icon sizes don't change.

Using `VisualDensity.adaptivePlatformDensity` is a great way to make your app feel more natural on different devices right from the start. On a phone, interactive elements will have standard spacing (making them easier to tap with a finger), while on a desktop, they will be more compact (better mouse/keyboard interaction and fitting more on screen).

### Under the Hood: How Widgets Use `VisualDensity`

When you set `visualDensity` in `ThemeData`, it gets stored within the theme information that is available using `Theme.of(context)`. Compatible widgets, when they build themselves, look up the current theme's `visualDensity`.

These widgets then translate the `horizontal` and `vertical` density values into actual pixel adjustments. The conversion isn't a simple 1-to-1 mapping for every widget. As the documentation states, "a change of 1 or -1 in density corresponds to 4 logical pixels" as a rule of thumb, but widgets can interpret this differently based on their design.

Let's imagine how a simple button might use the `vertical` density:

```mermaid
sequenceDiagram
    participant Button as ElevatedButton
    participant BuildContext as BuildContext
    participant ThemeWidget as Theme Widget
    participant ThemeData as ThemeData
    participant VisualDensity as VisualDensity Object

    Button->>BuildContext: "Hey, I need the theme's visual density!"
    BuildContext->>ThemeWidget: "Nearest Theme, what's your data?"
    ThemeWidget->>ThemeData: Get ThemeData object
    ThemeData->>VisualDensity: Get VisualDensity object
    VisualDensity-->>ThemeData: Return VisualDensity object (e.g., v: -1.0)
    ThemeData-->>Button: Return VisualDensity object
    Button->>Button: Calculate vertical padding baseado em VisualDensity.vertical
    Button->>Button: Render button with calculated padding
```

This diagram shows the button checking the theme for the `VisualDensity` object. Once it gets it, it uses the `vertical` property (and possibly `horizontal`) to calculate how much extra space (padding) it should add or remove around its content.

Looking at the `ThemeData` code snippet you provided, you can see `visualDensity` is a property stored directly in `ThemeData`:

```dart
/// The density value for specifying the compactness of various UI components.
///
/// {@template flutter.material.themedata.visualDensity}
/// ... (documentation for VisualDensity) ...
/// {@endtemplate}
final VisualDensity visualDensity;
```

Then, in the `ThemeData.lerp` method, you can see that `VisualDensity` is interpolated when animating between themes:

```dart
// From packages/flutter/lib/src/material/theme_data.dart
static ThemeData lerp(ThemeData a, ThemeData b, double t) {
  // ... other properties ...
  return ThemeData.raw(
    // ... other properties ...
    visualDensity: VisualDensity.lerp(a.visualDensity, b.visualDensity, t),
    // ... other properties ...
  );
}
```

And if you were to look at the source code for, say, `ElevatedButton`, you would eventually find where it uses the `VisualDensity` from the theme (often through a MaterialButton parent class or a component theme) to adjust its internal layout constraints or padding. The `VisualDensity` class itself has an `baseSizeAdjustment` getter that provides a base offset in pixels based on the density values, and widgets can use this offset (or a modified version of it) when calculating their size. Here's the snippet from `VisualDensity` class provided:

```dart
/// The base adjustment in logical pixels of the visual density of UI components.
///
/// The input density values are multiplied by a constant to arrive at a base
/// size adjustment that fits Material Design guidelines.
/// ...
  Offset get baseSizeAdjustment {
    // The number of logical pixels represented by an increase or decrease in
    // density by one. The Material Design guidelines say to increment/decrement
    // sizes in terms of four pixel increments.
    const double interval = 4.0;

    return Offset(horizontal, vertical) * interval;
  }

/// Return a copy of [constraints] whose minimum width and height have been
  /// updated with the [baseSizeAdjustment].
  /// ...
  BoxConstraints effectiveConstraints(BoxConstraints constraints) {
    assert(constraints.debugAssertIsValid());
    return constraints.copyWith(
      minWidth: clampDouble(
        constraints.minWidth + baseSizeAdjustment.dx,
        0.0,
        constraints.maxWidth,
      ),
      minHeight: clampDouble(
        constraints.minHeight + baseSizeAdjustment.dy,
        0.0,
        constraints.maxHeight,
      ),
    );
  }
```
This shows how the `horizontal` and `vertical` values are converted into a pixel `Offset` and how that offset can be used to modify the minimum size constraints of a widget.

### Conclusion

`VisualDensity` is a simple but effective way to control the overall "compactness" of interactive UI elements in your Flutter app. By setting this property in your `ThemeData`, you can subtly adjust the spacing of compatible widgets globally, without changing their text or icon sizes. Using `VisualDensity.adaptivePlatformDensity` is a recommended practice for creating apps that feel at home on both mobile and desktop platforms.

Now that we've looked at `VisualDensity`, let's dive into another related concept that affects the size of interactive areas: [MaterialTapTargetSize](06_materialtaptargetsize_.md).

[MaterialTapTargetSize](06_materialtaptargetsize_.md)
---
# Chapter 6: MaterialTapTargetSize

Welcome back! Over the last few chapters, we've explored how to style our Flutter app with [Theme](01_theme_.md) and [ThemeData](02_themedata_.md), managed colors using [ColorScheme](03_colorscheme_.md), added our own custom styles with [ThemeExtension](04_themeextension_.md), and subtly adjusted spacing with [VisualDensity](05_visualdensity_.md).

Now let's look at another setting in `ThemeData` that focuses on making interactive elements easier to touch or click: `MaterialTapTargetSize`.

### What Problem Does `MaterialTapTargetSize` Solve?

Imagine you have a small checkbox on the screen. The visual box of the checkbox might be quite small. If a user, especially someone with a motor impairment or using a touch device, tries to tap that tiny visual area, it can be difficult! They might miss the checkbox and nothing happens, which is frustrating.

Material Design guidelines recommend that interactive elements should have a tap target size of at least 48x48 logical pixels, even if the visual part of the element is smaller. This larger invisible area makes it much easier and more reliable for users to interact with your app.

`MaterialTapTargetSize` is a setting within your [ThemeData](02_themedata_.md) that tells Flutter to automatically ensure that certain interactive widgets have this minimum tap target size, even if their visible display is smaller. It's like putting a larger, invisible button pad around a small light switch to make sure you can easily hit it with your hand, without changing the size of the light switch itself.

### What is `MaterialTapTargetSize`?

`MaterialTapTargetSize` is a simple **enum** (a fixed set of named values) available as a property in [ThemeData](02_themedata_.md). It has just two settings:

*   `MaterialTapTargetSize.padded`: This is the **default** setting for mobile platforms. It tells compatible widgets to increase their tap target size to at least 48x48 logical pixels. This is the recommended setting for accessibility.
*   `MaterialTapTargetSize.shrinkWrap`: This setting tells compatible widgets to make their tap target size just big enough to contain their visual display, with no extra padding for easier tapping. This is the default for desktop platforms where precise mouse interaction is more common.

Like [VisualDensity](05_visualdensity_.md), `MaterialTapTargetSize` is **not** a widget. You set it once in your [ThemeData](02_themedata_.md), and then compatible widgets throughout your app will use that setting to determine their tap target size.

### How to Use `MaterialTapTargetSize`

You set the `materialTapTargetSize` property in your app's [ThemeData](02_themedata_.md).

Here's how you'd use it:

```dart
import 'package:flutter/material.dart';

void main() {
  runApp(const MyApp());
}

class MyApp extends StatelessWidget {
  const MyApp({super.key});

  @override
  Widget build(BuildContext context) {
    return MaterialApp(
      title: 'Tap Target Size Demo',
      theme: ThemeData(
        primarySwatch: Colors.blue,
        // --- SET THE TAP TARGET SIZE HERE ---
        materialTapTargetSize: MaterialTapTargetSize.padded, // Or .shrinkWrap
        useMaterial3: true,
      ),
      home: const HomeScreen(),
    );
  }
}

class HomeScreen extends StatelessWidget {
  const HomeScreen({super.key});

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        title: const Text('Tap Target Size Demo'),
      ),
      body: Center(
        child: Column(
          mainAxisAlignment: MainAxisAlignment.center,
          children: <Widget>[
            // Notice how these smaller elements are easier to tap with padded size:
            Checkbox(value: true, onChanged: (bool? newValue) {}),
            const SizedBox(height: 10),
            Radio<int>(value: 1, groupValue: 1, onChanged: (int? newValue) {}),
            const SizedBox(height: 10),
            IconButton(
              icon: const Icon(Icons.settings),
              onPressed: () {},
            ),
            const SizedBox(height: 10),
            Chip(
              label: const Text('Example Chip'),
              onPressed: () {},
            ),
          ],
        ),
      ),
    );
  }
}
```

Run this code on a mobile emulator or device and observe how easy it is to tap or check the small elements like the `Checkbox` or `Radio` button. Then, try changing `materialTapTargetSize: MaterialTapTargetSize.padded` to `materialTapTargetSize: MaterialTapTargetSize.shrinkWrap` in your `ThemeData`. Re-run the app and you'll likely find it harder to accurately tap those smaller items, especially on a touch screen. The visual appearance of the checkmark, radio button circle, or chip label doesn't change, but the invisible area around it that responds to taps does.

Using `MaterialTapTargetSize.padded` is generally important for ensuring your app is accessible and easy to use for everyone, especially on mobile devices.

### Under the Hood: How Widgets Use `MaterialTapTargetSize`

Similar to [VisualDensity](05_visualdensity_.md), widgets that are affected by `MaterialTapTargetSize` look up this setting in the theme. When they are calculating their size or how they respond to taps, they check the value of `materialTapTargetSize`.

If the setting is `padded`, the widget ensures that its minimum size is at least 48x48 logical pixels, or adds internal padding to its content to achieve this, without causing overflows. If the setting is `shrinkWrap`, the widget doesn't add this extra minimum size constraint and simply sizes itself based on its content.

Here's a simplified idea of how a `Checkbox` might use the `MaterialTapTargetSize`:

```mermaid
sequenceDiagram
    participant CheckboxW as Checkbox Widget
    participant BuildContext as BuildContext
    participant ThemeWidget as Theme Widget
    participant ThemeData as ThemeData
    participant MTS as MaterialTapTargetSize Enum

    CheckboxW->>BuildContext: "Hey, what's the theme's tap target size?"
    BuildContext->>ThemeWidget: "Nearest Theme, what's your data?"
    ThemeWidget->>ThemeData: Get ThemeData object
    ThemeData->>MTS: Get materialTapTargetSize value
    MTS-->>ThemeData: Return enum value (e.g., padded)
    ThemeData-->>CheckboxW: Return enum value
    CheckboxW->>CheckboxW: If padded, ensure minimum size is 48x48 or add padding.
    CheckboxW->>CheckboxW: Respond to taps within the calculated target area.
```

This diagram shows the `Checkbox` widget querying the theme for the `materialTapTargetSize`. Based on the returned value, it adjusts its internal behavior to ensure the tap target area is large enough when needed.

Looking at the `ThemeData` code snippet provided in the context, you can see `materialTapTargetSize` is a property stored directly in `ThemeData`:

```dart
/// Configures the hit test size of certain Material widgets.
///
/// Defaults to a [platform]-appropriate size: [MaterialTapTargetSize.padded]
/// on mobile platforms, [MaterialTapTargetSize.shrinkWrap] on desktop
/// platforms.
final MaterialTapTargetSize materialTapTargetSize;
```

And in the `ThemeData.lerp` method, you can see that `MaterialTapTargetSize` is *not* interpolated smoothly. Since it's an enum (a discrete choice), the interpolation simply picks one of the two values based on the interpolation factor `t`:

```dart
// From packages/flutter/lib/src/material/theme_data.dart
static ThemeData lerp(ThemeData a, ThemeData b, double t) {
  // ... other properties ...
  return ThemeData.raw(
    // ... other properties ...
    materialTapTargetSize: t < 0.5 ? a.materialTapTargetSize : b.materialTapTargetSize, // Picks one value
    // ... other properties ...
  );
}
```

This means that when animating between two themes with different `materialTapTargetSize` values, the change will happen instantly (or based on the `t < 0.5` threshold) rather than smoothly transitioning. This makes sense as it's a behavioral setting, not a visual property like color or size that can be partially between two states.

### Conclusion

`MaterialTapTargetSize` is a straightforward but important setting in `ThemeData` that directly impacts the accessibility and usability of interactive elements in your app. By controlling the minimum size of the tap target area, you make it easier for users to interact with widgets like buttons, checkboxes, and chips. Using `MaterialTapTargetSize.padded` (the default for mobile) is recommended for a better user experience and improved accessibility.

Now that you understand `MaterialTapTargetSize`, we'll move on to explore [DynamicSchemeVariant](07_dynamicschemevariant_.md), which ties into the more advanced color generation features introduced with Material Design 3.

[DynamicSchemeVariant](07_dynamicschemevariant_.md)

Relevant Code Snippets (Code itself remains unchanged):
--- File: packages/flutter/lib/src/material/color_scheme.dart ---
// Copyright 2014 The Flutter Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

/// @docImport 'input_decorator.dart';
/// @docImport 'scaffold.dart';
library;

import 'dart:async';
import 'dart:ui' as ui;

import 'package:flutter/foundation.dart';
import 'package:flutter/widgets.dart';
import 'package:material_color_utilities/material_color_utilities.dart';

import 'colors.dart';
import 'theme.dart';

/// The algorithm used to construct a [ColorScheme] in [ColorScheme.fromSeed].
///
/// The `tonalSpot` variant builds default Material scheme colors. These colors are
/// mapped to light or dark tones to achieve visually accessible color
/// pairings with sufficient contrast between foreground and background elements.
///
/// In some cases, the tones can prevent colors from appearing as intended,
/// such as when a color is too light to offer enough contrast for accessibility.
/// Color fidelity (`DynamicSchemeVariant.fidelity`) is a feature that adjusts
/// tones in these cases to produce the intended visual results without harming
/// visual contrast.
enum DynamicSchemeVariant {
  /// Default for Material theme colors. Builds pastel palettes with a low chroma.
  tonalSpot,

  /// The resulting color palettes match seed color, even if the seed color
  /// is very bright (high chroma).
  fidelity,

  /// All colors are grayscale, no chroma.
  monochrome,

  /// Close to grayscale, a hint of chroma.
  neutral,

  /// Pastel colors, high chroma palettes. The primary palette's chroma is at
  /// maximum. Use `fidelity` instead if tokens should alter their tone to match
  /// the palette vibrancy.
  vibrant,

  /// Pastel colors, medium chroma palettes. The primary palette's hue is
  /// different from the seed color, for variety.
  expressive,

  /// Almost identical to `fidelity`. Tokens and palettes match the seed color.
  /// [ColorScheme.primaryContainer] is the seed color, adjusted to ensure
  /// contrast with surfaces. The tertiary palette is analogue of the seed color.
  content,

  /// A playful theme - the seed color's hue does not appear in the theme.
  rainbow,

  /// A playful theme - the seed color's hue does not appear in the theme.
  fruitSalad,
}

/// {@template flutter.material.color_scheme.ColorScheme}
/// A set of 45 colors based on the
/// [Material spec](https://m3.material.io/styles/color/the-color-system/color-roles)
/// that can be used to configure the color properties of most components.
/// {@endtemplate}
///
/// ### Colors in Material 3
///
/// {@macro flutter.material.colors.colorRoles}
///
/// The main accent color groups in the scheme are [primary], [secondary],
/// and [tertiary].
///
/// * Primary colors are used for key components across the UI, such as the FAB,
///   prominent buttons, and active states.
///
/// * Secondary colors are used for less prominent components in the UI, such as
///   filter chips, while expanding the opportunity for color expression.
///
/// * Tertiary colors are used for contrasting accents that can be used to
///   balance primary and secondary colors or bring heightened attention to
///   an element, such as an input field. The tertiary colors are left
///   for makers to use at their discretion and are intended to support
///   broader color expression in products.
///
/// Each accent color group (primary, secondary and tertiary) includes '-Fixed'
/// '-Dim' color roles, such as [primaryFixed] and [primaryFixedDim]. Fixed roles
/// are appropriate to use in places where Container roles are normally used,
/// but they stay the same color between light and dark themes. The '-Dim' roles
/// provide a stronger, more emphasized color with the same fixed behavior.
///
/// The remaining colors of the scheme are composed of neutral colors used for
/// backgrounds and surfaces, as well as specific colors for errors, dividers
/// and shadows. Surface colors are used for backgrounds and large, low-emphasis
/// areas of the screen.
///
/// Material 3 also introduces tone-based surfaces and surface containers.
/// They replace the old opacity-based model which applied a tinted overlay on
/// top of surfaces based on their elevation. These colors include: [surfaceBright],
/// [surfaceDim], [surfaceContainerLowest], [surfaceContainerLow], [surfaceContainer],
/// [surfaceContainerHigh], and [surfaceContainerHighest].
///
/// Many of the colors have matching 'on' colors, which are used for drawing
/// content on top of the matching color. For example, if something is using
/// [primary] for a background color, [onPrimary] would be used to paint text
/// and icons on top of it. For this reason, the 'on' colors should have a
/// contrast ratio with their matching colors of at least 4.5:1 in order to
/// be readable. On '-FixedVariant' roles, such as [onPrimaryFixedVariant],
/// also have the same color between light and dark themes, but compared
/// with on '-Fixed' roles, such as [onPrimaryFixed], they provide a
/// lower-emphasis option for text and icons.
///
/// {@tool dartpad}
/// This example shows all Material [ColorScheme] roles in light and dark
/// brightnesses.
///
/// ** See code in examples/api/lib/material/color_scheme/color_scheme.0.dart **
/// {@end-tool}
///
/// ### Setting Colors in Flutter
///
///{@macro flutter.material.colors.settingColors}
@immutable
class ColorScheme with Diagnosticable {
  /// Create a ColorScheme instance from the given colors.
  ///
  /// [ColorScheme.fromSeed] can be used as a simpler way to create a full
  /// color scheme derived from a single seed color.
  ///
  /// For the color parameters that are nullable, it is still recommended
  /// that applications provide values for them. They are only nullable due
  /// to backwards compatibility concerns.
  ///
  /// If a color is not provided, the closest fallback color from the given
  /// colors will be used for it (e.g. [primaryContainer] will default
  /// to [primary]). Material Design 3 makes use of these colors for many
  /// component defaults, so for the best results the application should
  /// supply colors for all the parameters. An easy way to ensure this is to
  /// use [ColorScheme.fromSeed] to generate a full set of colors.
  ///
  /// During the migration to Material Design 3, if an app's
  /// [ThemeData.useMaterial3] is false, then components will only
  /// use the following colors for defaults:
  ///
  /// * [primary]
  /// * [onPrimary]
  /// * [secondary]
  /// * [onSecondary]
  /// * [error]
  /// * [onError]
  /// * [surface]
  /// * [onSurface]
  /// DEPRECATED:
  /// * [background]
  /// * [onBackground]
  const ColorScheme({
    required this.brightness,
    required this.primary,
    required this.onPrimary,
    Color? primaryContainer,
    Color? onPrimaryContainer,
    Color? primaryFixed,
    Color? primaryFixedDim,
    Color? onPrimaryFixed,
    Color? onPrimaryFixedVariant,
    required this.secondary,
    required this.onSecondary,
    Color? secondaryContainer,
    Color? onSecondaryContainer,
    Color? secondaryFixed,
    Color? secondaryFixedDim,
    Color? onSecondaryFixed,
    Color? onSecondaryFixedVariant,
    Color? tertiary,
    Color? onTertiary,
    Color? tertiaryContainer,
    Color? onTertiaryContainer,
    Color? tertiaryFixed,
    Color? tertiaryFixedDim,
    Color? onTertiaryFixed,
    Color? onTertiaryFixedVariant,
    required this.error,
    required this.onError,
    Color? errorContainer,
    Color? onErrorContainer,
    required this.surface,
    required this.onSurface,
    Color? surfaceDim,
    Color? surfaceBright,
    Color? surfaceContainerLowest,
    Color? surfaceContainerLow,
    Color? surfaceContainer,
    Color? surfaceContainerHigh,
    Color? surfaceContainerHighest,
    Color? onSurfaceVariant,
    Color? outline,
    Color? outlineVariant,
    Color? shadow,
    Color? scrim,
    Color? inverseSurface,
    Color? onInverseSurface,
    Color? inversePrimary,
    Color? surfaceTint,
    @Deprecated(
      'Use surface instead. '
      'This feature was deprecated after v3.18.0-0.1.pre.',
    )
    Color? background,
    @Deprecated(
      'Use onSurface instead. '
      'This feature was deprecated after v3.18.0-0.1.pre.',
    )
    Color? onBackground,
    @Deprecated(
      'Use surfaceContainerHighest instead. '
      'This feature was deprecated after v3.18.0-0.1.pre.',
    )
    Color? surfaceVariant,
  }) : _primaryContainer = primaryContainer,
       _onPrimaryContainer = onPrimaryContainer,
       _primaryFixed = primaryFixed,
       _primaryFixedDim = primaryFixedDim,
       _onPrimaryFixed = onPrimaryFixed,
       _onPrimaryFixedVariant = onPrimaryFixedVariant,
       _secondaryContainer = secondaryContainer,
       _onSecondaryContainer = onSecondaryContainer,
       _secondaryFixed = secondaryFixed,
       _secondaryFixedDim = secondaryFixedDim,
       _onSecondaryFixed = onSecondaryFixed,
       _onSecondaryFixedVariant = onSecondaryFixedVariant,
       _tertiary = tertiary,
       _onTertiary = onTertiary,
       _tertiaryContainer = tertiaryContainer,
       _onTertiaryContainer = onTertiaryContainer,
       _tertiaryFixed = tertiaryFixed,
       _tertiaryFixedDim = tertiaryFixedDim,
       _onTertiaryFixed = onTertiaryFixed,
       _onTertiaryFixedVariant = onTertiaryFixedVariant,
       _errorContainer = errorContainer,
       _onErrorContainer = onErrorContainer,
       _surfaceDim = surfaceDim,
       _surfaceBright = surfaceBright,
       _surfaceContainerLowest = surfaceContainerLowest,
       _surfaceContainerLow = surfaceContainerLow,
       _surfaceContainer = surfaceContainer,
       _surfaceContainerHigh = surfaceContainerHigh,
       _surfaceContainerHighest = surfaceContainerHighest,
       _onSurfaceVariant = onSurfaceVariant,
       _outline = outline,
       _outlineVariant = outlineVariant,
       _shadow = shadow,
       _scrim = scrim,
       _inverseSurface = inverseSurface,
       _onInverseSurface = onInverseSurface,
       _inversePrimary = inversePrimary,
       _surfaceTint = surfaceTint,
       // DEPRECATED (newest deprecations at the bottom)
       _background = background,
       _onBackground = onBackground,
       _surfaceVariant = surfaceVariant;

  /// Generate a [ColorScheme] derived from the given `seedColor`.
  ///
  /// Using the `seedColor` as a starting point, a set of tonal palettes are
  /// constructed. By default, the tonal palettes are based on the Material 3
  /// Color system and provide all of the [ColorScheme] colors. These colors are
  /// designed to work well together and meet contrast requirements for
  /// accessibility.
  ///
  /// If any of the optional color parameters are non-null they will be
  /// used in place of the generated colors for that field in the resulting
  /// color scheme. This allows apps to override specific colors for their
  /// needs.
  ///
  /// Given the nature of the algorithm, the `seedColor` may not wind up as
  /// one of the ColorScheme colors.
  ///
  /// The `dynamicSchemeVariant` parameter creates different types of
  /// [DynamicScheme]s, which are used to generate different styles of [ColorScheme]s.
  /// By default, `dynamicSchemeVariant` is set to `tonalSpot`. A [ColorScheme]
  /// constructed by `dynamicSchemeVariant.tonalSpot` has pastel palettes and
  /// won't be too "colorful" even if the `seedColor` has a high chroma value.
  /// If the resulting color scheme is too dark, consider setting `dynamicSchemeVariant`
  /// to [DynamicSchemeVariant.fidelity], whose palettes match the seed color.
  ///
  /// The `contrastLevel` parameter indicates the contrast level between color
  /// pairs, such as [primary] and [onPrimary]. 0.0 is the default (normal);
  /// -1.0 is the lowest; 1.0 is the highest. From Material Design guideline, the
  /// medium and high contrast correspond to 0.5 and 1.0 respectively.
  ///
  /// {@tool dartpad}
  /// This sample shows how to use [ColorScheme.fromSeed] to create dynamic
  /// color schemes with different [DynamicSchemeVariant]s and different
  /// contrast level.
  ///
  /// ** See code in examples/api/lib/material/color_scheme/color_scheme.0.dart **
  /// {@end-tool}
  ///
  /// See also:
  ///
  ///  * <https://m3.material.io/styles/color/the-color-system/color-roles>, the
  ///    Material 3 Color system specification.
  ///  * <https://pub.dev/packages/material_color_utilities>, the package
  ///    used to generate the tonal palettes needed for the scheme.
  factory ColorScheme.fromSeed({
    required Color seedColor,
    Brightness brightness = Brightness.light,
    DynamicSchemeVariant dynamicSchemeVariant = DynamicSchemeVariant.tonalSpot,
    double contrastLevel = 0.0,
    Color? primary,
    Color? onPrimary,
    Color? primaryContainer,
    Color? onPrimaryContainer,
    Color? primaryFixed,
    Color? primaryFixedDim,
    Color? onPrimaryFixed,
    Color? onPrimaryFixedVariant,
    Color? secondary,
    Color? onSecondary,
    Color? secondaryContainer,
    Color? onSecondaryContainer,
    Color? secondaryFixed,
    Color? secondaryFixedDim,
    Color? onSecondaryFixed,
    Color? onSecondaryFixedVariant,
    Color? tertiary,
    Color? onTertiary,
    Color? tertiaryContainer,
    Color? onTertiaryContainer,
    Color? tertiaryFixed,
    Color? tertiaryFixedDim,
    Color? onTertiaryFixed,
    Color? onTertiaryFixedVariant,
    Color? error,
    Color? onError,
    Color? errorContainer,
    Color? onErrorContainer,
    Color? outline,
    Color? outlineVariant,
    Color? surface,
    Color? onSurface,
    Color? surfaceDim,
    Color? surfaceBright,
    Color? surfaceContainerLowest,
    Color? surfaceContainerLow,
    Color? surfaceContainer,
    Color? surfaceContainerHigh,
    Color? surfaceContainerHighest,
    Color? onSurfaceVariant,
    Color? inverseSurface,
    Color? onInverseSurface,
    Color? inversePrimary,
    Color? shadow,
    Color? scrim,
    Color? surfaceTint,
    @Deprecated(
      'Use surface instead. '
      'This feature was deprecated after v3.18.0-0.1.pre.',
    )
    Color? background,
    @Deprecated(
      'Use onSurface instead. '
      'This feature was deprecated after v3.18.0-0.1.pre.',
    )
    Color? onBackground,
    @Deprecated(
      'Use surfaceContainerHighest instead. '
      'This feature was deprecated after v3.18.0-0.1.pre.',
    )
    Color? surfaceVariant,
  }) {
    final DynamicScheme scheme = _buildDynamicScheme(
      brightness,
      seedColor,
      dynamicSchemeVariant,
      contrastLevel,
    );

    return ColorScheme(
      primary: primary ?? Color(MaterialDynamicColors.primary.getArgb(scheme)),
      onPrimary: onPrimary ?? Color(MaterialDynamicColors.onPrimary.getArgb(scheme)),
      primaryContainer:
          primaryContainer ?? Color(MaterialDynamicColors.primaryContainer.getArgb(scheme)),
      onPrimaryContainer:
          onPrimaryContainer ?? Color(MaterialDynamicColors.onPrimaryContainer.getArgb(scheme)),
      primaryFixed: primaryFixed ?? Color(MaterialDynamicColors.primaryFixed.getArgb(scheme)),
      primaryFixedDim:
          primaryFixedDim ?? Color(MaterialDynamicColors.primaryFixedDim.getArgb(scheme)),
      onPrimaryFixed: onPrimaryFixed ?? Color(MaterialDynamicColors.onPrimaryFixed.getArgb(scheme)),
      onPrimaryFixedVariant:
          onPrimaryFixedVariant ??
          Color(MaterialDynamicColors.onPrimaryFixedVariant.getArgb(scheme)),
      secondary: secondary ?? Color(MaterialDynamicColors.secondary.getArgb(scheme)),
      onSecondary: onSecondary ?? Color(MaterialDynamicColors.onSecondary.getArgb(scheme)),
      secondaryContainer:
          secondaryContainer ?? Color(MaterialDynamicColors.secondaryContainer.getArgb(scheme)),
      onSecondaryContainer:
          onSecondaryContainer ?? Color(MaterialDynamicColors.onSecondaryContainer.getArgb(scheme)),
      secondaryFixed: secondaryFixed ?? Color(MaterialDynamicColors.secondaryFixed.getArgb(scheme)),
      secondaryFixedDim:
          secondaryFixedDim ?? Color(MaterialDynamicColors.secondaryFixedDim.getArgb(scheme)),
      onSecondaryFixed:
          onSecondaryFixed ?? Color(MaterialDynamicColors.onSecondaryFixed.getArgb(scheme)),
      onSecondaryFixedVariant:
          onSecondaryFixedVariant ??
          Color(MaterialDynamicColors.onSecondaryFixedVariant.getArgb(scheme)),
      tertiary: tertiary ?? Color(MaterialDynamicColors.tertiary.getArgb(scheme)),
      onTertiary: onTertiary ?? Color(MaterialDynamicColors.onTertiary.getArgb(scheme)),
      tertiaryContainer:
          tertiaryContainer ?? Color(MaterialDynamicColors.tertiaryContainer.getArgb(scheme)),
      onTertiaryContainer:
          onTertiaryContainer ?? Color(MaterialDynamicColors.onTertiaryContainer.getArgb(scheme)),
      tertiaryFixed: tertiaryFixed ?? Color(MaterialDynamicColors.tertiaryFixed.getArgb(scheme)),
      tertiaryFixedDim:
          tertiaryFixedDim ?? Color(MaterialDynamicColors.tertiaryFixedDim.getArgb(scheme)),
      onTertiaryFixed:
          onTertiaryFixed ?? Color(MaterialDynamicColors.onTertiaryFixed.getArgb(scheme)),
      onTertiaryFixedVariant:
          onTertiaryFixedVariant ??
          Color(MaterialDynamicColors.onTertiaryFixedVariant.getArgb(scheme)),
      error: error ?? Color(MaterialDynamicColors.error.getArgb(scheme)),
      onError: onError ?? Color(MaterialDynamicColors.onError.getArgb(scheme)),
      errorContainer: errorContainer ?? Color(MaterialDynamicColors.errorContainer.getArgb(scheme)),
      onErrorContainer:
          onErrorContainer ?? Color(MaterialDynamicColors.onErrorContainer.getArgb(scheme)),
      outline: outline ?? Color(MaterialDynamicColors.outline.getArgb(scheme)),
      outlineVariant: outlineVariant ?? Color(MaterialDynamicColors.outlineVariant.getArgb(scheme)),
      surface: surface ?? Color(MaterialDynamicColors.surface.getArgb(scheme)),
      surfaceDim: surfaceDim ?? Color(MaterialDynamicColors.surfaceDim.getArgb(scheme)),
      surfaceBright: surfaceBright ?? Color(MaterialDynamicColors.surfaceBright.getArgb(scheme)),
      surfaceContainerLowest:
          surfaceContainerLowest ??
          Color(MaterialDynamicColors.surfaceContainerLowest.getArgb(scheme)),
      surfaceContainerLow:
          surfaceContainerLow ?? Color(MaterialDynamicColors.surfaceContainerLow.getArgb(scheme)),
      surfaceContainer:
          surfaceContainer ?? Color(MaterialDynamicColors.surfaceContainer.getArgb(scheme)),
      surfaceContainerHigh:
          surfaceContainerHigh ?? Color(MaterialDynamicColors.surfaceContainerHigh.getArgb(scheme)),
      surfaceContainerHighest:
          surfaceContainerHighest ??
          Color(MaterialDynamicColors.surfaceContainerHighest.getArgb(scheme)),
      onSurface: onSurface ?? Color(MaterialDynamicColors.onSurface.getArgb(scheme)),
      onSurfaceVariant:
          onSurfaceVariant ?? Color(MaterialDynamicColors.onSurfaceVariant.getArgb(scheme)),
      inverseSurface: inverseSurface ?? Color(MaterialDynamicColors.inverseSurface.getArgb(scheme)),
      onInverseSurface:
          onInverseSurface ?? Color(MaterialDynamicColors.inverseOnSurface.getArgb(scheme)),
      inversePrimary: inversePrimary ?? Color(MaterialDynamicColors.inversePrimary.getArgb(scheme)),
      shadow: shadow ?? Color(MaterialDynamicColors.shadow.getArgb(scheme)),
      scrim: scrim ?? Color(MaterialDynamicColors.scrim.getArgb(scheme)),
      surfaceTint: surfaceTint ?? Color(MaterialDynamicColors.primary.getArgb(scheme)),
      brightness: brightness,
      // DEPRECATED (newest deprecations at the bottom)
      background: background ?? Color(MaterialDynamicColors.background.getArgb(scheme)),
      onBackground: onBackground ?? Color(MaterialDynamicColors.onBackground.getArgb(scheme)),
      surfaceVariant: surfaceVariant ?? Color(MaterialDynamicColors.surfaceVariant.getArgb(scheme)),
    );
  }

  /// Create a light ColorScheme based on a purple primary color that matches the
  /// [baseline Material 2 color scheme](https://material.io/design/color/the-color-system.html#color-theme-creation).
  ///
  /// This constructor shouldn't be used to update the Material 3 color scheme.
  ///
  /// For Material 3, use [ColorScheme.fromSeed] to create a color scheme
  /// from a single seed color based on the Material 3 color system.
  ///
  /// {@tool snippet}
  /// This example demonstrates how to create a color scheme similar to [ColorScheme.light]
  /// using the [ColorScheme.fromSeed] constructor:
  ///
  /// ```dart
  /// colorScheme: ColorScheme.fromSeed(seedColor: const Color(0xff6200ee)).copyWith(
  ///   primaryContainer: const Color(0xff6200ee),
  ///   onPrimaryContainer: Colors.white,
  ///   secondaryContainer: const Color(0xff03dac6),
  ///   onSecondaryContainer: Colors.black,
  ///   error: const Color(0xffb00020),
  ///   onError: Colors.white,
  /// ),
  /// ```
  /// {@end-tool}
  const ColorScheme.light({
    this.brightness = Brightness.light,
    this.primary = const Color(0xff6200ee),
    this.onPrimary = Colors.white,
    Color? primaryContainer,
    Color? onPrimaryContainer,
    Color? primaryFixed,
    Color? primaryFixedDim,
    Color? onPrimaryFixed,
    Color? onPrimaryFixedVariant,
    this.secondary = const Color(0xff03dac6),
    this.onSecondary = Colors.black,
    Color? secondaryContainer,
    Color? onSecondaryContainer,
    Color? secondaryFixed,
    Color? secondaryFixedDim,
    Color? onSecondaryFixed,
    Color? onSecondaryFixedVariant,
    Color? tertiary,
    Color? onTertiary,
    Color? tertiaryContainer,
    Color? onTertiaryContainer,
    Color? tertiaryFixed,
    Color? tertiaryFixedDim,
    Color? onTertiaryFixed,
    Color? onTertiaryFixedVariant,
    this.error = const Color(0xffb00020),
    this.onError = Colors.white,
    Color? errorContainer,
    Color? onErrorContainer,
    this.surface = Colors.white,
    this.onSurface = Colors.black,
    Color? surfaceDim,
    Color? surfaceBright,
    Color? surfaceContainerLowest,
    Color? surfaceContainerLow,
    Color? surfaceContainer,
    Color? surfaceContainerHigh,
    Color? surfaceContainerHighest,
    Color? onSurfaceVariant,
    Color? outline,
    Color? outlineVariant,
    Color? shadow,
    Color? scrim,
    Color? inverseSurface,
    Color? onInverseSurface,
    Color? inversePrimary,
    Color? surfaceTint,
    @Deprecated(
      'Use surface instead. '
      'This feature was deprecated after v3.18.0-0.1.pre.',
    )
    Color? background = Colors.white,
    @Deprecated(
      'Use onSurface instead. '
      'This feature was deprecated after v3.18.0-0.1.pre.',
    )
    Color? onBackground = Colors.black,
    @Deprecated(
      'Use surfaceContainerHighest instead. '
      'This feature was deprecated after v3.18.0-0.1.pre.',
    )
    Color? surfaceVariant,
  }) : _primaryContainer = primaryContainer,
       _onPrimaryContainer = onPrimaryContainer,
       _primaryFixed = primaryFixed,
       _primaryFixedDim = primaryFixedDim,
       _onPrimaryFixed = onPrimaryFixed,
       _onPrimaryFixedVariant = onPrimaryFixedVariant,
       _secondaryContainer = secondaryContainer,
       _onSecondaryContainer = onSecondaryContainer,
       _secondaryFixed = secondaryFixed,
       _secondaryFixedDim = secondaryFixedDim,
       _onSecondaryFixed = onSecondaryFixed,
       _onSecondaryFixedVariant = onSecondaryFixedVariant,
       _tertiary = tertiary,
       _onTertiary = onTertiary,
       _tertiaryContainer = tertiaryContainer,
       _onTertiaryContainer = onTertiaryContainer,
       _tertiaryFixed = tertiaryFixed,
       _tertiaryFixedDim = tertiaryFixedDim,
       _onTertiaryFixed = onTertiaryFixed,
       _onTertiaryFixedVariant = onTertiaryFixedVariant,
       _errorContainer = errorContainer,
       _onErrorContainer = onErrorContainer,
       _surfaceDim = surfaceDim,
       _surfaceBright = surfaceBright,
       _surfaceContainerLowest = surfaceContainerLowest,
       _surfaceContainerLow = surfaceContainerLow,
       _surfaceContainer = surfaceContainer,
       _surfaceContainerHigh = surfaceContainerHigh,
       _surfaceContainerHighest = surfaceContainerHighest,
       _onSurfaceVariant = onSurfaceVariant,
       _outline = outline,
       _outlineVariant = outlineVariant,
       _shadow = shadow,
       _scrim = scrim,
       _inverseSurface = inverseSurface,
       _onInverseSurface = onInverseSurface,
       _inversePrimary = inversePrimary,
       _surfaceTint = surfaceTint,
       // DEPRECATED (newest deprecations at the bottom)
       _background = background,
       _onBackground = onBackground,
       _surfaceVariant = surfaceVariant;

  /// Create the dark color scheme that matches the
  /// [baseline Material 2 color scheme](https://material.io/design/color/dark-theme.html#ui-application).
  ///
  /// This constructor shouldn't be used to update the Material 3 color scheme.
  ///
  /// For Material 3, use [ColorScheme.fromSeed] to create a color scheme
  /// from a single seed color based on the Material 3 color system.
  /// Override the `brightness` property of [ColorScheme.fromSeed] to create a
  /// dark color scheme.
  ///
  /// {@tool snippet}
  /// This example demonstrates how to create a color scheme similar to [ColorScheme.dark]
  /// using the [ColorScheme.fromSeed] constructor:
  ///
  /// ```dart
  /// colorScheme: ColorScheme.fromSeed(
  ///   seedColor: const Color(0xffbb86fc),
  ///   brightness: Brightness.dark,
  /// ).copyWith(
  ///   primaryContainer: const Color(0xffbb86fc),
  ///   onPrimaryContainer: Colors.black,
  ///   secondaryContainer: const Color(0xff03dac6),
  ///   onSecondaryContainer: Colors.black,
  ///   error: const Color(0xffcf6679),
  ///   onError: Colors.black,
  /// ),
  /// ```
  /// {@end-tool}
  const ColorScheme.dark({
    this.brightness = Brightness.dark,
    this.primary = const Color(0xffbb86fc),
    this.onPrimary = Colors.black,
    Color? primaryContainer,
    Color? onPrimaryContainer,
    Color? primaryFixed,
    Color? primaryFixedDim,
    Color? onPrimaryFixed,
    Color? onPrimaryFixedVariant,
    this.secondary = const Color(0xff03dac6),
    this.onSecondary = Colors.black,
    Color? secondaryContainer,
    Color? onSecondaryContainer,
    Color? secondaryFixed,
    Color? secondaryFixedDim,
    Color? onSecondaryFixed,
    Color? onSecondaryFixedVariant,
    Color? tertiary,
    Color? onTertiary,
    Color? tertiaryContainer,
    Color? onTertiaryContainer,
    Color? tertiaryFixed,
    Color? tertiaryFixedDim,
    Color? onTertiaryFixed,
    Color? onTertiaryFixedVariant,
    this.error = const Color(0xffcf6679),
    this.onError = Colors.black,
    Color? errorContainer,
    Color? onErrorContainer,
    this.surface = const Color(0xff121212),
    this.onSurface = Colors.white,
    Color? surfaceDim,
    Color? surfaceBright,
    Color? surfaceContainerLowest,
    Color? surfaceContainerLow,
    Color? surfaceContainer,
    Color? surfaceContainerHigh,
    Color? surfaceContainerHighest,
    Color? onSurfaceVariant,
    Color? outline,
    Color? outlineVariant,
    Color? shadow,
    Color? scrim,
    Color? inverseSurface,
    Color? onInverseSurface,
    Color? inversePrimary,
    Color? surfaceTint,
    @Deprecated(
      'Use surface instead. '
      'This feature was deprecated after v3.18.0-0.1.pre.',
    )
    Color? background = const Color(0xff121212),
    @Deprecated(
      'Use onSurface instead. '
      'This feature was deprecated after v3.18.0-0.1.pre.',
    )
    Color? onBackground = Colors.white,
    @Deprecated(
      'Use surfaceContainerHighest instead. '
      'This feature was deprecated after v3.18.0-0.1.pre.',
    )
    Color? surfaceVariant,
  }) : _primaryContainer = primaryContainer,
       _onPrimaryContainer = onPrimaryContainer,
       _primaryFixed = primaryFixed,
       _primaryFixedDim = primaryFixedDim,
       _onPrimaryFixed = onPrimaryFixed,
       _onPrimaryFixedVariant = onPrimaryFixedVariant,
       _secondaryContainer = secondaryContainer,
       _onSecondaryContainer = onSecondaryContainer,
       _secondaryFixed = secondaryFixed,
       _secondaryFixedDim = secondaryFixedDim,
       _onSecondaryFixed = onSecondaryFixed,
       _onSecondaryFixedVariant = onSecondaryFixedVariant,
       _tertiary = tertiary,
       _onTertiary = onTertiary,
       _tertiaryContainer = tertiaryContainer,
       _onTertiaryContainer = onTertiaryContainer,
       _tertiaryFixed = tertiaryFixed,
       _tertiaryFixedDim = tertiaryFixedDim,
       _onTertiaryFixed = onTertiaryFixed,
       _onTertiaryFixedVariant = onTertiaryFixedVariant,
       _errorContainer = errorContainer,
       _onErrorContainer = onErrorContainer,
       _surfaceDim = surfaceDim,
       _surfaceBright = surfaceBright,
       _surfaceContainerLowest = surfaceContainerLowest,
       _surfaceContainerLow = surfaceContainerLow,
       _surfaceContainer = surfaceContainer,
       _surfaceContainerHigh = surfaceContainerHigh,
       _surfaceContainerHighest = surfaceContainerHighest,
       _onSurfaceVariant = onSurfaceVariant,
       _outline = outline,
       _outlineVariant = outlineVariant,
       _shadow = shadow,
       _scrim = scrim,
       _inverseSurface = inverseSurface,
       _onInverseSurface = onInverseSurface,
       _inversePrimary = inversePrimary,
       _surfaceTint = surfaceTint,
       // DEPRECATED (newest deprecations at the bottom)
       _background = background,
       _onBackground = onBackground,
       _surfaceVariant = surfaceVariant;

  /// Create a high contrast ColorScheme based on a purple primary color that
  /// matches the [baseline Material 2 color scheme](https://material.io/design/color/the-color-system.html#color-theme-creation).
  ///
  /// This constructor shouldn't be used to update the Material 3 color scheme.
  ///
  /// For Material 3, use [ColorScheme.fromSeed] to create a color scheme
  /// from a single seed color based on the Material 3 color system. To create a
  /// high-contrast color scheme, set `contrastLevel` to 1.0.
  ///
  /// {@tool snippet}
  /// This example demonstrates how to create a color scheme similar to [ColorScheme.highContrastLight]
  /// using the [ColorScheme.fromSeed] constructor:
  ///
  /// ```dart
  /// colorScheme: ColorScheme.fromSeed(seedColor: const Color(0xff0000ba)).copyWith(
  ///   primaryContainer: const Color(0xff0000ba),
  ///   onPrimaryContainer: Colors.white,
  ///   secondaryContainer: const Color(0xff66fff9),
  ///   onSecondaryContainer: Colors.black,
  ///   error: const Color(0xff790000),
  ///   onError: Colors.white,
  /// ),
  /// ```
  /// {@end-tool}
  const ColorScheme.highContrastLight({
    this.brightness = Brightness.light,
    this.primary = const Color(0xff0000ba),
    this.onPrimary = Colors.white,
    Color? primaryContainer,
    Color? onPrimaryContainer,
    Color? primaryFixed,
    Color? primaryFixedDim,
    Color? onPrimaryFixed,
    Color? onPrimaryFixedVariant,
    this.secondary = const Color(0xff66fff9),
    this.onSecondary = Colors.black,
    Color? secondaryContainer,
    Color? onSecondaryContainer,
    Color? secondaryFixed,
    Color? secondaryFixedDim,
    Color? onSecondaryFixed,
    Color? onSecondaryFixedVariant,
    Color? tertiary,
    Color? onTertiary,
    Color? tertiaryContainer,
    Color? onTertiaryContainer,
    Color? tertiaryFixed,
    Color? tertiaryFixedDim,
    Color? onTertiaryFixed,
    Color? onTertiaryFixedVariant,
    this.error = const Color(0xff790000),
    this.onError = Colors.white,
    Color? errorContainer,
    Color? onErrorContainer,
    this.surface = Colors.white,
    this.onSurface = Colors.black,
    Color? surfaceDim,
    Color? surfaceBright,
    Color? surfaceContainerLowest,
    Color? surfaceContainerLow,
    Color? surfaceContainer,
    Color? surfaceContainerHigh,
    Color? surfaceContainerHighest,
    Color? onSurfaceVariant,
    Color? outline,
    Color? outlineVariant,
    Color? shadow,
    Color? scrim,
    Color? inverseSurface,
    Color? onInverseSurface,
    Color? inversePrimary,
    Color? surfaceTint,
    @Deprecated(
      'Use surface instead. '
      'This feature was deprecated after v3.18.0-0.1.pre.',
    )
    Color? background = Colors.white,
    @Deprecated(
      'Use onSurface instead. '
      'This feature was deprecated after v3.18.0-0.1.pre.',
    )
    Color? onBackground = Colors.black,
    @Deprecated(
      'Use surfaceContainerHighest instead. '
      'This feature was deprecated after v3.18.0-0.1.pre.',
    )
    Color? surfaceVariant,
  }) : _primaryContainer = primaryContainer,
       _onPrimaryContainer = onPrimaryContainer,
       _primaryFixed = primaryFixed,
       _primaryFixedDim = primaryFixedDim,
       _onPrimaryFixed = onPrimaryFixed,
       _onPrimaryFixedVariant = onPrimaryFixedVariant,
       _secondaryContainer = secondaryContainer,
       _onSecondaryContainer = onSecondaryContainer,
       _secondaryFixed = secondaryFixed,
       _secondaryFixedDim = secondaryFixedDim,
       _onSecondaryFixed = onSecondaryFixed,
       _onSecondaryFixedVariant = onSecondaryFixedVariant,
       _tertiary = tertiary,
       _onTertiary = onTertiary,
       _tertiaryContainer = tertiaryContainer,
       _onTertiaryContainer = onTertiaryContainer,
       _tertiaryFixed = tertiaryFixed,
       _tertiaryFixedDim = tertiaryFixedDim,
       _onTertiaryFixed = onTertiaryFixed,
       _onTertiaryFixedVariant = onTertiaryFixedVariant,
       _errorContainer = errorContainer,
       _onErrorContainer = onErrorContainer,
       _surfaceDim = surfaceDim,
       _surfaceBright = surfaceBright,
       _surfaceContainerLowest = surfaceContainerLowest,
       _surfaceContainerLow = surfaceContainerLow,
       _surfaceContainer = surfaceContainer,
       _surfaceContainerHigh = surfaceContainerHigh,
       _surfaceContainerHighest = surfaceContainerHighest,
       _onSurfaceVariant = onSurfaceVariant,
       _outline = outline,
       _outlineVariant = outlineVariant,
       _shadow = shadow,
       _scrim = scrim,
       _inverseSurface = inverseSurface,
       _onInverseSurface = onInverseSurface,
       _inversePrimary = inversePrimary,
       _surfaceTint = surfaceTint,
       // DEPRECATED (newest deprecations at the bottom)
       _background = background,
       _onBackground = onBackground,
       _surfaceVariant = surfaceVariant;

  /// Create a high contrast ColorScheme based on the dark
  /// [baseline Material 2 color scheme](https://material.io/design/color/dark-theme.html#ui-application).
  ///
  /// This constructor shouldn't be used to update the Material 3 color scheme.
  ///
  /// For Material 3, use [ColorScheme.fromSeed] to create a color scheme
  /// from a single seed color based on the Material 3 color system.
  /// Override the `brightness` property of [ColorScheme.fromSeed] to create a
  /// dark color scheme. To create a high-contrast color scheme, set
  /// `contrastLevel` to 1.0.
  ///
  /// {@tool snippet}
  /// This example demonstrates how to create a color scheme similar to [ColorScheme.highContrastDark]
  /// using the [ColorScheme.fromSeed] constructor:
  ///
  /// ```dart
  /// colorScheme: ColorScheme.fromSeed(
  ///   seedColor: const Color(0xffefb7ff),
  ///   brightness: Brightness.dark,
  /// ).copyWith(
  ///   primaryContainer: const Color(0xffefb7ff),
  ///   onPrimaryContainer: Colors.black,
  ///   secondaryContainer: const Color(0xff66fff9),
  ///   onSecondaryContainer: Colors.black,
  ///   error: const Color(0xff9b374d),
  ///   onError: Colors.white,
  /// ),
  /// ```
  /// {@end-tool}
  const ColorScheme.highContrastDark({
    this.brightness = Brightness.dark,
    this.primary = const Color(0xffefb7ff),
    this.onPrimary = Colors.black,
    Color? primaryContainer,
    Color? onPrimaryContainer,
    Color? primaryFixed,
    Color? primaryFixedDim,
    Color? onPrimaryFixed,
    Color? onPrimaryFixedVariant,
    this.secondary = const Color(0xff66fff9),
    this.onSecondary = Colors.black,
    Color? secondaryContainer,
    Color? onSecondaryContainer,
    Color? secondaryFixed,
    Color? secondaryFixedDim,
    Color? onSecondaryFixed,
    Color? onSecondaryFixedVariant,
    Color? tertiary,
    Color? onTertiary,
    Color? tertiaryContainer,
    Color? onTertiaryContainer,
    Color? tertiaryFixed,
    Color? tertiaryFixedDim,
    Color? onTertiaryFixed,
    Color? onTertiaryFixedVariant,
    this.error = const Color(0xff9b374d),
    this.onError = Colors.black,
    Color? errorContainer,
    Color? onErrorContainer,
    this.surface = const Color(0xff121212),
    this.onSurface = Colors.white,
    Color? surfaceDim,
    Color? surfaceBright,
    Color? surfaceContainerLowest,
    Color? surfaceContainerLow,
    Color? surfaceContainer,
    Color? surfaceContainerHigh,
    Color? surfaceContainerHighest,
    Color? onSurfaceVariant,
    Color? outline,
    Color? outlineVariant,
    Color? shadow,
    Color? scrim,
    Color? inverseSurface,
    Color? onInverseSurface,
    Color? inversePrimary,
    Color? surfaceTint,
    @Deprecated(
      'Use surface instead. '
      'This feature was deprecated after v3.18.0-0.1.pre.',
    )
    Color? background = const Color(0xff121212),
    @Deprecated(
      'Use onSurface instead. '
      'This feature was deprecated after v3.18.0-0.1.pre.',
    )
    Color? onBackground = Colors.white,
    @Deprecated(
      'Use surfaceContainerHighest instead. '
      'This feature was deprecated after v3.18.0-0.1.pre.',
    )
    Color? surfaceVariant,
  }) : _primaryContainer = primaryContainer,
       _onPrimaryContainer = onPrimaryContainer,
       _primaryFixed = primaryFixed,
       _primaryFixedDim = primaryFixedDim,
       _onPrimaryFixed = onPrimaryFixed,
       _onPrimaryFixedVariant = onPrimaryFixedVariant,
       _secondaryContainer = secondaryContainer,
       _onSecondaryContainer = onSecondaryContainer,
       _secondaryFixed = secondaryFixed,
       _secondaryFixedDim = secondaryFixedDim,
       _onSecondaryFixed = onSecondaryFixed,
       _onSecondaryFixedVariant = onSecondaryFixedVariant,
       _tertiary = tertiary,
       _onTertiary = onTertiary,
       _tertiaryContainer = tertiaryContainer,
       _onTertiaryContainer = onTertiaryContainer,
       _tertiaryFixed = tertiaryFixed,
       _tertiaryFixedDim = tertiaryFixedDim,
       _onTertiaryFixed = onTertiaryFixed,
       _onTertiaryFixedVariant = onTertiaryFixedVariant,
       _errorContainer = errorContainer,
       _onErrorContainer = onErrorContainer,
       _surfaceDim = surfaceDim,
       _surfaceBright = surfaceBright,
       _surfaceContainerLowest = surfaceContainerLowest,
       _surfaceContainerLow = surfaceContainerLow,
       _surfaceContainer = surfaceContainer,
       _surfaceContainerHigh = surfaceContainerHigh,
       _surfaceContainerHighest = surfaceContainerHighest,
       _onSurfaceVariant = onSurfaceVariant,
       _outline = outline,
       _outlineVariant = outlineVariant,
       _shadow = shadow,
       _scrim = scrim,
       _inverseSurface = inverseSurface,
       _onInverseSurface = onInverseSurface,
       _inversePrimary = inversePrimary,
       _surfaceTint = surfaceTint,
       // DEPRECATED (newest deprecations at the bottom)
       _background = background,
       _onBackground = onBackground,
       _surfaceVariant = surfaceVariant;

  /// Creates a color scheme from a [MaterialColor] swatch.
  ///
  /// In Material 3, this constructor is ignored by [ThemeData] when creating
  /// its default color scheme. Instead, [ThemeData] uses [ColorScheme.fromSeed]
  /// to create its default color scheme. This constructor shouldn't be used
  /// to update the Material 3 color scheme. It will be phased out gradually;
  /// see https://github.com/flutter/flutter/issues/120064 for more details.
  ///
  /// If [ThemeData.useMaterial3] is false, then this constructor is used by
  /// [ThemeData] to create its default color scheme.
  factory ColorScheme.fromSwatch({
    MaterialColor primarySwatch = Colors.blue,
    Color? accentColor,
    Color? cardColor,
    Color? backgroundColor,
    Color? errorColor,
    Brightness brightness = Brightness.light,
  }) {
    final bool isDark = brightness == Brightness.dark;
    final bool primaryIsDark = _brightnessFor(primarySwatch) == Brightness.dark;
    final Color secondary = accentColor ?? (isDark ? Colors.tealAccent[200]! : primarySwatch);
    final bool secondaryIsDark = _brightnessFor(secondary) == Brightness.dark;

    return ColorScheme(
      primary: primarySwatch,
      secondary: secondary,
      surface: cardColor ?? (isDark ? Colors.grey[800]! : Colors.white),
      error: errorColor ?? Colors.red[700]!,
      onPrimary: primaryIsDark ? Colors.white : Colors.black,
      onSecondary: secondaryIsDark ? Colors.white : Colors.black,
      onSurface: isDark ? Colors.white : Colors.black,
      onError: isDark ? Colors.black : Colors.white,
      brightness: brightness,
      // DEPRECATED (newest deprecations at the bottom)
      background: backgroundColor ?? (isDark ? Colors.grey[700]! : primarySwatch[200]!),
      onBackground: primaryIsDark ? Colors.white : Colors.black,
    );
  }

  static Brightness _brightnessFor(Color color) => ThemeData.estimateBrightnessForColor(color);

  /// The overall brightness of this color scheme.
  final Brightness brightness;

  /// The color displayed most frequently across your app’s screens and components.
  final Color primary;

  /// A color that's clearly legible when drawn on [primary].
  ///
  /// To ensure that an app is accessible, a contrast ratio between
  /// [primary] and [onPrimary] of at least 4.5:1 is recommended. See
  /// <https://www.w3.org/TR/UNDERSTANDING-WCAG20/visual-audio-contrast-contrast.html>.
  final Color onPrimary;

  final Color? _primaryContainer;

  /// A color used for elements needing less emphasis than [primary].
  Color get primaryContainer => _primaryContainer ?? primary;

  final Color? _onPrimaryContainer;

  /// A color that's clearly legible when drawn on [primaryContainer].
  ///
  /// To ensure that an app is accessible, a contrast ratio between
  /// [primaryContainer] and [onPrimaryContainer] of at least 4.5:1
  /// is recommended. See
  /// <https://www.w3.org/TR/UNDERSTANDING-WCAG20/visual-audio-contrast-contrast.html>.
  Color get onPrimaryContainer => _onPrimaryContainer ?? onPrimary;

  final Color? _primaryFixed;

  /// A substitute for [primaryContainer] that's the same color for the dark
  /// and light themes.
  Color get primaryFixed => _primaryFixed ?? primary;

  final Color? _primaryFixedDim;

  /// A color used for elements needing more emphasis than [primaryFixed].
  Color get primaryFixedDim => _primaryFixedDim ?? primary;

  final Color? _onPrimaryFixed;

  /// A color that is used for text and icons that exist on top of elements having
  /// [primaryFixed] color.
  Color get onPrimaryFixed => _onPrimaryFixed ?? onPrimary;

  final Color? _onPrimaryFixedVariant;

  /// A color that provides a lower-emphasis option for text and icons than
  /// [onPrimaryFixed].
  Color get onPrimaryFixedVariant => _onPrimaryFixedVariant ?? onPrimary;

  /// An accent color used for less prominent components in the UI, such as
  /// filter chips, while expanding the opportunity for color expression.
  final Color secondary;

  /// A color that's clearly legible when drawn on [secondary].
  ///
  /// To ensure that an app is accessible, a contrast ratio between
  /// [secondary] and [onSecondary] of at least 4.5:1 is recommended. See
  /// <https://www.w3.org/TR/UNDERSTANDING-WCAG20/visual-audio-contrast-contrast.html>.
  final Color onSecondary;

  final Color? _secondaryContainer;

  /// A color used for elements needing less emphasis than [secondary].
  Color get secondaryContainer => _secondaryContainer ?? secondary;

  final Color? _onSecondaryContainer;

  /// A color that's clearly legible when drawn on [secondaryContainer].
  ///
  /// To ensure that an app is accessible, a contrast ratio between
  /// [secondaryContainer] and [onSecondaryContainer] of at least 4.5:1 is
  /// recommended. See
  /// <https://www.w3.org/TR/UNDERSTANDING-WCAG20/visual-audio-contrast-contrast.html>.
  Color get onSecondaryContainer => _onSecondaryContainer ?? onSecondary;

  final Color? _secondaryFixed;

  /// A substitute for [secondaryContainer] that's the same color for the dark
  /// and light themes.
  Color get secondaryFixed => _secondaryFixed ?? secondary;

  final Color? _secondaryFixedDim;

  /// A color used for elements needing more emphasis than [secondaryFixed].
  Color get secondaryFixedDim => _secondaryFixedDim ?? secondary;

  final Color? _onSecondaryFixed;

  /// A color that is used for text and icons that exist on top of elements having
  /// [secondaryFixed] color.
  Color get onSecondaryFixed => _onSecondaryFixed ?? onSecondary;

  final Color? _onSecondaryFixedVariant;

  /// A color that provides a lower-emphasis option for text and icons than
  /// [onSecondaryFixed].
  Color get onSecondaryFixedVariant => _onSecondaryFixedVariant ?? onSecondary;

  final Color? _tertiary;

  /// A color used as a contrasting accent that can balance [primary]
  /// and [secondary] colors or bring heightened attention to an element,
  /// such as an input field.
  Color get tertiary => _tertiary ?? secondary;

  final Color? _onTertiary;

  /// A color that's clearly legible when drawn on [tertiary].
  ///
  /// To ensure that an app is accessible, a contrast ratio between
  /// [tertiary] and [onTertiary] of at least 4.5:1 is recommended. See
  /// <https://www.w3.org/TR/UNDERSTANDING-WCAG20/visual-audio-contrast-contrast.html>.
  Color get onTertiary => _onTertiary ?? onSecondary;

  final Color? _tertiaryContainer;

  /// A color used for elements needing less emphasis than [tertiary].
  Color get tertiaryContainer => _tertiaryContainer ?? tertiary;

  final Color? _onTertiaryContainer;

  /// A color that's clearly legible when drawn on [tertiaryContainer].
  ///
  /// To ensure that an app is accessible, a contrast ratio between
  /// [tertiaryContainer] and [onTertiaryContainer] of at least 4.5:1 is
  /// recommended. See
  /// <https://www.w3.org/TR/UNDERSTANDING-WCAG20/visual-audio-contrast-contrast.html>.
  Color get onTertiaryContainer => _onTertiaryContainer ?? onTertiary;

  final Color? _tertiaryFixed;

  /// A substitute for [tertiaryContainer] that's the same color for dark
  /// and light themes.
  Color get tertiaryFixed => _tertiaryFixed ?? tertiary;

  final Color? _tertiaryFixedDim;

  /// A color used for elements needing more emphasis than [tertiaryFixed].
  Color get tertiaryFixedDim => _tertiaryFixedDim ?? tertiary;

  final Color? _onTertiaryFixed;

  /// A color that is used for text and icons that exist on top of elements having
  /// [tertiaryFixed] color.
  Color get onTertiaryFixed => _onTertiaryFixed ?? onTertiary;

  final Color? _onTertiaryFixedVariant;

  /// A color that provides a lower-emphasis option for text and icons than
  /// [onTertiaryFixed].
  Color get onTertiaryFixedVariant => _onTertiaryFixedVariant ?? onTertiary;

  /// The color to use for input validation errors, e.g. for
  /// [InputDecoration.errorText].
  final Color error;

  /// A color that's clearly legible when drawn on [error].
  ///
  /// To ensure that an app is accessible, a contrast ratio between
  /// [error] and [onError] of at least 4.5:1 is recommended. See
  /// <https://www.w3.org/TR/UNDERSTANDING-WCAG20/visual-audio-contrast-contrast.html>.
  final Color onError;

  final Color? _errorContainer;

  /// A color used for error elements needing less emphasis than [error].
  Color get errorContainer => _errorContainer ?? error;

  final Color? _onErrorContainer;

  /// A color that's clearly legible when drawn on [errorContainer].
  ///
  /// To ensure that an app is accessible, a contrast ratio between
  /// [errorContainer] and [onErrorContainer] of at least 4.5:1 is
  /// recommended. See
  /// <https://www.w3.org/TR/UNDERSTANDING-WCAG20/visual-audio-contrast-contrast.html>.
  Color get onErrorContainer => _onErrorContainer ?? onError;

  /// The background color for widgets like [Scaffold].
  final Color surface;

  /// A color that's clearly legible when drawn on [surface].
  ///
  /// To ensure that an app is accessible, a contrast ratio between
  /// [surface] and [onSurface] of at least 4.5:1 is recommended. See
  /// <https://www.w3.org/TR/UNDERSTANDING-WCAG20/visual-audio-contrast-contrast.html>.
  final Color onSurface;

  final Color? _surfaceVariant;

  /// A color variant of [surface] that can be used for differentiation against
  /// a component using [surface].
  @Deprecated(
    'Use surfaceContainerHighest instead. '
    'This feature was deprecated after v3.18.0-0.1.pre.',
  )
  Color get surfaceVariant => _surfaceVariant ?? surface;

  final Color? _surfaceDim;

  /// A color that's always darkest in the dark or light theme.
  Color get surfaceDim => _surfaceDim ?? surface;

  final Color? _surfaceBright;

  /// A color that's always the lightest in the dark or light theme.
  Color get surfaceBright => _surfaceBright ?? surface;

  final Color? _surfaceContainerLowest;

  /// A surface container color with the lightest tone and the least emphasis
  /// relative to the surface.
  Color get surfaceContainerLowest => _surfaceContainerLowest ?? surface;

  final Color? _surfaceContainerLow;

  /// A surface container color with a lighter tone that creates less emphasis
  /// than [surfaceContainer] but more emphasis than [surfaceContainerLowest].
  Color get surfaceContainerLow => _surfaceContainerLow ?? surface;

  final Color? _surfaceContainer;

  /// A recommended color role for a distinct area within the surface.
  ///
  /// Surface container color roles are independent of elevation. They replace the old
  /// opacity-based model which applied a tinted overlay on top of
  /// surfaces based on their elevation.
  ///
  /// Surface container colors include [surfaceContainerLowest], [surfaceContainerLow],
  /// [surfaceContainer], [surfaceContainerHigh] and [surfaceContainerHighest].
  Color get surfaceContainer => _surfaceContainer ?? surface;

  final Color? _surfaceContainerHigh;

  /// A surface container color with a darker tone. It is used to create more
  /// emphasis than [surfaceContainer] but less emphasis than [surfaceContainerHighest].
  Color get surfaceContainerHigh => _surfaceContainerHigh ?? surface;

  final Color? _surfaceContainerHighest;

  /// A surface container color with the darkest tone. It is used to create the
  /// most emphasis against the surface.
  Color get surfaceContainerHighest => _surfaceContainerHighest ?? surface;

  final Color? _onSurfaceVariant;

  /// A color that's clearly legible when drawn on [surfaceVariant].
  ///
  /// To ensure that an app is accessible, a contrast ratio between
  /// [surfaceVariant] and [onSurfaceVariant] of at least 4.5:1 is
  /// recommended. See
  /// <https://www.w3.org/TR/UNDERSTANDING-WCAG20/visual-audio-contrast-contrast.html>.
  Color get onSurfaceVariant => _onSurfaceVariant ?? onSurface;

  final Color? _outline;

  /// A utility color that creates boundaries and emphasis to improve usability.
  Color get outline => _outline ?? onBackground;

  final Color? _outlineVariant;

  /// A utility color that creates boundaries for decorative elements when a
  /// 3:1 contrast isn’t required, such as for dividers or decorative elements.
  Color get outlineVariant => _outlineVariant ?? onBackground;

  final Color? _shadow;

  /// A color use to paint the drop shadows of elevated components.
  Color get shadow => _shadow ?? const Color(0xff000000);

  final Color? _scrim;

  /// A color use to paint the scrim around of modal components.
  Color get scrim => _scrim ?? const Color(0xff000000);

  final Color? _inverseSurface;

  /// A surface color used for displaying the reverse of what’s seen in the
  /// surrounding UI, for example in a SnackBar to bring attention to
  /// an alert.
  Color get inverseSurface => _inverseSurface ?? onSurface;

  final Color? _onInverseSurface;

  /// A color that's clearly legible when drawn on [inverseSurface].
  ///
  /// To ensure that an app is accessible, a contrast ratio between
  /// [inverseSurface] and [onInverseSurface] of at least 4.5:1 is
  /// recommended. See
  /// <https://www.w3.org/TR/UNDERSTANDING-WCAG20/visual-audio-contrast-contrast.html>.
  Color get onInverseSurface => _onInverseSurface ?? surface;

  final Color? _inversePrimary;

  /// An accent color used for displaying a highlight color on [inverseSurface]
  /// backgrounds, like button text in a SnackBar.
  Color get inversePrimary => _inversePrimary ?? onPrimary;

  final Color? _surfaceTint;

  /// A color used as an overlay on a surface color to indicate a component's
  /// elevation.
  Color get surfaceTint => _surfaceTint ?? primary;

  final Color? _background;

  /// A color that typically appears behind scrollable content.
  @Deprecated(
    'Use surface instead. '
    'This feature was deprecated after v3.18.0-0.1.pre.',
  )
  Color get background => _background ?? surface;

  final Color? _onBackground;

  /// A color that's clearly legible when drawn on [background].
  ///
  /// To ensure that an app is accessible, a contrast ratio between
  /// [background] and [onBackground] of at least 4.5:1 is recommended. See
  /// <https://www.w3.org/TR/UNDERSTANDING-WCAG20/visual-audio-contrast-contrast.html>.
  @Deprecated(
    'Use onSurface instead. '
    'This feature was deprecated after v3.18.0-0.1.pre.',
  )
  Color get onBackground => _onBackground ?? onSurface;

  /// Creates a copy of this color scheme with the given fields
  /// replaced by the non-null parameter values.
  ColorScheme copyWith({
    Brightness? brightness,
    Color? primary,
    Color? onPrimary,
    Color? primaryContainer,
    Color? onPrimaryContainer,
    Color? primaryFixed,
    Color? primaryFixedDim,
    Color? onPrimaryFixed,
    Color? onPrimaryFixedVariant,
    Color? secondary,
    Color? onSecondary,
    Color? secondaryContainer,
    Color? onSecondaryContainer,
    Color? secondaryFixed,
    Color? secondaryFixedDim,
    Color? onSecondaryFixed,
    Color? onSecondaryFixedVariant,
    Color? tertiary,
    Color? onTertiary,
    Color? tertiaryContainer,
    Color? onTertiaryContainer,
    Color? tertiaryFixed,
    Color? tertiaryFixedDim,
    Color? onTertiaryFixed,
    Color? onTertiaryFixedVariant,
    Color? error,
    Color? onError,
    Color? errorContainer,
    Color? onErrorContainer,
    Color? surface,
    Color? onSurface,
    Color? surfaceDim,
    Color? surfaceBright,
    Color? surfaceContainerLowest,
    Color? surfaceContainerLow,
    Color? surfaceContainer,
    Color? surfaceContainerHigh,
    Color? surfaceContainerHighest,
    Color? onSurfaceVariant,
    Color? outline,
    Color? outlineVariant,
    Color? shadow,
    Color? scrim,
    Color? inverseSurface,
    Color? onInverseSurface,
    Color? inversePrimary,
    Color? surfaceTint,
    @Deprecated(
      'Use surface instead. '
      'This feature was deprecated after v3.18.0-0.1.pre.',
    )
    Color? background,
    @Deprecated(
      'Use onSurface instead. '
      'This feature was deprecated after v3.18.0-0.1.pre.',
    )
    Color? onBackground,
    @Deprecated(
      'Use surfaceContainerHighest instead. '
      'This feature was deprecated after v3.18.0-0.1.pre.',
    )
    Color? surfaceVariant,
  }) {
    return ColorScheme(
      brightness: brightness ?? this.brightness,
      primary: primary ?? this.primary,
      onPrimary: onPrimary ?? this.onPrimary,
      primaryContainer: primaryContainer ?? this.primaryContainer,
      onPrimaryContainer: onPrimaryContainer ?? this.onPrimaryContainer,
      primaryFixed: primaryFixed ?? this.primaryFixed,
      primaryFixedDim: primaryFixedDim ?? this.primaryFixedDim,
      onPrimaryFixed: onPrimaryFixed ?? this.onPrimaryFixed,
      onPrimaryFixedVariant: onPrimaryFixedVariant ?? this.onPrimaryFixedVariant,
      secondary: secondary ?? this.secondary,
      onSecondary: onSecondary ?? this.onSecondary,
      secondaryContainer: secondaryContainer ?? this.secondaryContainer,
      onSecondaryContainer: onSecondaryContainer ?? this.onSecondaryContainer,
      secondaryFixed: secondaryFixed ?? this.secondaryFixed,
      secondaryFixedDim: secondaryFixedDim ?? this.secondaryFixedDim,
      onSecondaryFixed: onSecondaryFixed ?? this.onSecondaryFixed,
      onSecondaryFixedVariant: onSecondaryFixedVariant ?? this.onSecondaryFixedVariant,
      tertiary: tertiary ?? this.tertiary,
      onTertiary: onTertiary ?? this.onTertiary,
      tertiaryContainer: tertiaryContainer ?? this.tertiaryContainer,
      onTertiaryContainer: onTertiaryContainer ?? this.onTertiaryContainer,
      tertiaryFixed: tertiaryFixed ?? this.tertiaryFixed,
      tertiaryFixedDim: tertiaryFixedDim ?? this.tertiaryFixedDim,
      onTertiaryFixed: onTertiaryFixed ?? this.onTertiaryFixed,
      onTertiaryFixedVariant: onTertiaryFixedVariant ?? this.onTertiaryFixedVariant,
      error: error ?? this.error,
      onError: onError ?? this.onError,
      errorContainer: errorContainer ?? this.errorContainer,
      onErrorContainer: onErrorContainer ?? this.onErrorContainer,
      surface: surface ?? this.surface,
      onSurface: onSurface ?? this.onSurface,
      surfaceDim: surfaceDim ?? this.surfaceDim,
      surfaceBright: surfaceBright ?? this.surfaceBright,
      surfaceContainerLowest: surfaceContainerLowest ?? this.surfaceContainerLowest,
      surfaceContainerLow: surfaceContainerLow ?? this.surfaceContainerLow,
      surfaceContainer: surfaceContainer ?? this.surfaceContainer,
      surfaceContainerHigh: surfaceContainerHigh ?? this.surfaceContainerHigh,
      surfaceContainerHighest: surfaceContainerHighest ?? this.surfaceContainerHighest,
      onSurfaceVariant: onSurfaceVariant ?? this.onSurfaceVariant,
      outline: outline ?? this.outline,
      outlineVariant: outlineVariant ?? this.outlineVariant,
      shadow: shadow ?? this.shadow,
      scrim: scrim ?? this.scrim,
      inverseSurface: inverseSurface ?? this.inverseSurface,
      onInverseSurface: onInverseSurface ?? this.onInverseSurface,
      inversePrimary: inversePrimary ?? this.inversePrimary,
      surfaceTint: surfaceTint ?? this.surfaceTint,
      // DEPRECATED (newest deprecations at the bottom)
      background: background ?? this.background,
      onBackground: onBackground ?? this.onBackground,
      surfaceVariant: surfaceVariant ?? this.surfaceVariant,
    );
  }

  /// Linearly interpolate between two [ColorScheme] objects.
  ///
  /// {@macro dart.ui.shadow.lerp}
  static ColorScheme lerp(ColorScheme a, ColorScheme b, double t) {
    if (identical(a, b)) {
      return a;
    }
    return ColorScheme(
      brightness: t < 0.5 ? a.brightness : b.brightness,
      primary: Color.lerp(a.primary, b.primary, t)!,
      onPrimary: Color.lerp(a.onPrimary, b.onPrimary, t)!,
      primaryContainer: Color.lerp(a.primaryContainer, b.primaryContainer, t),
      onPrimaryContainer: Color.lerp(a.onPrimaryContainer, b.onPrimaryContainer, t),
      primaryFixed: Color.lerp(a.primaryFixed, b.primaryFixed, t),
      primaryFixedDim: Color.lerp(a.primaryFixedDim, b.primaryFixedDim, t),
      onPrimaryFixed: Color.lerp(a.onPrimaryFixed, b.onPrimaryFixed, t),
      onPrimaryFixedVariant: Color.lerp(a.onPrimaryFixedVariant, b.onPrimaryFixedVariant, t),
      secondary: Color.lerp(a.secondary, b.secondary, t)!,
      onSecondary: Color.lerp(a.onSecondary, b.onSecondary, t)!,
      secondaryContainer: Color.lerp(a.secondaryContainer, b.secondaryContainer, t),
      onSecondaryContainer: Color.lerp(a.onSecondaryContainer, b.onSecondaryContainer, t),
      secondaryFixed: Color.lerp(a.secondaryFixed, b.secondaryFixed, t),
      secondaryFixedDim: Color.lerp(a.secondaryFixedDim, b.secondaryFixedDim, t),
      onSecondaryFixed: Color.lerp(a.onSecondaryFixed, b.onSecondaryFixed, t),
      onSecondaryFixedVariant: Color.lerp(a.onSecondaryFixedVariant, b.onSecondaryFixedVariant, t),
      tertiary: Color.lerp(a.tertiary, b.tertiary, t),
      onTertiary: Color.lerp(a.onTertiary, b.onTertiary, t),
      tertiaryContainer: Color.lerp(a.tertiaryContainer, b.tertiaryContainer, t),
      onTertiaryContainer: Color.lerp(a.onTertiaryContainer, b.onTertiaryContainer, t),
      tertiaryFixed: Color.lerp(a.tertiaryFixed, b.tertiaryFixed, t),
      tertiaryFixedDim: Color.lerp(a.tertiaryFixedDim, b.tertiaryFixedDim, t),
      onTertiaryFixed: Color.lerp(a.onTertiaryFixed, b.onTertiaryFixed, t),
      onTertiaryFixedVariant: Color.lerp(a.onTertiaryFixedVariant, b.onTertiaryFixedVariant, t),
      error: Color.lerp(a.error, b.error, t)!,
      onError: Color.lerp(a.onError, b.onError, t)!,
      errorContainer: Color.lerp(a.errorContainer, b.errorContainer, t),
      onErrorContainer: Color.lerp(a.onErrorContainer, b.onErrorContainer, t),
      surface: Color.lerp(a.surface, b.surface, t)!,
      onSurface: Color.lerp(a.onSurface, b.onSurface, t)!,
      surfaceDim: Color.lerp(a.surfaceDim, b.surfaceDim, t),
      surfaceBright: Color.lerp(a.surfaceBright, b.surfaceBright, t),
      surfaceContainerLowest: Color.lerp(a.surfaceContainerLowest, b.surfaceContainerLowest, t),
      surfaceContainerLow: Color.lerp(a.surfaceContainerLow, b.surfaceContainerLow, t),
      surfaceContainer: Color.lerp(a.surfaceContainer, b.surfaceContainer, t),
      surfaceContainerHigh: Color.lerp(a.surfaceContainerHigh, b.surfaceContainerHigh, t),
      surfaceContainerHighest: Color.lerp(a.surfaceContainerHighest, b.surfaceContainerHighest, t),
      onSurfaceVariant: Color.lerp(a.onSurfaceVariant, b.onSurfaceVariant, t),
      outline: Color.lerp(a.outline, b.outline, t),
      outlineVariant: Color.lerp(a.outlineVariant, b.outlineVariant, t),
      shadow: Color.lerp(a.shadow, b.shadow, t),
      scrim: Color.lerp(a.scrim, b.scrim, t),
      inverseSurface: Color.lerp(a.inverseSurface, b.inverseSurface, t),
      onInverseSurface: Color.lerp(a.onInverseSurface, b.onInverseSurface, t),
      inversePrimary: Color.lerp(a.inversePrimary, b.inversePrimary, t),
      surfaceTint: Color.lerp(a.surfaceTint, b.surfaceTint, t),
      // DEPRECATED (newest deprecations at the bottom)
      background: Color.lerp(a.background, b.background, t),
      onBackground: Color.lerp(a.onBackground, b.onBackground, t),
      surfaceVariant: Color.lerp(a.surfaceVariant, b.surfaceVariant, t),
    );
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other.runtimeType != runtimeType) {
      return false;
    }
    return other is ColorScheme &&
        other.brightness == brightness &&
        other.primary == primary &&
        other.onPrimary == onPrimary &&
        other.primaryContainer == primaryContainer &&
        other.onPrimaryContainer == onPrimaryContainer &&
        other.primaryFixed == primaryFixed &&
        other.primaryFixedDim == primaryFixedDim &&
        other.onPrimaryFixed == onPrimaryFixed &&
        other.onPrimaryFixedVariant == onPrimaryFixedVariant &&
        other.secondary == secondary &&
        other.onSecondary == onSecondary &&
        other.secondaryContainer == secondaryContainer &&
        other.onSecondaryContainer == onSecondaryContainer &&
        other.secondaryFixed == secondaryFixed &&
        other.secondaryFixedDim == secondaryFixedDim &&
        other.onSecondaryFixed == onSecondaryFixed &&
        other.onSecondaryFixedVariant == onSecondaryFixedVariant &&
        other.tertiary == tertiary &&
        other.onTertiary == onTertiary &&
        other.tertiaryContainer == tertiaryContainer &&
        other.onTertiaryContainer == onTertiaryContainer &&
        other.tertiaryFixed == tertiaryFixed &&
        other.tertiaryFixedDim == tertiaryFixedDim &&
        other.onTertiaryFixed == onTertiaryFixed &&
        other.onTertiaryFixedVariant == onTertiaryFixedVariant &&
        other.error == error &&
        other.onError == onError &&
        other.errorContainer == errorContainer &&
        other.onErrorContainer == onErrorContainer &&
        other.surface == surface &&
        other.onSurface == onSurface &&
        other.surfaceDim == surfaceDim &&
        other.surfaceBright == surfaceBright &&
        other.surfaceContainerLowest == surfaceContainerLowest &&
        other.surfaceContainerLow == surfaceContainerLow &&
        other.surfaceContainer == surfaceContainer &&
        other.surfaceContainerHigh == surfaceContainerHigh &&
        other.surfaceContainerHighest == surfaceContainerHighest &&
        other.onSurfaceVariant == onSurfaceVariant &&
        other.outline == outline &&
        other.outlineVariant == outlineVariant &&
        other.shadow == shadow &&
        other.scrim == scrim &&
        other.inverseSurface == inverseSurface &&
        other.onInverseSurface == onInverseSurface &&
        other.inversePrimary == inversePrimary &&
        other.surfaceTint == surfaceTint
        // DEPRECATED (newest deprecations at the bottom)
        &&
        other.background == background &&
        other.onBackground == onBackground &&
        other.surfaceVariant == surfaceVariant;
  }

  @override
  int get hashCode => Object.hash(
    brightness,
    primary,
    onPrimary,
    primaryContainer,
    onPrimaryContainer,
    secondary,
    onSecondary,
    secondaryContainer,
    onSecondaryContainer,
    tertiary,
    onTertiary,
    tertiaryContainer,
    onTertiaryContainer,
    error,
    onError,
    errorContainer,
    onErrorContainer,
    Object.hash(
      surface,
      onSurface,
      surfaceDim,
      surfaceBright,
      surfaceContainerLowest,
      surfaceContainerLow,
      surfaceContainer,
      surfaceContainerHigh,
      surfaceContainerHighest,
      onSurfaceVariant,
      outline,
      outlineVariant,
      shadow,
      scrim,
      inverseSurface,
      onInverseSurface,
      inversePrimary,
      surfaceTint,
      Object.hash(
        primaryFixed,
        primaryFixedDim,
        onPrimaryFixed,
        onPrimaryFixedVariant,
        secondaryFixed,
        secondaryFixedDim,
        onSecondaryFixed,
        onSecondaryFixedVariant,
        tertiaryFixed,
        tertiaryFixedDim,
        onTertiaryFixed,
        onTertiaryFixedVariant,
        // DEPRECATED (newest deprecations at the bottom)
        background,
        onBackground,
        surfaceVariant,
      ),
    ),
  );

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    const ColorScheme defaultScheme = ColorScheme.light();
    properties.add(
      DiagnosticsProperty<Brightness>(
        'brightness',
        brightness,
        defaultValue: defaultScheme.brightness,
      ),
    );
    properties.add(ColorProperty('primary', primary, defaultValue: defaultScheme.primary));
    properties.add(ColorProperty('onPrimary', onPrimary, defaultValue: defaultScheme.onPrimary));
    properties.add(
      ColorProperty(
        'primaryContainer',
        primaryContainer,
        defaultValue: defaultScheme.primaryContainer,
      ),
    );
    properties.add(
      ColorProperty(
        'onPrimaryContainer',
        onPrimaryContainer,
        defaultValue: defaultScheme.onPrimaryContainer,
      ),
    );
    properties.add(
      ColorProperty('primaryFixed', primaryFixed, defaultValue: defaultScheme.primaryFixed),
    );
    properties.add(
      ColorProperty(
        'primaryFixedDim',
        primaryFixedDim,
        defaultValue: defaultScheme.primaryFixedDim,
      ),
    );
    properties.add(
      ColorProperty('onPrimaryFixed', onPrimaryFixed, defaultValue: defaultScheme.onPrimaryFixed),
    );
    properties.add(
      ColorProperty(
        'onPrimaryFixedVariant',
        onPrimaryFixedVariant,
        defaultValue: defaultScheme.onPrimaryFixedVariant,
      ),
    );
    properties.add(ColorProperty('secondary', secondary, defaultValue: defaultScheme.secondary));
    properties.add(
      ColorProperty('onSecondary', onSecondary, defaultValue: defaultScheme.onSecondary),
    );
    properties.add(
      ColorProperty(
        'secondaryContainer',
        secondaryContainer,
        defaultValue: defaultScheme.secondaryContainer,
      ),
    );
    properties.add(
      ColorProperty(
        'onSecondaryContainer',
        onSecondaryContainer,
        defaultValue: defaultScheme.onSecondaryContainer,
      ),
    );
    properties.add(
      ColorProperty('secondaryFixed', secondaryFixed, defaultValue: defaultScheme.secondaryFixed),
    );
    properties.add(
      ColorProperty(
        'secondaryFixedDim',
        secondaryFixedDim,
        defaultValue: defaultScheme.secondaryFixedDim,
      ),
    );
    properties.add(
      ColorProperty(
        'onSecondaryFixed',
        onSecondaryFixed,
        defaultValue: defaultScheme.onSecondaryFixed,
      ),
    );
    properties.add(
      ColorProperty(
        'onSecondaryFixedVariant',
        onSecondaryFixedVariant,
        defaultValue: defaultScheme.onSecondaryFixedVariant,
      ),
    );
    properties.add(ColorProperty('tertiary', tertiary, defaultValue: defaultScheme.tertiary));
    properties.add(ColorProperty('onTertiary', onTertiary, defaultValue: defaultScheme.onTertiary));
    properties.add(
      ColorProperty(
        'tertiaryContainer',
        tertiaryContainer,
        defaultValue: defaultScheme.tertiaryContainer,
      ),
    );
    properties.add(
      ColorProperty(
        'onTertiaryContainer',
        onTertiaryContainer,
        defaultValue: defaultScheme.onTertiaryContainer,
      ),
    );
    properties.add(
      ColorProperty('tertiaryFixed', tertiaryFixed, defaultValue: defaultScheme.tertiaryFixed),
    );
    properties.add(
      ColorProperty(
        'tertiaryFixedDim',
        tertiaryFixedDim,
        defaultValue: defaultScheme.tertiaryFixedDim,
      ),
    );
    properties.add(
      ColorProperty(
        'onTertiaryFixed',
        onTertiaryFixed,
        defaultValue: defaultScheme.onTertiaryFixed,
      ),
    );
    properties.add(
      ColorProperty(
        'onTertiaryFixedVariant',
        onTertiaryFixedVariant,
        defaultValue: defaultScheme.onTertiaryFixedVariant,
      ),
    );
    properties.add(ColorProperty('error', error, defaultValue: defaultScheme.error));
    properties.add(ColorProperty('onError', onError, defaultValue: defaultScheme.onError));
    properties.add(
      ColorProperty('errorContainer', errorContainer, defaultValue: defaultScheme.errorContainer),
    );
    properties.add(
      ColorProperty(
        'onErrorContainer',
        onErrorContainer,
        defaultValue: defaultScheme.onErrorContainer,
      ),
    );
    properties.add(ColorProperty('surface', surface, defaultValue: defaultScheme.surface));
    properties.add(ColorProperty('onSurface', onSurface, defaultValue: defaultScheme.onSurface));
    properties.add(ColorProperty('surfaceDim', surfaceDim, defaultValue: defaultScheme.surfaceDim));
    properties.add(
      ColorProperty('surfaceBright', surfaceBright, defaultValue: defaultScheme.surfaceBright),
    );
    properties.add(
      ColorProperty(
        'surfaceContainerLowest',
        surfaceContainerLowest,
        defaultValue: defaultScheme.surfaceContainerLowest,
      ),
    );
    properties.add(
      ColorProperty(
        'surfaceContainerLow',
        surfaceContainerLow,
        defaultValue: defaultScheme.surfaceContainerLow,
      ),
    );
    properties.add(
      ColorProperty(
        'surfaceContainer',
        surfaceContainer,
        defaultValue: defaultScheme.surfaceContainer,
      ),
    );
    properties.add(
      ColorProperty(
        'surfaceContainerHigh',
        surfaceContainerHigh,
        defaultValue: defaultScheme.surfaceContainerHigh,
      ),
    );
    properties.add(
      ColorProperty(
        'surfaceContainerHighest',
        surfaceContainerHighest,
        defaultValue: defaultScheme.surfaceContainerHighest,
      ),
    );
    properties.add(
      ColorProperty(
        'onSurfaceVariant',
        onSurfaceVariant,
        defaultValue: defaultScheme.onSurfaceVariant,
      ),
    );
    properties.add(ColorProperty('outline', outline, defaultValue: defaultScheme.outline));
    properties.add(
      ColorProperty('outlineVariant', outlineVariant, defaultValue: defaultScheme.outlineVariant),
    );
    properties.add(ColorProperty('shadow', shadow, defaultValue: defaultScheme.shadow));
    properties.add(ColorProperty('scrim', scrim, defaultValue: defaultScheme.scrim));
    properties.add(
      ColorProperty('inverseSurface', inverseSurface, defaultValue: defaultScheme.inverseSurface),
    );
    properties.add(
      ColorProperty(
        'onInverseSurface',
        onInverseSurface,
        defaultValue: defaultScheme.onInverseSurface,
      ),
    );
    properties.add(
      ColorProperty('inversePrimary', inversePrimary, defaultValue: defaultScheme.inversePrimary),
    );
    properties.add(
      ColorProperty('surfaceTint', surfaceTint, defaultValue: defaultScheme.surfaceTint),
    );
    // DEPRECATED (newest deprecations at the bottom)
    properties.add(ColorProperty('background', background, defaultValue: defaultScheme.background));
    properties.add(
      ColorProperty('onBackground', onBackground, defaultValue: defaultScheme.onBackground),
    );
    properties.add(
      ColorProperty('surfaceVariant', surfaceVariant, defaultValue: defaultScheme.surfaceVariant),
    );
  }

  /// Generate a [ColorScheme] derived from the given `imageProvider`.
  ///
  /// Material Color Utilities extracts the dominant color from the
  /// supplied [ImageProvider]. Using this color, a [ColorScheme] is generated
  /// with harmonious colors that meet contrast requirements for accessibility.
  ///
  /// If any of the optional color parameters are non-null, they will be
  /// used in place of the generated colors for that field in the resulting
  /// [ColorScheme]. This allows apps to override specific colors for their
  /// needs.
  ///
  /// Given the nature of the algorithm, the most dominant color of the
  /// `imageProvider` may not wind up as one of the [ColorScheme] colors.
  ///
  /// The provided image will be scaled down to a maximum size of 112x112 pixels
  /// during color extraction.
  ///
  /// {@tool dartpad}
  /// This sample shows how to use [ColorScheme.fromImageProvider] to create
  /// content-based dynamic color schemes.
  ///
  /// ** See code in examples/api/lib/material/color_scheme/dynamic_content_color.0.dart **
  /// {@end-tool}
  ///
  /// See also:
  ///
  ///  * [M3 Guidelines: Dynamic color from content](https://m3.material.io/styles/color/dynamic-color/user-generated-color#8af550b9-a19e-4e9f-bb0a-7f611fed5d0f)
  ///  * <https://pub.dev/packages/dynamic_color>, a package to create
  ///    [ColorScheme]s based on a platform's implementation of dynamic color.
  ///  * <https://m3.material.io/styles/color/the-color-system/color-roles>, the
  ///    Material 3 Color system specification.
  ///  * <https://pub.dev/packages/material_color_utilities>, the package
  ///    used to algorithmically determine the dominant color and to generate
  ///    the [ColorScheme].
  static Future<ColorScheme> fromImageProvider({
    required ImageProvider provider,
    Brightness brightness = Brightness.light,
    DynamicSchemeVariant dynamicSchemeVariant = DynamicSchemeVariant.tonalSpot,
    double contrastLevel = 0.0,
    Color? primary,
    Color? onPrimary,
    Color? primaryContainer,
    Color? onPrimaryContainer,
    Color? primaryFixed,
    Color? primaryFixedDim,
    Color? onPrimaryFixed,
    Color? onPrimaryFixedVariant,
    Color? secondary,
    Color? onSecondary,
    Color? secondaryContainer,
    Color? onSecondaryContainer,
    Color? secondaryFixed,
    Color? secondaryFixedDim,
    Color? onSecondaryFixed,
    Color? onSecondaryFixedVariant,
    Color? tertiary,
    Color? onTertiary,
    Color? tertiaryContainer,
    Color? onTertiaryContainer,
    Color? tertiaryFixed,
    Color? tertiaryFixedDim,
    Color? onTertiaryFixed,
    Color? onTertiaryFixedVariant,
    Color? error,
    Color? onError,
    Color? errorContainer,
    Color? onErrorContainer,
    Color? outline,
    Color? outlineVariant,
    Color? surface,
    Color? onSurface,
    Color? surfaceDim,
    Color? surfaceBright,
    Color? surfaceContainerLowest,
    Color? surfaceContainerLow,
    Color? surfaceContainer,
    Color? surfaceContainerHigh,
    Color? surfaceContainerHighest,
    Color? onSurfaceVariant,
    Color? inverseSurface,
    Color? onInverseSurface,
    Color? inversePrimary,
    Color? shadow,
    Color? scrim,
    Color? surfaceTint,
    @Deprecated(
      'Use surface instead. '
      'This feature was deprecated after v3.18.0-0.1.pre.',
    )
    Color? background,
    @Deprecated(
      'Use onSurface instead. '
      'This feature was deprecated after v3.18.0-0.1.pre.',
    )
    Color? onBackground,
    @Deprecated(
      'Use surfaceContainerHighest instead. '
      'This feature was deprecated after v3.18.0-0.1.pre.',
    )
    Color? surfaceVariant,
  }) async {
    // Extract dominant colors from image.
    final QuantizerResult quantizerResult = await _extractColorsFromImageProvider(provider);
    final Map<int, int> colorToCount = quantizerResult.colorToCount.map(
      (int key, int value) => MapEntry<int, int>(_getArgbFromAbgr(key), value),
    );

    // Score colors for color scheme suitability.
    final List<int> scoredResults = Score.score(colorToCount, desired: 1);
    final ui.Color baseColor = Color(scoredResults.first);

    final DynamicScheme scheme = _buildDynamicScheme(
      brightness,
      baseColor,
      dynamicSchemeVariant,
      contrastLevel,
    );

    return ColorScheme(
      primary: primary ?? Color(MaterialDynamicColors.primary.getArgb(scheme)),
      onPrimary: onPrimary ?? Color(MaterialDynamicColors.onPrimary.getArgb(scheme)),
      primaryContainer:
          primaryContainer ?? Color(MaterialDynamicColors.primaryContainer.getArgb(scheme)),
      onPrimaryContainer:
          onPrimaryContainer ?? Color(MaterialDynamicColors.onPrimaryContainer.getArgb(scheme)),
      primaryFixed: primaryFixed ?? Color(MaterialDynamicColors.primaryFixed.getArgb(scheme)),
      primaryFixedDim:
          primaryFixedDim ?? Color(MaterialDynamicColors.primaryFixedDim.getArgb(scheme)),
      onPrimaryFixed: onPrimaryFixed ?? Color(MaterialDynamicColors.onPrimaryFixed.getArgb(scheme)),
      onPrimaryFixedVariant:
          onPrimaryFixedVariant ??
          Color(MaterialDynamicColors.onPrimaryFixedVariant.getArgb(scheme)),
      secondary: secondary ?? Color(MaterialDynamicColors.secondary.getArgb(scheme)),
      onSecondary: onSecondary ?? Color(MaterialDynamicColors.onSecondary.getArgb(scheme)),
      secondaryContainer:
          secondaryContainer ?? Color(MaterialDynamicColors.secondaryContainer.getArgb(scheme)),
      onSecondaryContainer:
          onSecondaryContainer ?? Color(MaterialDynamicColors.onSecondaryContainer.getArgb(scheme)),
      secondaryFixed: secondaryFixed ?? Color(MaterialDynamicColors.secondaryFixed.getArgb(scheme)),
      secondaryFixedDim:
          secondaryFixedDim ?? Color(MaterialDynamicColors.secondaryFixedDim.getArgb(scheme)),
      onSecondaryFixed:
          onSecondaryFixed ?? Color(MaterialDynamicColors.onSecondaryFixed.getArgb(scheme)),
      onSecondaryFixedVariant:
          onSecondaryFixedVariant ??
          Color(MaterialDynamicColors.onSecondaryFixedVariant.getArgb(scheme)),
      tertiary: tertiary ?? Color(MaterialDynamicColors.tertiary.getArgb(scheme)),
      onTertiary: onTertiary ?? Color(MaterialDynamicColors.onTertiary.getArgb(scheme)),
      tertiaryContainer:
          tertiaryContainer ?? Color(MaterialDynamicColors.tertiaryContainer.getArgb(scheme)),
      onTertiaryContainer:
          onTertiaryContainer ?? Color(MaterialDynamicColors.onTertiaryContainer.getArgb(scheme)),
      tertiaryFixed: tertiaryFixed ?? Color(MaterialDynamicColors.tertiaryFixed.getArgb(scheme)),
      tertiaryFixedDim:
          tertiaryFixedDim ?? Color(MaterialDynamicColors.tertiaryFixedDim.getArgb(scheme)),
      onTertiaryFixed:
          onTertiaryFixed ?? Color(MaterialDynamicColors.onTertiaryFixed.getArgb(scheme)),
      onTertiaryFixedVariant:
          onTertiaryFixedVariant ??
          Color(MaterialDynamicColors.onTertiaryFixedVariant.getArgb(scheme)),
      error: error ?? Color(MaterialDynamicColors.error.getArgb(scheme)),
      onError: onError ?? Color(MaterialDynamicColors.onError.getArgb(scheme)),
      errorContainer: errorContainer ?? Color(MaterialDynamicColors.errorContainer.getArgb(scheme)),
      onErrorContainer:
          onErrorContainer ?? Color(MaterialDynamicColors.onErrorContainer.getArgb(scheme)),
      outline: outline ?? Color(MaterialDynamicColors.outline.getArgb(scheme)),
      outlineVariant: outlineVariant ?? Color(MaterialDynamicColors.outlineVariant.getArgb(scheme)),
      surface: surface ?? Color(MaterialDynamicColors.surface.getArgb(scheme)),
      surfaceDim: surfaceDim ?? Color(MaterialDynamicColors.surfaceDim.getArgb(scheme)),
      surfaceBright: surfaceBright ?? Color(MaterialDynamicColors.surfaceBright.getArgb(scheme)),
      surfaceContainerLowest:
          surfaceContainerLowest ??
          Color(MaterialDynamicColors.surfaceContainerLowest.getArgb(scheme)),
      surfaceContainerLow:
          surfaceContainerLow ?? Color(MaterialDynamicColors.surfaceContainerLow.getArgb(scheme)),
      surfaceContainer:
          surfaceContainer ?? Color(MaterialDynamicColors.surfaceContainer.getArgb(scheme)),
      surfaceContainerHigh:
          surfaceContainerHigh ?? Color(MaterialDynamicColors.surfaceContainerHigh.getArgb(scheme)),
      surfaceContainerHighest:
          surfaceContainerHighest ??
          Color(MaterialDynamicColors.surfaceContainerHighest.getArgb(scheme)),
      onSurface: onSurface ?? Color(MaterialDynamicColors.onSurface.getArgb(scheme)),
      onSurfaceVariant:
          onSurfaceVariant ?? Color(MaterialDynamicColors.onSurfaceVariant.getArgb(scheme)),
      inverseSurface: inverseSurface ?? Color(MaterialDynamicColors.inverseSurface.getArgb(scheme)),
      onInverseSurface:
          onInverseSurface ?? Color(MaterialDynamicColors.inverseOnSurface.getArgb(scheme)),
      inversePrimary: inversePrimary ?? Color(MaterialDynamicColors.inversePrimary.getArgb(scheme)),
      shadow: shadow ?? Color(MaterialDynamicColors.shadow.getArgb(scheme)),
      scrim: scrim ?? Color(MaterialDynamicColors.scrim.getArgb(scheme)),
      surfaceTint: surfaceTint ?? Color(MaterialDynamicColors.primary.getArgb(scheme)),
      brightness: brightness,
      // DEPRECATED (newest deprecations at the bottom)
      background: background ?? Color(MaterialDynamicColors.background.getArgb(scheme)),
      onBackground: onBackground ?? Color(MaterialDynamicColors.onBackground.getArgb(scheme)),
      surfaceVariant: surfaceVariant ?? Color(MaterialDynamicColors.surfaceVariant.getArgb(scheme)),
    );
  }

  // ColorScheme.fromImageProvider() utilities.

  // Extracts bytes from an [ImageProvider] and returns a [QuantizerResult]
  // containing the most dominant colors.
  static Future<QuantizerResult> _extractColorsFromImageProvider(
    ImageProvider imageProvider,
  ) async {
    final ui.Image scaledImage = await _imageProviderToScaled(imageProvider);
    final ByteData? imageBytes = await scaledImage.toByteData();

    final QuantizerResult quantizerResult = await QuantizerCelebi().quantize(
      imageBytes!.buffer.asUint32List(),
      128,
      returnInputPixelToClusterPixel: true,
    );
    return quantizerResult;
  }

  // Scale image size down to reduce computation time of color extraction.
  static Future<ui.Image> _imageProviderToScaled(ImageProvider imageProvider) async {
    const double maxDimension = 112.0;
    final ImageStream stream = imageProvider.resolve(
      const ImageConfiguration(size: Size(maxDimension, maxDimension)),
    );
    final Completer<ui.Image> imageCompleter = Completer<ui.Image>();
    late ImageStreamListener listener;
    late ui.Image scaledImage;
    Timer? loadFailureTimeout;

    listener = ImageStreamListener(
      (ImageInfo info, bool sync) async {
        loadFailureTimeout?.cancel();
        stream.removeListener(listener);
        final ui.Image image = info.image;
        final int width = image.width;
        final int height = image.height;
        double paintWidth = width.toDouble();
        double paintHeight = height.toDouble();
        assert(width > 0 && height > 0);

        final bool rescale = width > maxDimension || height > maxDimension;
        if (rescale) {
          paintWidth = (width > height) ? maxDimension : (maxDimension / height) * width;
          paintHeight = (height > width) ? maxDimension : (maxDimension / width) * height;
        }
        final ui.PictureRecorder pictureRecorder = ui.PictureRecorder();
        final Canvas canvas = Canvas(pictureRecorder);
        paintImage(
          canvas: canvas,
          rect: Rect.fromLTRB(0, 0, paintWidth, paintHeight),
          image: image,
          filterQuality: FilterQuality.none,
        );

        final ui.Picture picture = pictureRecorder.endRecording();
        scaledImage = await picture.toImage(paintWidth.toInt(), paintHeight.toInt());
        imageCompleter.complete(info.image);
      },
      onError: (Object exception, StackTrace? stackTrace) {
        stream.removeListener(listener);
        throw Exception('Failed to render image: $exception');
      },
    );

    loadFailureTimeout = Timer(const Duration(seconds: 5), () {
      stream.removeListener(listener);
      imageCompleter.completeError(TimeoutException('Timeout occurred trying to load image'));
    });

    stream.addListener(listener);
    await imageCompleter.future;
    return scaledImage;
  }

  // Converts AABBGGRR color int to AARRGGBB format.
  static int _getArgbFromAbgr(int abgr) {
    const int exceptRMask = 0xFF00FFFF;
    const int onlyRMask = ~exceptRMask;
    const int exceptBMask = 0xFFFFFF00;
    const int onlyBMask = ~exceptBMask;
    final int r = (abgr & onlyRMask) >> 16;
    final int b = abgr & onlyBMask;
    return (abgr & exceptRMask & exceptBMask) | (b << 16) | r;
  }

  static DynamicScheme _buildDynamicScheme(
    Brightness brightness,
    Color seedColor,
    DynamicSchemeVariant schemeVariant,
    double contrastLevel,
  ) {
    assert(
      contrastLevel >= -1.0 && contrastLevel <= 1.0,
      'contrastLevel must be between -1.0 and 1.0 inclusive.',
    );
    final bool isDark = brightness == Brightness.dark;
    final Hct sourceColor = Hct.fromInt(seedColor.value);
    return switch (schemeVariant) {
      DynamicSchemeVariant.tonalSpot => SchemeTonalSpot(
        sourceColorHct: sourceColor,
        isDark: isDark,
        contrastLevel: contrastLevel,
      ),
      DynamicSchemeVariant.fidelity => SchemeFidelity(
        sourceColorHct: sourceColor,
        isDark: isDark,
        contrastLevel: contrastLevel,
      ),
      DynamicSchemeVariant.content => SchemeContent(
        sourceColorHct: sourceColor,
        isDark: isDark,
        contrastLevel: contrastLevel,
      ),
      DynamicSchemeVariant.monochrome => SchemeMonochrome(
        sourceColorHct: sourceColor,
        isDark: isDark,
        contrastLevel: contrastLevel,
      ),
      DynamicSchemeVariant.neutral => SchemeNeutral(
        sourceColorHct: sourceColor,
        isDark: isDark,
        contrastLevel: contrastLevel,
      ),
      DynamicSchemeVariant.vibrant => SchemeVibrant(
        sourceColorHct: sourceColor,
        isDark: isDark,
        contrastLevel: contrastLevel,
      ),
      DynamicSchemeVariant.expressive => SchemeExpressive(
        sourceColorHct: sourceColor,
        isDark: isDark,
        contrastLevel: contrastLevel,
      ),
      DynamicSchemeVariant.rainbow => SchemeRainbow(
        sourceColorHct: sourceColor,
        isDark: isDark,
        contrastLevel: contrastLevel,
      ),
      DynamicSchemeVariant.fruitSalad => SchemeFruitSalad(
        sourceColorHct: sourceColor,
        isDark: isDark,
        contrastLevel: contrastLevel,
      ),
    };
  }

  /// The [ThemeData.colorScheme] of the ambient [Theme].
  ///
  /// Equivalent to `Theme.of(context).colorScheme`.
  static ColorScheme of(BuildContext context) => Theme.of(context).colorScheme;
}


Instructions for the chapter (Generate content in English unless specified otherwise):
- Start with a clear heading (e.g., `# Chapter 7: DynamicSchemeVariant
`). Use the provided concept name.

- If this is not the first chapter, begin with a brief transition from the previous chapter, referencing it with a proper Markdown link using its name.

- Begin with a high-level motivation explaining what problem this abstraction solves. Start with a central use case as a concrete example. The whole chapter should guide the reader to understand how to solve this use case. Make it very minimal and friendly to beginners.

- If the abstraction is complex, break it down into key concepts. Explain each concept one-by-one in a very beginner-friendly way.

- Explain how to use this abstraction to solve the use case. Give example inputs and outputs for code snippets (if the output isn't values, describe at a high level what will happen).

- Each code block should be BELOW 10 lines! If longer code blocks are needed, break them down into smaller pieces and walk through them one-by-one. Aggresively simplify the code to make it minimal. Use comments to skip non-important implementation details. Each code block should have a beginner friendly explanation right after it.

- Describe the internal implementation to help understand what's under the hood. First provide a non-code or code-light walkthrough on what happens step-by-step when the abstraction is called. It's recommended to use a simple sequenceDiagram with a dummy example - keep it minimal with at most 5 participants to ensure clarity. If participant name has space, use: `participant QP as Query Processing`. .

- Then dive deeper into code for the internal implementation with references to files. Provide example code blocks, but make them similarly simple and beginner-friendly. Explain.

- IMPORTANT: When you need to refer to other core abstractions covered in other chapters, ALWAYS use proper Markdown links like this: [Chapter Title](filename.md). Use the Complete Tutorial Structure above to find the correct filename and the chapter title. Translate the surrounding text.

- Use mermaid diagrams to illustrate complex concepts (```mermaid``` format). .

- Heavily use analogies and examples throughout to help beginners understand.

- End the chapter with a brief conclusion that summarizes what was learned and provides a transition to the next chapter. If there is a next chapter, use a proper Markdown link: [Next Chapter Title](next_chapter_filename).

- Ensure the tone is welcoming and easy for a newcomer to understand.

- Output *only* the Markdown content for this chapter.

Now, directly provide a super beginner-friendly Markdown output (DON'T need ```markdown``` tags):

2025-05-28 18:23:15,622 - INFO - RESPONSE: # Chapter 7: DynamicSchemeVariant

Welcome back! In our journey through Flutter theming, we've learned how [Theme](01_theme_.md) applies styles, [ThemeData](02_themedata_.md) holds the master blueprint, [ColorScheme](03_colorscheme_.md) organizes our colors neatly, [ThemeExtension](04_themeextension_.md) lets us add custom styling, [VisualDensity](05_visualdensity_.md) adjusts spacing, and [MaterialTapTargetSize](06_materialtaptargetsize_.md) makes interactive elements easier to tap.

In this chapter, we're going to explore `DynamicSchemeVariant`, a concept that adds another layer of flexibility when automatically generating color schemes using Material Design 3's features, specifically with [ColorScheme.fromSeed](03_colorscheme_.md).

### What Problem Does `DynamicSchemeVariant` Solve?

In Chapter 3, we saw how powerful [ColorScheme.fromSeed](03_colorscheme_.md) is. You give it ONE color (the "seed color"), and it magically generates a whole [ColorScheme](03_colorscheme_.md) with harmonious colors for all the different roles (primary, secondary, surface, etc.). This is fantastic because it ensures consistency and accessibility.

But sometimes, you might want a little more control over the *style* or *mood* of the generated color scheme, even if you're using the same seed color. Maybe you want the colors generated from your blue seed to feel bright and energetic, or maybe you want them to feel more muted and calm, or even grayscale. Just giving one seed color doesn't tell the generation process what kind of feeling you're going for.

`DynamicSchemeVariant` solves this by providing different "recipes" or "filters" for the color generation process. You pick a seed color, and then you choose a `DynamicSchemeVariant` to influence *how* the rest of the colors are generated from that seed. It's like telling the color generator, "Use this blue color, but make the resulting palette feel 'vibrant'," or "Use this green, but make the palette feel 'monochrome'."

Think of it as having different art filters you can apply to a photo taken with one main color. The photo is the same (like your seed color), but applying a "vibrant" filter versus a "monochrome" filter gives you a completely different visual result, even though they started from the same base.

### What is `DynamicSchemeVariant`?

`DynamicSchemeVariant` is an **enum**. Like `MaterialTapTargetSize` which we saw in Chapter 6, an enum is just a predefined list of options you can choose from. These options represent different algorithms or approaches for generating a [ColorScheme](03_colorscheme_.md) from a seed color.

Here are some of the common `DynamicSchemeVariant` options you can use with `ColorScheme.fromSeed`:

*   `DynamicSchemeVariant.tonalSpot`: This is the **default**. It creates classic Material Design 3 schemes, often using pastel palettes with moderate color intensity (chroma).
*   `DynamicSchemeVariant.vibrant`: This variant aims to create palettes with higher color intensity (chroma), making the generated colors look more vivid and energetic.
*   `DynamicSchemeVariant.monochrome`: This variant generates a grayscale palette, removing most color from the resulting scheme while still maintaining contrast and accessibility based on tones of gray.
*   `DynamicSchemeVariant.fidelity`: This variant tries to keep the generated colors closer to the actual hue of the seed color, even if the seed color has a very high chroma (brightness). The default `tonalSpot` might shift the hues slightly for balance.
*   `DynamicSchemeVariant.neutral`: Generates schemes that are close to grayscale, but with a faint hint of color (chroma).
*   There are other variants like `expressive`, `content`, `rainbow`, and `fruitSalad` that offer more unique and experimental color generations.

`DynamicSchemeVariant` is **not** a property of `ThemeData` or [ColorScheme](03_colorscheme_.md) itself after the scheme is created. It's a parameter you provide *when* you use the `ColorScheme.fromSeed` factory constructor to *generate* the scheme.

### How to Use `DynamicSchemeVariant`

You provide the `dynamicSchemeVariant` parameter when calling `ColorScheme.fromSeed`.

Here's how you would generate color schemes from the *same* seed color (`Colors.blue`) but with different `DynamicSchemeVariant`s:

```dart
import 'package:flutter/material.dart';

void main() {
  runApp(const MyApp());
}

class MyApp extends StatelessWidget {
  const MyApp({super.key});

  @override
  Widget build(BuildContext context) {
    // Same seed color
    const Color seedColor = Colors.blue;

    // --- Generate different schemes using the same seed color ---

    // Default scheme (tonalSpot)
    final ColorScheme defaultScheme = ColorScheme.fromSeed(
      seedColor: seedColor,
      brightness: Brightness.light,
      dynamicSchemeVariant: DynamicSchemeVariant.tonalSpot, // This is the default anyway
    );

    // Vibrant scheme
    final ColorScheme vibrantScheme = ColorScheme.fromSeed(
      seedColor: seedColor,
      brightness: Brightness.light,
      dynamicSchemeVariant: DynamicSchemeVariant.vibrant, // Using the vibrant variant
    );

    // Monochrome scheme
    final ColorScheme monochromeScheme = ColorScheme.fromSeed(
      seedColor: seedColor,
      brightness: Brightness.light,
      dynamicSchemeVariant: DynamicSchemeVariant.monochrome, // Using the monochrome variant
    );

    // You would choose *one* of these schemes for your MaterialApp's theme
    return MaterialApp(
      title: 'Dynamic Scheme Variant Demo',
       theme: ThemeData(
        colorScheme: defaultScheme, // Try changing this to vibrantScheme or monochromeScheme!
        useMaterial3: true,
      ),
      home: const HomeScreen(),
    );
  }
}

class HomeScreen extends StatelessWidget {
  const HomeScreen({super.key});

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        title: const Text('Dynamic Scheme Variant Demo'),
      ),
      body: Center(
        child: Column(
          mainAxisAlignment: MainAxisAlignment.center,
          children: [
            Text(
              'Text using primary color',
              style: TextStyle(color: Theme.of(context).colorScheme.primary),
            ),
            const SizedBox(height: 20),
            ElevatedButton(
              onPressed: () {},
              child: const Text('Button'),
            ),
            const SizedBox(height: 20),
            FloatingActionButton(
              onPressed: () {},
              child: const Icon(Icons.add),
            ),
          ],
        ),
      ),
    );
  }
}
```

In this example:

1.  We start with the same `seedColor` (`Colors.blue`).
2.  We create three `ColorScheme` objects using `ColorScheme.fromSeed`, but each time, we set the `dynamicSchemeVariant` to a different value (`tonalSpot`, `vibrant`, `monochrome`).
3.  We then use `defaultScheme` for the `MaterialApp`'s `theme`.

Run this code. You'll see the app themed with the colors generated by `tonalSpot` from the blue seed. Now, change the `theme` property in `MaterialApp` to use `vibrantScheme` and re-run. You'll notice the colors derived from the blue seed are much more intense! Finally, change it to `monochromeScheme` and see how the app becomes grayscale. The seed color was the same, but the `DynamicSchemeVariant` changed the entire feel of the generated palette.

This allows you to keep a core brand color (your seed) but easily create variations of your theme for different purposes or user preferences simply by changing the `DynamicSchemeVariant`.

### Under the Hood: How Variants Influence Generation

As we touched upon in Chapter 3, `ColorScheme.fromSeed` uses the `material_color_utilities` library. When you specify a `dynamicSchemeVariant`, you are essentially telling `ColorScheme.fromSeed` to use a *different algorithm* or *scheme class* from that library to generate the color palettes and map them to the [ColorScheme](03_colorscheme_.md) roles.

Here's a very simplified idea of how the variant parameter affects the process:

```mermaid
sequenceDiagram
    participant App as Your App Code
    participant CSSeed as ColorScheme.fromSeed
    participant MCU as material_color_utilities
    participant SchemeVariant Algo as Specific Scheme Algorithm (e.g. SchemeVibrant)
    participant CS as ColorScheme Object

    App->>CSSeed: Call ColorScheme.fromSeed(seedColor:..., dynamicSchemeVariant:...)
    CSSeed->>MCU: Pass seed color, brightness, AND dynamicSchemeVariant
    MCU->>MCU: Look up the algorithm/class corresponding to the selected variant
    MCU->>SchemeVariant Algo: Instantiate the chosen algorithm passing the seed color, brightness, etc.
    SchemeVariant Algo->>SchemeVariant Algo: Generate tonal palettes based on its specific logic and the seed
    SchemeVariant Algo-->>MCU: Return calculated colors for each role
    MCU->>CS: Create new ColorScheme object with calculated colors
    MCU-->>CSSeed: Return the new ColorScheme object
    CSSeed-->>App: Return the new ColorScheme object
```

This diagram shows that the `dynamicSchemeVariant` acts as a switch, determining which specific color generation logic within `material_color_utilities` is used to process the seed color and produce the final `ColorScheme`. Each variant's algorithm has different rules for how it selects and modifies colors from the tonal palettes derived from the seed.

Looking back at the `_buildDynamicScheme` method from the `ColorScheme` code snippet provided in the context:

```dart
static DynamicScheme _buildDynamicScheme(
  Brightness brightness,
  Color seedColor,
  DynamicSchemeVariant schemeVariant, // The variant parameter we pass!
  double contrastLevel,
) {
  final bool isDark = brightness == Brightness.dark;
  final Hct sourceColor = Hct.fromInt(seedColor.value);
  return switch (schemeVariant) { // Here's the crucial part: it switches based on variant!
    DynamicSchemeVariant.tonalSpot => SchemeTonalSpot( // Uses SchemeTonalSpot for tonalSpot
      sourceColorHct: sourceColor,
      isDark: isDark,
      contrastLevel: contrastLevel,
    ),
    DynamicSchemeVariant.fidelity => SchemeFidelity( // Uses SchemeFidelity for fidelity
      sourceColorHct: sourceColor,
      isDark: isDark,
      contrastLevel: contrastLevel,
    ),
    // ... other variants like monochrome, vibrant, etc.
  };
}
```

This code confirms that inside `ColorScheme.fromSeed`, the `dynamicSchemeVariant` parameter is used in a `switch` statement to instantiate and use the correct `DynamicScheme` subclass (like `SchemeTonalSpot`, `SchemeFidelity`, `SchemeMonochrome`, etc.) from the `material_color_utilities` library (`MaterialDynamicColors` comes from there). Each of these scheme subclasses has its own logic for generating the colors based on the seed.

### Conclusion

`DynamicSchemeVariant` is a powerful enum that gives you control over the style of the [ColorScheme](03_colorscheme_.md) generated by `ColorScheme.fromSeed`. By choosing different variants like `vibrant`, `monochrome`, or `fidelity`, you can create distinct visual moods for your app while maintaining a consistent color generation source (your seed color). It's an advanced tool for fine-tuning your color palette using the capabilities of Material Design 3.

With this chapter, you've completed your introduction to key theming concepts in Flutter! You now understand how themes work, how `ThemeData` acts as the blueprint, how `ColorScheme` organizes colors, how to extend themes with `ThemeExtension`, and how to control layout details with `VisualDensity` and `MaterialTapTargetSize`, and finally, influence color generation styles with `DynamicSchemeVariant`.

This knowledge provides a strong foundation for building visually consistent and well-styled Flutter applications!
