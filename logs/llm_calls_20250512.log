2025-05-12 13:26:08,086 - INFO - PROMPT: 
For the project `lib`:

Codebase Context:
--- File Index 0: state_manager.dart ---
/// Get State Manager is a light, modern and powerful state manager to Flutter
library;

export 'get_core/get_core.dart';
export 'get_rx/get_rx.dart';
export 'get_state_manager/get_state_manager.dart';


--- File Index 1: get_state_manager/get_state_manager.dart ---
library;

export 'src/rx_flutter/rx_getx_widget.dart';
export 'src/rx_flutter/rx_notifier.dart';
export 'src/rx_flutter/rx_obx_widget.dart';
export 'src/rx_flutter/rx_ticket_provider_mixin.dart';
export 'src/simple/get_controllers.dart';
export 'src/simple/get_responsive.dart';
export 'src/simple/get_state.dart';
export 'src/simple/get_view.dart';
export 'src/simple/simple_builder.dart';


--- File Index 2: get_state_manager/src/simple/list_notifier.dart ---
import 'dart:collection';

import 'package:flutter/foundation.dart';

// This callback remove the listener on addListener function
typedef Disposer = void Function();

// replacing StateSetter, return if the Widget is mounted for extra validation.
// if it brings overhead the extra call,
typedef GetStateUpdate = void Function();

class ListNotifier extends Listenable
    with ListNotifierSingleMixin, ListNotifierGroupMixin {}

/// A Notifier with single listeners
class ListNotifierSingle = ListNotifier with ListNotifierSingleMixin;

/// A notifier with group of listeners identified by id
class ListNotifierGroup = ListNotifier with ListNotifierGroupMixin;

/// This mixin add to Listenable the addListener, removerListener and
/// containsListener implementation
mixin ListNotifierSingleMixin on Listenable {
  List<GetStateUpdate>? _updaters = <GetStateUpdate>[];

  // final int _version = 0;
  // final int _microtaskVersion = 0;

  @override
  Disposer addListener(GetStateUpdate listener) {
    assert(_debugAssertNotDisposed());
    _updaters!.add(listener);
    return () => _updaters!.remove(listener);
  }

  bool containsListener(GetStateUpdate listener) {
    return _updaters?.contains(listener) ?? false;
  }

  @override
  void removeListener(VoidCallback listener) {
    assert(_debugAssertNotDisposed());
    _updaters!.remove(listener);
  }

  @protected
  void refresh() {
    assert(_debugAssertNotDisposed());
    _notifyUpdate();
  }

  @protected
  void reportRead() {
    Notifier.instance.read(this);
  }

  @protected
  void reportAdd(VoidCallback disposer) {
    Notifier.instance.add(disposer);
  }

  void _notifyUpdate() {
    // if (_microtaskVersion == _version) {
    //   _microtaskVersion++;
    //   scheduleMicrotask(() {
    //     _version++;
    //     _microtaskVersion = _version;
    final list = _updaters?.toList() ?? [];

    for (var element in list) {
      element();
    }
    //   });
    // }
  }

  bool get isDisposed => _updaters == null;

  bool _debugAssertNotDisposed() {
    assert(() {
      if (isDisposed) {
        throw FlutterError('''A $runtimeType was used after being disposed.\n
'Once you have called dispose() on a $runtimeType, it can no longer be used.''');
      }
      return true;
    }());
    return true;
  }

  int get listenersLength {
    assert(_debugAssertNotDisposed());
    return _updaters!.length;
  }

  @mustCallSuper
  void dispose() {
    assert(_debugAssertNotDisposed());
    _updaters = null;
  }
}

mixin ListNotifierGroupMixin on Listenable {
  HashMap<Object?, ListNotifierSingleMixin>? _updatersGroupIds =
      HashMap<Object?, ListNotifierSingleMixin>();

  void _notifyGroupUpdate(Object id) {
    if (_updatersGroupIds!.containsKey(id)) {
      _updatersGroupIds![id]!._notifyUpdate();
    }
  }

  @protected
  void notifyGroupChildrens(Object id) {
    assert(_debugAssertNotDisposed());
    Notifier.instance.read(_updatersGroupIds![id]!);
  }

  bool containsId(Object id) {
    return _updatersGroupIds?.containsKey(id) ?? false;
  }

  @protected
  void refreshGroup(Object id) {
    assert(_debugAssertNotDisposed());
    _notifyGroupUpdate(id);
  }

  bool _debugAssertNotDisposed() {
    assert(() {
      if (_updatersGroupIds == null) {
        throw FlutterError('''A $runtimeType was used after being disposed.\n
'Once you have called dispose() on a $runtimeType, it can no longer be used.''');
      }
      return true;
    }());
    return true;
  }

  void removeListenerId(Object id, VoidCallback listener) {
    assert(_debugAssertNotDisposed());
    if (_updatersGroupIds!.containsKey(id)) {
      _updatersGroupIds![id]!.removeListener(listener);
    }
  }

  @mustCallSuper
  void dispose() {
    assert(_debugAssertNotDisposed());
    _updatersGroupIds?.forEach((key, value) => value.dispose());
    _updatersGroupIds = null;
  }

  Disposer addListenerId(Object? key, GetStateUpdate listener) {
    _updatersGroupIds![key] ??= ListNotifierSingle();
    return _updatersGroupIds![key]!.addListener(listener);
  }

  /// To dispose an [id] from future updates(), this ids are registered
  /// by `GetBuilder()` or similar, so is a way to unlink the state change with
  /// the Widget from the Controller.
  void disposeId(Object id) {
    _updatersGroupIds?[id]?.dispose();
    _updatersGroupIds!.remove(id);
  }
}

class Notifier {
  Notifier._();

  static Notifier? _instance;
  static Notifier get instance => _instance ??= Notifier._();

  NotifyData? _notifyData;

  void add(VoidCallback listener) {
    _notifyData?.disposers.add(listener);
  }

  void read(ListNotifierSingleMixin updaters) {
    final listener = _notifyData?.updater;
    if (listener != null && !updaters.containsListener(listener)) {
      updaters.addListener(listener);
      add(() => updaters.removeListener(listener));
    }
  }

  T append<T>(NotifyData data, T Function() builder) {
    _notifyData = data;
    final result = builder();
    if (data.disposers.isEmpty && data.throwException) {
      throw const ObxError();
    }
    _notifyData = null;
    return result;
  }
}

class NotifyData {
  const NotifyData(
      {required this.updater,
      required this.disposers,
      this.throwException = true});
  final GetStateUpdate updater;
  final List<VoidCallback> disposers;
  final bool throwException;
}

class ObxError {
  const ObxError();
  @override
  String toString() {
    return """
      [Get] the improper use of a GetX has been detected. 
      You should only use GetX or Obx for the specific widget that will be updated.
      If you are seeing this error, you probably did not insert any observable variables into GetX/Obx 
      or insert them outside the scope that GetX considers suitable for an update 
      (example: GetX => HeavyWidget => variableObservable).
      If you need to update a parent widget and a child widget, wrap each one in an Obx/GetX.
      """;
  }
}


--- File Index 3: get_state_manager/src/simple/get_state.dart ---
// ignore_for_file: overridden_fields

import 'dart:async';

import 'package:flutter/material.dart';

import '../../../instance_manager.dart';
import '../../get_state_manager.dart';
import 'list_notifier.dart';

typedef InitBuilder<T> = T Function();

typedef GetControllerBuilder<T extends GetLifeCycleMixin> = Widget Function(
    T controller);

extension WatchExt on BuildContext {
  T listen<T>() {
    return Bind.of(this, rebuild: true);
  }
}

extension ReadExt on BuildContext {
  T get<T>() {
    return Bind.of(this);
  }
}

// extension FilterExt on BuildContext {
//   T filter<T extends GetxController>(Object Function(T value)? filter) {
//     return Bind.of(this, filter: filter, rebuild: true);
//   }
// }

class GetBuilder<T extends GetxController> extends StatelessWidget {
  final GetControllerBuilder<T> builder;
  final bool global;
  final Object? id;
  final String? tag;
  final bool autoRemove;
  final bool assignId;
  final Object Function(T value)? filter;
  final void Function(BindElement<T> state)? initState,
      dispose,
      didChangeDependencies;
  final void Function(Binder<T> oldWidget, BindElement<T> state)?
      didUpdateWidget;
  final T? init;

  const GetBuilder({
    super.key,
    this.init,
    this.global = true,
    required this.builder,
    this.autoRemove = true,
    this.assignId = false,
    this.initState,
    this.filter,
    this.tag,
    this.dispose,
    this.id,
    this.didChangeDependencies,
    this.didUpdateWidget,
  });

  @override
  Widget build(BuildContext context) {
    return Binder(
      init: init == null ? null : () => init!,
      global: global,
      autoRemove: autoRemove,
      assignId: assignId,
      initState: initState,
      filter: filter,
      tag: tag,
      dispose: dispose,
      id: id,
      lazy: false,
      didChangeDependencies: didChangeDependencies,
      didUpdateWidget: didUpdateWidget,
      child: Builder(builder: (context) {
        final controller = Bind.of<T>(context, rebuild: true);
        return builder(controller);
      }),
    );
    // return widget.builder(controller!);
  }
}

abstract class Bind<T> extends StatelessWidget {
  const Bind({
    super.key,
    required this.child,
    this.init,
    this.global = true,
    this.autoRemove = true,
    this.assignId = false,
    this.initState,
    this.filter,
    this.tag,
    this.dispose,
    this.id,
    this.didChangeDependencies,
    this.didUpdateWidget,
  });

  final InitBuilder<T>? init;

  final bool global;
  final Object? id;
  final String? tag;
  final bool autoRemove;
  final bool assignId;
  final Object Function(T value)? filter;
  final void Function(BindElement<T> state)? initState,
      dispose,
      didChangeDependencies;
  final void Function(Binder<T> oldWidget, BindElement<T> state)?
      didUpdateWidget;

  final Widget? child;

  static Bind put<S>(
    S dependency, {
    String? tag,
    bool permanent = false,
  }) {
    Get.put<S>(dependency, tag: tag, permanent: permanent);
    return _FactoryBind<S>(
      autoRemove: permanent,
      assignId: true,
      tag: tag,
    );
  }

  static bool fenixMode = false;

  static Bind lazyPut<S>(
    InstanceBuilderCallback<S> builder, {
    String? tag,
    bool? fenix,
    // VoidCallback? onInit,
    VoidCallback? onClose,
  }) {
    Get.lazyPut<S>(builder, tag: tag, fenix: fenix ?? fenixMode);
    return _FactoryBind<S>(
      tag: tag,
      // initState: (_) {
      //   onInit?.call();
      // },
      dispose: (_) {
        onClose?.call();
      },
    );
  }

  static Bind create<S>(InstanceCreateBuilderCallback<S> builder,
      {String? tag, bool permanent = true}) {
    return _FactoryBind<S>(
      create: builder,
      tag: tag,
      global: false,
    );
  }

  static Bind spawn<S>(InstanceBuilderCallback<S> builder,
      {String? tag, bool permanent = true}) {
    Get.spawn<S>(builder, tag: tag, permanent: permanent);
    return _FactoryBind<S>(
      tag: tag,
      global: false,
      autoRemove: permanent,
    );
  }

  static S find<S>({String? tag}) => Get.find<S>(tag: tag);

  static Future<bool> delete<S>({String? tag, bool force = false}) async =>
      Get.delete<S>(tag: tag, force: force);

  static Future<void> deleteAll({bool force = false}) async =>
      Get.deleteAll(force: force);

  static void reloadAll({bool force = false}) => Get.reloadAll(force: force);

  static void reload<S>({String? tag, String? key, bool force = false}) =>
      Get.reload<S>(tag: tag, key: key, force: force);

  static bool isRegistered<S>({String? tag}) => Get.isRegistered<S>(tag: tag);

  static bool isPrepared<S>({String? tag}) => Get.isPrepared<S>(tag: tag);

  static void replace<P>(P child, {String? tag}) {
    final info = Get.getInstanceInfo<P>(tag: tag);
    final permanent = (info.isPermanent ?? false);
    delete<P>(tag: tag, force: permanent);
    Get.put(child, tag: tag, permanent: permanent);
  }

  static void lazyReplace<P>(InstanceBuilderCallback<P> builder,
      {String? tag, bool? fenix}) {
    final info = Get.getInstanceInfo<P>(tag: tag);
    final permanent = (info.isPermanent ?? false);
    delete<P>(tag: tag, force: permanent);
    Get.lazyPut(builder, tag: tag, fenix: fenix ?? permanent);
  }

  factory Bind.builder({
    Widget? child,
    InitBuilder<T>? init,
    InstanceCreateBuilderCallback<T>? create,
    bool global = true,
    bool autoRemove = true,
    bool assignId = false,
    Object Function(T value)? filter,
    String? tag,
    Object? id,
    void Function(BindElement<T> state)? initState,
    void Function(BindElement<T> state)? dispose,
    void Function(BindElement<T> state)? didChangeDependencies,
    void Function(Binder<T> oldWidget, BindElement<T> state)? didUpdateWidget,
  }) =>
      _FactoryBind<T>(
        // key: key,
        init: init,
        create: create,
        global: global,
        autoRemove: autoRemove,
        assignId: assignId,
        initState: initState,
        filter: filter,
        tag: tag,
        dispose: dispose,
        id: id,
        didChangeDependencies: didChangeDependencies,
        didUpdateWidget: didUpdateWidget,
        child: child,
      );

  static T of<T>(
    BuildContext context, {
    bool rebuild = false,
    // Object Function(T value)? filter,
  }) {
    final inheritedElement =
        context.getElementForInheritedWidgetOfExactType<Binder<T>>()
            as BindElement<T>?;

    if (inheritedElement == null) {
      throw BindError(controller: '$T', tag: null);
    }

    if (rebuild) {
      // var newFilter = filter?.call(inheritedElement.controller!);
      // if (newFilter != null) {
      //  context.dependOnInheritedElement(inheritedElement, aspect: newFilter);
      // } else {
      context.dependOnInheritedElement(inheritedElement);
      // }
    }

    final controller = inheritedElement.controller;

    return controller;
  }

  @factory
  Bind<T> _copyWithChild(Widget child);
}

class _FactoryBind<T> extends Bind<T> {
  @override
  final InitBuilder<T>? init;

  final InstanceCreateBuilderCallback<T>? create;

  @override
  final bool global;
  @override
  final Object? id;
  @override
  final String? tag;
  @override
  final bool autoRemove;
  @override
  final bool assignId;
  @override
  final Object Function(T value)? filter;

  @override
  final void Function(BindElement<T> state)? initState,
      dispose,
      didChangeDependencies;
  @override
  final void Function(Binder<T> oldWidget, BindElement<T> state)?
      didUpdateWidget;

  @override
  final Widget? child;

  const _FactoryBind({
    super.key,
    this.child,
    this.init,
    this.create,
    this.global = true,
    this.autoRemove = true,
    this.assignId = false,
    this.initState,
    this.filter,
    this.tag,
    this.dispose,
    this.id,
    this.didChangeDependencies,
    this.didUpdateWidget,
  }) : super(child: child);

  @override
  Bind<T> _copyWithChild(Widget child) {
    return Bind<T>.builder(
      init: init,
      create: create,
      global: global,
      autoRemove: autoRemove,
      assignId: assignId,
      initState: initState,
      filter: filter,
      tag: tag,
      dispose: dispose,
      id: id,
      didChangeDependencies: didChangeDependencies,
      didUpdateWidget: didUpdateWidget,
      child: child,
    );
  }

  @override
  Widget build(BuildContext context) {
    return Binder<T>(
      create: create,
      global: global,
      autoRemove: autoRemove,
      assignId: assignId,
      initState: initState,
      filter: filter,
      tag: tag,
      dispose: dispose,
      id: id,
      didChangeDependencies: didChangeDependencies,
      didUpdateWidget: didUpdateWidget,
      child: child!,
    );
  }
}

class Binds extends StatelessWidget {
  final List<Bind<dynamic>> binds;
  final Widget child;

  Binds({
    super.key,
    required this.binds,
    required this.child,
  }) : assert(binds.isNotEmpty);

  @override
  Widget build(BuildContext context) =>
      binds.reversed.fold(child, (widget, e) => e._copyWithChild(widget));
}

class Binder<T> extends InheritedWidget {
  /// Create an inherited widget that updates its dependents when [controller]
  /// sends notifications.
  ///
  /// The [child] argument is required
  const Binder({
    super.key,
    required super.child,
    this.init,
    this.global = true,
    this.autoRemove = true,
    this.assignId = false,
    this.lazy = true,
    this.initState,
    this.filter,
    this.tag,
    this.dispose,
    this.id,
    this.didChangeDependencies,
    this.didUpdateWidget,
    this.create,
  });

  final InitBuilder<T>? init;
  final InstanceCreateBuilderCallback? create;
  final bool global;
  final Object? id;
  final String? tag;
  final bool lazy;
  final bool autoRemove;
  final bool assignId;
  final Object Function(T value)? filter;
  final void Function(BindElement<T> state)? initState,
      dispose,
      didChangeDependencies;
  final void Function(Binder<T> oldWidget, BindElement<T> state)?
      didUpdateWidget;

  @override
  bool updateShouldNotify(Binder<T> oldWidget) {
    return oldWidget.id != id ||
        oldWidget.global != global ||
        oldWidget.autoRemove != autoRemove ||
        oldWidget.assignId != assignId;
  }

  @override
  InheritedElement createElement() => BindElement<T>(this);
}

/// The BindElement is responsible for injecting dependencies into the widget
/// tree so that they can be observed
class BindElement<T> extends InheritedElement {
  BindElement(Binder<T> super.widget) {
    initState();
  }

  final disposers = <Disposer>[];

  InitBuilder<T>? _controllerBuilder;

  T? _controller;

  T get controller {
    if (_controller == null) {
      _controller = _controllerBuilder?.call();
      _subscribeToController();
      if (_controller == null) {
        throw BindError(controller: T, tag: widget.tag);
      }
      return _controller!;
    } else {
      return _controller!;
    }
  }

  bool? _isCreator = false;
  bool? _needStart = false;
  bool _wasStarted = false;
  VoidCallback? _remove;
  Object? _filter;

  void initState() {
    widget.initState?.call(this);

    var isRegistered = Get.isRegistered<T>(tag: widget.tag);

    if (widget.global) {
      if (isRegistered) {
        if (Get.isPrepared<T>(tag: widget.tag)) {
          _isCreator = true;
        } else {
          _isCreator = false;
        }

        _controllerBuilder = () => Get.find<T>(tag: widget.tag);
      } else {
        _controllerBuilder =
            () => (widget.create?.call(this) ?? widget.init?.call());
        _isCreator = true;
        if (widget.lazy) {
          Get.lazyPut<T>(_controllerBuilder!, tag: widget.tag);
        } else {
          Get.put<T>(_controllerBuilder!(), tag: widget.tag);
        }
      }
    } else {
      if (widget.create != null) {
        _controllerBuilder = () => widget.create!.call(this);
        Get.spawn<T>(_controllerBuilder!, tag: widget.tag, permanent: false);
      } else {
        _controllerBuilder = widget.init;
      }
      _controllerBuilder =
          (widget.create != null ? () => widget.create!.call(this) : null) ??
              widget.init;
      _isCreator = true;
      _needStart = true;
    }
  }

  /// Register to listen Controller's events.
  /// It gets a reference to the remove() callback, to delete the
  /// setState "link" from the Controller.
  void _subscribeToController() {
    if (widget.filter != null) {
      _filter = widget.filter!(_controller as T);
    }
    final filter = _filter != null ? _filterUpdate : getUpdate;
    final localController = _controller;

    if (_needStart == true && localController is GetLifeCycleMixin) {
      localController.onStart();
      _needStart = false;
      _wasStarted = true;
    }

    if (localController is GetxController) {
      _remove?.call();
      _remove = (widget.id == null)
          ? localController.addListener(filter)
          : localController.addListenerId(widget.id, filter);
    } else if (localController is Listenable) {
      _remove?.call();
      localController.addListener(filter);
      _remove = () => localController.removeListener(filter);
    } else if (localController is StreamController) {
      _remove?.call();
      final stream = localController.stream.listen((_) => filter());
      _remove = () => stream.cancel();
    }
  }

  void _filterUpdate() {
    var newFilter = widget.filter!(_controller as T);
    if (newFilter != _filter) {
      _filter = newFilter;
      getUpdate();
    }
  }

  void dispose() {
    widget.dispose?.call(this);
    if (_isCreator! || widget.assignId) {
      if (widget.autoRemove && Get.isRegistered<T>(tag: widget.tag)) {
        Get.delete<T>(tag: widget.tag);
      }
    }

    for (final disposer in disposers) {
      disposer();
    }

    disposers.clear();

    _remove?.call();
    _controller = null;
    _isCreator = null;
    _remove = null;
    _filter = null;
    _needStart = null;
    _controllerBuilder = null;
    _controller = null;
  }

  @override
  Binder<T> get widget => super.widget as Binder<T>;

  var _dirty = false;

  @override
  void update(Binder<T> newWidget) {
    final oldNotifier = widget.id;
    final newNotifier = newWidget.id;
    if (oldNotifier != newNotifier && _wasStarted) {
      _subscribeToController();
    }
    widget.didUpdateWidget?.call(widget, this);
    super.update(newWidget);
  }

  @override
  void didChangeDependencies() {
    super.didChangeDependencies();
    widget.didChangeDependencies?.call(this);
  }

  @override
  Widget build() {
    if (_dirty) {
      notifyClients(widget);
    }
    // return Notifier.instance.notifyAppend(
    //   NotifyData(
    //       disposers: disposers, updater: getUpdate, throwException: false),
    return super.build();
    //);
  }

  void getUpdate() {
    _dirty = true;
    markNeedsBuild();
  }

  @override
  void notifyClients(Binder<T> oldWidget) {
    super.notifyClients(oldWidget);
    _dirty = false;
  }

  @override
  void unmount() {
    dispose();
    super.unmount();
  }
}

class BindError<T> extends Error {
  /// The type of the class the user tried to retrieve
  final T controller;
  final String? tag;

  /// Creates a [BindError]
  BindError({required this.controller, required this.tag});

  @override
  String toString() {
    if (controller == 'dynamic') {
      return '''Error: please specify type [<T>] when calling context.listen<T>() or context.find<T>() method.''';
    }

    return '''Error: No Bind<$controller>  ancestor found. To fix this, please add a Bind<$controller> widget ancestor to the current context.
      ''';
  }
}

/// [Binding] should be extended.
/// When using `GetMaterialApp`, all `GetPage`s and navigation
/// methods (like Get.to()) have a `binding` property that takes an
/// instance of Bindings to manage the
/// dependencies() (via Get.put()) for the Route you are opening.
// ignore: one_member_abstracts
abstract class Binding extends BindingsInterface<List<Bind>> {}


--- File Index 4: get_state_manager/src/simple/get_controllers.dart ---
// ignore: prefer_mixin
import 'package:flutter/widgets.dart';

import '../../../instance_manager.dart';
import '../rx_flutter/rx_notifier.dart';
import 'list_notifier.dart';

// ignore: prefer_mixin
abstract class GetxController extends ListNotifier with GetLifeCycleMixin {
  /// Rebuilds `GetBuilder` each time you call `update()`;
  /// Can take a List of [ids], that will only update the matching
  /// `GetBuilder( id: )`,
  /// [ids] can be reused among `GetBuilders` like group tags.
  /// The update will only notify the Widgets, if [condition] is true.
  void update([List<Object>? ids, bool condition = true]) {
    if (!condition) {
      return;
    }
    if (ids == null) {
      refresh();
    } else {
      for (final id in ids) {
        refreshGroup(id);
      }
    }
  }
}

/// this mixin allow to fetch data when the scroll is at the bottom or on the
/// top
mixin ScrollMixin on GetLifeCycleMixin {
  final ScrollController scroll = ScrollController();

  @override
  void onInit() {
    super.onInit();
    scroll.addListener(_listener);
  }

  bool _canFetchBottom = true;

  bool _canFetchTop = true;

  void _listener() {
    if (scroll.position.atEdge) {
      _checkIfCanLoadMore();
    }
  }

  Future<void> _checkIfCanLoadMore() async {
    if (scroll.position.pixels == 0) {
      if (!_canFetchTop) return;
      _canFetchTop = false;
      await onTopScroll();
      _canFetchTop = true;
    } else {
      if (!_canFetchBottom) return;
      _canFetchBottom = false;
      await onEndScroll();
      _canFetchBottom = true;
    }
  }

  /// this method is called when the scroll is at the bottom
  Future<void> onEndScroll();

  /// this method is called when the scroll is at the top
  Future<void> onTopScroll();

  @override
  void onClose() {
    scroll.removeListener(_listener);
    super.onClose();
  }
}

/// A clean controller to be used with only Rx variables
abstract class RxController with GetLifeCycleMixin {}

/// A recommended way to use Getx with Future fetching
abstract class StateController<T> extends GetxController with StateMixin<T> {}

/// A controller with super lifecycles (including native lifecycles)
/// and StateMixins
abstract class SuperController<T> extends FullLifeCycleController
    with FullLifeCycleMixin, StateMixin<T> {}

/// A controller with super lifecycles (including native lifecycles)
abstract class FullLifeCycleController extends GetxController
    with
        // ignore: prefer_mixin
        WidgetsBindingObserver {}

mixin FullLifeCycleMixin on FullLifeCycleController {
  @mustCallSuper
  @override
  void onInit() {
    super.onInit();
    Engine.instance.addObserver(this);
  }

  @mustCallSuper
  @override
  void onClose() {
    Engine.instance.removeObserver(this);
    super.onClose();
  }

  @mustCallSuper
  @override
  void didChangeAppLifecycleState(AppLifecycleState state) {
    switch (state) {
      case AppLifecycleState.resumed:
        onResumed();
        break;
      case AppLifecycleState.inactive:
        onInactive();
        break;
      case AppLifecycleState.paused:
        onPaused();
        break;
      case AppLifecycleState.detached:
        onDetached();
        break;
      case AppLifecycleState.hidden:
        onHidden();
        break;
    }
  }

  void onResumed() {}
  void onPaused() {}
  void onInactive() {}
  void onDetached() {}
  void onHidden() {}
}


--- File Index 5: get_state_manager/src/simple/mixin_builder.dart ---
import 'package:flutter/material.dart';

import '../rx_flutter/rx_obx_widget.dart';
import 'get_controllers.dart';
import 'get_state.dart';

class MixinBuilder<T extends GetxController> extends StatelessWidget {
  @required
  final Widget Function(T) builder;
  final bool global;
  final String? id;
  final bool autoRemove;
  final void Function(BindElement<T> state)? initState,
      dispose,
      didChangeDependencies;
  final void Function(Binder<T> oldWidget, BindElement<T> state)?
      didUpdateWidget;
  final T? init;

  const MixinBuilder({
    super.key,
    this.init,
    this.global = true,
    required this.builder,
    this.autoRemove = true,
    this.initState,
    this.dispose,
    this.id,
    this.didChangeDependencies,
    this.didUpdateWidget,
  });

  @override
  Widget build(BuildContext context) {
    return GetBuilder<T>(
        init: init,
        global: global,
        autoRemove: autoRemove,
        initState: initState,
        dispose: dispose,
        id: id,
        didChangeDependencies: didChangeDependencies,
        didUpdateWidget: didUpdateWidget,
        builder: (controller) => Obx(() => builder.call(controller)));
  }
}


--- File Index 6: get_state_manager/src/simple/simple_builder.dart ---
import 'dart:async';

import 'package:flutter/widgets.dart';

import 'list_notifier.dart';

typedef ValueBuilderUpdateCallback<T> = void Function(T snapshot);
typedef ValueBuilderBuilder<T> = Widget Function(
    T snapshot, ValueBuilderUpdateCallback<T> updater);

/// Manages a local state like ObxValue, but uses a callback instead of
/// a Rx value.
///
/// Example:
/// ```
///  ValueBuilder<bool>(
///    initialValue: false,
///    builder: (value, update) => Switch(
///    value: value,
///    onChanged: (flag) {
///       update( flag );
///    },),
///    onUpdate: (value) => print("Value updated: $value"),
///  ),
///  ```
class ValueBuilder<T> extends StatefulWidget {
  final T initialValue;
  final ValueBuilderBuilder<T> builder;
  final void Function()? onDispose;
  final void Function(T)? onUpdate;

  const ValueBuilder({
    super.key,
    required this.initialValue,
    this.onDispose,
    this.onUpdate,
    required this.builder,
  });

  @override
  ValueBuilderState<T> createState() => ValueBuilderState<T>();
}

class ValueBuilderState<T> extends State<ValueBuilder<T>> {
  late T value;
  @override
  void initState() {
    value = widget.initialValue;
    super.initState();
  }

  @override
  Widget build(BuildContext context) => widget.builder(value, updater);

  void updater(T newValue) {
    if (widget.onUpdate != null) {
      widget.onUpdate!(newValue);
    }
    setState(() {
      value = newValue;
    });
  }

  @override
  void dispose() {
    super.dispose();
    widget.onDispose?.call();
    if (value is ChangeNotifier) {
      (value as ChangeNotifier?)?.dispose();
    } else if (value is StreamController) {
      (value as StreamController?)?.close();
    }
  }
}

class ObxElement = StatelessElement with StatelessObserverComponent;

// It's a experimental feature
class Observer extends ObxStatelessWidget {
  final WidgetBuilder builder;

  const Observer({super.key, required this.builder});

  @override
  Widget build(BuildContext context) => builder(context);
}

/// A StatelessWidget than can listen reactive changes.
abstract class ObxStatelessWidget extends StatelessWidget {
  /// Initializes [key] for subclasses.
  const ObxStatelessWidget({super.key});
  @override
  StatelessElement createElement() => ObxElement(this);
}

/// a Component that can track changes in a reactive variable
mixin StatelessObserverComponent on StatelessElement {
  List<Disposer>? disposers = <Disposer>[];

  void getUpdate() {
    // if (disposers != null && !dirty) {
    //   markNeedsBuild();
    // }
    if (disposers != null) {
      scheduleMicrotask(markNeedsBuild);
    }
  }

  @override
  Widget build() {
    return Notifier.instance.append(
        NotifyData(disposers: disposers!, updater: getUpdate), super.build);
  }

  @override
  void unmount() {
    super.unmount();
    for (final disposer in disposers!) {
      disposer();
    }
    disposers!.clear();
    disposers = null;
  }
}


--- File Index 7: get_state_manager/src/simple/get_view.dart ---
import 'package:flutter/widgets.dart';

import '../../../instance_manager.dart';
import '../../../utils.dart';
import 'get_state.dart';
import 'get_widget_cache.dart';

/// GetView is a great way of quickly access your Controller
/// without having to call `Get.find<AwesomeController>()` yourself.
///
/// Sample:
/// ```
/// class AwesomeController extends GetxController {
///   final String title = 'My Awesome View';
/// }
///
/// class AwesomeView extends GetView<AwesomeController> {
///   /// if you need you can pass the tag for
///   /// Get.find<AwesomeController>(tag:"myTag");
///   @override
///   final String tag = "myTag";
///
///   AwesomeView({Key key}):super(key:key);
///
///   @override
///   Widget build(BuildContext context) {
///     return Container(
///       padding: EdgeInsets.all(20),
///       child: Text( controller.title ),
///     );
///   }
/// }
///``
abstract class GetView<T> extends StatelessWidget {
  const GetView({super.key});

  final String? tag = null;

  T get controller => Get.find<T>(tag: tag)!;

  @override
  Widget build(BuildContext context);
}

/// GetWidget is a great way of quickly access your individual Controller
/// without having to call `Get.find<AwesomeController>()` yourself.
/// Get save you controller on cache, so, you can to use Get.create() safely
/// GetWidget is perfect to multiples instance of a same controller. Each
/// GetWidget will have your own controller, and will be call events as `onInit`
/// and `onClose` when the controller get in/get out on memory.
abstract class GetWidget<S extends GetLifeCycleMixin> extends GetWidgetCache {
  const GetWidget({super.key});

  @protected
  final String? tag = null;

  S get controller => GetWidget._cache[this] as S;

  // static final _cache = <GetWidget, GetLifeCycleBase>{};

  static final _cache = Expando<GetLifeCycleMixin>();

  @protected
  Widget build(BuildContext context);

  @override
  WidgetCache createWidgetCache() => _GetCache<S>();
}

class _GetCache<S extends GetLifeCycleMixin> extends WidgetCache<GetWidget<S>> {
  S? _controller;
  bool _isCreator = false;
  InstanceInfo? info;
  @override
  void onInit() {
    info = Get.getInstanceInfo<S>(tag: widget!.tag);

    _isCreator = info!.isPrepared && info!.isCreate;

    if (info!.isRegistered) {
      _controller = Get.find<S>(tag: widget!.tag);
    }

    GetWidget._cache[widget!] = _controller;

    super.onInit();
  }

  @override
  void onClose() {
    if (_isCreator) {
      Get.asap(() {
        widget!.controller.onDelete();
        Get.log('"${widget!.controller.runtimeType}" onClose() called');
        Get.log('"${widget!.controller.runtimeType}" deleted from memory');
        // GetWidget._cache[widget!] = null;
      });
    }
    info = null;
    super.onClose();
  }

  @override
  Widget build(BuildContext context) {
    return Binder(
      init: () => _controller,
      child: widget!.build(context),
    );
  }
}


--- File Index 8: get_state_manager/src/simple/get_responsive.dart ---
import 'package:flutter/widgets.dart';

import '../../../get.dart';

mixin GetResponsiveMixin on Widget {
  ResponsiveScreen get screen;
  bool get alwaysUseBuilder;

  @protected
  Widget build(BuildContext context) {
    screen.context = context;
    Widget? widget;
    if (alwaysUseBuilder) {
      widget = builder();
      if (widget != null) return widget;
    }
    if (screen.isDesktop) {
      widget = desktop() ?? widget;
      if (widget != null) return widget;
    }
    if (screen.isTablet) {
      widget = tablet() ?? desktop();
      if (widget != null) return widget;
    }
    if (screen.isPhone) {
      widget = phone() ?? tablet() ?? desktop();
      if (widget != null) return widget;
    }
    return watch() ?? phone() ?? tablet() ?? desktop() ?? builder()!;
  }

  Widget? builder() => null;

  Widget? desktop() => null;

  Widget? phone() => null;

  Widget? tablet() => null;

  Widget? watch() => null;
}

/// Extend this widget to build responsive view.
/// this widget contains the `screen` property that have all
/// information about the screen size and type.
/// You have two options to build it.
/// 1- with `builder` method you return the widget to build.
/// 2- with methods `desktop`, `tablet`,`phone`, `watch`. the specific
/// method will be built when the screen type matches the method
/// when the screen is [ScreenType.Tablet] the `tablet` method
/// will be exuded and so on.
/// Note if you use this method please set the
/// property `alwaysUseBuilder` to false
/// With `settings` property you can set the width limit for the screen types.
class GetResponsiveView<T> extends GetView<T> with GetResponsiveMixin {
  @override
  final bool alwaysUseBuilder;

  @override
  final ResponsiveScreen screen;

  GetResponsiveView({
    this.alwaysUseBuilder = false,
    ResponsiveScreenSettings settings = const ResponsiveScreenSettings(),
    super.key,
  }) : screen = ResponsiveScreen(settings);
}

class GetResponsiveWidget<T extends GetLifeCycleMixin> extends GetWidget<T>
    with GetResponsiveMixin {
  @override
  final bool alwaysUseBuilder;

  @override
  final ResponsiveScreen screen;

  GetResponsiveWidget({
    this.alwaysUseBuilder = false,
    ResponsiveScreenSettings settings = const ResponsiveScreenSettings(),
    super.key,
  }) : screen = ResponsiveScreen(settings);
}

class ResponsiveScreenSettings {
  /// When the width is greater als this value
  /// the display will be set as [ScreenType.Desktop]
  final double desktopChangePoint;

  /// When the width is greater als this value
  /// the display will be set as [ScreenType.Tablet]
  /// or when width greater als [watchChangePoint] and smaller als this value
  /// the display will be [ScreenType.Phone]
  final double tabletChangePoint;

  /// When the width is smaller als this value
  /// the display will be set as [ScreenType.Watch]
  /// or when width greater als this value and smaller als [tabletChangePoint]
  /// the display will be [ScreenType.Phone]
  final double watchChangePoint;

  const ResponsiveScreenSettings(
      {this.desktopChangePoint = 1200,
      this.tabletChangePoint = 600,
      this.watchChangePoint = 300});
}

class ResponsiveScreen {
  late BuildContext context;
  final ResponsiveScreenSettings settings;

  late bool _isPlatformDesktop;
  ResponsiveScreen(this.settings) {
    _isPlatformDesktop = GetPlatform.isDesktop;
  }

  double get height => context.height;
  double get width => context.width;

  /// Is [screenType] [ScreenType.Desktop]
  bool get isDesktop => (screenType == ScreenType.desktop);

  /// Is [screenType] [ScreenType.Tablet]
  bool get isTablet => (screenType == ScreenType.tablet);

  /// Is [screenType] [ScreenType.Phone]
  bool get isPhone => (screenType == ScreenType.phone);

  /// Is [screenType] [ScreenType.Watch]
  bool get isWatch => (screenType == ScreenType.watch);

  double get _getDeviceWidth {
    if (_isPlatformDesktop) {
      return width;
    }
    return context.mediaQueryShortestSide;
  }

  ScreenType get screenType {
    final deviceWidth = _getDeviceWidth;
    if (deviceWidth >= settings.desktopChangePoint) return ScreenType.desktop;
    if (deviceWidth >= settings.tabletChangePoint) return ScreenType.tablet;
    if (deviceWidth < settings.watchChangePoint) return ScreenType.watch;
    return ScreenType.phone;
  }

  /// Return widget according to screen type
  /// if the [screenType] is [ScreenType.Desktop] and
  /// `desktop` object is null the `tablet` object will be returned
  /// and if `tablet` object is null the `mobile` object will be returned
  /// and if `mobile` object is null the `watch` object will be returned
  ///  also when it is null.
  T? responsiveValue<T>({
    T? mobile,
    T? tablet,
    T? desktop,
    T? watch,
  }) {
    if (isDesktop && desktop != null) return desktop;
    if (isTablet && tablet != null) return tablet;
    if (isPhone && mobile != null) return mobile;
    return watch;
  }
}

enum ScreenType {
  watch,
  phone,
  tablet,
  desktop,
}


--- File Index 9: get_state_manager/src/simple/get_widget_cache.dart ---
import 'package:flutter/widgets.dart';

abstract class GetWidgetCache extends Widget {
  const GetWidgetCache({super.key});

  @override
  GetWidgetCacheElement createElement() => GetWidgetCacheElement(this);

  @protected
  @factory
  WidgetCache createWidgetCache();
}

class GetWidgetCacheElement extends ComponentElement {
  GetWidgetCacheElement(GetWidgetCache widget)
      : cache = widget.createWidgetCache(),
        super(widget) {
    cache._element = this;
    cache._widget = widget;
  }

  @override
  void mount(Element? parent, dynamic newSlot) {
    cache.onInit();
    super.mount(parent, newSlot);
  }

  @override
  Widget build() => cache.build(this);

  final WidgetCache<GetWidgetCache> cache;

  @override
  void activate() {
    super.activate();
    markNeedsBuild();
  }

  @override
  void unmount() {
    super.unmount();
    cache.onClose();
    cache._element = null;
  }
}

@optionalTypeArgs
abstract class WidgetCache<T extends GetWidgetCache> {
  T? get widget => _widget;
  T? _widget;

  BuildContext? get context => _element;

  GetWidgetCacheElement? _element;

  @protected
  @mustCallSuper
  void onInit() {}

  @protected
  @mustCallSuper
  void onClose() {}

  @protected
  Widget build(BuildContext context);
}


--- File Index 10: get_state_manager/src/rx_flutter/rx_ticket_provider_mixin.dart ---
// ignore_for_file: lines_longer_than_80_chars

import 'package:flutter/foundation.dart';
import 'package:flutter/material.dart';
import 'package:flutter/scheduler.dart';

import '../../../get_instance/src/lifecycle.dart';
import '../../get_state_manager.dart';

/// Used like `SingleTickerProviderMixin` but only with Get Controllers.
/// Simplifies AnimationController creation inside GetxController.
///
/// Example:
///```
///class SplashController extends GetxController with
///    GetSingleTickerProviderStateMixin {
///  AnimationController controller;
///
///  @override
///  void onInit() {
///    final duration = const Duration(seconds: 2);
///    controller =
///        AnimationController.unbounded(duration: duration, vsync: this);
///    controller.repeat();
///    controller.addListener(() =>
///        print("Animation Controller value: ${controller.value}"));
///  }
///  ...
/// ```
mixin GetSingleTickerProviderStateMixin on GetxController
    implements TickerProvider {
  Ticker? _ticker;

  @override
  Ticker createTicker(TickerCallback onTick) {
    assert(() {
      if (_ticker == null) return true;
      throw FlutterError.fromParts(<DiagnosticsNode>[
        ErrorSummary(
            '$runtimeType is a GetSingleTickerProviderStateMixin but multiple tickers were created.'),
        ErrorDescription(
            'A GetSingleTickerProviderStateMixin can only be used as a TickerProvider once.'),
        ErrorHint(
          'If a State is used for multiple AnimationController objects, or if it is passed to other '
          'objects and those objects might use it more than one time in total, then instead of '
          'mixing in a GetSingleTickerProviderStateMixin, use a regular GetTickerProviderStateMixin.',
        ),
      ]);
    }());
    _ticker =
        Ticker(onTick, debugLabel: kDebugMode ? 'created by $this' : null);
    // We assume that this is called from initState, build, or some sort of
    // event handler, and that thus TickerMode.of(context) would return true. We
    // can't actually check that here because if we're in initState then we're
    // not allowed to do inheritance checks yet.
    return _ticker!;
  }

  void didChangeDependencies(BuildContext context) {
    if (_ticker != null) _ticker!.muted = !TickerMode.of(context);
  }

  @override
  void onClose() {
    assert(() {
      if (_ticker == null || !_ticker!.isActive) return true;
      throw FlutterError.fromParts(<DiagnosticsNode>[
        ErrorSummary('$this was disposed with an active Ticker.'),
        ErrorDescription(
          '$runtimeType created a Ticker via its GetSingleTickerProviderStateMixin, but at the time '
          'dispose() was called on the mixin, that Ticker was still active. The Ticker must '
          'be disposed before calling super.dispose().',
        ),
        ErrorHint(
          'Tickers used by AnimationControllers '
          'should be disposed by calling dispose() on the AnimationController itself. '
          'Otherwise, the ticker will leak.',
        ),
        _ticker!.describeForError('The offending ticker was'),
      ]);
    }());
    super.onClose();
  }
}

/// Used like `TickerProviderMixin` but only with Get Controllers.
/// Simplifies multiple AnimationController creation inside GetxController.
///
/// Example:
///```
///class SplashController extends GetxController with
///    GetTickerProviderStateMixin {
///  AnimationController first_controller;
///  AnimationController second_controller;
///
///  @override
///  void onInit() {
///    final duration = const Duration(seconds: 2);
///    first_controller =
///        AnimationController.unbounded(duration: duration, vsync: this);
///    second_controller =
///        AnimationController.unbounded(duration: duration, vsync: this);
///    first_controller.repeat();
///    first_controller.addListener(() =>
///        print("Animation Controller value: ${first_controller.value}"));
///    second_controller.addListener(() =>
///        print("Animation Controller value: ${second_controller.value}"));
///  }
///  ...
/// ```
mixin GetTickerProviderStateMixin on GetxController implements TickerProvider {
  Set<Ticker>? _tickers;

  @override
  Ticker createTicker(TickerCallback onTick) {
    _tickers ??= <_WidgetTicker>{};
    final result = _WidgetTicker(onTick, this,
        debugLabel: kDebugMode ? 'created by ${describeIdentity(this)}' : null);
    _tickers!.add(result);
    return result;
  }

  void _removeTicker(_WidgetTicker ticker) {
    assert(_tickers != null);
    assert(_tickers!.contains(ticker));
    _tickers!.remove(ticker);
  }

  void didChangeDependencies(BuildContext context) {
    final muted = !TickerMode.of(context);
    if (_tickers != null) {
      for (final ticker in _tickers!) {
        ticker.muted = muted;
      }
    }
  }

  @override
  void onClose() {
    assert(() {
      if (_tickers != null) {
        for (final ticker in _tickers!) {
          if (ticker.isActive) {
            throw FlutterError.fromParts(<DiagnosticsNode>[
              ErrorSummary('$this was disposed with an active Ticker.'),
              ErrorDescription(
                '$runtimeType created a Ticker via its GetTickerProviderStateMixin, but at the time '
                'dispose() was called on the mixin, that Ticker was still active. All Tickers must '
                'be disposed before calling super.dispose().',
              ),
              ErrorHint(
                'Tickers used by AnimationControllers '
                'should be disposed by calling dispose() on the AnimationController itself. '
                'Otherwise, the ticker will leak.',
              ),
              ticker.describeForError('The offending ticker was'),
            ]);
          }
        }
      }
      return true;
    }());
    super.onClose();
  }
}

class _WidgetTicker extends Ticker {
  _WidgetTicker(super.onTick, this._creator, {super.debugLabel});

  final GetTickerProviderStateMixin _creator;

  @override
  void dispose() {
    _creator._removeTicker(this);
    super.dispose();
  }
}

@Deprecated('use GetSingleTickerProviderStateMixin')

/// Used like `SingleTickerProviderMixin` but only with Get Controllers.
/// Simplifies AnimationController creation inside GetxController.
///
/// Example:
///```
///class SplashController extends GetxController with
///    SingleGetTickerProviderMixin {
///  AnimationController _ac;
///
///  @override
///  void onInit() {
///    final dur = const Duration(seconds: 2);
///    _ac = AnimationController.unbounded(duration: dur, vsync: this);
///    _ac.repeat();
///    _ac.addListener(() => print("Animation Controller value: ${_ac.value}"));
///  }
///  ...
/// ```
mixin SingleGetTickerProviderMixin on GetLifeCycleMixin
    implements TickerProvider {
  @override
  Ticker createTicker(TickerCallback onTick) => Ticker(onTick);
}


--- File Index 11: get_state_manager/src/rx_flutter/rx_obx_widget.dart ---
import 'package:flutter/widgets.dart';

import '../../../get_rx/src/rx_types/rx_types.dart';
import '../simple/simple_builder.dart';

typedef WidgetCallback = Widget Function();

/// The [ObxWidget] is the base for all GetX reactive widgets
///
/// See also:
/// - [Obx]
/// - [ObxValue]
abstract class ObxWidget extends ObxStatelessWidget {
  const ObxWidget({super.key});
}

/// The simplest reactive widget in GetX.
///
/// Just pass your Rx variable in the root scope of the callback to have it
/// automatically registered for changes.
///
/// final _name = "GetX".obs;
/// Obx(() => Text( _name.value )),... ;
class Obx extends ObxWidget {
  final WidgetCallback builder;

  const Obx(this.builder, {super.key});

  @override
  Widget build(BuildContext context) {
    return builder();
  }
}

/// Similar to Obx, but manages a local state.
/// Pass the initial data in constructor.
/// Useful for simple local states, like toggles, visibility, themes,
/// button states, etc.
///  Sample:
///    ObxValue((data) => Switch(
///      value: data.value,
///      onChanged: (flag) => data.value = flag,
///    ),
///    false.obs,
///   ),
class ObxValue<T extends RxInterface> extends ObxWidget {
  final Widget Function(T) builder;
  final T data;

  const ObxValue(this.builder, this.data, {super.key});

  @override
  Widget build(BuildContext context) => builder(data);
}


--- File Index 12: get_state_manager/src/rx_flutter/rx_getx_widget.dart ---
import 'package:flutter/foundation.dart';
import 'package:flutter/widgets.dart';

import '../../../get_core/get_core.dart';
import '../../../get_instance/src/extension_instance.dart';
import '../../../get_instance/src/lifecycle.dart';
import '../simple/list_notifier.dart';

typedef GetXControllerBuilder<T extends GetLifeCycleMixin> = Widget Function(
    T controller);

class GetX<T extends GetLifeCycleMixin> extends StatefulWidget {
  final GetXControllerBuilder<T> builder;
  final bool global;
  final bool autoRemove;
  final bool assignId;
  final void Function(GetXState<T> state)? initState,
      dispose,
      didChangeDependencies;
  final void Function(GetX oldWidget, GetXState<T> state)? didUpdateWidget;
  final T? init;
  final String? tag;

  const GetX({
    super.key,
    this.tag,
    required this.builder,
    this.global = true,
    this.autoRemove = true,
    this.initState,
    this.assignId = false,
    //  this.stream,
    this.dispose,
    this.didChangeDependencies,
    this.didUpdateWidget,
    this.init,
    // this.streamController
  });

  @override
  StatefulElement createElement() => StatefulElement(this);

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
      ..add(
        DiagnosticsProperty<T>('controller', init),
      )
      ..add(DiagnosticsProperty<String>('tag', tag))
      ..add(
          ObjectFlagProperty<GetXControllerBuilder<T>>.has('builder', builder));
  }

  @override
  GetXState<T> createState() => GetXState<T>();
}

class GetXState<T extends GetLifeCycleMixin> extends State<GetX<T>> {
  T? controller;
  bool? _isCreator = false;

  @override
  void initState() {
    // var isPrepared = Get.isPrepared<T>(tag: widget.tag);
    final isRegistered = Get.isRegistered<T>(tag: widget.tag);

    if (widget.global) {
      if (isRegistered) {
        _isCreator = Get.isPrepared<T>(tag: widget.tag);
        controller = Get.find<T>(tag: widget.tag);
      } else {
        controller = widget.init;
        _isCreator = true;
        Get.put<T>(controller!, tag: widget.tag);
      }
    } else {
      controller = widget.init;
      _isCreator = true;
      controller?.onStart();
    }
    widget.initState?.call(this);
    if (widget.global && Get.smartManagement == SmartManagement.onlyBuilder) {
      controller?.onStart();
    }

    super.initState();
  }

  @override
  void didChangeDependencies() {
    super.didChangeDependencies();
    if (widget.didChangeDependencies != null) {
      widget.didChangeDependencies!(this);
    }
  }

  @override
  void didUpdateWidget(GetX oldWidget) {
    super.didUpdateWidget(oldWidget as GetX<T>);
    widget.didUpdateWidget?.call(oldWidget, this);
  }

  @override
  void dispose() {
    if (widget.dispose != null) widget.dispose!(this);
    if (_isCreator! || widget.assignId) {
      if (widget.autoRemove && Get.isRegistered<T>(tag: widget.tag)) {
        Get.delete<T>(tag: widget.tag);
      }
    }

    for (final disposer in disposers) {
      disposer();
    }

    disposers.clear();

    controller = null;
    _isCreator = null;
    super.dispose();
  }

  void _update() {
    if (mounted) {
      setState(() {});
    }
  }

  final disposers = <Disposer>[];

  @override
  Widget build(BuildContext context) => Notifier.instance.append(
      NotifyData(disposers: disposers, updater: _update),
      () => widget.builder(controller!));

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties.add(DiagnosticsProperty<T>('controller', controller));
  }
}


--- File Index 13: get_state_manager/src/rx_flutter/rx_notifier.dart ---
import 'dart:async';

import 'package:flutter/foundation.dart';
import 'package:flutter/material.dart';
import 'package:get/utils.dart';

import '../../../get_rx/src/rx_types/rx_types.dart';
import '../../../instance_manager.dart';
import '../../get_state_manager.dart';
import '../simple/list_notifier.dart';

extension _Empty on Object {
  bool _isEmpty() {
    final val = this;
    // if (val == null) return true;
    var result = false;
    if (val is Iterable) {
      result = val.isEmpty;
    } else if (val is String) {
      result = val.trim().isEmpty;
    } else if (val is Map) {
      result = val.isEmpty;
    }
    return result;
  }
}

mixin StateMixin<T> on ListNotifier {
  T? _value;
  GetStatus<T>? _status;

  void _fillInitialStatus() {
    _status = (_value == null || _value!._isEmpty())
        ? GetStatus<T>.loading()
        : GetStatus<T>.success(_value as T);
  }

  GetStatus<T> get status {
    reportRead();
    return _status ??= _status = GetStatus.loading();
  }

  T get state => value;

  set status(GetStatus<T> newStatus) {
    if (newStatus == status) return;
    _status = newStatus;
    if (newStatus is SuccessStatus<T>) {
      _value = newStatus.data;
    }
    refresh();
  }

  @protected
  T get value {
    reportRead();
    return _value as T;
  }

  @protected
  set value(T newValue) {
    if (_value == newValue) return;
    _value = newValue;
    refresh();
  }

  @protected
  void change(GetStatus<T> status) {
    if (status != this.status) {
      this.status = status;
    }
  }

  void setSuccess(T data) {
    change(GetStatus<T>.success(data));
  }

  void setError(Object error) {
    change(GetStatus<T>.error(error));
  }

  void setLoading() {
    change(GetStatus<T>.loading());
  }

  void setEmpty() {
    change(GetStatus<T>.empty());
  }

  void futurize(Future<T> Function() body,
      {T? initialData, String? errorMessage, bool useEmpty = true}) {
    final compute = body;
    _value ??= initialData;
    status = GetStatus<T>.loading();
    compute().then((newValue) {
      if ((newValue == null || newValue._isEmpty()) && useEmpty) {
        status = GetStatus<T>.empty();
      } else {
        status = GetStatus<T>.success(newValue);
      }

      refresh();
    }, onError: (err) {
      status = GetStatus.error(
          err is Exception ? err : Exception(errorMessage ?? err.toString()));
      refresh();
    });
  }
}

typedef FuturizeCallback<T> = Future<T> Function(VoidCallback fn);

typedef VoidCallback = void Function();

class GetListenable<T> extends ListNotifierSingle implements RxInterface<T> {
  GetListenable(T val) : _value = val;

  StreamController<T>? _controller;

  StreamController<T> get subject {
    if (_controller == null) {
      _controller =
          StreamController<T>.broadcast(onCancel: addListener(_streamListener));
      _controller?.add(_value);

      ///TODO: report to controller dispose
    }
    return _controller!;
  }

  void _streamListener() {
    _controller?.add(_value);
  }

  @override
  @mustCallSuper
  void close() {
    removeListener(_streamListener);
    _controller?.close();
    dispose();
  }

  Stream<T> get stream {
    return subject.stream;
  }

  T _value;

  @override
  T get value {
    reportRead();
    return _value;
  }

  void _notify() {
    refresh();
  }

  set value(T newValue) {
    if (_value == newValue) return;
    _value = newValue;
    _notify();
  }

  T? call([T? v]) {
    if (v != null) {
      value = v;
    }
    return value;
  }

  @override
  StreamSubscription<T> listen(
    void Function(T)? onData, {
    Function? onError,
    void Function()? onDone,
    bool? cancelOnError,
  }) =>
      stream.listen(
        onData,
        onError: onError,
        onDone: onDone,
        cancelOnError: cancelOnError ?? false,
      );

  @override
  String toString() => value.toString();
}

class Value<T> extends ListNotifier
    with StateMixin<T>
    implements ValueListenable<T?> {
  Value(T val) {
    _value = val;
    _fillInitialStatus();
  }

  @override
  T get value {
    reportRead();
    return _value as T;
  }

  @override
  set value(T newValue) {
    if (_value == newValue) return;
    _value = newValue;
    refresh();
  }

  T? call([T? v]) {
    if (v != null) {
      value = v;
    }
    return value;
  }

  void update(T Function(T? value) fn) {
    value = fn(value);
    // refresh();
  }

  @override
  String toString() => value.toString();

  dynamic toJson() => (value as dynamic)?.toJson();
}

/// GetNotifier has a native status and state implementation, with the
/// Get Lifecycle
abstract class GetNotifier<T> extends Value<T> with GetLifeCycleMixin {
  GetNotifier(super.initial);
}

extension StateExt<T> on StateMixin<T> {
  Widget obx(
    NotifierBuilder<T> widget, {
    Widget Function(String? error)? onError,
    Widget? onLoading,
    Widget? onEmpty,
    WidgetBuilder? onCustom,
  }) {
    return Observer(builder: (context) {
      if (status.isLoading) {
        return onLoading ?? const Center(child: CircularProgressIndicator());
      } else if (status.isError) {
        return onError != null
            ? onError(status.errorMessage)
            : Center(child: Text('A error occurred: ${status.errorMessage}'));
      } else if (status.isEmpty) {
        return onEmpty ??
            const SizedBox.shrink(); // Also can be widget(null); but is risky
      } else if (status.isSuccess) {
        return widget(value);
      } else if (status.isCustom) {
        return onCustom?.call(context) ??
            const SizedBox.shrink(); // Also can be widget(null); but is risky
      }
      return widget(value);
    });
  }
}

typedef NotifierBuilder<T> = Widget Function(T state);

abstract class GetStatus<T> with Equality {
  const GetStatus();

  factory GetStatus.loading() => LoadingStatus<T>();

  factory GetStatus.error(Object message) => ErrorStatus<T, Object>(message);

  factory GetStatus.empty() => EmptyStatus<T>();

  factory GetStatus.success(T data) => SuccessStatus<T>(data);

  factory GetStatus.custom() => CustomStatus<T>();
}

class CustomStatus<T> extends GetStatus<T> {
  @override
  List get props => [];
}

class LoadingStatus<T> extends GetStatus<T> {
  @override
  List get props => [];
}

class SuccessStatus<T> extends GetStatus<T> {
  final T data;

  const SuccessStatus(this.data);

  @override
  List get props => [data];
}

class ErrorStatus<T, S> extends GetStatus<T> {
  final S? error;

  const ErrorStatus([this.error]);

  @override
  List get props => [error];
}

class EmptyStatus<T> extends GetStatus<T> {
  @override
  List get props => [];
}

extension StatusDataExt<T> on GetStatus<T> {
  bool get isLoading => this is LoadingStatus;

  bool get isSuccess => this is SuccessStatus;

  bool get isError => this is ErrorStatus;

  bool get isEmpty => this is EmptyStatus;

  bool get isCustom => !isLoading && !isSuccess && !isError && !isEmpty;

  dynamic get error {
    if (this is ErrorStatus) {
      return (this as ErrorStatus).error;
    }
    return null;
  }

  String get errorMessage {
    final isError = this is ErrorStatus;
    if (isError) {
      final err = this as ErrorStatus;
      if (err.error != null) {
        if (err.error is String) {
          return err.error as String;
        }
        return err.error.toString();
      }
    }

    return '';
  }

  T? get data {
    if (this is SuccessStatus<T>) {
      final success = this as SuccessStatus<T>;
      return success.data;
    }
    return null;
  }
}


--- File Index 14: get_rx/get_rx.dart ---
library;

export 'src/rx_stream/rx_stream.dart';
export 'src/rx_types/rx_types.dart';
export 'src/rx_workers/rx_workers.dart';


--- File Index 15: get_rx/src/rx_stream/rx_stream.dart ---
library;

import 'dart:async';

import '../rx_typedefs/rx_typedefs.dart';

//part 'get_stream.dart';
part 'mini_stream.dart';


--- File Index 16: get_rx/src/rx_stream/mini_stream.dart ---
part of 'rx_stream.dart';

class Node<T> {
  T? data;
  Node<T>? next;
  Node<T>? prev;
  Node({this.data, this.next, this.prev});
}

class MiniSubscription<T> {
  const MiniSubscription(
      this.data, this.onError, this.onDone, this.cancelOnError, this.listener);
  final OnData<T> data;
  final Function? onError;
  final Callback? onDone;
  final bool cancelOnError;

  Future<void> cancel() async => listener.removeListener(this);

  final FastList<T> listener;
}

class MiniStream<T> {
  FastList<T> listenable = FastList<T>();

  late T _value;

  T get value => _value;

  set value(T val) {
    add(val);
  }

  void add(T event) {
    _value = event;
    listenable._notifyData(event);
  }

  void addError(Object error, [StackTrace? stackTrace]) {
    listenable._notifyError(error, stackTrace);
  }

  int get length => listenable.length;

  bool get hasListeners => listenable.isNotEmpty;

  bool get isClosed => _isClosed;

  MiniSubscription<T> listen(void Function(T event) onData,
      {Function? onError,
      void Function()? onDone,
      bool cancelOnError = false}) {
    final subs = MiniSubscription<T>(
      onData,
      onError,
      onDone,
      cancelOnError,
      listenable,
    );
    listenable.addListener(subs);
    return subs;
  }

  bool _isClosed = false;

  void close() {
    if (_isClosed) {
      throw 'You can not close a closed Stream';
    }
    listenable._notifyDone();
    listenable.clear();
    _isClosed = true;
  }
}

class FastList<T> {
  Node<MiniSubscription<T>>? _head;
  Node<MiniSubscription<T>>? _tail;
  int _length = 0;

  void _notifyData(T data) {
    var currentNode = _head;
    while (currentNode != null) {
      currentNode.data?.data(data);
      currentNode = currentNode.next;
    }
  }

  void _notifyDone() {
    var currentNode = _head;
    while (currentNode != null) {
      currentNode.data?.onDone?.call();
      currentNode = currentNode.next;
    }
  }

  void _notifyError(Object error, [StackTrace? stackTrace]) {
    var currentNode = _head;
    while (currentNode != null) {
      currentNode.data?.onError?.call(error, stackTrace);
      currentNode = currentNode.next;
    }
  }

  bool get isEmpty => _length == 0;

  bool get isNotEmpty => _length > 0;

  int get length => _length;

  MiniSubscription<T>? elementAt(int position) {
    if (isEmpty || position < 0 || position >= _length) return null;

    var node = _head;
    var current = 0;

    while (current != position) {
      node = node!.next;
      current++;
    }
    return node!.data;
  }

  void addListener(MiniSubscription<T> data) {
    var newNode = Node(data: data);

    if (isEmpty) {
      _head = _tail = newNode;
    } else {
      _tail!.next = newNode;
      newNode.prev = _tail;
      _tail = newNode;
    }
    _length++;
  }

  bool contains(T element) {
    var currentNode = _head;
    while (currentNode != null) {
      if (currentNode.data == element) return true;
      currentNode = currentNode.next;
    }
    return false;
  }

  void removeListener(MiniSubscription<T> element) {
    var currentNode = _head;
    while (currentNode != null) {
      if (currentNode.data == element) {
        _removeNode(currentNode);
        break;
      }
      currentNode = currentNode.next;
    }
  }

  void clear() {
    _head = _tail = null;
    _length = 0;
  }

  void _removeNode(Node<MiniSubscription<T>> node) {
    if (node.prev == null) {
      _head = node.next;
    } else {
      node.prev!.next = node.next;
    }

    if (node.next == null) {
      _tail = node.prev;
    } else {
      node.next!.prev = node.prev;
    }

    _length--;
  }
}


--- File Index 17: get_rx/src/rx_workers/rx_workers.dart ---
import 'dart:async';

import '../../../get_core/get_core.dart';
import '../../../get_state_manager/src/rx_flutter/rx_notifier.dart';
import '../rx_types/rx_types.dart';
import 'utils/debouncer.dart';

bool _conditional(dynamic condition) {
  if (condition == null) return true;
  if (condition is bool) return condition;
  if (condition is bool Function()) return condition();
  return true;
}

typedef WorkerCallback<T> = Function(T callback);

class Workers {
  Workers(this.workers);
  final List<Worker> workers;

  void dispose() {
    for (final worker in workers) {
      if (!worker._disposed) {
        worker.dispose();
      }
    }
  }
}

///
/// Called every time [listener] changes. As long as the [condition]
/// returns true.
///
/// Sample:
/// Every time increment() is called, ever() will process the [condition]
/// (can be a [bool] expression or a `bool Function()`), and only call
/// the callback when [condition] is true.
/// In our case, only when count is bigger to 5. In order to "dispose"
/// this Worker
/// that will run forever, we made a `worker` variable. So, when the count value
/// reaches 10, the worker gets disposed, and releases any memory resources.
///
/// ```
/// // imagine some counter widget...
///
/// class _CountController extends GetxController {
///   final count = 0.obs;
///   Worker worker;
///
///   void onInit() {
///     worker = ever(count, (value) {
///       print('counter changed to: $value');
///       if (value == 10) worker.dispose();
///     }, condition: () => count > 5);
///   }
///
///   void increment() => count + 1;
/// }
/// ```
Worker ever<T>(
  GetListenable<T> listener,
  WorkerCallback<T> callback, {
  dynamic condition = true,
  Function? onError,
  void Function()? onDone,
  bool? cancelOnError,
}) {
  StreamSubscription sub = listener.listen(
    (event) {
      if (_conditional(condition)) callback(event);
    },
    onError: onError,
    onDone: onDone,
    cancelOnError: cancelOnError,
  );
  return Worker(sub.cancel, '[ever]');
}

/// Similar to [ever], but takes a list of [listeners], the condition
/// for the [callback] is common to all [listeners],
/// and the [callback] is executed to each one of them. The [Worker] is
/// common to all, so `worker.dispose()` will cancel all streams.
Worker everAll(
  List<RxInterface> listeners,
  WorkerCallback callback, {
  dynamic condition = true,
  Function? onError,
  void Function()? onDone,
  bool? cancelOnError,
}) {
  final evers = <StreamSubscription>[];
  for (var i in listeners) {
    final sub = i.listen(
      (event) {
        if (_conditional(condition)) callback(event);
      },
      onError: onError,
      onDone: onDone,
      cancelOnError: cancelOnError,
    );
    evers.add(sub);
  }

  Future<void> cancel() async {
    for (var i in evers) {
      i.cancel();
    }
  }

  return Worker(cancel, '[everAll]');
}

/// `once()` will execute only 1 time when [condition] is met and cancel
/// the subscription to the [listener] stream right after that.
/// [condition] defines when [callback] is called, and
/// can be a [bool] or a `bool Function()`.
///
/// Sample:
/// ```
///  class _CountController extends GetxController {
///   final count = 0.obs;
///   Worker worker;
///
///   @override
///   Future<void> onInit() async {
///     worker = once(count, (value) {
///       print("counter reached $value before 3 seconds.");
///     }, condition: () => count() > 2);
///     3.delay(worker.dispose);
///   }
///   void increment() => count + 1;
/// }
///```
Worker once<T>(
  GetListenable<T> listener,
  WorkerCallback<T> callback, {
  dynamic condition = true,
  Function? onError,
  void Function()? onDone,
  bool? cancelOnError,
}) {
  late Worker ref;
  StreamSubscription? sub;
  sub = listener.listen(
    (event) {
      if (!_conditional(condition)) return;
      ref._disposed = true;
      ref._log('called');
      sub?.cancel();
      callback(event);
    },
    onError: onError,
    onDone: onDone,
    cancelOnError: cancelOnError,
  );
  ref = Worker(sub.cancel, '[once]');
  return ref;
}

/// Ignore all changes in [listener] during [time] (1 sec by default) or until
/// [condition] is met (can be a [bool] expression or a `bool Function()`),
/// It brings the 1st "value" since the period of time, so
/// if you click a counter button 3 times in 1 sec, it will show you "1"
/// (after 1 sec of the first press)
/// click counter 3 times in 1 sec, it will show you "4" (after 1 sec)
/// click counter 2 times in 1 sec, it will show you "7" (after 1 sec).
///
/// Sample:
/// // wait 1 sec each time an event starts, only if counter is lower than 20.
/// worker = interval(
///    count,
///    (value) => print(value),
///    time: 1.seconds,
///    condition: () => count < 20,
/// );
/// ```
Worker interval<T>(
  GetListenable<T> listener,
  WorkerCallback<T> callback, {
  Duration time = const Duration(seconds: 1),
  dynamic condition = true,
  Function? onError,
  void Function()? onDone,
  bool? cancelOnError,
}) {
  var debounceActive = false;
  StreamSubscription sub = listener.listen(
    (event) async {
      if (debounceActive || !_conditional(condition)) return;
      debounceActive = true;
      await Future.delayed(time);
      debounceActive = false;
      callback(event);
    },
    onError: onError,
    onDone: onDone,
    cancelOnError: cancelOnError,
  );
  return Worker(sub.cancel, '[interval]');
}

/// [debounce] is similar to [interval], but sends the last value.
/// Useful for Anti DDos, every time the user stops typing for 1 second,
/// for instance.
/// When [listener] emits the last "value", when [time] hits,
/// it calls [callback] with the last "value" emitted.
///
/// Sample:
///
/// ```
/// worker = debounce(
///      count,
///      (value) {
///        print(value);
///        if( value > 20 ) worker.dispose();
///      },
///      time: 1.seconds,
///    );
///  }
///  ```
Worker debounce<T>(
  GetListenable<T> listener,
  WorkerCallback<T> callback, {
  Duration? time,
  Function? onError,
  void Function()? onDone,
  bool? cancelOnError,
}) {
  final newDebouncer =
      Debouncer(delay: time ?? const Duration(milliseconds: 800));
  StreamSubscription sub = listener.listen(
    (event) {
      newDebouncer(() {
        callback(event);
      });
    },
    onError: onError,
    onDone: onDone,
    cancelOnError: cancelOnError,
  );
  return Worker(sub.cancel, '[debounce]');
}

class Worker {
  Worker(this.worker, this.type);

  /// subscription.cancel() callback
  final Future<void> Function() worker;

  /// type of worker (debounce, interval, ever)..
  final String type;
  bool _disposed = false;

  bool get disposed => _disposed;

  //final bool _verbose = true;
  void _log(String msg) {
    //  if (!_verbose) return;
    Get.log('$runtimeType $type $msg');
  }

  void dispose() {
    if (_disposed) {
      _log('already disposed');
      return;
    }
    _disposed = true;
    worker();
    _log('disposed');
  }

  void call() => dispose();
}


--- File Index 18: get_rx/src/rx_workers/utils/debouncer.dart ---
import 'dart:async';

/// This "function" class is the implementation of `debouncer()` Worker.
/// It calls the function passed after specified [delay] parameter.
/// Example:
/// ```
/// final delayed = Debouncer( delay: Duration( seconds: 1 )) ;
/// print( 'the next function will be called after 1 sec' );
/// delayed( () => print( 'called after 1 sec' ));
/// ```
class Debouncer {
  final Duration delay;
  Timer? _timer;

  Debouncer({required this.delay});

  void call(void Function() action) {
    _timer?.cancel();
    _timer = Timer(delay, action);
  }

  /// Notifies if the delayed call is active.
  bool get isRunning => _timer?.isActive ?? false;

  /// Cancel the current delayed call.
  void cancel() => _timer?.cancel();
}


--- File Index 19: get_rx/src/rx_types/rx_types.dart ---
library;

import 'dart:async';
import 'dart:collection';

import 'package:flutter/foundation.dart';

import '../../../get_state_manager/src/rx_flutter/rx_notifier.dart';
import '../rx_typedefs/rx_typedefs.dart';

part 'rx_core/rx_impl.dart';
part 'rx_core/rx_interface.dart';
part 'rx_core/rx_num.dart';
part 'rx_core/rx_string.dart';
part 'rx_iterables/rx_list.dart';
part 'rx_iterables/rx_map.dart';
part 'rx_iterables/rx_set.dart';


--- File Index 20: get_rx/src/rx_types/rx_iterables/rx_list.dart ---
part of '../rx_types.dart';

/// Create a list similar to `List<T>`
class RxList<E> extends GetListenable<List<E>>
    with ListMixin<E>, RxObjectMixin<List<E>> {
  RxList([super.initial = const []]);

  factory RxList.filled(int length, E fill, {bool growable = false}) {
    return RxList(List.filled(length, fill, growable: growable));
  }

  factory RxList.empty({bool growable = false}) {
    return RxList(List.empty(growable: growable));
  }

  /// Creates a list containing all [elements].
  factory RxList.from(Iterable elements, {bool growable = true}) {
    return RxList(List.from(elements, growable: growable));
  }

  /// Creates a list from [elements].
  factory RxList.of(Iterable<E> elements, {bool growable = true}) {
    return RxList(List.of(elements, growable: growable));
  }

  /// Generates a list of values.
  factory RxList.generate(int length, E Function(int index) generator,
      {bool growable = true}) {
    return RxList(List.generate(length, generator, growable: growable));
  }

  /// Creates an unmodifiable list containing all [elements].
  factory RxList.unmodifiable(Iterable elements) {
    return RxList(List.unmodifiable(elements));
  }

  @override
  Iterator<E> get iterator => value.iterator;

  @override
  void operator []=(int index, E val) {
    value[index] = val;
    refresh();
  }

  /// Special override to push() element(s) in a reactive way
  /// inside the List,
  @override
  RxList<E> operator +(Iterable<E> val) {
    addAll(val);
    // refresh();
    return this;
  }

  @override
  E operator [](int index) {
    return value[index];
  }

  @override
  void add(E element) {
    value.add(element);
    refresh();
  }

  @override
  void addAll(Iterable<E> iterable) {
    value.addAll(iterable);
    refresh();
  }

  @override
  bool remove(Object? element) {
    final removed = value.remove(element);
    refresh();
    return removed;
  }

  @override
  void removeWhere(bool Function(E element) test) {
    value.removeWhere(test);
    refresh();
  }

  @override
  void retainWhere(bool Function(E element) test) {
    value.retainWhere(test);
    refresh();
  }

  @override
  int get length => value.length;

  // @override
  // @protected
  // List<E> get value {
  //   RxInterface.proxy?.addListener(subject);
  //   return subject.value;
  // }

  @override
  set length(int newLength) {
    value.length = newLength;
    refresh();
  }

  @override
  void insertAll(int index, Iterable<E> iterable) {
    value.insertAll(index, iterable);
    refresh();
  }

  @override
  Iterable<E> get reversed => value.reversed;

  // @override
  // set value(List<E> val) {
  //   value = val;
  //   refresh();
  // }

  @override
  Iterable<E> where(bool Function(E) test) {
    return value.where(test);
  }

  @override
  Iterable<T> whereType<T>() {
    return value.whereType<T>();
  }

  @override
  void sort([int Function(E a, E b)? compare]) {
    value.sort(compare);
    refresh();
  }
}

extension ListExtension<E> on List<E> {
  RxList<E> get obs => RxList<E>(this);

  /// Add [item] to [List<E>] only if [item] is not null.
  void addNonNull(E item) {
    if (item != null) add(item);
  }

  /// Add [item] to [List<E>] only if [condition] is true.
  void addIf(dynamic condition, E item) {
    if (condition is Condition) condition = condition();
    if (condition is bool && condition) add(item);
  }

  /// Adds [Iterable<E>] to [List<E>] only if [condition] is true.
  void addAllIf(dynamic condition, Iterable<E> items) {
    if (condition is Condition) condition = condition();
    if (condition is bool && condition) addAll(items);
  }

  /// Replaces all existing items of this list with [item]
  void assign(E item) {
    // if (this is RxList) {
    //   (this as RxList)._value;
    // }

    if (this is RxList) {
      (this as RxList).value.clear();
    }
    add(item);
  }

  /// Replaces all existing items of this list with [items]
  void assignAll(Iterable<E> items) {
    if (this is RxList) {
      (this as RxList).value.clear();
    }
    //clear();
    addAll(items);
  }
}


--- File Index 21: get_rx/src/rx_types/rx_iterables/rx_map.dart ---
part of '../rx_types.dart';

class RxMap<K, V> extends GetListenable<Map<K, V>>
    with MapMixin<K, V>, RxObjectMixin<Map<K, V>> {
  RxMap([super.initial = const {}]);

  factory RxMap.from(Map<K, V> other) {
    return RxMap(Map.from(other));
  }

  /// Creates a [LinkedHashMap] with the same keys and values as [other].
  factory RxMap.of(Map<K, V> other) {
    return RxMap(Map.of(other));
  }

  ///Creates an unmodifiable hash based map containing the entries of [other].
  factory RxMap.unmodifiable(Map<dynamic, dynamic> other) {
    return RxMap(Map.unmodifiable(other));
  }

  /// Creates an identity map with the default implementation, [LinkedHashMap].
  factory RxMap.identity() {
    return RxMap(Map.identity());
  }

  @override
  V? operator [](Object? key) {
    return value[key as K];
  }

  @override
  void operator []=(K key, V value) {
    this.value[key] = value;
    refresh();
  }

  @override
  void clear() {
    value.clear();
    refresh();
  }

  @override
  Iterable<K> get keys => value.keys;

  @override
  V? remove(Object? key) {
    final val = value.remove(key);
    refresh();
    return val;
  }

  // @override
  // @protected
  // Map<K, V> get value {
  //   return subject.value;
  //   // RxInterface.proxy?.addListener(subject);
  //   // return _value;
  // }
}

extension MapExtension<K, V> on Map<K, V> {
  RxMap<K, V> get obs {
    return RxMap<K, V>(this);
  }

  void addIf(dynamic condition, K key, V value) {
    if (condition is Condition) condition = condition();
    if (condition is bool && condition) {
      this[key] = value;
    }
  }

  void addAllIf(dynamic condition, Map<K, V> values) {
    if (condition is Condition) condition = condition();
    if (condition is bool && condition) addAll(values);
  }

  void assign(K key, V val) {
    if (this is RxMap) {
      final map = (this as RxMap);
      // map._value;
      map.value.clear();
      this[key] = val;
    } else {
      clear();
      this[key] = val;
    }
  }

  void assignAll(Map<K, V> val) {
    if (val is RxMap && this is RxMap) {
      if ((val as RxMap).value == (this as RxMap).value) return;
    }
    if (this is RxMap) {
      final map = (this as RxMap);
      if (map.value == val) return;
      map.value = val;
      // ignore: invalid_use_of_protected_member
      map.refresh();
    } else {
      if (this == val) return;
      clear();
      addAll(val);
    }
  }
}


--- File Index 22: get_rx/src/rx_types/rx_iterables/rx_set.dart ---
part of '../rx_types.dart';

class RxSet<E> extends GetListenable<Set<E>>
    with SetMixin<E>, RxObjectMixin<Set<E>> {
  RxSet([super.initial = const {}]);

  /// Special override to push() element(s) in a reactive way
  /// inside the List,
  RxSet<E> operator +(Set<E> val) {
    addAll(val);
    //refresh();
    return this;
  }

  void update(void Function(Iterable<E>? value) fn) {
    fn(value);
    refresh();
  }

  // @override
  // @protected
  // Set<E> get value {
  //   return subject.value;
  //   // RxInterface.proxy?.addListener(subject);
  //   // return _value;
  // }

  // @override
  // @protected
  // set value(Set<E> val) {
  //   if (value == val) return;
  //   value = val;
  //   refresh();
  // }

  @override
  bool add(E value) {
    final hasAdded = this.value.add(value);
    if (hasAdded) {
      refresh();
    }
    return hasAdded;
  }

  @override
  bool contains(Object? element) {
    return value.contains(element);
  }

  @override
  Iterator<E> get iterator => value.iterator;

  @override
  int get length => value.length;

  @override
  E? lookup(Object? element) {
    return value.lookup(element);
  }

  @override
  bool remove(Object? value) {
    var hasRemoved = this.value.remove(value);
    if (hasRemoved) {
      refresh();
    }
    return hasRemoved;
  }

  @override
  Set<E> toSet() {
    return value.toSet();
  }

  @override
  void addAll(Iterable<E> elements) {
    value.addAll(elements);
    refresh();
  }

  @override
  void clear() {
    value.clear();
    refresh();
  }

  @override
  void removeAll(Iterable<Object?> elements) {
    value.removeAll(elements);
    refresh();
  }

  @override
  void retainAll(Iterable<Object?> elements) {
    value.retainAll(elements);
    refresh();
  }

  @override
  void retainWhere(bool Function(E) test) {
    value.retainWhere(test);
    refresh();
  }
}

extension SetExtension<E> on Set<E> {
  RxSet<E> get obs {
    return RxSet<E>(<E>{})..addAll(this);
  }

  // /// Add [item] to [List<E>] only if [item] is not null.
  // void addNonNull(E item) {
  //   if (item != null) add(item);
  // }

  // /// Add [Iterable<E>] to [List<E>] only if [Iterable<E>] is not null.
  // void addAllNonNull(Iterable<E> item) {
  //   if (item != null) addAll(item);
  // }

  /// Add [item] to [List<E>] only if [condition] is true.
  void addIf(dynamic condition, E item) {
    if (condition is Condition) condition = condition();
    if (condition is bool && condition) add(item);
  }

  /// Adds [Iterable<E>] to [List<E>] only if [condition] is true.
  void addAllIf(dynamic condition, Iterable<E> items) {
    if (condition is Condition) condition = condition();
    if (condition is bool && condition) addAll(items);
  }

  /// Replaces all existing items of this list with [item]
  void assign(E item) {
    // if (this is RxSet) {
    //   (this as RxSet)._value;
    // }

    clear();
    add(item);
  }

  /// Replaces all existing items of this list with [items]
  void assignAll(Iterable<E> items) {
    // if (this is RxSet) {
    //   (this as RxSet)._value;
    // }
    clear();
    addAll(items);
  }
}


--- File Index 23: get_rx/src/rx_types/rx_core/rx_interface.dart ---
part of '../rx_types.dart';

/// This class is the foundation for all reactive (Rx) classes that makes Get
/// so powerful.
/// This interface is the contract that `_RxImpl<T>` uses in all it's
/// subclass.
abstract class RxInterface<T> implements ValueListenable<T> {
  /// Close the Rx Variable
  void close();

  /// Calls `callback` with current value, when the value changes.
  StreamSubscription<T> listen(void Function(T event) onData,
      {Function? onError, void Function()? onDone, bool? cancelOnError});
}

class ObxError {
  const ObxError();
  @override
  String toString() {
    return """
      [Get] the improper use of a GetX has been detected. 
      You should only use GetX or Obx for the specific widget that will be updated.
      If you are seeing this error, you probably did not insert any observable variables into GetX/Obx 
      or insert them outside the scope that GetX considers suitable for an update 
      (example: GetX => HeavyWidget => variableObservable).
      If you need to update a parent widget and a child widget, wrap each one in an Obx/GetX.
      """;
  }
}


--- File Index 24: get_rx/src/rx_types/rx_core/rx_impl.dart ---
part of '../rx_types.dart';

/// global object that registers against `GetX` and `Obx`, and allows the
/// reactivity
/// of those `Widgets` and Rx values.

mixin RxObjectMixin<T> on GetListenable<T> {
  //late T _value;

  /// Makes a direct update of [value] adding it to the Stream
  /// useful when you make use of Rx for custom Types to refresh your UI.
  ///
  /// Sample:
  /// ```
  ///  class Person {
  ///     String name, last;
  ///     int age;
  ///     Person({this.name, this.last, this.age});
  ///     @override
  ///     String toString() => '$name $last, $age years old';
  ///  }
  ///
  /// final person = Person(name: 'John', last: 'Doe', age: 18).obs;
  /// person.value.name = 'Roi';
  /// person.refresh();
  /// print( person );
  /// ```
  // void refresh() {
  //   subject.add(value);
  // }

  /// updates the value to `null` and adds it to the Stream.
  /// Even with null-safety coming, is still an important feature to support, as
  /// `call()` doesn't accept `null` values. For instance,
  /// `InputDecoration.errorText` has to be null to not show the "error state".
  ///
  /// Sample:
  /// ```
  /// final inputError = ''.obs..nil();
  /// print('${inputError.runtimeType}: $inputError'); // outputs > RxString: null
  /// ```
  // void nil() {
  //   subject.add(_value = null);
  // }

  /// Makes this Rx looks like a function so you can update a new
  /// value using `rx(someOtherValue)`. Practical to assign the Rx directly
  /// to some Widget that has a signature ::onChange( value )
  ///
  /// Example:
  /// ```
  /// final myText = 'GetX rocks!'.obs;
  ///
  /// // in your Constructor, just to check it works :P
  /// ever( myText, print ) ;
  ///
  /// // in your build(BuildContext) {
  /// TextField(
  ///   onChanged: myText,
  /// ),
  ///```
  @override
  T call([T? v]) {
    if (v != null) {
      value = v;
    }
    return value;
  }

  bool firstRebuild = true;
  bool sentToStream = false;

  /// Same as `toString()` but using a getter.
  String get string => value.toString();

  @override
  String toString() => value.toString();

  /// Returns the json representation of `value`.
  dynamic toJson() => value;

  /// This equality override works for _RxImpl instances and the internal
  /// values.
  @override
  // ignore: avoid_equals_and_hash_code_on_mutable_classes
  bool operator ==(Object o) {
    // Todo, find a common implementation for the hashCode of different Types.
    if (o is T) return value == o;
    if (o is RxObjectMixin<T>) return value == o.value;
    return false;
  }

  @override
  // ignore: avoid_equals_and_hash_code_on_mutable_classes
  int get hashCode => value.hashCode;

  /// Updates the [value] and adds it to the stream, updating the observer
  /// Widget, only if it's different from the previous value.
  @override
  set value(T val) {
    if (isDisposed) return;
    sentToStream = false;
    if (value == val && !firstRebuild) return;
    firstRebuild = false;
    sentToStream = true;
    super.value = val;
  }

  /// Returns a [StreamSubscription] similar to [listen], but with the
  /// added benefit that it primes the stream with the current [value], rather
  /// than waiting for the next [value]. This should not be called in [onInit]
  /// or anywhere else during the build process.
  StreamSubscription<T> listenAndPump(void Function(T event) onData,
      {Function? onError, void Function()? onDone, bool? cancelOnError}) {
    final subscription = listen(
      onData,
      onError: onError,
      onDone: onDone,
      cancelOnError: cancelOnError,
    );

    subject.add(value);

    return subscription;
  }

  /// Binds an existing `Stream<T>` to this `Rx<T>` to keep the values in sync.
  /// You can bind multiple sources to update the value.
  /// Closing the subscription will happen automatically when the observer
  /// Widget (`GetX` or `Obx`) gets unmounted from the Widget tree.
  void bindStream(Stream<T> stream) {
    // final listSubscriptions =
    //     _subscriptions[subject] ??= <StreamSubscription>[];

    final sub = stream.listen((va) => value = va);
    reportAdd(sub.cancel);
  }
}

/// Base Rx class that manages all the stream logic for any Type.
abstract class _RxImpl<T> extends GetListenable<T> with RxObjectMixin<T> {
  _RxImpl(super.initial);

  void addError(Object error, [StackTrace? stackTrace]) {
    subject.addError(error, stackTrace);
  }

  Stream<R> map<R>(R Function(T? data) mapper) => stream.map(mapper);

  /// Uses a callback to update [value] internally, similar to [refresh],
  /// but provides the current value as the argument.
  /// Makes sense for custom Rx types (like Models).
  ///
  /// Sample:
  /// ```
  ///  class Person {
  ///     String name, last;
  ///     int age;
  ///     Person({this.name, this.last, this.age});
  ///     @override
  ///     String toString() => '$name $last, $age years old';
  ///  }
  ///
  /// final person = Person(name: 'John', last: 'Doe', age: 18).obs;
  /// person.update((person) {
  ///   person.name = 'Roi';
  /// });
  /// print( person );
  /// ```
  void update(T Function(T? val) fn) {
    value = fn(value);
    // subject.add(value);
  }

  /// Following certain practices on Rx data, we might want to react to certain
  /// listeners when a value has been provided, even if the value is the same.
  /// At the moment, we ignore part of the process if we `.call(value)` with
  /// the same value since it holds the value and there's no real
  /// need triggering the entire process for the same value inside, but
  /// there are other situations where we might be interested in
  /// triggering this.
  ///
  /// For example, supposed we have a `int seconds = 2` and we want to animate
  /// from invisible to visible a widget in two seconds:
  /// `RxEvent<int>.call(seconds);`
  /// then after a click happens, you want to call a `RxEvent<int>.call(seconds)`.
  /// By doing `call(seconds)`, if the value being held is the same,
  /// the listeners won't trigger, hence we need this new `trigger` function.
  /// This will refresh the listener of an AnimatedWidget and will keep
  /// the value if the Rx is kept in memory.
  /// Sample:
  /// ```
  /// Rx<Int> secondsRx = RxInt();
  /// secondsRx.listen((value) => print("$value seconds set"));
  ///
  /// secondsRx.call(2);      // This won't trigger any listener, since the value is the same
  /// secondsRx.trigger(2);   // This will trigger the listener independently from the value.
  /// ```
  ///
  void trigger(T v) {
    var firstRebuild = this.firstRebuild;
    value = v;
    // If it's not the first rebuild, the listeners have been called already
    // So we won't call them again.
    if (!firstRebuild && !sentToStream) {
      subject.add(v);
    }
  }
}

class RxBool extends Rx<bool> {
  RxBool(super.initial);
  @override
  String toString() {
    return value ? "true" : "false";
  }
}

class RxnBool extends Rx<bool?> {
  RxnBool([super.initial]);
  @override
  String toString() {
    return "$value";
  }
}

extension RxBoolExt on Rx<bool> {
  bool get isTrue => value;

  bool get isFalse => !isTrue;

  bool operator &(bool other) => other && value;

  bool operator |(bool other) => other || value;

  bool operator ^(bool other) => !other == value;

  /// Toggles the bool [value] between false and true.
  /// A shortcut for `flag.value = !flag.value;`
  void toggle() {
    call(!value);
    // return this;
  }
}

extension RxnBoolExt on Rx<bool?> {
  bool? get isTrue => value;

  bool? get isFalse {
    if (value != null) return !isTrue!;
    return null;
  }

  bool? operator &(bool other) {
    if (value != null) {
      return other && value!;
    }
    return null;
  }

  bool? operator |(bool other) {
    if (value != null) {
      return other || value!;
    }
    return null;
  }

  bool? operator ^(bool other) => !other == value;

  /// Toggles the bool [value] between false and true.
  /// A shortcut for `flag.value = !flag.value;`
  void toggle() {
    if (value != null) {
      call(!value!);
      // return this;
    }
  }
}

/// Foundation class used for custom `Types` outside the common native Dart
/// types.
/// For example, any custom "Model" class, like User().obs will use `Rx` as
/// wrapper.
class Rx<T> extends _RxImpl<T> {
  Rx(super.initial);

  @override
  dynamic toJson() {
    try {
      return (value as dynamic)?.toJson();
    } on Exception catch (_) {
      throw '$T has not method [toJson]';
    }
  }
}

class Rxn<T> extends Rx<T?> {
  Rxn([super.initial]);

  @override
  dynamic toJson() {
    try {
      return (value as dynamic)?.toJson();
    } on Exception catch (_) {
      throw '$T has not method [toJson]';
    }
  }
}

extension StringExtension on String {
  /// Returns a `RxString` with [this] `String` as initial value.
  RxString get obs => RxString(this);
}

extension IntExtension on int {
  /// Returns a `RxInt` with [this] `int` as initial value.
  RxInt get obs => RxInt(this);
}

extension DoubleExtension on double {
  /// Returns a `RxDouble` with [this] `double` as initial value.
  RxDouble get obs => RxDouble(this);
}

extension BoolExtension on bool {
  /// Returns a `RxBool` with [this] `bool` as initial value.
  RxBool get obs => RxBool(this);
}

extension RxT<T extends Object> on T {
  /// Returns a `Rx` instance with [this] `T` as initial value.
  Rx<T> get obs => Rx<T>(this);
}

/// This method will replace the old `.obs` method.
/// It's a breaking change, but it is essential to avoid conflicts with
/// the new dart 3 features. T will be inferred by contextual type inference
/// rather than the extension type.
extension RxTnew on Object {
  /// Returns a `Rx` instance with [this] `T` as initial value.
  Rx<T> obs<T>() => Rx<T>(this as T);
}


--- File Index 25: get_rx/src/rx_types/rx_core/rx_num.dart ---
part of '../rx_types.dart';

extension RxNumExt<T extends num> on Rx<T> {
  /// Multiplication operator.
  num operator *(num other) => value * other;

  /// Euclidean modulo operator.
  ///
  /// Returns the remainder of the Euclidean division. The Euclidean division of
  /// two integers `a` and `b` yields two integers `q` and `r` such that
  /// `a == b * q + r` and `0 <= r < b.abs()`.
  ///
  /// The Euclidean division is only defined for integers, but can be easily
  /// extended to work with doubles. In that case `r` may have a non-integer
  /// value, but it still verifies `0 <= r < |b|`.
  ///
  /// The sign of the returned value `r` is always positive.
  ///
  /// See [remainder] for the remainder of the truncating division.
  num operator %(num other) => value % other;

  /// Division operator.
  double operator /(num other) => value / other;

  /// Truncating division operator.
  ///
  /// If either operand is a [double] then the result of the truncating division
  /// `a ~/ b` is equivalent to `(a / b).truncate().toInt()`.
  ///
  /// If both operands are [int]s then `a ~/ b` performs the truncating
  /// integer division.
  int operator ~/(num other) => value ~/ other;

  /// Negate operator.
  num operator -() => -value;

  /// Returns the remainder of the truncating division of `this` by [other].
  ///
  /// The result `r` of this operation satisfies:
  /// `this == (this ~/ other) * other + r`.
  /// As a consequence the remainder `r` has the same sign as the divider
  /// `this`.
  num remainder(num other) => value.remainder(other);

  /// Relational less than operator.
  bool operator <(num other) => value < other;

  /// Relational less than or equal operator.
  bool operator <=(num other) => value <= other;

  /// Relational greater than operator.
  bool operator >(num other) => value > other;

  /// Relational greater than or equal operator.
  bool operator >=(num other) => value >= other;

  /// True if the number is the double Not-a-Number value; otherwise, false.
  bool get isNaN => value.isNaN;

  /// True if the number is negative; otherwise, false.
  ///
  /// Negative numbers are those less than zero, and the double `-0.0`.
  bool get isNegative => value.isNegative;

  /// True if the number is positive infinity or negative infinity; otherwise,
  /// false.
  bool get isInfinite => value.isInfinite;

  /// True if the number is finite; otherwise, false.
  ///
  /// The only non-finite numbers are NaN, positive infinity, and
  /// negative infinity.
  bool get isFinite => value.isFinite;

  /// Returns the absolute value of this [num].
  num abs() => value.abs();

  /// Returns minus one, zero or plus one depending on the sign and
  /// numerical value of the number.
  ///
  /// Returns minus one if the number is less than zero,
  /// plus one if the number is greater than zero,
  /// and zero if the number is equal to zero.
  ///
  /// Returns NaN if the number is the double NaN value.
  ///
  /// Returns a number of the same type as this number.
  /// For doubles, `-0.0.sign == -0.0`.
  /// The result satisfies:
  ///
  ///     n == n.sign * n.abs()
  ///
  /// for all numbers `n` (except NaN, because NaN isn't `==` to itself).
  num get sign => value.sign;

  /// Returns the integer closest to `this`.
  ///
  /// Rounds away from zero when there is no closest integer:
  ///  `(3.5).round() == 4` and `(-3.5).round() == -4`.
  ///
  /// If `this` is not finite (`NaN` or infinity), throws an [UnsupportedError].
  int round() => value.round();

  /// Returns the greatest integer no greater than `this`.
  ///
  /// If `this` is not finite (`NaN` or infinity), throws an [UnsupportedError].
  int floor() => value.floor();

  /// Returns the least integer no smaller than `this`.
  ///
  /// If `this` is not finite (`NaN` or infinity), throws an [UnsupportedError].
  int ceil() => value.ceil();

  /// Returns the integer obtained by discarding any fractional
  /// digits from `this`.
  ///
  /// If `this` is not finite (`NaN` or infinity), throws an [UnsupportedError].
  int truncate() => value.truncate();

  /// Returns the double integer value closest to `this`.
  ///
  /// Rounds away from zero when there is no closest integer:
  ///  `(3.5).roundToDouble() == 4` and `(-3.5).roundToDouble() == -4`.
  ///
  /// If this is already an integer valued double, including `-0.0`, or it is a
  /// non-finite double value, the value is returned unmodified.
  ///
  /// For the purpose of rounding, `-0.0` is considered to be below `0.0`,
  /// and `-0.0` is therefore considered closer to negative numbers than `0.0`.
  /// This means that for a value, `d` in the range `-0.5 < d < 0.0`,
  /// the result is `-0.0`.
  ///
  /// The result is always a double.
  /// If this is a numerically large integer, the result may be an infinite
  /// double.
  double roundToDouble() => value.roundToDouble();

  /// Returns the greatest double integer value no greater than `this`.
  ///
  /// If this is already an integer valued double, including `-0.0`, or it is a
  /// non-finite double value, the value is returned unmodified.
  ///
  /// For the purpose of rounding, `-0.0` is considered to be below `0.0`.
  /// A number `d` in the range `0.0 < d < 1.0` will return `0.0`.
  ///
  /// The result is always a double.
  /// If this is a numerically large integer, the result may be an infinite
  /// double.
  double floorToDouble() => value.floorToDouble();

  /// Returns the least double integer value no smaller than `this`.
  ///
  /// If this is already an integer valued double, including `-0.0`, or it is a
  /// non-finite double value, the value is returned unmodified.
  ///
  /// For the purpose of rounding, `-0.0` is considered to be below `0.0`.
  /// A number `d` in the range `-1.0 < d < 0.0` will return `-0.0`.
  ///
  /// The result is always a double.
  /// If this is a numerically large integer, the result may be an infinite
  /// double.
  double ceilToDouble() => value.ceilToDouble();

  /// Returns the double integer value obtained by discarding any fractional
  /// digits from the double value of `this`.
  ///
  /// If this is already an integer valued double, including `-0.0`, or it is a
  /// non-finite double value, the value is returned unmodified.
  ///
  /// For the purpose of rounding, `-0.0` is considered to be below `0.0`.
  /// A number `d` in the range `-1.0 < d < 0.0` will return `-0.0`, and
  /// in the range `0.0 < d < 1.0` it will return 0.0.
  ///
  /// The result is always a double.
  /// If this is a numerically large integer, the result may be an infinite
  /// double.
  double truncateToDouble() => value.truncateToDouble();

  /// Returns this [num] clamped to be in the range [lowerLimit]-[upperLimit].
  ///
  /// The comparison is done using [compareTo] and therefore takes `-0.0` into
  /// account. This also implies that [double.nan] is treated as the maximal
  /// double value.
  ///
  /// The arguments [lowerLimit] and [upperLimit] must form a valid range where
  /// `lowerLimit.compareTo(upperLimit) <= 0`.
  num clamp(num lowerLimit, num upperLimit) =>
      value.clamp(lowerLimit, upperLimit);

  /// Truncates this [num] to an integer and returns the result as an [int]. */
  int toInt() => value.toInt();

  /// Return this [num] as a [double].
  ///
  /// If the number is not representable as a [double], an
  /// approximation is returned. For numerically large integers, the
  /// approximation may be infinite.
  double toDouble() => value.toDouble();

  /// Returns a decimal-point string-representation of `this`.
  ///
  /// Converts `this` to a [double] before computing the string representation.
  ///
  /// If the absolute value of `this` is greater or equal to `10^21` then this
  /// methods returns an exponential representation computed by
  /// `this.toStringAsExponential()`. Otherwise the result
  /// is the closest string representation with exactly [fractionDigits] digits
  /// after the decimal point. If [fractionDigits] equals 0 then the decimal
  /// point is omitted.
  ///
  /// The parameter [fractionDigits] must be an integer satisfying:
  /// `0 <= fractionDigits <= 20`.
  ///
  /// Examples:
  ///
  ///     1.toStringAsFixed(3);  // 1.000
  ///     (4321.12345678).toStringAsFixed(3);  // 4321.123
  ///     (4321.12345678).toStringAsFixed(5);  // 4321.12346
  ///     123456789012345.toStringAsFixed(3);  // 123456789012345.000
  ///     10000000000000000.toStringAsFixed(4); // 10000000000000000.0000
  ///     5.25.toStringAsFixed(0); // 5
  String toStringAsFixed(int fractionDigits) =>
      value.toStringAsFixed(fractionDigits);

  /// Returns an exponential string-representation of `this`.
  ///
  /// Converts `this` to a [double] before computing the string representation.
  ///
  /// If [fractionDigits] is given then it must be an integer satisfying:
  /// `0 <= fractionDigits <= 20`. In this case the string contains exactly
  /// [fractionDigits] after the decimal point. Otherwise, without the
  /// parameter, the returned string uses the shortest number of digits that
  /// accurately represent [this].
  ///
  /// If [fractionDigits] equals 0 then the decimal point is omitted.
  /// Examples:
  ///
  ///     1.toStringAsExponential();       // 1e+0
  ///     1.toStringAsExponential(3);      // 1.000e+0
  ///     123456.toStringAsExponential();  // 1.23456e+5
  ///     123456.toStringAsExponential(3); // 1.235e+5
  ///     123.toStringAsExponential(0);    // 1e+2
  String toStringAsExponential([int? fractionDigits]) =>
      value.toStringAsExponential(fractionDigits);

  /// Converts `this` to a double and returns a string representation with
  /// exactly [precision] significant digits.
  ///
  /// The parameter [precision] must be an integer satisfying:
  /// `1 <= precision <= 21`.
  ///
  /// Examples:
  ///
  ///     1.toStringAsPrecision(2);       // 1.0
  ///     1e15.toStringAsPrecision(3);    // 1.00e+15
  ///     1234567.toStringAsPrecision(3); // 1.23e+6
  ///     1234567.toStringAsPrecision(9); // 1234567.00
  ///     12345678901234567890.toStringAsPrecision(20); // 12345678901234567168
  ///     12345678901234567890.toStringAsPrecision(14); // 1.2345678901235e+19
  ///     0.00000012345.toStringAsPrecision(15); // 1.23450000000000e-7
  ///     0.0000012345.toStringAsPrecision(15);  // 0.00000123450000000000
  String toStringAsPrecision(int precision) =>
      value.toStringAsPrecision(precision);
}

extension RxnNumExt<T extends num> on Rx<T?> {
  /// Multiplication operator.
  num? operator *(num other) {
    if (value != null) {
      return value! * other;
    }
    return null;
  }

  /// Euclidean modulo operator.
  ///
  /// Returns the remainder of the Euclidean division. The Euclidean division of
  /// two integers `a` and `b` yields two integers `q` and `r` such that
  /// `a == b * q + r` and `0 <= r < b.abs()`.
  ///
  /// The Euclidean division is only defined for integers, but can be easily
  /// extended to work with doubles. In that case `r` may have a non-integer
  /// value, but it still verifies `0 <= r < |b|`.
  ///
  /// The sign of the returned value `r` is always positive.
  ///
  /// See [remainder] for the remainder of the truncating division.
  num? operator %(num other) {
    if (value != null) {
      return value! % other;
    }
    return null;
  }

  /// Division operator.
  double? operator /(num other) {
    if (value != null) {
      return value! / other;
    }
    return null;
  }

  /// Truncating division operator.
  ///
  /// If either operand is a [double] then the result of the truncating division
  /// `a ~/ b` is equivalent to `(a / b).truncate().toInt()`.
  ///
  /// If both operands are [int]s then `a ~/ b` performs the truncating
  /// integer division.
  int? operator ~/(num other) {
    if (value != null) {
      return value! ~/ other;
    }
    return null;
  }

  /// Negate operator.
  num? operator -() {
    if (value != null) {
      return -value!;
    }
    return null;
  }

  /// Returns the remainder of the truncating division of `this` by [other].
  ///
  /// The result `r` of this operation satisfies:
  /// `this == (this ~/ other) * other + r`.
  /// As a consequence the remainder `r` has the same sign as the divider
  /// `this`.
  num? remainder(num other) => value?.remainder(other);

  /// Relational less than operator.
  bool? operator <(num other) {
    if (value != null) {
      return value! < other;
    }
    return null;
  }

  /// Relational less than or equal operator.
  bool? operator <=(num other) {
    if (value != null) {
      return value! <= other;
    }
    return null;
  }

  /// Relational greater than operator.
  bool? operator >(num other) {
    if (value != null) {
      return value! > other;
    }
    return null;
  }

  /// Relational greater than or equal operator.
  bool? operator >=(num other) {
    if (value != null) {
      return value! >= other;
    }
    return null;
  }

  /// True if the number is the double Not-a-Number value; otherwise, false.
  bool? get isNaN => value?.isNaN;

  /// True if the number is negative; otherwise, false.
  ///
  /// Negative numbers are those less than zero, and the double `-0.0`.
  bool? get isNegative => value?.isNegative;

  /// True if the number is positive infinity or negative infinity; otherwise,
  /// false.
  bool? get isInfinite => value?.isInfinite;

  /// True if the number is finite; otherwise, false.
  ///
  /// The only non-finite numbers are NaN, positive infinity, and
  /// negative infinity.
  bool? get isFinite => value?.isFinite;

  /// Returns the absolute value of this [num].
  num? abs() => value?.abs();

  /// Returns minus one, zero or plus one depending on the sign and
  /// numerical value of the number.
  ///
  /// Returns minus one if the number is less than zero,
  /// plus one if the number is greater than zero,
  /// and zero if the number is equal to zero.
  ///
  /// Returns NaN if the number is the double NaN value.
  ///
  /// Returns a number of the same type as this number.
  /// For doubles, `-0.0.sign == -0.0`.
  /// The result satisfies:
  ///
  ///     n == n.sign * n.abs()
  ///
  /// for all numbers `n` (except NaN, because NaN isn't `==` to itself).
  num? get sign => value?.sign;

  /// Returns the integer closest to `this`.
  ///
  /// Rounds away from zero when there is no closest integer:
  ///  `(3.5).round() == 4` and `(-3.5).round() == -4`.
  ///
  /// If `this` is not finite (`NaN` or infinity), throws an [UnsupportedError].
  int? round() => value?.round();

  /// Returns the greatest integer no greater than `this`.
  ///
  /// If `this` is not finite (`NaN` or infinity), throws an [UnsupportedError].
  int? floor() => value?.floor();

  /// Returns the least integer no smaller than `this`.
  ///
  /// If `this` is not finite (`NaN` or infinity), throws an [UnsupportedError].
  int? ceil() => value?.ceil();

  /// Returns the integer obtained by discarding any fractional
  /// digits from `this`.
  ///
  /// If `this` is not finite (`NaN` or infinity), throws an [UnsupportedError].
  int? truncate() => value?.truncate();

  /// Returns the double integer value closest to `this`.
  ///
  /// Rounds away from zero when there is no closest integer:
  ///  `(3.5).roundToDouble() == 4` and `(-3.5).roundToDouble() == -4`.
  ///
  /// If this is already an integer valued double, including `-0.0`, or it is a
  /// non-finite double value, the value is returned unmodified.
  ///
  /// For the purpose of rounding, `-0.0` is considered to be below `0.0`,
  /// and `-0.0` is therefore considered closer to negative numbers than `0.0`.
  /// This means that for a value, `d` in the range `-0.5 < d < 0.0`,
  /// the result is `-0.0`.
  ///
  /// The result is always a double.
  /// If this is a numerically large integer, the result may be an infinite
  /// double.
  double? roundToDouble() => value?.roundToDouble();

  /// Returns the greatest double integer value no greater than `this`.
  ///
  /// If this is already an integer valued double, including `-0.0`, or it is a
  /// non-finite double value, the value is returned unmodified.
  ///
  /// For the purpose of rounding, `-0.0` is considered to be below `0.0`.
  /// A number `d` in the range `0.0 < d < 1.0` will return `0.0`.
  ///
  /// The result is always a double.
  /// If this is a numerically large integer, the result may be an infinite
  /// double.
  double? floorToDouble() => value?.floorToDouble();

  /// Returns the least double integer value no smaller than `this`.
  ///
  /// If this is already an integer valued double, including `-0.0`, or it is a
  /// non-finite double value, the value is returned unmodified.
  ///
  /// For the purpose of rounding, `-0.0` is considered to be below `0.0`.
  /// A number `d` in the range `-1.0 < d < 0.0` will return `-0.0`.
  ///
  /// The result is always a double.
  /// If this is a numerically large integer, the result may be an infinite
  /// double.
  double? ceilToDouble() => value?.ceilToDouble();

  /// Returns the double integer value obtained by discarding any fractional
  /// digits from the double value of `this`.
  ///
  /// If this is already an integer valued double, including `-0.0`, or it is a
  /// non-finite double value, the value is returned unmodified.
  ///
  /// For the purpose of rounding, `-0.0` is considered to be below `0.0`.
  /// A number `d` in the range `-1.0 < d < 0.0` will return `-0.0`, and
  /// in the range `0.0 < d < 1.0` it will return 0.0.
  ///
  /// The result is always a double.
  /// If this is a numerically large integer, the result may be an infinite
  /// double.
  double? truncateToDouble() => value?.truncateToDouble();

  /// Returns this [num] clamped to be in the range [lowerLimit]-[upperLimit].
  ///
  /// The comparison is done using [compareTo] and therefore takes `-0.0` into
  /// account. This also implies that [double.nan] is treated as the maximal
  /// double value.
  ///
  /// The arguments [lowerLimit] and [upperLimit] must form a valid range where
  /// `lowerLimit.compareTo(upperLimit) <= 0`.
  num? clamp(num lowerLimit, num upperLimit) =>
      value?.clamp(lowerLimit, upperLimit);

  /// Truncates this [num] to an integer and returns the result as an [int]. */
  int? toInt() => value?.toInt();

  /// Return this [num] as a [double].
  ///
  /// If the number is not representable as a [double], an
  /// approximation is returned. For numerically large integers, the
  /// approximation may be infinite.
  double? toDouble() => value?.toDouble();

  /// Returns a decimal-point string-representation of `this`.
  ///
  /// Converts `this` to a [double] before computing the string representation.
  ///
  /// If the absolute value of `this` is greater or equal to `10^21` then this
  /// methods returns an exponential representation computed by
  /// `this.toStringAsExponential()`. Otherwise the result
  /// is the closest string representation with exactly [fractionDigits] digits
  /// after the decimal point. If [fractionDigits] equals 0 then the decimal
  /// point is omitted.
  ///
  /// The parameter [fractionDigits] must be an integer satisfying:
  /// `0 <= fractionDigits <= 20`.
  ///
  /// Examples:
  ///
  ///     1.toStringAsFixed(3);  // 1.000
  ///     (4321.12345678).toStringAsFixed(3);  // 4321.123
  ///     (4321.12345678).toStringAsFixed(5);  // 4321.12346
  ///     123456789012345.toStringAsFixed(3);  // 123456789012345.000
  ///     10000000000000000.toStringAsFixed(4); // 10000000000000000.0000
  ///     5.25.toStringAsFixed(0); // 5
  String? toStringAsFixed(int fractionDigits) =>
      value?.toStringAsFixed(fractionDigits);

  /// Returns an exponential string-representation of `this`.
  ///
  /// Converts `this` to a [double] before computing the string representation.
  ///
  /// If [fractionDigits] is given then it must be an integer satisfying:
  /// `0 <= fractionDigits <= 20`. In this case the string contains exactly
  /// [fractionDigits] after the decimal point. Otherwise, without the
  /// parameter, the returned string uses the shortest number of digits that
  /// accurately represent [this].
  ///
  /// If [fractionDigits] equals 0 then the decimal point is omitted.
  /// Examples:
  ///
  ///     1.toStringAsExponential();       // 1e+0
  ///     1.toStringAsExponential(3);      // 1.000e+0
  ///     123456.toStringAsExponential();  // 1.23456e+5
  ///     123456.toStringAsExponential(3); // 1.235e+5
  ///     123.toStringAsExponential(0);    // 1e+2
  String? toStringAsExponential([int? fractionDigits]) =>
      value?.toStringAsExponential(fractionDigits);

  /// Converts `this` to a double and returns a string representation with
  /// exactly [precision] significant digits.
  ///
  /// The parameter [precision] must be an integer satisfying:
  /// `1 <= precision <= 21`.
  ///
  /// Examples:
  ///
  ///     1.toStringAsPrecision(2);       // 1.0
  ///     1e15.toStringAsPrecision(3);    // 1.00e+15
  ///     1234567.toStringAsPrecision(3); // 1.23e+6
  ///     1234567.toStringAsPrecision(9); // 1234567.00
  ///     12345678901234567890.toStringAsPrecision(20); // 12345678901234567168
  ///     12345678901234567890.toStringAsPrecision(14); // 1.2345678901235e+19
  ///     0.00000012345.toStringAsPrecision(15); // 1.23450000000000e-7
  ///     0.0000012345.toStringAsPrecision(15);  // 0.00000123450000000000
  String? toStringAsPrecision(int precision) =>
      value?.toStringAsPrecision(precision);
}

class RxNum extends Rx<num> {
  RxNum(super.initial);

  num operator +(num other) {
    value += other;
    return value;
  }

  /// Subtraction operator.
  num operator -(num other) {
    value -= other;
    return value;
  }
}

class RxnNum extends Rx<num?> {
  RxnNum([super.initial]);

  num? operator +(num other) {
    if (value != null) {
      value = value! + other;
      return value;
    }
    return null;
  }

  /// Subtraction operator.
  num? operator -(num other) {
    if (value != null) {
      value = value! - other;
      return value;
    }
    return null;
  }
}

extension RxDoubleExt on Rx<double> {
  /// Addition operator.
  Rx<double> operator +(num other) {
    value = value + other;
    return this;
  }

  /// Subtraction operator.
  Rx<double> operator -(num other) {
    value = value - other;
    return this;
  }

  /// Multiplication operator.
  double operator *(num other) => value * other;

  double operator %(num other) => value % other;

  /// Division operator.
  double operator /(num other) => value / other;

  /// Truncating division operator.
  ///
  /// The result of the truncating division `a ~/ b` is equivalent to
  /// `(a / b).truncate()`.
  int operator ~/(num other) => value ~/ other;

  /// Negate operator. */
  double operator -() => -value;

  /// Returns the absolute value of this [double].
  double abs() => value.abs();

  /// Returns the sign of the double's numerical value.
  ///
  /// Returns -1.0 if the value is less than zero,
  /// +1.0 if the value is greater than zero,
  /// and the value itself if it is -0.0, 0.0 or NaN.
  double get sign => value.sign;

  /// Returns the integer closest to `this`.
  ///
  /// Rounds away from zero when there is no closest integer:
  ///  `(3.5).round() == 4` and `(-3.5).round() == -4`.
  ///
  /// If `this` is not finite (`NaN` or infinity), throws an [UnsupportedError].
  int round() => value.round();

  /// Returns the greatest integer no greater than `this`.
  ///
  /// If `this` is not finite (`NaN` or infinity), throws an [UnsupportedError].
  int floor() => value.floor();

  /// Returns the least integer no smaller than `this`.
  ///
  /// If `this` is not finite (`NaN` or infinity), throws an [UnsupportedError].
  int ceil() => value.ceil();

  /// Returns the integer obtained by discarding any fractional
  /// digits from `this`.
  ///
  /// If `this` is not finite (`NaN` or infinity), throws an [UnsupportedError].
  int truncate() => value.truncate();

  /// Returns the integer double value closest to `this`.
  ///
  /// Rounds away from zero when there is no closest integer:
  ///  `(3.5).roundToDouble() == 4` and `(-3.5).roundToDouble() == -4`.
  ///
  /// If this is already an integer valued double, including `-0.0`, or it is
  /// not a finite value, the value is returned unmodified.
  ///
  /// For the purpose of rounding, `-0.0` is considered to be below `0.0`,
  /// and `-0.0` is therefore considered closer to negative numbers than `0.0`.
  /// This means that for a value, `d` in the range `-0.5 < d < 0.0`,
  /// the result is `-0.0`.
  double roundToDouble() => value.roundToDouble();

  /// Returns the greatest integer double value no greater than `this`.
  ///
  /// If this is already an integer valued double, including `-0.0`, or it is
  /// not a finite value, the value is returned unmodified.
  ///
  /// For the purpose of rounding, `-0.0` is considered to be below `0.0`.
  /// A number `d` in the range `0.0 < d < 1.0` will return `0.0`.
  double floorToDouble() => value.floorToDouble();

  /// Returns the least integer double value no smaller than `this`.
  ///
  /// If this is already an integer valued double, including `-0.0`, or it is
  /// not a finite value, the value is returned unmodified.
  ///
  /// For the purpose of rounding, `-0.0` is considered to be below `0.0`.
  /// A number `d` in the range `-1.0 < d < 0.0` will return `-0.0`.
  double ceilToDouble() => value.ceilToDouble();

  /// Returns the integer double value obtained by discarding any fractional
  /// digits from `this`.
  ///
  /// If this is already an integer valued double, including `-0.0`, or it is
  /// not a finite value, the value is returned unmodified.
  ///
  /// For the purpose of rounding, `-0.0` is considered to be below `0.0`.
  /// A number `d` in the range `-1.0 < d < 0.0` will return `-0.0`, and
  /// in the range `0.0 < d < 1.0` it will return 0.0.
  double truncateToDouble() => value.truncateToDouble();
}

extension RxnDoubleExt on Rx<double?> {
  /// Addition operator.
  Rx<double?>? operator +(num other) {
    if (value != null) {
      value = value! + other;
      return this;
    }
    return null;
  }

  /// Subtraction operator.
  Rx<double?>? operator -(num other) {
    if (value != null) {
      value = value! + other;
      return this;
    }
    return null;
  }

  /// Multiplication operator.
  double? operator *(num other) {
    if (value != null) {
      return value! * other;
    }
    return null;
  }

  double? operator %(num other) {
    if (value != null) {
      return value! % other;
    }
    return null;
  }

  /// Division operator.
  double? operator /(num other) {
    if (value != null) {
      return value! / other;
    }
    return null;
  }

  /// Truncating division operator.
  ///
  /// The result of the truncating division `a ~/ b` is equivalent to
  /// `(a / b).truncate()`.
  int? operator ~/(num other) {
    if (value != null) {
      return value! ~/ other;
    }
    return null;
  }

  /// Negate operator. */
  double? operator -() {
    if (value != null) {
      return -value!;
    }
    return null;
  }

  /// Returns the absolute value of this [double].
  double? abs() {
    return value?.abs();
  }

  /// Returns the sign of the double's numerical value.
  ///
  /// Returns -1.0 if the value is less than zero,
  /// +1.0 if the value is greater than zero,
  /// and the value itself if it is -0.0, 0.0 or NaN.
  double? get sign => value?.sign;

  /// Returns the integer closest to `this`.
  ///
  /// Rounds away from zero when there is no closest integer:
  ///  `(3.5).round() == 4` and `(-3.5).round() == -4`.
  ///
  /// If `this` is not finite (`NaN` or infinity), throws an [UnsupportedError].
  int? round() => value?.round();

  /// Returns the greatest integer no greater than `this`.
  ///
  /// If `this` is not finite (`NaN` or infinity), throws an [UnsupportedError].
  int? floor() => value?.floor();

  /// Returns the least integer no smaller than `this`.
  ///
  /// If `this` is not finite (`NaN` or infinity), throws an [UnsupportedError].
  int? ceil() => value?.ceil();

  /// Returns the integer obtained by discarding any fractional
  /// digits from `this`.
  ///
  /// If `this` is not finite (`NaN` or infinity), throws an [UnsupportedError].
  int? truncate() => value?.truncate();

  /// Returns the integer double value closest to `this`.
  ///
  /// Rounds away from zero when there is no closest integer:
  ///  `(3.5).roundToDouble() == 4` and `(-3.5).roundToDouble() == -4`.
  ///
  /// If this is already an integer valued double, including `-0.0`, or it is
  /// not a finite value, the value is returned unmodified.
  ///
  /// For the purpose of rounding, `-0.0` is considered to be below `0.0`,
  /// and `-0.0` is therefore considered closer to negative numbers than `0.0`.
  /// This means that for a value, `d` in the range `-0.5 < d < 0.0`,
  /// the result is `-0.0`.
  double? roundToDouble() => value?.roundToDouble();

  /// Returns the greatest integer double value no greater than `this`.
  ///
  /// If this is already an integer valued double, including `-0.0`, or it is
  /// not a finite value, the value is returned unmodified.
  ///
  /// For the purpose of rounding, `-0.0` is considered to be below `0.0`.
  /// A number `d` in the range `0.0 < d < 1.0` will return `0.0`.
  double? floorToDouble() => value?.floorToDouble();

  /// Returns the least integer double value no smaller than `this`.
  ///
  /// If this is already an integer valued double, including `-0.0`, or it is
  /// not a finite value, the value is returned unmodified.
  ///
  /// For the purpose of rounding, `-0.0` is considered to be below `0.0`.
  /// A number `d` in the range `-1.0 < d < 0.0` will return `-0.0`.
  double? ceilToDouble() => value?.ceilToDouble();

  /// Returns the integer double value obtained by discarding any fractional
  /// digits from `this`.
  ///
  /// If this is already an integer valued double, including `-0.0`, or it is
  /// not a finite value, the value is returned unmodified.
  ///
  /// For the purpose of rounding, `-0.0` is considered to be below `0.0`.
  /// A number `d` in the range `-1.0 < d < 0.0` will return `-0.0`, and
  /// in the range `0.0 < d < 1.0` it will return 0.0.
  double? truncateToDouble() => value?.truncateToDouble();
}

class RxDouble extends Rx<double> {
  RxDouble(super.initial);
}

class RxnDouble extends Rx<double?> {
  RxnDouble([super.initial]);
}

class RxInt extends Rx<int> {
  RxInt(super.initial);

  /// Addition operator.
  RxInt operator +(int other) {
    value = value + other;
    return this;
  }

  /// Subtraction operator.
  RxInt operator -(int other) {
    value = value - other;
    return this;
  }
}

class RxnInt extends Rx<int?> {
  RxnInt([super.initial]);

  /// Addition operator.
  RxnInt operator +(int other) {
    if (value != null) {
      value = value! + other;
    }
    return this;
  }

  /// Subtraction operator.
  RxnInt operator -(int other) {
    if (value != null) {
      value = value! - other;
    }
    return this;
  }
}

extension RxIntExt on Rx<int> {
  /// Bit-wise and operator.
  ///
  /// Treating both `this` and [other] as sufficiently large two's component
  /// integers, the result is a number with only the bits set that are set in
  /// both `this` and [other]
  ///
  /// If both operands are negative, the result is negative, otherwise
  /// the result is non-negative.
  int operator &(int other) => value & other;

  /// Bit-wise or operator.
  ///
  /// Treating both `this` and [other] as sufficiently large two's component
  /// integers, the result is a number with the bits set that are set in either
  /// of `this` and [other]
  ///
  /// If both operands are non-negative, the result is non-negative,
  /// otherwise the result is negative.
  int operator |(int other) => value | other;

  /// Bit-wise exclusive-or operator.
  ///
  /// Treating both `this` and [other] as sufficiently large two's component
  /// integers, the result is a number with the bits set that are set in one,
  /// but not both, of `this` and [other]
  ///
  /// If the operands have the same sign, the result is non-negative,
  /// otherwise the result is negative.
  int operator ^(int other) => value ^ other;

  /// The bit-wise negate operator.
  ///
  /// Treating `this` as a sufficiently large two's component integer,
  /// the result is a number with the opposite bits set.
  ///
  /// This maps any integer `x` to `-x - 1`.
  int operator ~() => ~value;

  /// Shift the bits of this integer to the left by [shiftAmount].
  ///
  /// Shifting to the left makes the number larger, effectively multiplying
  /// the number by `pow(2, shiftIndex)`.
  ///
  /// There is no limit on the size of the result. It may be relevant to
  /// limit intermediate values by using the "and" operator with a suitable
  /// mask.
  ///
  /// It is an error if [shiftAmount] is negative.
  int operator <<(int shiftAmount) => value << shiftAmount;

  /// Shift the bits of this integer to the right by [shiftAmount].
  ///
  /// Shifting to the right makes the number smaller and drops the least
  /// significant bits, effectively doing an integer division by
  ///`pow(2, shiftIndex)`.
  ///
  /// It is an error if [shiftAmount] is negative.
  int operator >>(int shiftAmount) => value >> shiftAmount;

  /// Returns this integer to the power of [exponent] modulo [modulus].
  ///
  /// The [exponent] must be non-negative and [modulus] must be
  /// positive.
  int modPow(int exponent, int modulus) => value.modPow(exponent, modulus);

  /// Returns the modular multiplicative inverse of this integer
  /// modulo [modulus].
  ///
  /// The [modulus] must be positive.
  ///
  /// It is an error if no modular inverse exists.
  int modInverse(int modulus) => value.modInverse(modulus);

  /// Returns the greatest common divisor of this integer and [other].
  ///
  /// If either number is non-zero, the result is the numerically greatest
  /// integer dividing both `this` and `other`.
  ///
  /// The greatest common divisor is independent of the order,
  /// so `x.gcd(y)` is  always the same as `y.gcd(x)`.
  ///
  /// For any integer `x`, `x.gcd(x)` is `x.abs()`.
  ///
  /// If both `this` and `other` is zero, the result is also zero.
  int gcd(int other) => value.gcd(other);

  /// Returns true if and only if this integer is even.
  bool get isEven => value.isEven;

  /// Returns true if and only if this integer is odd.
  bool get isOdd => value.isOdd;

  /// Returns the minimum number of bits required to store this integer.
  ///
  /// The number of bits excludes the sign bit, which gives the natural length
  /// for non-negative (unsigned) values.  Negative values are complemented to
  /// return the bit position of the first bit that differs from the sign bit.
  ///
  /// To find the number of bits needed to store the value as a signed value,
  /// add one, i.e. use `x.bitLength + 1`.
  /// ```
  /// x.bitLength == (-x-1).bitLength
  ///
  /// 3.bitLength == 2;     // 00000011
  /// 2.bitLength == 2;     // 00000010
  /// 1.bitLength == 1;     // 00000001
  /// 0.bitLength == 0;     // 00000000
  /// (-1).bitLength == 0;  // 11111111
  /// (-2).bitLength == 1;  // 11111110
  /// (-3).bitLength == 2;  // 11111101
  /// (-4).bitLength == 2;  // 11111100
  /// ```
  int get bitLength => value.bitLength;

  /// Returns the least significant [width] bits of this integer as a
  /// non-negative number (i.e. unsigned representation).  The returned value
  /// has zeros in all bit positions higher than [width].
  /// ```
  /// (-1).toUnsigned(5) == 31   // 11111111  ->  00011111
  /// ```
  /// This operation can be used to simulate arithmetic from low level
  /// languages.
  /// For example, to increment an 8 bit quantity:
  /// ```
  /// q = (q + 1).toUnsigned(8);
  /// ```
  /// `q` will count from `0` up to `255` and then wrap around to `0`.
  ///
  /// If the input fits in [width] bits without truncation, the result is the
  /// same as the input.  The minimum width needed to avoid truncation of `x` is
  /// given by `x.bitLength`, i.e.
  /// ```
  /// x == x.toUnsigned(x.bitLength);
  /// ```
  int toUnsigned(int width) => value.toUnsigned(width);

  /// Returns the least significant [width] bits of this integer, extending the
  /// highest retained bit to the sign.  This is the same as truncating the
  /// value to fit in [width] bits using an signed 2-s complement
  /// representation.
  /// The returned value has the same bit value in all positions higher than
  /// [width].
  ///
  /// ```
  ///                                V--sign bit-V
  /// 16.toSigned(5) == -16   //  00010000 -> 11110000
  /// 239.toSigned(5) == 15   //  11101111 -> 00001111
  ///                                ^           ^
  /// ```
  /// This operation can be used to simulate arithmetic from low level
  /// languages.
  /// For example, to increment an 8 bit signed quantity:
  /// ```
  /// q = (q + 1).toSigned(8);
  /// ```
  /// `q` will count from `0` up to `127`, wrap to `-128` and count back up to
  /// `127`.
  ///
  /// If the input value fits in [width] bits without truncation, the result is
  /// the same as the input.  The minimum width needed to avoid truncation
  /// of `x` is `x.bitLength + 1`, i.e.
  /// ```
  /// x == x.toSigned(x.bitLength + 1);
  /// ```
  int toSigned(int width) => value.toSigned(width);

  /// Return the negative value of this integer.
  ///
  /// The result of negating an integer always has the opposite sign, except
  /// for zero, which is its own negation.
  int operator -() => -value;

  /// Returns the absolute value of this integer.
  ///
  /// For any integer `x`, the result is the same as `x < 0 ? -x : x`.
  int abs() => value.abs();

  /// Returns the sign of this integer.
  ///
  /// Returns 0 for zero, -1 for values less than zero and
  /// +1 for values greater than zero.
  int get sign => value.sign;

  /// Returns `this`.
  int round() => value.round();

  /// Returns `this`.
  int floor() => value.floor();

  /// Returns `this`.
  int ceil() => value.ceil();

  /// Returns `this`.
  int truncate() => value.truncate();

  /// Returns `this.toDouble()`.
  double roundToDouble() => value.roundToDouble();

  /// Returns `this.toDouble()`.
  double floorToDouble() => value.floorToDouble();

  /// Returns `this.toDouble()`.
  double ceilToDouble() => value.ceilToDouble();

  /// Returns `this.toDouble()`.
  double truncateToDouble() => value.truncateToDouble();
}

extension RxnIntExt on Rx<int?> {
  /// Bit-wise and operator.
  ///
  /// Treating both `this` and [other] as sufficiently large two's component
  /// integers, the result is a number with only the bits set that are set in
  /// both `this` and [other]
  ///
  /// If both operands are negative, the result is negative, otherwise
  /// the result is non-negative.
  int? operator &(int other) {
    if (value != null) {
      return value! & other;
    }
    return null;
  }

  /// Bit-wise or operator.
  ///
  /// Treating both `this` and [other] as sufficiently large two's component
  /// integers, the result is a number with the bits set that are set in either
  /// of `this` and [other]
  ///
  /// If both operands are non-negative, the result is non-negative,
  /// otherwise the result is negative.
  int? operator |(int other) {
    if (value != null) {
      return value! | other;
    }
    return null;
  }

  /// Bit-wise exclusive-or operator.
  ///
  /// Treating both `this` and [other] as sufficiently large two's component
  /// integers, the result is a number with the bits set that are set in one,
  /// but not both, of `this` and [other]
  ///
  /// If the operands have the same sign, the result is non-negative,
  /// otherwise the result is negative.
  int? operator ^(int other) {
    if (value != null) {
      return value! ^ other;
    }
    return null;
  }

  /// The bit-wise negate operator.
  ///
  /// Treating `this` as a sufficiently large two's component integer,
  /// the result is a number with the opposite bits set.
  ///
  /// This maps any integer `x` to `-x - 1`.
  int? operator ~() {
    if (value != null) {
      return ~value!;
    }
    return null;
  }

  /// Shift the bits of this integer to the left by [shiftAmount].
  ///
  /// Shifting to the left makes the number larger, effectively multiplying
  /// the number by `pow(2, shiftIndex)`.
  ///
  /// There is no limit on the size of the result. It may be relevant to
  /// limit intermediate values by using the "and" operator with a suitable
  /// mask.
  ///
  /// It is an error if [shiftAmount] is negative.
  int? operator <<(int shiftAmount) {
    if (value != null) {
      return value! << shiftAmount;
    }
    return null;
  }

  /// Shift the bits of this integer to the right by [shiftAmount].
  ///
  /// Shifting to the right makes the number smaller and drops the least
  /// significant bits, effectively doing an integer division by
  ///`pow(2, shiftIndex)`.
  ///
  /// It is an error if [shiftAmount] is negative.
  int? operator >>(int shiftAmount) {
    if (value != null) {
      return value! >> shiftAmount;
    }
    return null;
  }

  /// Returns this integer to the power of [exponent] modulo [modulus].
  ///
  /// The [exponent] must be non-negative and [modulus] must be
  /// positive.
  int? modPow(int exponent, int modulus) => value?.modPow(exponent, modulus);

  /// Returns the modular multiplicative inverse of this integer
  /// modulo [modulus].
  ///
  /// The [modulus] must be positive.
  ///
  /// It is an error if no modular inverse exists.
  int? modInverse(int modulus) => value?.modInverse(modulus);

  /// Returns the greatest common divisor of this integer and [other].
  ///
  /// If either number is non-zero, the result is the numerically greatest
  /// integer dividing both `this` and `other`.
  ///
  /// The greatest common divisor is independent of the order,
  /// so `x.gcd(y)` is  always the same as `y.gcd(x)`.
  ///
  /// For any integer `x`, `x.gcd(x)` is `x.abs()`.
  ///
  /// If both `this` and `other` is zero, the result is also zero.
  int? gcd(int other) => value?.gcd(other);

  /// Returns true if and only if this integer is even.
  bool? get isEven => value?.isEven;

  /// Returns true if and only if this integer is odd.
  bool? get isOdd => value?.isOdd;

  /// Returns the minimum number of bits required to store this integer.
  ///
  /// The number of bits excludes the sign bit, which gives the natural length
  /// for non-negative (unsigned) values.  Negative values are complemented to
  /// return the bit position of the first bit that differs from the sign bit.
  ///
  /// To find the number of bits needed to store the value as a signed value,
  /// add one, i.e. use `x.bitLength + 1`.
  /// ```
  /// x.bitLength == (-x-1).bitLength
  ///
  /// 3.bitLength == 2;     // 00000011
  /// 2.bitLength == 2;     // 00000010
  /// 1.bitLength == 1;     // 00000001
  /// 0.bitLength == 0;     // 00000000
  /// (-1).bitLength == 0;  // 11111111
  /// (-2).bitLength == 1;  // 11111110
  /// (-3).bitLength == 2;  // 11111101
  /// (-4).bitLength == 2;  // 11111100
  /// ```
  int? get bitLength => value?.bitLength;

  /// Returns the least significant [width] bits of this integer as a
  /// non-negative number (i.e. unsigned representation).  The returned value
  /// has zeros in all bit positions higher than [width].
  /// ```
  /// (-1).toUnsigned(5) == 31   // 11111111  ->  00011111
  /// ```
  /// This operation can be used to simulate arithmetic from low level
  /// languages.
  /// For example, to increment an 8 bit quantity:
  /// ```
  /// q = (q + 1).toUnsigned(8);
  /// ```
  /// `q` will count from `0` up to `255` and then wrap around to `0`.
  ///
  /// If the input fits in [width] bits without truncation, the result is the
  /// same as the input.  The minimum width needed to avoid truncation of `x` is
  /// given by `x.bitLength`, i.e.
  /// ```
  /// x == x.toUnsigned(x.bitLength);
  /// ```
  int? toUnsigned(int width) => value?.toUnsigned(width);

  /// Returns the least significant [width] bits of this integer, extending the
  /// highest retained bit to the sign.  This is the same as truncating the
  /// value to fit in [width] bits using an signed 2-s complement
  /// representation.
  /// The returned value has the same bit value in all positions higher than
  /// [width].
  ///
  /// ```
  ///                                V--sign bit-V
  /// 16.toSigned(5) == -16   //  00010000 -> 11110000
  /// 239.toSigned(5) == 15   //  11101111 -> 00001111
  ///                                ^           ^
  /// ```
  /// This operation can be used to simulate arithmetic from low level
  /// languages.
  /// For example, to increment an 8 bit signed quantity:
  /// ```
  /// q = (q + 1).toSigned(8);
  /// ```
  /// `q` will count from `0` up to `127`, wrap to `-128` and count back up to
  /// `127`.
  ///
  /// If the input value fits in [width] bits without truncation, the result is
  /// the same as the input.  The minimum width needed to avoid truncation
  /// of `x` is `x.bitLength + 1`, i.e.
  /// ```
  /// x == x.toSigned(x.bitLength + 1);
  /// ```
  int? toSigned(int width) => value?.toSigned(width);

  /// Return the negative value of this integer.
  ///
  /// The result of negating an integer always has the opposite sign, except
  /// for zero, which is its own negation.
  int? operator -() {
    if (value != null) {
      return -value!;
    }
    return null;
  }

  /// Returns the absolute value of this integer.
  ///
  /// For any integer `x`, the result is the same as `x < 0 ? -x : x`.
  int? abs() => value?.abs();

  /// Returns the sign of this integer.
  ///
  /// Returns 0 for zero, -1 for values less than zero and
  /// +1 for values greater than zero.
  int? get sign => value?.sign;

  /// Returns `this`.
  int? round() => value?.round();

  /// Returns `this`.
  int? floor() => value?.floor();

  /// Returns `this`.
  int? ceil() => value?.ceil();

  /// Returns `this`.
  int? truncate() => value?.truncate();

  /// Returns `this.toDouble()`.
  double? roundToDouble() => value?.roundToDouble();

  /// Returns `this.toDouble()`.
  double? floorToDouble() => value?.floorToDouble();

  /// Returns `this.toDouble()`.
  double? ceilToDouble() => value?.ceilToDouble();

  /// Returns `this.toDouble()`.
  double? truncateToDouble() => value?.truncateToDouble();
}


--- File Index 26: get_rx/src/rx_types/rx_core/rx_string.dart ---
part of '../rx_types.dart';

extension RxStringExt on Rx<String> {
  String operator +(String val) => value + val;

  int compareTo(String other) {
    return value.compareTo(other);
  }

  /// Returns true if this string ends with [other]. For example:
  ///
  ///     'Dart'.endsWith('t'); // true
  bool endsWith(String other) {
    return value.endsWith(other);
  }

  /// Returns true if this string starts with a match of [pattern].
  bool startsWith(Pattern pattern, [int index = 0]) {
    return value.startsWith(pattern, index);
  }

  /// Returns the position of the first match of [pattern] in this string
  int indexOf(Pattern pattern, [int start = 0]) {
    return value.indexOf(pattern, start);
  }

  /// Returns the starting position of the last match [pattern] in this string,
  /// searching backward starting at [start], inclusive:
  int lastIndexOf(Pattern pattern, [int? start]) {
    return value.lastIndexOf(pattern, start);
  }

  /// Returns true if this string is empty.
  bool get isEmpty => value.isEmpty;

  /// Returns true if this string is not empty.
  bool get isNotEmpty => !isEmpty;

  /// Returns the substring of this string that extends from [startIndex],
  /// inclusive, to [endIndex], exclusive
  String substring(int startIndex, [int? endIndex]) {
    return value.substring(startIndex, endIndex);
  }

  /// Returns the string without any leading and trailing whitespace.
  String trim() {
    return value.trim();
  }

  /// Returns the string without any leading whitespace.
  ///
  /// As [trim], but only removes leading whitespace.
  String trimLeft() {
    return value.trimLeft();
  }

  /// Returns the string without any trailing whitespace.
  ///
  /// As [trim], but only removes trailing whitespace.
  String trimRight() {
    return value.trimRight();
  }

  /// Pads this string on the left if it is shorter than [width].
  ///
  /// Return a new string that prepends [padding] onto this string
  /// one time for each position the length is less than [width].
  String padLeft(int width, [String padding = ' ']) {
    return value.padLeft(width, padding);
  }

  /// Pads this string on the right if it is shorter than [width].

  /// Return a new string that appends [padding] after this string
  /// one time for each position the length is less than [width].
  String padRight(int width, [String padding = ' ']) {
    return value.padRight(width, padding);
  }

  /// Returns true if this string contains a match of [other]:
  bool contains(Pattern other, [int startIndex = 0]) {
    return value.contains(other, startIndex);
  }

  /// Replaces all substrings that match [from] with [replace].
  String replaceAll(Pattern from, String replace) {
    return value.replaceAll(from, replace);
  }

  /// Splits the string at matches of [pattern] and returns a list
  /// of substrings.
  List<String> split(Pattern pattern) {
    return value.split(pattern);
  }

  /// Returns an unmodifiable list of the UTF-16 code units of this string.
  List<int> get codeUnits => value.codeUnits;

  /// Returns an [Iterable] of Unicode code-points of this string.
  ///
  /// If the string contains surrogate pairs, they are combined and returned
  /// as one integer by this iterator. Unmatched surrogate halves are treated
  /// like valid 16-bit code-units.
  Runes get runes => value.runes;

  /// Converts all characters in this string to lower case.
  /// If the string is already in all lower case, this method returns `this`.
  String toLowerCase() {
    return value.toLowerCase();
  }

  /// Converts all characters in this string to upper case.
  /// If the string is already in all upper case, this method returns `this`.
  String toUpperCase() {
    return value.toUpperCase();
  }

  Iterable<Match> allMatches(String string, [int start = 0]) {
    return value.allMatches(string, start);
  }

  Match? matchAsPrefix(String string, [int start = 0]) {
    return value.matchAsPrefix(string, start);
  }
}

extension RxnStringExt on Rx<String?> {
  String operator +(String val) => (value ?? '') + val;

  int? compareTo(String other) {
    return value?.compareTo(other);
  }

  /// Returns true if this string ends with [other]. For example:
  ///
  ///     'Dart'.endsWith('t'); // true
  bool? endsWith(String other) {
    return value?.endsWith(other);
  }

  /// Returns true if this string starts with a match of [pattern].
  bool? startsWith(Pattern pattern, [int index = 0]) {
    return value?.startsWith(pattern, index);
  }

  /// Returns the position of the first match of [pattern] in this string
  int? indexOf(Pattern pattern, [int start = 0]) {
    return value?.indexOf(pattern, start);
  }

  /// Returns the starting position of the last match [pattern] in this string,
  /// searching backward starting at [start], inclusive:
  int? lastIndexOf(Pattern pattern, [int? start]) {
    return value?.lastIndexOf(pattern, start);
  }

  /// Returns true if this string is empty.
  bool? get isEmpty => value?.isEmpty;

  /// Returns true if this string is not empty.
  bool? get isNotEmpty => value?.isNotEmpty;

  /// Returns the substring of this string that extends from [startIndex],
  /// inclusive, to [endIndex], exclusive
  String? substring(int startIndex, [int? endIndex]) {
    return value?.substring(startIndex, endIndex);
  }

  /// Returns the string without any leading and trailing whitespace.
  String? trim() {
    return value?.trim();
  }

  /// Returns the string without any leading whitespace.
  ///
  /// As [trim], but only removes leading whitespace.
  String? trimLeft() {
    return value?.trimLeft();
  }

  /// Returns the string without any trailing whitespace.
  ///
  /// As [trim], but only removes trailing whitespace.
  String? trimRight() {
    return value?.trimRight();
  }

  /// Pads this string on the left if it is shorter than [width].
  ///
  /// Return a new string that prepends [padding] onto this string
  /// one time for each position the length is less than [width].
  String? padLeft(int width, [String padding = ' ']) {
    return value?.padLeft(width, padding);
  }

  /// Pads this string on the right if it is shorter than [width].

  /// Return a new string that appends [padding] after this string
  /// one time for each position the length is less than [width].
  String? padRight(int width, [String padding = ' ']) {
    return value?.padRight(width, padding);
  }

  /// Returns true if this string contains a match of [other]:
  bool? contains(Pattern other, [int startIndex = 0]) {
    return value?.contains(other, startIndex);
  }

  /// Replaces all substrings that match [from] with [replace].
  String? replaceAll(Pattern from, String replace) {
    return value?.replaceAll(from, replace);
  }

  /// Splits the string at matches of [pattern] and returns a list
  /// of substrings.
  List<String>? split(Pattern pattern) {
    return value?.split(pattern);
  }

  /// Returns an unmodifiable list of the UTF-16 code units of this string.
  List<int>? get codeUnits => value?.codeUnits;

  /// Returns an [Iterable] of Unicode code-points of this string.
  ///
  /// If the string contains surrogate pairs, they are combined and returned
  /// as one integer by this iterator. Unmatched surrogate halves are treated
  /// like valid 16-bit code-units.
  Runes? get runes => value?.runes;

  /// Converts all characters in this string to lower case.
  /// If the string is already in all lower case, this method returns `this`.
  String? toLowerCase() {
    return value?.toLowerCase();
  }

  /// Converts all characters in this string to upper case.
  /// If the string is already in all upper case, this method returns `this`.
  String? toUpperCase() {
    return value?.toUpperCase();
  }

  Iterable<Match>? allMatches(String string, [int start = 0]) {
    return value?.allMatches(string, start);
  }

  Match? matchAsPrefix(String string, [int start = 0]) {
    return value?.matchAsPrefix(string, start);
  }
}

/// Rx class for `String` Type.
class RxString extends Rx<String> implements Comparable<String>, Pattern {
  RxString(super.initial);

  @override
  Iterable<Match> allMatches(String string, [int start = 0]) {
    return value.allMatches(string, start);
  }

  @override
  Match? matchAsPrefix(String string, [int start = 0]) {
    return value.matchAsPrefix(string, start);
  }

  @override
  int compareTo(String other) {
    return value.compareTo(other);
  }
}

/// Rx class for `String` Type.
class RxnString extends Rx<String?> implements Comparable<String>, Pattern {
  RxnString([super.initial]);

  @override
  Iterable<Match> allMatches(String string, [int start = 0]) {
    return value!.allMatches(string, start);
  }

  @override
  Match? matchAsPrefix(String string, [int start = 0]) {
    return value!.matchAsPrefix(string, start);
  }

  @override
  int compareTo(String other) {
    return value!.compareTo(other);
  }
}


--- File Index 27: get_rx/src/rx_typedefs/rx_typedefs.dart ---
typedef Condition = bool Function();
typedef OnData<T> = void Function(T data);
typedef Callback = void Function();


--- File Index 28: get_core/get_core.dart ---
library;

export 'src/flutter_engine.dart';
export 'src/get_interface.dart';
export 'src/get_main.dart';
export 'src/log.dart';
export 'src/smart_management.dart';
export 'src/typedefs.dart';


--- File Index 29: get_core/src/get_interface.dart ---
import 'package:flutter/foundation.dart';

import 'log.dart';
import 'smart_management.dart';

/// GetInterface allows any auxiliary package to be merged into the "Get"
/// class through extensions
abstract class GetInterface {
  SmartManagement smartManagement = SmartManagement.full;
  bool isLogEnable = kDebugMode;
  LogWriterCallback log = defaultLogWriterCallback;
}


--- File Index 30: get_core/src/typedefs.dart ---
typedef ValueUpdater<T> = T Function();


--- File Index 31: get_core/src/get_main.dart ---
import 'get_interface.dart';

///Use to instead of Navigator.push, off instead of Navigator.pushReplacement,
///offAll instead of Navigator.pushAndRemoveUntil. For named routes just
///add "named" after them. Example: toNamed, offNamed, and AllNamed.
///To return to the previous screen, use back().
///No need to pass any context to Get, just put the name of the route inside
///the parentheses and the magic will occur.
class _GetImpl extends GetInterface {}

// ignore: non_constant_identifier_names
final Get = _GetImpl();


--- File Index 32: get_core/src/log.dart ---
import 'dart:developer' as developer;
import 'get_main.dart';

///VoidCallback from logs
typedef LogWriterCallback = void Function(String text, {bool isError});

/// default logger from GetX
void defaultLogWriterCallback(String value, {bool isError = false}) {
  if (isError || Get.isLogEnable) developer.log(value, name: 'GETX');
}


--- File Index 33: get_core/src/flutter_engine.dart ---
import 'package:flutter/widgets.dart';

class Engine {
  static WidgetsBinding get instance {
    return WidgetsFlutterBinding.ensureInitialized();
  }
}


--- File Index 34: get_core/src/smart_management.dart ---
/// GetX by default disposes unused controllers from memory,
/// Through different behaviors.
/// SmartManagement.full
/// [SmartManagement.full] is the default one. Dispose classes that are
/// not being used and were not set to be permanent. In the majority
/// of the cases you will want to keep this config untouched.
/// If you new to GetX then don't change this.
/// [SmartManagement.onlyBuilder] only controllers started in init:
/// or loaded into a Binding with Get.lazyPut() will be disposed. If you use
/// Get.put() or Get.putAsync() or any other approach, SmartManagement
/// will not have permissions to exclude this dependency. With the default
/// behavior, even widgets instantiated with "Get.put" will be removed,
/// unlike SmartManagement.onlyBuilders.
/// [SmartManagement.keepFactory]Just like SmartManagement.full,
/// it will remove it's dependencies when it's not being used anymore.
/// However, it will keep their factory, which means it will recreate
/// the dependency if you need that instance again.
enum SmartManagement {
  full,
  onlyBuilder,
  keepFactory,
}




Analyze the codebase context.
Identify the top 5-10 core most important abstractions to help those new to the codebase.

For each abstraction, provide:
1. A concise `name`.
2. A beginner-friendly `description` explaining what it is with a simple analogy, in around 100 words.
3. A list of relevant `file_indices` (integers) using the format `idx # path/comment`.

List of file indices and paths present in the context:
- 0 # state_manager.dart
- 1 # get_state_manager/get_state_manager.dart
- 2 # get_state_manager/src/simple/list_notifier.dart
- 3 # get_state_manager/src/simple/get_state.dart
- 4 # get_state_manager/src/simple/get_controllers.dart
- 5 # get_state_manager/src/simple/mixin_builder.dart
- 6 # get_state_manager/src/simple/simple_builder.dart
- 7 # get_state_manager/src/simple/get_view.dart
- 8 # get_state_manager/src/simple/get_responsive.dart
- 9 # get_state_manager/src/simple/get_widget_cache.dart
- 10 # get_state_manager/src/rx_flutter/rx_ticket_provider_mixin.dart
- 11 # get_state_manager/src/rx_flutter/rx_obx_widget.dart
- 12 # get_state_manager/src/rx_flutter/rx_getx_widget.dart
- 13 # get_state_manager/src/rx_flutter/rx_notifier.dart
- 14 # get_rx/get_rx.dart
- 15 # get_rx/src/rx_stream/rx_stream.dart
- 16 # get_rx/src/rx_stream/mini_stream.dart
- 17 # get_rx/src/rx_workers/rx_workers.dart
- 18 # get_rx/src/rx_workers/utils/debouncer.dart
- 19 # get_rx/src/rx_types/rx_types.dart
- 20 # get_rx/src/rx_types/rx_iterables/rx_list.dart
- 21 # get_rx/src/rx_types/rx_iterables/rx_map.dart
- 22 # get_rx/src/rx_types/rx_iterables/rx_set.dart
- 23 # get_rx/src/rx_types/rx_core/rx_interface.dart
- 24 # get_rx/src/rx_types/rx_core/rx_impl.dart
- 25 # get_rx/src/rx_types/rx_core/rx_num.dart
- 26 # get_rx/src/rx_types/rx_core/rx_string.dart
- 27 # get_rx/src/rx_typedefs/rx_typedefs.dart
- 28 # get_core/get_core.dart
- 29 # get_core/src/get_interface.dart
- 30 # get_core/src/typedefs.dart
- 31 # get_core/src/get_main.dart
- 32 # get_core/src/log.dart
- 33 # get_core/src/flutter_engine.dart
- 34 # get_core/src/smart_management.dart

Format the output as a YAML list of dictionaries:

```yaml
- name: |
    Query Processing
  description: |
    Explains what the abstraction does.
    It's like a central dispatcher routing requests.
  file_indices:
    - 0 # path/to/file1.py
    - 3 # path/to/related.py
- name: |
    Query Optimization
  description: |
    Another core concept, similar to a blueprint for objects.
  file_indices:
    - 5 # path/to/another.js
# ... up to 10 abstractions
```
2025-05-12 13:27:26,249 - INFO - RESPONSE: ```yaml
- name: |
    Get (Global Access Facade)
  description: |
    The `Get` object is your main C# class 'System.Console' and entry point for most GetX features.
    Think of it as a universal remote control for dependency management (like storing and retrieving your app's managers),
    navigation, showing dialogs, and more. It provides easy-to-use static methods,
    often without needing Flutter's `BuildContext`, making your code cleaner and
    simplifying access to various GetX functionalities from anywhere in your app.
  file_indices:
    - 31 # get_core/src/get_main.dart
    - 29 # get_core/src/get_interface.dart
    - 28 # get_core/get_core.dart
    - 3 # get_state_manager/src/simple/get_state.dart (Illustrates usage via Get.find, Get.put for controllers)
    - 12 # get_state_manager/src/rx_flutter/rx_getx_widget.dart (Illustrates usage for controller management)

- name: |
    GetxController
  description: |
    A `GetxController` is like the manager or "brain" for a specific part of your app's screen or a feature.
    It holds the data (state) and the business logic (functions) for that part.
    When data changes, the controller can tell the UI to update by calling its `update()` method.
    It's like the director of a play scene, instructing which actors (widgets) need to change their
    appearance or behavior based on the script (logic and state). It's primarily used with `GetBuilder` for manual UI updates.
  file_indices:
    - 4 # get_state_manager/src/simple/get_controllers.dart
    - 2 # get_state_manager/src/simple/list_notifier.dart (Utilizes ListNotifier for update notifications)
    - 3 # get_state_manager/src/simple/get_state.dart (Used in conjunction with GetBuilder)

- name: |
    Rx<T> (Reactive Variables)
  description: |
    `Rx<T>` types (like `RxInt`, `RxString`, or anything ending with `.obs`) represent variables that can be "observed."
    Imagine a magic number on a special whiteboard: whenever someone writes a new number on it,
    a bell automatically rings, and anyone watching that specific number instantly sees the change.
    These variables are the core of GetX's reactive programming, allowing your UI (especially with `Obx` widgets) to
    automatically update whenever the underlying data changes.
  file_indices:
    - 19 # get_rx/src/rx_types/rx_types.dart
    - 24 # get_rx/src/rx_types/rx_core/rx_impl.dart
    - 13 # get_state_manager/src/rx_flutter/rx_notifier.dart (GetListenable is a base class for Rx types regarding listener management)
    - 23 # get_rx/src/rx_types/rx_core/rx_interface.dart

- name: |
    GetBuilder
  description: |
    `GetBuilder` is a widget that listens to a specific `GetxController`.
    When you explicitly call the `update()` method on that controller, any associated
    `GetBuilder` widgets will rebuild themselves to reflect the new state.
    It's like a digital display in a store that only refreshes its content when the
    store manager presses an "update display" button. This provides precise, manual control over UI updates for non-reactive state.
  file_indices:
    - 3 # get_state_manager/src/simple/get_state.dart
    - 4 # get_state_manager/src/simple/get_controllers.dart (Defines GetxController, which GetBuilder listens to)

- name: |
    Obx / ObxWidget
  description: |
    `Obx` (and its base `ObxWidget`) is a widget that automatically rebuilds when any reactive
    variable (`Rx<T>`) used inside its builder function changes.
    It's like having a smart picture frame that's wirelessly connected to a photo album;
    as soon as a new photo (data changes) is added to the observed album, the frame
    instantly displays it. This offers an efficient and declarative way to keep your UI in sync with reactive state.
  file_indices:
    - 11 # get_state_manager/src/rx_flutter/rx_obx_widget.dart
    - 6 # get_state_manager/src/simple/simple_builder.dart (StatelessObserverComponent provides the reactive listening mechanism)
    - 2 # get_state_manager/src/simple/list_notifier.dart (The global Notifier.instance is used by Obx mechanisms)

- name: |
    ListNotifier (and Mixins)
  description: |
    `ListNotifier` is the fundamental engine for managing lists of listeners and dispatching update notifications.
    Think of it as a highly efficient town crier. When a `GetxController`
    needs to announce a state change (via `update()`), it uses its `ListNotifier` to alert all subscribed
    widgets (like `GetBuilder`) that they need to refresh. This is a cornerstone of
    GetX's simple state management.
  file_indices:
    - 2 # get_state_manager/src/simple/list_notifier.dart
    - 4 # get_state_manager/src/simple/get_controllers.dart (GetxController extends ListNotifier)
    - 13 # get_state_manager/src/rx_flutter/rx_notifier.dart (StateMixin also extends ListNotifier)

- name: |
    Dependency Access (Binder, Bind.of, Get.find/put)
  description: |
    GetX provides ways to manage and access your "dependencies" (like `GetxController` instances) throughout your app.
    `Get.put()` registers a dependency. `Binder` is an `InheritedWidget` that provides these
    dependencies down the widget tree, allowing descendant widgets to access them via `Bind.of(context)`.
    Globally, `Get.find()` can retrieve any registered dependency. It's like a combination of a central
    warehouse and local delivery services for the "brains" (controllers) your widgets need.
  file_indices:
    - 3 # get_state_manager/src/simple/get_state.dart (Defines Binder, Bind.of and related dependency injection widgets)
    - 7 # get_state_manager/src/simple/get_view.dart (GetView/GetWidget demonstrate usage of Get.find)
    - 12 # get_state_manager/src/rx_flutter/rx_getx_widget.dart (GetX widget uses Get.put/find for controller management)

- name: |
    Workers
  description: |
    Workers (`ever`, `once`, `debounce`, `interval`) are functions that listen to `Rx` reactive variables
    and execute a callback when certain conditions or events occur on those variables.
    They are useful for performing side effects, like making an API call when a user ID changes,
    or saving data after a user stops typing. Think of them as automated sentinels that watch
    your reactive data streams and spring into action based on predefined rules, independent of direct UI rendering.
  file_indices:
    - 17 # get_rx/src/rx_workers/rx_workers.dart
    - 13 # get_state_manager/src/rx_flutter/rx_notifier.dart (Defines GetListenable, the interface Rx types implement, which workers listen to)
    - 18 # get_rx/src/rx_workers/utils/debouncer.dart (Utility for the debounce worker)

- name: |
    StateMixin
  description: |
    `StateMixin` is a utility mixed into controllers to easily manage common UI states for
    asynchronous operations: loading, success (with data), error, and empty.
    It provides a `status` property (e.g., `status.isLoading`) and simplifies showing different widgets (often using `obx` method)
    based on the current state of data fetching. Its like a
    standardized status panel for your data, clearly indicating its current condition.
  file_indices:
    - 13 # get_state_manager/src/rx_flutter/rx_notifier.dart
    - 4 # get_state_manager/src/simple/get_controllers.dart (StateController and SuperController incorporate StateMixin)
```
2025-05-12 13:27:26,313 - INFO - PROMPT: 
Based on the following abstractions and relevant code snippets from the project `lib`:

List of Abstraction Indices and Names:
0 # Get (Global Access Facade)

1 # GetxController

2 # Rx<T> (Reactive Variables)

3 # GetBuilder

4 # Obx / ObxWidget

5 # ListNotifier (and Mixins)

6 # Dependency Access (Binder, Bind.of, Get.find/put)

7 # Workers

8 # StateMixin


Context (Abstractions, Descriptions, Code):
Identified Abstractions:\n- Index 0: Get (Global Access Facade)
 (Relevant file indices: [3, 12, 28, 29, 31])\n  Description: The `Get` object is your main C# class 'System.Console' and entry point for most GetX features.
Think of it as a universal remote control for dependency management (like storing and retrieving your app's managers),
navigation, showing dialogs, and more. It provides easy-to-use static methods,
often without needing Flutter's `BuildContext`, making your code cleaner and
simplifying access to various GetX functionalities from anywhere in your app.
\n- Index 1: GetxController
 (Relevant file indices: [2, 3, 4])\n  Description: A `GetxController` is like the manager or "brain" for a specific part of your app's screen or a feature.
It holds the data (state) and the business logic (functions) for that part.
When data changes, the controller can tell the UI to update by calling its `update()` method.
It's like the director of a play scene, instructing which actors (widgets) need to change their
appearance or behavior based on the script (logic and state). It's primarily used with `GetBuilder` for manual UI updates.
\n- Index 2: Rx<T> (Reactive Variables)
 (Relevant file indices: [13, 19, 23, 24])\n  Description: `Rx<T>` types (like `RxInt`, `RxString`, or anything ending with `.obs`) represent variables that can be "observed."
Imagine a magic number on a special whiteboard: whenever someone writes a new number on it,
a bell automatically rings, and anyone watching that specific number instantly sees the change.
These variables are the core of GetX's reactive programming, allowing your UI (especially with `Obx` widgets) to
automatically update whenever the underlying data changes.
\n- Index 3: GetBuilder
 (Relevant file indices: [3, 4])\n  Description: `GetBuilder` is a widget that listens to a specific `GetxController`.
When you explicitly call the `update()` method on that controller, any associated
`GetBuilder` widgets will rebuild themselves to reflect the new state.
It's like a digital display in a store that only refreshes its content when the
store manager presses an "update display" button. This provides precise, manual control over UI updates for non-reactive state.
\n- Index 4: Obx / ObxWidget
 (Relevant file indices: [2, 6, 11])\n  Description: `Obx` (and its base `ObxWidget`) is a widget that automatically rebuilds when any reactive
variable (`Rx<T>`) used inside its builder function changes.
It's like having a smart picture frame that's wirelessly connected to a photo album;
as soon as a new photo (data changes) is added to the observed album, the frame
instantly displays it. This offers an efficient and declarative way to keep your UI in sync with reactive state.
\n- Index 5: ListNotifier (and Mixins)
 (Relevant file indices: [2, 4, 13])\n  Description: `ListNotifier` is the fundamental engine for managing lists of listeners and dispatching update notifications.
Think of it as a highly efficient town crier. When a `GetxController`
needs to announce a state change (via `update()`), it uses its `ListNotifier` to alert all subscribed
widgets (like `GetBuilder`) that they need to refresh. This is a cornerstone of
GetX's simple state management.
\n- Index 6: Dependency Access (Binder, Bind.of, Get.find/put)
 (Relevant file indices: [3, 7, 12])\n  Description: GetX provides ways to manage and access your "dependencies" (like `GetxController` instances) throughout your app.
`Get.put()` registers a dependency. `Binder` is an `InheritedWidget` that provides these
dependencies down the widget tree, allowing descendant widgets to access them via `Bind.of(context)`.
Globally, `Get.find()` can retrieve any registered dependency. It's like a combination of a central
warehouse and local delivery services for the "brains" (controllers) your widgets need.
\n- Index 7: Workers
 (Relevant file indices: [13, 17, 18])\n  Description: Workers (`ever`, `once`, `debounce`, `interval`) are functions that listen to `Rx` reactive variables
and execute a callback when certain conditions or events occur on those variables.
They are useful for performing side effects, like making an API call when a user ID changes,
or saving data after a user stops typing. Think of them as automated sentinels that watch
your reactive data streams and spring into action based on predefined rules, independent of direct UI rendering.
\n- Index 8: StateMixin
 (Relevant file indices: [4, 13])\n  Description: `StateMixin` is a utility mixed into controllers to easily manage common UI states for
asynchronous operations: loading, success (with data), error, and empty.
It provides a `status` property (e.g., `status.isLoading`) and simplifies showing different widgets (often using `obx` method)
based on the current state of data fetching. Its like a
standardized status panel for your data, clearly indicating its current condition.
\n\nRelevant File Snippets (Referenced by Index and Path):\n--- File: 2 # get_state_manager/src/simple/list_notifier.dart ---\nimport 'dart:collection';

import 'package:flutter/foundation.dart';

// This callback remove the listener on addListener function
typedef Disposer = void Function();

// replacing StateSetter, return if the Widget is mounted for extra validation.
// if it brings overhead the extra call,
typedef GetStateUpdate = void Function();

class ListNotifier extends Listenable
    with ListNotifierSingleMixin, ListNotifierGroupMixin {}

/// A Notifier with single listeners
class ListNotifierSingle = ListNotifier with ListNotifierSingleMixin;

/// A notifier with group of listeners identified by id
class ListNotifierGroup = ListNotifier with ListNotifierGroupMixin;

/// This mixin add to Listenable the addListener, removerListener and
/// containsListener implementation
mixin ListNotifierSingleMixin on Listenable {
  List<GetStateUpdate>? _updaters = <GetStateUpdate>[];

  // final int _version = 0;
  // final int _microtaskVersion = 0;

  @override
  Disposer addListener(GetStateUpdate listener) {
    assert(_debugAssertNotDisposed());
    _updaters!.add(listener);
    return () => _updaters!.remove(listener);
  }

  bool containsListener(GetStateUpdate listener) {
    return _updaters?.contains(listener) ?? false;
  }

  @override
  void removeListener(VoidCallback listener) {
    assert(_debugAssertNotDisposed());
    _updaters!.remove(listener);
  }

  @protected
  void refresh() {
    assert(_debugAssertNotDisposed());
    _notifyUpdate();
  }

  @protected
  void reportRead() {
    Notifier.instance.read(this);
  }

  @protected
  void reportAdd(VoidCallback disposer) {
    Notifier.instance.add(disposer);
  }

  void _notifyUpdate() {
    // if (_microtaskVersion == _version) {
    //   _microtaskVersion++;
    //   scheduleMicrotask(() {
    //     _version++;
    //     _microtaskVersion = _version;
    final list = _updaters?.toList() ?? [];

    for (var element in list) {
      element();
    }
    //   });
    // }
  }

  bool get isDisposed => _updaters == null;

  bool _debugAssertNotDisposed() {
    assert(() {
      if (isDisposed) {
        throw FlutterError('''A $runtimeType was used after being disposed.\n
'Once you have called dispose() on a $runtimeType, it can no longer be used.''');
      }
      return true;
    }());
    return true;
  }

  int get listenersLength {
    assert(_debugAssertNotDisposed());
    return _updaters!.length;
  }

  @mustCallSuper
  void dispose() {
    assert(_debugAssertNotDisposed());
    _updaters = null;
  }
}

mixin ListNotifierGroupMixin on Listenable {
  HashMap<Object?, ListNotifierSingleMixin>? _updatersGroupIds =
      HashMap<Object?, ListNotifierSingleMixin>();

  void _notifyGroupUpdate(Object id) {
    if (_updatersGroupIds!.containsKey(id)) {
      _updatersGroupIds![id]!._notifyUpdate();
    }
  }

  @protected
  void notifyGroupChildrens(Object id) {
    assert(_debugAssertNotDisposed());
    Notifier.instance.read(_updatersGroupIds![id]!);
  }

  bool containsId(Object id) {
    return _updatersGroupIds?.containsKey(id) ?? false;
  }

  @protected
  void refreshGroup(Object id) {
    assert(_debugAssertNotDisposed());
    _notifyGroupUpdate(id);
  }

  bool _debugAssertNotDisposed() {
    assert(() {
      if (_updatersGroupIds == null) {
        throw FlutterError('''A $runtimeType was used after being disposed.\n
'Once you have called dispose() on a $runtimeType, it can no longer be used.''');
      }
      return true;
    }());
    return true;
  }

  void removeListenerId(Object id, VoidCallback listener) {
    assert(_debugAssertNotDisposed());
    if (_updatersGroupIds!.containsKey(id)) {
      _updatersGroupIds![id]!.removeListener(listener);
    }
  }

  @mustCallSuper
  void dispose() {
    assert(_debugAssertNotDisposed());
    _updatersGroupIds?.forEach((key, value) => value.dispose());
    _updatersGroupIds = null;
  }

  Disposer addListenerId(Object? key, GetStateUpdate listener) {
    _updatersGroupIds![key] ??= ListNotifierSingle();
    return _updatersGroupIds![key]!.addListener(listener);
  }

  /// To dispose an [id] from future updates(), this ids are registered
  /// by `GetBuilder()` or similar, so is a way to unlink the state change with
  /// the Widget from the Controller.
  void disposeId(Object id) {
    _updatersGroupIds?[id]?.dispose();
    _updatersGroupIds!.remove(id);
  }
}

class Notifier {
  Notifier._();

  static Notifier? _instance;
  static Notifier get instance => _instance ??= Notifier._();

  NotifyData? _notifyData;

  void add(VoidCallback listener) {
    _notifyData?.disposers.add(listener);
  }

  void read(ListNotifierSingleMixin updaters) {
    final listener = _notifyData?.updater;
    if (listener != null && !updaters.containsListener(listener)) {
      updaters.addListener(listener);
      add(() => updaters.removeListener(listener));
    }
  }

  T append<T>(NotifyData data, T Function() builder) {
    _notifyData = data;
    final result = builder();
    if (data.disposers.isEmpty && data.throwException) {
      throw const ObxError();
    }
    _notifyData = null;
    return result;
  }
}

class NotifyData {
  const NotifyData(
      {required this.updater,
      required this.disposers,
      this.throwException = true});
  final GetStateUpdate updater;
  final List<VoidCallback> disposers;
  final bool throwException;
}

class ObxError {
  const ObxError();
  @override
  String toString() {
    return """
      [Get] the improper use of a GetX has been detected. 
      You should only use GetX or Obx for the specific widget that will be updated.
      If you are seeing this error, you probably did not insert any observable variables into GetX/Obx 
      or insert them outside the scope that GetX considers suitable for an update 
      (example: GetX => HeavyWidget => variableObservable).
      If you need to update a parent widget and a child widget, wrap each one in an Obx/GetX.
      """;
  }
}
\n\n--- File: 3 # get_state_manager/src/simple/get_state.dart ---\n// ignore_for_file: overridden_fields

import 'dart:async';

import 'package:flutter/material.dart';

import '../../../instance_manager.dart';
import '../../get_state_manager.dart';
import 'list_notifier.dart';

typedef InitBuilder<T> = T Function();

typedef GetControllerBuilder<T extends GetLifeCycleMixin> = Widget Function(
    T controller);

extension WatchExt on BuildContext {
  T listen<T>() {
    return Bind.of(this, rebuild: true);
  }
}

extension ReadExt on BuildContext {
  T get<T>() {
    return Bind.of(this);
  }
}

// extension FilterExt on BuildContext {
//   T filter<T extends GetxController>(Object Function(T value)? filter) {
//     return Bind.of(this, filter: filter, rebuild: true);
//   }
// }

class GetBuilder<T extends GetxController> extends StatelessWidget {
  final GetControllerBuilder<T> builder;
  final bool global;
  final Object? id;
  final String? tag;
  final bool autoRemove;
  final bool assignId;
  final Object Function(T value)? filter;
  final void Function(BindElement<T> state)? initState,
      dispose,
      didChangeDependencies;
  final void Function(Binder<T> oldWidget, BindElement<T> state)?
      didUpdateWidget;
  final T? init;

  const GetBuilder({
    super.key,
    this.init,
    this.global = true,
    required this.builder,
    this.autoRemove = true,
    this.assignId = false,
    this.initState,
    this.filter,
    this.tag,
    this.dispose,
    this.id,
    this.didChangeDependencies,
    this.didUpdateWidget,
  });

  @override
  Widget build(BuildContext context) {
    return Binder(
      init: init == null ? null : () => init!,
      global: global,
      autoRemove: autoRemove,
      assignId: assignId,
      initState: initState,
      filter: filter,
      tag: tag,
      dispose: dispose,
      id: id,
      lazy: false,
      didChangeDependencies: didChangeDependencies,
      didUpdateWidget: didUpdateWidget,
      child: Builder(builder: (context) {
        final controller = Bind.of<T>(context, rebuild: true);
        return builder(controller);
      }),
    );
    // return widget.builder(controller!);
  }
}

abstract class Bind<T> extends StatelessWidget {
  const Bind({
    super.key,
    required this.child,
    this.init,
    this.global = true,
    this.autoRemove = true,
    this.assignId = false,
    this.initState,
    this.filter,
    this.tag,
    this.dispose,
    this.id,
    this.didChangeDependencies,
    this.didUpdateWidget,
  });

  final InitBuilder<T>? init;

  final bool global;
  final Object? id;
  final String? tag;
  final bool autoRemove;
  final bool assignId;
  final Object Function(T value)? filter;
  final void Function(BindElement<T> state)? initState,
      dispose,
      didChangeDependencies;
  final void Function(Binder<T> oldWidget, BindElement<T> state)?
      didUpdateWidget;

  final Widget? child;

  static Bind put<S>(
    S dependency, {
    String? tag,
    bool permanent = false,
  }) {
    Get.put<S>(dependency, tag: tag, permanent: permanent);
    return _FactoryBind<S>(
      autoRemove: permanent,
      assignId: true,
      tag: tag,
    );
  }

  static bool fenixMode = false;

  static Bind lazyPut<S>(
    InstanceBuilderCallback<S> builder, {
    String? tag,
    bool? fenix,
    // VoidCallback? onInit,
    VoidCallback? onClose,
  }) {
    Get.lazyPut<S>(builder, tag: tag, fenix: fenix ?? fenixMode);
    return _FactoryBind<S>(
      tag: tag,
      // initState: (_) {
      //   onInit?.call();
      // },
      dispose: (_) {
        onClose?.call();
      },
    );
  }

  static Bind create<S>(InstanceCreateBuilderCallback<S> builder,
      {String? tag, bool permanent = true}) {
    return _FactoryBind<S>(
      create: builder,
      tag: tag,
      global: false,
    );
  }

  static Bind spawn<S>(InstanceBuilderCallback<S> builder,
      {String? tag, bool permanent = true}) {
    Get.spawn<S>(builder, tag: tag, permanent: permanent);
    return _FactoryBind<S>(
      tag: tag,
      global: false,
      autoRemove: permanent,
    );
  }

  static S find<S>({String? tag}) => Get.find<S>(tag: tag);

  static Future<bool> delete<S>({String? tag, bool force = false}) async =>
      Get.delete<S>(tag: tag, force: force);

  static Future<void> deleteAll({bool force = false}) async =>
      Get.deleteAll(force: force);

  static void reloadAll({bool force = false}) => Get.reloadAll(force: force);

  static void reload<S>({String? tag, String? key, bool force = false}) =>
      Get.reload<S>(tag: tag, key: key, force: force);

  static bool isRegistered<S>({String? tag}) => Get.isRegistered<S>(tag: tag);

  static bool isPrepared<S>({String? tag}) => Get.isPrepared<S>(tag: tag);

  static void replace<P>(P child, {String? tag}) {
    final info = Get.getInstanceInfo<P>(tag: tag);
    final permanent = (info.isPermanent ?? false);
    delete<P>(tag: tag, force: permanent);
    Get.put(child, tag: tag, permanent: permanent);
  }

  static void lazyReplace<P>(InstanceBuilderCallback<P> builder,
      {String? tag, bool? fenix}) {
    final info = Get.getInstanceInfo<P>(tag: tag);
    final permanent = (info.isPermanent ?? false);
    delete<P>(tag: tag, force: permanent);
    Get.lazyPut(builder, tag: tag, fenix: fenix ?? permanent);
  }

  factory Bind.builder({
    Widget? child,
    InitBuilder<T>? init,
    InstanceCreateBuilderCallback<T>? create,
    bool global = true,
    bool autoRemove = true,
    bool assignId = false,
    Object Function(T value)? filter,
    String? tag,
    Object? id,
    void Function(BindElement<T> state)? initState,
    void Function(BindElement<T> state)? dispose,
    void Function(BindElement<T> state)? didChangeDependencies,
    void Function(Binder<T> oldWidget, BindElement<T> state)? didUpdateWidget,
  }) =>
      _FactoryBind<T>(
        // key: key,
        init: init,
        create: create,
        global: global,
        autoRemove: autoRemove,
        assignId: assignId,
        initState: initState,
        filter: filter,
        tag: tag,
        dispose: dispose,
        id: id,
        didChangeDependencies: didChangeDependencies,
        didUpdateWidget: didUpdateWidget,
        child: child,
      );

  static T of<T>(
    BuildContext context, {
    bool rebuild = false,
    // Object Function(T value)? filter,
  }) {
    final inheritedElement =
        context.getElementForInheritedWidgetOfExactType<Binder<T>>()
            as BindElement<T>?;

    if (inheritedElement == null) {
      throw BindError(controller: '$T', tag: null);
    }

    if (rebuild) {
      // var newFilter = filter?.call(inheritedElement.controller!);
      // if (newFilter != null) {
      //  context.dependOnInheritedElement(inheritedElement, aspect: newFilter);
      // } else {
      context.dependOnInheritedElement(inheritedElement);
      // }
    }

    final controller = inheritedElement.controller;

    return controller;
  }

  @factory
  Bind<T> _copyWithChild(Widget child);
}

class _FactoryBind<T> extends Bind<T> {
  @override
  final InitBuilder<T>? init;

  final InstanceCreateBuilderCallback<T>? create;

  @override
  final bool global;
  @override
  final Object? id;
  @override
  final String? tag;
  @override
  final bool autoRemove;
  @override
  final bool assignId;
  @override
  final Object Function(T value)? filter;

  @override
  final void Function(BindElement<T> state)? initState,
      dispose,
      didChangeDependencies;
  @override
  final void Function(Binder<T> oldWidget, BindElement<T> state)?
      didUpdateWidget;

  @override
  final Widget? child;

  const _FactoryBind({
    super.key,
    this.child,
    this.init,
    this.create,
    this.global = true,
    this.autoRemove = true,
    this.assignId = false,
    this.initState,
    this.filter,
    this.tag,
    this.dispose,
    this.id,
    this.didChangeDependencies,
    this.didUpdateWidget,
  }) : super(child: child);

  @override
  Bind<T> _copyWithChild(Widget child) {
    return Bind<T>.builder(
      init: init,
      create: create,
      global: global,
      autoRemove: autoRemove,
      assignId: assignId,
      initState: initState,
      filter: filter,
      tag: tag,
      dispose: dispose,
      id: id,
      didChangeDependencies: didChangeDependencies,
      didUpdateWidget: didUpdateWidget,
      child: child,
    );
  }

  @override
  Widget build(BuildContext context) {
    return Binder<T>(
      create: create,
      global: global,
      autoRemove: autoRemove,
      assignId: assignId,
      initState: initState,
      filter: filter,
      tag: tag,
      dispose: dispose,
      id: id,
      didChangeDependencies: didChangeDependencies,
      didUpdateWidget: didUpdateWidget,
      child: child!,
    );
  }
}

class Binds extends StatelessWidget {
  final List<Bind<dynamic>> binds;
  final Widget child;

  Binds({
    super.key,
    required this.binds,
    required this.child,
  }) : assert(binds.isNotEmpty);

  @override
  Widget build(BuildContext context) =>
      binds.reversed.fold(child, (widget, e) => e._copyWithChild(widget));
}

class Binder<T> extends InheritedWidget {
  /// Create an inherited widget that updates its dependents when [controller]
  /// sends notifications.
  ///
  /// The [child] argument is required
  const Binder({
    super.key,
    required super.child,
    this.init,
    this.global = true,
    this.autoRemove = true,
    this.assignId = false,
    this.lazy = true,
    this.initState,
    this.filter,
    this.tag,
    this.dispose,
    this.id,
    this.didChangeDependencies,
    this.didUpdateWidget,
    this.create,
  });

  final InitBuilder<T>? init;
  final InstanceCreateBuilderCallback? create;
  final bool global;
  final Object? id;
  final String? tag;
  final bool lazy;
  final bool autoRemove;
  final bool assignId;
  final Object Function(T value)? filter;
  final void Function(BindElement<T> state)? initState,
      dispose,
      didChangeDependencies;
  final void Function(Binder<T> oldWidget, BindElement<T> state)?
      didUpdateWidget;

  @override
  bool updateShouldNotify(Binder<T> oldWidget) {
    return oldWidget.id != id ||
        oldWidget.global != global ||
        oldWidget.autoRemove != autoRemove ||
        oldWidget.assignId != assignId;
  }

  @override
  InheritedElement createElement() => BindElement<T>(this);
}

/// The BindElement is responsible for injecting dependencies into the widget
/// tree so that they can be observed
class BindElement<T> extends InheritedElement {
  BindElement(Binder<T> super.widget) {
    initState();
  }

  final disposers = <Disposer>[];

  InitBuilder<T>? _controllerBuilder;

  T? _controller;

  T get controller {
    if (_controller == null) {
      _controller = _controllerBuilder?.call();
      _subscribeToController();
      if (_controller == null) {
        throw BindError(controller: T, tag: widget.tag);
      }
      return _controller!;
    } else {
      return _controller!;
    }
  }

  bool? _isCreator = false;
  bool? _needStart = false;
  bool _wasStarted = false;
  VoidCallback? _remove;
  Object? _filter;

  void initState() {
    widget.initState?.call(this);

    var isRegistered = Get.isRegistered<T>(tag: widget.tag);

    if (widget.global) {
      if (isRegistered) {
        if (Get.isPrepared<T>(tag: widget.tag)) {
          _isCreator = true;
        } else {
          _isCreator = false;
        }

        _controllerBuilder = () => Get.find<T>(tag: widget.tag);
      } else {
        _controllerBuilder =
            () => (widget.create?.call(this) ?? widget.init?.call());
        _isCreator = true;
        if (widget.lazy) {
          Get.lazyPut<T>(_controllerBuilder!, tag: widget.tag);
        } else {
          Get.put<T>(_controllerBuilder!(), tag: widget.tag);
        }
      }
    } else {
      if (widget.create != null) {
        _controllerBuilder = () => widget.create!.call(this);
        Get.spawn<T>(_controllerBuilder!, tag: widget.tag, permanent: false);
      } else {
        _controllerBuilder = widget.init;
      }
      _controllerBuilder =
          (widget.create != null ? () => widget.create!.call(this) : null) ??
              widget.init;
      _isCreator = true;
      _needStart = true;
    }
  }

  /// Register to listen Controller's events.
  /// It gets a reference to the remove() callback, to delete the
  /// setState "link" from the Controller.
  void _subscribeToController() {
    if (widget.filter != null) {
      _filter = widget.filter!(_controller as T);
    }
    final filter = _filter != null ? _filterUpdate : getUpdate;
    final localController = _controller;

    if (_needStart == true && localController is GetLifeCycleMixin) {
      localController.onStart();
      _needStart = false;
      _wasStarted = true;
    }

    if (localController is GetxController) {
      _remove?.call();
      _remove = (widget.id == null)
          ? localController.addListener(filter)
          : localController.addListenerId(widget.id, filter);
    } else if (localController is Listenable) {
      _remove?.call();
      localController.addListener(filter);
      _remove = () => localController.removeListener(filter);
    } else if (localController is StreamController) {
      _remove?.call();
      final stream = localController.stream.listen((_) => filter());
      _remove = () => stream.cancel();
    }
  }

  void _filterUpdate() {
    var newFilter = widget.filter!(_controller as T);
    if (newFilter != _filter) {
      _filter = newFilter;
      getUpdate();
    }
  }

  void dispose() {
    widget.dispose?.call(this);
    if (_isCreator! || widget.assignId) {
      if (widget.autoRemove && Get.isRegistered<T>(tag: widget.tag)) {
        Get.delete<T>(tag: widget.tag);
      }
    }

    for (final disposer in disposers) {
      disposer();
    }

    disposers.clear();

    _remove?.call();
    _controller = null;
    _isCreator = null;
    _remove = null;
    _filter = null;
    _needStart = null;
    _controllerBuilder = null;
    _controller = null;
  }

  @override
  Binder<T> get widget => super.widget as Binder<T>;

  var _dirty = false;

  @override
  void update(Binder<T> newWidget) {
    final oldNotifier = widget.id;
    final newNotifier = newWidget.id;
    if (oldNotifier != newNotifier && _wasStarted) {
      _subscribeToController();
    }
    widget.didUpdateWidget?.call(widget, this);
    super.update(newWidget);
  }

  @override
  void didChangeDependencies() {
    super.didChangeDependencies();
    widget.didChangeDependencies?.call(this);
  }

  @override
  Widget build() {
    if (_dirty) {
      notifyClients(widget);
    }
    // return Notifier.instance.notifyAppend(
    //   NotifyData(
    //       disposers: disposers, updater: getUpdate, throwException: false),
    return super.build();
    //);
  }

  void getUpdate() {
    _dirty = true;
    markNeedsBuild();
  }

  @override
  void notifyClients(Binder<T> oldWidget) {
    super.notifyClients(oldWidget);
    _dirty = false;
  }

  @override
  void unmount() {
    dispose();
    super.unmount();
  }
}

class BindError<T> extends Error {
  /// The type of the class the user tried to retrieve
  final T controller;
  final String? tag;

  /// Creates a [BindError]
  BindError({required this.controller, required this.tag});

  @override
  String toString() {
    if (controller == 'dynamic') {
      return '''Error: please specify type [<T>] when calling context.listen<T>() or context.find<T>() method.''';
    }

    return '''Error: No Bind<$controller>  ancestor found. To fix this, please add a Bind<$controller> widget ancestor to the current context.
      ''';
  }
}

/// [Binding] should be extended.
/// When using `GetMaterialApp`, all `GetPage`s and navigation
/// methods (like Get.to()) have a `binding` property that takes an
/// instance of Bindings to manage the
/// dependencies() (via Get.put()) for the Route you are opening.
// ignore: one_member_abstracts
abstract class Binding extends BindingsInterface<List<Bind>> {}
\n\n--- File: 4 # get_state_manager/src/simple/get_controllers.dart ---\n// ignore: prefer_mixin
import 'package:flutter/widgets.dart';

import '../../../instance_manager.dart';
import '../rx_flutter/rx_notifier.dart';
import 'list_notifier.dart';

// ignore: prefer_mixin
abstract class GetxController extends ListNotifier with GetLifeCycleMixin {
  /// Rebuilds `GetBuilder` each time you call `update()`;
  /// Can take a List of [ids], that will only update the matching
  /// `GetBuilder( id: )`,
  /// [ids] can be reused among `GetBuilders` like group tags.
  /// The update will only notify the Widgets, if [condition] is true.
  void update([List<Object>? ids, bool condition = true]) {
    if (!condition) {
      return;
    }
    if (ids == null) {
      refresh();
    } else {
      for (final id in ids) {
        refreshGroup(id);
      }
    }
  }
}

/// this mixin allow to fetch data when the scroll is at the bottom or on the
/// top
mixin ScrollMixin on GetLifeCycleMixin {
  final ScrollController scroll = ScrollController();

  @override
  void onInit() {
    super.onInit();
    scroll.addListener(_listener);
  }

  bool _canFetchBottom = true;

  bool _canFetchTop = true;

  void _listener() {
    if (scroll.position.atEdge) {
      _checkIfCanLoadMore();
    }
  }

  Future<void> _checkIfCanLoadMore() async {
    if (scroll.position.pixels == 0) {
      if (!_canFetchTop) return;
      _canFetchTop = false;
      await onTopScroll();
      _canFetchTop = true;
    } else {
      if (!_canFetchBottom) return;
      _canFetchBottom = false;
      await onEndScroll();
      _canFetchBottom = true;
    }
  }

  /// this method is called when the scroll is at the bottom
  Future<void> onEndScroll();

  /// this method is called when the scroll is at the top
  Future<void> onTopScroll();

  @override
  void onClose() {
    scroll.removeListener(_listener);
    super.onClose();
  }
}

/// A clean controller to be used with only Rx variables
abstract class RxController with GetLifeCycleMixin {}

/// A recommended way to use Getx with Future fetching
abstract class StateController<T> extends GetxController with StateMixin<T> {}

/// A controller with super lifecycles (including native lifecycles)
/// and StateMixins
abstract class SuperController<T> extends FullLifeCycleController
    with FullLifeCycleMixin, StateMixin<T> {}

/// A controller with super lifecycles (including native lifecycles)
abstract class FullLifeCycleController extends GetxController
    with
        // ignore: prefer_mixin
        WidgetsBindingObserver {}

mixin FullLifeCycleMixin on FullLifeCycleController {
  @mustCallSuper
  @override
  void onInit() {
    super.onInit();
    Engine.instance.addObserver(this);
  }

  @mustCallSuper
  @override
  void onClose() {
    Engine.instance.removeObserver(this);
    super.onClose();
  }

  @mustCallSuper
  @override
  void didChangeAppLifecycleState(AppLifecycleState state) {
    switch (state) {
      case AppLifecycleState.resumed:
        onResumed();
        break;
      case AppLifecycleState.inactive:
        onInactive();
        break;
      case AppLifecycleState.paused:
        onPaused();
        break;
      case AppLifecycleState.detached:
        onDetached();
        break;
      case AppLifecycleState.hidden:
        onHidden();
        break;
    }
  }

  void onResumed() {}
  void onPaused() {}
  void onInactive() {}
  void onDetached() {}
  void onHidden() {}
}
\n\n--- File: 6 # get_state_manager/src/simple/simple_builder.dart ---\nimport 'dart:async';

import 'package:flutter/widgets.dart';

import 'list_notifier.dart';

typedef ValueBuilderUpdateCallback<T> = void Function(T snapshot);
typedef ValueBuilderBuilder<T> = Widget Function(
    T snapshot, ValueBuilderUpdateCallback<T> updater);

/// Manages a local state like ObxValue, but uses a callback instead of
/// a Rx value.
///
/// Example:
/// ```
///  ValueBuilder<bool>(
///    initialValue: false,
///    builder: (value, update) => Switch(
///    value: value,
///    onChanged: (flag) {
///       update( flag );
///    },),
///    onUpdate: (value) => print("Value updated: $value"),
///  ),
///  ```
class ValueBuilder<T> extends StatefulWidget {
  final T initialValue;
  final ValueBuilderBuilder<T> builder;
  final void Function()? onDispose;
  final void Function(T)? onUpdate;

  const ValueBuilder({
    super.key,
    required this.initialValue,
    this.onDispose,
    this.onUpdate,
    required this.builder,
  });

  @override
  ValueBuilderState<T> createState() => ValueBuilderState<T>();
}

class ValueBuilderState<T> extends State<ValueBuilder<T>> {
  late T value;
  @override
  void initState() {
    value = widget.initialValue;
    super.initState();
  }

  @override
  Widget build(BuildContext context) => widget.builder(value, updater);

  void updater(T newValue) {
    if (widget.onUpdate != null) {
      widget.onUpdate!(newValue);
    }
    setState(() {
      value = newValue;
    });
  }

  @override
  void dispose() {
    super.dispose();
    widget.onDispose?.call();
    if (value is ChangeNotifier) {
      (value as ChangeNotifier?)?.dispose();
    } else if (value is StreamController) {
      (value as StreamController?)?.close();
    }
  }
}

class ObxElement = StatelessElement with StatelessObserverComponent;

// It's a experimental feature
class Observer extends ObxStatelessWidget {
  final WidgetBuilder builder;

  const Observer({super.key, required this.builder});

  @override
  Widget build(BuildContext context) => builder(context);
}

/// A StatelessWidget than can listen reactive changes.
abstract class ObxStatelessWidget extends StatelessWidget {
  /// Initializes [key] for subclasses.
  const ObxStatelessWidget({super.key});
  @override
  StatelessElement createElement() => ObxElement(this);
}

/// a Component that can track changes in a reactive variable
mixin StatelessObserverComponent on StatelessElement {
  List<Disposer>? disposers = <Disposer>[];

  void getUpdate() {
    // if (disposers != null && !dirty) {
    //   markNeedsBuild();
    // }
    if (disposers != null) {
      scheduleMicrotask(markNeedsBuild);
    }
  }

  @override
  Widget build() {
    return Notifier.instance.append(
        NotifyData(disposers: disposers!, updater: getUpdate), super.build);
  }

  @override
  void unmount() {
    super.unmount();
    for (final disposer in disposers!) {
      disposer();
    }
    disposers!.clear();
    disposers = null;
  }
}
\n\n--- File: 7 # get_state_manager/src/simple/get_view.dart ---\nimport 'package:flutter/widgets.dart';

import '../../../instance_manager.dart';
import '../../../utils.dart';
import 'get_state.dart';
import 'get_widget_cache.dart';

/// GetView is a great way of quickly access your Controller
/// without having to call `Get.find<AwesomeController>()` yourself.
///
/// Sample:
/// ```
/// class AwesomeController extends GetxController {
///   final String title = 'My Awesome View';
/// }
///
/// class AwesomeView extends GetView<AwesomeController> {
///   /// if you need you can pass the tag for
///   /// Get.find<AwesomeController>(tag:"myTag");
///   @override
///   final String tag = "myTag";
///
///   AwesomeView({Key key}):super(key:key);
///
///   @override
///   Widget build(BuildContext context) {
///     return Container(
///       padding: EdgeInsets.all(20),
///       child: Text( controller.title ),
///     );
///   }
/// }
///``
abstract class GetView<T> extends StatelessWidget {
  const GetView({super.key});

  final String? tag = null;

  T get controller => Get.find<T>(tag: tag)!;

  @override
  Widget build(BuildContext context);
}

/// GetWidget is a great way of quickly access your individual Controller
/// without having to call `Get.find<AwesomeController>()` yourself.
/// Get save you controller on cache, so, you can to use Get.create() safely
/// GetWidget is perfect to multiples instance of a same controller. Each
/// GetWidget will have your own controller, and will be call events as `onInit`
/// and `onClose` when the controller get in/get out on memory.
abstract class GetWidget<S extends GetLifeCycleMixin> extends GetWidgetCache {
  const GetWidget({super.key});

  @protected
  final String? tag = null;

  S get controller => GetWidget._cache[this] as S;

  // static final _cache = <GetWidget, GetLifeCycleBase>{};

  static final _cache = Expando<GetLifeCycleMixin>();

  @protected
  Widget build(BuildContext context);

  @override
  WidgetCache createWidgetCache() => _GetCache<S>();
}

class _GetCache<S extends GetLifeCycleMixin> extends WidgetCache<GetWidget<S>> {
  S? _controller;
  bool _isCreator = false;
  InstanceInfo? info;
  @override
  void onInit() {
    info = Get.getInstanceInfo<S>(tag: widget!.tag);

    _isCreator = info!.isPrepared && info!.isCreate;

    if (info!.isRegistered) {
      _controller = Get.find<S>(tag: widget!.tag);
    }

    GetWidget._cache[widget!] = _controller;

    super.onInit();
  }

  @override
  void onClose() {
    if (_isCreator) {
      Get.asap(() {
        widget!.controller.onDelete();
        Get.log('"${widget!.controller.runtimeType}" onClose() called');
        Get.log('"${widget!.controller.runtimeType}" deleted from memory');
        // GetWidget._cache[widget!] = null;
      });
    }
    info = null;
    super.onClose();
  }

  @override
  Widget build(BuildContext context) {
    return Binder(
      init: () => _controller,
      child: widget!.build(context),
    );
  }
}
\n\n--- File: 11 # get_state_manager/src/rx_flutter/rx_obx_widget.dart ---\nimport 'package:flutter/widgets.dart';

import '../../../get_rx/src/rx_types/rx_types.dart';
import '../simple/simple_builder.dart';

typedef WidgetCallback = Widget Function();

/// The [ObxWidget] is the base for all GetX reactive widgets
///
/// See also:
/// - [Obx]
/// - [ObxValue]
abstract class ObxWidget extends ObxStatelessWidget {
  const ObxWidget({super.key});
}

/// The simplest reactive widget in GetX.
///
/// Just pass your Rx variable in the root scope of the callback to have it
/// automatically registered for changes.
///
/// final _name = "GetX".obs;
/// Obx(() => Text( _name.value )),... ;
class Obx extends ObxWidget {
  final WidgetCallback builder;

  const Obx(this.builder, {super.key});

  @override
  Widget build(BuildContext context) {
    return builder();
  }
}

/// Similar to Obx, but manages a local state.
/// Pass the initial data in constructor.
/// Useful for simple local states, like toggles, visibility, themes,
/// button states, etc.
///  Sample:
///    ObxValue((data) => Switch(
///      value: data.value,
///      onChanged: (flag) => data.value = flag,
///    ),
///    false.obs,
///   ),
class ObxValue<T extends RxInterface> extends ObxWidget {
  final Widget Function(T) builder;
  final T data;

  const ObxValue(this.builder, this.data, {super.key});

  @override
  Widget build(BuildContext context) => builder(data);
}
\n\n--- File: 12 # get_state_manager/src/rx_flutter/rx_getx_widget.dart ---\nimport 'package:flutter/foundation.dart';
import 'package:flutter/widgets.dart';

import '../../../get_core/get_core.dart';
import '../../../get_instance/src/extension_instance.dart';
import '../../../get_instance/src/lifecycle.dart';
import '../simple/list_notifier.dart';

typedef GetXControllerBuilder<T extends GetLifeCycleMixin> = Widget Function(
    T controller);

class GetX<T extends GetLifeCycleMixin> extends StatefulWidget {
  final GetXControllerBuilder<T> builder;
  final bool global;
  final bool autoRemove;
  final bool assignId;
  final void Function(GetXState<T> state)? initState,
      dispose,
      didChangeDependencies;
  final void Function(GetX oldWidget, GetXState<T> state)? didUpdateWidget;
  final T? init;
  final String? tag;

  const GetX({
    super.key,
    this.tag,
    required this.builder,
    this.global = true,
    this.autoRemove = true,
    this.initState,
    this.assignId = false,
    //  this.stream,
    this.dispose,
    this.didChangeDependencies,
    this.didUpdateWidget,
    this.init,
    // this.streamController
  });

  @override
  StatefulElement createElement() => StatefulElement(this);

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
      ..add(
        DiagnosticsProperty<T>('controller', init),
      )
      ..add(DiagnosticsProperty<String>('tag', tag))
      ..add(
          ObjectFlagProperty<GetXControllerBuilder<T>>.has('builder', builder));
  }

  @override
  GetXState<T> createState() => GetXState<T>();
}

class GetXState<T extends GetLifeCycleMixin> extends State<GetX<T>> {
  T? controller;
  bool? _isCreator = false;

  @override
  void initState() {
    // var isPrepared = Get.isPrepared<T>(tag: widget.tag);
    final isRegistered = Get.isRegistered<T>(tag: widget.tag);

    if (widget.global) {
      if (isRegistered) {
        _isCreator = Get.isPrepared<T>(tag: widget.tag);
        controller = Get.find<T>(tag: widget.tag);
      } else {
        controller = widget.init;
        _isCreator = true;
        Get.put<T>(controller!, tag: widget.tag);
      }
    } else {
      controller = widget.init;
      _isCreator = true;
      controller?.onStart();
    }
    widget.initState?.call(this);
    if (widget.global && Get.smartManagement == SmartManagement.onlyBuilder) {
      controller?.onStart();
    }

    super.initState();
  }

  @override
  void didChangeDependencies() {
    super.didChangeDependencies();
    if (widget.didChangeDependencies != null) {
      widget.didChangeDependencies!(this);
    }
  }

  @override
  void didUpdateWidget(GetX oldWidget) {
    super.didUpdateWidget(oldWidget as GetX<T>);
    widget.didUpdateWidget?.call(oldWidget, this);
  }

  @override
  void dispose() {
    if (widget.dispose != null) widget.dispose!(this);
    if (_isCreator! || widget.assignId) {
      if (widget.autoRemove && Get.isRegistered<T>(tag: widget.tag)) {
        Get.delete<T>(tag: widget.tag);
      }
    }

    for (final disposer in disposers) {
      disposer();
    }

    disposers.clear();

    controller = null;
    _isCreator = null;
    super.dispose();
  }

  void _update() {
    if (mounted) {
      setState(() {});
    }
  }

  final disposers = <Disposer>[];

  @override
  Widget build(BuildContext context) => Notifier.instance.append(
      NotifyData(disposers: disposers, updater: _update),
      () => widget.builder(controller!));

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties.add(DiagnosticsProperty<T>('controller', controller));
  }
}
\n\n--- File: 13 # get_state_manager/src/rx_flutter/rx_notifier.dart ---\nimport 'dart:async';

import 'package:flutter/foundation.dart';
import 'package:flutter/material.dart';
import 'package:get/utils.dart';

import '../../../get_rx/src/rx_types/rx_types.dart';
import '../../../instance_manager.dart';
import '../../get_state_manager.dart';
import '../simple/list_notifier.dart';

extension _Empty on Object {
  bool _isEmpty() {
    final val = this;
    // if (val == null) return true;
    var result = false;
    if (val is Iterable) {
      result = val.isEmpty;
    } else if (val is String) {
      result = val.trim().isEmpty;
    } else if (val is Map) {
      result = val.isEmpty;
    }
    return result;
  }
}

mixin StateMixin<T> on ListNotifier {
  T? _value;
  GetStatus<T>? _status;

  void _fillInitialStatus() {
    _status = (_value == null || _value!._isEmpty())
        ? GetStatus<T>.loading()
        : GetStatus<T>.success(_value as T);
  }

  GetStatus<T> get status {
    reportRead();
    return _status ??= _status = GetStatus.loading();
  }

  T get state => value;

  set status(GetStatus<T> newStatus) {
    if (newStatus == status) return;
    _status = newStatus;
    if (newStatus is SuccessStatus<T>) {
      _value = newStatus.data;
    }
    refresh();
  }

  @protected
  T get value {
    reportRead();
    return _value as T;
  }

  @protected
  set value(T newValue) {
    if (_value == newValue) return;
    _value = newValue;
    refresh();
  }

  @protected
  void change(GetStatus<T> status) {
    if (status != this.status) {
      this.status = status;
    }
  }

  void setSuccess(T data) {
    change(GetStatus<T>.success(data));
  }

  void setError(Object error) {
    change(GetStatus<T>.error(error));
  }

  void setLoading() {
    change(GetStatus<T>.loading());
  }

  void setEmpty() {
    change(GetStatus<T>.empty());
  }

  void futurize(Future<T> Function() body,
      {T? initialData, String? errorMessage, bool useEmpty = true}) {
    final compute = body;
    _value ??= initialData;
    status = GetStatus<T>.loading();
    compute().then((newValue) {
      if ((newValue == null || newValue._isEmpty()) && useEmpty) {
        status = GetStatus<T>.empty();
      } else {
        status = GetStatus<T>.success(newValue);
      }

      refresh();
    }, onError: (err) {
      status = GetStatus.error(
          err is Exception ? err : Exception(errorMessage ?? err.toString()));
      refresh();
    });
  }
}

typedef FuturizeCallback<T> = Future<T> Function(VoidCallback fn);

typedef VoidCallback = void Function();

class GetListenable<T> extends ListNotifierSingle implements RxInterface<T> {
  GetListenable(T val) : _value = val;

  StreamController<T>? _controller;

  StreamController<T> get subject {
    if (_controller == null) {
      _controller =
          StreamController<T>.broadcast(onCancel: addListener(_streamListener));
      _controller?.add(_value);

      ///TODO: report to controller dispose
    }
    return _controller!;
  }

  void _streamListener() {
    _controller?.add(_value);
  }

  @override
  @mustCallSuper
  void close() {
    removeListener(_streamListener);
    _controller?.close();
    dispose();
  }

  Stream<T> get stream {
    return subject.stream;
  }

  T _value;

  @override
  T get value {
    reportRead();
    return _value;
  }

  void _notify() {
    refresh();
  }

  set value(T newValue) {
    if (_value == newValue) return;
    _value = newValue;
    _notify();
  }

  T? call([T? v]) {
    if (v != null) {
      value = v;
    }
    return value;
  }

  @override
  StreamSubscription<T> listen(
    void Function(T)? onData, {
    Function? onError,
    void Function()? onDone,
    bool? cancelOnError,
  }) =>
      stream.listen(
        onData,
        onError: onError,
        onDone: onDone,
        cancelOnError: cancelOnError ?? false,
      );

  @override
  String toString() => value.toString();
}

class Value<T> extends ListNotifier
    with StateMixin<T>
    implements ValueListenable<T?> {
  Value(T val) {
    _value = val;
    _fillInitialStatus();
  }

  @override
  T get value {
    reportRead();
    return _value as T;
  }

  @override
  set value(T newValue) {
    if (_value == newValue) return;
    _value = newValue;
    refresh();
  }

  T? call([T? v]) {
    if (v != null) {
      value = v;
    }
    return value;
  }

  void update(T Function(T? value) fn) {
    value = fn(value);
    // refresh();
  }

  @override
  String toString() => value.toString();

  dynamic toJson() => (value as dynamic)?.toJson();
}

/// GetNotifier has a native status and state implementation, with the
/// Get Lifecycle
abstract class GetNotifier<T> extends Value<T> with GetLifeCycleMixin {
  GetNotifier(super.initial);
}

extension StateExt<T> on StateMixin<T> {
  Widget obx(
    NotifierBuilder<T> widget, {
    Widget Function(String? error)? onError,
    Widget? onLoading,
    Widget? onEmpty,
    WidgetBuilder? onCustom,
  }) {
    return Observer(builder: (context) {
      if (status.isLoading) {
        return onLoading ?? const Center(child: CircularProgressIndicator());
      } else if (status.isError) {
        return onError != null
            ? onError(status.errorMessage)
            : Center(child: Text('A error occurred: ${status.errorMessage}'));
      } else if (status.isEmpty) {
        return onEmpty ??
            const SizedBox.shrink(); // Also can be widget(null); but is risky
      } else if (status.isSuccess) {
        return widget(value);
      } else if (status.isCustom) {
        return onCustom?.call(context) ??
            const SizedBox.shrink(); // Also can be widget(null); but is risky
      }
      return widget(value);
    });
  }
}

typedef NotifierBuilder<T> = Widget Function(T state);

abstract class GetStatus<T> with Equality {
  const GetStatus();

  factory GetStatus.loading() => LoadingStatus<T>();

  factory GetStatus.error(Object message) => ErrorStatus<T, Object>(message);

  factory GetStatus.empty() => EmptyStatus<T>();

  factory GetStatus.success(T data) => SuccessStatus<T>(data);

  factory GetStatus.custom() => CustomStatus<T>();
}

class CustomStatus<T> extends GetStatus<T> {
  @override
  List get props => [];
}

class LoadingStatus<T> extends GetStatus<T> {
  @override
  List get props => [];
}

class SuccessStatus<T> extends GetStatus<T> {
  final T data;

  const SuccessStatus(this.data);

  @override
  List get props => [data];
}

class ErrorStatus<T, S> extends GetStatus<T> {
  final S? error;

  const ErrorStatus([this.error]);

  @override
  List get props => [error];
}

class EmptyStatus<T> extends GetStatus<T> {
  @override
  List get props => [];
}

extension StatusDataExt<T> on GetStatus<T> {
  bool get isLoading => this is LoadingStatus;

  bool get isSuccess => this is SuccessStatus;

  bool get isError => this is ErrorStatus;

  bool get isEmpty => this is EmptyStatus;

  bool get isCustom => !isLoading && !isSuccess && !isError && !isEmpty;

  dynamic get error {
    if (this is ErrorStatus) {
      return (this as ErrorStatus).error;
    }
    return null;
  }

  String get errorMessage {
    final isError = this is ErrorStatus;
    if (isError) {
      final err = this as ErrorStatus;
      if (err.error != null) {
        if (err.error is String) {
          return err.error as String;
        }
        return err.error.toString();
      }
    }

    return '';
  }

  T? get data {
    if (this is SuccessStatus<T>) {
      final success = this as SuccessStatus<T>;
      return success.data;
    }
    return null;
  }
}
\n\n--- File: 17 # get_rx/src/rx_workers/rx_workers.dart ---\nimport 'dart:async';

import '../../../get_core/get_core.dart';
import '../../../get_state_manager/src/rx_flutter/rx_notifier.dart';
import '../rx_types/rx_types.dart';
import 'utils/debouncer.dart';

bool _conditional(dynamic condition) {
  if (condition == null) return true;
  if (condition is bool) return condition;
  if (condition is bool Function()) return condition();
  return true;
}

typedef WorkerCallback<T> = Function(T callback);

class Workers {
  Workers(this.workers);
  final List<Worker> workers;

  void dispose() {
    for (final worker in workers) {
      if (!worker._disposed) {
        worker.dispose();
      }
    }
  }
}

///
/// Called every time [listener] changes. As long as the [condition]
/// returns true.
///
/// Sample:
/// Every time increment() is called, ever() will process the [condition]
/// (can be a [bool] expression or a `bool Function()`), and only call
/// the callback when [condition] is true.
/// In our case, only when count is bigger to 5. In order to "dispose"
/// this Worker
/// that will run forever, we made a `worker` variable. So, when the count value
/// reaches 10, the worker gets disposed, and releases any memory resources.
///
/// ```
/// // imagine some counter widget...
///
/// class _CountController extends GetxController {
///   final count = 0.obs;
///   Worker worker;
///
///   void onInit() {
///     worker = ever(count, (value) {
///       print('counter changed to: $value');
///       if (value == 10) worker.dispose();
///     }, condition: () => count > 5);
///   }
///
///   void increment() => count + 1;
/// }
/// ```
Worker ever<T>(
  GetListenable<T> listener,
  WorkerCallback<T> callback, {
  dynamic condition = true,
  Function? onError,
  void Function()? onDone,
  bool? cancelOnError,
}) {
  StreamSubscription sub = listener.listen(
    (event) {
      if (_conditional(condition)) callback(event);
    },
    onError: onError,
    onDone: onDone,
    cancelOnError: cancelOnError,
  );
  return Worker(sub.cancel, '[ever]');
}

/// Similar to [ever], but takes a list of [listeners], the condition
/// for the [callback] is common to all [listeners],
/// and the [callback] is executed to each one of them. The [Worker] is
/// common to all, so `worker.dispose()` will cancel all streams.
Worker everAll(
  List<RxInterface> listeners,
  WorkerCallback callback, {
  dynamic condition = true,
  Function? onError,
  void Function()? onDone,
  bool? cancelOnError,
}) {
  final evers = <StreamSubscription>[];
  for (var i in listeners) {
    final sub = i.listen(
      (event) {
        if (_conditional(condition)) callback(event);
      },
      onError: onError,
      onDone: onDone,
      cancelOnError: cancelOnError,
    );
    evers.add(sub);
  }

  Future<void> cancel() async {
    for (var i in evers) {
      i.cancel();
    }
  }

  return Worker(cancel, '[everAll]');
}

/// `once()` will execute only 1 time when [condition] is met and cancel
/// the subscription to the [listener] stream right after that.
/// [condition] defines when [callback] is called, and
/// can be a [bool] or a `bool Function()`.
///
/// Sample:
/// ```
///  class _CountController extends GetxController {
///   final count = 0.obs;
///   Worker worker;
///
///   @override
///   Future<void> onInit() async {
///     worker = once(count, (value) {
///       print("counter reached $value before 3 seconds.");
///     }, condition: () => count() > 2);
///     3.delay(worker.dispose);
///   }
///   void increment() => count + 1;
/// }
///```
Worker once<T>(
  GetListenable<T> listener,
  WorkerCallback<T> callback, {
  dynamic condition = true,
  Function? onError,
  void Function()? onDone,
  bool? cancelOnError,
}) {
  late Worker ref;
  StreamSubscription? sub;
  sub = listener.listen(
    (event) {
      if (!_conditional(condition)) return;
      ref._disposed = true;
      ref._log('called');
      sub?.cancel();
      callback(event);
    },
    onError: onError,
    onDone: onDone,
    cancelOnError: cancelOnError,
  );
  ref = Worker(sub.cancel, '[once]');
  return ref;
}

/// Ignore all changes in [listener] during [time] (1 sec by default) or until
/// [condition] is met (can be a [bool] expression or a `bool Function()`),
/// It brings the 1st "value" since the period of time, so
/// if you click a counter button 3 times in 1 sec, it will show you "1"
/// (after 1 sec of the first press)
/// click counter 3 times in 1 sec, it will show you "4" (after 1 sec)
/// click counter 2 times in 1 sec, it will show you "7" (after 1 sec).
///
/// Sample:
/// // wait 1 sec each time an event starts, only if counter is lower than 20.
/// worker = interval(
///    count,
///    (value) => print(value),
///    time: 1.seconds,
///    condition: () => count < 20,
/// );
/// ```
Worker interval<T>(
  GetListenable<T> listener,
  WorkerCallback<T> callback, {
  Duration time = const Duration(seconds: 1),
  dynamic condition = true,
  Function? onError,
  void Function()? onDone,
  bool? cancelOnError,
}) {
  var debounceActive = false;
  StreamSubscription sub = listener.listen(
    (event) async {
      if (debounceActive || !_conditional(condition)) return;
      debounceActive = true;
      await Future.delayed(time);
      debounceActive = false;
      callback(event);
    },
    onError: onError,
    onDone: onDone,
    cancelOnError: cancelOnError,
  );
  return Worker(sub.cancel, '[interval]');
}

/// [debounce] is similar to [interval], but sends the last value.
/// Useful for Anti DDos, every time the user stops typing for 1 second,
/// for instance.
/// When [listener] emits the last "value", when [time] hits,
/// it calls [callback] with the last "value" emitted.
///
/// Sample:
///
/// ```
/// worker = debounce(
///      count,
///      (value) {
///        print(value);
///        if( value > 20 ) worker.dispose();
///      },
///      time: 1.seconds,
///    );
///  }
///  ```
Worker debounce<T>(
  GetListenable<T> listener,
  WorkerCallback<T> callback, {
  Duration? time,
  Function? onError,
  void Function()? onDone,
  bool? cancelOnError,
}) {
  final newDebouncer =
      Debouncer(delay: time ?? const Duration(milliseconds: 800));
  StreamSubscription sub = listener.listen(
    (event) {
      newDebouncer(() {
        callback(event);
      });
    },
    onError: onError,
    onDone: onDone,
    cancelOnError: cancelOnError,
  );
  return Worker(sub.cancel, '[debounce]');
}

class Worker {
  Worker(this.worker, this.type);

  /// subscription.cancel() callback
  final Future<void> Function() worker;

  /// type of worker (debounce, interval, ever)..
  final String type;
  bool _disposed = false;

  bool get disposed => _disposed;

  //final bool _verbose = true;
  void _log(String msg) {
    //  if (!_verbose) return;
    Get.log('$runtimeType $type $msg');
  }

  void dispose() {
    if (_disposed) {
      _log('already disposed');
      return;
    }
    _disposed = true;
    worker();
    _log('disposed');
  }

  void call() => dispose();
}
\n\n--- File: 18 # get_rx/src/rx_workers/utils/debouncer.dart ---\nimport 'dart:async';

/// This "function" class is the implementation of `debouncer()` Worker.
/// It calls the function passed after specified [delay] parameter.
/// Example:
/// ```
/// final delayed = Debouncer( delay: Duration( seconds: 1 )) ;
/// print( 'the next function will be called after 1 sec' );
/// delayed( () => print( 'called after 1 sec' ));
/// ```
class Debouncer {
  final Duration delay;
  Timer? _timer;

  Debouncer({required this.delay});

  void call(void Function() action) {
    _timer?.cancel();
    _timer = Timer(delay, action);
  }

  /// Notifies if the delayed call is active.
  bool get isRunning => _timer?.isActive ?? false;

  /// Cancel the current delayed call.
  void cancel() => _timer?.cancel();
}
\n\n--- File: 19 # get_rx/src/rx_types/rx_types.dart ---\nlibrary;

import 'dart:async';
import 'dart:collection';

import 'package:flutter/foundation.dart';

import '../../../get_state_manager/src/rx_flutter/rx_notifier.dart';
import '../rx_typedefs/rx_typedefs.dart';

part 'rx_core/rx_impl.dart';
part 'rx_core/rx_interface.dart';
part 'rx_core/rx_num.dart';
part 'rx_core/rx_string.dart';
part 'rx_iterables/rx_list.dart';
part 'rx_iterables/rx_map.dart';
part 'rx_iterables/rx_set.dart';
\n\n--- File: 23 # get_rx/src/rx_types/rx_core/rx_interface.dart ---\npart of '../rx_types.dart';

/// This class is the foundation for all reactive (Rx) classes that makes Get
/// so powerful.
/// This interface is the contract that `_RxImpl<T>` uses in all it's
/// subclass.
abstract class RxInterface<T> implements ValueListenable<T> {
  /// Close the Rx Variable
  void close();

  /// Calls `callback` with current value, when the value changes.
  StreamSubscription<T> listen(void Function(T event) onData,
      {Function? onError, void Function()? onDone, bool? cancelOnError});
}

class ObxError {
  const ObxError();
  @override
  String toString() {
    return """
      [Get] the improper use of a GetX has been detected. 
      You should only use GetX or Obx for the specific widget that will be updated.
      If you are seeing this error, you probably did not insert any observable variables into GetX/Obx 
      or insert them outside the scope that GetX considers suitable for an update 
      (example: GetX => HeavyWidget => variableObservable).
      If you need to update a parent widget and a child widget, wrap each one in an Obx/GetX.
      """;
  }
}
\n\n--- File: 24 # get_rx/src/rx_types/rx_core/rx_impl.dart ---\npart of '../rx_types.dart';

/// global object that registers against `GetX` and `Obx`, and allows the
/// reactivity
/// of those `Widgets` and Rx values.

mixin RxObjectMixin<T> on GetListenable<T> {
  //late T _value;

  /// Makes a direct update of [value] adding it to the Stream
  /// useful when you make use of Rx for custom Types to refresh your UI.
  ///
  /// Sample:
  /// ```
  ///  class Person {
  ///     String name, last;
  ///     int age;
  ///     Person({this.name, this.last, this.age});
  ///     @override
  ///     String toString() => '$name $last, $age years old';
  ///  }
  ///
  /// final person = Person(name: 'John', last: 'Doe', age: 18).obs;
  /// person.value.name = 'Roi';
  /// person.refresh();
  /// print( person );
  /// ```
  // void refresh() {
  //   subject.add(value);
  // }

  /// updates the value to `null` and adds it to the Stream.
  /// Even with null-safety coming, is still an important feature to support, as
  /// `call()` doesn't accept `null` values. For instance,
  /// `InputDecoration.errorText` has to be null to not show the "error state".
  ///
  /// Sample:
  /// ```
  /// final inputError = ''.obs..nil();
  /// print('${inputError.runtimeType}: $inputError'); // outputs > RxString: null
  /// ```
  // void nil() {
  //   subject.add(_value = null);
  // }

  /// Makes this Rx looks like a function so you can update a new
  /// value using `rx(someOtherValue)`. Practical to assign the Rx directly
  /// to some Widget that has a signature ::onChange( value )
  ///
  /// Example:
  /// ```
  /// final myText = 'GetX rocks!'.obs;
  ///
  /// // in your Constructor, just to check it works :P
  /// ever( myText, print ) ;
  ///
  /// // in your build(BuildContext) {
  /// TextField(
  ///   onChanged: myText,
  /// ),
  ///```
  @override
  T call([T? v]) {
    if (v != null) {
      value = v;
    }
    return value;
  }

  bool firstRebuild = true;
  bool sentToStream = false;

  /// Same as `toString()` but using a getter.
  String get string => value.toString();

  @override
  String toString() => value.toString();

  /// Returns the json representation of `value`.
  dynamic toJson() => value;

  /// This equality override works for _RxImpl instances and the internal
  /// values.
  @override
  // ignore: avoid_equals_and_hash_code_on_mutable_classes
  bool operator ==(Object o) {
    // Todo, find a common implementation for the hashCode of different Types.
    if (o is T) return value == o;
    if (o is RxObjectMixin<T>) return value == o.value;
    return false;
  }

  @override
  // ignore: avoid_equals_and_hash_code_on_mutable_classes
  int get hashCode => value.hashCode;

  /// Updates the [value] and adds it to the stream, updating the observer
  /// Widget, only if it's different from the previous value.
  @override
  set value(T val) {
    if (isDisposed) return;
    sentToStream = false;
    if (value == val && !firstRebuild) return;
    firstRebuild = false;
    sentToStream = true;
    super.value = val;
  }

  /// Returns a [StreamSubscription] similar to [listen], but with the
  /// added benefit that it primes the stream with the current [value], rather
  /// than waiting for the next [value]. This should not be called in [onInit]
  /// or anywhere else during the build process.
  StreamSubscription<T> listenAndPump(void Function(T event) onData,
      {Function? onError, void Function()? onDone, bool? cancelOnError}) {
    final subscription = listen(
      onData,
      onError: onError,
      onDone: onDone,
      cancelOnError: cancelOnError,
    );

    subject.add(value);

    return subscription;
  }

  /// Binds an existing `Stream<T>` to this `Rx<T>` to keep the values in sync.
  /// You can bind multiple sources to update the value.
  /// Closing the subscription will happen automatically when the observer
  /// Widget (`GetX` or `Obx`) gets unmounted from the Widget tree.
  void bindStream(Stream<T> stream) {
    // final listSubscriptions =
    //     _subscriptions[subject] ??= <StreamSubscription>[];

    final sub = stream.listen((va) => value = va);
    reportAdd(sub.cancel);
  }
}

/// Base Rx class that manages all the stream logic for any Type.
abstract class _RxImpl<T> extends GetListenable<T> with RxObjectMixin<T> {
  _RxImpl(super.initial);

  void addError(Object error, [StackTrace? stackTrace]) {
    subject.addError(error, stackTrace);
  }

  Stream<R> map<R>(R Function(T? data) mapper) => stream.map(mapper);

  /// Uses a callback to update [value] internally, similar to [refresh],
  /// but provides the current value as the argument.
  /// Makes sense for custom Rx types (like Models).
  ///
  /// Sample:
  /// ```
  ///  class Person {
  ///     String name, last;
  ///     int age;
  ///     Person({this.name, this.last, this.age});
  ///     @override
  ///     String toString() => '$name $last, $age years old';
  ///  }
  ///
  /// final person = Person(name: 'John', last: 'Doe', age: 18).obs;
  /// person.update((person) {
  ///   person.name = 'Roi';
  /// });
  /// print( person );
  /// ```
  void update(T Function(T? val) fn) {
    value = fn(value);
    // subject.add(value);
  }

  /// Following certain practices on Rx data, we might want to react to certain
  /// listeners when a value has been provided, even if the value is the same.
  /// At the moment, we ignore part of the process if we `.call(value)` with
  /// the same value since it holds the value and there's no real
  /// need triggering the entire process for the same value inside, but
  /// there are other situations where we might be interested in
  /// triggering this.
  ///
  /// For example, supposed we have a `int seconds = 2` and we want to animate
  /// from invisible to visible a widget in two seconds:
  /// `RxEvent<int>.call(seconds);`
  /// then after a click happens, you want to call a `RxEvent<int>.call(seconds)`.
  /// By doing `call(seconds)`, if the value being held is the same,
  /// the listeners won't trigger, hence we need this new `trigger` function.
  /// This will refresh the listener of an AnimatedWidget and will keep
  /// the value if the Rx is kept in memory.
  /// Sample:
  /// ```
  /// Rx<Int> secondsRx = RxInt();
  /// secondsRx.listen((value) => print("$value seconds set"));
  ///
  /// secondsRx.call(2);      // This won't trigger any listener, since the value is the same
  /// secondsRx.trigger(2);   // This will trigger the listener independently from the value.
  /// ```
  ///
  void trigger(T v) {
    var firstRebuild = this.firstRebuild;
    value = v;
    // If it's not the first rebuild, the listeners have been called already
    // So we won't call them again.
    if (!firstRebuild && !sentToStream) {
      subject.add(v);
    }
  }
}

class RxBool extends Rx<bool> {
  RxBool(super.initial);
  @override
  String toString() {
    return value ? "true" : "false";
  }
}

class RxnBool extends Rx<bool?> {
  RxnBool([super.initial]);
  @override
  String toString() {
    return "$value";
  }
}

extension RxBoolExt on Rx<bool> {
  bool get isTrue => value;

  bool get isFalse => !isTrue;

  bool operator &(bool other) => other && value;

  bool operator |(bool other) => other || value;

  bool operator ^(bool other) => !other == value;

  /// Toggles the bool [value] between false and true.
  /// A shortcut for `flag.value = !flag.value;`
  void toggle() {
    call(!value);
    // return this;
  }
}

extension RxnBoolExt on Rx<bool?> {
  bool? get isTrue => value;

  bool? get isFalse {
    if (value != null) return !isTrue!;
    return null;
  }

  bool? operator &(bool other) {
    if (value != null) {
      return other && value!;
    }
    return null;
  }

  bool? operator |(bool other) {
    if (value != null) {
      return other || value!;
    }
    return null;
  }

  bool? operator ^(bool other) => !other == value;

  /// Toggles the bool [value] between false and true.
  /// A shortcut for `flag.value = !flag.value;`
  void toggle() {
    if (value != null) {
      call(!value!);
      // return this;
    }
  }
}

/// Foundation class used for custom `Types` outside the common native Dart
/// types.
/// For example, any custom "Model" class, like User().obs will use `Rx` as
/// wrapper.
class Rx<T> extends _RxImpl<T> {
  Rx(super.initial);

  @override
  dynamic toJson() {
    try {
      return (value as dynamic)?.toJson();
    } on Exception catch (_) {
      throw '$T has not method [toJson]';
    }
  }
}

class Rxn<T> extends Rx<T?> {
  Rxn([super.initial]);

  @override
  dynamic toJson() {
    try {
      return (value as dynamic)?.toJson();
    } on Exception catch (_) {
      throw '$T has not method [toJson]';
    }
  }
}

extension StringExtension on String {
  /// Returns a `RxString` with [this] `String` as initial value.
  RxString get obs => RxString(this);
}

extension IntExtension on int {
  /// Returns a `RxInt` with [this] `int` as initial value.
  RxInt get obs => RxInt(this);
}

extension DoubleExtension on double {
  /// Returns a `RxDouble` with [this] `double` as initial value.
  RxDouble get obs => RxDouble(this);
}

extension BoolExtension on bool {
  /// Returns a `RxBool` with [this] `bool` as initial value.
  RxBool get obs => RxBool(this);
}

extension RxT<T extends Object> on T {
  /// Returns a `Rx` instance with [this] `T` as initial value.
  Rx<T> get obs => Rx<T>(this);
}

/// This method will replace the old `.obs` method.
/// It's a breaking change, but it is essential to avoid conflicts with
/// the new dart 3 features. T will be inferred by contextual type inference
/// rather than the extension type.
extension RxTnew on Object {
  /// Returns a `Rx` instance with [this] `T` as initial value.
  Rx<T> obs<T>() => Rx<T>(this as T);
}
\n\n--- File: 28 # get_core/get_core.dart ---\nlibrary;

export 'src/flutter_engine.dart';
export 'src/get_interface.dart';
export 'src/get_main.dart';
export 'src/log.dart';
export 'src/smart_management.dart';
export 'src/typedefs.dart';
\n\n--- File: 29 # get_core/src/get_interface.dart ---\nimport 'package:flutter/foundation.dart';

import 'log.dart';
import 'smart_management.dart';

/// GetInterface allows any auxiliary package to be merged into the "Get"
/// class through extensions
abstract class GetInterface {
  SmartManagement smartManagement = SmartManagement.full;
  bool isLogEnable = kDebugMode;
  LogWriterCallback log = defaultLogWriterCallback;
}
\n\n--- File: 31 # get_core/src/get_main.dart ---\nimport 'get_interface.dart';

///Use to instead of Navigator.push, off instead of Navigator.pushReplacement,
///offAll instead of Navigator.pushAndRemoveUntil. For named routes just
///add "named" after them. Example: toNamed, offNamed, and AllNamed.
///To return to the previous screen, use back().
///No need to pass any context to Get, just put the name of the route inside
///the parentheses and the magic will occur.
class _GetImpl extends GetInterface {}

// ignore: non_constant_identifier_names
final Get = _GetImpl();


Please provide:
1. A high-level `summary` of the project's main purpose and functionality in a few beginner-friendly sentences. Use markdown formatting with **bold** and *italic* text to highlight important concepts.
2. A list (`relationships`) describing the key interactions between these abstractions. For each relationship, specify:
    - `from_abstraction`: Index of the source abstraction (e.g., `0 # AbstractionName1`)
    - `to_abstraction`: Index of the target abstraction (e.g., `1 # AbstractionName2`)
    - `label`: A brief label for the interaction **in just a few words** (e.g., "Manages", "Inherits", "Uses").
    Ideally the relationship should be backed by one abstraction calling or passing parameters to another.
    Simplify the relationship and exclude those non-important ones.

IMPORTANT: Make sure EVERY abstraction is involved in at least ONE relationship (either as source or target). Each abstraction index must appear at least once across all relationships.

Format the output as YAML:

```yaml
summary: |
  A brief, simple explanation of the project.
  Can span multiple lines with **bold** and *italic* for emphasis.
relationships:
  - from_abstraction: 0 # AbstractionName1
    to_abstraction: 1 # AbstractionName2
    label: "Manages"
  - from_abstraction: 2 # AbstractionName3
    to_abstraction: 0 # AbstractionName1
    label: "Provides config"
  # ... other relationships
```

Now, provide the YAML output:

2025-05-12 13:29:18,032 - INFO - RESPONSE: ```yaml
summary: |
  This project provides core functionalities for the **GetX** framework in Flutter, a popular solution for *state management*, *dependency injection*, and route management.
  It allows developers to build applications where the User Interface (UI) can react automatically to data changes (**reactive programming** using `Rx<T>` variables and `Obx` widgets) or be updated manually (via `GetxController` and `GetBuilder`).
  The `Get` object acts as a central facade for accessing these features, including tools to easily provide and find controllers or services (**dependency management**) throughout the application. It also includes helpers like `StateMixin` to manage common UI states (loading, error, success) for asynchronous operations.
relationships:
  - from_abstraction: 6 # Dependency Access (Binder, Bind.of, Get.find/put)
    to_abstraction: 0 # Get (Global Access Facade)
    label: "Uses for global DI"
  - from_abstraction: 1 # GetxController
    to_abstraction: 5 # ListNotifier (and Mixins)
    label: "Uses for update notifications"
  - from_abstraction: 3 # GetBuilder
    to_abstraction: 1 # GetxController
    label: "Listens for manual updates"
  - from_abstraction: 8 # StateMixin
    to_abstraction: 1 # GetxController
    label: "Enhances with async states"
  - from_abstraction: 4 # Obx / ObxWidget
    to_abstraction: 2 # Rx<T> (Reactive Variables)
    label: "Observes for reactive updates"
  - from_abstraction: 7 # Workers
    to_abstraction: 2 # Rx<T> (Reactive Variables)
    label: "Reacts to variable changes"
  - from_abstraction: 2 # Rx<T> (Reactive Variables)
    to_abstraction: 5 # ListNotifier (and Mixins)
    label: "Uses for reactive notifications"
  - from_abstraction: 3 # GetBuilder
    to_abstraction: 6 # Dependency Access (Binder, Bind.of, Get.find/put)
    label: "Accesses controller via"
  - from_abstraction: 4 # Obx / ObxWidget
    to_abstraction: 5 # ListNotifier (and Mixins)
    label: "Subscribes via Notifier"
  - from_abstraction: 8 # StateMixin
    to_abstraction: 5 # ListNotifier (and Mixins)
    label: "Uses for its own state changes"
  - from_abstraction: 6 # Dependency Access (Binder, Bind.of, Get.find/put)
    to_abstraction: 1 # GetxController
    label: "Provides controller instances"
  - from_abstraction: 8 # StateMixin
    to_abstraction: 4 # Obx / ObxWidget
    label: "Provides reactive builder for UI"
```
2025-05-12 13:29:18,106 - INFO - PROMPT: 
Given the following project abstractions and their relationships for the project ```` lib ````:

Abstractions (Index # Name):
- 0 # Get (Global Access Facade)

- 1 # GetxController

- 2 # Rx<T> (Reactive Variables)

- 3 # GetBuilder

- 4 # Obx / ObxWidget

- 5 # ListNotifier (and Mixins)

- 6 # Dependency Access (Binder, Bind.of, Get.find/put)

- 7 # Workers

- 8 # StateMixin


Context about relationships and project summary:
Project Summary:
This project provides core functionalities for the **GetX** framework in Flutter, a popular solution for *state management*, *dependency injection*, and route management.
It allows developers to build applications where the User Interface (UI) can react automatically to data changes (**reactive programming** using `Rx<T>` variables and `Obx` widgets) or be updated manually (via `GetxController` and `GetBuilder`).
The `Get` object acts as a central facade for accessing these features, including tools to easily provide and find controllers or services (**dependency management**) throughout the application. It also includes helpers like `StateMixin` to manage common UI states (loading, error, success) for asynchronous operations.


Relationships (Indices refer to abstractions above):
- From 6 (Dependency Access (Binder, Bind.of, Get.find/put)
) to 0 (Get (Global Access Facade)
): Uses for global DI
- From 1 (GetxController
) to 5 (ListNotifier (and Mixins)
): Uses for update notifications
- From 3 (GetBuilder
) to 1 (GetxController
): Listens for manual updates
- From 8 (StateMixin
) to 1 (GetxController
): Enhances with async states
- From 4 (Obx / ObxWidget
) to 2 (Rx<T> (Reactive Variables)
): Observes for reactive updates
- From 7 (Workers
) to 2 (Rx<T> (Reactive Variables)
): Reacts to variable changes
- From 2 (Rx<T> (Reactive Variables)
) to 5 (ListNotifier (and Mixins)
): Uses for reactive notifications
- From 3 (GetBuilder
) to 6 (Dependency Access (Binder, Bind.of, Get.find/put)
): Accesses controller via
- From 4 (Obx / ObxWidget
) to 5 (ListNotifier (and Mixins)
): Subscribes via Notifier
- From 8 (StateMixin
) to 5 (ListNotifier (and Mixins)
): Uses for its own state changes
- From 6 (Dependency Access (Binder, Bind.of, Get.find/put)
) to 1 (GetxController
): Provides controller instances
- From 8 (StateMixin
) to 4 (Obx / ObxWidget
): Provides reactive builder for UI


If you are going to make a tutorial for ```` lib ````, what is the best order to explain these abstractions, from first to last?
Ideally, first explain those that are the most important or foundational, perhaps user-facing concepts or entry points. Then move to more detailed, lower-level implementation details or supporting concepts.

Output the ordered list of abstraction indices, including the name in a comment for clarity. Use the format `idx # AbstractionName`.

```yaml
- 2 # FoundationalConcept
- 0 # CoreClassA
- 1 # CoreClassB (uses CoreClassA)
- ...
```

Now, provide the YAML output:

2025-05-12 13:30:35,879 - INFO - RESPONSE: Okay, here's a proposed order for explaining the abstractions in a tutorial, moving from foundational, user-facing concepts to more detailed or supporting ones:

1.  **`0 # Get (Global Access Facade)`**: This is the main entry point and central facade for almost all GetX functionalities. It's logical to introduce this first as the "gateway" to the framework.
2.  **`2 # Rx<T> (Reactive Variables)`**: Reactive programming is a core feature. `Rx<T>` is the fundamental building block for reactive state management.
3.  **`4 # Obx / ObxWidget`**: This directly complements `Rx<T>` by showing how to make the UI react to changes in reactive variables. These two (`Rx<T>` and `Obx`) form the basis of GetX's reactive state management.
4.  **`7 # Workers`**: Workers also react to changes in `Rx<T>` variables but are used for side effects (like calling an API, logging, etc.) rather than direct UI updates. They naturally follow after `Rx<T>` is understood.
5.  **`1 # GetxController`**: This introduces the other primary way of managing state and business logic, often used for more complex scenarios or when simple manual updates are preferred.
6.  **`6 # Dependency Access (Binder, Bind.of, Get.find/put)`**: Once `GetxController` (and other services) are introduced, it's crucial to explain how they are instantiated, provided, and accessed throughout the application (Dependency Injection). This system often uses `Get` as well.
7.  **`3 # GetBuilder`**: This is the UI widget that listens to `GetxController` for manual updates. It pairs with `GetxController` similarly to how `Obx` pairs with `Rx<T>`. It often uses DI (Dependency Access) to find its controller.
8.  **`8 # StateMixin`**: This is an enhancement for `GetxController` that helps manage common UI states for asynchronous operations (loading, success, error). It often builds upon `GetxController` and can provide reactive updates to the UI, fitting well after both controller and reactive concepts have been introduced.
9.  **`5 # ListNotifier (and Mixins)`**: This appears to be a lower-level notification mechanism used internally by several other abstractions (`GetxController`, `Rx<T>`, `StateMixin`, `Obx`). As it's more of an implementation detail or an underlying system, it's best explained last, once users understand the higher-level abstractions it supports.

```yaml
- 0 # Get (Global Access Facade)
- 2 # Rx<T> (Reactive Variables)
- 4 # Obx / ObxWidget
- 7 # Workers
- 1 # GetxController
- 6 # Dependency Access (Binder, Bind.of, Get.find/put)
- 3 # GetBuilder
- 8 # StateMixin
- 5 # ListNotifier (and Mixins)
```
2025-05-12 13:30:35,946 - INFO - PROMPT: 
Write a very beginner-friendly tutorial chapter (in Markdown format) for the project `lib` about the concept: "Get (Global Access Facade)
". This is Chapter 1.

Concept Details:
- Name: Get (Global Access Facade)

- Description:
The `Get` object is your main C# class 'System.Console' and entry point for most GetX features.
Think of it as a universal remote control for dependency management (like storing and retrieving your app's managers),
navigation, showing dialogs, and more. It provides easy-to-use static methods,
often without needing Flutter's `BuildContext`, making your code cleaner and
simplifying access to various GetX functionalities from anywhere in your app.


Complete Tutorial Structure:
1. [Get (Global Access Facade)
](01_get__global_access_facade__.md)
2. [Rx<T> (Reactive Variables)
](02_rx_t___reactive_variables__.md)
3. [Obx / ObxWidget
](03_obx___obxwidget_.md)
4. [Workers
](04_workers_.md)
5. [GetxController
](05_getxcontroller_.md)
6. [Dependency Access (Binder, Bind.of, Get.find/put)
](06_dependency_access__binder__bind_of__get_find_put__.md)
7. [GetBuilder
](07_getbuilder_.md)
8. [StateMixin
](08_statemixin_.md)
9. [ListNotifier (and Mixins)
](09_listnotifier__and_mixins__.md)

Context from previous chapters:
This is the first chapter.

Relevant Code Snippets (Code itself remains unchanged):
--- File: get_state_manager/src/simple/get_state.dart ---
// ignore_for_file: overridden_fields

import 'dart:async';

import 'package:flutter/material.dart';

import '../../../instance_manager.dart';
import '../../get_state_manager.dart';
import 'list_notifier.dart';

typedef InitBuilder<T> = T Function();

typedef GetControllerBuilder<T extends GetLifeCycleMixin> = Widget Function(
    T controller);

extension WatchExt on BuildContext {
  T listen<T>() {
    return Bind.of(this, rebuild: true);
  }
}

extension ReadExt on BuildContext {
  T get<T>() {
    return Bind.of(this);
  }
}

// extension FilterExt on BuildContext {
//   T filter<T extends GetxController>(Object Function(T value)? filter) {
//     return Bind.of(this, filter: filter, rebuild: true);
//   }
// }

class GetBuilder<T extends GetxController> extends StatelessWidget {
  final GetControllerBuilder<T> builder;
  final bool global;
  final Object? id;
  final String? tag;
  final bool autoRemove;
  final bool assignId;
  final Object Function(T value)? filter;
  final void Function(BindElement<T> state)? initState,
      dispose,
      didChangeDependencies;
  final void Function(Binder<T> oldWidget, BindElement<T> state)?
      didUpdateWidget;
  final T? init;

  const GetBuilder({
    super.key,
    this.init,
    this.global = true,
    required this.builder,
    this.autoRemove = true,
    this.assignId = false,
    this.initState,
    this.filter,
    this.tag,
    this.dispose,
    this.id,
    this.didChangeDependencies,
    this.didUpdateWidget,
  });

  @override
  Widget build(BuildContext context) {
    return Binder(
      init: init == null ? null : () => init!,
      global: global,
      autoRemove: autoRemove,
      assignId: assignId,
      initState: initState,
      filter: filter,
      tag: tag,
      dispose: dispose,
      id: id,
      lazy: false,
      didChangeDependencies: didChangeDependencies,
      didUpdateWidget: didUpdateWidget,
      child: Builder(builder: (context) {
        final controller = Bind.of<T>(context, rebuild: true);
        return builder(controller);
      }),
    );
    // return widget.builder(controller!);
  }
}

abstract class Bind<T> extends StatelessWidget {
  const Bind({
    super.key,
    required this.child,
    this.init,
    this.global = true,
    this.autoRemove = true,
    this.assignId = false,
    this.initState,
    this.filter,
    this.tag,
    this.dispose,
    this.id,
    this.didChangeDependencies,
    this.didUpdateWidget,
  });

  final InitBuilder<T>? init;

  final bool global;
  final Object? id;
  final String? tag;
  final bool autoRemove;
  final bool assignId;
  final Object Function(T value)? filter;
  final void Function(BindElement<T> state)? initState,
      dispose,
      didChangeDependencies;
  final void Function(Binder<T> oldWidget, BindElement<T> state)?
      didUpdateWidget;

  final Widget? child;

  static Bind put<S>(
    S dependency, {
    String? tag,
    bool permanent = false,
  }) {
    Get.put<S>(dependency, tag: tag, permanent: permanent);
    return _FactoryBind<S>(
      autoRemove: permanent,
      assignId: true,
      tag: tag,
    );
  }

  static bool fenixMode = false;

  static Bind lazyPut<S>(
    InstanceBuilderCallback<S> builder, {
    String? tag,
    bool? fenix,
    // VoidCallback? onInit,
    VoidCallback? onClose,
  }) {
    Get.lazyPut<S>(builder, tag: tag, fenix: fenix ?? fenixMode);
    return _FactoryBind<S>(
      tag: tag,
      // initState: (_) {
      //   onInit?.call();
      // },
      dispose: (_) {
        onClose?.call();
      },
    );
  }

  static Bind create<S>(InstanceCreateBuilderCallback<S> builder,
      {String? tag, bool permanent = true}) {
    return _FactoryBind<S>(
      create: builder,
      tag: tag,
      global: false,
    );
  }

  static Bind spawn<S>(InstanceBuilderCallback<S> builder,
      {String? tag, bool permanent = true}) {
    Get.spawn<S>(builder, tag: tag, permanent: permanent);
    return _FactoryBind<S>(
      tag: tag,
      global: false,
      autoRemove: permanent,
    );
  }

  static S find<S>({String? tag}) => Get.find<S>(tag: tag);

  static Future<bool> delete<S>({String? tag, bool force = false}) async =>
      Get.delete<S>(tag: tag, force: force);

  static Future<void> deleteAll({bool force = false}) async =>
      Get.deleteAll(force: force);

  static void reloadAll({bool force = false}) => Get.reloadAll(force: force);

  static void reload<S>({String? tag, String? key, bool force = false}) =>
      Get.reload<S>(tag: tag, key: key, force: force);

  static bool isRegistered<S>({String? tag}) => Get.isRegistered<S>(tag: tag);

  static bool isPrepared<S>({String? tag}) => Get.isPrepared<S>(tag: tag);

  static void replace<P>(P child, {String? tag}) {
    final info = Get.getInstanceInfo<P>(tag: tag);
    final permanent = (info.isPermanent ?? false);
    delete<P>(tag: tag, force: permanent);
    Get.put(child, tag: tag, permanent: permanent);
  }

  static void lazyReplace<P>(InstanceBuilderCallback<P> builder,
      {String? tag, bool? fenix}) {
    final info = Get.getInstanceInfo<P>(tag: tag);
    final permanent = (info.isPermanent ?? false);
    delete<P>(tag: tag, force: permanent);
    Get.lazyPut(builder, tag: tag, fenix: fenix ?? permanent);
  }

  factory Bind.builder({
    Widget? child,
    InitBuilder<T>? init,
    InstanceCreateBuilderCallback<T>? create,
    bool global = true,
    bool autoRemove = true,
    bool assignId = false,
    Object Function(T value)? filter,
    String? tag,
    Object? id,
    void Function(BindElement<T> state)? initState,
    void Function(BindElement<T> state)? dispose,
    void Function(BindElement<T> state)? didChangeDependencies,
    void Function(Binder<T> oldWidget, BindElement<T> state)? didUpdateWidget,
  }) =>
      _FactoryBind<T>(
        // key: key,
        init: init,
        create: create,
        global: global,
        autoRemove: autoRemove,
        assignId: assignId,
        initState: initState,
        filter: filter,
        tag: tag,
        dispose: dispose,
        id: id,
        didChangeDependencies: didChangeDependencies,
        didUpdateWidget: didUpdateWidget,
        child: child,
      );

  static T of<T>(
    BuildContext context, {
    bool rebuild = false,
    // Object Function(T value)? filter,
  }) {
    final inheritedElement =
        context.getElementForInheritedWidgetOfExactType<Binder<T>>()
            as BindElement<T>?;

    if (inheritedElement == null) {
      throw BindError(controller: '$T', tag: null);
    }

    if (rebuild) {
      // var newFilter = filter?.call(inheritedElement.controller!);
      // if (newFilter != null) {
      //  context.dependOnInheritedElement(inheritedElement, aspect: newFilter);
      // } else {
      context.dependOnInheritedElement(inheritedElement);
      // }
    }

    final controller = inheritedElement.controller;

    return controller;
  }

  @factory
  Bind<T> _copyWithChild(Widget child);
}

class _FactoryBind<T> extends Bind<T> {
  @override
  final InitBuilder<T>? init;

  final InstanceCreateBuilderCallback<T>? create;

  @override
  final bool global;
  @override
  final Object? id;
  @override
  final String? tag;
  @override
  final bool autoRemove;
  @override
  final bool assignId;
  @override
  final Object Function(T value)? filter;

  @override
  final void Function(BindElement<T> state)? initState,
      dispose,
      didChangeDependencies;
  @override
  final void Function(Binder<T> oldWidget, BindElement<T> state)?
      didUpdateWidget;

  @override
  final Widget? child;

  const _FactoryBind({
    super.key,
    this.child,
    this.init,
    this.create,
    this.global = true,
    this.autoRemove = true,
    this.assignId = false,
    this.initState,
    this.filter,
    this.tag,
    this.dispose,
    this.id,
    this.didChangeDependencies,
    this.didUpdateWidget,
  }) : super(child: child);

  @override
  Bind<T> _copyWithChild(Widget child) {
    return Bind<T>.builder(
      init: init,
      create: create,
      global: global,
      autoRemove: autoRemove,
      assignId: assignId,
      initState: initState,
      filter: filter,
      tag: tag,
      dispose: dispose,
      id: id,
      didChangeDependencies: didChangeDependencies,
      didUpdateWidget: didUpdateWidget,
      child: child,
    );
  }

  @override
  Widget build(BuildContext context) {
    return Binder<T>(
      create: create,
      global: global,
      autoRemove: autoRemove,
      assignId: assignId,
      initState: initState,
      filter: filter,
      tag: tag,
      dispose: dispose,
      id: id,
      didChangeDependencies: didChangeDependencies,
      didUpdateWidget: didUpdateWidget,
      child: child!,
    );
  }
}

class Binds extends StatelessWidget {
  final List<Bind<dynamic>> binds;
  final Widget child;

  Binds({
    super.key,
    required this.binds,
    required this.child,
  }) : assert(binds.isNotEmpty);

  @override
  Widget build(BuildContext context) =>
      binds.reversed.fold(child, (widget, e) => e._copyWithChild(widget));
}

class Binder<T> extends InheritedWidget {
  /// Create an inherited widget that updates its dependents when [controller]
  /// sends notifications.
  ///
  /// The [child] argument is required
  const Binder({
    super.key,
    required super.child,
    this.init,
    this.global = true,
    this.autoRemove = true,
    this.assignId = false,
    this.lazy = true,
    this.initState,
    this.filter,
    this.tag,
    this.dispose,
    this.id,
    this.didChangeDependencies,
    this.didUpdateWidget,
    this.create,
  });

  final InitBuilder<T>? init;
  final InstanceCreateBuilderCallback? create;
  final bool global;
  final Object? id;
  final String? tag;
  final bool lazy;
  final bool autoRemove;
  final bool assignId;
  final Object Function(T value)? filter;
  final void Function(BindElement<T> state)? initState,
      dispose,
      didChangeDependencies;
  final void Function(Binder<T> oldWidget, BindElement<T> state)?
      didUpdateWidget;

  @override
  bool updateShouldNotify(Binder<T> oldWidget) {
    return oldWidget.id != id ||
        oldWidget.global != global ||
        oldWidget.autoRemove != autoRemove ||
        oldWidget.assignId != assignId;
  }

  @override
  InheritedElement createElement() => BindElement<T>(this);
}

/// The BindElement is responsible for injecting dependencies into the widget
/// tree so that they can be observed
class BindElement<T> extends InheritedElement {
  BindElement(Binder<T> super.widget) {
    initState();
  }

  final disposers = <Disposer>[];

  InitBuilder<T>? _controllerBuilder;

  T? _controller;

  T get controller {
    if (_controller == null) {
      _controller = _controllerBuilder?.call();
      _subscribeToController();
      if (_controller == null) {
        throw BindError(controller: T, tag: widget.tag);
      }
      return _controller!;
    } else {
      return _controller!;
    }
  }

  bool? _isCreator = false;
  bool? _needStart = false;
  bool _wasStarted = false;
  VoidCallback? _remove;
  Object? _filter;

  void initState() {
    widget.initState?.call(this);

    var isRegistered = Get.isRegistered<T>(tag: widget.tag);

    if (widget.global) {
      if (isRegistered) {
        if (Get.isPrepared<T>(tag: widget.tag)) {
          _isCreator = true;
        } else {
          _isCreator = false;
        }

        _controllerBuilder = () => Get.find<T>(tag: widget.tag);
      } else {
        _controllerBuilder =
            () => (widget.create?.call(this) ?? widget.init?.call());
        _isCreator = true;
        if (widget.lazy) {
          Get.lazyPut<T>(_controllerBuilder!, tag: widget.tag);
        } else {
          Get.put<T>(_controllerBuilder!(), tag: widget.tag);
        }
      }
    } else {
      if (widget.create != null) {
        _controllerBuilder = () => widget.create!.call(this);
        Get.spawn<T>(_controllerBuilder!, tag: widget.tag, permanent: false);
      } else {
        _controllerBuilder = widget.init;
      }
      _controllerBuilder =
          (widget.create != null ? () => widget.create!.call(this) : null) ??
              widget.init;
      _isCreator = true;
      _needStart = true;
    }
  }

  /// Register to listen Controller's events.
  /// It gets a reference to the remove() callback, to delete the
  /// setState "link" from the Controller.
  void _subscribeToController() {
    if (widget.filter != null) {
      _filter = widget.filter!(_controller as T);
    }
    final filter = _filter != null ? _filterUpdate : getUpdate;
    final localController = _controller;

    if (_needStart == true && localController is GetLifeCycleMixin) {
      localController.onStart();
      _needStart = false;
      _wasStarted = true;
    }

    if (localController is GetxController) {
      _remove?.call();
      _remove = (widget.id == null)
          ? localController.addListener(filter)
          : localController.addListenerId(widget.id, filter);
    } else if (localController is Listenable) {
      _remove?.call();
      localController.addListener(filter);
      _remove = () => localController.removeListener(filter);
    } else if (localController is StreamController) {
      _remove?.call();
      final stream = localController.stream.listen((_) => filter());
      _remove = () => stream.cancel();
    }
  }

  void _filterUpdate() {
    var newFilter = widget.filter!(_controller as T);
    if (newFilter != _filter) {
      _filter = newFilter;
      getUpdate();
    }
  }

  void dispose() {
    widget.dispose?.call(this);
    if (_isCreator! || widget.assignId) {
      if (widget.autoRemove && Get.isRegistered<T>(tag: widget.tag)) {
        Get.delete<T>(tag: widget.tag);
      }
    }

    for (final disposer in disposers) {
      disposer();
    }

    disposers.clear();

    _remove?.call();
    _controller = null;
    _isCreator = null;
    _remove = null;
    _filter = null;
    _needStart = null;
    _controllerBuilder = null;
    _controller = null;
  }

  @override
  Binder<T> get widget => super.widget as Binder<T>;

  var _dirty = false;

  @override
  void update(Binder<T> newWidget) {
    final oldNotifier = widget.id;
    final newNotifier = newWidget.id;
    if (oldNotifier != newNotifier && _wasStarted) {
      _subscribeToController();
    }
    widget.didUpdateWidget?.call(widget, this);
    super.update(newWidget);
  }

  @override
  void didChangeDependencies() {
    super.didChangeDependencies();
    widget.didChangeDependencies?.call(this);
  }

  @override
  Widget build() {
    if (_dirty) {
      notifyClients(widget);
    }
    // return Notifier.instance.notifyAppend(
    //   NotifyData(
    //       disposers: disposers, updater: getUpdate, throwException: false),
    return super.build();
    //);
  }

  void getUpdate() {
    _dirty = true;
    markNeedsBuild();
  }

  @override
  void notifyClients(Binder<T> oldWidget) {
    super.notifyClients(oldWidget);
    _dirty = false;
  }

  @override
  void unmount() {
    dispose();
    super.unmount();
  }
}

class BindError<T> extends Error {
  /// The type of the class the user tried to retrieve
  final T controller;
  final String? tag;

  /// Creates a [BindError]
  BindError({required this.controller, required this.tag});

  @override
  String toString() {
    if (controller == 'dynamic') {
      return '''Error: please specify type [<T>] when calling context.listen<T>() or context.find<T>() method.''';
    }

    return '''Error: No Bind<$controller>  ancestor found. To fix this, please add a Bind<$controller> widget ancestor to the current context.
      ''';
  }
}

/// [Binding] should be extended.
/// When using `GetMaterialApp`, all `GetPage`s and navigation
/// methods (like Get.to()) have a `binding` property that takes an
/// instance of Bindings to manage the
/// dependencies() (via Get.put()) for the Route you are opening.
// ignore: one_member_abstracts
abstract class Binding extends BindingsInterface<List<Bind>> {}


--- File: get_state_manager/src/rx_flutter/rx_getx_widget.dart ---
import 'package:flutter/foundation.dart';
import 'package:flutter/widgets.dart';

import '../../../get_core/get_core.dart';
import '../../../get_instance/src/extension_instance.dart';
import '../../../get_instance/src/lifecycle.dart';
import '../simple/list_notifier.dart';

typedef GetXControllerBuilder<T extends GetLifeCycleMixin> = Widget Function(
    T controller);

class GetX<T extends GetLifeCycleMixin> extends StatefulWidget {
  final GetXControllerBuilder<T> builder;
  final bool global;
  final bool autoRemove;
  final bool assignId;
  final void Function(GetXState<T> state)? initState,
      dispose,
      didChangeDependencies;
  final void Function(GetX oldWidget, GetXState<T> state)? didUpdateWidget;
  final T? init;
  final String? tag;

  const GetX({
    super.key,
    this.tag,
    required this.builder,
    this.global = true,
    this.autoRemove = true,
    this.initState,
    this.assignId = false,
    //  this.stream,
    this.dispose,
    this.didChangeDependencies,
    this.didUpdateWidget,
    this.init,
    // this.streamController
  });

  @override
  StatefulElement createElement() => StatefulElement(this);

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
      ..add(
        DiagnosticsProperty<T>('controller', init),
      )
      ..add(DiagnosticsProperty<String>('tag', tag))
      ..add(
          ObjectFlagProperty<GetXControllerBuilder<T>>.has('builder', builder));
  }

  @override
  GetXState<T> createState() => GetXState<T>();
}

class GetXState<T extends GetLifeCycleMixin> extends State<GetX<T>> {
  T? controller;
  bool? _isCreator = false;

  @override
  void initState() {
    // var isPrepared = Get.isPrepared<T>(tag: widget.tag);
    final isRegistered = Get.isRegistered<T>(tag: widget.tag);

    if (widget.global) {
      if (isRegistered) {
        _isCreator = Get.isPrepared<T>(tag: widget.tag);
        controller = Get.find<T>(tag: widget.tag);
      } else {
        controller = widget.init;
        _isCreator = true;
        Get.put<T>(controller!, tag: widget.tag);
      }
    } else {
      controller = widget.init;
      _isCreator = true;
      controller?.onStart();
    }
    widget.initState?.call(this);
    if (widget.global && Get.smartManagement == SmartManagement.onlyBuilder) {
      controller?.onStart();
    }

    super.initState();
  }

  @override
  void didChangeDependencies() {
    super.didChangeDependencies();
    if (widget.didChangeDependencies != null) {
      widget.didChangeDependencies!(this);
    }
  }

  @override
  void didUpdateWidget(GetX oldWidget) {
    super.didUpdateWidget(oldWidget as GetX<T>);
    widget.didUpdateWidget?.call(oldWidget, this);
  }

  @override
  void dispose() {
    if (widget.dispose != null) widget.dispose!(this);
    if (_isCreator! || widget.assignId) {
      if (widget.autoRemove && Get.isRegistered<T>(tag: widget.tag)) {
        Get.delete<T>(tag: widget.tag);
      }
    }

    for (final disposer in disposers) {
      disposer();
    }

    disposers.clear();

    controller = null;
    _isCreator = null;
    super.dispose();
  }

  void _update() {
    if (mounted) {
      setState(() {});
    }
  }

  final disposers = <Disposer>[];

  @override
  Widget build(BuildContext context) => Notifier.instance.append(
      NotifyData(disposers: disposers, updater: _update),
      () => widget.builder(controller!));

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties.add(DiagnosticsProperty<T>('controller', controller));
  }
}


--- File: get_core/get_core.dart ---
library;

export 'src/flutter_engine.dart';
export 'src/get_interface.dart';
export 'src/get_main.dart';
export 'src/log.dart';
export 'src/smart_management.dart';
export 'src/typedefs.dart';


--- File: get_core/src/get_interface.dart ---
import 'package:flutter/foundation.dart';

import 'log.dart';
import 'smart_management.dart';

/// GetInterface allows any auxiliary package to be merged into the "Get"
/// class through extensions
abstract class GetInterface {
  SmartManagement smartManagement = SmartManagement.full;
  bool isLogEnable = kDebugMode;
  LogWriterCallback log = defaultLogWriterCallback;
}


--- File: get_core/src/get_main.dart ---
import 'get_interface.dart';

///Use to instead of Navigator.push, off instead of Navigator.pushReplacement,
///offAll instead of Navigator.pushAndRemoveUntil. For named routes just
///add "named" after them. Example: toNamed, offNamed, and AllNamed.
///To return to the previous screen, use back().
///No need to pass any context to Get, just put the name of the route inside
///the parentheses and the magic will occur.
class _GetImpl extends GetInterface {}

// ignore: non_constant_identifier_names
final Get = _GetImpl();


Instructions for the chapter (Generate content in English unless specified otherwise):
- Start with a clear heading (e.g., `# Chapter 1: Get (Global Access Facade)
`). Use the provided concept name.

- If this is not the first chapter, begin with a brief transition from the previous chapter, referencing it with a proper Markdown link using its name.

- Begin with a high-level motivation explaining what problem this abstraction solves. Start with a central use case as a concrete example. The whole chapter should guide the reader to understand how to solve this use case. Make it very minimal and friendly to beginners.

- If the abstraction is complex, break it down into key concepts. Explain each concept one-by-one in a very beginner-friendly way.

- Explain how to use this abstraction to solve the use case. Give example inputs and outputs for code snippets (if the output isn't values, describe at a high level what will happen).

- Each code block should be BELOW 10 lines! If longer code blocks are needed, break them down into smaller pieces and walk through them one-by-one. Aggresively simplify the code to make it minimal. Use comments to skip non-important implementation details. Each code block should have a beginner friendly explanation right after it.

- Describe the internal implementation to help understand what's under the hood. First provide a non-code or code-light walkthrough on what happens step-by-step when the abstraction is called. It's recommended to use a simple sequenceDiagram with a dummy example - keep it minimal with at most 5 participants to ensure clarity. If participant name has space, use: `participant QP as Query Processing`. .

- Then dive deeper into code for the internal implementation with references to files. Provide example code blocks, but make them similarly simple and beginner-friendly. Explain.

- IMPORTANT: When you need to refer to other core abstractions covered in other chapters, ALWAYS use proper Markdown links like this: [Chapter Title](filename.md). Use the Complete Tutorial Structure above to find the correct filename and the chapter title. Translate the surrounding text.

- Use mermaid diagrams to illustrate complex concepts (```mermaid``` format). .

- Heavily use analogies and examples throughout to help beginners understand.

- End the chapter with a brief conclusion that summarizes what was learned and provides a transition to the next chapter. If there is a next chapter, use a proper Markdown link: [Next Chapter Title](next_chapter_filename).

- Ensure the tone is welcoming and easy for a newcomer to understand.

- Output *only* the Markdown content for this chapter.

Now, directly provide a super beginner-friendly Markdown output (DON'T need ```markdown``` tags):

2025-05-12 13:31:24,102 - INFO - RESPONSE: # Chapter 1: Get (Global Access Facade)

Welcome to your GetX journey! In this first chapter, we'll explore one of the most fundamental and frequently used parts of the GetX ecosystem: the `Get` object.

## What is `Get` and Why Do You Need It?

Imagine you're building a Flutter app. You often need to perform common tasks like:
*   Showing a quick message (a "snackbar") to the user.
*   Navigating to a new screen.
*   Accessing a shared service, like a settings manager, from various parts of your app.

Traditionally, in Flutter, many of these tasks require access to something called `BuildContext`. `BuildContext` tells Flutter "where" you are in your widget tree, which is necessary for operations like finding the nearest `Navigator` or `Scaffold`. Getting `BuildContext` to the exact spot where you need it can sometimes be cumbersome, especially in deeper parts of your app's logic that aren't directly part of a widget.

This is where `Get` comes to the rescue!

The `Get` object is your main entry point for most GetX features. Think of it as a **universal remote control** for your application. It provides super easy-to-use tools (called static methods) for:

*   **Dependency Management:** Storing and retrieving your app's services or "managers" (like a `UserSettingsManager` or `ApiService`).
*   **Navigation:** Moving between screens with simple commands.
*   **Showing UI Elements:** Displaying dialogs, snackbars, or bottom sheets.
*   ...and much more!

The beauty of `Get` is that it often lets you do these things **without needing `BuildContext`**, making your code cleaner and simplifying access to GetX functionalities from virtually anywhere in your app.

## How to Use `Get`

Using `Get` is incredibly straightforward because its methods are `static`. This means you don't need to create an instance of a `Get` class; you just type `Get.` followed by the feature you want to use.

Let's look at a few common use cases:

### 1. Showing a Snackbar

Need to show a quick notification to the user?

```dart
import 'package:get/get.dart'; // Make sure to import GetX

// ...somewhere in your code, even inside a business logic class
void showSuccessMessage() {
  Get.snackbar(
    "Success!", // title
    "Your profile was updated successfully.", // message
    snackPosition: SnackPosition.BOTTOM
  );
}
```

**What happens?**
When `showSuccessMessage()` is called, GetX will display a snackbar at the bottom of the current screen with the title "Success!" and the given message. Notice you didn't need to pass any `BuildContext`!

### 2. Navigating to a New Screen

Want to open a new page?

```dart
import 'package:flutter/material.dart';
import 'package:get/get.dart';

class HomeScreen extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(title: Text("Home")),
      body: Center(
        child: ElevatedButton(
          onPressed: () {
            Get.to(DetailScreen()); // Navigate to DetailScreen
          },
          child: Text("Go to Details"),
        ),
      ),
    );
  }
}

class DetailScreen extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(title: Text("Details")),
      body: Center(
        child: ElevatedButton(
          onPressed: () {
            Get.back(); // Go back to the previous screen
          },
          child: Text("Go Back"),
        ),
      ),
    );
  }
}
```
**What happens?**
*   Tapping the "Go to Details" button on `HomeScreen` will push `DetailScreen` onto the navigation stack, making it visible.
*   Tapping the "Go Back" button on `DetailScreen` will pop it from the stack, revealing `HomeScreen` again.

Again, simple and no `BuildContext` needed for `Get.to()` or `Get.back()`. (Note: To use GetX navigation, your main app widget should be `GetMaterialApp` instead of `MaterialApp`).

### 3. Basic Dependency Management (Service Locator)

Imagine you have a class that manages user preferences:

```dart
class UserPreferencesService {
  bool _isDarkMode = false;

  bool get isDarkMode => _isDarkMode;

  void toggleDarkMode() {
    _isDarkMode = !_isDarkMode;
    print("Dark mode is now: $_isDarkMode");
    // In a real app, you'd save this preference
  }
}
```

You can "register" an instance of this service with GetX using `Get.put()`:

```dart
// Usually done at app startup or in a specific setup area
void initializeServices() {
  Get.put(UserPreferencesService());
  print("UserPreferencesService registered!");
}
```

Later, from anywhere in your app, you can retrieve this instance using `Get.find()`:

```dart
// ... in some widget or controller
void onThemeToggleButtonPressed() {
  final prefsService = Get.find<UserPreferencesService>();
  prefsService.toggleDarkMode();
  // You might then update your UI based on prefsService.isDarkMode
}
```

**What happens?**
*   `Get.put(UserPreferencesService());` creates an instance of `UserPreferencesService` and stores it in a global container managed by GetX.
*   `Get.find<UserPreferencesService>();` looks up and returns that stored instance.

This allows you to easily access shared services without passing instances around manually or using complex InheritedWidgets. We'll dive much deeper into dependency management in [Chapter 6: Dependency Access (Binder, Bind.of, Get.find/put)](06_dependency_access__binder__bind_of__get_find_put__.md).

## Under the Hood: How Does `Get` Work?

You might be wondering how `Get` can perform these actions, especially UI-related ones like showing snackbars, without `BuildContext`.

At its core, `Get` is a cleverly designed global static instance. When you use GetX (typically by wrapping your app with `GetMaterialApp`), GetX sets up the necessary infrastructure.

Here's a simplified conceptual flow for showing a snackbar:

```mermaid
sequenceDiagram
    participant YourCode as Your App Code
    participant Get as Get Object
    participant GetXCore as GetX Internal Logic
    participant FlutterFramework as Flutter Framework

    YourCode->>Get: Calls Get.snackbar("Title", "Message")
    Get->>GetXCore: Forwards request to internal snackbar logic
    GetXCore->>FlutterFramework: Uses Flutter's Overlay (or similar) to display UI
    FlutterFramework-->>YourCode: Snackbar appears on screen
```

**1. The `Get` Object Itself:**
The `Get` object you use is actually a global instance of a class. This is defined very simply in the GetX core:

```dart
// From: get_core/src/get_main.dart

// (_GetImpl is a class that implements GetInterface,
// where all the actual methods are defined or extended)
class _GetImpl extends GetInterface {}

// This creates a single, globally accessible instance named 'Get'
// ignore: non_constant_identifier_names
final Get = _GetImpl();
```
This `Get` variable is what you're accessing when you type `Get.something()`.

**2. `GetInterface` and Extensions:**
The `_GetImpl` class extends `GetInterface`.
```dart
// From: get_core/src/get_interface.dart
abstract class GetInterface {
  // Basic configurations like smartManagement and logging
  SmartManagement smartManagement = SmartManagement.full;
  bool isLogEnable = kDebugMode;
  LogWriterCallback log = defaultLogWriterCallback;
  // ... other core properties might be declared here
}
```
Many of GetX's functionalities (like `Get.to`, `Get.snackbar`, `Get.put`, `Get.find`) are added to this `GetInterface` through Dart's extension methods or are mixed into `_GetImpl`. These extensions contain the actual logic. For example, the navigation methods know how to find the `Navigator` provided by `GetMaterialApp`, and the snackbar methods know how to tap into Flutter's `Overlay` to display UI elements globally.

**3. For Dependency Management (`Get.put` / `Get.find`):**
When you use `Get.put(MyService())`, GetX stores this `MyService` instance in an internal data structure (like a map), often an_instance manager. When you later call `Get.find<MyService>()`, GetX looks up `MyService` in this internal storage by its type (and optionally by a tag) and returns the stored instance. We'll cover the `InstanceManager` in more detail in [Chapter 6: Dependency Access (Binder, Bind.of, Get.find/put)](06_dependency_access__binder__bind_of__get_find_put__.md).

The key takeaway is that `Get` acts as a **facade**  a simplified, unified interface to a more complex underlying system. It hides the complexities of interacting directly with Flutter's deeper systems or managing global instances, providing you with clean, easy-to-use static methods.

## Conclusion

You've now met `Get`, your go-to helper for many common tasks in GetX. It's a powerful yet simple facade that provides global access to navigation, UI utilities, dependency management, and more, often without the need for `BuildContext`. This keeps your code clean and makes development faster.

As you continue your GetX journey, you'll see `Get` being used in various contexts. Understanding its role as a global access point is key to mastering GetX.

In the next chapter, we'll explore a core GetX concept for making your application's data dynamic and responsive: [Rx<T> (Reactive Variables)](02_rx_t___reactive_variables__.md).
2025-05-12 13:31:24,172 - INFO - PROMPT: 
Write a very beginner-friendly tutorial chapter (in Markdown format) for the project `lib` about the concept: "Rx<T> (Reactive Variables)
". This is Chapter 2.

Concept Details:
- Name: Rx<T> (Reactive Variables)

- Description:
`Rx<T>` types (like `RxInt`, `RxString`, or anything ending with `.obs`) represent variables that can be "observed."
Imagine a magic number on a special whiteboard: whenever someone writes a new number on it,
a bell automatically rings, and anyone watching that specific number instantly sees the change.
These variables are the core of GetX's reactive programming, allowing your UI (especially with `Obx` widgets) to
automatically update whenever the underlying data changes.


Complete Tutorial Structure:
1. [Get (Global Access Facade)
](01_get__global_access_facade__.md)
2. [Rx<T> (Reactive Variables)
](02_rx_t___reactive_variables__.md)
3. [Obx / ObxWidget
](03_obx___obxwidget_.md)
4. [Workers
](04_workers_.md)
5. [GetxController
](05_getxcontroller_.md)
6. [Dependency Access (Binder, Bind.of, Get.find/put)
](06_dependency_access__binder__bind_of__get_find_put__.md)
7. [GetBuilder
](07_getbuilder_.md)
8. [StateMixin
](08_statemixin_.md)
9. [ListNotifier (and Mixins)
](09_listnotifier__and_mixins__.md)

Context from previous chapters:
# Chapter 1: Get (Global Access Facade)

Welcome to your GetX journey! In this first chapter, we'll explore one of the most fundamental and frequently used parts of the GetX ecosystem: the `Get` object.

## What is `Get` and Why Do You Need It?

Imagine you're building a Flutter app. You often need to perform common tasks like:
*   Showing a quick message (a "snackbar") to the user.
*   Navigating to a new screen.
*   Accessing a shared service, like a settings manager, from various parts of your app.

Traditionally, in Flutter, many of these tasks require access to something called `BuildContext`. `BuildContext` tells Flutter "where" you are in your widget tree, which is necessary for operations like finding the nearest `Navigator` or `Scaffold`. Getting `BuildContext` to the exact spot where you need it can sometimes be cumbersome, especially in deeper parts of your app's logic that aren't directly part of a widget.

This is where `Get` comes to the rescue!

The `Get` object is your main entry point for most GetX features. Think of it as a **universal remote control** for your application. It provides super easy-to-use tools (called static methods) for:

*   **Dependency Management:** Storing and retrieving your app's services or "managers" (like a `UserSettingsManager` or `ApiService`).
*   **Navigation:** Moving between screens with simple commands.
*   **Showing UI Elements:** Displaying dialogs, snackbars, or bottom sheets.
*   ...and much more!

The beauty of `Get` is that it often lets you do these things **without needing `BuildContext`**, making your code cleaner and simplifying access to GetX functionalities from virtually anywhere in your app.

## How to Use `Get`

Using `Get` is incredibly straightforward because its methods are `static`. This means you don't need to create an instance of a `Get` class; you just type `Get.` followed by the feature you want to use.

Let's look at a few common use cases:

### 1. Showing a Snackbar

Need to show a quick notification to the user?

```dart
import 'package:get/get.dart'; // Make sure to import GetX

// ...somewhere in your code, even inside a business logic class
void showSuccessMessage() {
  Get.snackbar(
    "Success!", // title
    "Your profile was updated successfully.", // message
    snackPosition: SnackPosition.BOTTOM
  );
}
```

**What happens?**
When `showSuccessMessage()` is called, GetX will display a snackbar at the bottom of the current screen with the title "Success!" and the given message. Notice you didn't need to pass any `BuildContext`!

### 2. Navigating to a New Screen

Want to open a new page?

```dart
import 'package:flutter/material.dart';
import 'package:get/get.dart';

class HomeScreen extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(title: Text("Home")),
      body: Center(
        child: ElevatedButton(
          onPressed: () {
            Get.to(DetailScreen()); // Navigate to DetailScreen
          },
          child: Text("Go to Details"),
        ),
      ),
    );
  }
}

class DetailScreen extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(title: Text("Details")),
      body: Center(
        child: ElevatedButton(
          onPressed: () {
            Get.back(); // Go back to the previous screen
          },
          child: Text("Go Back"),
        ),
      ),
    );
  }
}
```
**What happens?**
*   Tapping the "Go to Details" button on `HomeScreen` will push `DetailScreen` onto the navigation stack, making it visible.
*   Tapping the "Go Back" button on `DetailScreen` will pop it from the stack, revealing `HomeScreen` again.

Again, simple and no `BuildContext` needed for `Get.to()` or `Get.back()`. (Note: To use GetX navigation, your main app widget should be `GetMaterialApp` instead of `MaterialApp`).

### 3. Basic Dependency Management (Service Locator)

Imagine you have a class that manages user preferences:

```dart
class UserPreferencesService {
  bool _isDarkMode = false;

  bool get isDarkMode => _isDarkMode;

  void toggleDarkMode() {
    _isDarkMode = !_isDarkMode;
    print("Dark mode is now: $_isDarkMode");
    // In a real app, you'd save this preference
  }
}
```

You can "register" an instance of this service with GetX using `Get.put()`:

```dart
// Usually done at app startup or in a specific setup area
void initializeServices() {
  Get.put(UserPreferencesService());
  print("UserPreferencesService registered!");
}
```

Later, from anywhere in your app, you can retrieve this instance using `Get.find()`:

```dart
// ... in some widget or controller
void onThemeToggleButtonPressed() {
  final prefsService = Get.find<UserPreferencesService>();
  prefsService.toggleDarkMode();
  // You might then update your UI based on prefsService.isDarkMode
}
```

**What happens?**
*   `Get.put(UserPreferencesService());` creates an instance of `UserPreferencesService` and stores it in a global container managed by GetX.
*   `Get.find<UserPreferencesService>();` looks up and returns that stored instance.

This allows you to easily access shared services without passing instances around manually or using complex InheritedWidgets. We'll dive much deeper into dependency management in [Chapter 6: Dependency Access (Binder, Bind.of, Get.find/put)](06_dependency_access__binder__bind_of__get_find_put__.md).

## Under the Hood: How Does `Get` Work?

You might be wondering how `Get` can perform these actions, especially UI-related ones like showing snackbars, without `BuildContext`.

At its core, `Get` is a cleverly designed global static instance. When you use GetX (typically by wrapping your app with `GetMaterialApp`), GetX sets up the necessary infrastructure.

Here's a simplified conceptual flow for showing a snackbar:

```mermaid
sequenceDiagram
    participant YourCode as Your App Code
    participant Get as Get Object
    participant GetXCore as GetX Internal Logic
    participant FlutterFramework as Flutter Framework

    YourCode->>Get: Calls Get.snackbar("Title", "Message")
    Get->>GetXCore: Forwards request to internal snackbar logic
    GetXCore->>FlutterFramework: Uses Flutter's Overlay (or similar) to display UI
    FlutterFramework-->>YourCode: Snackbar appears on screen
```

**1. The `Get` Object Itself:**
The `Get` object you use is actually a global instance of a class. This is defined very simply in the GetX core:

```dart
// From: get_core/src/get_main.dart

// (_GetImpl is a class that implements GetInterface,
// where all the actual methods are defined or extended)
class _GetImpl extends GetInterface {}

// This creates a single, globally accessible instance named 'Get'
// ignore: non_constant_identifier_names
final Get = _GetImpl();
```
This `Get` variable is what you're accessing when you type `Get.something()`.

**2. `GetInterface` and Extensions:**
The `_GetImpl` class extends `GetInterface`.
```dart
// From: get_core/src/get_interface.dart
abstract class GetInterface {
  // Basic configurations like smartManagement and logging
  SmartManagement smartManagement = SmartManagement.full;
  bool isLogEnable = kDebugMode;
  LogWriterCallback log = defaultLogWriterCallback;
  // ... other core properties might be declared here
}
```
Many of GetX's functionalities (like `Get.to`, `Get.snackbar`, `Get.put`, `Get.find`) are added to this `GetInterface` through Dart's extension methods or are mixed into `_GetImpl`. These extensions contain the actual logic. For example, the navigation methods know how to find the `Navigator` provided by `GetMaterialApp`, and the snackbar methods know how to tap into Flutter's `Overlay` to display UI elements globally.

**3. For Dependency Management (`Get.put` / `Get.find`):**
When you use `Get.put(MyService())`, GetX stores this `MyService` instance in an internal data structure (like a map), often an_instance manager. When you later call `Get.find<MyService>()`, GetX looks up `MyService` in this internal storage by its type (and optionally by a tag) and returns the stored instance. We'll cover the `InstanceManager` in more detail in [Chapter 6: Dependency Access (Binder, Bind.of, Get.find/put)](06_dependency_access__binder__bind_of__get_find_put__.md).

The key takeaway is that `Get` acts as a **facade**  a simplified, unified interface to a more complex underlying system. It hides the complexities of interacting directly with Flutter's deeper systems or managing global instances, providing you with clean, easy-to-use static methods.

## Conclusion

You've now met `Get`, your go-to helper for many common tasks in GetX. It's a powerful yet simple facade that provides global access to navigation, UI utilities, dependency management, and more, often without the need for `BuildContext`. This keeps your code clean and makes development faster.

As you continue your GetX journey, you'll see `Get` being used in various contexts. Understanding its role as a global access point is key to mastering GetX.

In the next chapter, we'll explore a core GetX concept for making your application's data dynamic and responsive: [Rx<T> (Reactive Variables)](02_rx_t___reactive_variables__.md).

Relevant Code Snippets (Code itself remains unchanged):
--- File: get_state_manager/src/rx_flutter/rx_notifier.dart ---
import 'dart:async';

import 'package:flutter/foundation.dart';
import 'package:flutter/material.dart';
import 'package:get/utils.dart';

import '../../../get_rx/src/rx_types/rx_types.dart';
import '../../../instance_manager.dart';
import '../../get_state_manager.dart';
import '../simple/list_notifier.dart';

extension _Empty on Object {
  bool _isEmpty() {
    final val = this;
    // if (val == null) return true;
    var result = false;
    if (val is Iterable) {
      result = val.isEmpty;
    } else if (val is String) {
      result = val.trim().isEmpty;
    } else if (val is Map) {
      result = val.isEmpty;
    }
    return result;
  }
}

mixin StateMixin<T> on ListNotifier {
  T? _value;
  GetStatus<T>? _status;

  void _fillInitialStatus() {
    _status = (_value == null || _value!._isEmpty())
        ? GetStatus<T>.loading()
        : GetStatus<T>.success(_value as T);
  }

  GetStatus<T> get status {
    reportRead();
    return _status ??= _status = GetStatus.loading();
  }

  T get state => value;

  set status(GetStatus<T> newStatus) {
    if (newStatus == status) return;
    _status = newStatus;
    if (newStatus is SuccessStatus<T>) {
      _value = newStatus.data;
    }
    refresh();
  }

  @protected
  T get value {
    reportRead();
    return _value as T;
  }

  @protected
  set value(T newValue) {
    if (_value == newValue) return;
    _value = newValue;
    refresh();
  }

  @protected
  void change(GetStatus<T> status) {
    if (status != this.status) {
      this.status = status;
    }
  }

  void setSuccess(T data) {
    change(GetStatus<T>.success(data));
  }

  void setError(Object error) {
    change(GetStatus<T>.error(error));
  }

  void setLoading() {
    change(GetStatus<T>.loading());
  }

  void setEmpty() {
    change(GetStatus<T>.empty());
  }

  void futurize(Future<T> Function() body,
      {T? initialData, String? errorMessage, bool useEmpty = true}) {
    final compute = body;
    _value ??= initialData;
    status = GetStatus<T>.loading();
    compute().then((newValue) {
      if ((newValue == null || newValue._isEmpty()) && useEmpty) {
        status = GetStatus<T>.empty();
      } else {
        status = GetStatus<T>.success(newValue);
      }

      refresh();
    }, onError: (err) {
      status = GetStatus.error(
          err is Exception ? err : Exception(errorMessage ?? err.toString()));
      refresh();
    });
  }
}

typedef FuturizeCallback<T> = Future<T> Function(VoidCallback fn);

typedef VoidCallback = void Function();

class GetListenable<T> extends ListNotifierSingle implements RxInterface<T> {
  GetListenable(T val) : _value = val;

  StreamController<T>? _controller;

  StreamController<T> get subject {
    if (_controller == null) {
      _controller =
          StreamController<T>.broadcast(onCancel: addListener(_streamListener));
      _controller?.add(_value);

      ///TODO: report to controller dispose
    }
    return _controller!;
  }

  void _streamListener() {
    _controller?.add(_value);
  }

  @override
  @mustCallSuper
  void close() {
    removeListener(_streamListener);
    _controller?.close();
    dispose();
  }

  Stream<T> get stream {
    return subject.stream;
  }

  T _value;

  @override
  T get value {
    reportRead();
    return _value;
  }

  void _notify() {
    refresh();
  }

  set value(T newValue) {
    if (_value == newValue) return;
    _value = newValue;
    _notify();
  }

  T? call([T? v]) {
    if (v != null) {
      value = v;
    }
    return value;
  }

  @override
  StreamSubscription<T> listen(
    void Function(T)? onData, {
    Function? onError,
    void Function()? onDone,
    bool? cancelOnError,
  }) =>
      stream.listen(
        onData,
        onError: onError,
        onDone: onDone,
        cancelOnError: cancelOnError ?? false,
      );

  @override
  String toString() => value.toString();
}

class Value<T> extends ListNotifier
    with StateMixin<T>
    implements ValueListenable<T?> {
  Value(T val) {
    _value = val;
    _fillInitialStatus();
  }

  @override
  T get value {
    reportRead();
    return _value as T;
  }

  @override
  set value(T newValue) {
    if (_value == newValue) return;
    _value = newValue;
    refresh();
  }

  T? call([T? v]) {
    if (v != null) {
      value = v;
    }
    return value;
  }

  void update(T Function(T? value) fn) {
    value = fn(value);
    // refresh();
  }

  @override
  String toString() => value.toString();

  dynamic toJson() => (value as dynamic)?.toJson();
}

/// GetNotifier has a native status and state implementation, with the
/// Get Lifecycle
abstract class GetNotifier<T> extends Value<T> with GetLifeCycleMixin {
  GetNotifier(super.initial);
}

extension StateExt<T> on StateMixin<T> {
  Widget obx(
    NotifierBuilder<T> widget, {
    Widget Function(String? error)? onError,
    Widget? onLoading,
    Widget? onEmpty,
    WidgetBuilder? onCustom,
  }) {
    return Observer(builder: (context) {
      if (status.isLoading) {
        return onLoading ?? const Center(child: CircularProgressIndicator());
      } else if (status.isError) {
        return onError != null
            ? onError(status.errorMessage)
            : Center(child: Text('A error occurred: ${status.errorMessage}'));
      } else if (status.isEmpty) {
        return onEmpty ??
            const SizedBox.shrink(); // Also can be widget(null); but is risky
      } else if (status.isSuccess) {
        return widget(value);
      } else if (status.isCustom) {
        return onCustom?.call(context) ??
            const SizedBox.shrink(); // Also can be widget(null); but is risky
      }
      return widget(value);
    });
  }
}

typedef NotifierBuilder<T> = Widget Function(T state);

abstract class GetStatus<T> with Equality {
  const GetStatus();

  factory GetStatus.loading() => LoadingStatus<T>();

  factory GetStatus.error(Object message) => ErrorStatus<T, Object>(message);

  factory GetStatus.empty() => EmptyStatus<T>();

  factory GetStatus.success(T data) => SuccessStatus<T>(data);

  factory GetStatus.custom() => CustomStatus<T>();
}

class CustomStatus<T> extends GetStatus<T> {
  @override
  List get props => [];
}

class LoadingStatus<T> extends GetStatus<T> {
  @override
  List get props => [];
}

class SuccessStatus<T> extends GetStatus<T> {
  final T data;

  const SuccessStatus(this.data);

  @override
  List get props => [data];
}

class ErrorStatus<T, S> extends GetStatus<T> {
  final S? error;

  const ErrorStatus([this.error]);

  @override
  List get props => [error];
}

class EmptyStatus<T> extends GetStatus<T> {
  @override
  List get props => [];
}

extension StatusDataExt<T> on GetStatus<T> {
  bool get isLoading => this is LoadingStatus;

  bool get isSuccess => this is SuccessStatus;

  bool get isError => this is ErrorStatus;

  bool get isEmpty => this is EmptyStatus;

  bool get isCustom => !isLoading && !isSuccess && !isError && !isEmpty;

  dynamic get error {
    if (this is ErrorStatus) {
      return (this as ErrorStatus).error;
    }
    return null;
  }

  String get errorMessage {
    final isError = this is ErrorStatus;
    if (isError) {
      final err = this as ErrorStatus;
      if (err.error != null) {
        if (err.error is String) {
          return err.error as String;
        }
        return err.error.toString();
      }
    }

    return '';
  }

  T? get data {
    if (this is SuccessStatus<T>) {
      final success = this as SuccessStatus<T>;
      return success.data;
    }
    return null;
  }
}


--- File: get_rx/src/rx_types/rx_types.dart ---
library;

import 'dart:async';
import 'dart:collection';

import 'package:flutter/foundation.dart';

import '../../../get_state_manager/src/rx_flutter/rx_notifier.dart';
import '../rx_typedefs/rx_typedefs.dart';

part 'rx_core/rx_impl.dart';
part 'rx_core/rx_interface.dart';
part 'rx_core/rx_num.dart';
part 'rx_core/rx_string.dart';
part 'rx_iterables/rx_list.dart';
part 'rx_iterables/rx_map.dart';
part 'rx_iterables/rx_set.dart';


--- File: get_rx/src/rx_types/rx_core/rx_interface.dart ---
part of '../rx_types.dart';

/// This class is the foundation for all reactive (Rx) classes that makes Get
/// so powerful.
/// This interface is the contract that `_RxImpl<T>` uses in all it's
/// subclass.
abstract class RxInterface<T> implements ValueListenable<T> {
  /// Close the Rx Variable
  void close();

  /// Calls `callback` with current value, when the value changes.
  StreamSubscription<T> listen(void Function(T event) onData,
      {Function? onError, void Function()? onDone, bool? cancelOnError});
}

class ObxError {
  const ObxError();
  @override
  String toString() {
    return """
      [Get] the improper use of a GetX has been detected. 
      You should only use GetX or Obx for the specific widget that will be updated.
      If you are seeing this error, you probably did not insert any observable variables into GetX/Obx 
      or insert them outside the scope that GetX considers suitable for an update 
      (example: GetX => HeavyWidget => variableObservable).
      If you need to update a parent widget and a child widget, wrap each one in an Obx/GetX.
      """;
  }
}


--- File: get_rx/src/rx_types/rx_core/rx_impl.dart ---
part of '../rx_types.dart';

/// global object that registers against `GetX` and `Obx`, and allows the
/// reactivity
/// of those `Widgets` and Rx values.

mixin RxObjectMixin<T> on GetListenable<T> {
  //late T _value;

  /// Makes a direct update of [value] adding it to the Stream
  /// useful when you make use of Rx for custom Types to refresh your UI.
  ///
  /// Sample:
  /// ```
  ///  class Person {
  ///     String name, last;
  ///     int age;
  ///     Person({this.name, this.last, this.age});
  ///     @override
  ///     String toString() => '$name $last, $age years old';
  ///  }
  ///
  /// final person = Person(name: 'John', last: 'Doe', age: 18).obs;
  /// person.value.name = 'Roi';
  /// person.refresh();
  /// print( person );
  /// ```
  // void refresh() {
  //   subject.add(value);
  // }

  /// updates the value to `null` and adds it to the Stream.
  /// Even with null-safety coming, is still an important feature to support, as
  /// `call()` doesn't accept `null` values. For instance,
  /// `InputDecoration.errorText` has to be null to not show the "error state".
  ///
  /// Sample:
  /// ```
  /// final inputError = ''.obs..nil();
  /// print('${inputError.runtimeType}: $inputError'); // outputs > RxString: null
  /// ```
  // void nil() {
  //   subject.add(_value = null);
  // }

  /// Makes this Rx looks like a function so you can update a new
  /// value using `rx(someOtherValue)`. Practical to assign the Rx directly
  /// to some Widget that has a signature ::onChange( value )
  ///
  /// Example:
  /// ```
  /// final myText = 'GetX rocks!'.obs;
  ///
  /// // in your Constructor, just to check it works :P
  /// ever( myText, print ) ;
  ///
  /// // in your build(BuildContext) {
  /// TextField(
  ///   onChanged: myText,
  /// ),
  ///```
  @override
  T call([T? v]) {
    if (v != null) {
      value = v;
    }
    return value;
  }

  bool firstRebuild = true;
  bool sentToStream = false;

  /// Same as `toString()` but using a getter.
  String get string => value.toString();

  @override
  String toString() => value.toString();

  /// Returns the json representation of `value`.
  dynamic toJson() => value;

  /// This equality override works for _RxImpl instances and the internal
  /// values.
  @override
  // ignore: avoid_equals_and_hash_code_on_mutable_classes
  bool operator ==(Object o) {
    // Todo, find a common implementation for the hashCode of different Types.
    if (o is T) return value == o;
    if (o is RxObjectMixin<T>) return value == o.value;
    return false;
  }

  @override
  // ignore: avoid_equals_and_hash_code_on_mutable_classes
  int get hashCode => value.hashCode;

  /// Updates the [value] and adds it to the stream, updating the observer
  /// Widget, only if it's different from the previous value.
  @override
  set value(T val) {
    if (isDisposed) return;
    sentToStream = false;
    if (value == val && !firstRebuild) return;
    firstRebuild = false;
    sentToStream = true;
    super.value = val;
  }

  /// Returns a [StreamSubscription] similar to [listen], but with the
  /// added benefit that it primes the stream with the current [value], rather
  /// than waiting for the next [value]. This should not be called in [onInit]
  /// or anywhere else during the build process.
  StreamSubscription<T> listenAndPump(void Function(T event) onData,
      {Function? onError, void Function()? onDone, bool? cancelOnError}) {
    final subscription = listen(
      onData,
      onError: onError,
      onDone: onDone,
      cancelOnError: cancelOnError,
    );

    subject.add(value);

    return subscription;
  }

  /// Binds an existing `Stream<T>` to this `Rx<T>` to keep the values in sync.
  /// You can bind multiple sources to update the value.
  /// Closing the subscription will happen automatically when the observer
  /// Widget (`GetX` or `Obx`) gets unmounted from the Widget tree.
  void bindStream(Stream<T> stream) {
    // final listSubscriptions =
    //     _subscriptions[subject] ??= <StreamSubscription>[];

    final sub = stream.listen((va) => value = va);
    reportAdd(sub.cancel);
  }
}

/// Base Rx class that manages all the stream logic for any Type.
abstract class _RxImpl<T> extends GetListenable<T> with RxObjectMixin<T> {
  _RxImpl(super.initial);

  void addError(Object error, [StackTrace? stackTrace]) {
    subject.addError(error, stackTrace);
  }

  Stream<R> map<R>(R Function(T? data) mapper) => stream.map(mapper);

  /// Uses a callback to update [value] internally, similar to [refresh],
  /// but provides the current value as the argument.
  /// Makes sense for custom Rx types (like Models).
  ///
  /// Sample:
  /// ```
  ///  class Person {
  ///     String name, last;
  ///     int age;
  ///     Person({this.name, this.last, this.age});
  ///     @override
  ///     String toString() => '$name $last, $age years old';
  ///  }
  ///
  /// final person = Person(name: 'John', last: 'Doe', age: 18).obs;
  /// person.update((person) {
  ///   person.name = 'Roi';
  /// });
  /// print( person );
  /// ```
  void update(T Function(T? val) fn) {
    value = fn(value);
    // subject.add(value);
  }

  /// Following certain practices on Rx data, we might want to react to certain
  /// listeners when a value has been provided, even if the value is the same.
  /// At the moment, we ignore part of the process if we `.call(value)` with
  /// the same value since it holds the value and there's no real
  /// need triggering the entire process for the same value inside, but
  /// there are other situations where we might be interested in
  /// triggering this.
  ///
  /// For example, supposed we have a `int seconds = 2` and we want to animate
  /// from invisible to visible a widget in two seconds:
  /// `RxEvent<int>.call(seconds);`
  /// then after a click happens, you want to call a `RxEvent<int>.call(seconds)`.
  /// By doing `call(seconds)`, if the value being held is the same,
  /// the listeners won't trigger, hence we need this new `trigger` function.
  /// This will refresh the listener of an AnimatedWidget and will keep
  /// the value if the Rx is kept in memory.
  /// Sample:
  /// ```
  /// Rx<Int> secondsRx = RxInt();
  /// secondsRx.listen((value) => print("$value seconds set"));
  ///
  /// secondsRx.call(2);      // This won't trigger any listener, since the value is the same
  /// secondsRx.trigger(2);   // This will trigger the listener independently from the value.
  /// ```
  ///
  void trigger(T v) {
    var firstRebuild = this.firstRebuild;
    value = v;
    // If it's not the first rebuild, the listeners have been called already
    // So we won't call them again.
    if (!firstRebuild && !sentToStream) {
      subject.add(v);
    }
  }
}

class RxBool extends Rx<bool> {
  RxBool(super.initial);
  @override
  String toString() {
    return value ? "true" : "false";
  }
}

class RxnBool extends Rx<bool?> {
  RxnBool([super.initial]);
  @override
  String toString() {
    return "$value";
  }
}

extension RxBoolExt on Rx<bool> {
  bool get isTrue => value;

  bool get isFalse => !isTrue;

  bool operator &(bool other) => other && value;

  bool operator |(bool other) => other || value;

  bool operator ^(bool other) => !other == value;

  /// Toggles the bool [value] between false and true.
  /// A shortcut for `flag.value = !flag.value;`
  void toggle() {
    call(!value);
    // return this;
  }
}

extension RxnBoolExt on Rx<bool?> {
  bool? get isTrue => value;

  bool? get isFalse {
    if (value != null) return !isTrue!;
    return null;
  }

  bool? operator &(bool other) {
    if (value != null) {
      return other && value!;
    }
    return null;
  }

  bool? operator |(bool other) {
    if (value != null) {
      return other || value!;
    }
    return null;
  }

  bool? operator ^(bool other) => !other == value;

  /// Toggles the bool [value] between false and true.
  /// A shortcut for `flag.value = !flag.value;`
  void toggle() {
    if (value != null) {
      call(!value!);
      // return this;
    }
  }
}

/// Foundation class used for custom `Types` outside the common native Dart
/// types.
/// For example, any custom "Model" class, like User().obs will use `Rx` as
/// wrapper.
class Rx<T> extends _RxImpl<T> {
  Rx(super.initial);

  @override
  dynamic toJson() {
    try {
      return (value as dynamic)?.toJson();
    } on Exception catch (_) {
      throw '$T has not method [toJson]';
    }
  }
}

class Rxn<T> extends Rx<T?> {
  Rxn([super.initial]);

  @override
  dynamic toJson() {
    try {
      return (value as dynamic)?.toJson();
    } on Exception catch (_) {
      throw '$T has not method [toJson]';
    }
  }
}

extension StringExtension on String {
  /// Returns a `RxString` with [this] `String` as initial value.
  RxString get obs => RxString(this);
}

extension IntExtension on int {
  /// Returns a `RxInt` with [this] `int` as initial value.
  RxInt get obs => RxInt(this);
}

extension DoubleExtension on double {
  /// Returns a `RxDouble` with [this] `double` as initial value.
  RxDouble get obs => RxDouble(this);
}

extension BoolExtension on bool {
  /// Returns a `RxBool` with [this] `bool` as initial value.
  RxBool get obs => RxBool(this);
}

extension RxT<T extends Object> on T {
  /// Returns a `Rx` instance with [this] `T` as initial value.
  Rx<T> get obs => Rx<T>(this);
}

/// This method will replace the old `.obs` method.
/// It's a breaking change, but it is essential to avoid conflicts with
/// the new dart 3 features. T will be inferred by contextual type inference
/// rather than the extension type.
extension RxTnew on Object {
  /// Returns a `Rx` instance with [this] `T` as initial value.
  Rx<T> obs<T>() => Rx<T>(this as T);
}


Instructions for the chapter (Generate content in English unless specified otherwise):
- Start with a clear heading (e.g., `# Chapter 2: Rx<T> (Reactive Variables)
`). Use the provided concept name.

- If this is not the first chapter, begin with a brief transition from the previous chapter, referencing it with a proper Markdown link using its name.

- Begin with a high-level motivation explaining what problem this abstraction solves. Start with a central use case as a concrete example. The whole chapter should guide the reader to understand how to solve this use case. Make it very minimal and friendly to beginners.

- If the abstraction is complex, break it down into key concepts. Explain each concept one-by-one in a very beginner-friendly way.

- Explain how to use this abstraction to solve the use case. Give example inputs and outputs for code snippets (if the output isn't values, describe at a high level what will happen).

- Each code block should be BELOW 10 lines! If longer code blocks are needed, break them down into smaller pieces and walk through them one-by-one. Aggresively simplify the code to make it minimal. Use comments to skip non-important implementation details. Each code block should have a beginner friendly explanation right after it.

- Describe the internal implementation to help understand what's under the hood. First provide a non-code or code-light walkthrough on what happens step-by-step when the abstraction is called. It's recommended to use a simple sequenceDiagram with a dummy example - keep it minimal with at most 5 participants to ensure clarity. If participant name has space, use: `participant QP as Query Processing`. .

- Then dive deeper into code for the internal implementation with references to files. Provide example code blocks, but make them similarly simple and beginner-friendly. Explain.

- IMPORTANT: When you need to refer to other core abstractions covered in other chapters, ALWAYS use proper Markdown links like this: [Chapter Title](filename.md). Use the Complete Tutorial Structure above to find the correct filename and the chapter title. Translate the surrounding text.

- Use mermaid diagrams to illustrate complex concepts (```mermaid``` format). .

- Heavily use analogies and examples throughout to help beginners understand.

- End the chapter with a brief conclusion that summarizes what was learned and provides a transition to the next chapter. If there is a next chapter, use a proper Markdown link: [Next Chapter Title](next_chapter_filename).

- Ensure the tone is welcoming and easy for a newcomer to understand.

- Output *only* the Markdown content for this chapter.

Now, directly provide a super beginner-friendly Markdown output (DON'T need ```markdown``` tags):

2025-05-12 13:32:42,766 - INFO - RESPONSE: # Chapter 2: Rx<T> (Reactive Variables)

Welcome to Chapter 2! In [Chapter 1: Get (Global Access Facade)](01_get__global_access_facade__.md), we learned how the `Get` object acts as a handy "universal remote" for common app tasks. Now, we're going to dive into one of the most exciting features of GetX: making your app's data "reactive."

## What's the Big Deal with "Reactive"?

Imagine you're building an app that shows a user's score. When the score changes, you want the text on the screen displaying that score to update *automatically*, without you having to write a lot of complicated code to manually refresh the screen. This "automatic updating" is what reactive programming is all about.

`Rx<T>` variables are GetX's way of achieving this magic.

## Introducing `Rx<T>`: Your Magic Whiteboard

`Rx<T>` types (like `RxInt`, `RxString`, or pretty much anything you see ending with `.obs`) represent variables that can be "observed."

Think of an `Rx<T>` variable as a special number (or text, or any data) written on a **magic whiteboard**:
*   You write your initial data on this whiteboard (e.g., the number `0`).
*   Whenever someone erases the number and writes a new one (e.g., changes it to `1`), a bell automatically rings!
*   Anyone (or any part of your app's UI) specifically "watching" that number on the whiteboard instantly sees the change and reacts to it.

These `Rx<T>` variables are the heart of GetX's reactive programming. They allow your User Interface (UI), especially when used with widgets like `Obx` (which we'll cover in the [next chapter](03_obx___obxwidget_.md)), to automatically update whenever the underlying data changes.

The `T` in `Rx<T>` is a placeholder for the type of data the variable will hold, like `int`, `String`, `bool`, or even your own custom classes.

## How to Create and Use Reactive Variables

Let's see how to create and use these "magic" variables. The most common way is by using the `.obs` extension on a standard Dart value.

### 1. Creating a Reactive Variable

To make a regular variable reactive, you simply add `.obs` to its initial value.

**For a number (integer):**

```dart
import 'package:get/get.dart'; // Don't forget to import GetX

final count = 0.obs; // This is now an RxInt holding 0
// You could also write: final count = RxInt(0);
```
Here, `count` isn't just a regular `int`. It's now a special `RxInt` object that holds the integer value `0` and can notify others when it changes.

**For text (string):**

```dart
final userName = "Guest".obs; // This is an RxString holding "Guest"
// You could also write: final userName = RxString("Guest");
```
Similarly, `userName` is an `RxString`.

**For a boolean (true/false):**

```dart
final isLoggedIn = false.obs; // This is an RxBool holding false
// You could also write: final isLoggedIn = RxBool(false);
```

### 2. Getting the Value

If `count` is an `RxInt`, how do you get the actual integer value out of it? You use the `.value` property.

```dart
final count = 0.obs;
print(count.value); // Output: 0

final userName = "Guest".obs;
print(userName.value); // Output: Guest
```
Think of `.value` as looking at the magic whiteboard to read what's currently written on it.

### 3. Changing the Value (and Ringing the Bell!)

To change the value of a reactive variable, you also assign a new value to its `.value` property. This is the action that "rings the bell."

```dart
final count = 0.obs;
print("Initial count: ${count.value}"); // Output: Initial count: 0

count.value = 5; // You changed the number on the whiteboard!
print("New count: ${count.value}"); // Output: New count: 5
```
When you do `count.value = 5;`, the `count` variable not only updates its internal number but also sends out a notification that its value has changed.

You can also change the value by calling the `Rx` variable like a function:
```dart
final anotherCount = 10.obs;
anotherCount(15); // Same as anotherCount.value = 15;
print(anotherCount.value); // Output: 15
```
This is just a shorthand. Both ways achieve the same result.

### A Simple Example: The Counter Logic

Let's imagine the logic for a simple counter. We won't build the UI yet, just the data part.

```dart
import 'package:get/get.dart';

// 1. Create a reactive variable for our count
final magicCounter = 0.obs;

void incrementCounter() {
  // 2. Change its value
  magicCounter.value++; // This rings the bell!
  print("Counter is now: ${magicCounter.value}");
}

void main() {
  print("Counter starts at: ${magicCounter.value}");
  incrementCounter(); // Call the function to change the value
  incrementCounter();
}
```
**What happens?**
1.  `magicCounter` is created as an `RxInt` initialized to `0`.
2.  When `incrementCounter()` is called, `magicCounter.value++` increases the stored integer and notifies any listeners.
3.  The `print` statement shows the updated value.

Output:
```
Counter starts at: 0
Counter is now: 1
Counter is now: 2
```
Right now, only our `print` statements are "listening" in a very basic way. In the [next chapter](03_obx___obxwidget_.md), we'll see how to make Flutter UI widgets listen and update automatically!

## Under the Hood: How Does `.obs` Work?

You might wonder what `.obs` actually does. It's a clever use of Dart's "extension methods."

When you write `0.obs`, GetX has an extension on the `int` type that looks something like this (simplified):

```dart
// From: get_rx/src/rx_types/rx_core/rx_impl.dart (simplified concept)
extension IntExtension on int {
  RxInt get obs => RxInt(this); // 'this' refers to the integer itself
}
```
This code basically says: "If you see `.obs` after an integer, create a new `RxInt` object and give it that integer's value." Similar extensions exist for `String`, `bool`, `double`, and even a generic `Rx<T>` for any object via `T.obs`.

The `RxInt`, `RxString`, etc., classes (which generally inherit from `_RxImpl<T>`) are special classes that manage an internal value and have a built-in mechanism to notify listeners.

Here's a simplified step-by-step of what happens when you change an `Rx` variable's value:

```mermaid
sequenceDiagram
    participant YourCode as Your App Code
    participant RxVariable as count (RxInt)
    participant RxImpl as Internal Logic (_RxImpl)
    participant Listeners as Potential UI (e.g., Obx)

    YourCode->>RxVariable: count.value = 1
    Note over RxVariable: This calls the 'set value' logic
    RxVariable->>RxImpl: Pass new value (1)
    RxImpl->>RxImpl: Store new value (1) internally
    RxImpl->>RxImpl: Check: Has value actually changed?
    alt Value Changed
        RxImpl-->>Listeners: Notifies all listeners (rings the bell!)
        Listeners-->>RxVariable: (Later) Asks RxVariable for its new .value
    end
```

1.  **You assign to `.value`**: `count.value = 1;`
2.  **Setter is called**: The `RxInt` class (or its parent `_RxImpl` found in `get_rx/src/rx_types/rx_core/rx_impl.dart`) has a special `set value(newValue)` method.
3.  **Value Check**: This setter first checks if the `newValue` is actually different from the current stored value. If it's the same, it usually does nothing to avoid unnecessary notifications.
4.  **Store New Value**: If the value is different, it updates its internal storage.
5.  **Notify Listeners**: This is the magic part! The class then triggers a notification. Internally, it often uses a `StreamController` (from `dart:async`). When you change `.value`, it essentially adds the new value to its stream using something like `subject.add(newValue)` after updating its internal `_value`.
    ```dart
    // Highly simplified concept from RxObjectMixin in get_rx/src/rx_types/rx_core/rx_impl.dart
    // and GetListenable in get_state_manager/src/rx_flutter/rx_notifier.dart

    // In GetListenable:
    // StreamController<T>? _controller;
    // T _value;
    // void refresh() { _controller?.add(_value); }

    // In RxObjectMixin (which uses GetListenable):
    set value(T val) {
      if (_value == val && !firstRebuild) return; // _value is from GetListenable
      firstRebuild = false;
      super.value = val; // This typically calls GetListenable's setter, which then calls refresh()
                         // `super.value = val;` roughly does:_value = val; refresh();
    }
    ```
    The `super.value = val;` line in `RxObjectMixin`'s setter calls the setter in its parent class (`GetListenable`), which updates the internal `_value` and then calls `refresh()`. The `refresh()` method then typically adds the new value to an internal stream (`_controller?.add(_value);`), effectively "ringing the bell."

Any widget designed to listen to these streams (like `Obx`) will then pick up this notification.

## Different Kinds of Rx Variables

GetX provides several pre-built `Rx` types for convenience:

*   **Primitives:**
    *   `RxInt(initialValue)` or `initialValue.obs` for integers.
    *   `RxDouble(initialValue)` or `initialValue.obs` for doubles.
    *   `RxString(initialValue)` or `initialValue.obs` for strings.
    *   `RxBool(initialValue)` or `initialValue.obs` for booleans.
*   **Collections (these are a bit more advanced as they react to internal changes too):**
    *   `RxList<T>([])` or `[].obs` for lists.
    *   `RxMap<K, V>({})` or `{}.obs` for maps.
    *   `RxSet<T>({})` or `{}.obs` for sets.
*   **Generic `Rx<T>`:**
    *   For any other type, including your custom classes:
        ```dart
        class User {
          String name;
          User(this.name);
        }

        final user = User("Alice").obs; // user is now an Rx<User>
        // or: final user = Rx<User>(User("Alice"));

        print(user.value.name); // Output: Alice
        user.value.name = "Bob";
        user.refresh(); // For complex objects, you might need to call refresh()
                        // or use user.update((val) { val.name = "Bob"; });
                        // to ensure listeners are notified of internal changes.
        print(user.value.name); // Output: Bob
        ```
    For changes *inside* a custom object held by `Rx<T>`, like changing `user.value.name`, GetX might not automatically know the object's internal state changed. In such cases, you can call `user.refresh()` to manually trigger the "bell," or use the `update()` method: `user.update((currentUser) { currentUser.name = "Bob"; });` which handles the refresh for you.

## Conclusion

You've now learned about `Rx<T>` variables  the "magic whiteboards" of GetX! They are special variables, easily created with `.obs`, that automatically notify anyone interested when their `.value` changes. This is the foundation of reactive programming in GetX and is crucial for building UIs that update themselves effortlessly.

These reactive variables are often managed within [GetxController](05_getxcontroller_.md) classes (which we'll cover later), making state management clean and powerful.

In the [next chapter, Chapter 3: Obx / ObxWidget](03_obx___obxwidget_.md), we'll see how to use `Obx` widgets to make your UI actually listen to these `Rx<T>` variables and update automatically when that magic bell rings!
2025-05-12 13:32:42,826 - INFO - PROMPT: 
Write a very beginner-friendly tutorial chapter (in Markdown format) for the project `lib` about the concept: "Obx / ObxWidget
". This is Chapter 3.

Concept Details:
- Name: Obx / ObxWidget

- Description:
`Obx` (and its base `ObxWidget`) is a widget that automatically rebuilds when any reactive
variable (`Rx<T>`) used inside its builder function changes.
It's like having a smart picture frame that's wirelessly connected to a photo album;
as soon as a new photo (data changes) is added to the observed album, the frame
instantly displays it. This offers an efficient and declarative way to keep your UI in sync with reactive state.


Complete Tutorial Structure:
1. [Get (Global Access Facade)
](01_get__global_access_facade__.md)
2. [Rx<T> (Reactive Variables)
](02_rx_t___reactive_variables__.md)
3. [Obx / ObxWidget
](03_obx___obxwidget_.md)
4. [Workers
](04_workers_.md)
5. [GetxController
](05_getxcontroller_.md)
6. [Dependency Access (Binder, Bind.of, Get.find/put)
](06_dependency_access__binder__bind_of__get_find_put__.md)
7. [GetBuilder
](07_getbuilder_.md)
8. [StateMixin
](08_statemixin_.md)
9. [ListNotifier (and Mixins)
](09_listnotifier__and_mixins__.md)

Context from previous chapters:
# Chapter 1: Get (Global Access Facade)

Welcome to your GetX journey! In this first chapter, we'll explore one of the most fundamental and frequently used parts of the GetX ecosystem: the `Get` object.

## What is `Get` and Why Do You Need It?

Imagine you're building a Flutter app. You often need to perform common tasks like:
*   Showing a quick message (a "snackbar") to the user.
*   Navigating to a new screen.
*   Accessing a shared service, like a settings manager, from various parts of your app.

Traditionally, in Flutter, many of these tasks require access to something called `BuildContext`. `BuildContext` tells Flutter "where" you are in your widget tree, which is necessary for operations like finding the nearest `Navigator` or `Scaffold`. Getting `BuildContext` to the exact spot where you need it can sometimes be cumbersome, especially in deeper parts of your app's logic that aren't directly part of a widget.

This is where `Get` comes to the rescue!

The `Get` object is your main entry point for most GetX features. Think of it as a **universal remote control** for your application. It provides super easy-to-use tools (called static methods) for:

*   **Dependency Management:** Storing and retrieving your app's services or "managers" (like a `UserSettingsManager` or `ApiService`).
*   **Navigation:** Moving between screens with simple commands.
*   **Showing UI Elements:** Displaying dialogs, snackbars, or bottom sheets.
*   ...and much more!

The beauty of `Get` is that it often lets you do these things **without needing `BuildContext`**, making your code cleaner and simplifying access to GetX functionalities from virtually anywhere in your app.

## How to Use `Get`

Using `Get` is incredibly straightforward because its methods are `static`. This means you don't need to create an instance of a `Get` class; you just type `Get.` followed by the feature you want to use.

Let's look at a few common use cases:

### 1. Showing a Snackbar

Need to show a quick notification to the user?

```dart
import 'package:get/get.dart'; // Make sure to import GetX

// ...somewhere in your code, even inside a business logic class
void showSuccessMessage() {
  Get.snackbar(
    "Success!", // title
    "Your profile was updated successfully.", // message
    snackPosition: SnackPosition.BOTTOM
  );
}
```

**What happens?**
When `showSuccessMessage()` is called, GetX will display a snackbar at the bottom of the current screen with the title "Success!" and the given message. Notice you didn't need to pass any `BuildContext`!

### 2. Navigating to a New Screen

Want to open a new page?

```dart
import 'package:flutter/material.dart';
import 'package:get/get.dart';

class HomeScreen extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(title: Text("Home")),
      body: Center(
        child: ElevatedButton(
          onPressed: () {
            Get.to(DetailScreen()); // Navigate to DetailScreen
          },
          child: Text("Go to Details"),
        ),
      ),
    );
  }
}

class DetailScreen extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(title: Text("Details")),
      body: Center(
        child: ElevatedButton(
          onPressed: () {
            Get.back(); // Go back to the previous screen
          },
          child: Text("Go Back"),
        ),
      ),
    );
  }
}
```
**What happens?**
*   Tapping the "Go to Details" button on `HomeScreen` will push `DetailScreen` onto the navigation stack, making it visible.
*   Tapping the "Go Back" button on `DetailScreen` will pop it from the stack, revealing `HomeScreen` again.

Again, simple and no `BuildContext` needed for `Get.to()` or `Get.back()`. (Note: To use GetX navigation, your main app widget should be `GetMaterialApp` instead of `MaterialApp`).

### 3. Basic Dependency Management (Service Locator)

Imagine you have a class that manages user preferences:

```dart
class UserPreferencesService {
  bool _isDarkMode = false;

  bool get isDarkMode => _isDarkMode;

  void toggleDarkMode() {
    _isDarkMode = !_isDarkMode;
    print("Dark mode is now: $_isDarkMode");
    // In a real app, you'd save this preference
  }
}
```

You can "register" an instance of this service with GetX using `Get.put()`:

```dart
// Usually done at app startup or in a specific setup area
void initializeServices() {
  Get.put(UserPreferencesService());
  print("UserPreferencesService registered!");
}
```

Later, from anywhere in your app, you can retrieve this instance using `Get.find()`:

```dart
// ... in some widget or controller
void onThemeToggleButtonPressed() {
  final prefsService = Get.find<UserPreferencesService>();
  prefsService.toggleDarkMode();
  // You might then update your UI based on prefsService.isDarkMode
}
```

**What happens?**
*   `Get.put(UserPreferencesService());` creates an instance of `UserPreferencesService` and stores it in a global container managed by GetX.
*   `Get.find<UserPreferencesService>();` looks up and returns that stored instance.

This allows you to easily access shared services without passing instances around manually or using complex InheritedWidgets. We'll dive much deeper into dependency management in [Chapter 6: Dependency Access (Binder, Bind.of, Get.find/put)](06_dependency_access__binder__bind_of__get_find_put__.md).

## Under the Hood: How Does `Get` Work?

You might be wondering how `Get` can perform these actions, especially UI-related ones like showing snackbars, without `BuildContext`.

At its core, `Get` is a cleverly designed global static instance. When you use GetX (typically by wrapping your app with `GetMaterialApp`), GetX sets up the necessary infrastructure.

Here's a simplified conceptual flow for showing a snackbar:

```mermaid
sequenceDiagram
    participant YourCode as Your App Code
    participant Get as Get Object
    participant GetXCore as GetX Internal Logic
    participant FlutterFramework as Flutter Framework

    YourCode->>Get: Calls Get.snackbar("Title", "Message")
    Get->>GetXCore: Forwards request to internal snackbar logic
    GetXCore->>FlutterFramework: Uses Flutter's Overlay (or similar) to display UI
    FlutterFramework-->>YourCode: Snackbar appears on screen
```

**1. The `Get` Object Itself:**
The `Get` object you use is actually a global instance of a class. This is defined very simply in the GetX core:

```dart
// From: get_core/src/get_main.dart

// (_GetImpl is a class that implements GetInterface,
// where all the actual methods are defined or extended)
class _GetImpl extends GetInterface {}

// This creates a single, globally accessible instance named 'Get'
// ignore: non_constant_identifier_names
final Get = _GetImpl();
```
This `Get` variable is what you're accessing when you type `Get.something()`.

**2. `GetInterface` and Extensions:**
The `_GetImpl` class extends `GetInterface`.
```dart
// From: get_core/src/get_interface.dart
abstract class GetInterface {
  // Basic configurations like smartManagement and logging
  SmartManagement smartManagement = SmartManagement.full;
  bool isLogEnable = kDebugMode;
  LogWriterCallback log = defaultLogWriterCallback;
  // ... other core properties might be declared here
}
```
Many of GetX's functionalities (like `Get.to`, `Get.snackbar`, `Get.put`, `Get.find`) are added to this `GetInterface` through Dart's extension methods or are mixed into `_GetImpl`. These extensions contain the actual logic. For example, the navigation methods know how to find the `Navigator` provided by `GetMaterialApp`, and the snackbar methods know how to tap into Flutter's `Overlay` to display UI elements globally.

**3. For Dependency Management (`Get.put` / `Get.find`):**
When you use `Get.put(MyService())`, GetX stores this `MyService` instance in an internal data structure (like a map), often an_instance manager. When you later call `Get.find<MyService>()`, GetX looks up `MyService` in this internal storage by its type (and optionally by a tag) and returns the stored instance. We'll cover the `InstanceManager` in more detail in [Chapter 6: Dependency Access (Binder, Bind.of, Get.find/put)](06_dependency_access__binder__bind_of__get_find_put__.md).

The key takeaway is that `Get` acts as a **facade**  a simplified, unified interface to a more complex underlying system. It hides the complexities of interacting directly with Flutter's deeper systems or managing global instances, providing you with clean, easy-to-use static methods.

## Conclusion

You've now met `Get`, your go-to helper for many common tasks in GetX. It's a powerful yet simple facade that provides global access to navigation, UI utilities, dependency management, and more, often without the need for `BuildContext`. This keeps your code clean and makes development faster.

As you continue your GetX journey, you'll see `Get` being used in various contexts. Understanding its role as a global access point is key to mastering GetX.

In the next chapter, we'll explore a core GetX concept for making your application's data dynamic and responsive: [Rx<T> (Reactive Variables)](02_rx_t___reactive_variables__.md).
---
# Chapter 2: Rx<T> (Reactive Variables)

Welcome to Chapter 2! In [Chapter 1: Get (Global Access Facade)](01_get__global_access_facade__.md), we learned how the `Get` object acts as a handy "universal remote" for common app tasks. Now, we're going to dive into one of the most exciting features of GetX: making your app's data "reactive."

## What's the Big Deal with "Reactive"?

Imagine you're building an app that shows a user's score. When the score changes, you want the text on the screen displaying that score to update *automatically*, without you having to write a lot of complicated code to manually refresh the screen. This "automatic updating" is what reactive programming is all about.

`Rx<T>` variables are GetX's way of achieving this magic.

## Introducing `Rx<T>`: Your Magic Whiteboard

`Rx<T>` types (like `RxInt`, `RxString`, or pretty much anything you see ending with `.obs`) represent variables that can be "observed."

Think of an `Rx<T>` variable as a special number (or text, or any data) written on a **magic whiteboard**:
*   You write your initial data on this whiteboard (e.g., the number `0`).
*   Whenever someone erases the number and writes a new one (e.g., changes it to `1`), a bell automatically rings!
*   Anyone (or any part of your app's UI) specifically "watching" that number on the whiteboard instantly sees the change and reacts to it.

These `Rx<T>` variables are the heart of GetX's reactive programming. They allow your User Interface (UI), especially when used with widgets like `Obx` (which we'll cover in the [next chapter](03_obx___obxwidget_.md)), to automatically update whenever the underlying data changes.

The `T` in `Rx<T>` is a placeholder for the type of data the variable will hold, like `int`, `String`, `bool`, or even your own custom classes.

## How to Create and Use Reactive Variables

Let's see how to create and use these "magic" variables. The most common way is by using the `.obs` extension on a standard Dart value.

### 1. Creating a Reactive Variable

To make a regular variable reactive, you simply add `.obs` to its initial value.

**For a number (integer):**

```dart
import 'package:get/get.dart'; // Don't forget to import GetX

final count = 0.obs; // This is now an RxInt holding 0
// You could also write: final count = RxInt(0);
```
Here, `count` isn't just a regular `int`. It's now a special `RxInt` object that holds the integer value `0` and can notify others when it changes.

**For text (string):**

```dart
final userName = "Guest".obs; // This is an RxString holding "Guest"
// You could also write: final userName = RxString("Guest");
```
Similarly, `userName` is an `RxString`.

**For a boolean (true/false):**

```dart
final isLoggedIn = false.obs; // This is an RxBool holding false
// You could also write: final isLoggedIn = RxBool(false);
```

### 2. Getting the Value

If `count` is an `RxInt`, how do you get the actual integer value out of it? You use the `.value` property.

```dart
final count = 0.obs;
print(count.value); // Output: 0

final userName = "Guest".obs;
print(userName.value); // Output: Guest
```
Think of `.value` as looking at the magic whiteboard to read what's currently written on it.

### 3. Changing the Value (and Ringing the Bell!)

To change the value of a reactive variable, you also assign a new value to its `.value` property. This is the action that "rings the bell."

```dart
final count = 0.obs;
print("Initial count: ${count.value}"); // Output: Initial count: 0

count.value = 5; // You changed the number on the whiteboard!
print("New count: ${count.value}"); // Output: New count: 5
```
When you do `count.value = 5;`, the `count` variable not only updates its internal number but also sends out a notification that its value has changed.

You can also change the value by calling the `Rx` variable like a function:
```dart
final anotherCount = 10.obs;
anotherCount(15); // Same as anotherCount.value = 15;
print(anotherCount.value); // Output: 15
```
This is just a shorthand. Both ways achieve the same result.

### A Simple Example: The Counter Logic

Let's imagine the logic for a simple counter. We won't build the UI yet, just the data part.

```dart
import 'package:get/get.dart';

// 1. Create a reactive variable for our count
final magicCounter = 0.obs;

void incrementCounter() {
  // 2. Change its value
  magicCounter.value++; // This rings the bell!
  print("Counter is now: ${magicCounter.value}");
}

void main() {
  print("Counter starts at: ${magicCounter.value}");
  incrementCounter(); // Call the function to change the value
  incrementCounter();
}
```
**What happens?**
1.  `magicCounter` is created as an `RxInt` initialized to `0`.
2.  When `incrementCounter()` is called, `magicCounter.value++` increases the stored integer and notifies any listeners.
3.  The `print` statement shows the updated value.

Output:
```
Counter starts at: 0
Counter is now: 1
Counter is now: 2
```
Right now, only our `print` statements are "listening" in a very basic way. In the [next chapter](03_obx___obxwidget_.md), we'll see how to make Flutter UI widgets listen and update automatically!

## Under the Hood: How Does `.obs` Work?

You might wonder what `.obs` actually does. It's a clever use of Dart's "extension methods."

When you write `0.obs`, GetX has an extension on the `int` type that looks something like this (simplified):

```dart
// From: get_rx/src/rx_types/rx_core/rx_impl.dart (simplified concept)
extension IntExtension on int {
  RxInt get obs => RxInt(this); // 'this' refers to the integer itself
}
```
This code basically says: "If you see `.obs` after an integer, create a new `RxInt` object and give it that integer's value." Similar extensions exist for `String`, `bool`, `double`, and even a generic `Rx<T>` for any object via `T.obs`.

The `RxInt`, `RxString`, etc., classes (which generally inherit from `_RxImpl<T>`) are special classes that manage an internal value and have a built-in mechanism to notify listeners.

Here's a simplified step-by-step of what happens when you change an `Rx` variable's value:

```mermaid
sequenceDiagram
    participant YourCode as Your App Code
    participant RxVariable as count (RxInt)
    participant RxImpl as Internal Logic (_RxImpl)
    participant Listeners as Potential UI (e.g., Obx)

    YourCode->>RxVariable: count.value = 1
    Note over RxVariable: This calls the 'set value' logic
    RxVariable->>RxImpl: Pass new value (1)
    RxImpl->>RxImpl: Store new value (1) internally
    RxImpl->>RxImpl: Check: Has value actually changed?
    alt Value Changed
        RxImpl-->>Listeners: Notifies all listeners (rings the bell!)
        Listeners-->>RxVariable: (Later) Asks RxVariable for its new .value
    end
```

1.  **You assign to `.value`**: `count.value = 1;`
2.  **Setter is called**: The `RxInt` class (or its parent `_RxImpl` found in `get_rx/src/rx_types/rx_core/rx_impl.dart`) has a special `set value(newValue)` method.
3.  **Value Check**: This setter first checks if the `newValue` is actually different from the current stored value. If it's the same, it usually does nothing to avoid unnecessary notifications.
4.  **Store New Value**: If the value is different, it updates its internal storage.
5.  **Notify Listeners**: This is the magic part! The class then triggers a notification. Internally, it often uses a `StreamController` (from `dart:async`). When you change `.value`, it essentially adds the new value to its stream using something like `subject.add(newValue)` after updating its internal `_value`.
    ```dart
    // Highly simplified concept from RxObjectMixin in get_rx/src/rx_types/rx_core/rx_impl.dart
    // and GetListenable in get_state_manager/src/rx_flutter/rx_notifier.dart

    // In GetListenable:
    // StreamController<T>? _controller;
    // T _value;
    // void refresh() { _controller?.add(_value); }

    // In RxObjectMixin (which uses GetListenable):
    set value(T val) {
      if (_value == val && !firstRebuild) return; // _value is from GetListenable
      firstRebuild = false;
      super.value = val; // This typically calls GetListenable's setter, which then calls refresh()
                         // `super.value = val;` roughly does:_value = val; refresh();
    }
    ```
    The `super.value = val;` line in `RxObjectMixin`'s setter calls the setter in its parent class (`GetListenable`), which updates the internal `_value` and then calls `refresh()`. The `refresh()` method then typically adds the new value to an internal stream (`_controller?.add(_value);`), effectively "ringing the bell."

Any widget designed to listen to these streams (like `Obx`) will then pick up this notification.

## Different Kinds of Rx Variables

GetX provides several pre-built `Rx` types for convenience:

*   **Primitives:**
    *   `RxInt(initialValue)` or `initialValue.obs` for integers.
    *   `RxDouble(initialValue)` or `initialValue.obs` for doubles.
    *   `RxString(initialValue)` or `initialValue.obs` for strings.
    *   `RxBool(initialValue)` or `initialValue.obs` for booleans.
*   **Collections (these are a bit more advanced as they react to internal changes too):**
    *   `RxList<T>([])` or `[].obs` for lists.
    *   `RxMap<K, V>({})` or `{}.obs` for maps.
    *   `RxSet<T>({})` or `{}.obs` for sets.
*   **Generic `Rx<T>`:**
    *   For any other type, including your custom classes:
        ```dart
        class User {
          String name;
          User(this.name);
        }

        final user = User("Alice").obs; // user is now an Rx<User>
        // or: final user = Rx<User>(User("Alice"));

        print(user.value.name); // Output: Alice
        user.value.name = "Bob";
        user.refresh(); // For complex objects, you might need to call refresh()
                        // or use user.update((val) { val.name = "Bob"; });
                        // to ensure listeners are notified of internal changes.
        print(user.value.name); // Output: Bob
        ```
    For changes *inside* a custom object held by `Rx<T>`, like changing `user.value.name`, GetX might not automatically know the object's internal state changed. In such cases, you can call `user.refresh()` to manually trigger the "bell," or use the `update()` method: `user.update((currentUser) { currentUser.name = "Bob"; });` which handles the refresh for you.

## Conclusion

You've now learned about `Rx<T>` variables  the "magic whiteboards" of GetX! They are special variables, easily created with `.obs`, that automatically notify anyone interested when their `.value` changes. This is the foundation of reactive programming in GetX and is crucial for building UIs that update themselves effortlessly.

These reactive variables are often managed within [GetxController](05_getxcontroller_.md) classes (which we'll cover later), making state management clean and powerful.

In the [next chapter, Chapter 3: Obx / ObxWidget](03_obx___obxwidget_.md), we'll see how to use `Obx` widgets to make your UI actually listen to these `Rx<T>` variables and update automatically when that magic bell rings!

Relevant Code Snippets (Code itself remains unchanged):
--- File: get_state_manager/src/simple/list_notifier.dart ---
import 'dart:collection';

import 'package:flutter/foundation.dart';

// This callback remove the listener on addListener function
typedef Disposer = void Function();

// replacing StateSetter, return if the Widget is mounted for extra validation.
// if it brings overhead the extra call,
typedef GetStateUpdate = void Function();

class ListNotifier extends Listenable
    with ListNotifierSingleMixin, ListNotifierGroupMixin {}

/// A Notifier with single listeners
class ListNotifierSingle = ListNotifier with ListNotifierSingleMixin;

/// A notifier with group of listeners identified by id
class ListNotifierGroup = ListNotifier with ListNotifierGroupMixin;

/// This mixin add to Listenable the addListener, removerListener and
/// containsListener implementation
mixin ListNotifierSingleMixin on Listenable {
  List<GetStateUpdate>? _updaters = <GetStateUpdate>[];

  // final int _version = 0;
  // final int _microtaskVersion = 0;

  @override
  Disposer addListener(GetStateUpdate listener) {
    assert(_debugAssertNotDisposed());
    _updaters!.add(listener);
    return () => _updaters!.remove(listener);
  }

  bool containsListener(GetStateUpdate listener) {
    return _updaters?.contains(listener) ?? false;
  }

  @override
  void removeListener(VoidCallback listener) {
    assert(_debugAssertNotDisposed());
    _updaters!.remove(listener);
  }

  @protected
  void refresh() {
    assert(_debugAssertNotDisposed());
    _notifyUpdate();
  }

  @protected
  void reportRead() {
    Notifier.instance.read(this);
  }

  @protected
  void reportAdd(VoidCallback disposer) {
    Notifier.instance.add(disposer);
  }

  void _notifyUpdate() {
    // if (_microtaskVersion == _version) {
    //   _microtaskVersion++;
    //   scheduleMicrotask(() {
    //     _version++;
    //     _microtaskVersion = _version;
    final list = _updaters?.toList() ?? [];

    for (var element in list) {
      element();
    }
    //   });
    // }
  }

  bool get isDisposed => _updaters == null;

  bool _debugAssertNotDisposed() {
    assert(() {
      if (isDisposed) {
        throw FlutterError('''A $runtimeType was used after being disposed.\n
'Once you have called dispose() on a $runtimeType, it can no longer be used.''');
      }
      return true;
    }());
    return true;
  }

  int get listenersLength {
    assert(_debugAssertNotDisposed());
    return _updaters!.length;
  }

  @mustCallSuper
  void dispose() {
    assert(_debugAssertNotDisposed());
    _updaters = null;
  }
}

mixin ListNotifierGroupMixin on Listenable {
  HashMap<Object?, ListNotifierSingleMixin>? _updatersGroupIds =
      HashMap<Object?, ListNotifierSingleMixin>();

  void _notifyGroupUpdate(Object id) {
    if (_updatersGroupIds!.containsKey(id)) {
      _updatersGroupIds![id]!._notifyUpdate();
    }
  }

  @protected
  void notifyGroupChildrens(Object id) {
    assert(_debugAssertNotDisposed());
    Notifier.instance.read(_updatersGroupIds![id]!);
  }

  bool containsId(Object id) {
    return _updatersGroupIds?.containsKey(id) ?? false;
  }

  @protected
  void refreshGroup(Object id) {
    assert(_debugAssertNotDisposed());
    _notifyGroupUpdate(id);
  }

  bool _debugAssertNotDisposed() {
    assert(() {
      if (_updatersGroupIds == null) {
        throw FlutterError('''A $runtimeType was used after being disposed.\n
'Once you have called dispose() on a $runtimeType, it can no longer be used.''');
      }
      return true;
    }());
    return true;
  }

  void removeListenerId(Object id, VoidCallback listener) {
    assert(_debugAssertNotDisposed());
    if (_updatersGroupIds!.containsKey(id)) {
      _updatersGroupIds![id]!.removeListener(listener);
    }
  }

  @mustCallSuper
  void dispose() {
    assert(_debugAssertNotDisposed());
    _updatersGroupIds?.forEach((key, value) => value.dispose());
    _updatersGroupIds = null;
  }

  Disposer addListenerId(Object? key, GetStateUpdate listener) {
    _updatersGroupIds![key] ??= ListNotifierSingle();
    return _updatersGroupIds![key]!.addListener(listener);
  }

  /// To dispose an [id] from future updates(), this ids are registered
  /// by `GetBuilder()` or similar, so is a way to unlink the state change with
  /// the Widget from the Controller.
  void disposeId(Object id) {
    _updatersGroupIds?[id]?.dispose();
    _updatersGroupIds!.remove(id);
  }
}

class Notifier {
  Notifier._();

  static Notifier? _instance;
  static Notifier get instance => _instance ??= Notifier._();

  NotifyData? _notifyData;

  void add(VoidCallback listener) {
    _notifyData?.disposers.add(listener);
  }

  void read(ListNotifierSingleMixin updaters) {
    final listener = _notifyData?.updater;
    if (listener != null && !updaters.containsListener(listener)) {
      updaters.addListener(listener);
      add(() => updaters.removeListener(listener));
    }
  }

  T append<T>(NotifyData data, T Function() builder) {
    _notifyData = data;
    final result = builder();
    if (data.disposers.isEmpty && data.throwException) {
      throw const ObxError();
    }
    _notifyData = null;
    return result;
  }
}

class NotifyData {
  const NotifyData(
      {required this.updater,
      required this.disposers,
      this.throwException = true});
  final GetStateUpdate updater;
  final List<VoidCallback> disposers;
  final bool throwException;
}

class ObxError {
  const ObxError();
  @override
  String toString() {
    return """
      [Get] the improper use of a GetX has been detected. 
      You should only use GetX or Obx for the specific widget that will be updated.
      If you are seeing this error, you probably did not insert any observable variables into GetX/Obx 
      or insert them outside the scope that GetX considers suitable for an update 
      (example: GetX => HeavyWidget => variableObservable).
      If you need to update a parent widget and a child widget, wrap each one in an Obx/GetX.
      """;
  }
}


--- File: get_state_manager/src/simple/simple_builder.dart ---
import 'dart:async';

import 'package:flutter/widgets.dart';

import 'list_notifier.dart';

typedef ValueBuilderUpdateCallback<T> = void Function(T snapshot);
typedef ValueBuilderBuilder<T> = Widget Function(
    T snapshot, ValueBuilderUpdateCallback<T> updater);

/// Manages a local state like ObxValue, but uses a callback instead of
/// a Rx value.
///
/// Example:
/// ```
///  ValueBuilder<bool>(
///    initialValue: false,
///    builder: (value, update) => Switch(
///    value: value,
///    onChanged: (flag) {
///       update( flag );
///    },),
///    onUpdate: (value) => print("Value updated: $value"),
///  ),
///  ```
class ValueBuilder<T> extends StatefulWidget {
  final T initialValue;
  final ValueBuilderBuilder<T> builder;
  final void Function()? onDispose;
  final void Function(T)? onUpdate;

  const ValueBuilder({
    super.key,
    required this.initialValue,
    this.onDispose,
    this.onUpdate,
    required this.builder,
  });

  @override
  ValueBuilderState<T> createState() => ValueBuilderState<T>();
}

class ValueBuilderState<T> extends State<ValueBuilder<T>> {
  late T value;
  @override
  void initState() {
    value = widget.initialValue;
    super.initState();
  }

  @override
  Widget build(BuildContext context) => widget.builder(value, updater);

  void updater(T newValue) {
    if (widget.onUpdate != null) {
      widget.onUpdate!(newValue);
    }
    setState(() {
      value = newValue;
    });
  }

  @override
  void dispose() {
    super.dispose();
    widget.onDispose?.call();
    if (value is ChangeNotifier) {
      (value as ChangeNotifier?)?.dispose();
    } else if (value is StreamController) {
      (value as StreamController?)?.close();
    }
  }
}

class ObxElement = StatelessElement with StatelessObserverComponent;

// It's a experimental feature
class Observer extends ObxStatelessWidget {
  final WidgetBuilder builder;

  const Observer({super.key, required this.builder});

  @override
  Widget build(BuildContext context) => builder(context);
}

/// A StatelessWidget than can listen reactive changes.
abstract class ObxStatelessWidget extends StatelessWidget {
  /// Initializes [key] for subclasses.
  const ObxStatelessWidget({super.key});
  @override
  StatelessElement createElement() => ObxElement(this);
}

/// a Component that can track changes in a reactive variable
mixin StatelessObserverComponent on StatelessElement {
  List<Disposer>? disposers = <Disposer>[];

  void getUpdate() {
    // if (disposers != null && !dirty) {
    //   markNeedsBuild();
    // }
    if (disposers != null) {
      scheduleMicrotask(markNeedsBuild);
    }
  }

  @override
  Widget build() {
    return Notifier.instance.append(
        NotifyData(disposers: disposers!, updater: getUpdate), super.build);
  }

  @override
  void unmount() {
    super.unmount();
    for (final disposer in disposers!) {
      disposer();
    }
    disposers!.clear();
    disposers = null;
  }
}


--- File: get_state_manager/src/rx_flutter/rx_obx_widget.dart ---
import 'package:flutter/widgets.dart';

import '../../../get_rx/src/rx_types/rx_types.dart';
import '../simple/simple_builder.dart';

typedef WidgetCallback = Widget Function();

/// The [ObxWidget] is the base for all GetX reactive widgets
///
/// See also:
/// - [Obx]
/// - [ObxValue]
abstract class ObxWidget extends ObxStatelessWidget {
  const ObxWidget({super.key});
}

/// The simplest reactive widget in GetX.
///
/// Just pass your Rx variable in the root scope of the callback to have it
/// automatically registered for changes.
///
/// final _name = "GetX".obs;
/// Obx(() => Text( _name.value )),... ;
class Obx extends ObxWidget {
  final WidgetCallback builder;

  const Obx(this.builder, {super.key});

  @override
  Widget build(BuildContext context) {
    return builder();
  }
}

/// Similar to Obx, but manages a local state.
/// Pass the initial data in constructor.
/// Useful for simple local states, like toggles, visibility, themes,
/// button states, etc.
///  Sample:
///    ObxValue((data) => Switch(
///      value: data.value,
///      onChanged: (flag) => data.value = flag,
///    ),
///    false.obs,
///   ),
class ObxValue<T extends RxInterface> extends ObxWidget {
  final Widget Function(T) builder;
  final T data;

  const ObxValue(this.builder, this.data, {super.key});

  @override
  Widget build(BuildContext context) => builder(data);
}


Instructions for the chapter (Generate content in English unless specified otherwise):
- Start with a clear heading (e.g., `# Chapter 3: Obx / ObxWidget
`). Use the provided concept name.

- If this is not the first chapter, begin with a brief transition from the previous chapter, referencing it with a proper Markdown link using its name.

- Begin with a high-level motivation explaining what problem this abstraction solves. Start with a central use case as a concrete example. The whole chapter should guide the reader to understand how to solve this use case. Make it very minimal and friendly to beginners.

- If the abstraction is complex, break it down into key concepts. Explain each concept one-by-one in a very beginner-friendly way.

- Explain how to use this abstraction to solve the use case. Give example inputs and outputs for code snippets (if the output isn't values, describe at a high level what will happen).

- Each code block should be BELOW 10 lines! If longer code blocks are needed, break them down into smaller pieces and walk through them one-by-one. Aggresively simplify the code to make it minimal. Use comments to skip non-important implementation details. Each code block should have a beginner friendly explanation right after it.

- Describe the internal implementation to help understand what's under the hood. First provide a non-code or code-light walkthrough on what happens step-by-step when the abstraction is called. It's recommended to use a simple sequenceDiagram with a dummy example - keep it minimal with at most 5 participants to ensure clarity. If participant name has space, use: `participant QP as Query Processing`. .

- Then dive deeper into code for the internal implementation with references to files. Provide example code blocks, but make them similarly simple and beginner-friendly. Explain.

- IMPORTANT: When you need to refer to other core abstractions covered in other chapters, ALWAYS use proper Markdown links like this: [Chapter Title](filename.md). Use the Complete Tutorial Structure above to find the correct filename and the chapter title. Translate the surrounding text.

- Use mermaid diagrams to illustrate complex concepts (```mermaid``` format). .

- Heavily use analogies and examples throughout to help beginners understand.

- End the chapter with a brief conclusion that summarizes what was learned and provides a transition to the next chapter. If there is a next chapter, use a proper Markdown link: [Next Chapter Title](next_chapter_filename).

- Ensure the tone is welcoming and easy for a newcomer to understand.

- Output *only* the Markdown content for this chapter.

Now, directly provide a super beginner-friendly Markdown output (DON'T need ```markdown``` tags):

2025-05-12 13:34:09,249 - INFO - RESPONSE: # Chapter 3: Obx / ObxWidget

In [Chapter 2: Rx<T> (Reactive Variables)](02_rx_t___reactive_variables__.md), we discovered `Rx<T>` variables, our "magic whiteboards" that can signal when their data changes. That's fantastic for managing data, but how do we make our app's screen (the User Interface or UI) automatically show these changes?

Imagine you have a score in your game, stored in an `RxInt`. When the score increases, you want the score display on the screen to update instantly, without you having to write complex code to manually refresh it. This is where `Obx` comes in!

## Meet `Obx`: The Smart Picture Frame for Your UI

`Obx` (and its underlying base, `ObxWidget`) is a special Flutter widget provided by GetX. Its job is simple but powerful: it "watches" any reactive variables (`Rx<T>`) you use inside it and automatically rebuilds itself to show the new data whenever those variables change.

Remember our "magic whiteboard" (`Rx<T>`) from the last chapter?
Think of `Obx` as a **smart digital picture frame** that's wirelessly connected to that whiteboard.
*   You tell the `Obx` frame which part of the whiteboard to display (e.g., the score).
*   Whenever someone updates the score on the whiteboard (`Rx<T>` variable changes), the `Obx` frame *instantly* gets the new score and displays it.

This means your UI stays perfectly in sync with your app's state, efficiently and with very little code.

## How to Use `Obx`

Using `Obx` is wonderfully straightforward. You wrap the part of your UI that depends on a reactive variable with an `Obx` widget.

Let's build a very simple counter app to see it in action.

### 1. First, We Need a Reactive Variable

As we learned in [Chapter 2: Rx<T> (Reactive Variables)](02_rx_t___reactive_variables__.md), we create a reactive variable using `.obs`. Let's make a counter:

```dart
import 'package:get/get.dart'; // For .obs and Obx

final counter = 0.obs; // Our reactive integer, starting at 0
```
This `counter` is our "magic whiteboard" that will hold the current count.

### 2. Use `Obx` to Display the Reactive Variable

Now, let's use the `Obx` widget to display the value of `counter`. `Obx` takes a builder function. This function should return the widget(s) that depend on your reactive data.

Crucially, you **must** access the `.value` of your `Rx` variable *inside* this builder function for `Obx` to know which variable to watch.

```dart
// Inside your widget's build method:
Obx(() {
  // This Text widget will rebuild whenever 'counter.value' changes
  return Text("Button presses: ${counter.value}");
})
```
Here, `Obx` is our "smart picture frame." The builder function `() { return Text(...); }` tells the frame *what* to display. Because we used `counter.value` inside it, `Obx` knows to watch the `counter` variable.

### 3. Putting It All Together: A Simple Reactive Page

Let's see a complete, minimal example. We'll have a text display for the counter and a button to increment it.

```dart
import 'package:flutter/material.dart';
import 'package:get/get.dart';

// 1. Our reactive variable (could be in a GetxController later)
final counter = 0.obs;

class CounterPage extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(title: Text("Obx Counter Demo")),
      body: Center(
        // 2. Use Obx to wrap the widget that displays reactive data
        child: Obx(() {
          return Text(
            "Count: ${counter.value}", // Access .value here!
            style: TextStyle(fontSize: 28),
          );
        }),
      ),
      floatingActionButton: FloatingActionButton(
        onPressed: () {
          // 3. Change the reactive variable's value
          counter.value++;
        },
        child: Icon(Icons.add),
      ),
    );
  }
}
```

**What happens?**

1.  The page loads, `counter.value` is `0`. The `Obx` widget runs its builder function for the first time, and `Text("Count: 0")` is displayed.
2.  You tap the `+` button.
3.  The `onPressed` callback executes: `counter.value++`.
    *   The value of `counter` changes (e.g., from `0` to `1`).
    *   Because `counter` is an `RxInt` (a "magic whiteboard"), it "rings a bell," notifying its listeners that it has changed.
4.  The `Obx` widget, being a "smart picture frame" listening to `counter`, hears this bell!
5.  `Obx` automatically re-runs its builder function: `() { return Text("Count: ${counter.value}"); }`.
6.  This time, `counter.value` is `1`, so a new `Text("Count: 1")` widget is created and displayed.

The UI updates automatically, just like magic! You didn't have to call `setState()` or manually tell the UI to refresh.

### Important: Only Use Rx Variables *Inside* `Obx`'s Builder

`Obx` is smart, but it's not a mind reader. It only knows to rebuild if a reactive variable *that it has been told to observe* changes. It figures this out by tracking which reactive variables have their `.value` accessed *directly within its builder function*.

```dart
// GOOD: 'name.value' is inside Obx's builder
final name = "User".obs;
Obx(() => Text(name.value))

// BAD: If 'name.value' is not accessed inside, Obx won't react.
// (This would likely throw an ObxError if no other Rx var is accessed)
final name = "User".obs;
String currentName = name.value; // Accessed outside Obx's scope of observation
Obx(() => Text(currentName)) // Obx doesn't know about 'name' here
```

If you use an `Obx` widget and don't access any `.value` of an `Rx` variable inside its builder, GetX will usually show you an `ObxError` in the console, reminding you that `Obx` isn't observing anything.

```
[Get] the improper use of a GetX has been detected.
You should only use GetX or Obx for the specific widget that will be updated.
If you are seeing this error, you probably did not insert any observable variables into GetX/Obx...
```
This error message comes from the `ObxError` class defined in `get_state_manager/src/simple/list_notifier.dart`.

## Under the Hood: How Does `Obx` Work Its Magic?

It might seem like magic, but it's clever programming. Here's a simplified idea:

1.  **Subscription:** When an `Obx` widget is built for the first time, it prepares to listen. As its builder function executes, any `RxVariable.value` you access signals back to the `Obx` (via an internal `Notifier` system) saying, "Hey, Obx, I'm being read here! Please listen to me for changes." The `Obx` widget then subscribes to that `RxVariable`.
2.  **Value Change:** You change an `RxVariable` (e.g., `counter.value++`).
3.  **Notification:** The `RxVariable` "rings its bell" and notifies all its subscribers (including our `Obx` widget) that its value has changed.
4.  **Rebuild:** The `Obx` widget, upon receiving this notification, knows it needs to update. It schedules a rebuild, which simply means it calls its builder function again. Because the builder function now gets the new value from the `RxVariable`, the UI updates.

Here's a visual representation:

```mermaid
sequenceDiagram
    participant UserAction as User Taps Button
    participant RxVariable as counter (RxInt)
    participant ObxWidget as Obx Widget
    participant FlutterEngine as Flutter Engine

    Note over ObxWidget, RxVariable: Initial build: Obx reads counter.value, subscribes to counter.
    UserAction->>RxVariable: counter.value++
    RxVariable->>RxVariable: Internal value updates
    RxVariable-->>ObxWidget: Notifies Obx about the change
    ObxWidget->>ObxWidget: Schedules its builder to re-run
    ObxWidget->>RxVariable: Reads new counter.value (e.g., 1)
    ObxWidget-->>FlutterEngine: Provides new UI (e.g., Text("Count: 1"))
    FlutterEngine-->>UserAction: UI Updates on Screen
```

Let's peek at some (simplified) relevant code snippets:

`Obx` itself is quite simple. It extends `ObxWidget` (which extends `ObxStatelessWidget`).
```dart
// From: get_state_manager/src/rx_flutter/rx_obx_widget.dart
class Obx extends ObxWidget {
  final WidgetCallback builder; // Your () => Widget function
  const Obx(this.builder, {super.key});

  @override
  Widget build(BuildContext context) {
    return builder(); // It just calls your function!
  }
}
```
The real magic happens in `ObxStatelessWidget` and its `ObxElement`, which uses a mixin called `StatelessObserverComponent` (from `get_state_manager/src/simple/simple_builder.dart`).

```dart
// From: get_state_manager/src/simple/simple_builder.dart (simplified)
mixin StatelessObserverComponent on StatelessElement {
  List<Disposer>? disposers = <Disposer>[]; // To store cleanup functions

  void getUpdate() {
    // If I'm told to update, I tell Flutter to rebuild me!
    scheduleMicrotask(markNeedsBuild);
  }

  @override
  Widget build() {
    // Before calling the user's Obx builder (super.build),
    // set up the Notifier to catch Rx reads.
    return Notifier.instance.append(
        NotifyData(disposers: disposers!, updater: getUpdate),
        super.build // This eventually calls your Obx(() => Text(...))
    );
  }

  @override
  void unmount() { // When Obx is removed from the screen
    super.unmount();
    for (final disposer in disposers!) {
      disposer(); // Clean up subscriptions
    }
    disposers!.clear();
    disposers = null;
  }
}
```
When `yourRxVariable.value` is accessed *inside* the `Obx` builder (during `super.build` call above):
1.  The `Rx` variable's getter calls `reportRead()`. This method is mixed into `Rx` types from `ListNotifierSingleMixin` (in `get_state_manager/src/simple/list_notifier.dart`).
    ```dart
    // From: get_rx/src/rx_types/rx_core/rx_impl.dart (RxObjectMixin's value getter)
    // Simplified concept of what Rx's .value getter does
    T get value {
      reportRead(); // "I'm being read!"
      return _internalValue;
    }
    ```
2.  `reportRead()` calls `Notifier.instance.read(this)` (`this` refers to the `Rx` variable itself).
    ```dart
    // From: get_state_manager/src/simple/list_notifier.dart
    // (Inside ListNotifierSingleMixin)
    @protected
    void reportRead() {
      Notifier.instance.read(this);
    }
    ```
3.  `Notifier.instance.read()` checks the `_notifyData` that `StatelessObserverComponent.build()` set up. It finds the `getUpdate` method of our `Obx` widget and subscribes it to the `Rx` variable.
    ```dart
    // From: get_state_manager/src/simple/list_notifier.dart (Notifier class)
    void read(ListNotifierSingleMixin rxVariable) {
      final getStateUpdateFn = _notifyData?.updater; // This is Obx's getUpdate()
       // If Obx's getUpdate is available and not already listening to this rxVariable:
      if (getStateUpdateFn != null && !rxVariable.containsListener(getStateUpdateFn)) {
        // Tell rxVariable: "When you change, call Obx's getUpdate()"
        Disposer disposer = rxVariable.addListener(getStateUpdateFn);
        // And remember how to unsubscribe later
        _notifyData?.disposers.add(disposer);
      }
    }
    ```
So, when `RxVariable.value` changes later, it calls `refresh()` (from `ListNotifierSingleMixin`), which notifies its listeners. One of these listeners is the `Obx` widget's `getUpdate` method, causing the `Obx` widget to rebuild!

## What is `ObxWidget` then?

You'll mostly use `Obx`. `ObxWidget` is simply the base class that `Obx` (and `ObxValue`, another similar widget) extends. It provides the common reactive machinery. Advanced users could extend `ObxWidget` to create their own custom reactive widgets, but for most day-to-day tasks, `Obx` is all you need.

## Conclusion

You've now unlocked a cornerstone of GetX's reactivity: the `Obx` widget! It's your "smart picture frame" that automatically updates your UI when the underlying `Rx<T>` reactive variables change. This makes building dynamic and responsive UIs incredibly simple and efficient.

Typically, your `Rx<T>` variables will live inside a [GetxController](05_getxcontroller_.md) (which we'll cover soon) to keep your UI logic neatly organized. `Obx` then becomes the bridge that connects your controller's state to your visual widgets.

But what if you want to react to changes in `Rx<T>` variables *without* updating the UI? For example, maybe you want to log a message or make an API call when a value changes. For that, GetX provides something called "Workers." Let's explore those in the [next chapter, Chapter 4: Workers](04_workers_.md).
2025-05-12 13:34:09,305 - INFO - PROMPT: 
Write a very beginner-friendly tutorial chapter (in Markdown format) for the project `lib` about the concept: "Workers
". This is Chapter 4.

Concept Details:
- Name: Workers

- Description:
Workers (`ever`, `once`, `debounce`, `interval`) are functions that listen to `Rx` reactive variables
and execute a callback when certain conditions or events occur on those variables.
They are useful for performing side effects, like making an API call when a user ID changes,
or saving data after a user stops typing. Think of them as automated sentinels that watch
your reactive data streams and spring into action based on predefined rules, independent of direct UI rendering.


Complete Tutorial Structure:
1. [Get (Global Access Facade)
](01_get__global_access_facade__.md)
2. [Rx<T> (Reactive Variables)
](02_rx_t___reactive_variables__.md)
3. [Obx / ObxWidget
](03_obx___obxwidget_.md)
4. [Workers
](04_workers_.md)
5. [GetxController
](05_getxcontroller_.md)
6. [Dependency Access (Binder, Bind.of, Get.find/put)
](06_dependency_access__binder__bind_of__get_find_put__.md)
7. [GetBuilder
](07_getbuilder_.md)
8. [StateMixin
](08_statemixin_.md)
9. [ListNotifier (and Mixins)
](09_listnotifier__and_mixins__.md)

Context from previous chapters:
# Chapter 1: Get (Global Access Facade)

Welcome to your GetX journey! In this first chapter, we'll explore one of the most fundamental and frequently used parts of the GetX ecosystem: the `Get` object.

## What is `Get` and Why Do You Need It?

Imagine you're building a Flutter app. You often need to perform common tasks like:
*   Showing a quick message (a "snackbar") to the user.
*   Navigating to a new screen.
*   Accessing a shared service, like a settings manager, from various parts of your app.

Traditionally, in Flutter, many of these tasks require access to something called `BuildContext`. `BuildContext` tells Flutter "where" you are in your widget tree, which is necessary for operations like finding the nearest `Navigator` or `Scaffold`. Getting `BuildContext` to the exact spot where you need it can sometimes be cumbersome, especially in deeper parts of your app's logic that aren't directly part of a widget.

This is where `Get` comes to the rescue!

The `Get` object is your main entry point for most GetX features. Think of it as a **universal remote control** for your application. It provides super easy-to-use tools (called static methods) for:

*   **Dependency Management:** Storing and retrieving your app's services or "managers" (like a `UserSettingsManager` or `ApiService`).
*   **Navigation:** Moving between screens with simple commands.
*   **Showing UI Elements:** Displaying dialogs, snackbars, or bottom sheets.
*   ...and much more!

The beauty of `Get` is that it often lets you do these things **without needing `BuildContext`**, making your code cleaner and simplifying access to GetX functionalities from virtually anywhere in your app.

## How to Use `Get`

Using `Get` is incredibly straightforward because its methods are `static`. This means you don't need to create an instance of a `Get` class; you just type `Get.` followed by the feature you want to use.

Let's look at a few common use cases:

### 1. Showing a Snackbar

Need to show a quick notification to the user?

```dart
import 'package:get/get.dart'; // Make sure to import GetX

// ...somewhere in your code, even inside a business logic class
void showSuccessMessage() {
  Get.snackbar(
    "Success!", // title
    "Your profile was updated successfully.", // message
    snackPosition: SnackPosition.BOTTOM
  );
}
```

**What happens?**
When `showSuccessMessage()` is called, GetX will display a snackbar at the bottom of the current screen with the title "Success!" and the given message. Notice you didn't need to pass any `BuildContext`!

### 2. Navigating to a New Screen

Want to open a new page?

```dart
import 'package:flutter/material.dart';
import 'package:get/get.dart';

class HomeScreen extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(title: Text("Home")),
      body: Center(
        child: ElevatedButton(
          onPressed: () {
            Get.to(DetailScreen()); // Navigate to DetailScreen
          },
          child: Text("Go to Details"),
        ),
      ),
    );
  }
}

class DetailScreen extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(title: Text("Details")),
      body: Center(
        child: ElevatedButton(
          onPressed: () {
            Get.back(); // Go back to the previous screen
          },
          child: Text("Go Back"),
        ),
      ),
    );
  }
}
```
**What happens?**
*   Tapping the "Go to Details" button on `HomeScreen` will push `DetailScreen` onto the navigation stack, making it visible.
*   Tapping the "Go Back" button on `DetailScreen` will pop it from the stack, revealing `HomeScreen` again.

Again, simple and no `BuildContext` needed for `Get.to()` or `Get.back()`. (Note: To use GetX navigation, your main app widget should be `GetMaterialApp` instead of `MaterialApp`).

### 3. Basic Dependency Management (Service Locator)

Imagine you have a class that manages user preferences:

```dart
class UserPreferencesService {
  bool _isDarkMode = false;

  bool get isDarkMode => _isDarkMode;

  void toggleDarkMode() {
    _isDarkMode = !_isDarkMode;
    print("Dark mode is now: $_isDarkMode");
    // In a real app, you'd save this preference
  }
}
```

You can "register" an instance of this service with GetX using `Get.put()`:

```dart
// Usually done at app startup or in a specific setup area
void initializeServices() {
  Get.put(UserPreferencesService());
  print("UserPreferencesService registered!");
}
```

Later, from anywhere in your app, you can retrieve this instance using `Get.find()`:

```dart
// ... in some widget or controller
void onThemeToggleButtonPressed() {
  final prefsService = Get.find<UserPreferencesService>();
  prefsService.toggleDarkMode();
  // You might then update your UI based on prefsService.isDarkMode
}
```

**What happens?**
*   `Get.put(UserPreferencesService());` creates an instance of `UserPreferencesService` and stores it in a global container managed by GetX.
*   `Get.find<UserPreferencesService>();` looks up and returns that stored instance.

This allows you to easily access shared services without passing instances around manually or using complex InheritedWidgets. We'll dive much deeper into dependency management in [Chapter 6: Dependency Access (Binder, Bind.of, Get.find/put)](06_dependency_access__binder__bind_of__get_find_put__.md).

## Under the Hood: How Does `Get` Work?

You might be wondering how `Get` can perform these actions, especially UI-related ones like showing snackbars, without `BuildContext`.

At its core, `Get` is a cleverly designed global static instance. When you use GetX (typically by wrapping your app with `GetMaterialApp`), GetX sets up the necessary infrastructure.

Here's a simplified conceptual flow for showing a snackbar:

```mermaid
sequenceDiagram
    participant YourCode as Your App Code
    participant Get as Get Object
    participant GetXCore as GetX Internal Logic
    participant FlutterFramework as Flutter Framework

    YourCode->>Get: Calls Get.snackbar("Title", "Message")
    Get->>GetXCore: Forwards request to internal snackbar logic
    GetXCore->>FlutterFramework: Uses Flutter's Overlay (or similar) to display UI
    FlutterFramework-->>YourCode: Snackbar appears on screen
```

**1. The `Get` Object Itself:**
The `Get` object you use is actually a global instance of a class. This is defined very simply in the GetX core:

```dart
// From: get_core/src/get_main.dart

// (_GetImpl is a class that implements GetInterface,
// where all the actual methods are defined or extended)
class _GetImpl extends GetInterface {}

// This creates a single, globally accessible instance named 'Get'
// ignore: non_constant_identifier_names
final Get = _GetImpl();
```
This `Get` variable is what you're accessing when you type `Get.something()`.

**2. `GetInterface` and Extensions:**
The `_GetImpl` class extends `GetInterface`.
```dart
// From: get_core/src/get_interface.dart
abstract class GetInterface {
  // Basic configurations like smartManagement and logging
  SmartManagement smartManagement = SmartManagement.full;
  bool isLogEnable = kDebugMode;
  LogWriterCallback log = defaultLogWriterCallback;
  // ... other core properties might be declared here
}
```
Many of GetX's functionalities (like `Get.to`, `Get.snackbar`, `Get.put`, `Get.find`) are added to this `GetInterface` through Dart's extension methods or are mixed into `_GetImpl`. These extensions contain the actual logic. For example, the navigation methods know how to find the `Navigator` provided by `GetMaterialApp`, and the snackbar methods know how to tap into Flutter's `Overlay` to display UI elements globally.

**3. For Dependency Management (`Get.put` / `Get.find`):**
When you use `Get.put(MyService())`, GetX stores this `MyService` instance in an internal data structure (like a map), often an_instance manager. When you later call `Get.find<MyService>()`, GetX looks up `MyService` in this internal storage by its type (and optionally by a tag) and returns the stored instance. We'll cover the `InstanceManager` in more detail in [Chapter 6: Dependency Access (Binder, Bind.of, Get.find/put)](06_dependency_access__binder__bind_of__get_find_put__.md).

The key takeaway is that `Get` acts as a **facade**  a simplified, unified interface to a more complex underlying system. It hides the complexities of interacting directly with Flutter's deeper systems or managing global instances, providing you with clean, easy-to-use static methods.

## Conclusion

You've now met `Get`, your go-to helper for many common tasks in GetX. It's a powerful yet simple facade that provides global access to navigation, UI utilities, dependency management, and more, often without the need for `BuildContext`. This keeps your code clean and makes development faster.

As you continue your GetX journey, you'll see `Get` being used in various contexts. Understanding its role as a global access point is key to mastering GetX.

In the next chapter, we'll explore a core GetX concept for making your application's data dynamic and responsive: [Rx<T> (Reactive Variables)](02_rx_t___reactive_variables__.md).
---
# Chapter 2: Rx<T> (Reactive Variables)

Welcome to Chapter 2! In [Chapter 1: Get (Global Access Facade)](01_get__global_access_facade__.md), we learned how the `Get` object acts as a handy "universal remote" for common app tasks. Now, we're going to dive into one of the most exciting features of GetX: making your app's data "reactive."

## What's the Big Deal with "Reactive"?

Imagine you're building an app that shows a user's score. When the score changes, you want the text on the screen displaying that score to update *automatically*, without you having to write a lot of complicated code to manually refresh the screen. This "automatic updating" is what reactive programming is all about.

`Rx<T>` variables are GetX's way of achieving this magic.

## Introducing `Rx<T>`: Your Magic Whiteboard

`Rx<T>` types (like `RxInt`, `RxString`, or pretty much anything you see ending with `.obs`) represent variables that can be "observed."

Think of an `Rx<T>` variable as a special number (or text, or any data) written on a **magic whiteboard**:
*   You write your initial data on this whiteboard (e.g., the number `0`).
*   Whenever someone erases the number and writes a new one (e.g., changes it to `1`), a bell automatically rings!
*   Anyone (or any part of your app's UI) specifically "watching" that number on the whiteboard instantly sees the change and reacts to it.

These `Rx<T>` variables are the heart of GetX's reactive programming. They allow your User Interface (UI), especially when used with widgets like `Obx` (which we'll cover in the [next chapter](03_obx___obxwidget_.md)), to automatically update whenever the underlying data changes.

The `T` in `Rx<T>` is a placeholder for the type of data the variable will hold, like `int`, `String`, `bool`, or even your own custom classes.

## How to Create and Use Reactive Variables

Let's see how to create and use these "magic" variables. The most common way is by using the `.obs` extension on a standard Dart value.

### 1. Creating a Reactive Variable

To make a regular variable reactive, you simply add `.obs` to its initial value.

**For a number (integer):**

```dart
import 'package:get/get.dart'; // Don't forget to import GetX

final count = 0.obs; // This is now an RxInt holding 0
// You could also write: final count = RxInt(0);
```
Here, `count` isn't just a regular `int`. It's now a special `RxInt` object that holds the integer value `0` and can notify others when it changes.

**For text (string):**

```dart
final userName = "Guest".obs; // This is an RxString holding "Guest"
// You could also write: final userName = RxString("Guest");
```
Similarly, `userName` is an `RxString`.

**For a boolean (true/false):**

```dart
final isLoggedIn = false.obs; // This is an RxBool holding false
// You could also write: final isLoggedIn = RxBool(false);
```

### 2. Getting the Value

If `count` is an `RxInt`, how do you get the actual integer value out of it? You use the `.value` property.

```dart
final count = 0.obs;
print(count.value); // Output: 0

final userName = "Guest".obs;
print(userName.value); // Output: Guest
```
Think of `.value` as looking at the magic whiteboard to read what's currently written on it.

### 3. Changing the Value (and Ringing the Bell!)

To change the value of a reactive variable, you also assign a new value to its `.value` property. This is the action that "rings the bell."

```dart
final count = 0.obs;
print("Initial count: ${count.value}"); // Output: Initial count: 0

count.value = 5; // You changed the number on the whiteboard!
print("New count: ${count.value}"); // Output: New count: 5
```
When you do `count.value = 5;`, the `count` variable not only updates its internal number but also sends out a notification that its value has changed.

You can also change the value by calling the `Rx` variable like a function:
```dart
final anotherCount = 10.obs;
anotherCount(15); // Same as anotherCount.value = 15;
print(anotherCount.value); // Output: 15
```
This is just a shorthand. Both ways achieve the same result.

### A Simple Example: The Counter Logic

Let's imagine the logic for a simple counter. We won't build the UI yet, just the data part.

```dart
import 'package:get/get.dart';

// 1. Create a reactive variable for our count
final magicCounter = 0.obs;

void incrementCounter() {
  // 2. Change its value
  magicCounter.value++; // This rings the bell!
  print("Counter is now: ${magicCounter.value}");
}

void main() {
  print("Counter starts at: ${magicCounter.value}");
  incrementCounter(); // Call the function to change the value
  incrementCounter();
}
```
**What happens?**
1.  `magicCounter` is created as an `RxInt` initialized to `0`.
2.  When `incrementCounter()` is called, `magicCounter.value++` increases the stored integer and notifies any listeners.
3.  The `print` statement shows the updated value.

Output:
```
Counter starts at: 0
Counter is now: 1
Counter is now: 2
```
Right now, only our `print` statements are "listening" in a very basic way. In the [next chapter](03_obx___obxwidget_.md), we'll see how to make Flutter UI widgets listen and update automatically!

## Under the Hood: How Does `.obs` Work?

You might wonder what `.obs` actually does. It's a clever use of Dart's "extension methods."

When you write `0.obs`, GetX has an extension on the `int` type that looks something like this (simplified):

```dart
// From: get_rx/src/rx_types/rx_core/rx_impl.dart (simplified concept)
extension IntExtension on int {
  RxInt get obs => RxInt(this); // 'this' refers to the integer itself
}
```
This code basically says: "If you see `.obs` after an integer, create a new `RxInt` object and give it that integer's value." Similar extensions exist for `String`, `bool`, `double`, and even a generic `Rx<T>` for any object via `T.obs`.

The `RxInt`, `RxString`, etc., classes (which generally inherit from `_RxImpl<T>`) are special classes that manage an internal value and have a built-in mechanism to notify listeners.

Here's a simplified step-by-step of what happens when you change an `Rx` variable's value:

```mermaid
sequenceDiagram
    participant YourCode as Your App Code
    participant RxVariable as count (RxInt)
    participant RxImpl as Internal Logic (_RxImpl)
    participant Listeners as Potential UI (e.g., Obx)

    YourCode->>RxVariable: count.value = 1
    Note over RxVariable: This calls the 'set value' logic
    RxVariable->>RxImpl: Pass new value (1)
    RxImpl->>RxImpl: Store new value (1) internally
    RxImpl->>RxImpl: Check: Has value actually changed?
    alt Value Changed
        RxImpl-->>Listeners: Notifies all listeners (rings the bell!)
        Listeners-->>RxVariable: (Later) Asks RxVariable for its new .value
    end
```

1.  **You assign to `.value`**: `count.value = 1;`
2.  **Setter is called**: The `RxInt` class (or its parent `_RxImpl` found in `get_rx/src/rx_types/rx_core/rx_impl.dart`) has a special `set value(newValue)` method.
3.  **Value Check**: This setter first checks if the `newValue` is actually different from the current stored value. If it's the same, it usually does nothing to avoid unnecessary notifications.
4.  **Store New Value**: If the value is different, it updates its internal storage.
5.  **Notify Listeners**: This is the magic part! The class then triggers a notification. Internally, it often uses a `StreamController` (from `dart:async`). When you change `.value`, it essentially adds the new value to its stream using something like `subject.add(newValue)` after updating its internal `_value`.
    ```dart
    // Highly simplified concept from RxObjectMixin in get_rx/src/rx_types/rx_core/rx_impl.dart
    // and GetListenable in get_state_manager/src/rx_flutter/rx_notifier.dart

    // In GetListenable:
    // StreamController<T>? _controller;
    // T _value;
    // void refresh() { _controller?.add(_value); }

    // In RxObjectMixin (which uses GetListenable):
    set value(T val) {
      if (_value == val && !firstRebuild) return; // _value is from GetListenable
      firstRebuild = false;
      super.value = val; // This typically calls GetListenable's setter, which then calls refresh()
                         // `super.value = val;` roughly does:_value = val; refresh();
    }
    ```
    The `super.value = val;` line in `RxObjectMixin`'s setter calls the setter in its parent class (`GetListenable`), which updates the internal `_value` and then calls `refresh()`. The `refresh()` method then typically adds the new value to an internal stream (`_controller?.add(_value);`), effectively "ringing the bell."

Any widget designed to listen to these streams (like `Obx`) will then pick up this notification.

## Different Kinds of Rx Variables

GetX provides several pre-built `Rx` types for convenience:

*   **Primitives:**
    *   `RxInt(initialValue)` or `initialValue.obs` for integers.
    *   `RxDouble(initialValue)` or `initialValue.obs` for doubles.
    *   `RxString(initialValue)` or `initialValue.obs` for strings.
    *   `RxBool(initialValue)` or `initialValue.obs` for booleans.
*   **Collections (these are a bit more advanced as they react to internal changes too):**
    *   `RxList<T>([])` or `[].obs` for lists.
    *   `RxMap<K, V>({})` or `{}.obs` for maps.
    *   `RxSet<T>({})` or `{}.obs` for sets.
*   **Generic `Rx<T>`:**
    *   For any other type, including your custom classes:
        ```dart
        class User {
          String name;
          User(this.name);
        }

        final user = User("Alice").obs; // user is now an Rx<User>
        // or: final user = Rx<User>(User("Alice"));

        print(user.value.name); // Output: Alice
        user.value.name = "Bob";
        user.refresh(); // For complex objects, you might need to call refresh()
                        // or use user.update((val) { val.name = "Bob"; });
                        // to ensure listeners are notified of internal changes.
        print(user.value.name); // Output: Bob
        ```
    For changes *inside* a custom object held by `Rx<T>`, like changing `user.value.name`, GetX might not automatically know the object's internal state changed. In such cases, you can call `user.refresh()` to manually trigger the "bell," or use the `update()` method: `user.update((currentUser) { currentUser.name = "Bob"; });` which handles the refresh for you.

## Conclusion

You've now learned about `Rx<T>` variables  the "magic whiteboards" of GetX! They are special variables, easily created with `.obs`, that automatically notify anyone interested when their `.value` changes. This is the foundation of reactive programming in GetX and is crucial for building UIs that update themselves effortlessly.

These reactive variables are often managed within [GetxController](05_getxcontroller_.md) classes (which we'll cover later), making state management clean and powerful.

In the [next chapter, Chapter 3: Obx / ObxWidget](03_obx___obxwidget_.md), we'll see how to use `Obx` widgets to make your UI actually listen to these `Rx<T>` variables and update automatically when that magic bell rings!
---
# Chapter 3: Obx / ObxWidget

In [Chapter 2: Rx<T> (Reactive Variables)](02_rx_t___reactive_variables__.md), we discovered `Rx<T>` variables, our "magic whiteboards" that can signal when their data changes. That's fantastic for managing data, but how do we make our app's screen (the User Interface or UI) automatically show these changes?

Imagine you have a score in your game, stored in an `RxInt`. When the score increases, you want the score display on the screen to update instantly, without you having to write complex code to manually refresh it. This is where `Obx` comes in!

## Meet `Obx`: The Smart Picture Frame for Your UI

`Obx` (and its underlying base, `ObxWidget`) is a special Flutter widget provided by GetX. Its job is simple but powerful: it "watches" any reactive variables (`Rx<T>`) you use inside it and automatically rebuilds itself to show the new data whenever those variables change.

Remember our "magic whiteboard" (`Rx<T>`) from the last chapter?
Think of `Obx` as a **smart digital picture frame** that's wirelessly connected to that whiteboard.
*   You tell the `Obx` frame which part of the whiteboard to display (e.g., the score).
*   Whenever someone updates the score on the whiteboard (`Rx<T>` variable changes), the `Obx` frame *instantly* gets the new score and displays it.

This means your UI stays perfectly in sync with your app's state, efficiently and with very little code.

## How to Use `Obx`

Using `Obx` is wonderfully straightforward. You wrap the part of your UI that depends on a reactive variable with an `Obx` widget.

Let's build a very simple counter app to see it in action.

### 1. First, We Need a Reactive Variable

As we learned in [Chapter 2: Rx<T> (Reactive Variables)](02_rx_t___reactive_variables__.md), we create a reactive variable using `.obs`. Let's make a counter:

```dart
import 'package:get/get.dart'; // For .obs and Obx

final counter = 0.obs; // Our reactive integer, starting at 0
```
This `counter` is our "magic whiteboard" that will hold the current count.

### 2. Use `Obx` to Display the Reactive Variable

Now, let's use the `Obx` widget to display the value of `counter`. `Obx` takes a builder function. This function should return the widget(s) that depend on your reactive data.

Crucially, you **must** access the `.value` of your `Rx` variable *inside* this builder function for `Obx` to know which variable to watch.

```dart
// Inside your widget's build method:
Obx(() {
  // This Text widget will rebuild whenever 'counter.value' changes
  return Text("Button presses: ${counter.value}");
})
```
Here, `Obx` is our "smart picture frame." The builder function `() { return Text(...); }` tells the frame *what* to display. Because we used `counter.value` inside it, `Obx` knows to watch the `counter` variable.

### 3. Putting It All Together: A Simple Reactive Page

Let's see a complete, minimal example. We'll have a text display for the counter and a button to increment it.

```dart
import 'package:flutter/material.dart';
import 'package:get/get.dart';

// 1. Our reactive variable (could be in a GetxController later)
final counter = 0.obs;

class CounterPage extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(title: Text("Obx Counter Demo")),
      body: Center(
        // 2. Use Obx to wrap the widget that displays reactive data
        child: Obx(() {
          return Text(
            "Count: ${counter.value}", // Access .value here!
            style: TextStyle(fontSize: 28),
          );
        }),
      ),
      floatingActionButton: FloatingActionButton(
        onPressed: () {
          // 3. Change the reactive variable's value
          counter.value++;
        },
        child: Icon(Icons.add),
      ),
    );
  }
}
```

**What happens?**

1.  The page loads, `counter.value` is `0`. The `Obx` widget runs its builder function for the first time, and `Text("Count: 0")` is displayed.
2.  You tap the `+` button.
3.  The `onPressed` callback executes: `counter.value++`.
    *   The value of `counter` changes (e.g., from `0` to `1`).
    *   Because `counter` is an `RxInt` (a "magic whiteboard"), it "rings a bell," notifying its listeners that it has changed.
4.  The `Obx` widget, being a "smart picture frame" listening to `counter`, hears this bell!
5.  `Obx` automatically re-runs its builder function: `() { return Text("Count: ${counter.value}"); }`.
6.  This time, `counter.value` is `1`, so a new `Text("Count: 1")` widget is created and displayed.

The UI updates automatically, just like magic! You didn't have to call `setState()` or manually tell the UI to refresh.

### Important: Only Use Rx Variables *Inside* `Obx`'s Builder

`Obx` is smart, but it's not a mind reader. It only knows to rebuild if a reactive variable *that it has been told to observe* changes. It figures this out by tracking which reactive variables have their `.value` accessed *directly within its builder function*.

```dart
// GOOD: 'name.value' is inside Obx's builder
final name = "User".obs;
Obx(() => Text(name.value))

// BAD: If 'name.value' is not accessed inside, Obx won't react.
// (This would likely throw an ObxError if no other Rx var is accessed)
final name = "User".obs;
String currentName = name.value; // Accessed outside Obx's scope of observation
Obx(() => Text(currentName)) // Obx doesn't know about 'name' here
```

If you use an `Obx` widget and don't access any `.value` of an `Rx` variable inside its builder, GetX will usually show you an `ObxError` in the console, reminding you that `Obx` isn't observing anything.

```
[Get] the improper use of a GetX has been detected.
You should only use GetX or Obx for the specific widget that will be updated.
If you are seeing this error, you probably did not insert any observable variables into GetX/Obx...
```
This error message comes from the `ObxError` class defined in `get_state_manager/src/simple/list_notifier.dart`.

## Under the Hood: How Does `Obx` Work Its Magic?

It might seem like magic, but it's clever programming. Here's a simplified idea:

1.  **Subscription:** When an `Obx` widget is built for the first time, it prepares to listen. As its builder function executes, any `RxVariable.value` you access signals back to the `Obx` (via an internal `Notifier` system) saying, "Hey, Obx, I'm being read here! Please listen to me for changes." The `Obx` widget then subscribes to that `RxVariable`.
2.  **Value Change:** You change an `RxVariable` (e.g., `counter.value++`).
3.  **Notification:** The `RxVariable` "rings its bell" and notifies all its subscribers (including our `Obx` widget) that its value has changed.
4.  **Rebuild:** The `Obx` widget, upon receiving this notification, knows it needs to update. It schedules a rebuild, which simply means it calls its builder function again. Because the builder function now gets the new value from the `RxVariable`, the UI updates.

Here's a visual representation:

```mermaid
sequenceDiagram
    participant UserAction as User Taps Button
    participant RxVariable as counter (RxInt)
    participant ObxWidget as Obx Widget
    participant FlutterEngine as Flutter Engine

    Note over ObxWidget, RxVariable: Initial build: Obx reads counter.value, subscribes to counter.
    UserAction->>RxVariable: counter.value++
    RxVariable->>RxVariable: Internal value updates
    RxVariable-->>ObxWidget: Notifies Obx about the change
    ObxWidget->>ObxWidget: Schedules its builder to re-run
    ObxWidget->>RxVariable: Reads new counter.value (e.g., 1)
    ObxWidget-->>FlutterEngine: Provides new UI (e.g., Text("Count: 1"))
    FlutterEngine-->>UserAction: UI Updates on Screen
```

Let's peek at some (simplified) relevant code snippets:

`Obx` itself is quite simple. It extends `ObxWidget` (which extends `ObxStatelessWidget`).
```dart
// From: get_state_manager/src/rx_flutter/rx_obx_widget.dart
class Obx extends ObxWidget {
  final WidgetCallback builder; // Your () => Widget function
  const Obx(this.builder, {super.key});

  @override
  Widget build(BuildContext context) {
    return builder(); // It just calls your function!
  }
}
```
The real magic happens in `ObxStatelessWidget` and its `ObxElement`, which uses a mixin called `StatelessObserverComponent` (from `get_state_manager/src/simple/simple_builder.dart`).

```dart
// From: get_state_manager/src/simple/simple_builder.dart (simplified)
mixin StatelessObserverComponent on StatelessElement {
  List<Disposer>? disposers = <Disposer>[]; // To store cleanup functions

  void getUpdate() {
    // If I'm told to update, I tell Flutter to rebuild me!
    scheduleMicrotask(markNeedsBuild);
  }

  @override
  Widget build() {
    // Before calling the user's Obx builder (super.build),
    // set up the Notifier to catch Rx reads.
    return Notifier.instance.append(
        NotifyData(disposers: disposers!, updater: getUpdate),
        super.build // This eventually calls your Obx(() => Text(...))
    );
  }

  @override
  void unmount() { // When Obx is removed from the screen
    super.unmount();
    for (final disposer in disposers!) {
      disposer(); // Clean up subscriptions
    }
    disposers!.clear();
    disposers = null;
  }
}
```
When `yourRxVariable.value` is accessed *inside* the `Obx` builder (during `super.build` call above):
1.  The `Rx` variable's getter calls `reportRead()`. This method is mixed into `Rx` types from `ListNotifierSingleMixin` (in `get_state_manager/src/simple/list_notifier.dart`).
    ```dart
    // From: get_rx/src/rx_types/rx_core/rx_impl.dart (RxObjectMixin's value getter)
    // Simplified concept of what Rx's .value getter does
    T get value {
      reportRead(); // "I'm being read!"
      return _internalValue;
    }
    ```
2.  `reportRead()` calls `Notifier.instance.read(this)` (`this` refers to the `Rx` variable itself).
    ```dart
    // From: get_state_manager/src/simple/list_notifier.dart
    // (Inside ListNotifierSingleMixin)
    @protected
    void reportRead() {
      Notifier.instance.read(this);
    }
    ```
3.  `Notifier.instance.read()` checks the `_notifyData` that `StatelessObserverComponent.build()` set up. It finds the `getUpdate` method of our `Obx` widget and subscribes it to the `Rx` variable.
    ```dart
    // From: get_state_manager/src/simple/list_notifier.dart (Notifier class)
    void read(ListNotifierSingleMixin rxVariable) {
      final getStateUpdateFn = _notifyData?.updater; // This is Obx's getUpdate()
       // If Obx's getUpdate is available and not already listening to this rxVariable:
      if (getStateUpdateFn != null && !rxVariable.containsListener(getStateUpdateFn)) {
        // Tell rxVariable: "When you change, call Obx's getUpdate()"
        Disposer disposer = rxVariable.addListener(getStateUpdateFn);
        // And remember how to unsubscribe later
        _notifyData?.disposers.add(disposer);
      }
    }
    ```
So, when `RxVariable.value` changes later, it calls `refresh()` (from `ListNotifierSingleMixin`), which notifies its listeners. One of these listeners is the `Obx` widget's `getUpdate` method, causing the `Obx` widget to rebuild!

## What is `ObxWidget` then?

You'll mostly use `Obx`. `ObxWidget` is simply the base class that `Obx` (and `ObxValue`, another similar widget) extends. It provides the common reactive machinery. Advanced users could extend `ObxWidget` to create their own custom reactive widgets, but for most day-to-day tasks, `Obx` is all you need.

## Conclusion

You've now unlocked a cornerstone of GetX's reactivity: the `Obx` widget! It's your "smart picture frame" that automatically updates your UI when the underlying `Rx<T>` reactive variables change. This makes building dynamic and responsive UIs incredibly simple and efficient.

Typically, your `Rx<T>` variables will live inside a [GetxController](05_getxcontroller_.md) (which we'll cover soon) to keep your UI logic neatly organized. `Obx` then becomes the bridge that connects your controller's state to your visual widgets.

But what if you want to react to changes in `Rx<T>` variables *without* updating the UI? For example, maybe you want to log a message or make an API call when a value changes. For that, GetX provides something called "Workers." Let's explore those in the [next chapter, Chapter 4: Workers](04_workers_.md).

Relevant Code Snippets (Code itself remains unchanged):
--- File: get_state_manager/src/rx_flutter/rx_notifier.dart ---
import 'dart:async';

import 'package:flutter/foundation.dart';
import 'package:flutter/material.dart';
import 'package:get/utils.dart';

import '../../../get_rx/src/rx_types/rx_types.dart';
import '../../../instance_manager.dart';
import '../../get_state_manager.dart';
import '../simple/list_notifier.dart';

extension _Empty on Object {
  bool _isEmpty() {
    final val = this;
    // if (val == null) return true;
    var result = false;
    if (val is Iterable) {
      result = val.isEmpty;
    } else if (val is String) {
      result = val.trim().isEmpty;
    } else if (val is Map) {
      result = val.isEmpty;
    }
    return result;
  }
}

mixin StateMixin<T> on ListNotifier {
  T? _value;
  GetStatus<T>? _status;

  void _fillInitialStatus() {
    _status = (_value == null || _value!._isEmpty())
        ? GetStatus<T>.loading()
        : GetStatus<T>.success(_value as T);
  }

  GetStatus<T> get status {
    reportRead();
    return _status ??= _status = GetStatus.loading();
  }

  T get state => value;

  set status(GetStatus<T> newStatus) {
    if (newStatus == status) return;
    _status = newStatus;
    if (newStatus is SuccessStatus<T>) {
      _value = newStatus.data;
    }
    refresh();
  }

  @protected
  T get value {
    reportRead();
    return _value as T;
  }

  @protected
  set value(T newValue) {
    if (_value == newValue) return;
    _value = newValue;
    refresh();
  }

  @protected
  void change(GetStatus<T> status) {
    if (status != this.status) {
      this.status = status;
    }
  }

  void setSuccess(T data) {
    change(GetStatus<T>.success(data));
  }

  void setError(Object error) {
    change(GetStatus<T>.error(error));
  }

  void setLoading() {
    change(GetStatus<T>.loading());
  }

  void setEmpty() {
    change(GetStatus<T>.empty());
  }

  void futurize(Future<T> Function() body,
      {T? initialData, String? errorMessage, bool useEmpty = true}) {
    final compute = body;
    _value ??= initialData;
    status = GetStatus<T>.loading();
    compute().then((newValue) {
      if ((newValue == null || newValue._isEmpty()) && useEmpty) {
        status = GetStatus<T>.empty();
      } else {
        status = GetStatus<T>.success(newValue);
      }

      refresh();
    }, onError: (err) {
      status = GetStatus.error(
          err is Exception ? err : Exception(errorMessage ?? err.toString()));
      refresh();
    });
  }
}

typedef FuturizeCallback<T> = Future<T> Function(VoidCallback fn);

typedef VoidCallback = void Function();

class GetListenable<T> extends ListNotifierSingle implements RxInterface<T> {
  GetListenable(T val) : _value = val;

  StreamController<T>? _controller;

  StreamController<T> get subject {
    if (_controller == null) {
      _controller =
          StreamController<T>.broadcast(onCancel: addListener(_streamListener));
      _controller?.add(_value);

      ///TODO: report to controller dispose
    }
    return _controller!;
  }

  void _streamListener() {
    _controller?.add(_value);
  }

  @override
  @mustCallSuper
  void close() {
    removeListener(_streamListener);
    _controller?.close();
    dispose();
  }

  Stream<T> get stream {
    return subject.stream;
  }

  T _value;

  @override
  T get value {
    reportRead();
    return _value;
  }

  void _notify() {
    refresh();
  }

  set value(T newValue) {
    if (_value == newValue) return;
    _value = newValue;
    _notify();
  }

  T? call([T? v]) {
    if (v != null) {
      value = v;
    }
    return value;
  }

  @override
  StreamSubscription<T> listen(
    void Function(T)? onData, {
    Function? onError,
    void Function()? onDone,
    bool? cancelOnError,
  }) =>
      stream.listen(
        onData,
        onError: onError,
        onDone: onDone,
        cancelOnError: cancelOnError ?? false,
      );

  @override
  String toString() => value.toString();
}

class Value<T> extends ListNotifier
    with StateMixin<T>
    implements ValueListenable<T?> {
  Value(T val) {
    _value = val;
    _fillInitialStatus();
  }

  @override
  T get value {
    reportRead();
    return _value as T;
  }

  @override
  set value(T newValue) {
    if (_value == newValue) return;
    _value = newValue;
    refresh();
  }

  T? call([T? v]) {
    if (v != null) {
      value = v;
    }
    return value;
  }

  void update(T Function(T? value) fn) {
    value = fn(value);
    // refresh();
  }

  @override
  String toString() => value.toString();

  dynamic toJson() => (value as dynamic)?.toJson();
}

/// GetNotifier has a native status and state implementation, with the
/// Get Lifecycle
abstract class GetNotifier<T> extends Value<T> with GetLifeCycleMixin {
  GetNotifier(super.initial);
}

extension StateExt<T> on StateMixin<T> {
  Widget obx(
    NotifierBuilder<T> widget, {
    Widget Function(String? error)? onError,
    Widget? onLoading,
    Widget? onEmpty,
    WidgetBuilder? onCustom,
  }) {
    return Observer(builder: (context) {
      if (status.isLoading) {
        return onLoading ?? const Center(child: CircularProgressIndicator());
      } else if (status.isError) {
        return onError != null
            ? onError(status.errorMessage)
            : Center(child: Text('A error occurred: ${status.errorMessage}'));
      } else if (status.isEmpty) {
        return onEmpty ??
            const SizedBox.shrink(); // Also can be widget(null); but is risky
      } else if (status.isSuccess) {
        return widget(value);
      } else if (status.isCustom) {
        return onCustom?.call(context) ??
            const SizedBox.shrink(); // Also can be widget(null); but is risky
      }
      return widget(value);
    });
  }
}

typedef NotifierBuilder<T> = Widget Function(T state);

abstract class GetStatus<T> with Equality {
  const GetStatus();

  factory GetStatus.loading() => LoadingStatus<T>();

  factory GetStatus.error(Object message) => ErrorStatus<T, Object>(message);

  factory GetStatus.empty() => EmptyStatus<T>();

  factory GetStatus.success(T data) => SuccessStatus<T>(data);

  factory GetStatus.custom() => CustomStatus<T>();
}

class CustomStatus<T> extends GetStatus<T> {
  @override
  List get props => [];
}

class LoadingStatus<T> extends GetStatus<T> {
  @override
  List get props => [];
}

class SuccessStatus<T> extends GetStatus<T> {
  final T data;

  const SuccessStatus(this.data);

  @override
  List get props => [data];
}

class ErrorStatus<T, S> extends GetStatus<T> {
  final S? error;

  const ErrorStatus([this.error]);

  @override
  List get props => [error];
}

class EmptyStatus<T> extends GetStatus<T> {
  @override
  List get props => [];
}

extension StatusDataExt<T> on GetStatus<T> {
  bool get isLoading => this is LoadingStatus;

  bool get isSuccess => this is SuccessStatus;

  bool get isError => this is ErrorStatus;

  bool get isEmpty => this is EmptyStatus;

  bool get isCustom => !isLoading && !isSuccess && !isError && !isEmpty;

  dynamic get error {
    if (this is ErrorStatus) {
      return (this as ErrorStatus).error;
    }
    return null;
  }

  String get errorMessage {
    final isError = this is ErrorStatus;
    if (isError) {
      final err = this as ErrorStatus;
      if (err.error != null) {
        if (err.error is String) {
          return err.error as String;
        }
        return err.error.toString();
      }
    }

    return '';
  }

  T? get data {
    if (this is SuccessStatus<T>) {
      final success = this as SuccessStatus<T>;
      return success.data;
    }
    return null;
  }
}


--- File: get_rx/src/rx_workers/rx_workers.dart ---
import 'dart:async';

import '../../../get_core/get_core.dart';
import '../../../get_state_manager/src/rx_flutter/rx_notifier.dart';
import '../rx_types/rx_types.dart';
import 'utils/debouncer.dart';

bool _conditional(dynamic condition) {
  if (condition == null) return true;
  if (condition is bool) return condition;
  if (condition is bool Function()) return condition();
  return true;
}

typedef WorkerCallback<T> = Function(T callback);

class Workers {
  Workers(this.workers);
  final List<Worker> workers;

  void dispose() {
    for (final worker in workers) {
      if (!worker._disposed) {
        worker.dispose();
      }
    }
  }
}

///
/// Called every time [listener] changes. As long as the [condition]
/// returns true.
///
/// Sample:
/// Every time increment() is called, ever() will process the [condition]
/// (can be a [bool] expression or a `bool Function()`), and only call
/// the callback when [condition] is true.
/// In our case, only when count is bigger to 5. In order to "dispose"
/// this Worker
/// that will run forever, we made a `worker` variable. So, when the count value
/// reaches 10, the worker gets disposed, and releases any memory resources.
///
/// ```
/// // imagine some counter widget...
///
/// class _CountController extends GetxController {
///   final count = 0.obs;
///   Worker worker;
///
///   void onInit() {
///     worker = ever(count, (value) {
///       print('counter changed to: $value');
///       if (value == 10) worker.dispose();
///     }, condition: () => count > 5);
///   }
///
///   void increment() => count + 1;
/// }
/// ```
Worker ever<T>(
  GetListenable<T> listener,
  WorkerCallback<T> callback, {
  dynamic condition = true,
  Function? onError,
  void Function()? onDone,
  bool? cancelOnError,
}) {
  StreamSubscription sub = listener.listen(
    (event) {
      if (_conditional(condition)) callback(event);
    },
    onError: onError,
    onDone: onDone,
    cancelOnError: cancelOnError,
  );
  return Worker(sub.cancel, '[ever]');
}

/// Similar to [ever], but takes a list of [listeners], the condition
/// for the [callback] is common to all [listeners],
/// and the [callback] is executed to each one of them. The [Worker] is
/// common to all, so `worker.dispose()` will cancel all streams.
Worker everAll(
  List<RxInterface> listeners,
  WorkerCallback callback, {
  dynamic condition = true,
  Function? onError,
  void Function()? onDone,
  bool? cancelOnError,
}) {
  final evers = <StreamSubscription>[];
  for (var i in listeners) {
    final sub = i.listen(
      (event) {
        if (_conditional(condition)) callback(event);
      },
      onError: onError,
      onDone: onDone,
      cancelOnError: cancelOnError,
    );
    evers.add(sub);
  }

  Future<void> cancel() async {
    for (var i in evers) {
      i.cancel();
    }
  }

  return Worker(cancel, '[everAll]');
}

/// `once()` will execute only 1 time when [condition] is met and cancel
/// the subscription to the [listener] stream right after that.
/// [condition] defines when [callback] is called, and
/// can be a [bool] or a `bool Function()`.
///
/// Sample:
/// ```
///  class _CountController extends GetxController {
///   final count = 0.obs;
///   Worker worker;
///
///   @override
///   Future<void> onInit() async {
///     worker = once(count, (value) {
///       print("counter reached $value before 3 seconds.");
///     }, condition: () => count() > 2);
///     3.delay(worker.dispose);
///   }
///   void increment() => count + 1;
/// }
///```
Worker once<T>(
  GetListenable<T> listener,
  WorkerCallback<T> callback, {
  dynamic condition = true,
  Function? onError,
  void Function()? onDone,
  bool? cancelOnError,
}) {
  late Worker ref;
  StreamSubscription? sub;
  sub = listener.listen(
    (event) {
      if (!_conditional(condition)) return;
      ref._disposed = true;
      ref._log('called');
      sub?.cancel();
      callback(event);
    },
    onError: onError,
    onDone: onDone,
    cancelOnError: cancelOnError,
  );
  ref = Worker(sub.cancel, '[once]');
  return ref;
}

/// Ignore all changes in [listener] during [time] (1 sec by default) or until
/// [condition] is met (can be a [bool] expression or a `bool Function()`),
/// It brings the 1st "value" since the period of time, so
/// if you click a counter button 3 times in 1 sec, it will show you "1"
/// (after 1 sec of the first press)
/// click counter 3 times in 1 sec, it will show you "4" (after 1 sec)
/// click counter 2 times in 1 sec, it will show you "7" (after 1 sec).
///
/// Sample:
/// // wait 1 sec each time an event starts, only if counter is lower than 20.
/// worker = interval(
///    count,
///    (value) => print(value),
///    time: 1.seconds,
///    condition: () => count < 20,
/// );
/// ```
Worker interval<T>(
  GetListenable<T> listener,
  WorkerCallback<T> callback, {
  Duration time = const Duration(seconds: 1),
  dynamic condition = true,
  Function? onError,
  void Function()? onDone,
  bool? cancelOnError,
}) {
  var debounceActive = false;
  StreamSubscription sub = listener.listen(
    (event) async {
      if (debounceActive || !_conditional(condition)) return;
      debounceActive = true;
      await Future.delayed(time);
      debounceActive = false;
      callback(event);
    },
    onError: onError,
    onDone: onDone,
    cancelOnError: cancelOnError,
  );
  return Worker(sub.cancel, '[interval]');
}

/// [debounce] is similar to [interval], but sends the last value.
/// Useful for Anti DDos, every time the user stops typing for 1 second,
/// for instance.
/// When [listener] emits the last "value", when [time] hits,
/// it calls [callback] with the last "value" emitted.
///
/// Sample:
///
/// ```
/// worker = debounce(
///      count,
///      (value) {
///        print(value);
///        if( value > 20 ) worker.dispose();
///      },
///      time: 1.seconds,
///    );
///  }
///  ```
Worker debounce<T>(
  GetListenable<T> listener,
  WorkerCallback<T> callback, {
  Duration? time,
  Function? onError,
  void Function()? onDone,
  bool? cancelOnError,
}) {
  final newDebouncer =
      Debouncer(delay: time ?? const Duration(milliseconds: 800));
  StreamSubscription sub = listener.listen(
    (event) {
      newDebouncer(() {
        callback(event);
      });
    },
    onError: onError,
    onDone: onDone,
    cancelOnError: cancelOnError,
  );
  return Worker(sub.cancel, '[debounce]');
}

class Worker {
  Worker(this.worker, this.type);

  /// subscription.cancel() callback
  final Future<void> Function() worker;

  /// type of worker (debounce, interval, ever)..
  final String type;
  bool _disposed = false;

  bool get disposed => _disposed;

  //final bool _verbose = true;
  void _log(String msg) {
    //  if (!_verbose) return;
    Get.log('$runtimeType $type $msg');
  }

  void dispose() {
    if (_disposed) {
      _log('already disposed');
      return;
    }
    _disposed = true;
    worker();
    _log('disposed');
  }

  void call() => dispose();
}


--- File: get_rx/src/rx_workers/utils/debouncer.dart ---
import 'dart:async';

/// This "function" class is the implementation of `debouncer()` Worker.
/// It calls the function passed after specified [delay] parameter.
/// Example:
/// ```
/// final delayed = Debouncer( delay: Duration( seconds: 1 )) ;
/// print( 'the next function will be called after 1 sec' );
/// delayed( () => print( 'called after 1 sec' ));
/// ```
class Debouncer {
  final Duration delay;
  Timer? _timer;

  Debouncer({required this.delay});

  void call(void Function() action) {
    _timer?.cancel();
    _timer = Timer(delay, action);
  }

  /// Notifies if the delayed call is active.
  bool get isRunning => _timer?.isActive ?? false;

  /// Cancel the current delayed call.
  void cancel() => _timer?.cancel();
}


Instructions for the chapter (Generate content in English unless specified otherwise):
- Start with a clear heading (e.g., `# Chapter 4: Workers
`). Use the provided concept name.

- If this is not the first chapter, begin with a brief transition from the previous chapter, referencing it with a proper Markdown link using its name.

- Begin with a high-level motivation explaining what problem this abstraction solves. Start with a central use case as a concrete example. The whole chapter should guide the reader to understand how to solve this use case. Make it very minimal and friendly to beginners.

- If the abstraction is complex, break it down into key concepts. Explain each concept one-by-one in a very beginner-friendly way.

- Explain how to use this abstraction to solve the use case. Give example inputs and outputs for code snippets (if the output isn't values, describe at a high level what will happen).

- Each code block should be BELOW 10 lines! If longer code blocks are needed, break them down into smaller pieces and walk through them one-by-one. Aggresively simplify the code to make it minimal. Use comments to skip non-important implementation details. Each code block should have a beginner friendly explanation right after it.

- Describe the internal implementation to help understand what's under the hood. First provide a non-code or code-light walkthrough on what happens step-by-step when the abstraction is called. It's recommended to use a simple sequenceDiagram with a dummy example - keep it minimal with at most 5 participants to ensure clarity. If participant name has space, use: `participant QP as Query Processing`. .

- Then dive deeper into code for the internal implementation with references to files. Provide example code blocks, but make them similarly simple and beginner-friendly. Explain.

- IMPORTANT: When you need to refer to other core abstractions covered in other chapters, ALWAYS use proper Markdown links like this: [Chapter Title](filename.md). Use the Complete Tutorial Structure above to find the correct filename and the chapter title. Translate the surrounding text.

- Use mermaid diagrams to illustrate complex concepts (```mermaid``` format). .

- Heavily use analogies and examples throughout to help beginners understand.

- End the chapter with a brief conclusion that summarizes what was learned and provides a transition to the next chapter. If there is a next chapter, use a proper Markdown link: [Next Chapter Title](next_chapter_filename).

- Ensure the tone is welcoming and easy for a newcomer to understand.

- Output *only* the Markdown content for this chapter.

Now, directly provide a super beginner-friendly Markdown output (DON'T need ```markdown``` tags):

2025-05-12 13:35:05,036 - INFO - RESPONSE: # Chapter 4: Workers

In [Chapter 3: Obx / ObxWidget](03_obx___obxwidget_.md), we saw how `Obx` acts like a smart picture frame, automatically updating our UI when reactive variables change. That's perfect for what users see! But what if we want to perform actions *behind the scenes* when our data changes? For instance, what if we need to fetch new data from the internet when a user's ID changes, or automatically save their input after they've stopped typing for a moment? This is where GetX Workers come in!

## What Problem Do Workers Solve?

Imagine you have a reactive variable, say, `userId.obs`. When this `userId` changes, you might want to:
*   Log the change for debugging.
*   Fetch the new user's profile from a server.
*   Update some other non-UI related data.

You don't want to put this logic directly in your UI-building code because it's not about drawing pixels on the screen. It's about reacting to data changes with *side effects*.

**Workers** are your dedicated helpers for exactly this. They are functions that "listen" to your [Rx<T> (Reactive Variables)](02_rx_t___reactive_variables__.md) and execute a callback function when specific events or conditions occur on those variables. Think of them as automated sentinels, tirelessly watching your reactive data streams. When a predefined rule is met (like "the data changed!" or "the user stopped typing!"), they spring into action, independent of direct UI rendering.

## Meet the Workers: Your Automated Sentinels

GetX provides a few different types of Workers, each designed for a specific kind of listening task. Let's meet the main ones: `ever`, `once`, `debounce`, and `interval`.

All these workers are typically set up within the `onInit()` method of a [GetxController](05_getxcontroller_.md) (which we'll cover in the next chapter), or anywhere you have access to your reactive variables and need to react to their changes.

### 1. `ever`: The Ever-Watchful Sentinel

The `ever` worker executes its callback function **every time** the reactive variable it's watching changes.

Let's say we have a reactive variable for a username:
```dart
import 'package:get/get.dart';

final username = 'Guest'.obs; // Our reactive username
```
Now, let's set up an `ever` worker to print a message whenever `username` changes:
```dart
// Typically, you'd do this in onInit() of a GetxController
ever(username, (String newName) {
  print("Username changed to: $newName");
});

// Let's simulate some changes:
username.value = 'Alice';
username.value = 'Bob';
```
**What happens?**
Every time `username.value` is assigned a new value, the `ever` worker's callback `(String newName) { ... }` is triggered.
Output:
```
Username changed to: Alice
Username changed to: Bob
```

You can also add a `condition` to `ever`. The callback will only run if the condition is true when the main variable changes.
```dart
final count = 0.obs;

ever(count, (int newCount) {
  print("Count is now $newCount (and it's greater than 2!)");
}, condition: () => count.value > 2); // Only run if count > 2

count.value = 1; // No output
count.value = 3; // Output: Count is now 3 (and it's greater than 2!)
count.value = 4; // Output: Count is now 4 (and it's greater than 2!)
```

### 2. `once`: The One-Time Sentinel

The `once` worker executes its callback function **only the first time** a specific condition (related to the reactive variable) is met. After it runs once, it automatically stops listening.

Imagine you want to show a welcome message only the very first time a user logs in (i.e., `isLoggedIn.value` becomes `true`).
```dart
final isLoggedIn = false.obs;

once(isLoggedIn, (bool loggedInStatus) {
  if (loggedInStatus == true) {
    print("Welcome! You've logged in for the first time (during this session).");
  }
}, condition: () => isLoggedIn.value == true); // Condition to trigger

isLoggedIn.value = true;  // Triggers 'once'
isLoggedIn.value = false; // 'once' won't trigger again
isLoggedIn.value = true;  // 'once' won't trigger again
```
**What happens?**
The callback is executed only when `isLoggedIn.value` changes *and* the condition `isLoggedIn.value == true` is met for the *first time*.
Output:
```
Welcome! You've logged in for the first time (during this session).
```
Even if `isLoggedIn` becomes `true` again later, `once` has done its job and won't fire again.

### 3. `debounce`: The "Wait-and-See" Sentinel

The `debounce` worker is super useful for scenarios like search fields. It waits for a certain period of inactivity before executing the callback. If the variable changes again before the waiting period is over, the timer resets.

Imagine a search bar. You don't want to make an API call for every single letter the user types. Instead, you want to wait until they pause typing.
```dart
final searchQuery = ''.obs;

debounce(searchQuery, (String query) {
  print("User stopped typing. Search for: $query");
  // In a real app, you'd make an API call here: fetchResults(query);
}, time: Duration(milliseconds: 500)); // Wait for 500ms of inactivity

// Simulate typing quickly, then pausing
searchQuery.value = 'h';
searchQuery.value = 'he';
searchQuery.value = 'hel'; // Timer resets each time
// User pauses... after 500ms:
// Output: User stopped typing. Search for: hel
```
**What happens?**
*   User types 'h', then 'e', then 'l' quickly. The `debounce` timer keeps resetting.
*   After 'hel', if the user pauses for 500 milliseconds, the callback `(String query) { ... }` is executed with the latest value ('hel').
*   If they type 'lo' next, the same process repeats.

### 4. `interval`: The "Periodic Check-up" Sentinel

The `interval` worker is a bit like `debounce` but it triggers its callback with the value that the reactive variable had at the *beginning* of the interval, after a specified duration has passed, and *only if* no new changes occurred during that interval (this behavior can be subtle, often `debounce` is what people want for "after a delay"). It's more like "if nothing changes for X time, then act on the value from X time ago".

A more common use of a timed worker might be "check something every X seconds while a condition is true." `interval` is designed to trigger *after* a period of stability. If you rapidly change the value, `interval` might not fire for each change because a new event interrupts the "quiet period" it's waiting for.

Let's consider a scenario where you want to perform an action if a value remains stable for a certain period.
```dart
final status = 'idle'.obs;

interval(status, (String currentStatus) {
  print("Status has been '$currentStatus' for 1 second.");
}, time: Duration(seconds: 1));

status.value = 'processing'; // Worker starts listening
// If 'status' remains 'processing' for 1 second:
// Output: Status has been 'processing' for 1 second.

// If you change it quickly:
// status.value = 'A';
// await Future.delayed(Duration(milliseconds: 200));
// status.value = 'B'; // 'A' might not trigger the interval callback
```
**What happens?**
If `status.value` becomes 'processing' and stays 'processing' for 1 second without any other changes to `status`, the callback will fire. If `status` changes again *within* that 1-second window, the timer for the *previous* value is essentially reset/ignored, and a new interval evaluation potentially begins for the new value. `debounce` is often more intuitive for "do something after a pause."

For `interval`, the primary mechanism is: when an event arrives, it waits for `time`. If another event arrives *before* `time` is up, the first event is effectively ignored by that specific `interval`'s timer. When `time` *does* elapse without a new event, the callback is fired with the value that was present when the `time` period began.


## Disposing of Workers

Workers, like `StreamSubscription`s in Dart, need to be disposed of when they are no longer needed. This is crucial to prevent memory leaks and unwanted behavior, especially if the reactive variable they are listening to outlives the context where the worker was created.

When you create a worker, it returns a `Worker` object. This object has a `dispose()` method:
```dart
final count = 0.obs;
late Worker everWorker; // Declare the worker variable

// In onInit() or similar setup:
everWorker = ever(count, (_) => print('Count changed!'));

// ... later, when this logic is no longer needed (e.g., in onClose() of a GetxController):
void cleanup() {
  everWorker.dispose();
  print("Ever worker disposed.");
}

count.value = 1; // Output: Count changed!
cleanup();
count.value = 2; // No output, because the worker is disposed.
```

It's a common pattern to initialize workers in the `onInit()` method of a [GetxController](05_getxcontroller_.md) and dispose of them in its `onClose()` method. GetX also provides a way to automatically manage this if workers are declared inside a controller, but manual disposal is good practice to understand.

## Under the Hood: How Do Workers... Work?

Workers function by subscribing to the underlying stream of an [Rx<T> (Reactive Variables)](02_rx_t___reactive_variables__.md). Remember from Chapter 2 that `Rx` variables can notify listeners when they change? Workers are specialized listeners.

1.  **Subscription:** When you create a worker (e.g., `ever(myRxVar, callback)`), the worker function internally calls `myRxVar.listen(...)`. This is similar to listening to a Dart `Stream`.
2.  **Event Emission:** When `myRxVar.value` changes, `myRxVar` emits this new value to its listeners.
3.  **Worker Logic:** The worker receives this new value.
    *   For `ever`, it typically checks an optional condition and then calls your callback.
    *   For `once`, it does the same but also cancels its own subscription after the first valid trigger.
    *   For `debounce`, it uses a timer (like the `Debouncer` utility class in GetX). Each new event resets the timer. If the timer completes, the callback is called with the *last* event received.
    *   For `interval`, it also uses a timer. When an event arrives, it starts a timer. If the timer completes *without* a new event arriving, it calls the callback with the event that started that timer.
4.  **Callback Execution:** If the worker's specific logic decides it's time, your provided callback function is executed with the relevant value.

Heres a simplified sequence diagram showing a `debounce` worker in action:

```mermaid
sequenceDiagram
    participant UserAction as User Typing
    participant SearchRx as searchQuery.obs
    participant DebounceWorker as Debounce Logic
    participant YourCallback as (query) => API.search(query)

    UserAction->>SearchRx: searchQuery.value = "flut"
    SearchRx-->>DebounceWorker: Notifies with "flut"
    DebounceWorker->>DebounceWorker: Starts/Resets 500ms timer
    UserAction->>SearchRx: searchQuery.value = "flutter"
    SearchRx-->>DebounceWorker: Notifies with "flutter"
    DebounceWorker->>DebounceWorker: Resets 500ms timer (for "flutter")
    Note over DebounceWorker: User pauses typing...
    DebounceWorker-->>YourCallback: After 500ms, calls YourCallback("flutter")
```

The actual implementation can be found in `get_rx/src/rx_workers/rx_workers.dart`.
For example, the `ever` worker (simplified):
```dart
// From: get_rx/src/rx_workers/rx_workers.dart (conceptual)
Worker ever<T>(
  GetListenable<T> listener, // This is your Rx variable
  WorkerCallback<T> callback, {
  dynamic condition = true, // Optional condition
  /* ... other params ... */
}) {
  // 1. Listen to the Rx variable's stream
  StreamSubscription sub = listener.listen(
    (event) { // 'event' is the new value from the Rx variable
      // 2. Check the condition
      if (_conditional(condition)) { // _conditional is a helper
        // 3. Execute your callback
        callback(event);
      }
    },
    /* ... onError, onDone ... */
  );
  // 4. Return a Worker object that can be used to cancel the subscription
  return Worker(sub.cancel, '[ever]');
}
```
The `_conditional` function (also in `rx_workers.dart`) is a utility that evaluates the `condition` argument, which can be a `bool` or a `bool Function()`.

The `debounce` worker uses a `Debouncer` utility class (found in `get_rx/src/rx_workers/utils/debouncer.dart`):
```dart
// From: get_rx/src/rx_workers/rx_workers.dart (conceptual)
Worker debounce<T>(
  GetListenable<T> listener,
  WorkerCallback<T> callback, {
  Duration? time, /* ... */
}) {
  // 1. Create a Debouncer instance
  final newDebouncer = Debouncer(delay: time ?? Duration(milliseconds: 800));
  StreamSubscription sub = listener.listen(
    (event) {
      // 2. When Rx variable changes, call the debouncer
      newDebouncer(() {
        // 3. Debouncer will execute this only after the 'delay'
        callback(event);
      });
    }, /* ... */
  );
  return Worker(sub.cancel, '[debounce]');
}
```
The `Debouncer` class itself manages a `Timer` to achieve the "wait for inactivity" behavior.

## Conclusion

Workers (`ever`, `once`,  `debounce`, `interval`) are powerful tools in GetX for reacting to changes in your [Rx<T> (Reactive Variables)](02_rx_t___reactive_variables__.md) by performing side effects like API calls, logging, or triggering other logic that isn't directly tied to UI updates. They help you keep your code clean by separating these concerns. Remember to always `dispose()` your workers when they're no longer needed to keep your app running smoothly.

Now that we've seen how to create reactive data (`Rx<T>`), how to make our UI react to it (`Obx`), and how to perform side effects based on it (Workers), it's time to look at how to organize all this reactive goodness. In the [next chapter, Chapter 5: GetxController](05_getxcontroller_.md), we'll explore `GetxController`, the recommended way to encapsulate your business logic and reactive state.
2025-05-12 13:35:05,101 - INFO - PROMPT: 
Write a very beginner-friendly tutorial chapter (in Markdown format) for the project `lib` about the concept: "GetxController
". This is Chapter 5.

Concept Details:
- Name: GetxController

- Description:
A `GetxController` is like the manager or "brain" for a specific part of your app's screen or a feature.
It holds the data (state) and the business logic (functions) for that part.
When data changes, the controller can tell the UI to update by calling its `update()` method.
It's like the director of a play scene, instructing which actors (widgets) need to change their
appearance or behavior based on the script (logic and state). It's primarily used with `GetBuilder` for manual UI updates.


Complete Tutorial Structure:
1. [Get (Global Access Facade)
](01_get__global_access_facade__.md)
2. [Rx<T> (Reactive Variables)
](02_rx_t___reactive_variables__.md)
3. [Obx / ObxWidget
](03_obx___obxwidget_.md)
4. [Workers
](04_workers_.md)
5. [GetxController
](05_getxcontroller_.md)
6. [Dependency Access (Binder, Bind.of, Get.find/put)
](06_dependency_access__binder__bind_of__get_find_put__.md)
7. [GetBuilder
](07_getbuilder_.md)
8. [StateMixin
](08_statemixin_.md)
9. [ListNotifier (and Mixins)
](09_listnotifier__and_mixins__.md)

Context from previous chapters:
# Chapter 1: Get (Global Access Facade)

Welcome to your GetX journey! In this first chapter, we'll explore one of the most fundamental and frequently used parts of the GetX ecosystem: the `Get` object.

## What is `Get` and Why Do You Need It?

Imagine you're building a Flutter app. You often need to perform common tasks like:
*   Showing a quick message (a "snackbar") to the user.
*   Navigating to a new screen.
*   Accessing a shared service, like a settings manager, from various parts of your app.

Traditionally, in Flutter, many of these tasks require access to something called `BuildContext`. `BuildContext` tells Flutter "where" you are in your widget tree, which is necessary for operations like finding the nearest `Navigator` or `Scaffold`. Getting `BuildContext` to the exact spot where you need it can sometimes be cumbersome, especially in deeper parts of your app's logic that aren't directly part of a widget.

This is where `Get` comes to the rescue!

The `Get` object is your main entry point for most GetX features. Think of it as a **universal remote control** for your application. It provides super easy-to-use tools (called static methods) for:

*   **Dependency Management:** Storing and retrieving your app's services or "managers" (like a `UserSettingsManager` or `ApiService`).
*   **Navigation:** Moving between screens with simple commands.
*   **Showing UI Elements:** Displaying dialogs, snackbars, or bottom sheets.
*   ...and much more!

The beauty of `Get` is that it often lets you do these things **without needing `BuildContext`**, making your code cleaner and simplifying access to GetX functionalities from virtually anywhere in your app.

## How to Use `Get`

Using `Get` is incredibly straightforward because its methods are `static`. This means you don't need to create an instance of a `Get` class; you just type `Get.` followed by the feature you want to use.

Let's look at a few common use cases:

### 1. Showing a Snackbar

Need to show a quick notification to the user?

```dart
import 'package:get/get.dart'; // Make sure to import GetX

// ...somewhere in your code, even inside a business logic class
void showSuccessMessage() {
  Get.snackbar(
    "Success!", // title
    "Your profile was updated successfully.", // message
    snackPosition: SnackPosition.BOTTOM
  );
}
```

**What happens?**
When `showSuccessMessage()` is called, GetX will display a snackbar at the bottom of the current screen with the title "Success!" and the given message. Notice you didn't need to pass any `BuildContext`!

### 2. Navigating to a New Screen

Want to open a new page?

```dart
import 'package:flutter/material.dart';
import 'package:get/get.dart';

class HomeScreen extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(title: Text("Home")),
      body: Center(
        child: ElevatedButton(
          onPressed: () {
            Get.to(DetailScreen()); // Navigate to DetailScreen
          },
          child: Text("Go to Details"),
        ),
      ),
    );
  }
}

class DetailScreen extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(title: Text("Details")),
      body: Center(
        child: ElevatedButton(
          onPressed: () {
            Get.back(); // Go back to the previous screen
          },
          child: Text("Go Back"),
        ),
      ),
    );
  }
}
```
**What happens?**
*   Tapping the "Go to Details" button on `HomeScreen` will push `DetailScreen` onto the navigation stack, making it visible.
*   Tapping the "Go Back" button on `DetailScreen` will pop it from the stack, revealing `HomeScreen` again.

Again, simple and no `BuildContext` needed for `Get.to()` or `Get.back()`. (Note: To use GetX navigation, your main app widget should be `GetMaterialApp` instead of `MaterialApp`).

### 3. Basic Dependency Management (Service Locator)

Imagine you have a class that manages user preferences:

```dart
class UserPreferencesService {
  bool _isDarkMode = false;

  bool get isDarkMode => _isDarkMode;

  void toggleDarkMode() {
    _isDarkMode = !_isDarkMode;
    print("Dark mode is now: $_isDarkMode");
    // In a real app, you'd save this preference
  }
}
```

You can "register" an instance of this service with GetX using `Get.put()`:

```dart
// Usually done at app startup or in a specific setup area
void initializeServices() {
  Get.put(UserPreferencesService());
  print("UserPreferencesService registered!");
}
```

Later, from anywhere in your app, you can retrieve this instance using `Get.find()`:

```dart
// ... in some widget or controller
void onThemeToggleButtonPressed() {
  final prefsService = Get.find<UserPreferencesService>();
  prefsService.toggleDarkMode();
  // You might then update your UI based on prefsService.isDarkMode
}
```

**What happens?**
*   `Get.put(UserPreferencesService());` creates an instance of `UserPreferencesService` and stores it in a global container managed by GetX.
*   `Get.find<UserPreferencesService>();` looks up and returns that stored instance.

This allows you to easily access shared services without passing instances around manually or using complex InheritedWidgets. We'll dive much deeper into dependency management in [Chapter 6: Dependency Access (Binder, Bind.of, Get.find/put)](06_dependency_access__binder__bind_of__get_find_put__.md).

## Under the Hood: How Does `Get` Work?

You might be wondering how `Get` can perform these actions, especially UI-related ones like showing snackbars, without `BuildContext`.

At its core, `Get` is a cleverly designed global static instance. When you use GetX (typically by wrapping your app with `GetMaterialApp`), GetX sets up the necessary infrastructure.

Here's a simplified conceptual flow for showing a snackbar:

```mermaid
sequenceDiagram
    participant YourCode as Your App Code
    participant Get as Get Object
    participant GetXCore as GetX Internal Logic
    participant FlutterFramework as Flutter Framework

    YourCode->>Get: Calls Get.snackbar("Title", "Message")
    Get->>GetXCore: Forwards request to internal snackbar logic
    GetXCore->>FlutterFramework: Uses Flutter's Overlay (or similar) to display UI
    FlutterFramework-->>YourCode: Snackbar appears on screen
```

**1. The `Get` Object Itself:**
The `Get` object you use is actually a global instance of a class. This is defined very simply in the GetX core:

```dart
// From: get_core/src/get_main.dart

// (_GetImpl is a class that implements GetInterface,
// where all the actual methods are defined or extended)
class _GetImpl extends GetInterface {}

// This creates a single, globally accessible instance named 'Get'
// ignore: non_constant_identifier_names
final Get = _GetImpl();
```
This `Get` variable is what you're accessing when you type `Get.something()`.

**2. `GetInterface` and Extensions:**
The `_GetImpl` class extends `GetInterface`.
```dart
// From: get_core/src/get_interface.dart
abstract class GetInterface {
  // Basic configurations like smartManagement and logging
  SmartManagement smartManagement = SmartManagement.full;
  bool isLogEnable = kDebugMode;
  LogWriterCallback log = defaultLogWriterCallback;
  // ... other core properties might be declared here
}
```
Many of GetX's functionalities (like `Get.to`, `Get.snackbar`, `Get.put`, `Get.find`) are added to this `GetInterface` through Dart's extension methods or are mixed into `_GetImpl`. These extensions contain the actual logic. For example, the navigation methods know how to find the `Navigator` provided by `GetMaterialApp`, and the snackbar methods know how to tap into Flutter's `Overlay` to display UI elements globally.

**3. For Dependency Management (`Get.put` / `Get.find`):**
When you use `Get.put(MyService())`, GetX stores this `MyService` instance in an internal data structure (like a map), often an_instance manager. When you later call `Get.find<MyService>()`, GetX looks up `MyService` in this internal storage by its type (and optionally by a tag) and returns the stored instance. We'll cover the `InstanceManager` in more detail in [Chapter 6: Dependency Access (Binder, Bind.of, Get.find/put)](06_dependency_access__binder__bind_of__get_find_put__.md).

The key takeaway is that `Get` acts as a **facade**  a simplified, unified interface to a more complex underlying system. It hides the complexities of interacting directly with Flutter's deeper systems or managing global instances, providing you with clean, easy-to-use static methods.

## Conclusion

You've now met `Get`, your go-to helper for many common tasks in GetX. It's a powerful yet simple facade that provides global access to navigation, UI utilities, dependency management, and more, often without the need for `BuildContext`. This keeps your code clean and makes development faster.

As you continue your GetX journey, you'll see `Get` being used in various contexts. Understanding its role as a global access point is key to mastering GetX.

In the next chapter, we'll explore a core GetX concept for making your application's data dynamic and responsive: [Rx<T> (Reactive Variables)](02_rx_t___reactive_variables__.md).
---
# Chapter 2: Rx<T> (Reactive Variables)

Welcome to Chapter 2! In [Chapter 1: Get (Global Access Facade)](01_get__global_access_facade__.md), we learned how the `Get` object acts as a handy "universal remote" for common app tasks. Now, we're going to dive into one of the most exciting features of GetX: making your app's data "reactive."

## What's the Big Deal with "Reactive"?

Imagine you're building an app that shows a user's score. When the score changes, you want the text on the screen displaying that score to update *automatically*, without you having to write a lot of complicated code to manually refresh the screen. This "automatic updating" is what reactive programming is all about.

`Rx<T>` variables are GetX's way of achieving this magic.

## Introducing `Rx<T>`: Your Magic Whiteboard

`Rx<T>` types (like `RxInt`, `RxString`, or pretty much anything you see ending with `.obs`) represent variables that can be "observed."

Think of an `Rx<T>` variable as a special number (or text, or any data) written on a **magic whiteboard**:
*   You write your initial data on this whiteboard (e.g., the number `0`).
*   Whenever someone erases the number and writes a new one (e.g., changes it to `1`), a bell automatically rings!
*   Anyone (or any part of your app's UI) specifically "watching" that number on the whiteboard instantly sees the change and reacts to it.

These `Rx<T>` variables are the heart of GetX's reactive programming. They allow your User Interface (UI), especially when used with widgets like `Obx` (which we'll cover in the [next chapter](03_obx___obxwidget_.md)), to automatically update whenever the underlying data changes.

The `T` in `Rx<T>` is a placeholder for the type of data the variable will hold, like `int`, `String`, `bool`, or even your own custom classes.

## How to Create and Use Reactive Variables

Let's see how to create and use these "magic" variables. The most common way is by using the `.obs` extension on a standard Dart value.

### 1. Creating a Reactive Variable

To make a regular variable reactive, you simply add `.obs` to its initial value.

**For a number (integer):**

```dart
import 'package:get/get.dart'; // Don't forget to import GetX

final count = 0.obs; // This is now an RxInt holding 0
// You could also write: final count = RxInt(0);
```
Here, `count` isn't just a regular `int`. It's now a special `RxInt` object that holds the integer value `0` and can notify others when it changes.

**For text (string):**

```dart
final userName = "Guest".obs; // This is an RxString holding "Guest"
// You could also write: final userName = RxString("Guest");
```
Similarly, `userName` is an `RxString`.

**For a boolean (true/false):**

```dart
final isLoggedIn = false.obs; // This is an RxBool holding false
// You could also write: final isLoggedIn = RxBool(false);
```

### 2. Getting the Value

If `count` is an `RxInt`, how do you get the actual integer value out of it? You use the `.value` property.

```dart
final count = 0.obs;
print(count.value); // Output: 0

final userName = "Guest".obs;
print(userName.value); // Output: Guest
```
Think of `.value` as looking at the magic whiteboard to read what's currently written on it.

### 3. Changing the Value (and Ringing the Bell!)

To change the value of a reactive variable, you also assign a new value to its `.value` property. This is the action that "rings the bell."

```dart
final count = 0.obs;
print("Initial count: ${count.value}"); // Output: Initial count: 0

count.value = 5; // You changed the number on the whiteboard!
print("New count: ${count.value}"); // Output: New count: 5
```
When you do `count.value = 5;`, the `count` variable not only updates its internal number but also sends out a notification that its value has changed.

You can also change the value by calling the `Rx` variable like a function:
```dart
final anotherCount = 10.obs;
anotherCount(15); // Same as anotherCount.value = 15;
print(anotherCount.value); // Output: 15
```
This is just a shorthand. Both ways achieve the same result.

### A Simple Example: The Counter Logic

Let's imagine the logic for a simple counter. We won't build the UI yet, just the data part.

```dart
import 'package:get/get.dart';

// 1. Create a reactive variable for our count
final magicCounter = 0.obs;

void incrementCounter() {
  // 2. Change its value
  magicCounter.value++; // This rings the bell!
  print("Counter is now: ${magicCounter.value}");
}

void main() {
  print("Counter starts at: ${magicCounter.value}");
  incrementCounter(); // Call the function to change the value
  incrementCounter();
}
```
**What happens?**
1.  `magicCounter` is created as an `RxInt` initialized to `0`.
2.  When `incrementCounter()` is called, `magicCounter.value++` increases the stored integer and notifies any listeners.
3.  The `print` statement shows the updated value.

Output:
```
Counter starts at: 0
Counter is now: 1
Counter is now: 2
```
Right now, only our `print` statements are "listening" in a very basic way. In the [next chapter](03_obx___obxwidget_.md), we'll see how to make Flutter UI widgets listen and update automatically!

## Under the Hood: How Does `.obs` Work?

You might wonder what `.obs` actually does. It's a clever use of Dart's "extension methods."

When you write `0.obs`, GetX has an extension on the `int` type that looks something like this (simplified):

```dart
// From: get_rx/src/rx_types/rx_core/rx_impl.dart (simplified concept)
extension IntExtension on int {
  RxInt get obs => RxInt(this); // 'this' refers to the integer itself
}
```
This code basically says: "If you see `.obs` after an integer, create a new `RxInt` object and give it that integer's value." Similar extensions exist for `String`, `bool`, `double`, and even a generic `Rx<T>` for any object via `T.obs`.

The `RxInt`, `RxString`, etc., classes (which generally inherit from `_RxImpl<T>`) are special classes that manage an internal value and have a built-in mechanism to notify listeners.

Here's a simplified step-by-step of what happens when you change an `Rx` variable's value:

```mermaid
sequenceDiagram
    participant YourCode as Your App Code
    participant RxVariable as count (RxInt)
    participant RxImpl as Internal Logic (_RxImpl)
    participant Listeners as Potential UI (e.g., Obx)

    YourCode->>RxVariable: count.value = 1
    Note over RxVariable: This calls the 'set value' logic
    RxVariable->>RxImpl: Pass new value (1)
    RxImpl->>RxImpl: Store new value (1) internally
    RxImpl->>RxImpl: Check: Has value actually changed?
    alt Value Changed
        RxImpl-->>Listeners: Notifies all listeners (rings the bell!)
        Listeners-->>RxVariable: (Later) Asks RxVariable for its new .value
    end
```

1.  **You assign to `.value`**: `count.value = 1;`
2.  **Setter is called**: The `RxInt` class (or its parent `_RxImpl` found in `get_rx/src/rx_types/rx_core/rx_impl.dart`) has a special `set value(newValue)` method.
3.  **Value Check**: This setter first checks if the `newValue` is actually different from the current stored value. If it's the same, it usually does nothing to avoid unnecessary notifications.
4.  **Store New Value**: If the value is different, it updates its internal storage.
5.  **Notify Listeners**: This is the magic part! The class then triggers a notification. Internally, it often uses a `StreamController` (from `dart:async`). When you change `.value`, it essentially adds the new value to its stream using something like `subject.add(newValue)` after updating its internal `_value`.
    ```dart
    // Highly simplified concept from RxObjectMixin in get_rx/src/rx_types/rx_core/rx_impl.dart
    // and GetListenable in get_state_manager/src/rx_flutter/rx_notifier.dart

    // In GetListenable:
    // StreamController<T>? _controller;
    // T _value;
    // void refresh() { _controller?.add(_value); }

    // In RxObjectMixin (which uses GetListenable):
    set value(T val) {
      if (_value == val && !firstRebuild) return; // _value is from GetListenable
      firstRebuild = false;
      super.value = val; // This typically calls GetListenable's setter, which then calls refresh()
                         // `super.value = val;` roughly does:_value = val; refresh();
    }
    ```
    The `super.value = val;` line in `RxObjectMixin`'s setter calls the setter in its parent class (`GetListenable`), which updates the internal `_value` and then calls `refresh()`. The `refresh()` method then typically adds the new value to an internal stream (`_controller?.add(_value);`), effectively "ringing the bell."

Any widget designed to listen to these streams (like `Obx`) will then pick up this notification.

## Different Kinds of Rx Variables

GetX provides several pre-built `Rx` types for convenience:

*   **Primitives:**
    *   `RxInt(initialValue)` or `initialValue.obs` for integers.
    *   `RxDouble(initialValue)` or `initialValue.obs` for doubles.
    *   `RxString(initialValue)` or `initialValue.obs` for strings.
    *   `RxBool(initialValue)` or `initialValue.obs` for booleans.
*   **Collections (these are a bit more advanced as they react to internal changes too):**
    *   `RxList<T>([])` or `[].obs` for lists.
    *   `RxMap<K, V>({})` or `{}.obs` for maps.
    *   `RxSet<T>({})` or `{}.obs` for sets.
*   **Generic `Rx<T>`:**
    *   For any other type, including your custom classes:
        ```dart
        class User {
          String name;
          User(this.name);
        }

        final user = User("Alice").obs; // user is now an Rx<User>
        // or: final user = Rx<User>(User("Alice"));

        print(user.value.name); // Output: Alice
        user.value.name = "Bob";
        user.refresh(); // For complex objects, you might need to call refresh()
                        // or use user.update((val) { val.name = "Bob"; });
                        // to ensure listeners are notified of internal changes.
        print(user.value.name); // Output: Bob
        ```
    For changes *inside* a custom object held by `Rx<T>`, like changing `user.value.name`, GetX might not automatically know the object's internal state changed. In such cases, you can call `user.refresh()` to manually trigger the "bell," or use the `update()` method: `user.update((currentUser) { currentUser.name = "Bob"; });` which handles the refresh for you.

## Conclusion

You've now learned about `Rx<T>` variables  the "magic whiteboards" of GetX! They are special variables, easily created with `.obs`, that automatically notify anyone interested when their `.value` changes. This is the foundation of reactive programming in GetX and is crucial for building UIs that update themselves effortlessly.

These reactive variables are often managed within [GetxController](05_getxcontroller_.md) classes (which we'll cover later), making state management clean and powerful.

In the [next chapter, Chapter 3: Obx / ObxWidget](03_obx___obxwidget_.md), we'll see how to use `Obx` widgets to make your UI actually listen to these `Rx<T>` variables and update automatically when that magic bell rings!
---
# Chapter 3: Obx / ObxWidget

In [Chapter 2: Rx<T> (Reactive Variables)](02_rx_t___reactive_variables__.md), we discovered `Rx<T>` variables, our "magic whiteboards" that can signal when their data changes. That's fantastic for managing data, but how do we make our app's screen (the User Interface or UI) automatically show these changes?

Imagine you have a score in your game, stored in an `RxInt`. When the score increases, you want the score display on the screen to update instantly, without you having to write complex code to manually refresh it. This is where `Obx` comes in!

## Meet `Obx`: The Smart Picture Frame for Your UI

`Obx` (and its underlying base, `ObxWidget`) is a special Flutter widget provided by GetX. Its job is simple but powerful: it "watches" any reactive variables (`Rx<T>`) you use inside it and automatically rebuilds itself to show the new data whenever those variables change.

Remember our "magic whiteboard" (`Rx<T>`) from the last chapter?
Think of `Obx` as a **smart digital picture frame** that's wirelessly connected to that whiteboard.
*   You tell the `Obx` frame which part of the whiteboard to display (e.g., the score).
*   Whenever someone updates the score on the whiteboard (`Rx<T>` variable changes), the `Obx` frame *instantly* gets the new score and displays it.

This means your UI stays perfectly in sync with your app's state, efficiently and with very little code.

## How to Use `Obx`

Using `Obx` is wonderfully straightforward. You wrap the part of your UI that depends on a reactive variable with an `Obx` widget.

Let's build a very simple counter app to see it in action.

### 1. First, We Need a Reactive Variable

As we learned in [Chapter 2: Rx<T> (Reactive Variables)](02_rx_t___reactive_variables__.md), we create a reactive variable using `.obs`. Let's make a counter:

```dart
import 'package:get/get.dart'; // For .obs and Obx

final counter = 0.obs; // Our reactive integer, starting at 0
```
This `counter` is our "magic whiteboard" that will hold the current count.

### 2. Use `Obx` to Display the Reactive Variable

Now, let's use the `Obx` widget to display the value of `counter`. `Obx` takes a builder function. This function should return the widget(s) that depend on your reactive data.

Crucially, you **must** access the `.value` of your `Rx` variable *inside* this builder function for `Obx` to know which variable to watch.

```dart
// Inside your widget's build method:
Obx(() {
  // This Text widget will rebuild whenever 'counter.value' changes
  return Text("Button presses: ${counter.value}");
})
```
Here, `Obx` is our "smart picture frame." The builder function `() { return Text(...); }` tells the frame *what* to display. Because we used `counter.value` inside it, `Obx` knows to watch the `counter` variable.

### 3. Putting It All Together: A Simple Reactive Page

Let's see a complete, minimal example. We'll have a text display for the counter and a button to increment it.

```dart
import 'package:flutter/material.dart';
import 'package:get/get.dart';

// 1. Our reactive variable (could be in a GetxController later)
final counter = 0.obs;

class CounterPage extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(title: Text("Obx Counter Demo")),
      body: Center(
        // 2. Use Obx to wrap the widget that displays reactive data
        child: Obx(() {
          return Text(
            "Count: ${counter.value}", // Access .value here!
            style: TextStyle(fontSize: 28),
          );
        }),
      ),
      floatingActionButton: FloatingActionButton(
        onPressed: () {
          // 3. Change the reactive variable's value
          counter.value++;
        },
        child: Icon(Icons.add),
      ),
    );
  }
}
```

**What happens?**

1.  The page loads, `counter.value` is `0`. The `Obx` widget runs its builder function for the first time, and `Text("Count: 0")` is displayed.
2.  You tap the `+` button.
3.  The `onPressed` callback executes: `counter.value++`.
    *   The value of `counter` changes (e.g., from `0` to `1`).
    *   Because `counter` is an `RxInt` (a "magic whiteboard"), it "rings a bell," notifying its listeners that it has changed.
4.  The `Obx` widget, being a "smart picture frame" listening to `counter`, hears this bell!
5.  `Obx` automatically re-runs its builder function: `() { return Text("Count: ${counter.value}"); }`.
6.  This time, `counter.value` is `1`, so a new `Text("Count: 1")` widget is created and displayed.

The UI updates automatically, just like magic! You didn't have to call `setState()` or manually tell the UI to refresh.

### Important: Only Use Rx Variables *Inside* `Obx`'s Builder

`Obx` is smart, but it's not a mind reader. It only knows to rebuild if a reactive variable *that it has been told to observe* changes. It figures this out by tracking which reactive variables have their `.value` accessed *directly within its builder function*.

```dart
// GOOD: 'name.value' is inside Obx's builder
final name = "User".obs;
Obx(() => Text(name.value))

// BAD: If 'name.value' is not accessed inside, Obx won't react.
// (This would likely throw an ObxError if no other Rx var is accessed)
final name = "User".obs;
String currentName = name.value; // Accessed outside Obx's scope of observation
Obx(() => Text(currentName)) // Obx doesn't know about 'name' here
```

If you use an `Obx` widget and don't access any `.value` of an `Rx` variable inside its builder, GetX will usually show you an `ObxError` in the console, reminding you that `Obx` isn't observing anything.

```
[Get] the improper use of a GetX has been detected.
You should only use GetX or Obx for the specific widget that will be updated.
If you are seeing this error, you probably did not insert any observable variables into GetX/Obx...
```
This error message comes from the `ObxError` class defined in `get_state_manager/src/simple/list_notifier.dart`.

## Under the Hood: How Does `Obx` Work Its Magic?

It might seem like magic, but it's clever programming. Here's a simplified idea:

1.  **Subscription:** When an `Obx` widget is built for the first time, it prepares to listen. As its builder function executes, any `RxVariable.value` you access signals back to the `Obx` (via an internal `Notifier` system) saying, "Hey, Obx, I'm being read here! Please listen to me for changes." The `Obx` widget then subscribes to that `RxVariable`.
2.  **Value Change:** You change an `RxVariable` (e.g., `counter.value++`).
3.  **Notification:** The `RxVariable` "rings its bell" and notifies all its subscribers (including our `Obx` widget) that its value has changed.
4.  **Rebuild:** The `Obx` widget, upon receiving this notification, knows it needs to update. It schedules a rebuild, which simply means it calls its builder function again. Because the builder function now gets the new value from the `RxVariable`, the UI updates.

Here's a visual representation:

```mermaid
sequenceDiagram
    participant UserAction as User Taps Button
    participant RxVariable as counter (RxInt)
    participant ObxWidget as Obx Widget
    participant FlutterEngine as Flutter Engine

    Note over ObxWidget, RxVariable: Initial build: Obx reads counter.value, subscribes to counter.
    UserAction->>RxVariable: counter.value++
    RxVariable->>RxVariable: Internal value updates
    RxVariable-->>ObxWidget: Notifies Obx about the change
    ObxWidget->>ObxWidget: Schedules its builder to re-run
    ObxWidget->>RxVariable: Reads new counter.value (e.g., 1)
    ObxWidget-->>FlutterEngine: Provides new UI (e.g., Text("Count: 1"))
    FlutterEngine-->>UserAction: UI Updates on Screen
```

Let's peek at some (simplified) relevant code snippets:

`Obx` itself is quite simple. It extends `ObxWidget` (which extends `ObxStatelessWidget`).
```dart
// From: get_state_manager/src/rx_flutter/rx_obx_widget.dart
class Obx extends ObxWidget {
  final WidgetCallback builder; // Your () => Widget function
  const Obx(this.builder, {super.key});

  @override
  Widget build(BuildContext context) {
    return builder(); // It just calls your function!
  }
}
```
The real magic happens in `ObxStatelessWidget` and its `ObxElement`, which uses a mixin called `StatelessObserverComponent` (from `get_state_manager/src/simple/simple_builder.dart`).

```dart
// From: get_state_manager/src/simple/simple_builder.dart (simplified)
mixin StatelessObserverComponent on StatelessElement {
  List<Disposer>? disposers = <Disposer>[]; // To store cleanup functions

  void getUpdate() {
    // If I'm told to update, I tell Flutter to rebuild me!
    scheduleMicrotask(markNeedsBuild);
  }

  @override
  Widget build() {
    // Before calling the user's Obx builder (super.build),
    // set up the Notifier to catch Rx reads.
    return Notifier.instance.append(
        NotifyData(disposers: disposers!, updater: getUpdate),
        super.build // This eventually calls your Obx(() => Text(...))
    );
  }

  @override
  void unmount() { // When Obx is removed from the screen
    super.unmount();
    for (final disposer in disposers!) {
      disposer(); // Clean up subscriptions
    }
    disposers!.clear();
    disposers = null;
  }
}
```
When `yourRxVariable.value` is accessed *inside* the `Obx` builder (during `super.build` call above):
1.  The `Rx` variable's getter calls `reportRead()`. This method is mixed into `Rx` types from `ListNotifierSingleMixin` (in `get_state_manager/src/simple/list_notifier.dart`).
    ```dart
    // From: get_rx/src/rx_types/rx_core/rx_impl.dart (RxObjectMixin's value getter)
    // Simplified concept of what Rx's .value getter does
    T get value {
      reportRead(); // "I'm being read!"
      return _internalValue;
    }
    ```
2.  `reportRead()` calls `Notifier.instance.read(this)` (`this` refers to the `Rx` variable itself).
    ```dart
    // From: get_state_manager/src/simple/list_notifier.dart
    // (Inside ListNotifierSingleMixin)
    @protected
    void reportRead() {
      Notifier.instance.read(this);
    }
    ```
3.  `Notifier.instance.read()` checks the `_notifyData` that `StatelessObserverComponent.build()` set up. It finds the `getUpdate` method of our `Obx` widget and subscribes it to the `Rx` variable.
    ```dart
    // From: get_state_manager/src/simple/list_notifier.dart (Notifier class)
    void read(ListNotifierSingleMixin rxVariable) {
      final getStateUpdateFn = _notifyData?.updater; // This is Obx's getUpdate()
       // If Obx's getUpdate is available and not already listening to this rxVariable:
      if (getStateUpdateFn != null && !rxVariable.containsListener(getStateUpdateFn)) {
        // Tell rxVariable: "When you change, call Obx's getUpdate()"
        Disposer disposer = rxVariable.addListener(getStateUpdateFn);
        // And remember how to unsubscribe later
        _notifyData?.disposers.add(disposer);
      }
    }
    ```
So, when `RxVariable.value` changes later, it calls `refresh()` (from `ListNotifierSingleMixin`), which notifies its listeners. One of these listeners is the `Obx` widget's `getUpdate` method, causing the `Obx` widget to rebuild!

## What is `ObxWidget` then?

You'll mostly use `Obx`. `ObxWidget` is simply the base class that `Obx` (and `ObxValue`, another similar widget) extends. It provides the common reactive machinery. Advanced users could extend `ObxWidget` to create their own custom reactive widgets, but for most day-to-day tasks, `Obx` is all you need.

## Conclusion

You've now unlocked a cornerstone of GetX's reactivity: the `Obx` widget! It's your "smart picture frame" that automatically updates your UI when the underlying `Rx<T>` reactive variables change. This makes building dynamic and responsive UIs incredibly simple and efficient.

Typically, your `Rx<T>` variables will live inside a [GetxController](05_getxcontroller_.md) (which we'll cover soon) to keep your UI logic neatly organized. `Obx` then becomes the bridge that connects your controller's state to your visual widgets.

But what if you want to react to changes in `Rx<T>` variables *without* updating the UI? For example, maybe you want to log a message or make an API call when a value changes. For that, GetX provides something called "Workers." Let's explore those in the [next chapter, Chapter 4: Workers](04_workers_.md).
---
# Chapter 4: Workers

In [Chapter 3: Obx / ObxWidget](03_obx___obxwidget_.md), we saw how `Obx` acts like a smart picture frame, automatically updating our UI when reactive variables change. That's perfect for what users see! But what if we want to perform actions *behind the scenes* when our data changes? For instance, what if we need to fetch new data from the internet when a user's ID changes, or automatically save their input after they've stopped typing for a moment? This is where GetX Workers come in!

## What Problem Do Workers Solve?

Imagine you have a reactive variable, say, `userId.obs`. When this `userId` changes, you might want to:
*   Log the change for debugging.
*   Fetch the new user's profile from a server.
*   Update some other non-UI related data.

You don't want to put this logic directly in your UI-building code because it's not about drawing pixels on the screen. It's about reacting to data changes with *side effects*.

**Workers** are your dedicated helpers for exactly this. They are functions that "listen" to your [Rx<T> (Reactive Variables)](02_rx_t___reactive_variables__.md) and execute a callback function when specific events or conditions occur on those variables. Think of them as automated sentinels, tirelessly watching your reactive data streams. When a predefined rule is met (like "the data changed!" or "the user stopped typing!"), they spring into action, independent of direct UI rendering.

## Meet the Workers: Your Automated Sentinels

GetX provides a few different types of Workers, each designed for a specific kind of listening task. Let's meet the main ones: `ever`, `once`, `debounce`, and `interval`.

All these workers are typically set up within the `onInit()` method of a [GetxController](05_getxcontroller_.md) (which we'll cover in the next chapter), or anywhere you have access to your reactive variables and need to react to their changes.

### 1. `ever`: The Ever-Watchful Sentinel

The `ever` worker executes its callback function **every time** the reactive variable it's watching changes.

Let's say we have a reactive variable for a username:
```dart
import 'package:get/get.dart';

final username = 'Guest'.obs; // Our reactive username
```
Now, let's set up an `ever` worker to print a message whenever `username` changes:
```dart
// Typically, you'd do this in onInit() of a GetxController
ever(username, (String newName) {
  print("Username changed to: $newName");
});

// Let's simulate some changes:
username.value = 'Alice';
username.value = 'Bob';
```
**What happens?**
Every time `username.value` is assigned a new value, the `ever` worker's callback `(String newName) { ... }` is triggered.
Output:
```
Username changed to: Alice
Username changed to: Bob
```

You can also add a `condition` to `ever`. The callback will only run if the condition is true when the main variable changes.
```dart
final count = 0.obs;

ever(count, (int newCount) {
  print("Count is now $newCount (and it's greater than 2!)");
}, condition: () => count.value > 2); // Only run if count > 2

count.value = 1; // No output
count.value = 3; // Output: Count is now 3 (and it's greater than 2!)
count.value = 4; // Output: Count is now 4 (and it's greater than 2!)
```

### 2. `once`: The One-Time Sentinel

The `once` worker executes its callback function **only the first time** a specific condition (related to the reactive variable) is met. After it runs once, it automatically stops listening.

Imagine you want to show a welcome message only the very first time a user logs in (i.e., `isLoggedIn.value` becomes `true`).
```dart
final isLoggedIn = false.obs;

once(isLoggedIn, (bool loggedInStatus) {
  if (loggedInStatus == true) {
    print("Welcome! You've logged in for the first time (during this session).");
  }
}, condition: () => isLoggedIn.value == true); // Condition to trigger

isLoggedIn.value = true;  // Triggers 'once'
isLoggedIn.value = false; // 'once' won't trigger again
isLoggedIn.value = true;  // 'once' won't trigger again
```
**What happens?**
The callback is executed only when `isLoggedIn.value` changes *and* the condition `isLoggedIn.value == true` is met for the *first time*.
Output:
```
Welcome! You've logged in for the first time (during this session).
```
Even if `isLoggedIn` becomes `true` again later, `once` has done its job and won't fire again.

### 3. `debounce`: The "Wait-and-See" Sentinel

The `debounce` worker is super useful for scenarios like search fields. It waits for a certain period of inactivity before executing the callback. If the variable changes again before the waiting period is over, the timer resets.

Imagine a search bar. You don't want to make an API call for every single letter the user types. Instead, you want to wait until they pause typing.
```dart
final searchQuery = ''.obs;

debounce(searchQuery, (String query) {
  print("User stopped typing. Search for: $query");
  // In a real app, you'd make an API call here: fetchResults(query);
}, time: Duration(milliseconds: 500)); // Wait for 500ms of inactivity

// Simulate typing quickly, then pausing
searchQuery.value = 'h';
searchQuery.value = 'he';
searchQuery.value = 'hel'; // Timer resets each time
// User pauses... after 500ms:
// Output: User stopped typing. Search for: hel
```
**What happens?**
*   User types 'h', then 'e', then 'l' quickly. The `debounce` timer keeps resetting.
*   After 'hel', if the user pauses for 500 milliseconds, the callback `(String query) { ... }` is executed with the latest value ('hel').
*   If they type 'lo' next, the same process repeats.

### 4. `interval`: The "Periodic Check-up" Sentinel

The `interval` worker is a bit like `debounce` but it triggers its callback with the value that the reactive variable had at the *beginning* of the interval, after a specified duration has passed, and *only if* no new changes occurred during that interval (this behavior can be subtle, often `debounce` is what people want for "after a delay"). It's more like "if nothing changes for X time, then act on the value from X time ago".

A more common use of a timed worker might be "check something every X seconds while a condition is true." `interval` is designed to trigger *after* a period of stability. If you rapidly change the value, `interval` might not fire for each change because a new event interrupts the "quiet period" it's waiting for.

Let's consider a scenario where you want to perform an action if a value remains stable for a certain period.
```dart
final status = 'idle'.obs;

interval(status, (String currentStatus) {
  print("Status has been '$currentStatus' for 1 second.");
}, time: Duration(seconds: 1));

status.value = 'processing'; // Worker starts listening
// If 'status' remains 'processing' for 1 second:
// Output: Status has been 'processing' for 1 second.

// If you change it quickly:
// status.value = 'A';
// await Future.delayed(Duration(milliseconds: 200));
// status.value = 'B'; // 'A' might not trigger the interval callback
```
**What happens?**
If `status.value` becomes 'processing' and stays 'processing' for 1 second without any other changes to `status`, the callback will fire. If `status` changes again *within* that 1-second window, the timer for the *previous* value is essentially reset/ignored, and a new interval evaluation potentially begins for the new value. `debounce` is often more intuitive for "do something after a pause."

For `interval`, the primary mechanism is: when an event arrives, it waits for `time`. If another event arrives *before* `time` is up, the first event is effectively ignored by that specific `interval`'s timer. When `time` *does* elapse without a new event, the callback is fired with the value that was present when the `time` period began.


## Disposing of Workers

Workers, like `StreamSubscription`s in Dart, need to be disposed of when they are no longer needed. This is crucial to prevent memory leaks and unwanted behavior, especially if the reactive variable they are listening to outlives the context where the worker was created.

When you create a worker, it returns a `Worker` object. This object has a `dispose()` method:
```dart
final count = 0.obs;
late Worker everWorker; // Declare the worker variable

// In onInit() or similar setup:
everWorker = ever(count, (_) => print('Count changed!'));

// ... later, when this logic is no longer needed (e.g., in onClose() of a GetxController):
void cleanup() {
  everWorker.dispose();
  print("Ever worker disposed.");
}

count.value = 1; // Output: Count changed!
cleanup();
count.value = 2; // No output, because the worker is disposed.
```

It's a common pattern to initialize workers in the `onInit()` method of a [GetxController](05_getxcontroller_.md) and dispose of them in its `onClose()` method. GetX also provides a way to automatically manage this if workers are declared inside a controller, but manual disposal is good practice to understand.

## Under the Hood: How Do Workers... Work?

Workers function by subscribing to the underlying stream of an [Rx<T> (Reactive Variables)](02_rx_t___reactive_variables__.md). Remember from Chapter 2 that `Rx` variables can notify listeners when they change? Workers are specialized listeners.

1.  **Subscription:** When you create a worker (e.g., `ever(myRxVar, callback)`), the worker function internally calls `myRxVar.listen(...)`. This is similar to listening to a Dart `Stream`.
2.  **Event Emission:** When `myRxVar.value` changes, `myRxVar` emits this new value to its listeners.
3.  **Worker Logic:** The worker receives this new value.
    *   For `ever`, it typically checks an optional condition and then calls your callback.
    *   For `once`, it does the same but also cancels its own subscription after the first valid trigger.
    *   For `debounce`, it uses a timer (like the `Debouncer` utility class in GetX). Each new event resets the timer. If the timer completes, the callback is called with the *last* event received.
    *   For `interval`, it also uses a timer. When an event arrives, it starts a timer. If the timer completes *without* a new event arriving, it calls the callback with the event that started that timer.
4.  **Callback Execution:** If the worker's specific logic decides it's time, your provided callback function is executed with the relevant value.

Heres a simplified sequence diagram showing a `debounce` worker in action:

```mermaid
sequenceDiagram
    participant UserAction as User Typing
    participant SearchRx as searchQuery.obs
    participant DebounceWorker as Debounce Logic
    participant YourCallback as (query) => API.search(query)

    UserAction->>SearchRx: searchQuery.value = "flut"
    SearchRx-->>DebounceWorker: Notifies with "flut"
    DebounceWorker->>DebounceWorker: Starts/Resets 500ms timer
    UserAction->>SearchRx: searchQuery.value = "flutter"
    SearchRx-->>DebounceWorker: Notifies with "flutter"
    DebounceWorker->>DebounceWorker: Resets 500ms timer (for "flutter")
    Note over DebounceWorker: User pauses typing...
    DebounceWorker-->>YourCallback: After 500ms, calls YourCallback("flutter")
```

The actual implementation can be found in `get_rx/src/rx_workers/rx_workers.dart`.
For example, the `ever` worker (simplified):
```dart
// From: get_rx/src/rx_workers/rx_workers.dart (conceptual)
Worker ever<T>(
  GetListenable<T> listener, // This is your Rx variable
  WorkerCallback<T> callback, {
  dynamic condition = true, // Optional condition
  /* ... other params ... */
}) {
  // 1. Listen to the Rx variable's stream
  StreamSubscription sub = listener.listen(
    (event) { // 'event' is the new value from the Rx variable
      // 2. Check the condition
      if (_conditional(condition)) { // _conditional is a helper
        // 3. Execute your callback
        callback(event);
      }
    },
    /* ... onError, onDone ... */
  );
  // 4. Return a Worker object that can be used to cancel the subscription
  return Worker(sub.cancel, '[ever]');
}
```
The `_conditional` function (also in `rx_workers.dart`) is a utility that evaluates the `condition` argument, which can be a `bool` or a `bool Function()`.

The `debounce` worker uses a `Debouncer` utility class (found in `get_rx/src/rx_workers/utils/debouncer.dart`):
```dart
// From: get_rx/src/rx_workers/rx_workers.dart (conceptual)
Worker debounce<T>(
  GetListenable<T> listener,
  WorkerCallback<T> callback, {
  Duration? time, /* ... */
}) {
  // 1. Create a Debouncer instance
  final newDebouncer = Debouncer(delay: time ?? Duration(milliseconds: 800));
  StreamSubscription sub = listener.listen(
    (event) {
      // 2. When Rx variable changes, call the debouncer
      newDebouncer(() {
        // 3. Debouncer will execute this only after the 'delay'
        callback(event);
      });
    }, /* ... */
  );
  return Worker(sub.cancel, '[debounce]');
}
```
The `Debouncer` class itself manages a `Timer` to achieve the "wait for inactivity" behavior.

## Conclusion

Workers (`ever`, `once`,  `debounce`, `interval`) are powerful tools in GetX for reacting to changes in your [Rx<T> (Reactive Variables)](02_rx_t___reactive_variables__.md) by performing side effects like API calls, logging, or triggering other logic that isn't directly tied to UI updates. They help you keep your code clean by separating these concerns. Remember to always `dispose()` your workers when they're no longer needed to keep your app running smoothly.

Now that we've seen how to create reactive data (`Rx<T>`), how to make our UI react to it (`Obx`), and how to perform side effects based on it (Workers), it's time to look at how to organize all this reactive goodness. In the [next chapter, Chapter 5: GetxController](05_getxcontroller_.md), we'll explore `GetxController`, the recommended way to encapsulate your business logic and reactive state.

Relevant Code Snippets (Code itself remains unchanged):
--- File: get_state_manager/src/simple/list_notifier.dart ---
import 'dart:collection';

import 'package:flutter/foundation.dart';

// This callback remove the listener on addListener function
typedef Disposer = void Function();

// replacing StateSetter, return if the Widget is mounted for extra validation.
// if it brings overhead the extra call,
typedef GetStateUpdate = void Function();

class ListNotifier extends Listenable
    with ListNotifierSingleMixin, ListNotifierGroupMixin {}

/// A Notifier with single listeners
class ListNotifierSingle = ListNotifier with ListNotifierSingleMixin;

/// A notifier with group of listeners identified by id
class ListNotifierGroup = ListNotifier with ListNotifierGroupMixin;

/// This mixin add to Listenable the addListener, removerListener and
/// containsListener implementation
mixin ListNotifierSingleMixin on Listenable {
  List<GetStateUpdate>? _updaters = <GetStateUpdate>[];

  // final int _version = 0;
  // final int _microtaskVersion = 0;

  @override
  Disposer addListener(GetStateUpdate listener) {
    assert(_debugAssertNotDisposed());
    _updaters!.add(listener);
    return () => _updaters!.remove(listener);
  }

  bool containsListener(GetStateUpdate listener) {
    return _updaters?.contains(listener) ?? false;
  }

  @override
  void removeListener(VoidCallback listener) {
    assert(_debugAssertNotDisposed());
    _updaters!.remove(listener);
  }

  @protected
  void refresh() {
    assert(_debugAssertNotDisposed());
    _notifyUpdate();
  }

  @protected
  void reportRead() {
    Notifier.instance.read(this);
  }

  @protected
  void reportAdd(VoidCallback disposer) {
    Notifier.instance.add(disposer);
  }

  void _notifyUpdate() {
    // if (_microtaskVersion == _version) {
    //   _microtaskVersion++;
    //   scheduleMicrotask(() {
    //     _version++;
    //     _microtaskVersion = _version;
    final list = _updaters?.toList() ?? [];

    for (var element in list) {
      element();
    }
    //   });
    // }
  }

  bool get isDisposed => _updaters == null;

  bool _debugAssertNotDisposed() {
    assert(() {
      if (isDisposed) {
        throw FlutterError('''A $runtimeType was used after being disposed.\n
'Once you have called dispose() on a $runtimeType, it can no longer be used.''');
      }
      return true;
    }());
    return true;
  }

  int get listenersLength {
    assert(_debugAssertNotDisposed());
    return _updaters!.length;
  }

  @mustCallSuper
  void dispose() {
    assert(_debugAssertNotDisposed());
    _updaters = null;
  }
}

mixin ListNotifierGroupMixin on Listenable {
  HashMap<Object?, ListNotifierSingleMixin>? _updatersGroupIds =
      HashMap<Object?, ListNotifierSingleMixin>();

  void _notifyGroupUpdate(Object id) {
    if (_updatersGroupIds!.containsKey(id)) {
      _updatersGroupIds![id]!._notifyUpdate();
    }
  }

  @protected
  void notifyGroupChildrens(Object id) {
    assert(_debugAssertNotDisposed());
    Notifier.instance.read(_updatersGroupIds![id]!);
  }

  bool containsId(Object id) {
    return _updatersGroupIds?.containsKey(id) ?? false;
  }

  @protected
  void refreshGroup(Object id) {
    assert(_debugAssertNotDisposed());
    _notifyGroupUpdate(id);
  }

  bool _debugAssertNotDisposed() {
    assert(() {
      if (_updatersGroupIds == null) {
        throw FlutterError('''A $runtimeType was used after being disposed.\n
'Once you have called dispose() on a $runtimeType, it can no longer be used.''');
      }
      return true;
    }());
    return true;
  }

  void removeListenerId(Object id, VoidCallback listener) {
    assert(_debugAssertNotDisposed());
    if (_updatersGroupIds!.containsKey(id)) {
      _updatersGroupIds![id]!.removeListener(listener);
    }
  }

  @mustCallSuper
  void dispose() {
    assert(_debugAssertNotDisposed());
    _updatersGroupIds?.forEach((key, value) => value.dispose());
    _updatersGroupIds = null;
  }

  Disposer addListenerId(Object? key, GetStateUpdate listener) {
    _updatersGroupIds![key] ??= ListNotifierSingle();
    return _updatersGroupIds![key]!.addListener(listener);
  }

  /// To dispose an [id] from future updates(), this ids are registered
  /// by `GetBuilder()` or similar, so is a way to unlink the state change with
  /// the Widget from the Controller.
  void disposeId(Object id) {
    _updatersGroupIds?[id]?.dispose();
    _updatersGroupIds!.remove(id);
  }
}

class Notifier {
  Notifier._();

  static Notifier? _instance;
  static Notifier get instance => _instance ??= Notifier._();

  NotifyData? _notifyData;

  void add(VoidCallback listener) {
    _notifyData?.disposers.add(listener);
  }

  void read(ListNotifierSingleMixin updaters) {
    final listener = _notifyData?.updater;
    if (listener != null && !updaters.containsListener(listener)) {
      updaters.addListener(listener);
      add(() => updaters.removeListener(listener));
    }
  }

  T append<T>(NotifyData data, T Function() builder) {
    _notifyData = data;
    final result = builder();
    if (data.disposers.isEmpty && data.throwException) {
      throw const ObxError();
    }
    _notifyData = null;
    return result;
  }
}

class NotifyData {
  const NotifyData(
      {required this.updater,
      required this.disposers,
      this.throwException = true});
  final GetStateUpdate updater;
  final List<VoidCallback> disposers;
  final bool throwException;
}

class ObxError {
  const ObxError();
  @override
  String toString() {
    return """
      [Get] the improper use of a GetX has been detected. 
      You should only use GetX or Obx for the specific widget that will be updated.
      If you are seeing this error, you probably did not insert any observable variables into GetX/Obx 
      or insert them outside the scope that GetX considers suitable for an update 
      (example: GetX => HeavyWidget => variableObservable).
      If you need to update a parent widget and a child widget, wrap each one in an Obx/GetX.
      """;
  }
}


--- File: get_state_manager/src/simple/get_state.dart ---
// ignore_for_file: overridden_fields

import 'dart:async';

import 'package:flutter/material.dart';

import '../../../instance_manager.dart';
import '../../get_state_manager.dart';
import 'list_notifier.dart';

typedef InitBuilder<T> = T Function();

typedef GetControllerBuilder<T extends GetLifeCycleMixin> = Widget Function(
    T controller);

extension WatchExt on BuildContext {
  T listen<T>() {
    return Bind.of(this, rebuild: true);
  }
}

extension ReadExt on BuildContext {
  T get<T>() {
    return Bind.of(this);
  }
}

// extension FilterExt on BuildContext {
//   T filter<T extends GetxController>(Object Function(T value)? filter) {
//     return Bind.of(this, filter: filter, rebuild: true);
//   }
// }

class GetBuilder<T extends GetxController> extends StatelessWidget {
  final GetControllerBuilder<T> builder;
  final bool global;
  final Object? id;
  final String? tag;
  final bool autoRemove;
  final bool assignId;
  final Object Function(T value)? filter;
  final void Function(BindElement<T> state)? initState,
      dispose,
      didChangeDependencies;
  final void Function(Binder<T> oldWidget, BindElement<T> state)?
      didUpdateWidget;
  final T? init;

  const GetBuilder({
    super.key,
    this.init,
    this.global = true,
    required this.builder,
    this.autoRemove = true,
    this.assignId = false,
    this.initState,
    this.filter,
    this.tag,
    this.dispose,
    this.id,
    this.didChangeDependencies,
    this.didUpdateWidget,
  });

  @override
  Widget build(BuildContext context) {
    return Binder(
      init: init == null ? null : () => init!,
      global: global,
      autoRemove: autoRemove,
      assignId: assignId,
      initState: initState,
      filter: filter,
      tag: tag,
      dispose: dispose,
      id: id,
      lazy: false,
      didChangeDependencies: didChangeDependencies,
      didUpdateWidget: didUpdateWidget,
      child: Builder(builder: (context) {
        final controller = Bind.of<T>(context, rebuild: true);
        return builder(controller);
      }),
    );
    // return widget.builder(controller!);
  }
}

abstract class Bind<T> extends StatelessWidget {
  const Bind({
    super.key,
    required this.child,
    this.init,
    this.global = true,
    this.autoRemove = true,
    this.assignId = false,
    this.initState,
    this.filter,
    this.tag,
    this.dispose,
    this.id,
    this.didChangeDependencies,
    this.didUpdateWidget,
  });

  final InitBuilder<T>? init;

  final bool global;
  final Object? id;
  final String? tag;
  final bool autoRemove;
  final bool assignId;
  final Object Function(T value)? filter;
  final void Function(BindElement<T> state)? initState,
      dispose,
      didChangeDependencies;
  final void Function(Binder<T> oldWidget, BindElement<T> state)?
      didUpdateWidget;

  final Widget? child;

  static Bind put<S>(
    S dependency, {
    String? tag,
    bool permanent = false,
  }) {
    Get.put<S>(dependency, tag: tag, permanent: permanent);
    return _FactoryBind<S>(
      autoRemove: permanent,
      assignId: true,
      tag: tag,
    );
  }

  static bool fenixMode = false;

  static Bind lazyPut<S>(
    InstanceBuilderCallback<S> builder, {
    String? tag,
    bool? fenix,
    // VoidCallback? onInit,
    VoidCallback? onClose,
  }) {
    Get.lazyPut<S>(builder, tag: tag, fenix: fenix ?? fenixMode);
    return _FactoryBind<S>(
      tag: tag,
      // initState: (_) {
      //   onInit?.call();
      // },
      dispose: (_) {
        onClose?.call();
      },
    );
  }

  static Bind create<S>(InstanceCreateBuilderCallback<S> builder,
      {String? tag, bool permanent = true}) {
    return _FactoryBind<S>(
      create: builder,
      tag: tag,
      global: false,
    );
  }

  static Bind spawn<S>(InstanceBuilderCallback<S> builder,
      {String? tag, bool permanent = true}) {
    Get.spawn<S>(builder, tag: tag, permanent: permanent);
    return _FactoryBind<S>(
      tag: tag,
      global: false,
      autoRemove: permanent,
    );
  }

  static S find<S>({String? tag}) => Get.find<S>(tag: tag);

  static Future<bool> delete<S>({String? tag, bool force = false}) async =>
      Get.delete<S>(tag: tag, force: force);

  static Future<void> deleteAll({bool force = false}) async =>
      Get.deleteAll(force: force);

  static void reloadAll({bool force = false}) => Get.reloadAll(force: force);

  static void reload<S>({String? tag, String? key, bool force = false}) =>
      Get.reload<S>(tag: tag, key: key, force: force);

  static bool isRegistered<S>({String? tag}) => Get.isRegistered<S>(tag: tag);

  static bool isPrepared<S>({String? tag}) => Get.isPrepared<S>(tag: tag);

  static void replace<P>(P child, {String? tag}) {
    final info = Get.getInstanceInfo<P>(tag: tag);
    final permanent = (info.isPermanent ?? false);
    delete<P>(tag: tag, force: permanent);
    Get.put(child, tag: tag, permanent: permanent);
  }

  static void lazyReplace<P>(InstanceBuilderCallback<P> builder,
      {String? tag, bool? fenix}) {
    final info = Get.getInstanceInfo<P>(tag: tag);
    final permanent = (info.isPermanent ?? false);
    delete<P>(tag: tag, force: permanent);
    Get.lazyPut(builder, tag: tag, fenix: fenix ?? permanent);
  }

  factory Bind.builder({
    Widget? child,
    InitBuilder<T>? init,
    InstanceCreateBuilderCallback<T>? create,
    bool global = true,
    bool autoRemove = true,
    bool assignId = false,
    Object Function(T value)? filter,
    String? tag,
    Object? id,
    void Function(BindElement<T> state)? initState,
    void Function(BindElement<T> state)? dispose,
    void Function(BindElement<T> state)? didChangeDependencies,
    void Function(Binder<T> oldWidget, BindElement<T> state)? didUpdateWidget,
  }) =>
      _FactoryBind<T>(
        // key: key,
        init: init,
        create: create,
        global: global,
        autoRemove: autoRemove,
        assignId: assignId,
        initState: initState,
        filter: filter,
        tag: tag,
        dispose: dispose,
        id: id,
        didChangeDependencies: didChangeDependencies,
        didUpdateWidget: didUpdateWidget,
        child: child,
      );

  static T of<T>(
    BuildContext context, {
    bool rebuild = false,
    // Object Function(T value)? filter,
  }) {
    final inheritedElement =
        context.getElementForInheritedWidgetOfExactType<Binder<T>>()
            as BindElement<T>?;

    if (inheritedElement == null) {
      throw BindError(controller: '$T', tag: null);
    }

    if (rebuild) {
      // var newFilter = filter?.call(inheritedElement.controller!);
      // if (newFilter != null) {
      //  context.dependOnInheritedElement(inheritedElement, aspect: newFilter);
      // } else {
      context.dependOnInheritedElement(inheritedElement);
      // }
    }

    final controller = inheritedElement.controller;

    return controller;
  }

  @factory
  Bind<T> _copyWithChild(Widget child);
}

class _FactoryBind<T> extends Bind<T> {
  @override
  final InitBuilder<T>? init;

  final InstanceCreateBuilderCallback<T>? create;

  @override
  final bool global;
  @override
  final Object? id;
  @override
  final String? tag;
  @override
  final bool autoRemove;
  @override
  final bool assignId;
  @override
  final Object Function(T value)? filter;

  @override
  final void Function(BindElement<T> state)? initState,
      dispose,
      didChangeDependencies;
  @override
  final void Function(Binder<T> oldWidget, BindElement<T> state)?
      didUpdateWidget;

  @override
  final Widget? child;

  const _FactoryBind({
    super.key,
    this.child,
    this.init,
    this.create,
    this.global = true,
    this.autoRemove = true,
    this.assignId = false,
    this.initState,
    this.filter,
    this.tag,
    this.dispose,
    this.id,
    this.didChangeDependencies,
    this.didUpdateWidget,
  }) : super(child: child);

  @override
  Bind<T> _copyWithChild(Widget child) {
    return Bind<T>.builder(
      init: init,
      create: create,
      global: global,
      autoRemove: autoRemove,
      assignId: assignId,
      initState: initState,
      filter: filter,
      tag: tag,
      dispose: dispose,
      id: id,
      didChangeDependencies: didChangeDependencies,
      didUpdateWidget: didUpdateWidget,
      child: child,
    );
  }

  @override
  Widget build(BuildContext context) {
    return Binder<T>(
      create: create,
      global: global,
      autoRemove: autoRemove,
      assignId: assignId,
      initState: initState,
      filter: filter,
      tag: tag,
      dispose: dispose,
      id: id,
      didChangeDependencies: didChangeDependencies,
      didUpdateWidget: didUpdateWidget,
      child: child!,
    );
  }
}

class Binds extends StatelessWidget {
  final List<Bind<dynamic>> binds;
  final Widget child;

  Binds({
    super.key,
    required this.binds,
    required this.child,
  }) : assert(binds.isNotEmpty);

  @override
  Widget build(BuildContext context) =>
      binds.reversed.fold(child, (widget, e) => e._copyWithChild(widget));
}

class Binder<T> extends InheritedWidget {
  /// Create an inherited widget that updates its dependents when [controller]
  /// sends notifications.
  ///
  /// The [child] argument is required
  const Binder({
    super.key,
    required super.child,
    this.init,
    this.global = true,
    this.autoRemove = true,
    this.assignId = false,
    this.lazy = true,
    this.initState,
    this.filter,
    this.tag,
    this.dispose,
    this.id,
    this.didChangeDependencies,
    this.didUpdateWidget,
    this.create,
  });

  final InitBuilder<T>? init;
  final InstanceCreateBuilderCallback? create;
  final bool global;
  final Object? id;
  final String? tag;
  final bool lazy;
  final bool autoRemove;
  final bool assignId;
  final Object Function(T value)? filter;
  final void Function(BindElement<T> state)? initState,
      dispose,
      didChangeDependencies;
  final void Function(Binder<T> oldWidget, BindElement<T> state)?
      didUpdateWidget;

  @override
  bool updateShouldNotify(Binder<T> oldWidget) {
    return oldWidget.id != id ||
        oldWidget.global != global ||
        oldWidget.autoRemove != autoRemove ||
        oldWidget.assignId != assignId;
  }

  @override
  InheritedElement createElement() => BindElement<T>(this);
}

/// The BindElement is responsible for injecting dependencies into the widget
/// tree so that they can be observed
class BindElement<T> extends InheritedElement {
  BindElement(Binder<T> super.widget) {
    initState();
  }

  final disposers = <Disposer>[];

  InitBuilder<T>? _controllerBuilder;

  T? _controller;

  T get controller {
    if (_controller == null) {
      _controller = _controllerBuilder?.call();
      _subscribeToController();
      if (_controller == null) {
        throw BindError(controller: T, tag: widget.tag);
      }
      return _controller!;
    } else {
      return _controller!;
    }
  }

  bool? _isCreator = false;
  bool? _needStart = false;
  bool _wasStarted = false;
  VoidCallback? _remove;
  Object? _filter;

  void initState() {
    widget.initState?.call(this);

    var isRegistered = Get.isRegistered<T>(tag: widget.tag);

    if (widget.global) {
      if (isRegistered) {
        if (Get.isPrepared<T>(tag: widget.tag)) {
          _isCreator = true;
        } else {
          _isCreator = false;
        }

        _controllerBuilder = () => Get.find<T>(tag: widget.tag);
      } else {
        _controllerBuilder =
            () => (widget.create?.call(this) ?? widget.init?.call());
        _isCreator = true;
        if (widget.lazy) {
          Get.lazyPut<T>(_controllerBuilder!, tag: widget.tag);
        } else {
          Get.put<T>(_controllerBuilder!(), tag: widget.tag);
        }
      }
    } else {
      if (widget.create != null) {
        _controllerBuilder = () => widget.create!.call(this);
        Get.spawn<T>(_controllerBuilder!, tag: widget.tag, permanent: false);
      } else {
        _controllerBuilder = widget.init;
      }
      _controllerBuilder =
          (widget.create != null ? () => widget.create!.call(this) : null) ??
              widget.init;
      _isCreator = true;
      _needStart = true;
    }
  }

  /// Register to listen Controller's events.
  /// It gets a reference to the remove() callback, to delete the
  /// setState "link" from the Controller.
  void _subscribeToController() {
    if (widget.filter != null) {
      _filter = widget.filter!(_controller as T);
    }
    final filter = _filter != null ? _filterUpdate : getUpdate;
    final localController = _controller;

    if (_needStart == true && localController is GetLifeCycleMixin) {
      localController.onStart();
      _needStart = false;
      _wasStarted = true;
    }

    if (localController is GetxController) {
      _remove?.call();
      _remove = (widget.id == null)
          ? localController.addListener(filter)
          : localController.addListenerId(widget.id, filter);
    } else if (localController is Listenable) {
      _remove?.call();
      localController.addListener(filter);
      _remove = () => localController.removeListener(filter);
    } else if (localController is StreamController) {
      _remove?.call();
      final stream = localController.stream.listen((_) => filter());
      _remove = () => stream.cancel();
    }
  }

  void _filterUpdate() {
    var newFilter = widget.filter!(_controller as T);
    if (newFilter != _filter) {
      _filter = newFilter;
      getUpdate();
    }
  }

  void dispose() {
    widget.dispose?.call(this);
    if (_isCreator! || widget.assignId) {
      if (widget.autoRemove && Get.isRegistered<T>(tag: widget.tag)) {
        Get.delete<T>(tag: widget.tag);
      }
    }

    for (final disposer in disposers) {
      disposer();
    }

    disposers.clear();

    _remove?.call();
    _controller = null;
    _isCreator = null;
    _remove = null;
    _filter = null;
    _needStart = null;
    _controllerBuilder = null;
    _controller = null;
  }

  @override
  Binder<T> get widget => super.widget as Binder<T>;

  var _dirty = false;

  @override
  void update(Binder<T> newWidget) {
    final oldNotifier = widget.id;
    final newNotifier = newWidget.id;
    if (oldNotifier != newNotifier && _wasStarted) {
      _subscribeToController();
    }
    widget.didUpdateWidget?.call(widget, this);
    super.update(newWidget);
  }

  @override
  void didChangeDependencies() {
    super.didChangeDependencies();
    widget.didChangeDependencies?.call(this);
  }

  @override
  Widget build() {
    if (_dirty) {
      notifyClients(widget);
    }
    // return Notifier.instance.notifyAppend(
    //   NotifyData(
    //       disposers: disposers, updater: getUpdate, throwException: false),
    return super.build();
    //);
  }

  void getUpdate() {
    _dirty = true;
    markNeedsBuild();
  }

  @override
  void notifyClients(Binder<T> oldWidget) {
    super.notifyClients(oldWidget);
    _dirty = false;
  }

  @override
  void unmount() {
    dispose();
    super.unmount();
  }
}

class BindError<T> extends Error {
  /// The type of the class the user tried to retrieve
  final T controller;
  final String? tag;

  /// Creates a [BindError]
  BindError({required this.controller, required this.tag});

  @override
  String toString() {
    if (controller == 'dynamic') {
      return '''Error: please specify type [<T>] when calling context.listen<T>() or context.find<T>() method.''';
    }

    return '''Error: No Bind<$controller>  ancestor found. To fix this, please add a Bind<$controller> widget ancestor to the current context.
      ''';
  }
}

/// [Binding] should be extended.
/// When using `GetMaterialApp`, all `GetPage`s and navigation
/// methods (like Get.to()) have a `binding` property that takes an
/// instance of Bindings to manage the
/// dependencies() (via Get.put()) for the Route you are opening.
// ignore: one_member_abstracts
abstract class Binding extends BindingsInterface<List<Bind>> {}


--- File: get_state_manager/src/simple/get_controllers.dart ---
// ignore: prefer_mixin
import 'package:flutter/widgets.dart';

import '../../../instance_manager.dart';
import '../rx_flutter/rx_notifier.dart';
import 'list_notifier.dart';

// ignore: prefer_mixin
abstract class GetxController extends ListNotifier with GetLifeCycleMixin {
  /// Rebuilds `GetBuilder` each time you call `update()`;
  /// Can take a List of [ids], that will only update the matching
  /// `GetBuilder( id: )`,
  /// [ids] can be reused among `GetBuilders` like group tags.
  /// The update will only notify the Widgets, if [condition] is true.
  void update([List<Object>? ids, bool condition = true]) {
    if (!condition) {
      return;
    }
    if (ids == null) {
      refresh();
    } else {
      for (final id in ids) {
        refreshGroup(id);
      }
    }
  }
}

/// this mixin allow to fetch data when the scroll is at the bottom or on the
/// top
mixin ScrollMixin on GetLifeCycleMixin {
  final ScrollController scroll = ScrollController();

  @override
  void onInit() {
    super.onInit();
    scroll.addListener(_listener);
  }

  bool _canFetchBottom = true;

  bool _canFetchTop = true;

  void _listener() {
    if (scroll.position.atEdge) {
      _checkIfCanLoadMore();
    }
  }

  Future<void> _checkIfCanLoadMore() async {
    if (scroll.position.pixels == 0) {
      if (!_canFetchTop) return;
      _canFetchTop = false;
      await onTopScroll();
      _canFetchTop = true;
    } else {
      if (!_canFetchBottom) return;
      _canFetchBottom = false;
      await onEndScroll();
      _canFetchBottom = true;
    }
  }

  /// this method is called when the scroll is at the bottom
  Future<void> onEndScroll();

  /// this method is called when the scroll is at the top
  Future<void> onTopScroll();

  @override
  void onClose() {
    scroll.removeListener(_listener);
    super.onClose();
  }
}

/// A clean controller to be used with only Rx variables
abstract class RxController with GetLifeCycleMixin {}

/// A recommended way to use Getx with Future fetching
abstract class StateController<T> extends GetxController with StateMixin<T> {}

/// A controller with super lifecycles (including native lifecycles)
/// and StateMixins
abstract class SuperController<T> extends FullLifeCycleController
    with FullLifeCycleMixin, StateMixin<T> {}

/// A controller with super lifecycles (including native lifecycles)
abstract class FullLifeCycleController extends GetxController
    with
        // ignore: prefer_mixin
        WidgetsBindingObserver {}

mixin FullLifeCycleMixin on FullLifeCycleController {
  @mustCallSuper
  @override
  void onInit() {
    super.onInit();
    Engine.instance.addObserver(this);
  }

  @mustCallSuper
  @override
  void onClose() {
    Engine.instance.removeObserver(this);
    super.onClose();
  }

  @mustCallSuper
  @override
  void didChangeAppLifecycleState(AppLifecycleState state) {
    switch (state) {
      case AppLifecycleState.resumed:
        onResumed();
        break;
      case AppLifecycleState.inactive:
        onInactive();
        break;
      case AppLifecycleState.paused:
        onPaused();
        break;
      case AppLifecycleState.detached:
        onDetached();
        break;
      case AppLifecycleState.hidden:
        onHidden();
        break;
    }
  }

  void onResumed() {}
  void onPaused() {}
  void onInactive() {}
  void onDetached() {}
  void onHidden() {}
}


Instructions for the chapter (Generate content in English unless specified otherwise):
- Start with a clear heading (e.g., `# Chapter 5: GetxController
`). Use the provided concept name.

- If this is not the first chapter, begin with a brief transition from the previous chapter, referencing it with a proper Markdown link using its name.

- Begin with a high-level motivation explaining what problem this abstraction solves. Start with a central use case as a concrete example. The whole chapter should guide the reader to understand how to solve this use case. Make it very minimal and friendly to beginners.

- If the abstraction is complex, break it down into key concepts. Explain each concept one-by-one in a very beginner-friendly way.

- Explain how to use this abstraction to solve the use case. Give example inputs and outputs for code snippets (if the output isn't values, describe at a high level what will happen).

- Each code block should be BELOW 10 lines! If longer code blocks are needed, break them down into smaller pieces and walk through them one-by-one. Aggresively simplify the code to make it minimal. Use comments to skip non-important implementation details. Each code block should have a beginner friendly explanation right after it.

- Describe the internal implementation to help understand what's under the hood. First provide a non-code or code-light walkthrough on what happens step-by-step when the abstraction is called. It's recommended to use a simple sequenceDiagram with a dummy example - keep it minimal with at most 5 participants to ensure clarity. If participant name has space, use: `participant QP as Query Processing`. .

- Then dive deeper into code for the internal implementation with references to files. Provide example code blocks, but make them similarly simple and beginner-friendly. Explain.

- IMPORTANT: When you need to refer to other core abstractions covered in other chapters, ALWAYS use proper Markdown links like this: [Chapter Title](filename.md). Use the Complete Tutorial Structure above to find the correct filename and the chapter title. Translate the surrounding text.

- Use mermaid diagrams to illustrate complex concepts (```mermaid``` format). .

- Heavily use analogies and examples throughout to help beginners understand.

- End the chapter with a brief conclusion that summarizes what was learned and provides a transition to the next chapter. If there is a next chapter, use a proper Markdown link: [Next Chapter Title](next_chapter_filename).

- Ensure the tone is welcoming and easy for a newcomer to understand.

- Output *only* the Markdown content for this chapter.

Now, directly provide a super beginner-friendly Markdown output (DON'T need ```markdown``` tags):

2025-05-12 13:35:59,470 - INFO - RESPONSE: # Chapter 5: GetxController

In [Chapter 4: Workers](04_workers_.md), we learned how to perform actions behind the scenes when_our_reactive data changes. That's great for side effects! But as your app grows, you'll find yourself asking:
*   Where should I keep my app's data (like that `counter.obs` or `searchQuery.obs`)?
*   Where should the functions that change this data (like `incrementCounter()` or `performSearch()`) live?
*   How can I neatly organize all this for a specific feature or screen?

Simply putting reactive variables and functions globally or directly in UI widgets can get messy quickly. We need a dedicated "manager" for different parts of our application. That's where `GetxController` shines!

## What is a GetxController? The Brain of Your Feature!

A `GetxController` is like the **manager** or **"brain"** for a specific part of your app's screen or a particular feature. Think of it as a dedicated organizer. Its main jobs are:

1.  **Holding Data (State):** It stores the variables (often [Rx<T> (Reactive Variables)](02_rx_t___reactive_variables__.md)) that your feature needs. For example, in a counter feature, it would hold the current count.
2.  **Holding Business Logic (Functions):** It contains the functions that operate on this data or perform actions related to the feature. For the counter, this would be the `increment()` function.
3.  **Managing Lifecycle:** It has special methods that get called at different points in its life (like when it's created or destroyed), allowing you to set things up or clean up resources.
4.  **Notifying UI (with `update()`):** When its data changes (especially non-reactive data, or if you need more control), the controller can tell the UI to update by calling its `update()` method. This is primarily used with a widget called `GetBuilder`, which we'll explore in [Chapter 7: GetBuilder](07_getbuilder_.md).

Imagine a scene in a play. The `GetxController` is like the **director** of that scene. It knows the script (logic), manages the actors' states (data), and tells them when and how to change their appearance or behavior.

## How to Use a GetxController

Let's go back to our simple counter example and see how we can organize it using a `GetxController`.

### 1. Creating Your Controller

First, you create a new Dart class that `extends GetxController`.

```dart
// counter_controller.dart
import 'package:get/get.dart';

class CounterController extends GetxController {
  // 1. Hold your reactive data (state)
  final count = 0.obs; // Our familiar RxInt

  // 2. Define your business logic (functions)
  void increment() {
    count.value++;
    // If we were using GetBuilder and non-Rx state, we might call update() here.
  }
}
```
**Explanation:**
*   We created `CounterController` that inherits from `GetxController`.
*   Inside it, we moved our reactive `count` variable.
*   We also moved the `increment` logic into a method within the controller. Now, all things related to the counter's state and logic are neatly bundled together!

### 2. Making the Controller Available (Quick Peek at Dependency Injection)

Before your UI can use the controller, GetX needs to know about it. You "register" your controller, usually when the feature or screen is first needed. The most common way is using `Get.put()`:

```dart
// Somewhere before you need the controller, e.g., when navigating to the page
Get.put(CounterController());
```
**Explanation:**
*   `Get.put(CounterController());` creates an instance of `CounterController` and makes it available for other parts of your app to find.
*   We'll dive deep into `Get.put()` and other ways to manage controllers in [Chapter 6: Dependency Access (Binder, Bind.of, Get.find/put)](06_dependency_access__binder__bind_of__get_find_put__.md). For now, just know this step is necessary.

### 3. Accessing and Using the Controller in Your UI

Once the controller is "put", your UI widgets can find and use it. You use `Get.find()` for this:

```dart
// In your widget file (e.g., counter_page.dart)
import 'package:flutter/material.dart';
import 'package:get/get.dart';
import 'counter_controller.dart'; // Import your controller fine

class CounterPage extends StatelessWidget {
  // Find the instance of CounterController that GetX is managing
  final CounterController controller = Get.find<CounterController>();

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(title: Text("GetxController Counter")),
      body: Center(
        child: Obx(() { // Obx watches reactive variables
          return Text(
            "Count: ${controller.count.value}", // Use controller's data
            style: TextStyle(fontSize: 28),
          );
        }),
      ),
      floatingActionButton: FloatingActionButton(
        onPressed: () {
          controller.increment(); // Call controller's method
        },
        child: Icon(Icons.add),
      ),
    );
  }
}
```
**Explanation:**
*   `final CounterController controller = Get.find<CounterController>();` asks GetX to give us the instance of `CounterController` it's managing.
*   Inside the `Obx` widget (from [Chapter 3: Obx / ObxWidget](03_obx___obxwidget_.md)), we access `controller.count.value` to display the reactive count.
*   In `onPressed` for the button, we call `controller.increment()` to execute the logic defined in our controller.

Now, run this app. It works just like our previous counter, but the state and logic are much better organized within `CounterController`!

### Controller Lifecycle: `onInit()`, `onReady()`, `onClose()`

`GetxController`s have a lifecycle, meaning special methods are called automatically at certain points:

*   **`onInit()`:** Called right after the controller is allocated in memory (after its constructor) but *before* the widget that uses it is built for the first time. This is the perfect place to:
    *   Initialize data.
    *   Set up [Workers](04_workers_.md) to listen to reactive variable changes.
    *   Make initial API calls.

    ```dart
    class MyController extends GetxController {
      var data = ''.obs;

      @override
      void onInit() {
        super.onInit(); // Always call super.onInit()
        print("MyController onInit!");
        // Example: Fetch initial data or set up a worker
        ever(data, (_) => print("Data changed in MyController: ${data.value}"));
        data.value = "Initial Data";
      }
    }
    ```
    Output (when `MyController` is `put`):
    ```
    MyController onInit!
    Data changed in MyController: Initial Data
    ```

*   **`onReady()`:** Called a moment *after* the widget associated with this controller is rendered on screen for the first time. Useful if you need to do something *after* the UI is visible (e.g., show an intro animation or dialog).

    ```dart
    class MyController extends GetxController {
      @override
      void onReady() {
        super.onReady(); // Always call super.onReady()
        print("MyController onReady! UI is now visible.");
        // Get.snackbar("Hint", "Controller is ready and UI is built!");
      }
    }
    ```

*   **`onClose()`:** Called just before the controller is removed from memory. This happens when it's no longer needed (e.g., the screen is closed, or `Get.delete<MyController>()` is called). This is crucial for:
    *   Cleaning up resources.
    *   Disposing of [Workers](04_workers_.md).
    *   Canceling stream subscriptions or closing database connections to prevent memory leaks.

    ```dart
    class MyController extends GetxController {
      late Worker _dataWorker;
      var data = ''.obs;

      @override
      void onInit() {
        super.onInit();
        _dataWorker = ever(data, (_) => print("Data: ${data.value}"));
      }

      @override
      void onClose() {
        print("MyController onClose! Cleaning up.");
        _dataWorker.dispose(); // IMPORTANT: Dispose workers!
        super.onClose(); // Always call super.onClose()
      }
    }
    ```
    **Explanation:** If you create workers, timers, or other listeners in `onInit()`, you *must* clean them up in `onClose()` to avoid problems.

### The `update()` Method: For Manual UI Refreshes

So far, our counter UI updates automatically because `count` is an `RxInt` and we're using `Obx`. `Obx` rebuilds when `count.value` changes.

However, sometimes you might have:
*   Regular Dart variables (not `.obs`) in your controller.
*   Complex logic where you want to decide *exactly* when to tell the UI to refresh.

For these "manual" updates, `GetxController` provides the `update()` method. When you call `update()` from within your controller, it signals to any `GetBuilder` widgets listening to this controller that they should rebuild.

```dart
class ManualUpdateController extends GetxController {
  int manualCount = 0; // A regular int, not reactive

  void incrementManualCount() {
    manualCount++;
    update(); // Tell listening GetBuilders to refresh!
    print("Manual count incremented: $manualCount. Update called.");
  }
}
```
**Explanation:**
*   `manualCount` is just a normal integer.
*   When `incrementManualCount()` is called, it changes `manualCount` and then calls `update()`.
*   This `update()` call will trigger any `GetBuilder` associated with this `ManualUpdateController` to rebuild itself and display the new `manualCount`.

We'll learn all about `GetBuilder` in [Chapter 7: GetBuilder](07_getbuilder_.md). For now, understand that `update()` is the controller's way of manually triggering UI refreshes for widgets that use `GetBuilder`.

## Under the Hood: What Makes a GetxController Tick?

A `GetxController` isn't just an empty class. It gets its powers from a few key pieces in the GetX framework:

*   It `extends ListNotifier` (from `get_state_manager/src/simple/list_notifier.dart`).
*   `ListNotifier` mixes in `GetLifeCycleMixin` (from `get_state_manager/src/rx_flutter/rx_notifier.dart` indirectly through its own mixins or base classes).

Let's see what these provide:

1.  **`GetLifeCycleMixin`:** This mixin is responsible for the lifecycle methods (`onInit`, `onReady`, `onClose`). When a controller is `put` using `Get.put()`, GetX's dependency management system knows it's a `GetLifeCycleMixin` and hooks into its lifecycle, calling these methods at the appropriate times. It also handles cleaning up the controller (calling `onClose`) when it's deleted (e.g., with `Get.delete()`).

2.  **`ListNotifier` (and its `ListNotifierSingleMixin`):** This is the heart of the manual `update()` mechanism.
    *   It maintains a list of listeners (callbacks).
    *   When you call `update()` in your controller, it actually calls `refresh()` (a method from `ListNotifierSingleMixin`).
    *   `refresh()` then iterates through all its registered listeners and calls them.
    *   Widgets like `GetBuilder` (which we'll see in [Chapter 7: GetBuilder](07_getbuilder_.md)) add themselves as listeners to the controller. So, when `refresh()` is called, the `GetBuilder`'s "update me" function gets executed, causing it to rebuild.

Here's a simplified conceptual flow for the `update()` mechanism:

```mermaid
sequenceDiagram
    participant UserAction as User Taps Button
    participant YourController as MyController
    participant ListNotifierMixin as (Part of MyController)
    participant GetBuilderWidget as GetBuilder (UI Widget)

    UserAction->>YourController: Calls controller.someMethod()
    YourController->>YourController: Logic updates non-Rx state (e.g., `manualCount++`)
    YourController->>ListNotifierMixin: Calls this.update()
    Note over ListNotifierMixin: update() internally calls refresh()
    ListNotifierMixin-->>GetBuilderWidget: Notifies its listener (the GetBuilder's update function)
    GetBuilderWidget->>GetBuilderWidget: Rebuilds itself to show new state
```

The actual code in `GetxController` for `update()` is quite simple:
```dart
// From: get_state_manager/src/simple/get_controllers.dart
abstract class GetxController extends ListNotifier with GetLifeCycleMixin {
  void update([List<Object>? ids, bool condition = true]) {
    if (!condition) {
      return;
    }
    if (ids == null) {
      refresh(); // From ListNotifierSingleMixin
    } else {
      for (final id in ids) {
        refreshGroup(id); // Also from ListNotifier, for targeted updates
      }
    }
  }
}
```
And `refresh()` in `ListNotifierSingleMixin` (simplified):
```dart
// From: get_state_manager/src/simple/list_notifier.dart
mixin ListNotifierSingleMixin on Listenable {
  List<GetStateUpdate>? _updaters = <GetStateUpdate>[]; // List of listeners

  // ... other methods ...

  @protected
  void refresh() {
    // Take a copy of listeners, in case list changes during iteration
    final list = _updaters?.toList() ?? [];
    for (var element in list) {
      element(); // Call each listener (e.g., GetBuilder's update function)
    }
  }
}
```
So, `GetxController` elegantly combines lifecycle management with a notification system to manage state and communicate changes to the UI.

## Conclusion

You've now met `GetxController`, the cornerstone for organizing your application's state and logic in GetX! It acts as a dedicated manager for your features or screen sections, holding data (often reactive), business logic, and providing lifecycle hooks (`onInit`, `onClose`) for setup and cleanup. You also learned about its `update()` method, which is essential for manually refreshing UI parts when using `GetBuilder`.

By using `GetxController`, you can create cleaner, more maintainable, and better-structured Flutter applications.

We've seen how to *create* controllers and *make them available* with a quick `Get.put()`. But how exactly does GetX manage these controllers? How many ways are there to "put" and "find" them? That's what we'll explore next in [Chapter 6: Dependency Access (Binder, Bind.of, Get.find/put)](06_dependency_access__binder__bind_of__get_find_put__.md).
2025-05-12 13:35:59,538 - INFO - PROMPT: 
Write a very beginner-friendly tutorial chapter (in Markdown format) for the project `lib` about the concept: "Dependency Access (Binder, Bind.of, Get.find/put)
". This is Chapter 6.

Concept Details:
- Name: Dependency Access (Binder, Bind.of, Get.find/put)

- Description:
GetX provides ways to manage and access your "dependencies" (like `GetxController` instances) throughout your app.
`Get.put()` registers a dependency. `Binder` is an `InheritedWidget` that provides these
dependencies down the widget tree, allowing descendant widgets to access them via `Bind.of(context)`.
Globally, `Get.find()` can retrieve any registered dependency. It's like a combination of a central
warehouse and local delivery services for the "brains" (controllers) your widgets need.


Complete Tutorial Structure:
1. [Get (Global Access Facade)
](01_get__global_access_facade__.md)
2. [Rx<T> (Reactive Variables)
](02_rx_t___reactive_variables__.md)
3. [Obx / ObxWidget
](03_obx___obxwidget_.md)
4. [Workers
](04_workers_.md)
5. [GetxController
](05_getxcontroller_.md)
6. [Dependency Access (Binder, Bind.of, Get.find/put)
](06_dependency_access__binder__bind_of__get_find_put__.md)
7. [GetBuilder
](07_getbuilder_.md)
8. [StateMixin
](08_statemixin_.md)
9. [ListNotifier (and Mixins)
](09_listnotifier__and_mixins__.md)

Context from previous chapters:
# Chapter 1: Get (Global Access Facade)

Welcome to your GetX journey! In this first chapter, we'll explore one of the most fundamental and frequently used parts of the GetX ecosystem: the `Get` object.

## What is `Get` and Why Do You Need It?

Imagine you're building a Flutter app. You often need to perform common tasks like:
*   Showing a quick message (a "snackbar") to the user.
*   Navigating to a new screen.
*   Accessing a shared service, like a settings manager, from various parts of your app.

Traditionally, in Flutter, many of these tasks require access to something called `BuildContext`. `BuildContext` tells Flutter "where" you are in your widget tree, which is necessary for operations like finding the nearest `Navigator` or `Scaffold`. Getting `BuildContext` to the exact spot where you need it can sometimes be cumbersome, especially in deeper parts of your app's logic that aren't directly part of a widget.

This is where `Get` comes to the rescue!

The `Get` object is your main entry point for most GetX features. Think of it as a **universal remote control** for your application. It provides super easy-to-use tools (called static methods) for:

*   **Dependency Management:** Storing and retrieving your app's services or "managers" (like a `UserSettingsManager` or `ApiService`).
*   **Navigation:** Moving between screens with simple commands.
*   **Showing UI Elements:** Displaying dialogs, snackbars, or bottom sheets.
*   ...and much more!

The beauty of `Get` is that it often lets you do these things **without needing `BuildContext`**, making your code cleaner and simplifying access to GetX functionalities from virtually anywhere in your app.

## How to Use `Get`

Using `Get` is incredibly straightforward because its methods are `static`. This means you don't need to create an instance of a `Get` class; you just type `Get.` followed by the feature you want to use.

Let's look at a few common use cases:

### 1. Showing a Snackbar

Need to show a quick notification to the user?

```dart
import 'package:get/get.dart'; // Make sure to import GetX

// ...somewhere in your code, even inside a business logic class
void showSuccessMessage() {
  Get.snackbar(
    "Success!", // title
    "Your profile was updated successfully.", // message
    snackPosition: SnackPosition.BOTTOM
  );
}
```

**What happens?**
When `showSuccessMessage()` is called, GetX will display a snackbar at the bottom of the current screen with the title "Success!" and the given message. Notice you didn't need to pass any `BuildContext`!

### 2. Navigating to a New Screen

Want to open a new page?

```dart
import 'package:flutter/material.dart';
import 'package:get/get.dart';

class HomeScreen extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(title: Text("Home")),
      body: Center(
        child: ElevatedButton(
          onPressed: () {
            Get.to(DetailScreen()); // Navigate to DetailScreen
          },
          child: Text("Go to Details"),
        ),
      ),
    );
  }
}

class DetailScreen extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(title: Text("Details")),
      body: Center(
        child: ElevatedButton(
          onPressed: () {
            Get.back(); // Go back to the previous screen
          },
          child: Text("Go Back"),
        ),
      ),
    );
  }
}
```
**What happens?**
*   Tapping the "Go to Details" button on `HomeScreen` will push `DetailScreen` onto the navigation stack, making it visible.
*   Tapping the "Go Back" button on `DetailScreen` will pop it from the stack, revealing `HomeScreen` again.

Again, simple and no `BuildContext` needed for `Get.to()` or `Get.back()`. (Note: To use GetX navigation, your main app widget should be `GetMaterialApp` instead of `MaterialApp`).

### 3. Basic Dependency Management (Service Locator)

Imagine you have a class that manages user preferences:

```dart
class UserPreferencesService {
  bool _isDarkMode = false;

  bool get isDarkMode => _isDarkMode;

  void toggleDarkMode() {
    _isDarkMode = !_isDarkMode;
    print("Dark mode is now: $_isDarkMode");
    // In a real app, you'd save this preference
  }
}
```

You can "register" an instance of this service with GetX using `Get.put()`:

```dart
// Usually done at app startup or in a specific setup area
void initializeServices() {
  Get.put(UserPreferencesService());
  print("UserPreferencesService registered!");
}
```

Later, from anywhere in your app, you can retrieve this instance using `Get.find()`:

```dart
// ... in some widget or controller
void onThemeToggleButtonPressed() {
  final prefsService = Get.find<UserPreferencesService>();
  prefsService.toggleDarkMode();
  // You might then update your UI based on prefsService.isDarkMode
}
```

**What happens?**
*   `Get.put(UserPreferencesService());` creates an instance of `UserPreferencesService` and stores it in a global container managed by GetX.
*   `Get.find<UserPreferencesService>();` looks up and returns that stored instance.

This allows you to easily access shared services without passing instances around manually or using complex InheritedWidgets. We'll dive much deeper into dependency management in [Chapter 6: Dependency Access (Binder, Bind.of, Get.find/put)](06_dependency_access__binder__bind_of__get_find_put__.md).

## Under the Hood: How Does `Get` Work?

You might be wondering how `Get` can perform these actions, especially UI-related ones like showing snackbars, without `BuildContext`.

At its core, `Get` is a cleverly designed global static instance. When you use GetX (typically by wrapping your app with `GetMaterialApp`), GetX sets up the necessary infrastructure.

Here's a simplified conceptual flow for showing a snackbar:

```mermaid
sequenceDiagram
    participant YourCode as Your App Code
    participant Get as Get Object
    participant GetXCore as GetX Internal Logic
    participant FlutterFramework as Flutter Framework

    YourCode->>Get: Calls Get.snackbar("Title", "Message")
    Get->>GetXCore: Forwards request to internal snackbar logic
    GetXCore->>FlutterFramework: Uses Flutter's Overlay (or similar) to display UI
    FlutterFramework-->>YourCode: Snackbar appears on screen
```

**1. The `Get` Object Itself:**
The `Get` object you use is actually a global instance of a class. This is defined very simply in the GetX core:

```dart
// From: get_core/src/get_main.dart

// (_GetImpl is a class that implements GetInterface,
// where all the actual methods are defined or extended)
class _GetImpl extends GetInterface {}

// This creates a single, globally accessible instance named 'Get'
// ignore: non_constant_identifier_names
final Get = _GetImpl();
```
This `Get` variable is what you're accessing when you type `Get.something()`.

**2. `GetInterface` and Extensions:**
The `_GetImpl` class extends `GetInterface`.
```dart
// From: get_core/src/get_interface.dart
abstract class GetInterface {
  // Basic configurations like smartManagement and logging
  SmartManagement smartManagement = SmartManagement.full;
  bool isLogEnable = kDebugMode;
  LogWriterCallback log = defaultLogWriterCallback;
  // ... other core properties might be declared here
}
```
Many of GetX's functionalities (like `Get.to`, `Get.snackbar`, `Get.put`, `Get.find`) are added to this `GetInterface` through Dart's extension methods or are mixed into `_GetImpl`. These extensions contain the actual logic. For example, the navigation methods know how to find the `Navigator` provided by `GetMaterialApp`, and the snackbar methods know how to tap into Flutter's `Overlay` to display UI elements globally.

**3. For Dependency Management (`Get.put` / `Get.find`):**
When you use `Get.put(MyService())`, GetX stores this `MyService` instance in an internal data structure (like a map), often an_instance manager. When you later call `Get.find<MyService>()`, GetX looks up `MyService` in this internal storage by its type (and optionally by a tag) and returns the stored instance. We'll cover the `InstanceManager` in more detail in [Chapter 6: Dependency Access (Binder, Bind.of, Get.find/put)](06_dependency_access__binder__bind_of__get_find_put__.md).

The key takeaway is that `Get` acts as a **facade**  a simplified, unified interface to a more complex underlying system. It hides the complexities of interacting directly with Flutter's deeper systems or managing global instances, providing you with clean, easy-to-use static methods.

## Conclusion

You've now met `Get`, your go-to helper for many common tasks in GetX. It's a powerful yet simple facade that provides global access to navigation, UI utilities, dependency management, and more, often without the need for `BuildContext`. This keeps your code clean and makes development faster.

As you continue your GetX journey, you'll see `Get` being used in various contexts. Understanding its role as a global access point is key to mastering GetX.

In the next chapter, we'll explore a core GetX concept for making your application's data dynamic and responsive: [Rx<T> (Reactive Variables)](02_rx_t___reactive_variables__.md).
---
# Chapter 2: Rx<T> (Reactive Variables)

Welcome to Chapter 2! In [Chapter 1: Get (Global Access Facade)](01_get__global_access_facade__.md), we learned how the `Get` object acts as a handy "universal remote" for common app tasks. Now, we're going to dive into one of the most exciting features of GetX: making your app's data "reactive."

## What's the Big Deal with "Reactive"?

Imagine you're building an app that shows a user's score. When the score changes, you want the text on the screen displaying that score to update *automatically*, without you having to write a lot of complicated code to manually refresh the screen. This "automatic updating" is what reactive programming is all about.

`Rx<T>` variables are GetX's way of achieving this magic.

## Introducing `Rx<T>`: Your Magic Whiteboard

`Rx<T>` types (like `RxInt`, `RxString`, or pretty much anything you see ending with `.obs`) represent variables that can be "observed."

Think of an `Rx<T>` variable as a special number (or text, or any data) written on a **magic whiteboard**:
*   You write your initial data on this whiteboard (e.g., the number `0`).
*   Whenever someone erases the number and writes a new one (e.g., changes it to `1`), a bell automatically rings!
*   Anyone (or any part of your app's UI) specifically "watching" that number on the whiteboard instantly sees the change and reacts to it.

These `Rx<T>` variables are the heart of GetX's reactive programming. They allow your User Interface (UI), especially when used with widgets like `Obx` (which we'll cover in the [next chapter](03_obx___obxwidget_.md)), to automatically update whenever the underlying data changes.

The `T` in `Rx<T>` is a placeholder for the type of data the variable will hold, like `int`, `String`, `bool`, or even your own custom classes.

## How to Create and Use Reactive Variables

Let's see how to create and use these "magic" variables. The most common way is by using the `.obs` extension on a standard Dart value.

### 1. Creating a Reactive Variable

To make a regular variable reactive, you simply add `.obs` to its initial value.

**For a number (integer):**

```dart
import 'package:get/get.dart'; // Don't forget to import GetX

final count = 0.obs; // This is now an RxInt holding 0
// You could also write: final count = RxInt(0);
```
Here, `count` isn't just a regular `int`. It's now a special `RxInt` object that holds the integer value `0` and can notify others when it changes.

**For text (string):**

```dart
final userName = "Guest".obs; // This is an RxString holding "Guest"
// You could also write: final userName = RxString("Guest");
```
Similarly, `userName` is an `RxString`.

**For a boolean (true/false):**

```dart
final isLoggedIn = false.obs; // This is an RxBool holding false
// You could also write: final isLoggedIn = RxBool(false);
```

### 2. Getting the Value

If `count` is an `RxInt`, how do you get the actual integer value out of it? You use the `.value` property.

```dart
final count = 0.obs;
print(count.value); // Output: 0

final userName = "Guest".obs;
print(userName.value); // Output: Guest
```
Think of `.value` as looking at the magic whiteboard to read what's currently written on it.

### 3. Changing the Value (and Ringing the Bell!)

To change the value of a reactive variable, you also assign a new value to its `.value` property. This is the action that "rings the bell."

```dart
final count = 0.obs;
print("Initial count: ${count.value}"); // Output: Initial count: 0

count.value = 5; // You changed the number on the whiteboard!
print("New count: ${count.value}"); // Output: New count: 5
```
When you do `count.value = 5;`, the `count` variable not only updates its internal number but also sends out a notification that its value has changed.

You can also change the value by calling the `Rx` variable like a function:
```dart
final anotherCount = 10.obs;
anotherCount(15); // Same as anotherCount.value = 15;
print(anotherCount.value); // Output: 15
```
This is just a shorthand. Both ways achieve the same result.

### A Simple Example: The Counter Logic

Let's imagine the logic for a simple counter. We won't build the UI yet, just the data part.

```dart
import 'package:get/get.dart';

// 1. Create a reactive variable for our count
final magicCounter = 0.obs;

void incrementCounter() {
  // 2. Change its value
  magicCounter.value++; // This rings the bell!
  print("Counter is now: ${magicCounter.value}");
}

void main() {
  print("Counter starts at: ${magicCounter.value}");
  incrementCounter(); // Call the function to change the value
  incrementCounter();
}
```
**What happens?**
1.  `magicCounter` is created as an `RxInt` initialized to `0`.
2.  When `incrementCounter()` is called, `magicCounter.value++` increases the stored integer and notifies any listeners.
3.  The `print` statement shows the updated value.

Output:
```
Counter starts at: 0
Counter is now: 1
Counter is now: 2
```
Right now, only our `print` statements are "listening" in a very basic way. In the [next chapter](03_obx___obxwidget_.md), we'll see how to make Flutter UI widgets listen and update automatically!

## Under the Hood: How Does `.obs` Work?

You might wonder what `.obs` actually does. It's a clever use of Dart's "extension methods."

When you write `0.obs`, GetX has an extension on the `int` type that looks something like this (simplified):

```dart
// From: get_rx/src/rx_types/rx_core/rx_impl.dart (simplified concept)
extension IntExtension on int {
  RxInt get obs => RxInt(this); // 'this' refers to the integer itself
}
```
This code basically says: "If you see `.obs` after an integer, create a new `RxInt` object and give it that integer's value." Similar extensions exist for `String`, `bool`, `double`, and even a generic `Rx<T>` for any object via `T.obs`.

The `RxInt`, `RxString`, etc., classes (which generally inherit from `_RxImpl<T>`) are special classes that manage an internal value and have a built-in mechanism to notify listeners.

Here's a simplified step-by-step of what happens when you change an `Rx` variable's value:

```mermaid
sequenceDiagram
    participant YourCode as Your App Code
    participant RxVariable as count (RxInt)
    participant RxImpl as Internal Logic (_RxImpl)
    participant Listeners as Potential UI (e.g., Obx)

    YourCode->>RxVariable: count.value = 1
    Note over RxVariable: This calls the 'set value' logic
    RxVariable->>RxImpl: Pass new value (1)
    RxImpl->>RxImpl: Store new value (1) internally
    RxImpl->>RxImpl: Check: Has value actually changed?
    alt Value Changed
        RxImpl-->>Listeners: Notifies all listeners (rings the bell!)
        Listeners-->>RxVariable: (Later) Asks RxVariable for its new .value
    end
```

1.  **You assign to `.value`**: `count.value = 1;`
2.  **Setter is called**: The `RxInt` class (or its parent `_RxImpl` found in `get_rx/src/rx_types/rx_core/rx_impl.dart`) has a special `set value(newValue)` method.
3.  **Value Check**: This setter first checks if the `newValue` is actually different from the current stored value. If it's the same, it usually does nothing to avoid unnecessary notifications.
4.  **Store New Value**: If the value is different, it updates its internal storage.
5.  **Notify Listeners**: This is the magic part! The class then triggers a notification. Internally, it often uses a `StreamController` (from `dart:async`). When you change `.value`, it essentially adds the new value to its stream using something like `subject.add(newValue)` after updating its internal `_value`.
    ```dart
    // Highly simplified concept from RxObjectMixin in get_rx/src/rx_types/rx_core/rx_impl.dart
    // and GetListenable in get_state_manager/src/rx_flutter/rx_notifier.dart

    // In GetListenable:
    // StreamController<T>? _controller;
    // T _value;
    // void refresh() { _controller?.add(_value); }

    // In RxObjectMixin (which uses GetListenable):
    set value(T val) {
      if (_value == val && !firstRebuild) return; // _value is from GetListenable
      firstRebuild = false;
      super.value = val; // This typically calls GetListenable's setter, which then calls refresh()
                         // `super.value = val;` roughly does:_value = val; refresh();
    }
    ```
    The `super.value = val;` line in `RxObjectMixin`'s setter calls the setter in its parent class (`GetListenable`), which updates the internal `_value` and then calls `refresh()`. The `refresh()` method then typically adds the new value to an internal stream (`_controller?.add(_value);`), effectively "ringing the bell."

Any widget designed to listen to these streams (like `Obx`) will then pick up this notification.

## Different Kinds of Rx Variables

GetX provides several pre-built `Rx` types for convenience:

*   **Primitives:**
    *   `RxInt(initialValue)` or `initialValue.obs` for integers.
    *   `RxDouble(initialValue)` or `initialValue.obs` for doubles.
    *   `RxString(initialValue)` or `initialValue.obs` for strings.
    *   `RxBool(initialValue)` or `initialValue.obs` for booleans.
*   **Collections (these are a bit more advanced as they react to internal changes too):**
    *   `RxList<T>([])` or `[].obs` for lists.
    *   `RxMap<K, V>({})` or `{}.obs` for maps.
    *   `RxSet<T>({})` or `{}.obs` for sets.
*   **Generic `Rx<T>`:**
    *   For any other type, including your custom classes:
        ```dart
        class User {
          String name;
          User(this.name);
        }

        final user = User("Alice").obs; // user is now an Rx<User>
        // or: final user = Rx<User>(User("Alice"));

        print(user.value.name); // Output: Alice
        user.value.name = "Bob";
        user.refresh(); // For complex objects, you might need to call refresh()
                        // or use user.update((val) { val.name = "Bob"; });
                        // to ensure listeners are notified of internal changes.
        print(user.value.name); // Output: Bob
        ```
    For changes *inside* a custom object held by `Rx<T>`, like changing `user.value.name`, GetX might not automatically know the object's internal state changed. In such cases, you can call `user.refresh()` to manually trigger the "bell," or use the `update()` method: `user.update((currentUser) { currentUser.name = "Bob"; });` which handles the refresh for you.

## Conclusion

You've now learned about `Rx<T>` variables  the "magic whiteboards" of GetX! They are special variables, easily created with `.obs`, that automatically notify anyone interested when their `.value` changes. This is the foundation of reactive programming in GetX and is crucial for building UIs that update themselves effortlessly.

These reactive variables are often managed within [GetxController](05_getxcontroller_.md) classes (which we'll cover later), making state management clean and powerful.

In the [next chapter, Chapter 3: Obx / ObxWidget](03_obx___obxwidget_.md), we'll see how to use `Obx` widgets to make your UI actually listen to these `Rx<T>` variables and update automatically when that magic bell rings!
---
# Chapter 3: Obx / ObxWidget

In [Chapter 2: Rx<T> (Reactive Variables)](02_rx_t___reactive_variables__.md), we discovered `Rx<T>` variables, our "magic whiteboards" that can signal when their data changes. That's fantastic for managing data, but how do we make our app's screen (the User Interface or UI) automatically show these changes?

Imagine you have a score in your game, stored in an `RxInt`. When the score increases, you want the score display on the screen to update instantly, without you having to write complex code to manually refresh it. This is where `Obx` comes in!

## Meet `Obx`: The Smart Picture Frame for Your UI

`Obx` (and its underlying base, `ObxWidget`) is a special Flutter widget provided by GetX. Its job is simple but powerful: it "watches" any reactive variables (`Rx<T>`) you use inside it and automatically rebuilds itself to show the new data whenever those variables change.

Remember our "magic whiteboard" (`Rx<T>`) from the last chapter?
Think of `Obx` as a **smart digital picture frame** that's wirelessly connected to that whiteboard.
*   You tell the `Obx` frame which part of the whiteboard to display (e.g., the score).
*   Whenever someone updates the score on the whiteboard (`Rx<T>` variable changes), the `Obx` frame *instantly* gets the new score and displays it.

This means your UI stays perfectly in sync with your app's state, efficiently and with very little code.

## How to Use `Obx`

Using `Obx` is wonderfully straightforward. You wrap the part of your UI that depends on a reactive variable with an `Obx` widget.

Let's build a very simple counter app to see it in action.

### 1. First, We Need a Reactive Variable

As we learned in [Chapter 2: Rx<T> (Reactive Variables)](02_rx_t___reactive_variables__.md), we create a reactive variable using `.obs`. Let's make a counter:

```dart
import 'package:get/get.dart'; // For .obs and Obx

final counter = 0.obs; // Our reactive integer, starting at 0
```
This `counter` is our "magic whiteboard" that will hold the current count.

### 2. Use `Obx` to Display the Reactive Variable

Now, let's use the `Obx` widget to display the value of `counter`. `Obx` takes a builder function. This function should return the widget(s) that depend on your reactive data.

Crucially, you **must** access the `.value` of your `Rx` variable *inside* this builder function for `Obx` to know which variable to watch.

```dart
// Inside your widget's build method:
Obx(() {
  // This Text widget will rebuild whenever 'counter.value' changes
  return Text("Button presses: ${counter.value}");
})
```
Here, `Obx` is our "smart picture frame." The builder function `() { return Text(...); }` tells the frame *what* to display. Because we used `counter.value` inside it, `Obx` knows to watch the `counter` variable.

### 3. Putting It All Together: A Simple Reactive Page

Let's see a complete, minimal example. We'll have a text display for the counter and a button to increment it.

```dart
import 'package:flutter/material.dart';
import 'package:get/get.dart';

// 1. Our reactive variable (could be in a GetxController later)
final counter = 0.obs;

class CounterPage extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(title: Text("Obx Counter Demo")),
      body: Center(
        // 2. Use Obx to wrap the widget that displays reactive data
        child: Obx(() {
          return Text(
            "Count: ${counter.value}", // Access .value here!
            style: TextStyle(fontSize: 28),
          );
        }),
      ),
      floatingActionButton: FloatingActionButton(
        onPressed: () {
          // 3. Change the reactive variable's value
          counter.value++;
        },
        child: Icon(Icons.add),
      ),
    );
  }
}
```

**What happens?**

1.  The page loads, `counter.value` is `0`. The `Obx` widget runs its builder function for the first time, and `Text("Count: 0")` is displayed.
2.  You tap the `+` button.
3.  The `onPressed` callback executes: `counter.value++`.
    *   The value of `counter` changes (e.g., from `0` to `1`).
    *   Because `counter` is an `RxInt` (a "magic whiteboard"), it "rings a bell," notifying its listeners that it has changed.
4.  The `Obx` widget, being a "smart picture frame" listening to `counter`, hears this bell!
5.  `Obx` automatically re-runs its builder function: `() { return Text("Count: ${counter.value}"); }`.
6.  This time, `counter.value` is `1`, so a new `Text("Count: 1")` widget is created and displayed.

The UI updates automatically, just like magic! You didn't have to call `setState()` or manually tell the UI to refresh.

### Important: Only Use Rx Variables *Inside* `Obx`'s Builder

`Obx` is smart, but it's not a mind reader. It only knows to rebuild if a reactive variable *that it has been told to observe* changes. It figures this out by tracking which reactive variables have their `.value` accessed *directly within its builder function*.

```dart
// GOOD: 'name.value' is inside Obx's builder
final name = "User".obs;
Obx(() => Text(name.value))

// BAD: If 'name.value' is not accessed inside, Obx won't react.
// (This would likely throw an ObxError if no other Rx var is accessed)
final name = "User".obs;
String currentName = name.value; // Accessed outside Obx's scope of observation
Obx(() => Text(currentName)) // Obx doesn't know about 'name' here
```

If you use an `Obx` widget and don't access any `.value` of an `Rx` variable inside its builder, GetX will usually show you an `ObxError` in the console, reminding you that `Obx` isn't observing anything.

```
[Get] the improper use of a GetX has been detected.
You should only use GetX or Obx for the specific widget that will be updated.
If you are seeing this error, you probably did not insert any observable variables into GetX/Obx...
```
This error message comes from the `ObxError` class defined in `get_state_manager/src/simple/list_notifier.dart`.

## Under the Hood: How Does `Obx` Work Its Magic?

It might seem like magic, but it's clever programming. Here's a simplified idea:

1.  **Subscription:** When an `Obx` widget is built for the first time, it prepares to listen. As its builder function executes, any `RxVariable.value` you access signals back to the `Obx` (via an internal `Notifier` system) saying, "Hey, Obx, I'm being read here! Please listen to me for changes." The `Obx` widget then subscribes to that `RxVariable`.
2.  **Value Change:** You change an `RxVariable` (e.g., `counter.value++`).
3.  **Notification:** The `RxVariable` "rings its bell" and notifies all its subscribers (including our `Obx` widget) that its value has changed.
4.  **Rebuild:** The `Obx` widget, upon receiving this notification, knows it needs to update. It schedules a rebuild, which simply means it calls its builder function again. Because the builder function now gets the new value from the `RxVariable`, the UI updates.

Here's a visual representation:

```mermaid
sequenceDiagram
    participant UserAction as User Taps Button
    participant RxVariable as counter (RxInt)
    participant ObxWidget as Obx Widget
    participant FlutterEngine as Flutter Engine

    Note over ObxWidget, RxVariable: Initial build: Obx reads counter.value, subscribes to counter.
    UserAction->>RxVariable: counter.value++
    RxVariable->>RxVariable: Internal value updates
    RxVariable-->>ObxWidget: Notifies Obx about the change
    ObxWidget->>ObxWidget: Schedules its builder to re-run
    ObxWidget->>RxVariable: Reads new counter.value (e.g., 1)
    ObxWidget-->>FlutterEngine: Provides new UI (e.g., Text("Count: 1"))
    FlutterEngine-->>UserAction: UI Updates on Screen
```

Let's peek at some (simplified) relevant code snippets:

`Obx` itself is quite simple. It extends `ObxWidget` (which extends `ObxStatelessWidget`).
```dart
// From: get_state_manager/src/rx_flutter/rx_obx_widget.dart
class Obx extends ObxWidget {
  final WidgetCallback builder; // Your () => Widget function
  const Obx(this.builder, {super.key});

  @override
  Widget build(BuildContext context) {
    return builder(); // It just calls your function!
  }
}
```
The real magic happens in `ObxStatelessWidget` and its `ObxElement`, which uses a mixin called `StatelessObserverComponent` (from `get_state_manager/src/simple/simple_builder.dart`).

```dart
// From: get_state_manager/src/simple/simple_builder.dart (simplified)
mixin StatelessObserverComponent on StatelessElement {
  List<Disposer>? disposers = <Disposer>[]; // To store cleanup functions

  void getUpdate() {
    // If I'm told to update, I tell Flutter to rebuild me!
    scheduleMicrotask(markNeedsBuild);
  }

  @override
  Widget build() {
    // Before calling the user's Obx builder (super.build),
    // set up the Notifier to catch Rx reads.
    return Notifier.instance.append(
        NotifyData(disposers: disposers!, updater: getUpdate),
        super.build // This eventually calls your Obx(() => Text(...))
    );
  }

  @override
  void unmount() { // When Obx is removed from the screen
    super.unmount();
    for (final disposer in disposers!) {
      disposer(); // Clean up subscriptions
    }
    disposers!.clear();
    disposers = null;
  }
}
```
When `yourRxVariable.value` is accessed *inside* the `Obx` builder (during `super.build` call above):
1.  The `Rx` variable's getter calls `reportRead()`. This method is mixed into `Rx` types from `ListNotifierSingleMixin` (in `get_state_manager/src/simple/list_notifier.dart`).
    ```dart
    // From: get_rx/src/rx_types/rx_core/rx_impl.dart (RxObjectMixin's value getter)
    // Simplified concept of what Rx's .value getter does
    T get value {
      reportRead(); // "I'm being read!"
      return _internalValue;
    }
    ```
2.  `reportRead()` calls `Notifier.instance.read(this)` (`this` refers to the `Rx` variable itself).
    ```dart
    // From: get_state_manager/src/simple/list_notifier.dart
    // (Inside ListNotifierSingleMixin)
    @protected
    void reportRead() {
      Notifier.instance.read(this);
    }
    ```
3.  `Notifier.instance.read()` checks the `_notifyData` that `StatelessObserverComponent.build()` set up. It finds the `getUpdate` method of our `Obx` widget and subscribes it to the `Rx` variable.
    ```dart
    // From: get_state_manager/src/simple/list_notifier.dart (Notifier class)
    void read(ListNotifierSingleMixin rxVariable) {
      final getStateUpdateFn = _notifyData?.updater; // This is Obx's getUpdate()
       // If Obx's getUpdate is available and not already listening to this rxVariable:
      if (getStateUpdateFn != null && !rxVariable.containsListener(getStateUpdateFn)) {
        // Tell rxVariable: "When you change, call Obx's getUpdate()"
        Disposer disposer = rxVariable.addListener(getStateUpdateFn);
        // And remember how to unsubscribe later
        _notifyData?.disposers.add(disposer);
      }
    }
    ```
So, when `RxVariable.value` changes later, it calls `refresh()` (from `ListNotifierSingleMixin`), which notifies its listeners. One of these listeners is the `Obx` widget's `getUpdate` method, causing the `Obx` widget to rebuild!

## What is `ObxWidget` then?

You'll mostly use `Obx`. `ObxWidget` is simply the base class that `Obx` (and `ObxValue`, another similar widget) extends. It provides the common reactive machinery. Advanced users could extend `ObxWidget` to create their own custom reactive widgets, but for most day-to-day tasks, `Obx` is all you need.

## Conclusion

You've now unlocked a cornerstone of GetX's reactivity: the `Obx` widget! It's your "smart picture frame" that automatically updates your UI when the underlying `Rx<T>` reactive variables change. This makes building dynamic and responsive UIs incredibly simple and efficient.

Typically, your `Rx<T>` variables will live inside a [GetxController](05_getxcontroller_.md) (which we'll cover soon) to keep your UI logic neatly organized. `Obx` then becomes the bridge that connects your controller's state to your visual widgets.

But what if you want to react to changes in `Rx<T>` variables *without* updating the UI? For example, maybe you want to log a message or make an API call when a value changes. For that, GetX provides something called "Workers." Let's explore those in the [next chapter, Chapter 4: Workers](04_workers_.md).
---
# Chapter 4: Workers

In [Chapter 3: Obx / ObxWidget](03_obx___obxwidget_.md), we saw how `Obx` acts like a smart picture frame, automatically updating our UI when reactive variables change. That's perfect for what users see! But what if we want to perform actions *behind the scenes* when our data changes? For instance, what if we need to fetch new data from the internet when a user's ID changes, or automatically save their input after they've stopped typing for a moment? This is where GetX Workers come in!

## What Problem Do Workers Solve?

Imagine you have a reactive variable, say, `userId.obs`. When this `userId` changes, you might want to:
*   Log the change for debugging.
*   Fetch the new user's profile from a server.
*   Update some other non-UI related data.

You don't want to put this logic directly in your UI-building code because it's not about drawing pixels on the screen. It's about reacting to data changes with *side effects*.

**Workers** are your dedicated helpers for exactly this. They are functions that "listen" to your [Rx<T> (Reactive Variables)](02_rx_t___reactive_variables__.md) and execute a callback function when specific events or conditions occur on those variables. Think of them as automated sentinels, tirelessly watching your reactive data streams. When a predefined rule is met (like "the data changed!" or "the user stopped typing!"), they spring into action, independent of direct UI rendering.

## Meet the Workers: Your Automated Sentinels

GetX provides a few different types of Workers, each designed for a specific kind of listening task. Let's meet the main ones: `ever`, `once`, `debounce`, and `interval`.

All these workers are typically set up within the `onInit()` method of a [GetxController](05_getxcontroller_.md) (which we'll cover in the next chapter), or anywhere you have access to your reactive variables and need to react to their changes.

### 1. `ever`: The Ever-Watchful Sentinel

The `ever` worker executes its callback function **every time** the reactive variable it's watching changes.

Let's say we have a reactive variable for a username:
```dart
import 'package:get/get.dart';

final username = 'Guest'.obs; // Our reactive username
```
Now, let's set up an `ever` worker to print a message whenever `username` changes:
```dart
// Typically, you'd do this in onInit() of a GetxController
ever(username, (String newName) {
  print("Username changed to: $newName");
});

// Let's simulate some changes:
username.value = 'Alice';
username.value = 'Bob';
```
**What happens?**
Every time `username.value` is assigned a new value, the `ever` worker's callback `(String newName) { ... }` is triggered.
Output:
```
Username changed to: Alice
Username changed to: Bob
```

You can also add a `condition` to `ever`. The callback will only run if the condition is true when the main variable changes.
```dart
final count = 0.obs;

ever(count, (int newCount) {
  print("Count is now $newCount (and it's greater than 2!)");
}, condition: () => count.value > 2); // Only run if count > 2

count.value = 1; // No output
count.value = 3; // Output: Count is now 3 (and it's greater than 2!)
count.value = 4; // Output: Count is now 4 (and it's greater than 2!)
```

### 2. `once`: The One-Time Sentinel

The `once` worker executes its callback function **only the first time** a specific condition (related to the reactive variable) is met. After it runs once, it automatically stops listening.

Imagine you want to show a welcome message only the very first time a user logs in (i.e., `isLoggedIn.value` becomes `true`).
```dart
final isLoggedIn = false.obs;

once(isLoggedIn, (bool loggedInStatus) {
  if (loggedInStatus == true) {
    print("Welcome! You've logged in for the first time (during this session).");
  }
}, condition: () => isLoggedIn.value == true); // Condition to trigger

isLoggedIn.value = true;  // Triggers 'once'
isLoggedIn.value = false; // 'once' won't trigger again
isLoggedIn.value = true;  // 'once' won't trigger again
```
**What happens?**
The callback is executed only when `isLoggedIn.value` changes *and* the condition `isLoggedIn.value == true` is met for the *first time*.
Output:
```
Welcome! You've logged in for the first time (during this session).
```
Even if `isLoggedIn` becomes `true` again later, `once` has done its job and won't fire again.

### 3. `debounce`: The "Wait-and-See" Sentinel

The `debounce` worker is super useful for scenarios like search fields. It waits for a certain period of inactivity before executing the callback. If the variable changes again before the waiting period is over, the timer resets.

Imagine a search bar. You don't want to make an API call for every single letter the user types. Instead, you want to wait until they pause typing.
```dart
final searchQuery = ''.obs;

debounce(searchQuery, (String query) {
  print("User stopped typing. Search for: $query");
  // In a real app, you'd make an API call here: fetchResults(query);
}, time: Duration(milliseconds: 500)); // Wait for 500ms of inactivity

// Simulate typing quickly, then pausing
searchQuery.value = 'h';
searchQuery.value = 'he';
searchQuery.value = 'hel'; // Timer resets each time
// User pauses... after 500ms:
// Output: User stopped typing. Search for: hel
```
**What happens?**
*   User types 'h', then 'e', then 'l' quickly. The `debounce` timer keeps resetting.
*   After 'hel', if the user pauses for 500 milliseconds, the callback `(String query) { ... }` is executed with the latest value ('hel').
*   If they type 'lo' next, the same process repeats.

### 4. `interval`: The "Periodic Check-up" Sentinel

The `interval` worker is a bit like `debounce` but it triggers its callback with the value that the reactive variable had at the *beginning* of the interval, after a specified duration has passed, and *only if* no new changes occurred during that interval (this behavior can be subtle, often `debounce` is what people want for "after a delay"). It's more like "if nothing changes for X time, then act on the value from X time ago".

A more common use of a timed worker might be "check something every X seconds while a condition is true." `interval` is designed to trigger *after* a period of stability. If you rapidly change the value, `interval` might not fire for each change because a new event interrupts the "quiet period" it's waiting for.

Let's consider a scenario where you want to perform an action if a value remains stable for a certain period.
```dart
final status = 'idle'.obs;

interval(status, (String currentStatus) {
  print("Status has been '$currentStatus' for 1 second.");
}, time: Duration(seconds: 1));

status.value = 'processing'; // Worker starts listening
// If 'status' remains 'processing' for 1 second:
// Output: Status has been 'processing' for 1 second.

// If you change it quickly:
// status.value = 'A';
// await Future.delayed(Duration(milliseconds: 200));
// status.value = 'B'; // 'A' might not trigger the interval callback
```
**What happens?**
If `status.value` becomes 'processing' and stays 'processing' for 1 second without any other changes to `status`, the callback will fire. If `status` changes again *within* that 1-second window, the timer for the *previous* value is essentially reset/ignored, and a new interval evaluation potentially begins for the new value. `debounce` is often more intuitive for "do something after a pause."

For `interval`, the primary mechanism is: when an event arrives, it waits for `time`. If another event arrives *before* `time` is up, the first event is effectively ignored by that specific `interval`'s timer. When `time` *does* elapse without a new event, the callback is fired with the value that was present when the `time` period began.


## Disposing of Workers

Workers, like `StreamSubscription`s in Dart, need to be disposed of when they are no longer needed. This is crucial to prevent memory leaks and unwanted behavior, especially if the reactive variable they are listening to outlives the context where the worker was created.

When you create a worker, it returns a `Worker` object. This object has a `dispose()` method:
```dart
final count = 0.obs;
late Worker everWorker; // Declare the worker variable

// In onInit() or similar setup:
everWorker = ever(count, (_) => print('Count changed!'));

// ... later, when this logic is no longer needed (e.g., in onClose() of a GetxController):
void cleanup() {
  everWorker.dispose();
  print("Ever worker disposed.");
}

count.value = 1; // Output: Count changed!
cleanup();
count.value = 2; // No output, because the worker is disposed.
```

It's a common pattern to initialize workers in the `onInit()` method of a [GetxController](05_getxcontroller_.md) and dispose of them in its `onClose()` method. GetX also provides a way to automatically manage this if workers are declared inside a controller, but manual disposal is good practice to understand.

## Under the Hood: How Do Workers... Work?

Workers function by subscribing to the underlying stream of an [Rx<T> (Reactive Variables)](02_rx_t___reactive_variables__.md). Remember from Chapter 2 that `Rx` variables can notify listeners when they change? Workers are specialized listeners.

1.  **Subscription:** When you create a worker (e.g., `ever(myRxVar, callback)`), the worker function internally calls `myRxVar.listen(...)`. This is similar to listening to a Dart `Stream`.
2.  **Event Emission:** When `myRxVar.value` changes, `myRxVar` emits this new value to its listeners.
3.  **Worker Logic:** The worker receives this new value.
    *   For `ever`, it typically checks an optional condition and then calls your callback.
    *   For `once`, it does the same but also cancels its own subscription after the first valid trigger.
    *   For `debounce`, it uses a timer (like the `Debouncer` utility class in GetX). Each new event resets the timer. If the timer completes, the callback is called with the *last* event received.
    *   For `interval`, it also uses a timer. When an event arrives, it starts a timer. If the timer completes *without* a new event arriving, it calls the callback with the event that started that timer.
4.  **Callback Execution:** If the worker's specific logic decides it's time, your provided callback function is executed with the relevant value.

Heres a simplified sequence diagram showing a `debounce` worker in action:

```mermaid
sequenceDiagram
    participant UserAction as User Typing
    participant SearchRx as searchQuery.obs
    participant DebounceWorker as Debounce Logic
    participant YourCallback as (query) => API.search(query)

    UserAction->>SearchRx: searchQuery.value = "flut"
    SearchRx-->>DebounceWorker: Notifies with "flut"
    DebounceWorker->>DebounceWorker: Starts/Resets 500ms timer
    UserAction->>SearchRx: searchQuery.value = "flutter"
    SearchRx-->>DebounceWorker: Notifies with "flutter"
    DebounceWorker->>DebounceWorker: Resets 500ms timer (for "flutter")
    Note over DebounceWorker: User pauses typing...
    DebounceWorker-->>YourCallback: After 500ms, calls YourCallback("flutter")
```

The actual implementation can be found in `get_rx/src/rx_workers/rx_workers.dart`.
For example, the `ever` worker (simplified):
```dart
// From: get_rx/src/rx_workers/rx_workers.dart (conceptual)
Worker ever<T>(
  GetListenable<T> listener, // This is your Rx variable
  WorkerCallback<T> callback, {
  dynamic condition = true, // Optional condition
  /* ... other params ... */
}) {
  // 1. Listen to the Rx variable's stream
  StreamSubscription sub = listener.listen(
    (event) { // 'event' is the new value from the Rx variable
      // 2. Check the condition
      if (_conditional(condition)) { // _conditional is a helper
        // 3. Execute your callback
        callback(event);
      }
    },
    /* ... onError, onDone ... */
  );
  // 4. Return a Worker object that can be used to cancel the subscription
  return Worker(sub.cancel, '[ever]');
}
```
The `_conditional` function (also in `rx_workers.dart`) is a utility that evaluates the `condition` argument, which can be a `bool` or a `bool Function()`.

The `debounce` worker uses a `Debouncer` utility class (found in `get_rx/src/rx_workers/utils/debouncer.dart`):
```dart
// From: get_rx/src/rx_workers/rx_workers.dart (conceptual)
Worker debounce<T>(
  GetListenable<T> listener,
  WorkerCallback<T> callback, {
  Duration? time, /* ... */
}) {
  // 1. Create a Debouncer instance
  final newDebouncer = Debouncer(delay: time ?? Duration(milliseconds: 800));
  StreamSubscription sub = listener.listen(
    (event) {
      // 2. When Rx variable changes, call the debouncer
      newDebouncer(() {
        // 3. Debouncer will execute this only after the 'delay'
        callback(event);
      });
    }, /* ... */
  );
  return Worker(sub.cancel, '[debounce]');
}
```
The `Debouncer` class itself manages a `Timer` to achieve the "wait for inactivity" behavior.

## Conclusion

Workers (`ever`, `once`,  `debounce`, `interval`) are powerful tools in GetX for reacting to changes in your [Rx<T> (Reactive Variables)](02_rx_t___reactive_variables__.md) by performing side effects like API calls, logging, or triggering other logic that isn't directly tied to UI updates. They help you keep your code clean by separating these concerns. Remember to always `dispose()` your workers when they're no longer needed to keep your app running smoothly.

Now that we've seen how to create reactive data (`Rx<T>`), how to make our UI react to it (`Obx`), and how to perform side effects based on it (Workers), it's time to look at how to organize all this reactive goodness. In the [next chapter, Chapter 5: GetxController](05_getxcontroller_.md), we'll explore `GetxController`, the recommended way to encapsulate your business logic and reactive state.
---
# Chapter 5: GetxController

In [Chapter 4: Workers](04_workers_.md), we learned how to perform actions behind the scenes when_our_reactive data changes. That's great for side effects! But as your app grows, you'll find yourself asking:
*   Where should I keep my app's data (like that `counter.obs` or `searchQuery.obs`)?
*   Where should the functions that change this data (like `incrementCounter()` or `performSearch()`) live?
*   How can I neatly organize all this for a specific feature or screen?

Simply putting reactive variables and functions globally or directly in UI widgets can get messy quickly. We need a dedicated "manager" for different parts of our application. That's where `GetxController` shines!

## What is a GetxController? The Brain of Your Feature!

A `GetxController` is like the **manager** or **"brain"** for a specific part of your app's screen or a particular feature. Think of it as a dedicated organizer. Its main jobs are:

1.  **Holding Data (State):** It stores the variables (often [Rx<T> (Reactive Variables)](02_rx_t___reactive_variables__.md)) that your feature needs. For example, in a counter feature, it would hold the current count.
2.  **Holding Business Logic (Functions):** It contains the functions that operate on this data or perform actions related to the feature. For the counter, this would be the `increment()` function.
3.  **Managing Lifecycle:** It has special methods that get called at different points in its life (like when it's created or destroyed), allowing you to set things up or clean up resources.
4.  **Notifying UI (with `update()`):** When its data changes (especially non-reactive data, or if you need more control), the controller can tell the UI to update by calling its `update()` method. This is primarily used with a widget called `GetBuilder`, which we'll explore in [Chapter 7: GetBuilder](07_getbuilder_.md).

Imagine a scene in a play. The `GetxController` is like the **director** of that scene. It knows the script (logic), manages the actors' states (data), and tells them when and how to change their appearance or behavior.

## How to Use a GetxController

Let's go back to our simple counter example and see how we can organize it using a `GetxController`.

### 1. Creating Your Controller

First, you create a new Dart class that `extends GetxController`.

```dart
// counter_controller.dart
import 'package:get/get.dart';

class CounterController extends GetxController {
  // 1. Hold your reactive data (state)
  final count = 0.obs; // Our familiar RxInt

  // 2. Define your business logic (functions)
  void increment() {
    count.value++;
    // If we were using GetBuilder and non-Rx state, we might call update() here.
  }
}
```
**Explanation:**
*   We created `CounterController` that inherits from `GetxController`.
*   Inside it, we moved our reactive `count` variable.
*   We also moved the `increment` logic into a method within the controller. Now, all things related to the counter's state and logic are neatly bundled together!

### 2. Making the Controller Available (Quick Peek at Dependency Injection)

Before your UI can use the controller, GetX needs to know about it. You "register" your controller, usually when the feature or screen is first needed. The most common way is using `Get.put()`:

```dart
// Somewhere before you need the controller, e.g., when navigating to the page
Get.put(CounterController());
```
**Explanation:**
*   `Get.put(CounterController());` creates an instance of `CounterController` and makes it available for other parts of your app to find.
*   We'll dive deep into `Get.put()` and other ways to manage controllers in [Chapter 6: Dependency Access (Binder, Bind.of, Get.find/put)](06_dependency_access__binder__bind_of__get_find_put__.md). For now, just know this step is necessary.

### 3. Accessing and Using the Controller in Your UI

Once the controller is "put", your UI widgets can find and use it. You use `Get.find()` for this:

```dart
// In your widget file (e.g., counter_page.dart)
import 'package:flutter/material.dart';
import 'package:get/get.dart';
import 'counter_controller.dart'; // Import your controller fine

class CounterPage extends StatelessWidget {
  // Find the instance of CounterController that GetX is managing
  final CounterController controller = Get.find<CounterController>();

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(title: Text("GetxController Counter")),
      body: Center(
        child: Obx(() { // Obx watches reactive variables
          return Text(
            "Count: ${controller.count.value}", // Use controller's data
            style: TextStyle(fontSize: 28),
          );
        }),
      ),
      floatingActionButton: FloatingActionButton(
        onPressed: () {
          controller.increment(); // Call controller's method
        },
        child: Icon(Icons.add),
      ),
    );
  }
}
```
**Explanation:**
*   `final CounterController controller = Get.find<CounterController>();` asks GetX to give us the instance of `CounterController` it's managing.
*   Inside the `Obx` widget (from [Chapter 3: Obx / ObxWidget](03_obx___obxwidget_.md)), we access `controller.count.value` to display the reactive count.
*   In `onPressed` for the button, we call `controller.increment()` to execute the logic defined in our controller.

Now, run this app. It works just like our previous counter, but the state and logic are much better organized within `CounterController`!

### Controller Lifecycle: `onInit()`, `onReady()`, `onClose()`

`GetxController`s have a lifecycle, meaning special methods are called automatically at certain points:

*   **`onInit()`:** Called right after the controller is allocated in memory (after its constructor) but *before* the widget that uses it is built for the first time. This is the perfect place to:
    *   Initialize data.
    *   Set up [Workers](04_workers_.md) to listen to reactive variable changes.
    *   Make initial API calls.

    ```dart
    class MyController extends GetxController {
      var data = ''.obs;

      @override
      void onInit() {
        super.onInit(); // Always call super.onInit()
        print("MyController onInit!");
        // Example: Fetch initial data or set up a worker
        ever(data, (_) => print("Data changed in MyController: ${data.value}"));
        data.value = "Initial Data";
      }
    }
    ```
    Output (when `MyController` is `put`):
    ```
    MyController onInit!
    Data changed in MyController: Initial Data
    ```

*   **`onReady()`:** Called a moment *after* the widget associated with this controller is rendered on screen for the first time. Useful if you need to do something *after* the UI is visible (e.g., show an intro animation or dialog).

    ```dart
    class MyController extends GetxController {
      @override
      void onReady() {
        super.onReady(); // Always call super.onReady()
        print("MyController onReady! UI is now visible.");
        // Get.snackbar("Hint", "Controller is ready and UI is built!");
      }
    }
    ```

*   **`onClose()`:** Called just before the controller is removed from memory. This happens when it's no longer needed (e.g., the screen is closed, or `Get.delete<MyController>()` is called). This is crucial for:
    *   Cleaning up resources.
    *   Disposing of [Workers](04_workers_.md).
    *   Canceling stream subscriptions or closing database connections to prevent memory leaks.

    ```dart
    class MyController extends GetxController {
      late Worker _dataWorker;
      var data = ''.obs;

      @override
      void onInit() {
        super.onInit();
        _dataWorker = ever(data, (_) => print("Data: ${data.value}"));
      }

      @override
      void onClose() {
        print("MyController onClose! Cleaning up.");
        _dataWorker.dispose(); // IMPORTANT: Dispose workers!
        super.onClose(); // Always call super.onClose()
      }
    }
    ```
    **Explanation:** If you create workers, timers, or other listeners in `onInit()`, you *must* clean them up in `onClose()` to avoid problems.

### The `update()` Method: For Manual UI Refreshes

So far, our counter UI updates automatically because `count` is an `RxInt` and we're using `Obx`. `Obx` rebuilds when `count.value` changes.

However, sometimes you might have:
*   Regular Dart variables (not `.obs`) in your controller.
*   Complex logic where you want to decide *exactly* when to tell the UI to refresh.

For these "manual" updates, `GetxController` provides the `update()` method. When you call `update()` from within your controller, it signals to any `GetBuilder` widgets listening to this controller that they should rebuild.

```dart
class ManualUpdateController extends GetxController {
  int manualCount = 0; // A regular int, not reactive

  void incrementManualCount() {
    manualCount++;
    update(); // Tell listening GetBuilders to refresh!
    print("Manual count incremented: $manualCount. Update called.");
  }
}
```
**Explanation:**
*   `manualCount` is just a normal integer.
*   When `incrementManualCount()` is called, it changes `manualCount` and then calls `update()`.
*   This `update()` call will trigger any `GetBuilder` associated with this `ManualUpdateController` to rebuild itself and display the new `manualCount`.

We'll learn all about `GetBuilder` in [Chapter 7: GetBuilder](07_getbuilder_.md). For now, understand that `update()` is the controller's way of manually triggering UI refreshes for widgets that use `GetBuilder`.

## Under the Hood: What Makes a GetxController Tick?

A `GetxController` isn't just an empty class. It gets its powers from a few key pieces in the GetX framework:

*   It `extends ListNotifier` (from `get_state_manager/src/simple/list_notifier.dart`).
*   `ListNotifier` mixes in `GetLifeCycleMixin` (from `get_state_manager/src/rx_flutter/rx_notifier.dart` indirectly through its own mixins or base classes).

Let's see what these provide:

1.  **`GetLifeCycleMixin`:** This mixin is responsible for the lifecycle methods (`onInit`, `onReady`, `onClose`). When a controller is `put` using `Get.put()`, GetX's dependency management system knows it's a `GetLifeCycleMixin` and hooks into its lifecycle, calling these methods at the appropriate times. It also handles cleaning up the controller (calling `onClose`) when it's deleted (e.g., with `Get.delete()`).

2.  **`ListNotifier` (and its `ListNotifierSingleMixin`):** This is the heart of the manual `update()` mechanism.
    *   It maintains a list of listeners (callbacks).
    *   When you call `update()` in your controller, it actually calls `refresh()` (a method from `ListNotifierSingleMixin`).
    *   `refresh()` then iterates through all its registered listeners and calls them.
    *   Widgets like `GetBuilder` (which we'll see in [Chapter 7: GetBuilder](07_getbuilder_.md)) add themselves as listeners to the controller. So, when `refresh()` is called, the `GetBuilder`'s "update me" function gets executed, causing it to rebuild.

Here's a simplified conceptual flow for the `update()` mechanism:

```mermaid
sequenceDiagram
    participant UserAction as User Taps Button
    participant YourController as MyController
    participant ListNotifierMixin as (Part of MyController)
    participant GetBuilderWidget as GetBuilder (UI Widget)

    UserAction->>YourController: Calls controller.someMethod()
    YourController->>YourController: Logic updates non-Rx state (e.g., `manualCount++`)
    YourController->>ListNotifierMixin: Calls this.update()
    Note over ListNotifierMixin: update() internally calls refresh()
    ListNotifierMixin-->>GetBuilderWidget: Notifies its listener (the GetBuilder's update function)
    GetBuilderWidget->>GetBuilderWidget: Rebuilds itself to show new state
```

The actual code in `GetxController` for `update()` is quite simple:
```dart
// From: get_state_manager/src/simple/get_controllers.dart
abstract class GetxController extends ListNotifier with GetLifeCycleMixin {
  void update([List<Object>? ids, bool condition = true]) {
    if (!condition) {
      return;
    }
    if (ids == null) {
      refresh(); // From ListNotifierSingleMixin
    } else {
      for (final id in ids) {
        refreshGroup(id); // Also from ListNotifier, for targeted updates
      }
    }
  }
}
```
And `refresh()` in `ListNotifierSingleMixin` (simplified):
```dart
// From: get_state_manager/src/simple/list_notifier.dart
mixin ListNotifierSingleMixin on Listenable {
  List<GetStateUpdate>? _updaters = <GetStateUpdate>[]; // List of listeners

  // ... other methods ...

  @protected
  void refresh() {
    // Take a copy of listeners, in case list changes during iteration
    final list = _updaters?.toList() ?? [];
    for (var element in list) {
      element(); // Call each listener (e.g., GetBuilder's update function)
    }
  }
}
```
So, `GetxController` elegantly combines lifecycle management with a notification system to manage state and communicate changes to the UI.

## Conclusion

You've now met `GetxController`, the cornerstone for organizing your application's state and logic in GetX! It acts as a dedicated manager for your features or screen sections, holding data (often reactive), business logic, and providing lifecycle hooks (`onInit`, `onClose`) for setup and cleanup. You also learned about its `update()` method, which is essential for manually refreshing UI parts when using `GetBuilder`.

By using `GetxController`, you can create cleaner, more maintainable, and better-structured Flutter applications.

We've seen how to *create* controllers and *make them available* with a quick `Get.put()`. But how exactly does GetX manage these controllers? How many ways are there to "put" and "find" them? That's what we'll explore next in [Chapter 6: Dependency Access (Binder, Bind.of, Get.find/put)](06_dependency_access__binder__bind_of__get_find_put__.md).

Relevant Code Snippets (Code itself remains unchanged):
--- File: get_state_manager/src/simple/get_state.dart ---
// ignore_for_file: overridden_fields

import 'dart:async';

import 'package:flutter/material.dart';

import '../../../instance_manager.dart';
import '../../get_state_manager.dart';
import 'list_notifier.dart';

typedef InitBuilder<T> = T Function();

typedef GetControllerBuilder<T extends GetLifeCycleMixin> = Widget Function(
    T controller);

extension WatchExt on BuildContext {
  T listen<T>() {
    return Bind.of(this, rebuild: true);
  }
}

extension ReadExt on BuildContext {
  T get<T>() {
    return Bind.of(this);
  }
}

// extension FilterExt on BuildContext {
//   T filter<T extends GetxController>(Object Function(T value)? filter) {
//     return Bind.of(this, filter: filter, rebuild: true);
//   }
// }

class GetBuilder<T extends GetxController> extends StatelessWidget {
  final GetControllerBuilder<T> builder;
  final bool global;
  final Object? id;
  final String? tag;
  final bool autoRemove;
  final bool assignId;
  final Object Function(T value)? filter;
  final void Function(BindElement<T> state)? initState,
      dispose,
      didChangeDependencies;
  final void Function(Binder<T> oldWidget, BindElement<T> state)?
      didUpdateWidget;
  final T? init;

  const GetBuilder({
    super.key,
    this.init,
    this.global = true,
    required this.builder,
    this.autoRemove = true,
    this.assignId = false,
    this.initState,
    this.filter,
    this.tag,
    this.dispose,
    this.id,
    this.didChangeDependencies,
    this.didUpdateWidget,
  });

  @override
  Widget build(BuildContext context) {
    return Binder(
      init: init == null ? null : () => init!,
      global: global,
      autoRemove: autoRemove,
      assignId: assignId,
      initState: initState,
      filter: filter,
      tag: tag,
      dispose: dispose,
      id: id,
      lazy: false,
      didChangeDependencies: didChangeDependencies,
      didUpdateWidget: didUpdateWidget,
      child: Builder(builder: (context) {
        final controller = Bind.of<T>(context, rebuild: true);
        return builder(controller);
      }),
    );
    // return widget.builder(controller!);
  }
}

abstract class Bind<T> extends StatelessWidget {
  const Bind({
    super.key,
    required this.child,
    this.init,
    this.global = true,
    this.autoRemove = true,
    this.assignId = false,
    this.initState,
    this.filter,
    this.tag,
    this.dispose,
    this.id,
    this.didChangeDependencies,
    this.didUpdateWidget,
  });

  final InitBuilder<T>? init;

  final bool global;
  final Object? id;
  final String? tag;
  final bool autoRemove;
  final bool assignId;
  final Object Function(T value)? filter;
  final void Function(BindElement<T> state)? initState,
      dispose,
      didChangeDependencies;
  final void Function(Binder<T> oldWidget, BindElement<T> state)?
      didUpdateWidget;

  final Widget? child;

  static Bind put<S>(
    S dependency, {
    String? tag,
    bool permanent = false,
  }) {
    Get.put<S>(dependency, tag: tag, permanent: permanent);
    return _FactoryBind<S>(
      autoRemove: permanent,
      assignId: true,
      tag: tag,
    );
  }

  static bool fenixMode = false;

  static Bind lazyPut<S>(
    InstanceBuilderCallback<S> builder, {
    String? tag,
    bool? fenix,
    // VoidCallback? onInit,
    VoidCallback? onClose,
  }) {
    Get.lazyPut<S>(builder, tag: tag, fenix: fenix ?? fenixMode);
    return _FactoryBind<S>(
      tag: tag,
      // initState: (_) {
      //   onInit?.call();
      // },
      dispose: (_) {
        onClose?.call();
      },
    );
  }

  static Bind create<S>(InstanceCreateBuilderCallback<S> builder,
      {String? tag, bool permanent = true}) {
    return _FactoryBind<S>(
      create: builder,
      tag: tag,
      global: false,
    );
  }

  static Bind spawn<S>(InstanceBuilderCallback<S> builder,
      {String? tag, bool permanent = true}) {
    Get.spawn<S>(builder, tag: tag, permanent: permanent);
    return _FactoryBind<S>(
      tag: tag,
      global: false,
      autoRemove: permanent,
    );
  }

  static S find<S>({String? tag}) => Get.find<S>(tag: tag);

  static Future<bool> delete<S>({String? tag, bool force = false}) async =>
      Get.delete<S>(tag: tag, force: force);

  static Future<void> deleteAll({bool force = false}) async =>
      Get.deleteAll(force: force);

  static void reloadAll({bool force = false}) => Get.reloadAll(force: force);

  static void reload<S>({String? tag, String? key, bool force = false}) =>
      Get.reload<S>(tag: tag, key: key, force: force);

  static bool isRegistered<S>({String? tag}) => Get.isRegistered<S>(tag: tag);

  static bool isPrepared<S>({String? tag}) => Get.isPrepared<S>(tag: tag);

  static void replace<P>(P child, {String? tag}) {
    final info = Get.getInstanceInfo<P>(tag: tag);
    final permanent = (info.isPermanent ?? false);
    delete<P>(tag: tag, force: permanent);
    Get.put(child, tag: tag, permanent: permanent);
  }

  static void lazyReplace<P>(InstanceBuilderCallback<P> builder,
      {String? tag, bool? fenix}) {
    final info = Get.getInstanceInfo<P>(tag: tag);
    final permanent = (info.isPermanent ?? false);
    delete<P>(tag: tag, force: permanent);
    Get.lazyPut(builder, tag: tag, fenix: fenix ?? permanent);
  }

  factory Bind.builder({
    Widget? child,
    InitBuilder<T>? init,
    InstanceCreateBuilderCallback<T>? create,
    bool global = true,
    bool autoRemove = true,
    bool assignId = false,
    Object Function(T value)? filter,
    String? tag,
    Object? id,
    void Function(BindElement<T> state)? initState,
    void Function(BindElement<T> state)? dispose,
    void Function(BindElement<T> state)? didChangeDependencies,
    void Function(Binder<T> oldWidget, BindElement<T> state)? didUpdateWidget,
  }) =>
      _FactoryBind<T>(
        // key: key,
        init: init,
        create: create,
        global: global,
        autoRemove: autoRemove,
        assignId: assignId,
        initState: initState,
        filter: filter,
        tag: tag,
        dispose: dispose,
        id: id,
        didChangeDependencies: didChangeDependencies,
        didUpdateWidget: didUpdateWidget,
        child: child,
      );

  static T of<T>(
    BuildContext context, {
    bool rebuild = false,
    // Object Function(T value)? filter,
  }) {
    final inheritedElement =
        context.getElementForInheritedWidgetOfExactType<Binder<T>>()
            as BindElement<T>?;

    if (inheritedElement == null) {
      throw BindError(controller: '$T', tag: null);
    }

    if (rebuild) {
      // var newFilter = filter?.call(inheritedElement.controller!);
      // if (newFilter != null) {
      //  context.dependOnInheritedElement(inheritedElement, aspect: newFilter);
      // } else {
      context.dependOnInheritedElement(inheritedElement);
      // }
    }

    final controller = inheritedElement.controller;

    return controller;
  }

  @factory
  Bind<T> _copyWithChild(Widget child);
}

class _FactoryBind<T> extends Bind<T> {
  @override
  final InitBuilder<T>? init;

  final InstanceCreateBuilderCallback<T>? create;

  @override
  final bool global;
  @override
  final Object? id;
  @override
  final String? tag;
  @override
  final bool autoRemove;
  @override
  final bool assignId;
  @override
  final Object Function(T value)? filter;

  @override
  final void Function(BindElement<T> state)? initState,
      dispose,
      didChangeDependencies;
  @override
  final void Function(Binder<T> oldWidget, BindElement<T> state)?
      didUpdateWidget;

  @override
  final Widget? child;

  const _FactoryBind({
    super.key,
    this.child,
    this.init,
    this.create,
    this.global = true,
    this.autoRemove = true,
    this.assignId = false,
    this.initState,
    this.filter,
    this.tag,
    this.dispose,
    this.id,
    this.didChangeDependencies,
    this.didUpdateWidget,
  }) : super(child: child);

  @override
  Bind<T> _copyWithChild(Widget child) {
    return Bind<T>.builder(
      init: init,
      create: create,
      global: global,
      autoRemove: autoRemove,
      assignId: assignId,
      initState: initState,
      filter: filter,
      tag: tag,
      dispose: dispose,
      id: id,
      didChangeDependencies: didChangeDependencies,
      didUpdateWidget: didUpdateWidget,
      child: child,
    );
  }

  @override
  Widget build(BuildContext context) {
    return Binder<T>(
      create: create,
      global: global,
      autoRemove: autoRemove,
      assignId: assignId,
      initState: initState,
      filter: filter,
      tag: tag,
      dispose: dispose,
      id: id,
      didChangeDependencies: didChangeDependencies,
      didUpdateWidget: didUpdateWidget,
      child: child!,
    );
  }
}

class Binds extends StatelessWidget {
  final List<Bind<dynamic>> binds;
  final Widget child;

  Binds({
    super.key,
    required this.binds,
    required this.child,
  }) : assert(binds.isNotEmpty);

  @override
  Widget build(BuildContext context) =>
      binds.reversed.fold(child, (widget, e) => e._copyWithChild(widget));
}

class Binder<T> extends InheritedWidget {
  /// Create an inherited widget that updates its dependents when [controller]
  /// sends notifications.
  ///
  /// The [child] argument is required
  const Binder({
    super.key,
    required super.child,
    this.init,
    this.global = true,
    this.autoRemove = true,
    this.assignId = false,
    this.lazy = true,
    this.initState,
    this.filter,
    this.tag,
    this.dispose,
    this.id,
    this.didChangeDependencies,
    this.didUpdateWidget,
    this.create,
  });

  final InitBuilder<T>? init;
  final InstanceCreateBuilderCallback? create;
  final bool global;
  final Object? id;
  final String? tag;
  final bool lazy;
  final bool autoRemove;
  final bool assignId;
  final Object Function(T value)? filter;
  final void Function(BindElement<T> state)? initState,
      dispose,
      didChangeDependencies;
  final void Function(Binder<T> oldWidget, BindElement<T> state)?
      didUpdateWidget;

  @override
  bool updateShouldNotify(Binder<T> oldWidget) {
    return oldWidget.id != id ||
        oldWidget.global != global ||
        oldWidget.autoRemove != autoRemove ||
        oldWidget.assignId != assignId;
  }

  @override
  InheritedElement createElement() => BindElement<T>(this);
}

/// The BindElement is responsible for injecting dependencies into the widget
/// tree so that they can be observed
class BindElement<T> extends InheritedElement {
  BindElement(Binder<T> super.widget) {
    initState();
  }

  final disposers = <Disposer>[];

  InitBuilder<T>? _controllerBuilder;

  T? _controller;

  T get controller {
    if (_controller == null) {
      _controller = _controllerBuilder?.call();
      _subscribeToController();
      if (_controller == null) {
        throw BindError(controller: T, tag: widget.tag);
      }
      return _controller!;
    } else {
      return _controller!;
    }
  }

  bool? _isCreator = false;
  bool? _needStart = false;
  bool _wasStarted = false;
  VoidCallback? _remove;
  Object? _filter;

  void initState() {
    widget.initState?.call(this);

    var isRegistered = Get.isRegistered<T>(tag: widget.tag);

    if (widget.global) {
      if (isRegistered) {
        if (Get.isPrepared<T>(tag: widget.tag)) {
          _isCreator = true;
        } else {
          _isCreator = false;
        }

        _controllerBuilder = () => Get.find<T>(tag: widget.tag);
      } else {
        _controllerBuilder =
            () => (widget.create?.call(this) ?? widget.init?.call());
        _isCreator = true;
        if (widget.lazy) {
          Get.lazyPut<T>(_controllerBuilder!, tag: widget.tag);
        } else {
          Get.put<T>(_controllerBuilder!(), tag: widget.tag);
        }
      }
    } else {
      if (widget.create != null) {
        _controllerBuilder = () => widget.create!.call(this);
        Get.spawn<T>(_controllerBuilder!, tag: widget.tag, permanent: false);
      } else {
        _controllerBuilder = widget.init;
      }
      _controllerBuilder =
          (widget.create != null ? () => widget.create!.call(this) : null) ??
              widget.init;
      _isCreator = true;
      _needStart = true;
    }
  }

  /// Register to listen Controller's events.
  /// It gets a reference to the remove() callback, to delete the
  /// setState "link" from the Controller.
  void _subscribeToController() {
    if (widget.filter != null) {
      _filter = widget.filter!(_controller as T);
    }
    final filter = _filter != null ? _filterUpdate : getUpdate;
    final localController = _controller;

    if (_needStart == true && localController is GetLifeCycleMixin) {
      localController.onStart();
      _needStart = false;
      _wasStarted = true;
    }

    if (localController is GetxController) {
      _remove?.call();
      _remove = (widget.id == null)
          ? localController.addListener(filter)
          : localController.addListenerId(widget.id, filter);
    } else if (localController is Listenable) {
      _remove?.call();
      localController.addListener(filter);
      _remove = () => localController.removeListener(filter);
    } else if (localController is StreamController) {
      _remove?.call();
      final stream = localController.stream.listen((_) => filter());
      _remove = () => stream.cancel();
    }
  }

  void _filterUpdate() {
    var newFilter = widget.filter!(_controller as T);
    if (newFilter != _filter) {
      _filter = newFilter;
      getUpdate();
    }
  }

  void dispose() {
    widget.dispose?.call(this);
    if (_isCreator! || widget.assignId) {
      if (widget.autoRemove && Get.isRegistered<T>(tag: widget.tag)) {
        Get.delete<T>(tag: widget.tag);
      }
    }

    for (final disposer in disposers) {
      disposer();
    }

    disposers.clear();

    _remove?.call();
    _controller = null;
    _isCreator = null;
    _remove = null;
    _filter = null;
    _needStart = null;
    _controllerBuilder = null;
    _controller = null;
  }

  @override
  Binder<T> get widget => super.widget as Binder<T>;

  var _dirty = false;

  @override
  void update(Binder<T> newWidget) {
    final oldNotifier = widget.id;
    final newNotifier = newWidget.id;
    if (oldNotifier != newNotifier && _wasStarted) {
      _subscribeToController();
    }
    widget.didUpdateWidget?.call(widget, this);
    super.update(newWidget);
  }

  @override
  void didChangeDependencies() {
    super.didChangeDependencies();
    widget.didChangeDependencies?.call(this);
  }

  @override
  Widget build() {
    if (_dirty) {
      notifyClients(widget);
    }
    // return Notifier.instance.notifyAppend(
    //   NotifyData(
    //       disposers: disposers, updater: getUpdate, throwException: false),
    return super.build();
    //);
  }

  void getUpdate() {
    _dirty = true;
    markNeedsBuild();
  }

  @override
  void notifyClients(Binder<T> oldWidget) {
    super.notifyClients(oldWidget);
    _dirty = false;
  }

  @override
  void unmount() {
    dispose();
    super.unmount();
  }
}

class BindError<T> extends Error {
  /// The type of the class the user tried to retrieve
  final T controller;
  final String? tag;

  /// Creates a [BindError]
  BindError({required this.controller, required this.tag});

  @override
  String toString() {
    if (controller == 'dynamic') {
      return '''Error: please specify type [<T>] when calling context.listen<T>() or context.find<T>() method.''';
    }

    return '''Error: No Bind<$controller>  ancestor found. To fix this, please add a Bind<$controller> widget ancestor to the current context.
      ''';
  }
}

/// [Binding] should be extended.
/// When using `GetMaterialApp`, all `GetPage`s and navigation
/// methods (like Get.to()) have a `binding` property that takes an
/// instance of Bindings to manage the
/// dependencies() (via Get.put()) for the Route you are opening.
// ignore: one_member_abstracts
abstract class Binding extends BindingsInterface<List<Bind>> {}


--- File: get_state_manager/src/simple/get_view.dart ---
import 'package:flutter/widgets.dart';

import '../../../instance_manager.dart';
import '../../../utils.dart';
import 'get_state.dart';
import 'get_widget_cache.dart';

/// GetView is a great way of quickly access your Controller
/// without having to call `Get.find<AwesomeController>()` yourself.
///
/// Sample:
/// ```
/// class AwesomeController extends GetxController {
///   final String title = 'My Awesome View';
/// }
///
/// class AwesomeView extends GetView<AwesomeController> {
///   /// if you need you can pass the tag for
///   /// Get.find<AwesomeController>(tag:"myTag");
///   @override
///   final String tag = "myTag";
///
///   AwesomeView({Key key}):super(key:key);
///
///   @override
///   Widget build(BuildContext context) {
///     return Container(
///       padding: EdgeInsets.all(20),
///       child: Text( controller.title ),
///     );
///   }
/// }
///``
abstract class GetView<T> extends StatelessWidget {
  const GetView({super.key});

  final String? tag = null;

  T get controller => Get.find<T>(tag: tag)!;

  @override
  Widget build(BuildContext context);
}

/// GetWidget is a great way of quickly access your individual Controller
/// without having to call `Get.find<AwesomeController>()` yourself.
/// Get save you controller on cache, so, you can to use Get.create() safely
/// GetWidget is perfect to multiples instance of a same controller. Each
/// GetWidget will have your own controller, and will be call events as `onInit`
/// and `onClose` when the controller get in/get out on memory.
abstract class GetWidget<S extends GetLifeCycleMixin> extends GetWidgetCache {
  const GetWidget({super.key});

  @protected
  final String? tag = null;

  S get controller => GetWidget._cache[this] as S;

  // static final _cache = <GetWidget, GetLifeCycleBase>{};

  static final _cache = Expando<GetLifeCycleMixin>();

  @protected
  Widget build(BuildContext context);

  @override
  WidgetCache createWidgetCache() => _GetCache<S>();
}

class _GetCache<S extends GetLifeCycleMixin> extends WidgetCache<GetWidget<S>> {
  S? _controller;
  bool _isCreator = false;
  InstanceInfo? info;
  @override
  void onInit() {
    info = Get.getInstanceInfo<S>(tag: widget!.tag);

    _isCreator = info!.isPrepared && info!.isCreate;

    if (info!.isRegistered) {
      _controller = Get.find<S>(tag: widget!.tag);
    }

    GetWidget._cache[widget!] = _controller;

    super.onInit();
  }

  @override
  void onClose() {
    if (_isCreator) {
      Get.asap(() {
        widget!.controller.onDelete();
        Get.log('"${widget!.controller.runtimeType}" onClose() called');
        Get.log('"${widget!.controller.runtimeType}" deleted from memory');
        // GetWidget._cache[widget!] = null;
      });
    }
    info = null;
    super.onClose();
  }

  @override
  Widget build(BuildContext context) {
    return Binder(
      init: () => _controller,
      child: widget!.build(context),
    );
  }
}


--- File: get_state_manager/src/rx_flutter/rx_getx_widget.dart ---
import 'package:flutter/foundation.dart';
import 'package:flutter/widgets.dart';

import '../../../get_core/get_core.dart';
import '../../../get_instance/src/extension_instance.dart';
import '../../../get_instance/src/lifecycle.dart';
import '../simple/list_notifier.dart';

typedef GetXControllerBuilder<T extends GetLifeCycleMixin> = Widget Function(
    T controller);

class GetX<T extends GetLifeCycleMixin> extends StatefulWidget {
  final GetXControllerBuilder<T> builder;
  final bool global;
  final bool autoRemove;
  final bool assignId;
  final void Function(GetXState<T> state)? initState,
      dispose,
      didChangeDependencies;
  final void Function(GetX oldWidget, GetXState<T> state)? didUpdateWidget;
  final T? init;
  final String? tag;

  const GetX({
    super.key,
    this.tag,
    required this.builder,
    this.global = true,
    this.autoRemove = true,
    this.initState,
    this.assignId = false,
    //  this.stream,
    this.dispose,
    this.didChangeDependencies,
    this.didUpdateWidget,
    this.init,
    // this.streamController
  });

  @override
  StatefulElement createElement() => StatefulElement(this);

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
      ..add(
        DiagnosticsProperty<T>('controller', init),
      )
      ..add(DiagnosticsProperty<String>('tag', tag))
      ..add(
          ObjectFlagProperty<GetXControllerBuilder<T>>.has('builder', builder));
  }

  @override
  GetXState<T> createState() => GetXState<T>();
}

class GetXState<T extends GetLifeCycleMixin> extends State<GetX<T>> {
  T? controller;
  bool? _isCreator = false;

  @override
  void initState() {
    // var isPrepared = Get.isPrepared<T>(tag: widget.tag);
    final isRegistered = Get.isRegistered<T>(tag: widget.tag);

    if (widget.global) {
      if (isRegistered) {
        _isCreator = Get.isPrepared<T>(tag: widget.tag);
        controller = Get.find<T>(tag: widget.tag);
      } else {
        controller = widget.init;
        _isCreator = true;
        Get.put<T>(controller!, tag: widget.tag);
      }
    } else {
      controller = widget.init;
      _isCreator = true;
      controller?.onStart();
    }
    widget.initState?.call(this);
    if (widget.global && Get.smartManagement == SmartManagement.onlyBuilder) {
      controller?.onStart();
    }

    super.initState();
  }

  @override
  void didChangeDependencies() {
    super.didChangeDependencies();
    if (widget.didChangeDependencies != null) {
      widget.didChangeDependencies!(this);
    }
  }

  @override
  void didUpdateWidget(GetX oldWidget) {
    super.didUpdateWidget(oldWidget as GetX<T>);
    widget.didUpdateWidget?.call(oldWidget, this);
  }

  @override
  void dispose() {
    if (widget.dispose != null) widget.dispose!(this);
    if (_isCreator! || widget.assignId) {
      if (widget.autoRemove && Get.isRegistered<T>(tag: widget.tag)) {
        Get.delete<T>(tag: widget.tag);
      }
    }

    for (final disposer in disposers) {
      disposer();
    }

    disposers.clear();

    controller = null;
    _isCreator = null;
    super.dispose();
  }

  void _update() {
    if (mounted) {
      setState(() {});
    }
  }

  final disposers = <Disposer>[];

  @override
  Widget build(BuildContext context) => Notifier.instance.append(
      NotifyData(disposers: disposers, updater: _update),
      () => widget.builder(controller!));

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties.add(DiagnosticsProperty<T>('controller', controller));
  }
}


Instructions for the chapter (Generate content in English unless specified otherwise):
- Start with a clear heading (e.g., `# Chapter 6: Dependency Access (Binder, Bind.of, Get.find/put)
`). Use the provided concept name.

- If this is not the first chapter, begin with a brief transition from the previous chapter, referencing it with a proper Markdown link using its name.

- Begin with a high-level motivation explaining what problem this abstraction solves. Start with a central use case as a concrete example. The whole chapter should guide the reader to understand how to solve this use case. Make it very minimal and friendly to beginners.

- If the abstraction is complex, break it down into key concepts. Explain each concept one-by-one in a very beginner-friendly way.

- Explain how to use this abstraction to solve the use case. Give example inputs and outputs for code snippets (if the output isn't values, describe at a high level what will happen).

- Each code block should be BELOW 10 lines! If longer code blocks are needed, break them down into smaller pieces and walk through them one-by-one. Aggresively simplify the code to make it minimal. Use comments to skip non-important implementation details. Each code block should have a beginner friendly explanation right after it.

- Describe the internal implementation to help understand what's under the hood. First provide a non-code or code-light walkthrough on what happens step-by-step when the abstraction is called. It's recommended to use a simple sequenceDiagram with a dummy example - keep it minimal with at most 5 participants to ensure clarity. If participant name has space, use: `participant QP as Query Processing`. .

- Then dive deeper into code for the internal implementation with references to files. Provide example code blocks, but make them similarly simple and beginner-friendly. Explain.

- IMPORTANT: When you need to refer to other core abstractions covered in other chapters, ALWAYS use proper Markdown links like this: [Chapter Title](filename.md). Use the Complete Tutorial Structure above to find the correct filename and the chapter title. Translate the surrounding text.

- Use mermaid diagrams to illustrate complex concepts (```mermaid``` format). .

- Heavily use analogies and examples throughout to help beginners understand.

- End the chapter with a brief conclusion that summarizes what was learned and provides a transition to the next chapter. If there is a next chapter, use a proper Markdown link: [Next Chapter Title](next_chapter_filename).

- Ensure the tone is welcoming and easy for a newcomer to understand.

- Output *only* the Markdown content for this chapter.

Now, directly provide a super beginner-friendly Markdown output (DON'T need ```markdown``` tags):

2025-05-12 13:37:11,998 - INFO - RESPONSE: # Chapter 6: Dependency Access (Binder, Bind.of, Get.find/put)

In [Chapter 5: GetxController](05_getxcontroller_.md), we learned how to organize our app's "brains"its data and logicinto `GetxController` classes. Now, once we have these controllers (our dependencies), how do we make them available to the parts of our app (usually widgets) that need them? How does a widget get a "wire" to its controller?

GetX provides a flexible system for this, acting like a combination of a central warehouse and local delivery services for your app's dependencies. Let's explore the main ways: `Get.put()`, `Get.find()`, `Binder`, and `Bind.of(context)`.

## What Problem Are We Solving?

Imagine you have a `UserProfileController` that manages user data.
```dart
// A simple controller (more details in Chapter 5)
class UserProfileController extends GetxController {
  final userName = 'Guest'.obs;
  void login(String name) {
    userName.value = name;
  }
}
```
Several different widgets in your app might need to display the `userName` or call the `login` method:
*   A `ProfileHeaderWidget` in the app bar.
*   A `SettingsScreenWidget` deep in the navigation stack.

How do these widgets get access to the *same instance* of `UserProfileController` without manually passing it down through many widget constructors (which is called "prop drilling" and can be messy)? This is where GetX's dependency access tools come in.

## 1. The Global Warehouse: `Get.put()` and `Get.find()`

Think of `Get.put()` and `Get.find()` as your app's central, global warehouse for important items (your controllers or other services).

### `Get.put()`: Storing Your Dependency

`Get.put(SomeClass())` is like taking an instance of `SomeClass` and placing it into a secure, well-organized global storage area managed by GetX. Once "put," this instance is generally available throughout your app. You usually do this when your app starts, or when a feature that needs the controller is first initialized.

```dart
// main.dart or an initialization file
void main() {
  // Put an instance of UserProfileController into GetX's global storage
  Get.put(UserProfileController());
  runApp(MyApp());
}
```
**What happens?**
An instance of `UserProfileController` is created and registered with GetX. By default, `Get.put()` creates a **singleton**, meaning there will only be one instance of `UserProfileController` managed by this global `put`.

### `Get.find()`: Retrieving Your Dependency

`Get.find<SomeClass>()` is like going to the warehouse and asking for the instance of `SomeClass` you stored earlier. GetX will locate it and give it to you.

Any widget, anywhere in your app (after the `Get.put()` has happened), can then get access to that controller:

```dart
// profile_header_widget.dart
class ProfileHeaderWidget extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    // Find the globally available UserProfileController
    final userController = Get.find<UserProfileController>();

    return Obx(() => Text("User: ${userController.userName.value}"));
  }
}

// settings_screen_widget.dart
class SettingsScreenWidget extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    // Find the same globally available UserProfileController
    final userController = Get.find<UserProfileController>();

    return ElevatedButton(
      onPressed: () => userController.login("Alice"),
      child: Text("Login as Alice"),
    );
  }
}
```
**What happens?**
Both `ProfileHeaderWidget` and `SettingsScreenWidget` will receive the *exact same instance* of `UserProfileController` that was registered with `Get.put()`. Changes made through one widget (like logging in) will be reflected in the other (the username display updates).

**When to use `Get.put()`/`Get.find()`?**
This global approach is great for dependencies that:
*   Need to be singletons (only one instance throughout the app).
*   Need to be easily accessible from many disparate parts of your application without complex wiring.

### Under the Hood: `Get.put()` and `Get.find()`

As we touched upon in [Chapter 1: Get (Global Access Facade)](01_get__global_access_facade__.md), GetX maintains an internal "Instance Manager" (conceptually, a map where keys are often types and values are the instances).

```mermaid
sequenceDiagram
    participant YourApp as Your App Startup
    participant GetPut as Get.put(UserProfileController())
    participant InstanceManager as GetX Instance Manager
    participant WidgetA as ProfileHeaderWidget
    participant GetFind as Get.find<UserProfileController>()

    YourApp->>GetPut: Calls Get.put(new UserProfileController())
    GetPut->>InstanceManager: Stores UserProfileController instance (e.g., by Type)
    Note over InstanceManager: UserProfileController now in global storage

    WidgetA->>GetFind: Calls Get.find<UserProfileController>()
    GetFind->>InstanceManager: Looks up UserProfileController by Type
    InstanceManager-->>GetFind: Returns stored instance
    GetFind-->>WidgetA: Provides instance to WidgetA
```

1.  **`Get.put(MyController())`**: When you call this, `Get` (via its `GetInstance` powers, mostly in `get_instance/src/get_instance.dart`) takes the `MyController` instance and stores it in a central collection (like a `Map<String, InstanceInternal>`). It often uses the Type of the controller (e.g., "MyController") and an optional "tag" to create a unique key for storage.
2.  **`Get.find<MyController>()`**: This method also uses `GetInstance` to look up the key (Type or Type+tag) in that central collection. If found, it returns the stored instance. If not found, it will throw an error.

This simple yet powerful mechanism is what allows `Get.find()` to retrieve dependencies from anywhere.

## 2. Local Delivery Service: `Binder` and `Bind.of(context)`

Sometimes, a global singleton isn't what you need.
*   What if a specific section of your app requires its *own*, independent instance of a controller?
*   What if you want to provide a dependency only to a specific widget and its children, without polluting the global scope?

This is where `Binder` and `Bind.of(context)` come in, acting like a "local delivery service" for your dependencies. `Binder` is a special widget from GetX (an `InheritedWidget` under the hood) that makes an instance of a controller available to all its descendant widgets in the tree.

### `Binder`: Providing a Dependency Locally

You wrap a part of your widget tree with `Binder` and tell it how to create or find the dependency it should provide.

Let's say you have a `ProductDetailController` that should only exist for a specific `ProductDetailScreen`.

```dart
// product_detail_controller.dart
class ProductDetailController extends GetxController {
  final productId;
  ProductDetailController(this.productId);

  void loadProductDetails() {
    print("Loading details for product ID: $productId");
    // ... fetch details ...
  }
  // ... other product specific logic ...
}

// product_detail_screen.dart
class ProductDetailScreen extends StatelessWidget {
  final String productId;
  ProductDetailScreen({required this.productId});

  @override
  Widget build(BuildContext context) {
    // Binder provides ProductDetailController to its children
    return Binder<ProductDetailController>(
      // 'init' creates the controller when Binder is built
      init: () => ProductDetailController(productId),
      // 'autoRemove: true' (default) means controller is disposed when screen is removed
      child: Scaffold(
        appBar: AppBar(title: Text("Product $productId")),
        body: ProductInfoDisplay(), // A child widget
      ),
    );
  }
}
```
**What happens?**
*   When `ProductDetailScreen` is built, the `Binder` widget is created.
*   The `init: () => ProductDetailController(productId)` function is called, creating a *new* instance of `ProductDetailController` specifically for this screen.
*   This instance is now available to `ProductInfoDisplay` and any other widgets inside this `Binder`'s `child` subtree.

### `Bind.of(context)`: Accessing the Locally Provided Dependency

Descendant widgets can then access this controller using `Bind.of<ControllerType>(context)`.

```dart
// product_info_display.dart (child of ProductDetailScreen's Binder)
class ProductInfoDisplay extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    // Access the ProductDetailController provided by an ancestor Binder
    final controller = Bind.of<ProductDetailController>(context);
    // Or, more conveniently, using an extension:
    // final controller = context.get<ProductDetailController>();

    controller.loadProductDetails(); // Call method on the local controller

    return Center(
      child: Text("Displaying info for product: ${controller.productId}"),
    );
  }
}
```
**What happens?**
*   `Bind.of<ProductDetailController>(context)` (or `context.get<ProductDetailController>()`) looks *up* the widget tree from `ProductInfoDisplay`.
*   It finds the nearest `Binder<ProductDetailController>` ancestor and retrieves the controller instance held by that `Binder`.
*   If you had two different `ProductDetailScreen`s on screen at once (e.g., in a split view), each would have its *own* `ProductDetailController` instance thanks to their respective `Binder`s.

**Important:** `Bind.of(context)` retrieves the dependency. If you also want the widget to rebuild when the controller calls `update()` (as discussed in [Chapter 5: GetxController](05_getxcontroller_.md) for `GetBuilder`), you would typically use `Bind.of(context, rebuild: true)` or its shorthand `context.listen<ProductDetailController>()`. This is what `GetBuilder` uses internally, as we'll see in [Chapter 7: GetBuilder](07_getbuilder_.md).


### Under the Hood: `Binder` and `Bind.of(context)`

`Binder` is essentially a specialized `InheritedWidget`. `InheritedWidget` is Flutter's standard way of passing data down the widget tree efficiently.

```mermaid
sequenceDiagram
    participant WidgetTree as ProductDetailScreen Builds
    participant BinderWidget as Binder<ProductDetailController>
    participant Flutter as Flutter Framework
    participant ChildWidget as ProductInfoDisplay
    participant BindOf as Bind.of(context) / context.get()

    WidgetTree->>BinderWidget: Creates Binder(init: () => ProductDetailController(...))
    BinderWidget->>BinderWidget: Initializes controller via 'init'
    Note over BinderWidget: Stores controller instance internally

    ChildWidget->>BindOf: Calls Bind.of<ProductDetailController>(context)
    BindOf->>Flutter: Asks Flutter: "Find nearest Binder<ProductDetailController> ancestor"
    Flutter-->>BindOf: Returns the found Binder's element
    BindOf->>BinderWidget: Accesses controller from Binder's element
    BinderWidget-->>BindOf: Returns controller instance
    BindOf-->>ChildWidget: Provides instance to ChildWidget
```

1.  **`Binder<T>(init: ..., child: ...)`**:
    *   This widget, defined in `get_state_manager/src/simple/get_state.dart`, extends `InheritedWidget`.
    *   When it's inserted into the tree, its `init` function is called (if provided and the controller isn't already globally available via `Get.put` in some configurations). It creates and holds an instance of your controller `T`.
    *   The `BindElement<T>` (its `Element`) holds the actual controller instance.

2.  **`Bind.of<T>(context)`**:
    *   This static method uses `context.getElementForInheritedWidgetOfExactType<Binder<T>>()`.
    *   This is a standard Flutter mechanism to efficiently find the nearest ancestor `Binder<T>` in the widget tree.
    *   Once found, it retrieves the controller instance from that `Binder`'s element.
    *   If `rebuild: true` is passed (or `context.listen<T>()` is used), it also establishes a dependency, so if that `Binder` later signals an update (because the controller called `update()`), this widget will rebuild.

## Global Warehouse vs. Local Delivery: Which to Choose?

*   **`Get.put()` / `Get.find()` (Global Warehouse):**
    *   **Pros:** Very easy to access truly global singletons from anywhere. Less boilerplate for simple global access.
    *   **Cons:** Can make it harder to track where a dependency is used. Testing can be trickier if everything relies on global state. Can be "too global" if a dependency is only needed in one section.
    *   **Use when:** For app-wide services (ThemeService, ApiService, UserSessionController) that are inherently singletons.

*   **`Binder` / `Bind.of(context)` (Local Delivery):**
    *   **Pros:** Dependencies are scoped to a specific part of the widget tree. Clearer where a dependency comes from (an ancestor `Binder`). Easier to have multiple, independent instances of the same controller type for different UI sections. Integrates naturally with Flutter's widget system and `BuildContext`. Better for testability of individual UI sections.
    *   **Cons:** Requires `BuildContext`. Slightly more verbose for providing the dependency (wrapping with `Binder`).
    *   **Use when:** A controller/dependency is specific to a particular screen or feature area. When you need multiple instancesManaging state for list items where each item might have its own controller. When you want to leverage Flutter's `InheritedWidget` patterns more directly.

Often, a GetX app will use a mix of both!

## Conclusion

You've now learned the key ways GetX helps you manage and access your dependencies:
*   `Get.put()` registers a dependency globally, making it like an item in a central warehouse.
*   `Get.find()` retrieves these globally registered dependencies.
*   `Binder` is an `InheritedWidget` that acts like a local delivery service, providing dependencies to a specific part of your widget tree.
*   `Bind.of(context)` (or context extensions like `context.get<T>()` and `context.listen<T>()`) allows descendant widgets to access these locally provided dependencies.

Understanding these mechanisms is crucial for building well-structured and maintainable GetX applications. You can now choose the right tool for the job, whether it's providing a global service or a locally scoped controller.

In the next chapter, we'll look at [Chapter 7: GetBuilder](07_getbuilder_.md). `GetBuilder` is a widget that often uses `Binder` and `Bind.of(context)` (or `Get.find()` implicitly) to listen to your `GetxController`'s manual `update()` calls and rebuild the UI efficiently.
2025-05-12 13:37:12,072 - INFO - PROMPT: 
Write a very beginner-friendly tutorial chapter (in Markdown format) for the project `lib` about the concept: "GetBuilder
". This is Chapter 7.

Concept Details:
- Name: GetBuilder

- Description:
`GetBuilder` is a widget that listens to a specific `GetxController`.
When you explicitly call the `update()` method on that controller, any associated
`GetBuilder` widgets will rebuild themselves to reflect the new state.
It's like a digital display in a store that only refreshes its content when the
store manager presses an "update display" button. This provides precise, manual control over UI updates for non-reactive state.


Complete Tutorial Structure:
1. [Get (Global Access Facade)
](01_get__global_access_facade__.md)
2. [Rx<T> (Reactive Variables)
](02_rx_t___reactive_variables__.md)
3. [Obx / ObxWidget
](03_obx___obxwidget_.md)
4. [Workers
](04_workers_.md)
5. [GetxController
](05_getxcontroller_.md)
6. [Dependency Access (Binder, Bind.of, Get.find/put)
](06_dependency_access__binder__bind_of__get_find_put__.md)
7. [GetBuilder
](07_getbuilder_.md)
8. [StateMixin
](08_statemixin_.md)
9. [ListNotifier (and Mixins)
](09_listnotifier__and_mixins__.md)

Context from previous chapters:
# Chapter 1: Get (Global Access Facade)

Welcome to your GetX journey! In this first chapter, we'll explore one of the most fundamental and frequently used parts of the GetX ecosystem: the `Get` object.

## What is `Get` and Why Do You Need It?

Imagine you're building a Flutter app. You often need to perform common tasks like:
*   Showing a quick message (a "snackbar") to the user.
*   Navigating to a new screen.
*   Accessing a shared service, like a settings manager, from various parts of your app.

Traditionally, in Flutter, many of these tasks require access to something called `BuildContext`. `BuildContext` tells Flutter "where" you are in your widget tree, which is necessary for operations like finding the nearest `Navigator` or `Scaffold`. Getting `BuildContext` to the exact spot where you need it can sometimes be cumbersome, especially in deeper parts of your app's logic that aren't directly part of a widget.

This is where `Get` comes to the rescue!

The `Get` object is your main entry point for most GetX features. Think of it as a **universal remote control** for your application. It provides super easy-to-use tools (called static methods) for:

*   **Dependency Management:** Storing and retrieving your app's services or "managers" (like a `UserSettingsManager` or `ApiService`).
*   **Navigation:** Moving between screens with simple commands.
*   **Showing UI Elements:** Displaying dialogs, snackbars, or bottom sheets.
*   ...and much more!

The beauty of `Get` is that it often lets you do these things **without needing `BuildContext`**, making your code cleaner and simplifying access to GetX functionalities from virtually anywhere in your app.

## How to Use `Get`

Using `Get` is incredibly straightforward because its methods are `static`. This means you don't need to create an instance of a `Get` class; you just type `Get.` followed by the feature you want to use.

Let's look at a few common use cases:

### 1. Showing a Snackbar

Need to show a quick notification to the user?

```dart
import 'package:get/get.dart'; // Make sure to import GetX

// ...somewhere in your code, even inside a business logic class
void showSuccessMessage() {
  Get.snackbar(
    "Success!", // title
    "Your profile was updated successfully.", // message
    snackPosition: SnackPosition.BOTTOM
  );
}
```

**What happens?**
When `showSuccessMessage()` is called, GetX will display a snackbar at the bottom of the current screen with the title "Success!" and the given message. Notice you didn't need to pass any `BuildContext`!

### 2. Navigating to a New Screen

Want to open a new page?

```dart
import 'package:flutter/material.dart';
import 'package:get/get.dart';

class HomeScreen extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(title: Text("Home")),
      body: Center(
        child: ElevatedButton(
          onPressed: () {
            Get.to(DetailScreen()); // Navigate to DetailScreen
          },
          child: Text("Go to Details"),
        ),
      ),
    );
  }
}

class DetailScreen extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(title: Text("Details")),
      body: Center(
        child: ElevatedButton(
          onPressed: () {
            Get.back(); // Go back to the previous screen
          },
          child: Text("Go Back"),
        ),
      ),
    );
  }
}
```
**What happens?**
*   Tapping the "Go to Details" button on `HomeScreen` will push `DetailScreen` onto the navigation stack, making it visible.
*   Tapping the "Go Back" button on `DetailScreen` will pop it from the stack, revealing `HomeScreen` again.

Again, simple and no `BuildContext` needed for `Get.to()` or `Get.back()`. (Note: To use GetX navigation, your main app widget should be `GetMaterialApp` instead of `MaterialApp`).

### 3. Basic Dependency Management (Service Locator)

Imagine you have a class that manages user preferences:

```dart
class UserPreferencesService {
  bool _isDarkMode = false;

  bool get isDarkMode => _isDarkMode;

  void toggleDarkMode() {
    _isDarkMode = !_isDarkMode;
    print("Dark mode is now: $_isDarkMode");
    // In a real app, you'd save this preference
  }
}
```

You can "register" an instance of this service with GetX using `Get.put()`:

```dart
// Usually done at app startup or in a specific setup area
void initializeServices() {
  Get.put(UserPreferencesService());
  print("UserPreferencesService registered!");
}
```

Later, from anywhere in your app, you can retrieve this instance using `Get.find()`:

```dart
// ... in some widget or controller
void onThemeToggleButtonPressed() {
  final prefsService = Get.find<UserPreferencesService>();
  prefsService.toggleDarkMode();
  // You might then update your UI based on prefsService.isDarkMode
}
```

**What happens?**
*   `Get.put(UserPreferencesService());` creates an instance of `UserPreferencesService` and stores it in a global container managed by GetX.
*   `Get.find<UserPreferencesService>();` looks up and returns that stored instance.

This allows you to easily access shared services without passing instances around manually or using complex InheritedWidgets. We'll dive much deeper into dependency management in [Chapter 6: Dependency Access (Binder, Bind.of, Get.find/put)](06_dependency_access__binder__bind_of__get_find_put__.md).

## Under the Hood: How Does `Get` Work?

You might be wondering how `Get` can perform these actions, especially UI-related ones like showing snackbars, without `BuildContext`.

At its core, `Get` is a cleverly designed global static instance. When you use GetX (typically by wrapping your app with `GetMaterialApp`), GetX sets up the necessary infrastructure.

Here's a simplified conceptual flow for showing a snackbar:

```mermaid
sequenceDiagram
    participant YourCode as Your App Code
    participant Get as Get Object
    participant GetXCore as GetX Internal Logic
    participant FlutterFramework as Flutter Framework

    YourCode->>Get: Calls Get.snackbar("Title", "Message")
    Get->>GetXCore: Forwards request to internal snackbar logic
    GetXCore->>FlutterFramework: Uses Flutter's Overlay (or similar) to display UI
    FlutterFramework-->>YourCode: Snackbar appears on screen
```

**1. The `Get` Object Itself:**
The `Get` object you use is actually a global instance of a class. This is defined very simply in the GetX core:

```dart
// From: get_core/src/get_main.dart

// (_GetImpl is a class that implements GetInterface,
// where all the actual methods are defined or extended)
class _GetImpl extends GetInterface {}

// This creates a single, globally accessible instance named 'Get'
// ignore: non_constant_identifier_names
final Get = _GetImpl();
```
This `Get` variable is what you're accessing when you type `Get.something()`.

**2. `GetInterface` and Extensions:**
The `_GetImpl` class extends `GetInterface`.
```dart
// From: get_core/src/get_interface.dart
abstract class GetInterface {
  // Basic configurations like smartManagement and logging
  SmartManagement smartManagement = SmartManagement.full;
  bool isLogEnable = kDebugMode;
  LogWriterCallback log = defaultLogWriterCallback;
  // ... other core properties might be declared here
}
```
Many of GetX's functionalities (like `Get.to`, `Get.snackbar`, `Get.put`, `Get.find`) are added to this `GetInterface` through Dart's extension methods or are mixed into `_GetImpl`. These extensions contain the actual logic. For example, the navigation methods know how to find the `Navigator` provided by `GetMaterialApp`, and the snackbar methods know how to tap into Flutter's `Overlay` to display UI elements globally.

**3. For Dependency Management (`Get.put` / `Get.find`):**
When you use `Get.put(MyService())`, GetX stores this `MyService` instance in an internal data structure (like a map), often an_instance manager. When you later call `Get.find<MyService>()`, GetX looks up `MyService` in this internal storage by its type (and optionally by a tag) and returns the stored instance. We'll cover the `InstanceManager` in more detail in [Chapter 6: Dependency Access (Binder, Bind.of, Get.find/put)](06_dependency_access__binder__bind_of__get_find_put__.md).

The key takeaway is that `Get` acts as a **facade**  a simplified, unified interface to a more complex underlying system. It hides the complexities of interacting directly with Flutter's deeper systems or managing global instances, providing you with clean, easy-to-use static methods.

## Conclusion

You've now met `Get`, your go-to helper for many common tasks in GetX. It's a powerful yet simple facade that provides global access to navigation, UI utilities, dependency management, and more, often without the need for `BuildContext`. This keeps your code clean and makes development faster.

As you continue your GetX journey, you'll see `Get` being used in various contexts. Understanding its role as a global access point is key to mastering GetX.

In the next chapter, we'll explore a core GetX concept for making your application's data dynamic and responsive: [Rx<T> (Reactive Variables)](02_rx_t___reactive_variables__.md).
---
# Chapter 2: Rx<T> (Reactive Variables)

Welcome to Chapter 2! In [Chapter 1: Get (Global Access Facade)](01_get__global_access_facade__.md), we learned how the `Get` object acts as a handy "universal remote" for common app tasks. Now, we're going to dive into one of the most exciting features of GetX: making your app's data "reactive."

## What's the Big Deal with "Reactive"?

Imagine you're building an app that shows a user's score. When the score changes, you want the text on the screen displaying that score to update *automatically*, without you having to write a lot of complicated code to manually refresh the screen. This "automatic updating" is what reactive programming is all about.

`Rx<T>` variables are GetX's way of achieving this magic.

## Introducing `Rx<T>`: Your Magic Whiteboard

`Rx<T>` types (like `RxInt`, `RxString`, or pretty much anything you see ending with `.obs`) represent variables that can be "observed."

Think of an `Rx<T>` variable as a special number (or text, or any data) written on a **magic whiteboard**:
*   You write your initial data on this whiteboard (e.g., the number `0`).
*   Whenever someone erases the number and writes a new one (e.g., changes it to `1`), a bell automatically rings!
*   Anyone (or any part of your app's UI) specifically "watching" that number on the whiteboard instantly sees the change and reacts to it.

These `Rx<T>` variables are the heart of GetX's reactive programming. They allow your User Interface (UI), especially when used with widgets like `Obx` (which we'll cover in the [next chapter](03_obx___obxwidget_.md)), to automatically update whenever the underlying data changes.

The `T` in `Rx<T>` is a placeholder for the type of data the variable will hold, like `int`, `String`, `bool`, or even your own custom classes.

## How to Create and Use Reactive Variables

Let's see how to create and use these "magic" variables. The most common way is by using the `.obs` extension on a standard Dart value.

### 1. Creating a Reactive Variable

To make a regular variable reactive, you simply add `.obs` to its initial value.

**For a number (integer):**

```dart
import 'package:get/get.dart'; // Don't forget to import GetX

final count = 0.obs; // This is now an RxInt holding 0
// You could also write: final count = RxInt(0);
```
Here, `count` isn't just a regular `int`. It's now a special `RxInt` object that holds the integer value `0` and can notify others when it changes.

**For text (string):**

```dart
final userName = "Guest".obs; // This is an RxString holding "Guest"
// You could also write: final userName = RxString("Guest");
```
Similarly, `userName` is an `RxString`.

**For a boolean (true/false):**

```dart
final isLoggedIn = false.obs; // This is an RxBool holding false
// You could also write: final isLoggedIn = RxBool(false);
```

### 2. Getting the Value

If `count` is an `RxInt`, how do you get the actual integer value out of it? You use the `.value` property.

```dart
final count = 0.obs;
print(count.value); // Output: 0

final userName = "Guest".obs;
print(userName.value); // Output: Guest
```
Think of `.value` as looking at the magic whiteboard to read what's currently written on it.

### 3. Changing the Value (and Ringing the Bell!)

To change the value of a reactive variable, you also assign a new value to its `.value` property. This is the action that "rings the bell."

```dart
final count = 0.obs;
print("Initial count: ${count.value}"); // Output: Initial count: 0

count.value = 5; // You changed the number on the whiteboard!
print("New count: ${count.value}"); // Output: New count: 5
```
When you do `count.value = 5;`, the `count` variable not only updates its internal number but also sends out a notification that its value has changed.

You can also change the value by calling the `Rx` variable like a function:
```dart
final anotherCount = 10.obs;
anotherCount(15); // Same as anotherCount.value = 15;
print(anotherCount.value); // Output: 15
```
This is just a shorthand. Both ways achieve the same result.

### A Simple Example: The Counter Logic

Let's imagine the logic for a simple counter. We won't build the UI yet, just the data part.

```dart
import 'package:get/get.dart';

// 1. Create a reactive variable for our count
final magicCounter = 0.obs;

void incrementCounter() {
  // 2. Change its value
  magicCounter.value++; // This rings the bell!
  print("Counter is now: ${magicCounter.value}");
}

void main() {
  print("Counter starts at: ${magicCounter.value}");
  incrementCounter(); // Call the function to change the value
  incrementCounter();
}
```
**What happens?**
1.  `magicCounter` is created as an `RxInt` initialized to `0`.
2.  When `incrementCounter()` is called, `magicCounter.value++` increases the stored integer and notifies any listeners.
3.  The `print` statement shows the updated value.

Output:
```
Counter starts at: 0
Counter is now: 1
Counter is now: 2
```
Right now, only our `print` statements are "listening" in a very basic way. In the [next chapter](03_obx___obxwidget_.md), we'll see how to make Flutter UI widgets listen and update automatically!

## Under the Hood: How Does `.obs` Work?

You might wonder what `.obs` actually does. It's a clever use of Dart's "extension methods."

When you write `0.obs`, GetX has an extension on the `int` type that looks something like this (simplified):

```dart
// From: get_rx/src/rx_types/rx_core/rx_impl.dart (simplified concept)
extension IntExtension on int {
  RxInt get obs => RxInt(this); // 'this' refers to the integer itself
}
```
This code basically says: "If you see `.obs` after an integer, create a new `RxInt` object and give it that integer's value." Similar extensions exist for `String`, `bool`, `double`, and even a generic `Rx<T>` for any object via `T.obs`.

The `RxInt`, `RxString`, etc., classes (which generally inherit from `_RxImpl<T>`) are special classes that manage an internal value and have a built-in mechanism to notify listeners.

Here's a simplified step-by-step of what happens when you change an `Rx` variable's value:

```mermaid
sequenceDiagram
    participant YourCode as Your App Code
    participant RxVariable as count (RxInt)
    participant RxImpl as Internal Logic (_RxImpl)
    participant Listeners as Potential UI (e.g., Obx)

    YourCode->>RxVariable: count.value = 1
    Note over RxVariable: This calls the 'set value' logic
    RxVariable->>RxImpl: Pass new value (1)
    RxImpl->>RxImpl: Store new value (1) internally
    RxImpl->>RxImpl: Check: Has value actually changed?
    alt Value Changed
        RxImpl-->>Listeners: Notifies all listeners (rings the bell!)
        Listeners-->>RxVariable: (Later) Asks RxVariable for its new .value
    end
```

1.  **You assign to `.value`**: `count.value = 1;`
2.  **Setter is called**: The `RxInt` class (or its parent `_RxImpl` found in `get_rx/src/rx_types/rx_core/rx_impl.dart`) has a special `set value(newValue)` method.
3.  **Value Check**: This setter first checks if the `newValue` is actually different from the current stored value. If it's the same, it usually does nothing to avoid unnecessary notifications.
4.  **Store New Value**: If the value is different, it updates its internal storage.
5.  **Notify Listeners**: This is the magic part! The class then triggers a notification. Internally, it often uses a `StreamController` (from `dart:async`). When you change `.value`, it essentially adds the new value to its stream using something like `subject.add(newValue)` after updating its internal `_value`.
    ```dart
    // Highly simplified concept from RxObjectMixin in get_rx/src/rx_types/rx_core/rx_impl.dart
    // and GetListenable in get_state_manager/src/rx_flutter/rx_notifier.dart

    // In GetListenable:
    // StreamController<T>? _controller;
    // T _value;
    // void refresh() { _controller?.add(_value); }

    // In RxObjectMixin (which uses GetListenable):
    set value(T val) {
      if (_value == val && !firstRebuild) return; // _value is from GetListenable
      firstRebuild = false;
      super.value = val; // This typically calls GetListenable's setter, which then calls refresh()
                         // `super.value = val;` roughly does:_value = val; refresh();
    }
    ```
    The `super.value = val;` line in `RxObjectMixin`'s setter calls the setter in its parent class (`GetListenable`), which updates the internal `_value` and then calls `refresh()`. The `refresh()` method then typically adds the new value to an internal stream (`_controller?.add(_value);`), effectively "ringing the bell."

Any widget designed to listen to these streams (like `Obx`) will then pick up this notification.

## Different Kinds of Rx Variables

GetX provides several pre-built `Rx` types for convenience:

*   **Primitives:**
    *   `RxInt(initialValue)` or `initialValue.obs` for integers.
    *   `RxDouble(initialValue)` or `initialValue.obs` for doubles.
    *   `RxString(initialValue)` or `initialValue.obs` for strings.
    *   `RxBool(initialValue)` or `initialValue.obs` for booleans.
*   **Collections (these are a bit more advanced as they react to internal changes too):**
    *   `RxList<T>([])` or `[].obs` for lists.
    *   `RxMap<K, V>({})` or `{}.obs` for maps.
    *   `RxSet<T>({})` or `{}.obs` for sets.
*   **Generic `Rx<T>`:**
    *   For any other type, including your custom classes:
        ```dart
        class User {
          String name;
          User(this.name);
        }

        final user = User("Alice").obs; // user is now an Rx<User>
        // or: final user = Rx<User>(User("Alice"));

        print(user.value.name); // Output: Alice
        user.value.name = "Bob";
        user.refresh(); // For complex objects, you might need to call refresh()
                        // or use user.update((val) { val.name = "Bob"; });
                        // to ensure listeners are notified of internal changes.
        print(user.value.name); // Output: Bob
        ```
    For changes *inside* a custom object held by `Rx<T>`, like changing `user.value.name`, GetX might not automatically know the object's internal state changed. In such cases, you can call `user.refresh()` to manually trigger the "bell," or use the `update()` method: `user.update((currentUser) { currentUser.name = "Bob"; });` which handles the refresh for you.

## Conclusion

You've now learned about `Rx<T>` variables  the "magic whiteboards" of GetX! They are special variables, easily created with `.obs`, that automatically notify anyone interested when their `.value` changes. This is the foundation of reactive programming in GetX and is crucial for building UIs that update themselves effortlessly.

These reactive variables are often managed within [GetxController](05_getxcontroller_.md) classes (which we'll cover later), making state management clean and powerful.

In the [next chapter, Chapter 3: Obx / ObxWidget](03_obx___obxwidget_.md), we'll see how to use `Obx` widgets to make your UI actually listen to these `Rx<T>` variables and update automatically when that magic bell rings!
---
# Chapter 3: Obx / ObxWidget

In [Chapter 2: Rx<T> (Reactive Variables)](02_rx_t___reactive_variables__.md), we discovered `Rx<T>` variables, our "magic whiteboards" that can signal when their data changes. That's fantastic for managing data, but how do we make our app's screen (the User Interface or UI) automatically show these changes?

Imagine you have a score in your game, stored in an `RxInt`. When the score increases, you want the score display on the screen to update instantly, without you having to write complex code to manually refresh it. This is where `Obx` comes in!

## Meet `Obx`: The Smart Picture Frame for Your UI

`Obx` (and its underlying base, `ObxWidget`) is a special Flutter widget provided by GetX. Its job is simple but powerful: it "watches" any reactive variables (`Rx<T>`) you use inside it and automatically rebuilds itself to show the new data whenever those variables change.

Remember our "magic whiteboard" (`Rx<T>`) from the last chapter?
Think of `Obx` as a **smart digital picture frame** that's wirelessly connected to that whiteboard.
*   You tell the `Obx` frame which part of the whiteboard to display (e.g., the score).
*   Whenever someone updates the score on the whiteboard (`Rx<T>` variable changes), the `Obx` frame *instantly* gets the new score and displays it.

This means your UI stays perfectly in sync with your app's state, efficiently and with very little code.

## How to Use `Obx`

Using `Obx` is wonderfully straightforward. You wrap the part of your UI that depends on a reactive variable with an `Obx` widget.

Let's build a very simple counter app to see it in action.

### 1. First, We Need a Reactive Variable

As we learned in [Chapter 2: Rx<T> (Reactive Variables)](02_rx_t___reactive_variables__.md), we create a reactive variable using `.obs`. Let's make a counter:

```dart
import 'package:get/get.dart'; // For .obs and Obx

final counter = 0.obs; // Our reactive integer, starting at 0
```
This `counter` is our "magic whiteboard" that will hold the current count.

### 2. Use `Obx` to Display the Reactive Variable

Now, let's use the `Obx` widget to display the value of `counter`. `Obx` takes a builder function. This function should return the widget(s) that depend on your reactive data.

Crucially, you **must** access the `.value` of your `Rx` variable *inside* this builder function for `Obx` to know which variable to watch.

```dart
// Inside your widget's build method:
Obx(() {
  // This Text widget will rebuild whenever 'counter.value' changes
  return Text("Button presses: ${counter.value}");
})
```
Here, `Obx` is our "smart picture frame." The builder function `() { return Text(...); }` tells the frame *what* to display. Because we used `counter.value` inside it, `Obx` knows to watch the `counter` variable.

### 3. Putting It All Together: A Simple Reactive Page

Let's see a complete, minimal example. We'll have a text display for the counter and a button to increment it.

```dart
import 'package:flutter/material.dart';
import 'package:get/get.dart';

// 1. Our reactive variable (could be in a GetxController later)
final counter = 0.obs;

class CounterPage extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(title: Text("Obx Counter Demo")),
      body: Center(
        // 2. Use Obx to wrap the widget that displays reactive data
        child: Obx(() {
          return Text(
            "Count: ${counter.value}", // Access .value here!
            style: TextStyle(fontSize: 28),
          );
        }),
      ),
      floatingActionButton: FloatingActionButton(
        onPressed: () {
          // 3. Change the reactive variable's value
          counter.value++;
        },
        child: Icon(Icons.add),
      ),
    );
  }
}
```

**What happens?**

1.  The page loads, `counter.value` is `0`. The `Obx` widget runs its builder function for the first time, and `Text("Count: 0")` is displayed.
2.  You tap the `+` button.
3.  The `onPressed` callback executes: `counter.value++`.
    *   The value of `counter` changes (e.g., from `0` to `1`).
    *   Because `counter` is an `RxInt` (a "magic whiteboard"), it "rings a bell," notifying its listeners that it has changed.
4.  The `Obx` widget, being a "smart picture frame" listening to `counter`, hears this bell!
5.  `Obx` automatically re-runs its builder function: `() { return Text("Count: ${counter.value}"); }`.
6.  This time, `counter.value` is `1`, so a new `Text("Count: 1")` widget is created and displayed.

The UI updates automatically, just like magic! You didn't have to call `setState()` or manually tell the UI to refresh.

### Important: Only Use Rx Variables *Inside* `Obx`'s Builder

`Obx` is smart, but it's not a mind reader. It only knows to rebuild if a reactive variable *that it has been told to observe* changes. It figures this out by tracking which reactive variables have their `.value` accessed *directly within its builder function*.

```dart
// GOOD: 'name.value' is inside Obx's builder
final name = "User".obs;
Obx(() => Text(name.value))

// BAD: If 'name.value' is not accessed inside, Obx won't react.
// (This would likely throw an ObxError if no other Rx var is accessed)
final name = "User".obs;
String currentName = name.value; // Accessed outside Obx's scope of observation
Obx(() => Text(currentName)) // Obx doesn't know about 'name' here
```

If you use an `Obx` widget and don't access any `.value` of an `Rx` variable inside its builder, GetX will usually show you an `ObxError` in the console, reminding you that `Obx` isn't observing anything.

```
[Get] the improper use of a GetX has been detected.
You should only use GetX or Obx for the specific widget that will be updated.
If you are seeing this error, you probably did not insert any observable variables into GetX/Obx...
```
This error message comes from the `ObxError` class defined in `get_state_manager/src/simple/list_notifier.dart`.

## Under the Hood: How Does `Obx` Work Its Magic?

It might seem like magic, but it's clever programming. Here's a simplified idea:

1.  **Subscription:** When an `Obx` widget is built for the first time, it prepares to listen. As its builder function executes, any `RxVariable.value` you access signals back to the `Obx` (via an internal `Notifier` system) saying, "Hey, Obx, I'm being read here! Please listen to me for changes." The `Obx` widget then subscribes to that `RxVariable`.
2.  **Value Change:** You change an `RxVariable` (e.g., `counter.value++`).
3.  **Notification:** The `RxVariable` "rings its bell" and notifies all its subscribers (including our `Obx` widget) that its value has changed.
4.  **Rebuild:** The `Obx` widget, upon receiving this notification, knows it needs to update. It schedules a rebuild, which simply means it calls its builder function again. Because the builder function now gets the new value from the `RxVariable`, the UI updates.

Here's a visual representation:

```mermaid
sequenceDiagram
    participant UserAction as User Taps Button
    participant RxVariable as counter (RxInt)
    participant ObxWidget as Obx Widget
    participant FlutterEngine as Flutter Engine

    Note over ObxWidget, RxVariable: Initial build: Obx reads counter.value, subscribes to counter.
    UserAction->>RxVariable: counter.value++
    RxVariable->>RxVariable: Internal value updates
    RxVariable-->>ObxWidget: Notifies Obx about the change
    ObxWidget->>ObxWidget: Schedules its builder to re-run
    ObxWidget->>RxVariable: Reads new counter.value (e.g., 1)
    ObxWidget-->>FlutterEngine: Provides new UI (e.g., Text("Count: 1"))
    FlutterEngine-->>UserAction: UI Updates on Screen
```

Let's peek at some (simplified) relevant code snippets:

`Obx` itself is quite simple. It extends `ObxWidget` (which extends `ObxStatelessWidget`).
```dart
// From: get_state_manager/src/rx_flutter/rx_obx_widget.dart
class Obx extends ObxWidget {
  final WidgetCallback builder; // Your () => Widget function
  const Obx(this.builder, {super.key});

  @override
  Widget build(BuildContext context) {
    return builder(); // It just calls your function!
  }
}
```
The real magic happens in `ObxStatelessWidget` and its `ObxElement`, which uses a mixin called `StatelessObserverComponent` (from `get_state_manager/src/simple/simple_builder.dart`).

```dart
// From: get_state_manager/src/simple/simple_builder.dart (simplified)
mixin StatelessObserverComponent on StatelessElement {
  List<Disposer>? disposers = <Disposer>[]; // To store cleanup functions

  void getUpdate() {
    // If I'm told to update, I tell Flutter to rebuild me!
    scheduleMicrotask(markNeedsBuild);
  }

  @override
  Widget build() {
    // Before calling the user's Obx builder (super.build),
    // set up the Notifier to catch Rx reads.
    return Notifier.instance.append(
        NotifyData(disposers: disposers!, updater: getUpdate),
        super.build // This eventually calls your Obx(() => Text(...))
    );
  }

  @override
  void unmount() { // When Obx is removed from the screen
    super.unmount();
    for (final disposer in disposers!) {
      disposer(); // Clean up subscriptions
    }
    disposers!.clear();
    disposers = null;
  }
}
```
When `yourRxVariable.value` is accessed *inside* the `Obx` builder (during `super.build` call above):
1.  The `Rx` variable's getter calls `reportRead()`. This method is mixed into `Rx` types from `ListNotifierSingleMixin` (in `get_state_manager/src/simple/list_notifier.dart`).
    ```dart
    // From: get_rx/src/rx_types/rx_core/rx_impl.dart (RxObjectMixin's value getter)
    // Simplified concept of what Rx's .value getter does
    T get value {
      reportRead(); // "I'm being read!"
      return _internalValue;
    }
    ```
2.  `reportRead()` calls `Notifier.instance.read(this)` (`this` refers to the `Rx` variable itself).
    ```dart
    // From: get_state_manager/src/simple/list_notifier.dart
    // (Inside ListNotifierSingleMixin)
    @protected
    void reportRead() {
      Notifier.instance.read(this);
    }
    ```
3.  `Notifier.instance.read()` checks the `_notifyData` that `StatelessObserverComponent.build()` set up. It finds the `getUpdate` method of our `Obx` widget and subscribes it to the `Rx` variable.
    ```dart
    // From: get_state_manager/src/simple/list_notifier.dart (Notifier class)
    void read(ListNotifierSingleMixin rxVariable) {
      final getStateUpdateFn = _notifyData?.updater; // This is Obx's getUpdate()
       // If Obx's getUpdate is available and not already listening to this rxVariable:
      if (getStateUpdateFn != null && !rxVariable.containsListener(getStateUpdateFn)) {
        // Tell rxVariable: "When you change, call Obx's getUpdate()"
        Disposer disposer = rxVariable.addListener(getStateUpdateFn);
        // And remember how to unsubscribe later
        _notifyData?.disposers.add(disposer);
      }
    }
    ```
So, when `RxVariable.value` changes later, it calls `refresh()` (from `ListNotifierSingleMixin`), which notifies its listeners. One of these listeners is the `Obx` widget's `getUpdate` method, causing the `Obx` widget to rebuild!

## What is `ObxWidget` then?

You'll mostly use `Obx`. `ObxWidget` is simply the base class that `Obx` (and `ObxValue`, another similar widget) extends. It provides the common reactive machinery. Advanced users could extend `ObxWidget` to create their own custom reactive widgets, but for most day-to-day tasks, `Obx` is all you need.

## Conclusion

You've now unlocked a cornerstone of GetX's reactivity: the `Obx` widget! It's your "smart picture frame" that automatically updates your UI when the underlying `Rx<T>` reactive variables change. This makes building dynamic and responsive UIs incredibly simple and efficient.

Typically, your `Rx<T>` variables will live inside a [GetxController](05_getxcontroller_.md) (which we'll cover soon) to keep your UI logic neatly organized. `Obx` then becomes the bridge that connects your controller's state to your visual widgets.

But what if you want to react to changes in `Rx<T>` variables *without* updating the UI? For example, maybe you want to log a message or make an API call when a value changes. For that, GetX provides something called "Workers." Let's explore those in the [next chapter, Chapter 4: Workers](04_workers_.md).
---
# Chapter 4: Workers

In [Chapter 3: Obx / ObxWidget](03_obx___obxwidget_.md), we saw how `Obx` acts like a smart picture frame, automatically updating our UI when reactive variables change. That's perfect for what users see! But what if we want to perform actions *behind the scenes* when our data changes? For instance, what if we need to fetch new data from the internet when a user's ID changes, or automatically save their input after they've stopped typing for a moment? This is where GetX Workers come in!

## What Problem Do Workers Solve?

Imagine you have a reactive variable, say, `userId.obs`. When this `userId` changes, you might want to:
*   Log the change for debugging.
*   Fetch the new user's profile from a server.
*   Update some other non-UI related data.

You don't want to put this logic directly in your UI-building code because it's not about drawing pixels on the screen. It's about reacting to data changes with *side effects*.

**Workers** are your dedicated helpers for exactly this. They are functions that "listen" to your [Rx<T> (Reactive Variables)](02_rx_t___reactive_variables__.md) and execute a callback function when specific events or conditions occur on those variables. Think of them as automated sentinels, tirelessly watching your reactive data streams. When a predefined rule is met (like "the data changed!" or "the user stopped typing!"), they spring into action, independent of direct UI rendering.

## Meet the Workers: Your Automated Sentinels

GetX provides a few different types of Workers, each designed for a specific kind of listening task. Let's meet the main ones: `ever`, `once`, `debounce`, and `interval`.

All these workers are typically set up within the `onInit()` method of a [GetxController](05_getxcontroller_.md) (which we'll cover in the next chapter), or anywhere you have access to your reactive variables and need to react to their changes.

### 1. `ever`: The Ever-Watchful Sentinel

The `ever` worker executes its callback function **every time** the reactive variable it's watching changes.

Let's say we have a reactive variable for a username:
```dart
import 'package:get/get.dart';

final username = 'Guest'.obs; // Our reactive username
```
Now, let's set up an `ever` worker to print a message whenever `username` changes:
```dart
// Typically, you'd do this in onInit() of a GetxController
ever(username, (String newName) {
  print("Username changed to: $newName");
});

// Let's simulate some changes:
username.value = 'Alice';
username.value = 'Bob';
```
**What happens?**
Every time `username.value` is assigned a new value, the `ever` worker's callback `(String newName) { ... }` is triggered.
Output:
```
Username changed to: Alice
Username changed to: Bob
```

You can also add a `condition` to `ever`. The callback will only run if the condition is true when the main variable changes.
```dart
final count = 0.obs;

ever(count, (int newCount) {
  print("Count is now $newCount (and it's greater than 2!)");
}, condition: () => count.value > 2); // Only run if count > 2

count.value = 1; // No output
count.value = 3; // Output: Count is now 3 (and it's greater than 2!)
count.value = 4; // Output: Count is now 4 (and it's greater than 2!)
```

### 2. `once`: The One-Time Sentinel

The `once` worker executes its callback function **only the first time** a specific condition (related to the reactive variable) is met. After it runs once, it automatically stops listening.

Imagine you want to show a welcome message only the very first time a user logs in (i.e., `isLoggedIn.value` becomes `true`).
```dart
final isLoggedIn = false.obs;

once(isLoggedIn, (bool loggedInStatus) {
  if (loggedInStatus == true) {
    print("Welcome! You've logged in for the first time (during this session).");
  }
}, condition: () => isLoggedIn.value == true); // Condition to trigger

isLoggedIn.value = true;  // Triggers 'once'
isLoggedIn.value = false; // 'once' won't trigger again
isLoggedIn.value = true;  // 'once' won't trigger again
```
**What happens?**
The callback is executed only when `isLoggedIn.value` changes *and* the condition `isLoggedIn.value == true` is met for the *first time*.
Output:
```
Welcome! You've logged in for the first time (during this session).
```
Even if `isLoggedIn` becomes `true` again later, `once` has done its job and won't fire again.

### 3. `debounce`: The "Wait-and-See" Sentinel

The `debounce` worker is super useful for scenarios like search fields. It waits for a certain period of inactivity before executing the callback. If the variable changes again before the waiting period is over, the timer resets.

Imagine a search bar. You don't want to make an API call for every single letter the user types. Instead, you want to wait until they pause typing.
```dart
final searchQuery = ''.obs;

debounce(searchQuery, (String query) {
  print("User stopped typing. Search for: $query");
  // In a real app, you'd make an API call here: fetchResults(query);
}, time: Duration(milliseconds: 500)); // Wait for 500ms of inactivity

// Simulate typing quickly, then pausing
searchQuery.value = 'h';
searchQuery.value = 'he';
searchQuery.value = 'hel'; // Timer resets each time
// User pauses... after 500ms:
// Output: User stopped typing. Search for: hel
```
**What happens?**
*   User types 'h', then 'e', then 'l' quickly. The `debounce` timer keeps resetting.
*   After 'hel', if the user pauses for 500 milliseconds, the callback `(String query) { ... }` is executed with the latest value ('hel').
*   If they type 'lo' next, the same process repeats.

### 4. `interval`: The "Periodic Check-up" Sentinel

The `interval` worker is a bit like `debounce` but it triggers its callback with the value that the reactive variable had at the *beginning* of the interval, after a specified duration has passed, and *only if* no new changes occurred during that interval (this behavior can be subtle, often `debounce` is what people want for "after a delay"). It's more like "if nothing changes for X time, then act on the value from X time ago".

A more common use of a timed worker might be "check something every X seconds while a condition is true." `interval` is designed to trigger *after* a period of stability. If you rapidly change the value, `interval` might not fire for each change because a new event interrupts the "quiet period" it's waiting for.

Let's consider a scenario where you want to perform an action if a value remains stable for a certain period.
```dart
final status = 'idle'.obs;

interval(status, (String currentStatus) {
  print("Status has been '$currentStatus' for 1 second.");
}, time: Duration(seconds: 1));

status.value = 'processing'; // Worker starts listening
// If 'status' remains 'processing' for 1 second:
// Output: Status has been 'processing' for 1 second.

// If you change it quickly:
// status.value = 'A';
// await Future.delayed(Duration(milliseconds: 200));
// status.value = 'B'; // 'A' might not trigger the interval callback
```
**What happens?**
If `status.value` becomes 'processing' and stays 'processing' for 1 second without any other changes to `status`, the callback will fire. If `status` changes again *within* that 1-second window, the timer for the *previous* value is essentially reset/ignored, and a new interval evaluation potentially begins for the new value. `debounce` is often more intuitive for "do something after a pause."

For `interval`, the primary mechanism is: when an event arrives, it waits for `time`. If another event arrives *before* `time` is up, the first event is effectively ignored by that specific `interval`'s timer. When `time` *does* elapse without a new event, the callback is fired with the value that was present when the `time` period began.


## Disposing of Workers

Workers, like `StreamSubscription`s in Dart, need to be disposed of when they are no longer needed. This is crucial to prevent memory leaks and unwanted behavior, especially if the reactive variable they are listening to outlives the context where the worker was created.

When you create a worker, it returns a `Worker` object. This object has a `dispose()` method:
```dart
final count = 0.obs;
late Worker everWorker; // Declare the worker variable

// In onInit() or similar setup:
everWorker = ever(count, (_) => print('Count changed!'));

// ... later, when this logic is no longer needed (e.g., in onClose() of a GetxController):
void cleanup() {
  everWorker.dispose();
  print("Ever worker disposed.");
}

count.value = 1; // Output: Count changed!
cleanup();
count.value = 2; // No output, because the worker is disposed.
```

It's a common pattern to initialize workers in the `onInit()` method of a [GetxController](05_getxcontroller_.md) and dispose of them in its `onClose()` method. GetX also provides a way to automatically manage this if workers are declared inside a controller, but manual disposal is good practice to understand.

## Under the Hood: How Do Workers... Work?

Workers function by subscribing to the underlying stream of an [Rx<T> (Reactive Variables)](02_rx_t___reactive_variables__.md). Remember from Chapter 2 that `Rx` variables can notify listeners when they change? Workers are specialized listeners.

1.  **Subscription:** When you create a worker (e.g., `ever(myRxVar, callback)`), the worker function internally calls `myRxVar.listen(...)`. This is similar to listening to a Dart `Stream`.
2.  **Event Emission:** When `myRxVar.value` changes, `myRxVar` emits this new value to its listeners.
3.  **Worker Logic:** The worker receives this new value.
    *   For `ever`, it typically checks an optional condition and then calls your callback.
    *   For `once`, it does the same but also cancels its own subscription after the first valid trigger.
    *   For `debounce`, it uses a timer (like the `Debouncer` utility class in GetX). Each new event resets the timer. If the timer completes, the callback is called with the *last* event received.
    *   For `interval`, it also uses a timer. When an event arrives, it starts a timer. If the timer completes *without* a new event arriving, it calls the callback with the event that started that timer.
4.  **Callback Execution:** If the worker's specific logic decides it's time, your provided callback function is executed with the relevant value.

Heres a simplified sequence diagram showing a `debounce` worker in action:

```mermaid
sequenceDiagram
    participant UserAction as User Typing
    participant SearchRx as searchQuery.obs
    participant DebounceWorker as Debounce Logic
    participant YourCallback as (query) => API.search(query)

    UserAction->>SearchRx: searchQuery.value = "flut"
    SearchRx-->>DebounceWorker: Notifies with "flut"
    DebounceWorker->>DebounceWorker: Starts/Resets 500ms timer
    UserAction->>SearchRx: searchQuery.value = "flutter"
    SearchRx-->>DebounceWorker: Notifies with "flutter"
    DebounceWorker->>DebounceWorker: Resets 500ms timer (for "flutter")
    Note over DebounceWorker: User pauses typing...
    DebounceWorker-->>YourCallback: After 500ms, calls YourCallback("flutter")
```

The actual implementation can be found in `get_rx/src/rx_workers/rx_workers.dart`.
For example, the `ever` worker (simplified):
```dart
// From: get_rx/src/rx_workers/rx_workers.dart (conceptual)
Worker ever<T>(
  GetListenable<T> listener, // This is your Rx variable
  WorkerCallback<T> callback, {
  dynamic condition = true, // Optional condition
  /* ... other params ... */
}) {
  // 1. Listen to the Rx variable's stream
  StreamSubscription sub = listener.listen(
    (event) { // 'event' is the new value from the Rx variable
      // 2. Check the condition
      if (_conditional(condition)) { // _conditional is a helper
        // 3. Execute your callback
        callback(event);
      }
    },
    /* ... onError, onDone ... */
  );
  // 4. Return a Worker object that can be used to cancel the subscription
  return Worker(sub.cancel, '[ever]');
}
```
The `_conditional` function (also in `rx_workers.dart`) is a utility that evaluates the `condition` argument, which can be a `bool` or a `bool Function()`.

The `debounce` worker uses a `Debouncer` utility class (found in `get_rx/src/rx_workers/utils/debouncer.dart`):
```dart
// From: get_rx/src/rx_workers/rx_workers.dart (conceptual)
Worker debounce<T>(
  GetListenable<T> listener,
  WorkerCallback<T> callback, {
  Duration? time, /* ... */
}) {
  // 1. Create a Debouncer instance
  final newDebouncer = Debouncer(delay: time ?? Duration(milliseconds: 800));
  StreamSubscription sub = listener.listen(
    (event) {
      // 2. When Rx variable changes, call the debouncer
      newDebouncer(() {
        // 3. Debouncer will execute this only after the 'delay'
        callback(event);
      });
    }, /* ... */
  );
  return Worker(sub.cancel, '[debounce]');
}
```
The `Debouncer` class itself manages a `Timer` to achieve the "wait for inactivity" behavior.

## Conclusion

Workers (`ever`, `once`,  `debounce`, `interval`) are powerful tools in GetX for reacting to changes in your [Rx<T> (Reactive Variables)](02_rx_t___reactive_variables__.md) by performing side effects like API calls, logging, or triggering other logic that isn't directly tied to UI updates. They help you keep your code clean by separating these concerns. Remember to always `dispose()` your workers when they're no longer needed to keep your app running smoothly.

Now that we've seen how to create reactive data (`Rx<T>`), how to make our UI react to it (`Obx`), and how to perform side effects based on it (Workers), it's time to look at how to organize all this reactive goodness. In the [next chapter, Chapter 5: GetxController](05_getxcontroller_.md), we'll explore `GetxController`, the recommended way to encapsulate your business logic and reactive state.
---
# Chapter 5: GetxController

In [Chapter 4: Workers](04_workers_.md), we learned how to perform actions behind the scenes when_our_reactive data changes. That's great for side effects! But as your app grows, you'll find yourself asking:
*   Where should I keep my app's data (like that `counter.obs` or `searchQuery.obs`)?
*   Where should the functions that change this data (like `incrementCounter()` or `performSearch()`) live?
*   How can I neatly organize all this for a specific feature or screen?

Simply putting reactive variables and functions globally or directly in UI widgets can get messy quickly. We need a dedicated "manager" for different parts of our application. That's where `GetxController` shines!

## What is a GetxController? The Brain of Your Feature!

A `GetxController` is like the **manager** or **"brain"** for a specific part of your app's screen or a particular feature. Think of it as a dedicated organizer. Its main jobs are:

1.  **Holding Data (State):** It stores the variables (often [Rx<T> (Reactive Variables)](02_rx_t___reactive_variables__.md)) that your feature needs. For example, in a counter feature, it would hold the current count.
2.  **Holding Business Logic (Functions):** It contains the functions that operate on this data or perform actions related to the feature. For the counter, this would be the `increment()` function.
3.  **Managing Lifecycle:** It has special methods that get called at different points in its life (like when it's created or destroyed), allowing you to set things up or clean up resources.
4.  **Notifying UI (with `update()`):** When its data changes (especially non-reactive data, or if you need more control), the controller can tell the UI to update by calling its `update()` method. This is primarily used with a widget called `GetBuilder`, which we'll explore in [Chapter 7: GetBuilder](07_getbuilder_.md).

Imagine a scene in a play. The `GetxController` is like the **director** of that scene. It knows the script (logic), manages the actors' states (data), and tells them when and how to change their appearance or behavior.

## How to Use a GetxController

Let's go back to our simple counter example and see how we can organize it using a `GetxController`.

### 1. Creating Your Controller

First, you create a new Dart class that `extends GetxController`.

```dart
// counter_controller.dart
import 'package:get/get.dart';

class CounterController extends GetxController {
  // 1. Hold your reactive data (state)
  final count = 0.obs; // Our familiar RxInt

  // 2. Define your business logic (functions)
  void increment() {
    count.value++;
    // If we were using GetBuilder and non-Rx state, we might call update() here.
  }
}
```
**Explanation:**
*   We created `CounterController` that inherits from `GetxController`.
*   Inside it, we moved our reactive `count` variable.
*   We also moved the `increment` logic into a method within the controller. Now, all things related to the counter's state and logic are neatly bundled together!

### 2. Making the Controller Available (Quick Peek at Dependency Injection)

Before your UI can use the controller, GetX needs to know about it. You "register" your controller, usually when the feature or screen is first needed. The most common way is using `Get.put()`:

```dart
// Somewhere before you need the controller, e.g., when navigating to the page
Get.put(CounterController());
```
**Explanation:**
*   `Get.put(CounterController());` creates an instance of `CounterController` and makes it available for other parts of your app to find.
*   We'll dive deep into `Get.put()` and other ways to manage controllers in [Chapter 6: Dependency Access (Binder, Bind.of, Get.find/put)](06_dependency_access__binder__bind_of__get_find_put__.md). For now, just know this step is necessary.

### 3. Accessing and Using the Controller in Your UI

Once the controller is "put", your UI widgets can find and use it. You use `Get.find()` for this:

```dart
// In your widget file (e.g., counter_page.dart)
import 'package:flutter/material.dart';
import 'package:get/get.dart';
import 'counter_controller.dart'; // Import your controller fine

class CounterPage extends StatelessWidget {
  // Find the instance of CounterController that GetX is managing
  final CounterController controller = Get.find<CounterController>();

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(title: Text("GetxController Counter")),
      body: Center(
        child: Obx(() { // Obx watches reactive variables
          return Text(
            "Count: ${controller.count.value}", // Use controller's data
            style: TextStyle(fontSize: 28),
          );
        }),
      ),
      floatingActionButton: FloatingActionButton(
        onPressed: () {
          controller.increment(); // Call controller's method
        },
        child: Icon(Icons.add),
      ),
    );
  }
}
```
**Explanation:**
*   `final CounterController controller = Get.find<CounterController>();` asks GetX to give us the instance of `CounterController` it's managing.
*   Inside the `Obx` widget (from [Chapter 3: Obx / ObxWidget](03_obx___obxwidget_.md)), we access `controller.count.value` to display the reactive count.
*   In `onPressed` for the button, we call `controller.increment()` to execute the logic defined in our controller.

Now, run this app. It works just like our previous counter, but the state and logic are much better organized within `CounterController`!

### Controller Lifecycle: `onInit()`, `onReady()`, `onClose()`

`GetxController`s have a lifecycle, meaning special methods are called automatically at certain points:

*   **`onInit()`:** Called right after the controller is allocated in memory (after its constructor) but *before* the widget that uses it is built for the first time. This is the perfect place to:
    *   Initialize data.
    *   Set up [Workers](04_workers_.md) to listen to reactive variable changes.
    *   Make initial API calls.

    ```dart
    class MyController extends GetxController {
      var data = ''.obs;

      @override
      void onInit() {
        super.onInit(); // Always call super.onInit()
        print("MyController onInit!");
        // Example: Fetch initial data or set up a worker
        ever(data, (_) => print("Data changed in MyController: ${data.value}"));
        data.value = "Initial Data";
      }
    }
    ```
    Output (when `MyController` is `put`):
    ```
    MyController onInit!
    Data changed in MyController: Initial Data
    ```

*   **`onReady()`:** Called a moment *after* the widget associated with this controller is rendered on screen for the first time. Useful if you need to do something *after* the UI is visible (e.g., show an intro animation or dialog).

    ```dart
    class MyController extends GetxController {
      @override
      void onReady() {
        super.onReady(); // Always call super.onReady()
        print("MyController onReady! UI is now visible.");
        // Get.snackbar("Hint", "Controller is ready and UI is built!");
      }
    }
    ```

*   **`onClose()`:** Called just before the controller is removed from memory. This happens when it's no longer needed (e.g., the screen is closed, or `Get.delete<MyController>()` is called). This is crucial for:
    *   Cleaning up resources.
    *   Disposing of [Workers](04_workers_.md).
    *   Canceling stream subscriptions or closing database connections to prevent memory leaks.

    ```dart
    class MyController extends GetxController {
      late Worker _dataWorker;
      var data = ''.obs;

      @override
      void onInit() {
        super.onInit();
        _dataWorker = ever(data, (_) => print("Data: ${data.value}"));
      }

      @override
      void onClose() {
        print("MyController onClose! Cleaning up.");
        _dataWorker.dispose(); // IMPORTANT: Dispose workers!
        super.onClose(); // Always call super.onClose()
      }
    }
    ```
    **Explanation:** If you create workers, timers, or other listeners in `onInit()`, you *must* clean them up in `onClose()` to avoid problems.

### The `update()` Method: For Manual UI Refreshes

So far, our counter UI updates automatically because `count` is an `RxInt` and we're using `Obx`. `Obx` rebuilds when `count.value` changes.

However, sometimes you might have:
*   Regular Dart variables (not `.obs`) in your controller.
*   Complex logic where you want to decide *exactly* when to tell the UI to refresh.

For these "manual" updates, `GetxController` provides the `update()` method. When you call `update()` from within your controller, it signals to any `GetBuilder` widgets listening to this controller that they should rebuild.

```dart
class ManualUpdateController extends GetxController {
  int manualCount = 0; // A regular int, not reactive

  void incrementManualCount() {
    manualCount++;
    update(); // Tell listening GetBuilders to refresh!
    print("Manual count incremented: $manualCount. Update called.");
  }
}
```
**Explanation:**
*   `manualCount` is just a normal integer.
*   When `incrementManualCount()` is called, it changes `manualCount` and then calls `update()`.
*   This `update()` call will trigger any `GetBuilder` associated with this `ManualUpdateController` to rebuild itself and display the new `manualCount`.

We'll learn all about `GetBuilder` in [Chapter 7: GetBuilder](07_getbuilder_.md). For now, understand that `update()` is the controller's way of manually triggering UI refreshes for widgets that use `GetBuilder`.

## Under the Hood: What Makes a GetxController Tick?

A `GetxController` isn't just an empty class. It gets its powers from a few key pieces in the GetX framework:

*   It `extends ListNotifier` (from `get_state_manager/src/simple/list_notifier.dart`).
*   `ListNotifier` mixes in `GetLifeCycleMixin` (from `get_state_manager/src/rx_flutter/rx_notifier.dart` indirectly through its own mixins or base classes).

Let's see what these provide:

1.  **`GetLifeCycleMixin`:** This mixin is responsible for the lifecycle methods (`onInit`, `onReady`, `onClose`). When a controller is `put` using `Get.put()`, GetX's dependency management system knows it's a `GetLifeCycleMixin` and hooks into its lifecycle, calling these methods at the appropriate times. It also handles cleaning up the controller (calling `onClose`) when it's deleted (e.g., with `Get.delete()`).

2.  **`ListNotifier` (and its `ListNotifierSingleMixin`):** This is the heart of the manual `update()` mechanism.
    *   It maintains a list of listeners (callbacks).
    *   When you call `update()` in your controller, it actually calls `refresh()` (a method from `ListNotifierSingleMixin`).
    *   `refresh()` then iterates through all its registered listeners and calls them.
    *   Widgets like `GetBuilder` (which we'll see in [Chapter 7: GetBuilder](07_getbuilder_.md)) add themselves as listeners to the controller. So, when `refresh()` is called, the `GetBuilder`'s "update me" function gets executed, causing it to rebuild.

Here's a simplified conceptual flow for the `update()` mechanism:

```mermaid
sequenceDiagram
    participant UserAction as User Taps Button
    participant YourController as MyController
    participant ListNotifierMixin as (Part of MyController)
    participant GetBuilderWidget as GetBuilder (UI Widget)

    UserAction->>YourController: Calls controller.someMethod()
    YourController->>YourController: Logic updates non-Rx state (e.g., `manualCount++`)
    YourController->>ListNotifierMixin: Calls this.update()
    Note over ListNotifierMixin: update() internally calls refresh()
    ListNotifierMixin-->>GetBuilderWidget: Notifies its listener (the GetBuilder's update function)
    GetBuilderWidget->>GetBuilderWidget: Rebuilds itself to show new state
```

The actual code in `GetxController` for `update()` is quite simple:
```dart
// From: get_state_manager/src/simple/get_controllers.dart
abstract class GetxController extends ListNotifier with GetLifeCycleMixin {
  void update([List<Object>? ids, bool condition = true]) {
    if (!condition) {
      return;
    }
    if (ids == null) {
      refresh(); // From ListNotifierSingleMixin
    } else {
      for (final id in ids) {
        refreshGroup(id); // Also from ListNotifier, for targeted updates
      }
    }
  }
}
```
And `refresh()` in `ListNotifierSingleMixin` (simplified):
```dart
// From: get_state_manager/src/simple/list_notifier.dart
mixin ListNotifierSingleMixin on Listenable {
  List<GetStateUpdate>? _updaters = <GetStateUpdate>[]; // List of listeners

  // ... other methods ...

  @protected
  void refresh() {
    // Take a copy of listeners, in case list changes during iteration
    final list = _updaters?.toList() ?? [];
    for (var element in list) {
      element(); // Call each listener (e.g., GetBuilder's update function)
    }
  }
}
```
So, `GetxController` elegantly combines lifecycle management with a notification system to manage state and communicate changes to the UI.

## Conclusion

You've now met `GetxController`, the cornerstone for organizing your application's state and logic in GetX! It acts as a dedicated manager for your features or screen sections, holding data (often reactive), business logic, and providing lifecycle hooks (`onInit`, `onClose`) for setup and cleanup. You also learned about its `update()` method, which is essential for manually refreshing UI parts when using `GetBuilder`.

By using `GetxController`, you can create cleaner, more maintainable, and better-structured Flutter applications.

We've seen how to *create* controllers and *make them available* with a quick `Get.put()`. But how exactly does GetX manage these controllers? How many ways are there to "put" and "find" them? That's what we'll explore next in [Chapter 6: Dependency Access (Binder, Bind.of, Get.find/put)](06_dependency_access__binder__bind_of__get_find_put__.md).
---
# Chapter 6: Dependency Access (Binder, Bind.of, Get.find/put)

In [Chapter 5: GetxController](05_getxcontroller_.md), we learned how to organize our app's "brains"its data and logicinto `GetxController` classes. Now, once we have these controllers (our dependencies), how do we make them available to the parts of our app (usually widgets) that need them? How does a widget get a "wire" to its controller?

GetX provides a flexible system for this, acting like a combination of a central warehouse and local delivery services for your app's dependencies. Let's explore the main ways: `Get.put()`, `Get.find()`, `Binder`, and `Bind.of(context)`.

## What Problem Are We Solving?

Imagine you have a `UserProfileController` that manages user data.
```dart
// A simple controller (more details in Chapter 5)
class UserProfileController extends GetxController {
  final userName = 'Guest'.obs;
  void login(String name) {
    userName.value = name;
  }
}
```
Several different widgets in your app might need to display the `userName` or call the `login` method:
*   A `ProfileHeaderWidget` in the app bar.
*   A `SettingsScreenWidget` deep in the navigation stack.

How do these widgets get access to the *same instance* of `UserProfileController` without manually passing it down through many widget constructors (which is called "prop drilling" and can be messy)? This is where GetX's dependency access tools come in.

## 1. The Global Warehouse: `Get.put()` and `Get.find()`

Think of `Get.put()` and `Get.find()` as your app's central, global warehouse for important items (your controllers or other services).

### `Get.put()`: Storing Your Dependency

`Get.put(SomeClass())` is like taking an instance of `SomeClass` and placing it into a secure, well-organized global storage area managed by GetX. Once "put," this instance is generally available throughout your app. You usually do this when your app starts, or when a feature that needs the controller is first initialized.

```dart
// main.dart or an initialization file
void main() {
  // Put an instance of UserProfileController into GetX's global storage
  Get.put(UserProfileController());
  runApp(MyApp());
}
```
**What happens?**
An instance of `UserProfileController` is created and registered with GetX. By default, `Get.put()` creates a **singleton**, meaning there will only be one instance of `UserProfileController` managed by this global `put`.

### `Get.find()`: Retrieving Your Dependency

`Get.find<SomeClass>()` is like going to the warehouse and asking for the instance of `SomeClass` you stored earlier. GetX will locate it and give it to you.

Any widget, anywhere in your app (after the `Get.put()` has happened), can then get access to that controller:

```dart
// profile_header_widget.dart
class ProfileHeaderWidget extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    // Find the globally available UserProfileController
    final userController = Get.find<UserProfileController>();

    return Obx(() => Text("User: ${userController.userName.value}"));
  }
}

// settings_screen_widget.dart
class SettingsScreenWidget extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    // Find the same globally available UserProfileController
    final userController = Get.find<UserProfileController>();

    return ElevatedButton(
      onPressed: () => userController.login("Alice"),
      child: Text("Login as Alice"),
    );
  }
}
```
**What happens?**
Both `ProfileHeaderWidget` and `SettingsScreenWidget` will receive the *exact same instance* of `UserProfileController` that was registered with `Get.put()`. Changes made through one widget (like logging in) will be reflected in the other (the username display updates).

**When to use `Get.put()`/`Get.find()`?**
This global approach is great for dependencies that:
*   Need to be singletons (only one instance throughout the app).
*   Need to be easily accessible from many disparate parts of your application without complex wiring.

### Under the Hood: `Get.put()` and `Get.find()`

As we touched upon in [Chapter 1: Get (Global Access Facade)](01_get__global_access_facade__.md), GetX maintains an internal "Instance Manager" (conceptually, a map where keys are often types and values are the instances).

```mermaid
sequenceDiagram
    participant YourApp as Your App Startup
    participant GetPut as Get.put(UserProfileController())
    participant InstanceManager as GetX Instance Manager
    participant WidgetA as ProfileHeaderWidget
    participant GetFind as Get.find<UserProfileController>()

    YourApp->>GetPut: Calls Get.put(new UserProfileController())
    GetPut->>InstanceManager: Stores UserProfileController instance (e.g., by Type)
    Note over InstanceManager: UserProfileController now in global storage

    WidgetA->>GetFind: Calls Get.find<UserProfileController>()
    GetFind->>InstanceManager: Looks up UserProfileController by Type
    InstanceManager-->>GetFind: Returns stored instance
    GetFind-->>WidgetA: Provides instance to WidgetA
```

1.  **`Get.put(MyController())`**: When you call this, `Get` (via its `GetInstance` powers, mostly in `get_instance/src/get_instance.dart`) takes the `MyController` instance and stores it in a central collection (like a `Map<String, InstanceInternal>`). It often uses the Type of the controller (e.g., "MyController") and an optional "tag" to create a unique key for storage.
2.  **`Get.find<MyController>()`**: This method also uses `GetInstance` to look up the key (Type or Type+tag) in that central collection. If found, it returns the stored instance. If not found, it will throw an error.

This simple yet powerful mechanism is what allows `Get.find()` to retrieve dependencies from anywhere.

## 2. Local Delivery Service: `Binder` and `Bind.of(context)`

Sometimes, a global singleton isn't what you need.
*   What if a specific section of your app requires its *own*, independent instance of a controller?
*   What if you want to provide a dependency only to a specific widget and its children, without polluting the global scope?

This is where `Binder` and `Bind.of(context)` come in, acting like a "local delivery service" for your dependencies. `Binder` is a special widget from GetX (an `InheritedWidget` under the hood) that makes an instance of a controller available to all its descendant widgets in the tree.

### `Binder`: Providing a Dependency Locally

You wrap a part of your widget tree with `Binder` and tell it how to create or find the dependency it should provide.

Let's say you have a `ProductDetailController` that should only exist for a specific `ProductDetailScreen`.

```dart
// product_detail_controller.dart
class ProductDetailController extends GetxController {
  final productId;
  ProductDetailController(this.productId);

  void loadProductDetails() {
    print("Loading details for product ID: $productId");
    // ... fetch details ...
  }
  // ... other product specific logic ...
}

// product_detail_screen.dart
class ProductDetailScreen extends StatelessWidget {
  final String productId;
  ProductDetailScreen({required this.productId});

  @override
  Widget build(BuildContext context) {
    // Binder provides ProductDetailController to its children
    return Binder<ProductDetailController>(
      // 'init' creates the controller when Binder is built
      init: () => ProductDetailController(productId),
      // 'autoRemove: true' (default) means controller is disposed when screen is removed
      child: Scaffold(
        appBar: AppBar(title: Text("Product $productId")),
        body: ProductInfoDisplay(), // A child widget
      ),
    );
  }
}
```
**What happens?**
*   When `ProductDetailScreen` is built, the `Binder` widget is created.
*   The `init: () => ProductDetailController(productId)` function is called, creating a *new* instance of `ProductDetailController` specifically for this screen.
*   This instance is now available to `ProductInfoDisplay` and any other widgets inside this `Binder`'s `child` subtree.

### `Bind.of(context)`: Accessing the Locally Provided Dependency

Descendant widgets can then access this controller using `Bind.of<ControllerType>(context)`.

```dart
// product_info_display.dart (child of ProductDetailScreen's Binder)
class ProductInfoDisplay extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    // Access the ProductDetailController provided by an ancestor Binder
    final controller = Bind.of<ProductDetailController>(context);
    // Or, more conveniently, using an extension:
    // final controller = context.get<ProductDetailController>();

    controller.loadProductDetails(); // Call method on the local controller

    return Center(
      child: Text("Displaying info for product: ${controller.productId}"),
    );
  }
}
```
**What happens?**
*   `Bind.of<ProductDetailController>(context)` (or `context.get<ProductDetailController>()`) looks *up* the widget tree from `ProductInfoDisplay`.
*   It finds the nearest `Binder<ProductDetailController>` ancestor and retrieves the controller instance held by that `Binder`.
*   If you had two different `ProductDetailScreen`s on screen at once (e.g., in a split view), each would have its *own* `ProductDetailController` instance thanks to their respective `Binder`s.

**Important:** `Bind.of(context)` retrieves the dependency. If you also want the widget to rebuild when the controller calls `update()` (as discussed in [Chapter 5: GetxController](05_getxcontroller_.md) for `GetBuilder`), you would typically use `Bind.of(context, rebuild: true)` or its shorthand `context.listen<ProductDetailController>()`. This is what `GetBuilder` uses internally, as we'll see in [Chapter 7: GetBuilder](07_getbuilder_.md).


### Under the Hood: `Binder` and `Bind.of(context)`

`Binder` is essentially a specialized `InheritedWidget`. `InheritedWidget` is Flutter's standard way of passing data down the widget tree efficiently.

```mermaid
sequenceDiagram
    participant WidgetTree as ProductDetailScreen Builds
    participant BinderWidget as Binder<ProductDetailController>
    participant Flutter as Flutter Framework
    participant ChildWidget as ProductInfoDisplay
    participant BindOf as Bind.of(context) / context.get()

    WidgetTree->>BinderWidget: Creates Binder(init: () => ProductDetailController(...))
    BinderWidget->>BinderWidget: Initializes controller via 'init'
    Note over BinderWidget: Stores controller instance internally

    ChildWidget->>BindOf: Calls Bind.of<ProductDetailController>(context)
    BindOf->>Flutter: Asks Flutter: "Find nearest Binder<ProductDetailController> ancestor"
    Flutter-->>BindOf: Returns the found Binder's element
    BindOf->>BinderWidget: Accesses controller from Binder's element
    BinderWidget-->>BindOf: Returns controller instance
    BindOf-->>ChildWidget: Provides instance to ChildWidget
```

1.  **`Binder<T>(init: ..., child: ...)`**:
    *   This widget, defined in `get_state_manager/src/simple/get_state.dart`, extends `InheritedWidget`.
    *   When it's inserted into the tree, its `init` function is called (if provided and the controller isn't already globally available via `Get.put` in some configurations). It creates and holds an instance of your controller `T`.
    *   The `BindElement<T>` (its `Element`) holds the actual controller instance.

2.  **`Bind.of<T>(context)`**:
    *   This static method uses `context.getElementForInheritedWidgetOfExactType<Binder<T>>()`.
    *   This is a standard Flutter mechanism to efficiently find the nearest ancestor `Binder<T>` in the widget tree.
    *   Once found, it retrieves the controller instance from that `Binder`'s element.
    *   If `rebuild: true` is passed (or `context.listen<T>()` is used), it also establishes a dependency, so if that `Binder` later signals an update (because the controller called `update()`), this widget will rebuild.

## Global Warehouse vs. Local Delivery: Which to Choose?

*   **`Get.put()` / `Get.find()` (Global Warehouse):**
    *   **Pros:** Very easy to access truly global singletons from anywhere. Less boilerplate for simple global access.
    *   **Cons:** Can make it harder to track where a dependency is used. Testing can be trickier if everything relies on global state. Can be "too global" if a dependency is only needed in one section.
    *   **Use when:** For app-wide services (ThemeService, ApiService, UserSessionController) that are inherently singletons.

*   **`Binder` / `Bind.of(context)` (Local Delivery):**
    *   **Pros:** Dependencies are scoped to a specific part of the widget tree. Clearer where a dependency comes from (an ancestor `Binder`). Easier to have multiple, independent instances of the same controller type for different UI sections. Integrates naturally with Flutter's widget system and `BuildContext`. Better for testability of individual UI sections.
    *   **Cons:** Requires `BuildContext`. Slightly more verbose for providing the dependency (wrapping with `Binder`).
    *   **Use when:** A controller/dependency is specific to a particular screen or feature area. When you need multiple instancesManaging state for list items where each item might have its own controller. When you want to leverage Flutter's `InheritedWidget` patterns more directly.

Often, a GetX app will use a mix of both!

## Conclusion

You've now learned the key ways GetX helps you manage and access your dependencies:
*   `Get.put()` registers a dependency globally, making it like an item in a central warehouse.
*   `Get.find()` retrieves these globally registered dependencies.
*   `Binder` is an `InheritedWidget` that acts like a local delivery service, providing dependencies to a specific part of your widget tree.
*   `Bind.of(context)` (or context extensions like `context.get<T>()` and `context.listen<T>()`) allows descendant widgets to access these locally provided dependencies.

Understanding these mechanisms is crucial for building well-structured and maintainable GetX applications. You can now choose the right tool for the job, whether it's providing a global service or a locally scoped controller.

In the next chapter, we'll look at [Chapter 7: GetBuilder](07_getbuilder_.md). `GetBuilder` is a widget that often uses `Binder` and `Bind.of(context)` (or `Get.find()` implicitly) to listen to your `GetxController`'s manual `update()` calls and rebuild the UI efficiently.

Relevant Code Snippets (Code itself remains unchanged):
--- File: get_state_manager/src/simple/get_state.dart ---
// ignore_for_file: overridden_fields

import 'dart:async';

import 'package:flutter/material.dart';

import '../../../instance_manager.dart';
import '../../get_state_manager.dart';
import 'list_notifier.dart';

typedef InitBuilder<T> = T Function();

typedef GetControllerBuilder<T extends GetLifeCycleMixin> = Widget Function(
    T controller);

extension WatchExt on BuildContext {
  T listen<T>() {
    return Bind.of(this, rebuild: true);
  }
}

extension ReadExt on BuildContext {
  T get<T>() {
    return Bind.of(this);
  }
}

// extension FilterExt on BuildContext {
//   T filter<T extends GetxController>(Object Function(T value)? filter) {
//     return Bind.of(this, filter: filter, rebuild: true);
//   }
// }

class GetBuilder<T extends GetxController> extends StatelessWidget {
  final GetControllerBuilder<T> builder;
  final bool global;
  final Object? id;
  final String? tag;
  final bool autoRemove;
  final bool assignId;
  final Object Function(T value)? filter;
  final void Function(BindElement<T> state)? initState,
      dispose,
      didChangeDependencies;
  final void Function(Binder<T> oldWidget, BindElement<T> state)?
      didUpdateWidget;
  final T? init;

  const GetBuilder({
    super.key,
    this.init,
    this.global = true,
    required this.builder,
    this.autoRemove = true,
    this.assignId = false,
    this.initState,
    this.filter,
    this.tag,
    this.dispose,
    this.id,
    this.didChangeDependencies,
    this.didUpdateWidget,
  });

  @override
  Widget build(BuildContext context) {
    return Binder(
      init: init == null ? null : () => init!,
      global: global,
      autoRemove: autoRemove,
      assignId: assignId,
      initState: initState,
      filter: filter,
      tag: tag,
      dispose: dispose,
      id: id,
      lazy: false,
      didChangeDependencies: didChangeDependencies,
      didUpdateWidget: didUpdateWidget,
      child: Builder(builder: (context) {
        final controller = Bind.of<T>(context, rebuild: true);
        return builder(controller);
      }),
    );
    // return widget.builder(controller!);
  }
}

abstract class Bind<T> extends StatelessWidget {
  const Bind({
    super.key,
    required this.child,
    this.init,
    this.global = true,
    this.autoRemove = true,
    this.assignId = false,
    this.initState,
    this.filter,
    this.tag,
    this.dispose,
    this.id,
    this.didChangeDependencies,
    this.didUpdateWidget,
  });

  final InitBuilder<T>? init;

  final bool global;
  final Object? id;
  final String? tag;
  final bool autoRemove;
  final bool assignId;
  final Object Function(T value)? filter;
  final void Function(BindElement<T> state)? initState,
      dispose,
      didChangeDependencies;
  final void Function(Binder<T> oldWidget, BindElement<T> state)?
      didUpdateWidget;

  final Widget? child;

  static Bind put<S>(
    S dependency, {
    String? tag,
    bool permanent = false,
  }) {
    Get.put<S>(dependency, tag: tag, permanent: permanent);
    return _FactoryBind<S>(
      autoRemove: permanent,
      assignId: true,
      tag: tag,
    );
  }

  static bool fenixMode = false;

  static Bind lazyPut<S>(
    InstanceBuilderCallback<S> builder, {
    String? tag,
    bool? fenix,
    // VoidCallback? onInit,
    VoidCallback? onClose,
  }) {
    Get.lazyPut<S>(builder, tag: tag, fenix: fenix ?? fenixMode);
    return _FactoryBind<S>(
      tag: tag,
      // initState: (_) {
      //   onInit?.call();
      // },
      dispose: (_) {
        onClose?.call();
      },
    );
  }

  static Bind create<S>(InstanceCreateBuilderCallback<S> builder,
      {String? tag, bool permanent = true}) {
    return _FactoryBind<S>(
      create: builder,
      tag: tag,
      global: false,
    );
  }

  static Bind spawn<S>(InstanceBuilderCallback<S> builder,
      {String? tag, bool permanent = true}) {
    Get.spawn<S>(builder, tag: tag, permanent: permanent);
    return _FactoryBind<S>(
      tag: tag,
      global: false,
      autoRemove: permanent,
    );
  }

  static S find<S>({String? tag}) => Get.find<S>(tag: tag);

  static Future<bool> delete<S>({String? tag, bool force = false}) async =>
      Get.delete<S>(tag: tag, force: force);

  static Future<void> deleteAll({bool force = false}) async =>
      Get.deleteAll(force: force);

  static void reloadAll({bool force = false}) => Get.reloadAll(force: force);

  static void reload<S>({String? tag, String? key, bool force = false}) =>
      Get.reload<S>(tag: tag, key: key, force: force);

  static bool isRegistered<S>({String? tag}) => Get.isRegistered<S>(tag: tag);

  static bool isPrepared<S>({String? tag}) => Get.isPrepared<S>(tag: tag);

  static void replace<P>(P child, {String? tag}) {
    final info = Get.getInstanceInfo<P>(tag: tag);
    final permanent = (info.isPermanent ?? false);
    delete<P>(tag: tag, force: permanent);
    Get.put(child, tag: tag, permanent: permanent);
  }

  static void lazyReplace<P>(InstanceBuilderCallback<P> builder,
      {String? tag, bool? fenix}) {
    final info = Get.getInstanceInfo<P>(tag: tag);
    final permanent = (info.isPermanent ?? false);
    delete<P>(tag: tag, force: permanent);
    Get.lazyPut(builder, tag: tag, fenix: fenix ?? permanent);
  }

  factory Bind.builder({
    Widget? child,
    InitBuilder<T>? init,
    InstanceCreateBuilderCallback<T>? create,
    bool global = true,
    bool autoRemove = true,
    bool assignId = false,
    Object Function(T value)? filter,
    String? tag,
    Object? id,
    void Function(BindElement<T> state)? initState,
    void Function(BindElement<T> state)? dispose,
    void Function(BindElement<T> state)? didChangeDependencies,
    void Function(Binder<T> oldWidget, BindElement<T> state)? didUpdateWidget,
  }) =>
      _FactoryBind<T>(
        // key: key,
        init: init,
        create: create,
        global: global,
        autoRemove: autoRemove,
        assignId: assignId,
        initState: initState,
        filter: filter,
        tag: tag,
        dispose: dispose,
        id: id,
        didChangeDependencies: didChangeDependencies,
        didUpdateWidget: didUpdateWidget,
        child: child,
      );

  static T of<T>(
    BuildContext context, {
    bool rebuild = false,
    // Object Function(T value)? filter,
  }) {
    final inheritedElement =
        context.getElementForInheritedWidgetOfExactType<Binder<T>>()
            as BindElement<T>?;

    if (inheritedElement == null) {
      throw BindError(controller: '$T', tag: null);
    }

    if (rebuild) {
      // var newFilter = filter?.call(inheritedElement.controller!);
      // if (newFilter != null) {
      //  context.dependOnInheritedElement(inheritedElement, aspect: newFilter);
      // } else {
      context.dependOnInheritedElement(inheritedElement);
      // }
    }

    final controller = inheritedElement.controller;

    return controller;
  }

  @factory
  Bind<T> _copyWithChild(Widget child);
}

class _FactoryBind<T> extends Bind<T> {
  @override
  final InitBuilder<T>? init;

  final InstanceCreateBuilderCallback<T>? create;

  @override
  final bool global;
  @override
  final Object? id;
  @override
  final String? tag;
  @override
  final bool autoRemove;
  @override
  final bool assignId;
  @override
  final Object Function(T value)? filter;

  @override
  final void Function(BindElement<T> state)? initState,
      dispose,
      didChangeDependencies;
  @override
  final void Function(Binder<T> oldWidget, BindElement<T> state)?
      didUpdateWidget;

  @override
  final Widget? child;

  const _FactoryBind({
    super.key,
    this.child,
    this.init,
    this.create,
    this.global = true,
    this.autoRemove = true,
    this.assignId = false,
    this.initState,
    this.filter,
    this.tag,
    this.dispose,
    this.id,
    this.didChangeDependencies,
    this.didUpdateWidget,
  }) : super(child: child);

  @override
  Bind<T> _copyWithChild(Widget child) {
    return Bind<T>.builder(
      init: init,
      create: create,
      global: global,
      autoRemove: autoRemove,
      assignId: assignId,
      initState: initState,
      filter: filter,
      tag: tag,
      dispose: dispose,
      id: id,
      didChangeDependencies: didChangeDependencies,
      didUpdateWidget: didUpdateWidget,
      child: child,
    );
  }

  @override
  Widget build(BuildContext context) {
    return Binder<T>(
      create: create,
      global: global,
      autoRemove: autoRemove,
      assignId: assignId,
      initState: initState,
      filter: filter,
      tag: tag,
      dispose: dispose,
      id: id,
      didChangeDependencies: didChangeDependencies,
      didUpdateWidget: didUpdateWidget,
      child: child!,
    );
  }
}

class Binds extends StatelessWidget {
  final List<Bind<dynamic>> binds;
  final Widget child;

  Binds({
    super.key,
    required this.binds,
    required this.child,
  }) : assert(binds.isNotEmpty);

  @override
  Widget build(BuildContext context) =>
      binds.reversed.fold(child, (widget, e) => e._copyWithChild(widget));
}

class Binder<T> extends InheritedWidget {
  /// Create an inherited widget that updates its dependents when [controller]
  /// sends notifications.
  ///
  /// The [child] argument is required
  const Binder({
    super.key,
    required super.child,
    this.init,
    this.global = true,
    this.autoRemove = true,
    this.assignId = false,
    this.lazy = true,
    this.initState,
    this.filter,
    this.tag,
    this.dispose,
    this.id,
    this.didChangeDependencies,
    this.didUpdateWidget,
    this.create,
  });

  final InitBuilder<T>? init;
  final InstanceCreateBuilderCallback? create;
  final bool global;
  final Object? id;
  final String? tag;
  final bool lazy;
  final bool autoRemove;
  final bool assignId;
  final Object Function(T value)? filter;
  final void Function(BindElement<T> state)? initState,
      dispose,
      didChangeDependencies;
  final void Function(Binder<T> oldWidget, BindElement<T> state)?
      didUpdateWidget;

  @override
  bool updateShouldNotify(Binder<T> oldWidget) {
    return oldWidget.id != id ||
        oldWidget.global != global ||
        oldWidget.autoRemove != autoRemove ||
        oldWidget.assignId != assignId;
  }

  @override
  InheritedElement createElement() => BindElement<T>(this);
}

/// The BindElement is responsible for injecting dependencies into the widget
/// tree so that they can be observed
class BindElement<T> extends InheritedElement {
  BindElement(Binder<T> super.widget) {
    initState();
  }

  final disposers = <Disposer>[];

  InitBuilder<T>? _controllerBuilder;

  T? _controller;

  T get controller {
    if (_controller == null) {
      _controller = _controllerBuilder?.call();
      _subscribeToController();
      if (_controller == null) {
        throw BindError(controller: T, tag: widget.tag);
      }
      return _controller!;
    } else {
      return _controller!;
    }
  }

  bool? _isCreator = false;
  bool? _needStart = false;
  bool _wasStarted = false;
  VoidCallback? _remove;
  Object? _filter;

  void initState() {
    widget.initState?.call(this);

    var isRegistered = Get.isRegistered<T>(tag: widget.tag);

    if (widget.global) {
      if (isRegistered) {
        if (Get.isPrepared<T>(tag: widget.tag)) {
          _isCreator = true;
        } else {
          _isCreator = false;
        }

        _controllerBuilder = () => Get.find<T>(tag: widget.tag);
      } else {
        _controllerBuilder =
            () => (widget.create?.call(this) ?? widget.init?.call());
        _isCreator = true;
        if (widget.lazy) {
          Get.lazyPut<T>(_controllerBuilder!, tag: widget.tag);
        } else {
          Get.put<T>(_controllerBuilder!(), tag: widget.tag);
        }
      }
    } else {
      if (widget.create != null) {
        _controllerBuilder = () => widget.create!.call(this);
        Get.spawn<T>(_controllerBuilder!, tag: widget.tag, permanent: false);
      } else {
        _controllerBuilder = widget.init;
      }
      _controllerBuilder =
          (widget.create != null ? () => widget.create!.call(this) : null) ??
              widget.init;
      _isCreator = true;
      _needStart = true;
    }
  }

  /// Register to listen Controller's events.
  /// It gets a reference to the remove() callback, to delete the
  /// setState "link" from the Controller.
  void _subscribeToController() {
    if (widget.filter != null) {
      _filter = widget.filter!(_controller as T);
    }
    final filter = _filter != null ? _filterUpdate : getUpdate;
    final localController = _controller;

    if (_needStart == true && localController is GetLifeCycleMixin) {
      localController.onStart();
      _needStart = false;
      _wasStarted = true;
    }

    if (localController is GetxController) {
      _remove?.call();
      _remove = (widget.id == null)
          ? localController.addListener(filter)
          : localController.addListenerId(widget.id, filter);
    } else if (localController is Listenable) {
      _remove?.call();
      localController.addListener(filter);
      _remove = () => localController.removeListener(filter);
    } else if (localController is StreamController) {
      _remove?.call();
      final stream = localController.stream.listen((_) => filter());
      _remove = () => stream.cancel();
    }
  }

  void _filterUpdate() {
    var newFilter = widget.filter!(_controller as T);
    if (newFilter != _filter) {
      _filter = newFilter;
      getUpdate();
    }
  }

  void dispose() {
    widget.dispose?.call(this);
    if (_isCreator! || widget.assignId) {
      if (widget.autoRemove && Get.isRegistered<T>(tag: widget.tag)) {
        Get.delete<T>(tag: widget.tag);
      }
    }

    for (final disposer in disposers) {
      disposer();
    }

    disposers.clear();

    _remove?.call();
    _controller = null;
    _isCreator = null;
    _remove = null;
    _filter = null;
    _needStart = null;
    _controllerBuilder = null;
    _controller = null;
  }

  @override
  Binder<T> get widget => super.widget as Binder<T>;

  var _dirty = false;

  @override
  void update(Binder<T> newWidget) {
    final oldNotifier = widget.id;
    final newNotifier = newWidget.id;
    if (oldNotifier != newNotifier && _wasStarted) {
      _subscribeToController();
    }
    widget.didUpdateWidget?.call(widget, this);
    super.update(newWidget);
  }

  @override
  void didChangeDependencies() {
    super.didChangeDependencies();
    widget.didChangeDependencies?.call(this);
  }

  @override
  Widget build() {
    if (_dirty) {
      notifyClients(widget);
    }
    // return Notifier.instance.notifyAppend(
    //   NotifyData(
    //       disposers: disposers, updater: getUpdate, throwException: false),
    return super.build();
    //);
  }

  void getUpdate() {
    _dirty = true;
    markNeedsBuild();
  }

  @override
  void notifyClients(Binder<T> oldWidget) {
    super.notifyClients(oldWidget);
    _dirty = false;
  }

  @override
  void unmount() {
    dispose();
    super.unmount();
  }
}

class BindError<T> extends Error {
  /// The type of the class the user tried to retrieve
  final T controller;
  final String? tag;

  /// Creates a [BindError]
  BindError({required this.controller, required this.tag});

  @override
  String toString() {
    if (controller == 'dynamic') {
      return '''Error: please specify type [<T>] when calling context.listen<T>() or context.find<T>() method.''';
    }

    return '''Error: No Bind<$controller>  ancestor found. To fix this, please add a Bind<$controller> widget ancestor to the current context.
      ''';
  }
}

/// [Binding] should be extended.
/// When using `GetMaterialApp`, all `GetPage`s and navigation
/// methods (like Get.to()) have a `binding` property that takes an
/// instance of Bindings to manage the
/// dependencies() (via Get.put()) for the Route you are opening.
// ignore: one_member_abstracts
abstract class Binding extends BindingsInterface<List<Bind>> {}


--- File: get_state_manager/src/simple/get_controllers.dart ---
// ignore: prefer_mixin
import 'package:flutter/widgets.dart';

import '../../../instance_manager.dart';
import '../rx_flutter/rx_notifier.dart';
import 'list_notifier.dart';

// ignore: prefer_mixin
abstract class GetxController extends ListNotifier with GetLifeCycleMixin {
  /// Rebuilds `GetBuilder` each time you call `update()`;
  /// Can take a List of [ids], that will only update the matching
  /// `GetBuilder( id: )`,
  /// [ids] can be reused among `GetBuilders` like group tags.
  /// The update will only notify the Widgets, if [condition] is true.
  void update([List<Object>? ids, bool condition = true]) {
    if (!condition) {
      return;
    }
    if (ids == null) {
      refresh();
    } else {
      for (final id in ids) {
        refreshGroup(id);
      }
    }
  }
}

/// this mixin allow to fetch data when the scroll is at the bottom or on the
/// top
mixin ScrollMixin on GetLifeCycleMixin {
  final ScrollController scroll = ScrollController();

  @override
  void onInit() {
    super.onInit();
    scroll.addListener(_listener);
  }

  bool _canFetchBottom = true;

  bool _canFetchTop = true;

  void _listener() {
    if (scroll.position.atEdge) {
      _checkIfCanLoadMore();
    }
  }

  Future<void> _checkIfCanLoadMore() async {
    if (scroll.position.pixels == 0) {
      if (!_canFetchTop) return;
      _canFetchTop = false;
      await onTopScroll();
      _canFetchTop = true;
    } else {
      if (!_canFetchBottom) return;
      _canFetchBottom = false;
      await onEndScroll();
      _canFetchBottom = true;
    }
  }

  /// this method is called when the scroll is at the bottom
  Future<void> onEndScroll();

  /// this method is called when the scroll is at the top
  Future<void> onTopScroll();

  @override
  void onClose() {
    scroll.removeListener(_listener);
    super.onClose();
  }
}

/// A clean controller to be used with only Rx variables
abstract class RxController with GetLifeCycleMixin {}

/// A recommended way to use Getx with Future fetching
abstract class StateController<T> extends GetxController with StateMixin<T> {}

/// A controller with super lifecycles (including native lifecycles)
/// and StateMixins
abstract class SuperController<T> extends FullLifeCycleController
    with FullLifeCycleMixin, StateMixin<T> {}

/// A controller with super lifecycles (including native lifecycles)
abstract class FullLifeCycleController extends GetxController
    with
        // ignore: prefer_mixin
        WidgetsBindingObserver {}

mixin FullLifeCycleMixin on FullLifeCycleController {
  @mustCallSuper
  @override
  void onInit() {
    super.onInit();
    Engine.instance.addObserver(this);
  }

  @mustCallSuper
  @override
  void onClose() {
    Engine.instance.removeObserver(this);
    super.onClose();
  }

  @mustCallSuper
  @override
  void didChangeAppLifecycleState(AppLifecycleState state) {
    switch (state) {
      case AppLifecycleState.resumed:
        onResumed();
        break;
      case AppLifecycleState.inactive:
        onInactive();
        break;
      case AppLifecycleState.paused:
        onPaused();
        break;
      case AppLifecycleState.detached:
        onDetached();
        break;
      case AppLifecycleState.hidden:
        onHidden();
        break;
    }
  }

  void onResumed() {}
  void onPaused() {}
  void onInactive() {}
  void onDetached() {}
  void onHidden() {}
}


Instructions for the chapter (Generate content in English unless specified otherwise):
- Start with a clear heading (e.g., `# Chapter 7: GetBuilder
`). Use the provided concept name.

- If this is not the first chapter, begin with a brief transition from the previous chapter, referencing it with a proper Markdown link using its name.

- Begin with a high-level motivation explaining what problem this abstraction solves. Start with a central use case as a concrete example. The whole chapter should guide the reader to understand how to solve this use case. Make it very minimal and friendly to beginners.

- If the abstraction is complex, break it down into key concepts. Explain each concept one-by-one in a very beginner-friendly way.

- Explain how to use this abstraction to solve the use case. Give example inputs and outputs for code snippets (if the output isn't values, describe at a high level what will happen).

- Each code block should be BELOW 10 lines! If longer code blocks are needed, break them down into smaller pieces and walk through them one-by-one. Aggresively simplify the code to make it minimal. Use comments to skip non-important implementation details. Each code block should have a beginner friendly explanation right after it.

- Describe the internal implementation to help understand what's under the hood. First provide a non-code or code-light walkthrough on what happens step-by-step when the abstraction is called. It's recommended to use a simple sequenceDiagram with a dummy example - keep it minimal with at most 5 participants to ensure clarity. If participant name has space, use: `participant QP as Query Processing`. .

- Then dive deeper into code for the internal implementation with references to files. Provide example code blocks, but make them similarly simple and beginner-friendly. Explain.

- IMPORTANT: When you need to refer to other core abstractions covered in other chapters, ALWAYS use proper Markdown links like this: [Chapter Title](filename.md). Use the Complete Tutorial Structure above to find the correct filename and the chapter title. Translate the surrounding text.

- Use mermaid diagrams to illustrate complex concepts (```mermaid``` format). .

- Heavily use analogies and examples throughout to help beginners understand.

- End the chapter with a brief conclusion that summarizes what was learned and provides a transition to the next chapter. If there is a next chapter, use a proper Markdown link: [Next Chapter Title](next_chapter_filename).

- Ensure the tone is welcoming and easy for a newcomer to understand.

- Output *only* the Markdown content for this chapter.

Now, directly provide a super beginner-friendly Markdown output (DON'T need ```markdown``` tags):

2025-05-12 13:38:18,293 - INFO - RESPONSE: # Chapter 7: GetBuilder

Welcome to Chapter 7! In [Chapter 6: Dependency Access (Binder, Bind.of, Get.find/put)](06_dependency_access__binder__bind_of__get_find_put__.md), we explored how to make our `GetxController` instances (our app's "brains") available to different parts of our UI. Now, let's look at another way to connect our UI to these controllers, specifically when we want more *manual* control over UI updates.

## What's the Problem? "I Want to Update My Screen *Only* When I Say So!"

Imagine you have an app screen displaying a count.
*   In [Chapter 3: Obx / ObxWidget](03_obx___obxwidget_.md), we learned about `Obx` which is fantastic for automatically updating the UI whenever an `Rx<T>` (reactive) variable changes.
*   But what if your count is just a regular `int` variable inside your `GetxController`, not an `RxInt`?
*   Or what if you want to perform several state changes and then update the UI only once, at the very end, for performance reasons or finer control?

This is where `GetBuilder` comes in. It's like having a digital display in a store that only refreshes its content when the store manager explicitly presses an "update display" button. It gives you precise, manual control.

## Meet GetBuilder: The Manually Triggered UI Refresher

`GetBuilder` is a Flutter widget provided by GetX. Its primary job is to:
1.  Listen to a specific [GetxController](05_getxcontroller_.md).
2.  Rebuild the part of your UI it wraps *only* when you explicitly call the `update()` method on that controller.

This is different from `Obx`, which reacts automatically to changes in `.obs` variables. `GetBuilder` responds to the manual `controller.update()` command.

## How to Use `GetBuilder`

Let's build a simple counter app where the count is a plain `int` in our controller, and we use `GetBuilder` to update the display.

### 1. Create Your Controller with Manual Updates

First, let's define a `GetxController`. Inside, we'll have a regular integer for our count and a method to increment it. Crucially, this method will call `update()` after changing the count.

```dart
// counter_controller.dart
import 'package:get/get.dart';

class ManualCounterController extends GetxController {
  int count = 0; // A regular integer, NOT reactive (.obs)

  void increment() {
    count++;
    update(); // THIS is the "update display" button!
    print("Count is now $count. UI update requested.");
  }
}
```
**Explanation:**
*   `count` is a simple `int`. Changes to it won't automatically trigger UI updates.
*   The `increment()` method increases `count` and then calls `update()`. This `update()` call is what `GetBuilder` will listen for.

### 2. Make Your Controller Available

As we learned in [Chapter 6: Dependency Access (Binder, Bind.of, Get.find/put)](06_dependency_access__binder__bind_of__get_find_put__.md), your controller needs to be made available. For simplicity, we can use `Get.put()` if it's a global controller, or it could be provided by an ancestor `Binder` widget.

```dart
// In your main.dart or an initialization file
Get.put(ManualCounterController());
```
This makes an instance of `ManualCounterController` available for `GetBuilder` to find.

### 3. Use `GetBuilder` in Your UI

Now, in your widget, you wrap the part of the UI that needs to display the `count` with `GetBuilder`.

```dart
// counter_page.dart
import 'package:flutter/material.dart';
import 'package:get/get.dart';
import 'counter_controller.dart'; // Your controller file

class ManualCounterPage extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(title: Text("GetBuilder Counter")),
      body: Center(
        // 1. Wrap your UI with GetBuilder
        child: GetBuilder<ManualCounterController>(
          // It will find the controller put by Get.put()
          // Or you could provide 'init: ManualCounterController()' here
          // to create a new instance scoped to this GetBuilder.

          builder: (controller) { // 2. The builder gives you the controller
            return Text(
              "Count: ${controller.count}", // 3. Access controller's state
              style: TextStyle(fontSize: 30),
            );
          },
        ),
      ),
      floatingActionButton: FloatingActionButton(
        onPressed: () {
          // Find the controller and call its method
          final ManualCounterController c = Get.find();
          c.increment();
        },
        child: Icon(Icons.add),
      ),
    );
  }
}
```
**What happens?**
1.  The `ManualCounterPage` loads. `GetBuilder` finds the `ManualCounterController` instance (the one we registered with `Get.put()`). It runs its `builder` function, and `Text("Count: 0")` is displayed.
2.  You tap the `+` button.
3.  The `onPressed` callback calls `controller.increment()`.
4.  Inside `increment()`, `count` becomes `1`, and then `update()` is called.
5.  The `GetBuilder` widget, which is listening to this specific `ManualCounterController`, "hears" the `update()` call.
6.  `GetBuilder` re-runs its `builder` function. This time, `controller.count` is `1`, so a new `Text("Count: 1")` is created and displayed.
Output (in console from the controller):
```
Count is now 1. UI update requested.
Count is now 2. UI update requested.
...
```
The UI refreshes precisely when `update()` is invoked!

### Key Properties of `GetBuilder`

*   **`builder: (controller) { ... }` (Required):** This function takes the controller instance `T` and must return the widget that should be rebuilt.
*   **`init: YourController()` (Optional):** If you provide an `init` property, `GetBuilder` will create and manage a new instance of that controller. This instance will typically be scoped to this `GetBuilder`, meaning it's available to this `GetBuilder` and its children, and it's usually disposed of when the `GetBuilder` is removed from the widget tree (due to `autoRemove: true` by default).
    ```dart
    GetBuilder<MyScopedController>(
      init: MyScopedController(), // Creates a new controller instance here
      builder: (controller) => Text(controller.data),
    )
    ```
*   **Finding an Existing Controller:** If `init` is *not* provided, `GetBuilder` attempts to find an already existing controller.
    *   By default (`global: true`), it will effectively use `Get.find<T>()` or find it through the `Binder` it creates internally (which itself can use `Get.find()`).
    * If `global: false`, it relies more strictly on finding the controller from an ancestor `Binder` widget in the tree. This is useful for more localized state. (Refer to [Chapter 6](06_dependency_access__binder__bind_of__get_find_put__.md) for `Binder`).
*   **`id: 'someUniqueId'` (Optional):** For selective updates. If you have multiple `GetBuilder`s listening to the same controller, you can give them IDs. Then, in your controller, you can call `update(['someUniqueId'])` to only rebuild `GetBuilder`s that have matching IDs.
    ```dart
    // In controller:
    // void updateProfileSection() { update(['profile']); }
    // void updateSettingsSection() { update(['settings']); }

    // In UI:
    // GetBuilder<UserController>(id: 'profile', builder: ...)
    // GetBuilder<UserController>(id: 'settings', builder: ...)
    ```
*   **`autoRemove: true` (Default):** If `GetBuilder` initialized the controller (via `init`), this determines if the controller should be disposed when `GetBuilder` is removed from the widget tree. Usually, you want this to be `true` to prevent memory leaks.
*   **`global: true` (Default):** Controls how the `Binder` (used internally by `GetBuilder`) finds or registers the controller with GetX's dependency manager. For beginners, the default usually works well, allowing `GetBuilder` to find globally `put` controllers or manage its own if `init` is used.

## GetBuilder vs. Obx: When to Use Which?

This is a common question for newcomers!

*   **`Obx` ([Chapter 3: Obx / ObxWidget](03_obx___obxwidget_.md)):**
    *   Use with **reactive variables** (e.g., `name.obs`, `count.obs`).
    *   Updates **automatically** when the `.value` of an observed `Rx<T>` variable changes *inside* its builder.
    *   Typically simpler for purely reactive state.
    *   Syntax: `Obx(() => Text(controller.reactiveName.value))`

*   **`GetBuilder`:**
    *   Use with **any type of state** in your `GetxController`, including non-reactive variables (like plain `int`s or `String`s).
    *   Updates **manually** when you call `controller.update()`.
    *   Gives you more **explicit control** over when rebuilds occur.
    *   Can be useful if you want to batch multiple state changes and trigger a single UI update.
    *   Sometimes preferred for complex state logic or when migrating from other state management solutions that use manual refresh notifications.
    *   Syntax: `GetBuilder<MyController>(builder: (controller) => Text(controller.plainName))`

You can even use both in the same app, or even for the same controller, depending on the specific needs of different UI parts!

## Under the Hood: How Does `GetBuilder` Work?

`GetBuilder` might seem simple on the surface, but it leverages some clever GetX mechanics:

1.  **Controller Access:**
    *   As seen in the internal `build` method of `GetBuilder` (in `get_state_manager/src/simple/get_state.dart`), it actually wraps its `child` (defined by your `builder` function) with a `Binder` widget.
    ```dart
    // Simplified from GetBuilder's build method in get_state.dart
    @override
    Widget build(BuildContext context) {
      return Binder( // GetBuilder uses a Binder internally!
        init: init == null ? null : () => init!, // Passes your init
        global: global, // And other properties...
        // ...
        child: Builder(builder: (context) {
          // It then uses Bind.of to get the controller
          // 'rebuild: true' means it subscribes for updates
          final controller = Bind.of<T>(context, rebuild: true);
          return builder(controller); // Calls your builder function
        }),
      );
    }
    ```
    *   This `Binder` is responsible for either creating a new controller instance (if `init` is provided) or finding an existing one (as explained in [Chapter 6: Dependency Access (Binder, Bind.of, Get.find/put)](06_dependency_access__binder__bind_of__get_find_put__.md)).
    *   The `Bind.of<T>(context, rebuild: true)` part is crucial. It not only gets the controller instance but also tells Flutter that this widget (the `Builder` inside `GetBuilder`) depends on the `Binder`. If the `Binder` signals an update, this widget should rebuild.

2.  **Listening for `update()`:**
    *   When `Bind.of(context, rebuild: true)` connects to the controller (managed by the `Binder`), the `BinderElement` (the `Element` for the `Binder` widget) adds a listener to the controller.
    *   Remember from [Chapter 5: GetxController](05_getxcontroller_.md) that `GetxController` extends `ListNotifier`? This `ListNotifier` is what manages a list of "update functions" (listeners).
    *   The `BinderElement` effectively gives its own "rebuild me" function to the controller's `ListNotifier`.

3.  **The `update()` Call:**
    *   When you call `controller.update()` in your `GetxController`, this internally calls `refresh()` on its `ListNotifier`.
    *   `refresh()` then iterates through all its registered listeners (including the one from `GetBuilder`'s internal `BinderElement`) and executes them.

4.  **UI Rebuild:**
    *   When `GetBuilder`'s `BinderElement` listener is called, it marks itself as needing a rebuild.
    *   Flutter then schedules a rebuild for that part of the widget tree.
    *   `GetBuilder`'s main `build` method runs again, which in turn calls your `builder: (controller) { ... }` function with the same controller instance (which now has the updated state).

Here's a simplified sequence:

```mermaid
sequenceDiagram
    participant UserAction as User Taps Button
    participant Controller as YourController
    participant ControllerNotifier as Controller's ListNotifier
    participant GetBuilderInternal as GetBuilder (Binder/Bind.of)
    participant YourUIBuilder as Your builder: (ctrl) => Text(...)

    Note over ControllerNotifier, GetBuilderInternal: GetBuilder (via Binder) has subscribed to Controller's Notifier

    UserAction->>Controller: Calls controller.increment()
    Controller->>Controller: Updates its internal state (e.g., `count++`)
    Controller->>ControllerNotifier: Calls this.update() which calls refresh()
    ControllerNotifier-->>GetBuilderInternal: Notifies its listener (the BinderElement)
    GetBuilderInternal->>GetBuilderInternal: Marks itself for rebuild
    GetBuilderInternal-->>YourUIBuilder: Invokes your builder function
    YourUIBuilder->>Controller: Accesses controller.count (new value)
    YourUIBuilder-->>UserAction: UI displays updated count
```

So, `GetBuilder` provides a structured way to manually trigger UI updates by cleverly using `Binder` and the `ListNotifier` capabilities of `GetxController`.

## Conclusion

You've now learned about `GetBuilder`, your tool for manually controlling UI updates in GetX. It's ideal when you're not using reactive `.obs` variables for a piece of state, or when you need fine-grained control over *when* your UI should refresh in response to changes in a `GetxController`. By calling `controller.update()`, you tell all listening `GetBuilder` widgets it's time to redraw themselves.

While `GetBuilder` deals with general state and manual updates, GetX also offers specialized tools for handling more complex state scenarios, like loading data from a server, showing error messages, or displaying empty states. One such tool is the `StateMixin`.

Let's explore this powerful mixin in the [next chapter, Chapter 8: StateMixin](08_statemixin_.md).
2025-05-12 13:38:18,356 - INFO - PROMPT: 
Write a very beginner-friendly tutorial chapter (in Markdown format) for the project `lib` about the concept: "StateMixin
". This is Chapter 8.

Concept Details:
- Name: StateMixin

- Description:
`StateMixin` is a utility mixed into controllers to easily manage common UI states for
asynchronous operations: loading, success (with data), error, and empty.
It provides a `status` property (e.g., `status.isLoading`) and simplifies showing different widgets (often using `obx` method)
based on the current state of data fetching. Its like a
standardized status panel for your data, clearly indicating its current condition.


Complete Tutorial Structure:
1. [Get (Global Access Facade)
](01_get__global_access_facade__.md)
2. [Rx<T> (Reactive Variables)
](02_rx_t___reactive_variables__.md)
3. [Obx / ObxWidget
](03_obx___obxwidget_.md)
4. [Workers
](04_workers_.md)
5. [GetxController
](05_getxcontroller_.md)
6. [Dependency Access (Binder, Bind.of, Get.find/put)
](06_dependency_access__binder__bind_of__get_find_put__.md)
7. [GetBuilder
](07_getbuilder_.md)
8. [StateMixin
](08_statemixin_.md)
9. [ListNotifier (and Mixins)
](09_listnotifier__and_mixins__.md)

Context from previous chapters:
# Chapter 1: Get (Global Access Facade)

Welcome to your GetX journey! In this first chapter, we'll explore one of the most fundamental and frequently used parts of the GetX ecosystem: the `Get` object.

## What is `Get` and Why Do You Need It?

Imagine you're building a Flutter app. You often need to perform common tasks like:
*   Showing a quick message (a "snackbar") to the user.
*   Navigating to a new screen.
*   Accessing a shared service, like a settings manager, from various parts of your app.

Traditionally, in Flutter, many of these tasks require access to something called `BuildContext`. `BuildContext` tells Flutter "where" you are in your widget tree, which is necessary for operations like finding the nearest `Navigator` or `Scaffold`. Getting `BuildContext` to the exact spot where you need it can sometimes be cumbersome, especially in deeper parts of your app's logic that aren't directly part of a widget.

This is where `Get` comes to the rescue!

The `Get` object is your main entry point for most GetX features. Think of it as a **universal remote control** for your application. It provides super easy-to-use tools (called static methods) for:

*   **Dependency Management:** Storing and retrieving your app's services or "managers" (like a `UserSettingsManager` or `ApiService`).
*   **Navigation:** Moving between screens with simple commands.
*   **Showing UI Elements:** Displaying dialogs, snackbars, or bottom sheets.
*   ...and much more!

The beauty of `Get` is that it often lets you do these things **without needing `BuildContext`**, making your code cleaner and simplifying access to GetX functionalities from virtually anywhere in your app.

## How to Use `Get`

Using `Get` is incredibly straightforward because its methods are `static`. This means you don't need to create an instance of a `Get` class; you just type `Get.` followed by the feature you want to use.

Let's look at a few common use cases:

### 1. Showing a Snackbar

Need to show a quick notification to the user?

```dart
import 'package:get/get.dart'; // Make sure to import GetX

// ...somewhere in your code, even inside a business logic class
void showSuccessMessage() {
  Get.snackbar(
    "Success!", // title
    "Your profile was updated successfully.", // message
    snackPosition: SnackPosition.BOTTOM
  );
}
```

**What happens?**
When `showSuccessMessage()` is called, GetX will display a snackbar at the bottom of the current screen with the title "Success!" and the given message. Notice you didn't need to pass any `BuildContext`!

### 2. Navigating to a New Screen

Want to open a new page?

```dart
import 'package:flutter/material.dart';
import 'package:get/get.dart';

class HomeScreen extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(title: Text("Home")),
      body: Center(
        child: ElevatedButton(
          onPressed: () {
            Get.to(DetailScreen()); // Navigate to DetailScreen
          },
          child: Text("Go to Details"),
        ),
      ),
    );
  }
}

class DetailScreen extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(title: Text("Details")),
      body: Center(
        child: ElevatedButton(
          onPressed: () {
            Get.back(); // Go back to the previous screen
          },
          child: Text("Go Back"),
        ),
      ),
    );
  }
}
```
**What happens?**
*   Tapping the "Go to Details" button on `HomeScreen` will push `DetailScreen` onto the navigation stack, making it visible.
*   Tapping the "Go Back" button on `DetailScreen` will pop it from the stack, revealing `HomeScreen` again.

Again, simple and no `BuildContext` needed for `Get.to()` or `Get.back()`. (Note: To use GetX navigation, your main app widget should be `GetMaterialApp` instead of `MaterialApp`).

### 3. Basic Dependency Management (Service Locator)

Imagine you have a class that manages user preferences:

```dart
class UserPreferencesService {
  bool _isDarkMode = false;

  bool get isDarkMode => _isDarkMode;

  void toggleDarkMode() {
    _isDarkMode = !_isDarkMode;
    print("Dark mode is now: $_isDarkMode");
    // In a real app, you'd save this preference
  }
}
```

You can "register" an instance of this service with GetX using `Get.put()`:

```dart
// Usually done at app startup or in a specific setup area
void initializeServices() {
  Get.put(UserPreferencesService());
  print("UserPreferencesService registered!");
}
```

Later, from anywhere in your app, you can retrieve this instance using `Get.find()`:

```dart
// ... in some widget or controller
void onThemeToggleButtonPressed() {
  final prefsService = Get.find<UserPreferencesService>();
  prefsService.toggleDarkMode();
  // You might then update your UI based on prefsService.isDarkMode
}
```

**What happens?**
*   `Get.put(UserPreferencesService());` creates an instance of `UserPreferencesService` and stores it in a global container managed by GetX.
*   `Get.find<UserPreferencesService>();` looks up and returns that stored instance.

This allows you to easily access shared services without passing instances around manually or using complex InheritedWidgets. We'll dive much deeper into dependency management in [Chapter 6: Dependency Access (Binder, Bind.of, Get.find/put)](06_dependency_access__binder__bind_of__get_find_put__.md).

## Under the Hood: How Does `Get` Work?

You might be wondering how `Get` can perform these actions, especially UI-related ones like showing snackbars, without `BuildContext`.

At its core, `Get` is a cleverly designed global static instance. When you use GetX (typically by wrapping your app with `GetMaterialApp`), GetX sets up the necessary infrastructure.

Here's a simplified conceptual flow for showing a snackbar:

```mermaid
sequenceDiagram
    participant YourCode as Your App Code
    participant Get as Get Object
    participant GetXCore as GetX Internal Logic
    participant FlutterFramework as Flutter Framework

    YourCode->>Get: Calls Get.snackbar("Title", "Message")
    Get->>GetXCore: Forwards request to internal snackbar logic
    GetXCore->>FlutterFramework: Uses Flutter's Overlay (or similar) to display UI
    FlutterFramework-->>YourCode: Snackbar appears on screen
```

**1. The `Get` Object Itself:**
The `Get` object you use is actually a global instance of a class. This is defined very simply in the GetX core:

```dart
// From: get_core/src/get_main.dart

// (_GetImpl is a class that implements GetInterface,
// where all the actual methods are defined or extended)
class _GetImpl extends GetInterface {}

// This creates a single, globally accessible instance named 'Get'
// ignore: non_constant_identifier_names
final Get = _GetImpl();
```
This `Get` variable is what you're accessing when you type `Get.something()`.

**2. `GetInterface` and Extensions:**
The `_GetImpl` class extends `GetInterface`.
```dart
// From: get_core/src/get_interface.dart
abstract class GetInterface {
  // Basic configurations like smartManagement and logging
  SmartManagement smartManagement = SmartManagement.full;
  bool isLogEnable = kDebugMode;
  LogWriterCallback log = defaultLogWriterCallback;
  // ... other core properties might be declared here
}
```
Many of GetX's functionalities (like `Get.to`, `Get.snackbar`, `Get.put`, `Get.find`) are added to this `GetInterface` through Dart's extension methods or are mixed into `_GetImpl`. These extensions contain the actual logic. For example, the navigation methods know how to find the `Navigator` provided by `GetMaterialApp`, and the snackbar methods know how to tap into Flutter's `Overlay` to display UI elements globally.

**3. For Dependency Management (`Get.put` / `Get.find`):**
When you use `Get.put(MyService())`, GetX stores this `MyService` instance in an internal data structure (like a map), often an_instance manager. When you later call `Get.find<MyService>()`, GetX looks up `MyService` in this internal storage by its type (and optionally by a tag) and returns the stored instance. We'll cover the `InstanceManager` in more detail in [Chapter 6: Dependency Access (Binder, Bind.of, Get.find/put)](06_dependency_access__binder__bind_of__get_find_put__.md).

The key takeaway is that `Get` acts as a **facade**  a simplified, unified interface to a more complex underlying system. It hides the complexities of interacting directly with Flutter's deeper systems or managing global instances, providing you with clean, easy-to-use static methods.

## Conclusion

You've now met `Get`, your go-to helper for many common tasks in GetX. It's a powerful yet simple facade that provides global access to navigation, UI utilities, dependency management, and more, often without the need for `BuildContext`. This keeps your code clean and makes development faster.

As you continue your GetX journey, you'll see `Get` being used in various contexts. Understanding its role as a global access point is key to mastering GetX.

In the next chapter, we'll explore a core GetX concept for making your application's data dynamic and responsive: [Rx<T> (Reactive Variables)](02_rx_t___reactive_variables__.md).
---
# Chapter 2: Rx<T> (Reactive Variables)

Welcome to Chapter 2! In [Chapter 1: Get (Global Access Facade)](01_get__global_access_facade__.md), we learned how the `Get` object acts as a handy "universal remote" for common app tasks. Now, we're going to dive into one of the most exciting features of GetX: making your app's data "reactive."

## What's the Big Deal with "Reactive"?

Imagine you're building an app that shows a user's score. When the score changes, you want the text on the screen displaying that score to update *automatically*, without you having to write a lot of complicated code to manually refresh the screen. This "automatic updating" is what reactive programming is all about.

`Rx<T>` variables are GetX's way of achieving this magic.

## Introducing `Rx<T>`: Your Magic Whiteboard

`Rx<T>` types (like `RxInt`, `RxString`, or pretty much anything you see ending with `.obs`) represent variables that can be "observed."

Think of an `Rx<T>` variable as a special number (or text, or any data) written on a **magic whiteboard**:
*   You write your initial data on this whiteboard (e.g., the number `0`).
*   Whenever someone erases the number and writes a new one (e.g., changes it to `1`), a bell automatically rings!
*   Anyone (or any part of your app's UI) specifically "watching" that number on the whiteboard instantly sees the change and reacts to it.

These `Rx<T>` variables are the heart of GetX's reactive programming. They allow your User Interface (UI), especially when used with widgets like `Obx` (which we'll cover in the [next chapter](03_obx___obxwidget_.md)), to automatically update whenever the underlying data changes.

The `T` in `Rx<T>` is a placeholder for the type of data the variable will hold, like `int`, `String`, `bool`, or even your own custom classes.

## How to Create and Use Reactive Variables

Let's see how to create and use these "magic" variables. The most common way is by using the `.obs` extension on a standard Dart value.

### 1. Creating a Reactive Variable

To make a regular variable reactive, you simply add `.obs` to its initial value.

**For a number (integer):**

```dart
import 'package:get/get.dart'; // Don't forget to import GetX

final count = 0.obs; // This is now an RxInt holding 0
// You could also write: final count = RxInt(0);
```
Here, `count` isn't just a regular `int`. It's now a special `RxInt` object that holds the integer value `0` and can notify others when it changes.

**For text (string):**

```dart
final userName = "Guest".obs; // This is an RxString holding "Guest"
// You could also write: final userName = RxString("Guest");
```
Similarly, `userName` is an `RxString`.

**For a boolean (true/false):**

```dart
final isLoggedIn = false.obs; // This is an RxBool holding false
// You could also write: final isLoggedIn = RxBool(false);
```

### 2. Getting the Value

If `count` is an `RxInt`, how do you get the actual integer value out of it? You use the `.value` property.

```dart
final count = 0.obs;
print(count.value); // Output: 0

final userName = "Guest".obs;
print(userName.value); // Output: Guest
```
Think of `.value` as looking at the magic whiteboard to read what's currently written on it.

### 3. Changing the Value (and Ringing the Bell!)

To change the value of a reactive variable, you also assign a new value to its `.value` property. This is the action that "rings the bell."

```dart
final count = 0.obs;
print("Initial count: ${count.value}"); // Output: Initial count: 0

count.value = 5; // You changed the number on the whiteboard!
print("New count: ${count.value}"); // Output: New count: 5
```
When you do `count.value = 5;`, the `count` variable not only updates its internal number but also sends out a notification that its value has changed.

You can also change the value by calling the `Rx` variable like a function:
```dart
final anotherCount = 10.obs;
anotherCount(15); // Same as anotherCount.value = 15;
print(anotherCount.value); // Output: 15
```
This is just a shorthand. Both ways achieve the same result.

### A Simple Example: The Counter Logic

Let's imagine the logic for a simple counter. We won't build the UI yet, just the data part.

```dart
import 'package:get/get.dart';

// 1. Create a reactive variable for our count
final magicCounter = 0.obs;

void incrementCounter() {
  // 2. Change its value
  magicCounter.value++; // This rings the bell!
  print("Counter is now: ${magicCounter.value}");
}

void main() {
  print("Counter starts at: ${magicCounter.value}");
  incrementCounter(); // Call the function to change the value
  incrementCounter();
}
```
**What happens?**
1.  `magicCounter` is created as an `RxInt` initialized to `0`.
2.  When `incrementCounter()` is called, `magicCounter.value++` increases the stored integer and notifies any listeners.
3.  The `print` statement shows the updated value.

Output:
```
Counter starts at: 0
Counter is now: 1
Counter is now: 2
```
Right now, only our `print` statements are "listening" in a very basic way. In the [next chapter](03_obx___obxwidget_.md), we'll see how to make Flutter UI widgets listen and update automatically!

## Under the Hood: How Does `.obs` Work?

You might wonder what `.obs` actually does. It's a clever use of Dart's "extension methods."

When you write `0.obs`, GetX has an extension on the `int` type that looks something like this (simplified):

```dart
// From: get_rx/src/rx_types/rx_core/rx_impl.dart (simplified concept)
extension IntExtension on int {
  RxInt get obs => RxInt(this); // 'this' refers to the integer itself
}
```
This code basically says: "If you see `.obs` after an integer, create a new `RxInt` object and give it that integer's value." Similar extensions exist for `String`, `bool`, `double`, and even a generic `Rx<T>` for any object via `T.obs`.

The `RxInt`, `RxString`, etc., classes (which generally inherit from `_RxImpl<T>`) are special classes that manage an internal value and have a built-in mechanism to notify listeners.

Here's a simplified step-by-step of what happens when you change an `Rx` variable's value:

```mermaid
sequenceDiagram
    participant YourCode as Your App Code
    participant RxVariable as count (RxInt)
    participant RxImpl as Internal Logic (_RxImpl)
    participant Listeners as Potential UI (e.g., Obx)

    YourCode->>RxVariable: count.value = 1
    Note over RxVariable: This calls the 'set value' logic
    RxVariable->>RxImpl: Pass new value (1)
    RxImpl->>RxImpl: Store new value (1) internally
    RxImpl->>RxImpl: Check: Has value actually changed?
    alt Value Changed
        RxImpl-->>Listeners: Notifies all listeners (rings the bell!)
        Listeners-->>RxVariable: (Later) Asks RxVariable for its new .value
    end
```

1.  **You assign to `.value`**: `count.value = 1;`
2.  **Setter is called**: The `RxInt` class (or its parent `_RxImpl` found in `get_rx/src/rx_types/rx_core/rx_impl.dart`) has a special `set value(newValue)` method.
3.  **Value Check**: This setter first checks if the `newValue` is actually different from the current stored value. If it's the same, it usually does nothing to avoid unnecessary notifications.
4.  **Store New Value**: If the value is different, it updates its internal storage.
5.  **Notify Listeners**: This is the magic part! The class then triggers a notification. Internally, it often uses a `StreamController` (from `dart:async`). When you change `.value`, it essentially adds the new value to its stream using something like `subject.add(newValue)` after updating its internal `_value`.
    ```dart
    // Highly simplified concept from RxObjectMixin in get_rx/src/rx_types/rx_core/rx_impl.dart
    // and GetListenable in get_state_manager/src/rx_flutter/rx_notifier.dart

    // In GetListenable:
    // StreamController<T>? _controller;
    // T _value;
    // void refresh() { _controller?.add(_value); }

    // In RxObjectMixin (which uses GetListenable):
    set value(T val) {
      if (_value == val && !firstRebuild) return; // _value is from GetListenable
      firstRebuild = false;
      super.value = val; // This typically calls GetListenable's setter, which then calls refresh()
                         // `super.value = val;` roughly does:_value = val; refresh();
    }
    ```
    The `super.value = val;` line in `RxObjectMixin`'s setter calls the setter in its parent class (`GetListenable`), which updates the internal `_value` and then calls `refresh()`. The `refresh()` method then typically adds the new value to an internal stream (`_controller?.add(_value);`), effectively "ringing the bell."

Any widget designed to listen to these streams (like `Obx`) will then pick up this notification.

## Different Kinds of Rx Variables

GetX provides several pre-built `Rx` types for convenience:

*   **Primitives:**
    *   `RxInt(initialValue)` or `initialValue.obs` for integers.
    *   `RxDouble(initialValue)` or `initialValue.obs` for doubles.
    *   `RxString(initialValue)` or `initialValue.obs` for strings.
    *   `RxBool(initialValue)` or `initialValue.obs` for booleans.
*   **Collections (these are a bit more advanced as they react to internal changes too):**
    *   `RxList<T>([])` or `[].obs` for lists.
    *   `RxMap<K, V>({})` or `{}.obs` for maps.
    *   `RxSet<T>({})` or `{}.obs` for sets.
*   **Generic `Rx<T>`:**
    *   For any other type, including your custom classes:
        ```dart
        class User {
          String name;
          User(this.name);
        }

        final user = User("Alice").obs; // user is now an Rx<User>
        // or: final user = Rx<User>(User("Alice"));

        print(user.value.name); // Output: Alice
        user.value.name = "Bob";
        user.refresh(); // For complex objects, you might need to call refresh()
                        // or use user.update((val) { val.name = "Bob"; });
                        // to ensure listeners are notified of internal changes.
        print(user.value.name); // Output: Bob
        ```
    For changes *inside* a custom object held by `Rx<T>`, like changing `user.value.name`, GetX might not automatically know the object's internal state changed. In such cases, you can call `user.refresh()` to manually trigger the "bell," or use the `update()` method: `user.update((currentUser) { currentUser.name = "Bob"; });` which handles the refresh for you.

## Conclusion

You've now learned about `Rx<T>` variables  the "magic whiteboards" of GetX! They are special variables, easily created with `.obs`, that automatically notify anyone interested when their `.value` changes. This is the foundation of reactive programming in GetX and is crucial for building UIs that update themselves effortlessly.

These reactive variables are often managed within [GetxController](05_getxcontroller_.md) classes (which we'll cover later), making state management clean and powerful.

In the [next chapter, Chapter 3: Obx / ObxWidget](03_obx___obxwidget_.md), we'll see how to use `Obx` widgets to make your UI actually listen to these `Rx<T>` variables and update automatically when that magic bell rings!
---
# Chapter 3: Obx / ObxWidget

In [Chapter 2: Rx<T> (Reactive Variables)](02_rx_t___reactive_variables__.md), we discovered `Rx<T>` variables, our "magic whiteboards" that can signal when their data changes. That's fantastic for managing data, but how do we make our app's screen (the User Interface or UI) automatically show these changes?

Imagine you have a score in your game, stored in an `RxInt`. When the score increases, you want the score display on the screen to update instantly, without you having to write complex code to manually refresh it. This is where `Obx` comes in!

## Meet `Obx`: The Smart Picture Frame for Your UI

`Obx` (and its underlying base, `ObxWidget`) is a special Flutter widget provided by GetX. Its job is simple but powerful: it "watches" any reactive variables (`Rx<T>`) you use inside it and automatically rebuilds itself to show the new data whenever those variables change.

Remember our "magic whiteboard" (`Rx<T>`) from the last chapter?
Think of `Obx` as a **smart digital picture frame** that's wirelessly connected to that whiteboard.
*   You tell the `Obx` frame which part of the whiteboard to display (e.g., the score).
*   Whenever someone updates the score on the whiteboard (`Rx<T>` variable changes), the `Obx` frame *instantly* gets the new score and displays it.

This means your UI stays perfectly in sync with your app's state, efficiently and with very little code.

## How to Use `Obx`

Using `Obx` is wonderfully straightforward. You wrap the part of your UI that depends on a reactive variable with an `Obx` widget.

Let's build a very simple counter app to see it in action.

### 1. First, We Need a Reactive Variable

As we learned in [Chapter 2: Rx<T> (Reactive Variables)](02_rx_t___reactive_variables__.md), we create a reactive variable using `.obs`. Let's make a counter:

```dart
import 'package:get/get.dart'; // For .obs and Obx

final counter = 0.obs; // Our reactive integer, starting at 0
```
This `counter` is our "magic whiteboard" that will hold the current count.

### 2. Use `Obx` to Display the Reactive Variable

Now, let's use the `Obx` widget to display the value of `counter`. `Obx` takes a builder function. This function should return the widget(s) that depend on your reactive data.

Crucially, you **must** access the `.value` of your `Rx` variable *inside* this builder function for `Obx` to know which variable to watch.

```dart
// Inside your widget's build method:
Obx(() {
  // This Text widget will rebuild whenever 'counter.value' changes
  return Text("Button presses: ${counter.value}");
})
```
Here, `Obx` is our "smart picture frame." The builder function `() { return Text(...); }` tells the frame *what* to display. Because we used `counter.value` inside it, `Obx` knows to watch the `counter` variable.

### 3. Putting It All Together: A Simple Reactive Page

Let's see a complete, minimal example. We'll have a text display for the counter and a button to increment it.

```dart
import 'package:flutter/material.dart';
import 'package:get/get.dart';

// 1. Our reactive variable (could be in a GetxController later)
final counter = 0.obs;

class CounterPage extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(title: Text("Obx Counter Demo")),
      body: Center(
        // 2. Use Obx to wrap the widget that displays reactive data
        child: Obx(() {
          return Text(
            "Count: ${counter.value}", // Access .value here!
            style: TextStyle(fontSize: 28),
          );
        }),
      ),
      floatingActionButton: FloatingActionButton(
        onPressed: () {
          // 3. Change the reactive variable's value
          counter.value++;
        },
        child: Icon(Icons.add),
      ),
    );
  }
}
```

**What happens?**

1.  The page loads, `counter.value` is `0`. The `Obx` widget runs its builder function for the first time, and `Text("Count: 0")` is displayed.
2.  You tap the `+` button.
3.  The `onPressed` callback executes: `counter.value++`.
    *   The value of `counter` changes (e.g., from `0` to `1`).
    *   Because `counter` is an `RxInt` (a "magic whiteboard"), it "rings a bell," notifying its listeners that it has changed.
4.  The `Obx` widget, being a "smart picture frame" listening to `counter`, hears this bell!
5.  `Obx` automatically re-runs its builder function: `() { return Text("Count: ${counter.value}"); }`.
6.  This time, `counter.value` is `1`, so a new `Text("Count: 1")` widget is created and displayed.

The UI updates automatically, just like magic! You didn't have to call `setState()` or manually tell the UI to refresh.

### Important: Only Use Rx Variables *Inside* `Obx`'s Builder

`Obx` is smart, but it's not a mind reader. It only knows to rebuild if a reactive variable *that it has been told to observe* changes. It figures this out by tracking which reactive variables have their `.value` accessed *directly within its builder function*.

```dart
// GOOD: 'name.value' is inside Obx's builder
final name = "User".obs;
Obx(() => Text(name.value))

// BAD: If 'name.value' is not accessed inside, Obx won't react.
// (This would likely throw an ObxError if no other Rx var is accessed)
final name = "User".obs;
String currentName = name.value; // Accessed outside Obx's scope of observation
Obx(() => Text(currentName)) // Obx doesn't know about 'name' here
```

If you use an `Obx` widget and don't access any `.value` of an `Rx` variable inside its builder, GetX will usually show you an `ObxError` in the console, reminding you that `Obx` isn't observing anything.

```
[Get] the improper use of a GetX has been detected.
You should only use GetX or Obx for the specific widget that will be updated.
If you are seeing this error, you probably did not insert any observable variables into GetX/Obx...
```
This error message comes from the `ObxError` class defined in `get_state_manager/src/simple/list_notifier.dart`.

## Under the Hood: How Does `Obx` Work Its Magic?

It might seem like magic, but it's clever programming. Here's a simplified idea:

1.  **Subscription:** When an `Obx` widget is built for the first time, it prepares to listen. As its builder function executes, any `RxVariable.value` you access signals back to the `Obx` (via an internal `Notifier` system) saying, "Hey, Obx, I'm being read here! Please listen to me for changes." The `Obx` widget then subscribes to that `RxVariable`.
2.  **Value Change:** You change an `RxVariable` (e.g., `counter.value++`).
3.  **Notification:** The `RxVariable` "rings its bell" and notifies all its subscribers (including our `Obx` widget) that its value has changed.
4.  **Rebuild:** The `Obx` widget, upon receiving this notification, knows it needs to update. It schedules a rebuild, which simply means it calls its builder function again. Because the builder function now gets the new value from the `RxVariable`, the UI updates.

Here's a visual representation:

```mermaid
sequenceDiagram
    participant UserAction as User Taps Button
    participant RxVariable as counter (RxInt)
    participant ObxWidget as Obx Widget
    participant FlutterEngine as Flutter Engine

    Note over ObxWidget, RxVariable: Initial build: Obx reads counter.value, subscribes to counter.
    UserAction->>RxVariable: counter.value++
    RxVariable->>RxVariable: Internal value updates
    RxVariable-->>ObxWidget: Notifies Obx about the change
    ObxWidget->>ObxWidget: Schedules its builder to re-run
    ObxWidget->>RxVariable: Reads new counter.value (e.g., 1)
    ObxWidget-->>FlutterEngine: Provides new UI (e.g., Text("Count: 1"))
    FlutterEngine-->>UserAction: UI Updates on Screen
```

Let's peek at some (simplified) relevant code snippets:

`Obx` itself is quite simple. It extends `ObxWidget` (which extends `ObxStatelessWidget`).
```dart
// From: get_state_manager/src/rx_flutter/rx_obx_widget.dart
class Obx extends ObxWidget {
  final WidgetCallback builder; // Your () => Widget function
  const Obx(this.builder, {super.key});

  @override
  Widget build(BuildContext context) {
    return builder(); // It just calls your function!
  }
}
```
The real magic happens in `ObxStatelessWidget` and its `ObxElement`, which uses a mixin called `StatelessObserverComponent` (from `get_state_manager/src/simple/simple_builder.dart`).

```dart
// From: get_state_manager/src/simple/simple_builder.dart (simplified)
mixin StatelessObserverComponent on StatelessElement {
  List<Disposer>? disposers = <Disposer>[]; // To store cleanup functions

  void getUpdate() {
    // If I'm told to update, I tell Flutter to rebuild me!
    scheduleMicrotask(markNeedsBuild);
  }

  @override
  Widget build() {
    // Before calling the user's Obx builder (super.build),
    // set up the Notifier to catch Rx reads.
    return Notifier.instance.append(
        NotifyData(disposers: disposers!, updater: getUpdate),
        super.build // This eventually calls your Obx(() => Text(...))
    );
  }

  @override
  void unmount() { // When Obx is removed from the screen
    super.unmount();
    for (final disposer in disposers!) {
      disposer(); // Clean up subscriptions
    }
    disposers!.clear();
    disposers = null;
  }
}
```
When `yourRxVariable.value` is accessed *inside* the `Obx` builder (during `super.build` call above):
1.  The `Rx` variable's getter calls `reportRead()`. This method is mixed into `Rx` types from `ListNotifierSingleMixin` (in `get_state_manager/src/simple/list_notifier.dart`).
    ```dart
    // From: get_rx/src/rx_types/rx_core/rx_impl.dart (RxObjectMixin's value getter)
    // Simplified concept of what Rx's .value getter does
    T get value {
      reportRead(); // "I'm being read!"
      return _internalValue;
    }
    ```
2.  `reportRead()` calls `Notifier.instance.read(this)` (`this` refers to the `Rx` variable itself).
    ```dart
    // From: get_state_manager/src/simple/list_notifier.dart
    // (Inside ListNotifierSingleMixin)
    @protected
    void reportRead() {
      Notifier.instance.read(this);
    }
    ```
3.  `Notifier.instance.read()` checks the `_notifyData` that `StatelessObserverComponent.build()` set up. It finds the `getUpdate` method of our `Obx` widget and subscribes it to the `Rx` variable.
    ```dart
    // From: get_state_manager/src/simple/list_notifier.dart (Notifier class)
    void read(ListNotifierSingleMixin rxVariable) {
      final getStateUpdateFn = _notifyData?.updater; // This is Obx's getUpdate()
       // If Obx's getUpdate is available and not already listening to this rxVariable:
      if (getStateUpdateFn != null && !rxVariable.containsListener(getStateUpdateFn)) {
        // Tell rxVariable: "When you change, call Obx's getUpdate()"
        Disposer disposer = rxVariable.addListener(getStateUpdateFn);
        // And remember how to unsubscribe later
        _notifyData?.disposers.add(disposer);
      }
    }
    ```
So, when `RxVariable.value` changes later, it calls `refresh()` (from `ListNotifierSingleMixin`), which notifies its listeners. One of these listeners is the `Obx` widget's `getUpdate` method, causing the `Obx` widget to rebuild!

## What is `ObxWidget` then?

You'll mostly use `Obx`. `ObxWidget` is simply the base class that `Obx` (and `ObxValue`, another similar widget) extends. It provides the common reactive machinery. Advanced users could extend `ObxWidget` to create their own custom reactive widgets, but for most day-to-day tasks, `Obx` is all you need.

## Conclusion

You've now unlocked a cornerstone of GetX's reactivity: the `Obx` widget! It's your "smart picture frame" that automatically updates your UI when the underlying `Rx<T>` reactive variables change. This makes building dynamic and responsive UIs incredibly simple and efficient.

Typically, your `Rx<T>` variables will live inside a [GetxController](05_getxcontroller_.md) (which we'll cover soon) to keep your UI logic neatly organized. `Obx` then becomes the bridge that connects your controller's state to your visual widgets.

But what if you want to react to changes in `Rx<T>` variables *without* updating the UI? For example, maybe you want to log a message or make an API call when a value changes. For that, GetX provides something called "Workers." Let's explore those in the [next chapter, Chapter 4: Workers](04_workers_.md).
---
# Chapter 4: Workers

In [Chapter 3: Obx / ObxWidget](03_obx___obxwidget_.md), we saw how `Obx` acts like a smart picture frame, automatically updating our UI when reactive variables change. That's perfect for what users see! But what if we want to perform actions *behind the scenes* when our data changes? For instance, what if we need to fetch new data from the internet when a user's ID changes, or automatically save their input after they've stopped typing for a moment? This is where GetX Workers come in!

## What Problem Do Workers Solve?

Imagine you have a reactive variable, say, `userId.obs`. When this `userId` changes, you might want to:
*   Log the change for debugging.
*   Fetch the new user's profile from a server.
*   Update some other non-UI related data.

You don't want to put this logic directly in your UI-building code because it's not about drawing pixels on the screen. It's about reacting to data changes with *side effects*.

**Workers** are your dedicated helpers for exactly this. They are functions that "listen" to your [Rx<T> (Reactive Variables)](02_rx_t___reactive_variables__.md) and execute a callback function when specific events or conditions occur on those variables. Think of them as automated sentinels, tirelessly watching your reactive data streams. When a predefined rule is met (like "the data changed!" or "the user stopped typing!"), they spring into action, independent of direct UI rendering.

## Meet the Workers: Your Automated Sentinels

GetX provides a few different types of Workers, each designed for a specific kind of listening task. Let's meet the main ones: `ever`, `once`, `debounce`, and `interval`.

All these workers are typically set up within the `onInit()` method of a [GetxController](05_getxcontroller_.md) (which we'll cover in the next chapter), or anywhere you have access to your reactive variables and need to react to their changes.

### 1. `ever`: The Ever-Watchful Sentinel

The `ever` worker executes its callback function **every time** the reactive variable it's watching changes.

Let's say we have a reactive variable for a username:
```dart
import 'package:get/get.dart';

final username = 'Guest'.obs; // Our reactive username
```
Now, let's set up an `ever` worker to print a message whenever `username` changes:
```dart
// Typically, you'd do this in onInit() of a GetxController
ever(username, (String newName) {
  print("Username changed to: $newName");
});

// Let's simulate some changes:
username.value = 'Alice';
username.value = 'Bob';
```
**What happens?**
Every time `username.value` is assigned a new value, the `ever` worker's callback `(String newName) { ... }` is triggered.
Output:
```
Username changed to: Alice
Username changed to: Bob
```

You can also add a `condition` to `ever`. The callback will only run if the condition is true when the main variable changes.
```dart
final count = 0.obs;

ever(count, (int newCount) {
  print("Count is now $newCount (and it's greater than 2!)");
}, condition: () => count.value > 2); // Only run if count > 2

count.value = 1; // No output
count.value = 3; // Output: Count is now 3 (and it's greater than 2!)
count.value = 4; // Output: Count is now 4 (and it's greater than 2!)
```

### 2. `once`: The One-Time Sentinel

The `once` worker executes its callback function **only the first time** a specific condition (related to the reactive variable) is met. After it runs once, it automatically stops listening.

Imagine you want to show a welcome message only the very first time a user logs in (i.e., `isLoggedIn.value` becomes `true`).
```dart
final isLoggedIn = false.obs;

once(isLoggedIn, (bool loggedInStatus) {
  if (loggedInStatus == true) {
    print("Welcome! You've logged in for the first time (during this session).");
  }
}, condition: () => isLoggedIn.value == true); // Condition to trigger

isLoggedIn.value = true;  // Triggers 'once'
isLoggedIn.value = false; // 'once' won't trigger again
isLoggedIn.value = true;  // 'once' won't trigger again
```
**What happens?**
The callback is executed only when `isLoggedIn.value` changes *and* the condition `isLoggedIn.value == true` is met for the *first time*.
Output:
```
Welcome! You've logged in for the first time (during this session).
```
Even if `isLoggedIn` becomes `true` again later, `once` has done its job and won't fire again.

### 3. `debounce`: The "Wait-and-See" Sentinel

The `debounce` worker is super useful for scenarios like search fields. It waits for a certain period of inactivity before executing the callback. If the variable changes again before the waiting period is over, the timer resets.

Imagine a search bar. You don't want to make an API call for every single letter the user types. Instead, you want to wait until they pause typing.
```dart
final searchQuery = ''.obs;

debounce(searchQuery, (String query) {
  print("User stopped typing. Search for: $query");
  // In a real app, you'd make an API call here: fetchResults(query);
}, time: Duration(milliseconds: 500)); // Wait for 500ms of inactivity

// Simulate typing quickly, then pausing
searchQuery.value = 'h';
searchQuery.value = 'he';
searchQuery.value = 'hel'; // Timer resets each time
// User pauses... after 500ms:
// Output: User stopped typing. Search for: hel
```
**What happens?**
*   User types 'h', then 'e', then 'l' quickly. The `debounce` timer keeps resetting.
*   After 'hel', if the user pauses for 500 milliseconds, the callback `(String query) { ... }` is executed with the latest value ('hel').
*   If they type 'lo' next, the same process repeats.

### 4. `interval`: The "Periodic Check-up" Sentinel

The `interval` worker is a bit like `debounce` but it triggers its callback with the value that the reactive variable had at the *beginning* of the interval, after a specified duration has passed, and *only if* no new changes occurred during that interval (this behavior can be subtle, often `debounce` is what people want for "after a delay"). It's more like "if nothing changes for X time, then act on the value from X time ago".

A more common use of a timed worker might be "check something every X seconds while a condition is true." `interval` is designed to trigger *after* a period of stability. If you rapidly change the value, `interval` might not fire for each change because a new event interrupts the "quiet period" it's waiting for.

Let's consider a scenario where you want to perform an action if a value remains stable for a certain period.
```dart
final status = 'idle'.obs;

interval(status, (String currentStatus) {
  print("Status has been '$currentStatus' for 1 second.");
}, time: Duration(seconds: 1));

status.value = 'processing'; // Worker starts listening
// If 'status' remains 'processing' for 1 second:
// Output: Status has been 'processing' for 1 second.

// If you change it quickly:
// status.value = 'A';
// await Future.delayed(Duration(milliseconds: 200));
// status.value = 'B'; // 'A' might not trigger the interval callback
```
**What happens?**
If `status.value` becomes 'processing' and stays 'processing' for 1 second without any other changes to `status`, the callback will fire. If `status` changes again *within* that 1-second window, the timer for the *previous* value is essentially reset/ignored, and a new interval evaluation potentially begins for the new value. `debounce` is often more intuitive for "do something after a pause."

For `interval`, the primary mechanism is: when an event arrives, it waits for `time`. If another event arrives *before* `time` is up, the first event is effectively ignored by that specific `interval`'s timer. When `time` *does* elapse without a new event, the callback is fired with the value that was present when the `time` period began.


## Disposing of Workers

Workers, like `StreamSubscription`s in Dart, need to be disposed of when they are no longer needed. This is crucial to prevent memory leaks and unwanted behavior, especially if the reactive variable they are listening to outlives the context where the worker was created.

When you create a worker, it returns a `Worker` object. This object has a `dispose()` method:
```dart
final count = 0.obs;
late Worker everWorker; // Declare the worker variable

// In onInit() or similar setup:
everWorker = ever(count, (_) => print('Count changed!'));

// ... later, when this logic is no longer needed (e.g., in onClose() of a GetxController):
void cleanup() {
  everWorker.dispose();
  print("Ever worker disposed.");
}

count.value = 1; // Output: Count changed!
cleanup();
count.value = 2; // No output, because the worker is disposed.
```

It's a common pattern to initialize workers in the `onInit()` method of a [GetxController](05_getxcontroller_.md) and dispose of them in its `onClose()` method. GetX also provides a way to automatically manage this if workers are declared inside a controller, but manual disposal is good practice to understand.

## Under the Hood: How Do Workers... Work?

Workers function by subscribing to the underlying stream of an [Rx<T> (Reactive Variables)](02_rx_t___reactive_variables__.md). Remember from Chapter 2 that `Rx` variables can notify listeners when they change? Workers are specialized listeners.

1.  **Subscription:** When you create a worker (e.g., `ever(myRxVar, callback)`), the worker function internally calls `myRxVar.listen(...)`. This is similar to listening to a Dart `Stream`.
2.  **Event Emission:** When `myRxVar.value` changes, `myRxVar` emits this new value to its listeners.
3.  **Worker Logic:** The worker receives this new value.
    *   For `ever`, it typically checks an optional condition and then calls your callback.
    *   For `once`, it does the same but also cancels its own subscription after the first valid trigger.
    *   For `debounce`, it uses a timer (like the `Debouncer` utility class in GetX). Each new event resets the timer. If the timer completes, the callback is called with the *last* event received.
    *   For `interval`, it also uses a timer. When an event arrives, it starts a timer. If the timer completes *without* a new event arriving, it calls the callback with the event that started that timer.
4.  **Callback Execution:** If the worker's specific logic decides it's time, your provided callback function is executed with the relevant value.

Heres a simplified sequence diagram showing a `debounce` worker in action:

```mermaid
sequenceDiagram
    participant UserAction as User Typing
    participant SearchRx as searchQuery.obs
    participant DebounceWorker as Debounce Logic
    participant YourCallback as (query) => API.search(query)

    UserAction->>SearchRx: searchQuery.value = "flut"
    SearchRx-->>DebounceWorker: Notifies with "flut"
    DebounceWorker->>DebounceWorker: Starts/Resets 500ms timer
    UserAction->>SearchRx: searchQuery.value = "flutter"
    SearchRx-->>DebounceWorker: Notifies with "flutter"
    DebounceWorker->>DebounceWorker: Resets 500ms timer (for "flutter")
    Note over DebounceWorker: User pauses typing...
    DebounceWorker-->>YourCallback: After 500ms, calls YourCallback("flutter")
```

The actual implementation can be found in `get_rx/src/rx_workers/rx_workers.dart`.
For example, the `ever` worker (simplified):
```dart
// From: get_rx/src/rx_workers/rx_workers.dart (conceptual)
Worker ever<T>(
  GetListenable<T> listener, // This is your Rx variable
  WorkerCallback<T> callback, {
  dynamic condition = true, // Optional condition
  /* ... other params ... */
}) {
  // 1. Listen to the Rx variable's stream
  StreamSubscription sub = listener.listen(
    (event) { // 'event' is the new value from the Rx variable
      // 2. Check the condition
      if (_conditional(condition)) { // _conditional is a helper
        // 3. Execute your callback
        callback(event);
      }
    },
    /* ... onError, onDone ... */
  );
  // 4. Return a Worker object that can be used to cancel the subscription
  return Worker(sub.cancel, '[ever]');
}
```
The `_conditional` function (also in `rx_workers.dart`) is a utility that evaluates the `condition` argument, which can be a `bool` or a `bool Function()`.

The `debounce` worker uses a `Debouncer` utility class (found in `get_rx/src/rx_workers/utils/debouncer.dart`):
```dart
// From: get_rx/src/rx_workers/rx_workers.dart (conceptual)
Worker debounce<T>(
  GetListenable<T> listener,
  WorkerCallback<T> callback, {
  Duration? time, /* ... */
}) {
  // 1. Create a Debouncer instance
  final newDebouncer = Debouncer(delay: time ?? Duration(milliseconds: 800));
  StreamSubscription sub = listener.listen(
    (event) {
      // 2. When Rx variable changes, call the debouncer
      newDebouncer(() {
        // 3. Debouncer will execute this only after the 'delay'
        callback(event);
      });
    }, /* ... */
  );
  return Worker(sub.cancel, '[debounce]');
}
```
The `Debouncer` class itself manages a `Timer` to achieve the "wait for inactivity" behavior.

## Conclusion

Workers (`ever`, `once`,  `debounce`, `interval`) are powerful tools in GetX for reacting to changes in your [Rx<T> (Reactive Variables)](02_rx_t___reactive_variables__.md) by performing side effects like API calls, logging, or triggering other logic that isn't directly tied to UI updates. They help you keep your code clean by separating these concerns. Remember to always `dispose()` your workers when they're no longer needed to keep your app running smoothly.

Now that we've seen how to create reactive data (`Rx<T>`), how to make our UI react to it (`Obx`), and how to perform side effects based on it (Workers), it's time to look at how to organize all this reactive goodness. In the [next chapter, Chapter 5: GetxController](05_getxcontroller_.md), we'll explore `GetxController`, the recommended way to encapsulate your business logic and reactive state.
---
# Chapter 5: GetxController

In [Chapter 4: Workers](04_workers_.md), we learned how to perform actions behind the scenes when_our_reactive data changes. That's great for side effects! But as your app grows, you'll find yourself asking:
*   Where should I keep my app's data (like that `counter.obs` or `searchQuery.obs`)?
*   Where should the functions that change this data (like `incrementCounter()` or `performSearch()`) live?
*   How can I neatly organize all this for a specific feature or screen?

Simply putting reactive variables and functions globally or directly in UI widgets can get messy quickly. We need a dedicated "manager" for different parts of our application. That's where `GetxController` shines!

## What is a GetxController? The Brain of Your Feature!

A `GetxController` is like the **manager** or **"brain"** for a specific part of your app's screen or a particular feature. Think of it as a dedicated organizer. Its main jobs are:

1.  **Holding Data (State):** It stores the variables (often [Rx<T> (Reactive Variables)](02_rx_t___reactive_variables__.md)) that your feature needs. For example, in a counter feature, it would hold the current count.
2.  **Holding Business Logic (Functions):** It contains the functions that operate on this data or perform actions related to the feature. For the counter, this would be the `increment()` function.
3.  **Managing Lifecycle:** It has special methods that get called at different points in its life (like when it's created or destroyed), allowing you to set things up or clean up resources.
4.  **Notifying UI (with `update()`):** When its data changes (especially non-reactive data, or if you need more control), the controller can tell the UI to update by calling its `update()` method. This is primarily used with a widget called `GetBuilder`, which we'll explore in [Chapter 7: GetBuilder](07_getbuilder_.md).

Imagine a scene in a play. The `GetxController` is like the **director** of that scene. It knows the script (logic), manages the actors' states (data), and tells them when and how to change their appearance or behavior.

## How to Use a GetxController

Let's go back to our simple counter example and see how we can organize it using a `GetxController`.

### 1. Creating Your Controller

First, you create a new Dart class that `extends GetxController`.

```dart
// counter_controller.dart
import 'package:get/get.dart';

class CounterController extends GetxController {
  // 1. Hold your reactive data (state)
  final count = 0.obs; // Our familiar RxInt

  // 2. Define your business logic (functions)
  void increment() {
    count.value++;
    // If we were using GetBuilder and non-Rx state, we might call update() here.
  }
}
```
**Explanation:**
*   We created `CounterController` that inherits from `GetxController`.
*   Inside it, we moved our reactive `count` variable.
*   We also moved the `increment` logic into a method within the controller. Now, all things related to the counter's state and logic are neatly bundled together!

### 2. Making the Controller Available (Quick Peek at Dependency Injection)

Before your UI can use the controller, GetX needs to know about it. You "register" your controller, usually when the feature or screen is first needed. The most common way is using `Get.put()`:

```dart
// Somewhere before you need the controller, e.g., when navigating to the page
Get.put(CounterController());
```
**Explanation:**
*   `Get.put(CounterController());` creates an instance of `CounterController` and makes it available for other parts of your app to find.
*   We'll dive deep into `Get.put()` and other ways to manage controllers in [Chapter 6: Dependency Access (Binder, Bind.of, Get.find/put)](06_dependency_access__binder__bind_of__get_find_put__.md). For now, just know this step is necessary.

### 3. Accessing and Using the Controller in Your UI

Once the controller is "put", your UI widgets can find and use it. You use `Get.find()` for this:

```dart
// In your widget file (e.g., counter_page.dart)
import 'package:flutter/material.dart';
import 'package:get/get.dart';
import 'counter_controller.dart'; // Import your controller fine

class CounterPage extends StatelessWidget {
  // Find the instance of CounterController that GetX is managing
  final CounterController controller = Get.find<CounterController>();

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(title: Text("GetxController Counter")),
      body: Center(
        child: Obx(() { // Obx watches reactive variables
          return Text(
            "Count: ${controller.count.value}", // Use controller's data
            style: TextStyle(fontSize: 28),
          );
        }),
      ),
      floatingActionButton: FloatingActionButton(
        onPressed: () {
          controller.increment(); // Call controller's method
        },
        child: Icon(Icons.add),
      ),
    );
  }
}
```
**Explanation:**
*   `final CounterController controller = Get.find<CounterController>();` asks GetX to give us the instance of `CounterController` it's managing.
*   Inside the `Obx` widget (from [Chapter 3: Obx / ObxWidget](03_obx___obxwidget_.md)), we access `controller.count.value` to display the reactive count.
*   In `onPressed` for the button, we call `controller.increment()` to execute the logic defined in our controller.

Now, run this app. It works just like our previous counter, but the state and logic are much better organized within `CounterController`!

### Controller Lifecycle: `onInit()`, `onReady()`, `onClose()`

`GetxController`s have a lifecycle, meaning special methods are called automatically at certain points:

*   **`onInit()`:** Called right after the controller is allocated in memory (after its constructor) but *before* the widget that uses it is built for the first time. This is the perfect place to:
    *   Initialize data.
    *   Set up [Workers](04_workers_.md) to listen to reactive variable changes.
    *   Make initial API calls.

    ```dart
    class MyController extends GetxController {
      var data = ''.obs;

      @override
      void onInit() {
        super.onInit(); // Always call super.onInit()
        print("MyController onInit!");
        // Example: Fetch initial data or set up a worker
        ever(data, (_) => print("Data changed in MyController: ${data.value}"));
        data.value = "Initial Data";
      }
    }
    ```
    Output (when `MyController` is `put`):
    ```
    MyController onInit!
    Data changed in MyController: Initial Data
    ```

*   **`onReady()`:** Called a moment *after* the widget associated with this controller is rendered on screen for the first time. Useful if you need to do something *after* the UI is visible (e.g., show an intro animation or dialog).

    ```dart
    class MyController extends GetxController {
      @override
      void onReady() {
        super.onReady(); // Always call super.onReady()
        print("MyController onReady! UI is now visible.");
        // Get.snackbar("Hint", "Controller is ready and UI is built!");
      }
    }
    ```

*   **`onClose()`:** Called just before the controller is removed from memory. This happens when it's no longer needed (e.g., the screen is closed, or `Get.delete<MyController>()` is called). This is crucial for:
    *   Cleaning up resources.
    *   Disposing of [Workers](04_workers_.md).
    *   Canceling stream subscriptions or closing database connections to prevent memory leaks.

    ```dart
    class MyController extends GetxController {
      late Worker _dataWorker;
      var data = ''.obs;

      @override
      void onInit() {
        super.onInit();
        _dataWorker = ever(data, (_) => print("Data: ${data.value}"));
      }

      @override
      void onClose() {
        print("MyController onClose! Cleaning up.");
        _dataWorker.dispose(); // IMPORTANT: Dispose workers!
        super.onClose(); // Always call super.onClose()
      }
    }
    ```
    **Explanation:** If you create workers, timers, or other listeners in `onInit()`, you *must* clean them up in `onClose()` to avoid problems.

### The `update()` Method: For Manual UI Refreshes

So far, our counter UI updates automatically because `count` is an `RxInt` and we're using `Obx`. `Obx` rebuilds when `count.value` changes.

However, sometimes you might have:
*   Regular Dart variables (not `.obs`) in your controller.
*   Complex logic where you want to decide *exactly* when to tell the UI to refresh.

For these "manual" updates, `GetxController` provides the `update()` method. When you call `update()` from within your controller, it signals to any `GetBuilder` widgets listening to this controller that they should rebuild.

```dart
class ManualUpdateController extends GetxController {
  int manualCount = 0; // A regular int, not reactive

  void incrementManualCount() {
    manualCount++;
    update(); // Tell listening GetBuilders to refresh!
    print("Manual count incremented: $manualCount. Update called.");
  }
}
```
**Explanation:**
*   `manualCount` is just a normal integer.
*   When `incrementManualCount()` is called, it changes `manualCount` and then calls `update()`.
*   This `update()` call will trigger any `GetBuilder` associated with this `ManualUpdateController` to rebuild itself and display the new `manualCount`.

We'll learn all about `GetBuilder` in [Chapter 7: GetBuilder](07_getbuilder_.md). For now, understand that `update()` is the controller's way of manually triggering UI refreshes for widgets that use `GetBuilder`.

## Under the Hood: What Makes a GetxController Tick?

A `GetxController` isn't just an empty class. It gets its powers from a few key pieces in the GetX framework:

*   It `extends ListNotifier` (from `get_state_manager/src/simple/list_notifier.dart`).
*   `ListNotifier` mixes in `GetLifeCycleMixin` (from `get_state_manager/src/rx_flutter/rx_notifier.dart` indirectly through its own mixins or base classes).

Let's see what these provide:

1.  **`GetLifeCycleMixin`:** This mixin is responsible for the lifecycle methods (`onInit`, `onReady`, `onClose`). When a controller is `put` using `Get.put()`, GetX's dependency management system knows it's a `GetLifeCycleMixin` and hooks into its lifecycle, calling these methods at the appropriate times. It also handles cleaning up the controller (calling `onClose`) when it's deleted (e.g., with `Get.delete()`).

2.  **`ListNotifier` (and its `ListNotifierSingleMixin`):** This is the heart of the manual `update()` mechanism.
    *   It maintains a list of listeners (callbacks).
    *   When you call `update()` in your controller, it actually calls `refresh()` (a method from `ListNotifierSingleMixin`).
    *   `refresh()` then iterates through all its registered listeners and calls them.
    *   Widgets like `GetBuilder` (which we'll see in [Chapter 7: GetBuilder](07_getbuilder_.md)) add themselves as listeners to the controller. So, when `refresh()` is called, the `GetBuilder`'s "update me" function gets executed, causing it to rebuild.

Here's a simplified conceptual flow for the `update()` mechanism:

```mermaid
sequenceDiagram
    participant UserAction as User Taps Button
    participant YourController as MyController
    participant ListNotifierMixin as (Part of MyController)
    participant GetBuilderWidget as GetBuilder (UI Widget)

    UserAction->>YourController: Calls controller.someMethod()
    YourController->>YourController: Logic updates non-Rx state (e.g., `manualCount++`)
    YourController->>ListNotifierMixin: Calls this.update()
    Note over ListNotifierMixin: update() internally calls refresh()
    ListNotifierMixin-->>GetBuilderWidget: Notifies its listener (the GetBuilder's update function)
    GetBuilderWidget->>GetBuilderWidget: Rebuilds itself to show new state
```

The actual code in `GetxController` for `update()` is quite simple:
```dart
// From: get_state_manager/src/simple/get_controllers.dart
abstract class GetxController extends ListNotifier with GetLifeCycleMixin {
  void update([List<Object>? ids, bool condition = true]) {
    if (!condition) {
      return;
    }
    if (ids == null) {
      refresh(); // From ListNotifierSingleMixin
    } else {
      for (final id in ids) {
        refreshGroup(id); // Also from ListNotifier, for targeted updates
      }
    }
  }
}
```
And `refresh()` in `ListNotifierSingleMixin` (simplified):
```dart
// From: get_state_manager/src/simple/list_notifier.dart
mixin ListNotifierSingleMixin on Listenable {
  List<GetStateUpdate>? _updaters = <GetStateUpdate>[]; // List of listeners

  // ... other methods ...

  @protected
  void refresh() {
    // Take a copy of listeners, in case list changes during iteration
    final list = _updaters?.toList() ?? [];
    for (var element in list) {
      element(); // Call each listener (e.g., GetBuilder's update function)
    }
  }
}
```
So, `GetxController` elegantly combines lifecycle management with a notification system to manage state and communicate changes to the UI.

## Conclusion

You've now met `GetxController`, the cornerstone for organizing your application's state and logic in GetX! It acts as a dedicated manager for your features or screen sections, holding data (often reactive), business logic, and providing lifecycle hooks (`onInit`, `onClose`) for setup and cleanup. You also learned about its `update()` method, which is essential for manually refreshing UI parts when using `GetBuilder`.

By using `GetxController`, you can create cleaner, more maintainable, and better-structured Flutter applications.

We've seen how to *create* controllers and *make them available* with a quick `Get.put()`. But how exactly does GetX manage these controllers? How many ways are there to "put" and "find" them? That's what we'll explore next in [Chapter 6: Dependency Access (Binder, Bind.of, Get.find/put)](06_dependency_access__binder__bind_of__get_find_put__.md).
---
# Chapter 6: Dependency Access (Binder, Bind.of, Get.find/put)

In [Chapter 5: GetxController](05_getxcontroller_.md), we learned how to organize our app's "brains"its data and logicinto `GetxController` classes. Now, once we have these controllers (our dependencies), how do we make them available to the parts of our app (usually widgets) that need them? How does a widget get a "wire" to its controller?

GetX provides a flexible system for this, acting like a combination of a central warehouse and local delivery services for your app's dependencies. Let's explore the main ways: `Get.put()`, `Get.find()`, `Binder`, and `Bind.of(context)`.

## What Problem Are We Solving?

Imagine you have a `UserProfileController` that manages user data.
```dart
// A simple controller (more details in Chapter 5)
class UserProfileController extends GetxController {
  final userName = 'Guest'.obs;
  void login(String name) {
    userName.value = name;
  }
}
```
Several different widgets in your app might need to display the `userName` or call the `login` method:
*   A `ProfileHeaderWidget` in the app bar.
*   A `SettingsScreenWidget` deep in the navigation stack.

How do these widgets get access to the *same instance* of `UserProfileController` without manually passing it down through many widget constructors (which is called "prop drilling" and can be messy)? This is where GetX's dependency access tools come in.

## 1. The Global Warehouse: `Get.put()` and `Get.find()`

Think of `Get.put()` and `Get.find()` as your app's central, global warehouse for important items (your controllers or other services).

### `Get.put()`: Storing Your Dependency

`Get.put(SomeClass())` is like taking an instance of `SomeClass` and placing it into a secure, well-organized global storage area managed by GetX. Once "put," this instance is generally available throughout your app. You usually do this when your app starts, or when a feature that needs the controller is first initialized.

```dart
// main.dart or an initialization file
void main() {
  // Put an instance of UserProfileController into GetX's global storage
  Get.put(UserProfileController());
  runApp(MyApp());
}
```
**What happens?**
An instance of `UserProfileController` is created and registered with GetX. By default, `Get.put()` creates a **singleton**, meaning there will only be one instance of `UserProfileController` managed by this global `put`.

### `Get.find()`: Retrieving Your Dependency

`Get.find<SomeClass>()` is like going to the warehouse and asking for the instance of `SomeClass` you stored earlier. GetX will locate it and give it to you.

Any widget, anywhere in your app (after the `Get.put()` has happened), can then get access to that controller:

```dart
// profile_header_widget.dart
class ProfileHeaderWidget extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    // Find the globally available UserProfileController
    final userController = Get.find<UserProfileController>();

    return Obx(() => Text("User: ${userController.userName.value}"));
  }
}

// settings_screen_widget.dart
class SettingsScreenWidget extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    // Find the same globally available UserProfileController
    final userController = Get.find<UserProfileController>();

    return ElevatedButton(
      onPressed: () => userController.login("Alice"),
      child: Text("Login as Alice"),
    );
  }
}
```
**What happens?**
Both `ProfileHeaderWidget` and `SettingsScreenWidget` will receive the *exact same instance* of `UserProfileController` that was registered with `Get.put()`. Changes made through one widget (like logging in) will be reflected in the other (the username display updates).

**When to use `Get.put()`/`Get.find()`?**
This global approach is great for dependencies that:
*   Need to be singletons (only one instance throughout the app).
*   Need to be easily accessible from many disparate parts of your application without complex wiring.

### Under the Hood: `Get.put()` and `Get.find()`

As we touched upon in [Chapter 1: Get (Global Access Facade)](01_get__global_access_facade__.md), GetX maintains an internal "Instance Manager" (conceptually, a map where keys are often types and values are the instances).

```mermaid
sequenceDiagram
    participant YourApp as Your App Startup
    participant GetPut as Get.put(UserProfileController())
    participant InstanceManager as GetX Instance Manager
    participant WidgetA as ProfileHeaderWidget
    participant GetFind as Get.find<UserProfileController>()

    YourApp->>GetPut: Calls Get.put(new UserProfileController())
    GetPut->>InstanceManager: Stores UserProfileController instance (e.g., by Type)
    Note over InstanceManager: UserProfileController now in global storage

    WidgetA->>GetFind: Calls Get.find<UserProfileController>()
    GetFind->>InstanceManager: Looks up UserProfileController by Type
    InstanceManager-->>GetFind: Returns stored instance
    GetFind-->>WidgetA: Provides instance to WidgetA
```

1.  **`Get.put(MyController())`**: When you call this, `Get` (via its `GetInstance` powers, mostly in `get_instance/src/get_instance.dart`) takes the `MyController` instance and stores it in a central collection (like a `Map<String, InstanceInternal>`). It often uses the Type of the controller (e.g., "MyController") and an optional "tag" to create a unique key for storage.
2.  **`Get.find<MyController>()`**: This method also uses `GetInstance` to look up the key (Type or Type+tag) in that central collection. If found, it returns the stored instance. If not found, it will throw an error.

This simple yet powerful mechanism is what allows `Get.find()` to retrieve dependencies from anywhere.

## 2. Local Delivery Service: `Binder` and `Bind.of(context)`

Sometimes, a global singleton isn't what you need.
*   What if a specific section of your app requires its *own*, independent instance of a controller?
*   What if you want to provide a dependency only to a specific widget and its children, without polluting the global scope?

This is where `Binder` and `Bind.of(context)` come in, acting like a "local delivery service" for your dependencies. `Binder` is a special widget from GetX (an `InheritedWidget` under the hood) that makes an instance of a controller available to all its descendant widgets in the tree.

### `Binder`: Providing a Dependency Locally

You wrap a part of your widget tree with `Binder` and tell it how to create or find the dependency it should provide.

Let's say you have a `ProductDetailController` that should only exist for a specific `ProductDetailScreen`.

```dart
// product_detail_controller.dart
class ProductDetailController extends GetxController {
  final productId;
  ProductDetailController(this.productId);

  void loadProductDetails() {
    print("Loading details for product ID: $productId");
    // ... fetch details ...
  }
  // ... other product specific logic ...
}

// product_detail_screen.dart
class ProductDetailScreen extends StatelessWidget {
  final String productId;
  ProductDetailScreen({required this.productId});

  @override
  Widget build(BuildContext context) {
    // Binder provides ProductDetailController to its children
    return Binder<ProductDetailController>(
      // 'init' creates the controller when Binder is built
      init: () => ProductDetailController(productId),
      // 'autoRemove: true' (default) means controller is disposed when screen is removed
      child: Scaffold(
        appBar: AppBar(title: Text("Product $productId")),
        body: ProductInfoDisplay(), // A child widget
      ),
    );
  }
}
```
**What happens?**
*   When `ProductDetailScreen` is built, the `Binder` widget is created.
*   The `init: () => ProductDetailController(productId)` function is called, creating a *new* instance of `ProductDetailController` specifically for this screen.
*   This instance is now available to `ProductInfoDisplay` and any other widgets inside this `Binder`'s `child` subtree.

### `Bind.of(context)`: Accessing the Locally Provided Dependency

Descendant widgets can then access this controller using `Bind.of<ControllerType>(context)`.

```dart
// product_info_display.dart (child of ProductDetailScreen's Binder)
class ProductInfoDisplay extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    // Access the ProductDetailController provided by an ancestor Binder
    final controller = Bind.of<ProductDetailController>(context);
    // Or, more conveniently, using an extension:
    // final controller = context.get<ProductDetailController>();

    controller.loadProductDetails(); // Call method on the local controller

    return Center(
      child: Text("Displaying info for product: ${controller.productId}"),
    );
  }
}
```
**What happens?**
*   `Bind.of<ProductDetailController>(context)` (or `context.get<ProductDetailController>()`) looks *up* the widget tree from `ProductInfoDisplay`.
*   It finds the nearest `Binder<ProductDetailController>` ancestor and retrieves the controller instance held by that `Binder`.
*   If you had two different `ProductDetailScreen`s on screen at once (e.g., in a split view), each would have its *own* `ProductDetailController` instance thanks to their respective `Binder`s.

**Important:** `Bind.of(context)` retrieves the dependency. If you also want the widget to rebuild when the controller calls `update()` (as discussed in [Chapter 5: GetxController](05_getxcontroller_.md) for `GetBuilder`), you would typically use `Bind.of(context, rebuild: true)` or its shorthand `context.listen<ProductDetailController>()`. This is what `GetBuilder` uses internally, as we'll see in [Chapter 7: GetBuilder](07_getbuilder_.md).


### Under the Hood: `Binder` and `Bind.of(context)`

`Binder` is essentially a specialized `InheritedWidget`. `InheritedWidget` is Flutter's standard way of passing data down the widget tree efficiently.

```mermaid
sequenceDiagram
    participant WidgetTree as ProductDetailScreen Builds
    participant BinderWidget as Binder<ProductDetailController>
    participant Flutter as Flutter Framework
    participant ChildWidget as ProductInfoDisplay
    participant BindOf as Bind.of(context) / context.get()

    WidgetTree->>BinderWidget: Creates Binder(init: () => ProductDetailController(...))
    BinderWidget->>BinderWidget: Initializes controller via 'init'
    Note over BinderWidget: Stores controller instance internally

    ChildWidget->>BindOf: Calls Bind.of<ProductDetailController>(context)
    BindOf->>Flutter: Asks Flutter: "Find nearest Binder<ProductDetailController> ancestor"
    Flutter-->>BindOf: Returns the found Binder's element
    BindOf->>BinderWidget: Accesses controller from Binder's element
    BinderWidget-->>BindOf: Returns controller instance
    BindOf-->>ChildWidget: Provides instance to ChildWidget
```

1.  **`Binder<T>(init: ..., child: ...)`**:
    *   This widget, defined in `get_state_manager/src/simple/get_state.dart`, extends `InheritedWidget`.
    *   When it's inserted into the tree, its `init` function is called (if provided and the controller isn't already globally available via `Get.put` in some configurations). It creates and holds an instance of your controller `T`.
    *   The `BindElement<T>` (its `Element`) holds the actual controller instance.

2.  **`Bind.of<T>(context)`**:
    *   This static method uses `context.getElementForInheritedWidgetOfExactType<Binder<T>>()`.
    *   This is a standard Flutter mechanism to efficiently find the nearest ancestor `Binder<T>` in the widget tree.
    *   Once found, it retrieves the controller instance from that `Binder`'s element.
    *   If `rebuild: true` is passed (or `context.listen<T>()` is used), it also establishes a dependency, so if that `Binder` later signals an update (because the controller called `update()`), this widget will rebuild.

## Global Warehouse vs. Local Delivery: Which to Choose?

*   **`Get.put()` / `Get.find()` (Global Warehouse):**
    *   **Pros:** Very easy to access truly global singletons from anywhere. Less boilerplate for simple global access.
    *   **Cons:** Can make it harder to track where a dependency is used. Testing can be trickier if everything relies on global state. Can be "too global" if a dependency is only needed in one section.
    *   **Use when:** For app-wide services (ThemeService, ApiService, UserSessionController) that are inherently singletons.

*   **`Binder` / `Bind.of(context)` (Local Delivery):**
    *   **Pros:** Dependencies are scoped to a specific part of the widget tree. Clearer where a dependency comes from (an ancestor `Binder`). Easier to have multiple, independent instances of the same controller type for different UI sections. Integrates naturally with Flutter's widget system and `BuildContext`. Better for testability of individual UI sections.
    *   **Cons:** Requires `BuildContext`. Slightly more verbose for providing the dependency (wrapping with `Binder`).
    *   **Use when:** A controller/dependency is specific to a particular screen or feature area. When you need multiple instancesManaging state for list items where each item might have its own controller. When you want to leverage Flutter's `InheritedWidget` patterns more directly.

Often, a GetX app will use a mix of both!

## Conclusion

You've now learned the key ways GetX helps you manage and access your dependencies:
*   `Get.put()` registers a dependency globally, making it like an item in a central warehouse.
*   `Get.find()` retrieves these globally registered dependencies.
*   `Binder` is an `InheritedWidget` that acts like a local delivery service, providing dependencies to a specific part of your widget tree.
*   `Bind.of(context)` (or context extensions like `context.get<T>()` and `context.listen<T>()`) allows descendant widgets to access these locally provided dependencies.

Understanding these mechanisms is crucial for building well-structured and maintainable GetX applications. You can now choose the right tool for the job, whether it's providing a global service or a locally scoped controller.

In the next chapter, we'll look at [Chapter 7: GetBuilder](07_getbuilder_.md). `GetBuilder` is a widget that often uses `Binder` and `Bind.of(context)` (or `Get.find()` implicitly) to listen to your `GetxController`'s manual `update()` calls and rebuild the UI efficiently.
---
# Chapter 7: GetBuilder

Welcome to Chapter 7! In [Chapter 6: Dependency Access (Binder, Bind.of, Get.find/put)](06_dependency_access__binder__bind_of__get_find_put__.md), we explored how to make our `GetxController` instances (our app's "brains") available to different parts of our UI. Now, let's look at another way to connect our UI to these controllers, specifically when we want more *manual* control over UI updates.

## What's the Problem? "I Want to Update My Screen *Only* When I Say So!"

Imagine you have an app screen displaying a count.
*   In [Chapter 3: Obx / ObxWidget](03_obx___obxwidget_.md), we learned about `Obx` which is fantastic for automatically updating the UI whenever an `Rx<T>` (reactive) variable changes.
*   But what if your count is just a regular `int` variable inside your `GetxController`, not an `RxInt`?
*   Or what if you want to perform several state changes and then update the UI only once, at the very end, for performance reasons or finer control?

This is where `GetBuilder` comes in. It's like having a digital display in a store that only refreshes its content when the store manager explicitly presses an "update display" button. It gives you precise, manual control.

## Meet GetBuilder: The Manually Triggered UI Refresher

`GetBuilder` is a Flutter widget provided by GetX. Its primary job is to:
1.  Listen to a specific [GetxController](05_getxcontroller_.md).
2.  Rebuild the part of your UI it wraps *only* when you explicitly call the `update()` method on that controller.

This is different from `Obx`, which reacts automatically to changes in `.obs` variables. `GetBuilder` responds to the manual `controller.update()` command.

## How to Use `GetBuilder`

Let's build a simple counter app where the count is a plain `int` in our controller, and we use `GetBuilder` to update the display.

### 1. Create Your Controller with Manual Updates

First, let's define a `GetxController`. Inside, we'll have a regular integer for our count and a method to increment it. Crucially, this method will call `update()` after changing the count.

```dart
// counter_controller.dart
import 'package:get/get.dart';

class ManualCounterController extends GetxController {
  int count = 0; // A regular integer, NOT reactive (.obs)

  void increment() {
    count++;
    update(); // THIS is the "update display" button!
    print("Count is now $count. UI update requested.");
  }
}
```
**Explanation:**
*   `count` is a simple `int`. Changes to it won't automatically trigger UI updates.
*   The `increment()` method increases `count` and then calls `update()`. This `update()` call is what `GetBuilder` will listen for.

### 2. Make Your Controller Available

As we learned in [Chapter 6: Dependency Access (Binder, Bind.of, Get.find/put)](06_dependency_access__binder__bind_of__get_find_put__.md), your controller needs to be made available. For simplicity, we can use `Get.put()` if it's a global controller, or it could be provided by an ancestor `Binder` widget.

```dart
// In your main.dart or an initialization file
Get.put(ManualCounterController());
```
This makes an instance of `ManualCounterController` available for `GetBuilder` to find.

### 3. Use `GetBuilder` in Your UI

Now, in your widget, you wrap the part of the UI that needs to display the `count` with `GetBuilder`.

```dart
// counter_page.dart
import 'package:flutter/material.dart';
import 'package:get/get.dart';
import 'counter_controller.dart'; // Your controller file

class ManualCounterPage extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(title: Text("GetBuilder Counter")),
      body: Center(
        // 1. Wrap your UI with GetBuilder
        child: GetBuilder<ManualCounterController>(
          // It will find the controller put by Get.put()
          // Or you could provide 'init: ManualCounterController()' here
          // to create a new instance scoped to this GetBuilder.

          builder: (controller) { // 2. The builder gives you the controller
            return Text(
              "Count: ${controller.count}", // 3. Access controller's state
              style: TextStyle(fontSize: 30),
            );
          },
        ),
      ),
      floatingActionButton: FloatingActionButton(
        onPressed: () {
          // Find the controller and call its method
          final ManualCounterController c = Get.find();
          c.increment();
        },
        child: Icon(Icons.add),
      ),
    );
  }
}
```
**What happens?**
1.  The `ManualCounterPage` loads. `GetBuilder` finds the `ManualCounterController` instance (the one we registered with `Get.put()`). It runs its `builder` function, and `Text("Count: 0")` is displayed.
2.  You tap the `+` button.
3.  The `onPressed` callback calls `controller.increment()`.
4.  Inside `increment()`, `count` becomes `1`, and then `update()` is called.
5.  The `GetBuilder` widget, which is listening to this specific `ManualCounterController`, "hears" the `update()` call.
6.  `GetBuilder` re-runs its `builder` function. This time, `controller.count` is `1`, so a new `Text("Count: 1")` is created and displayed.
Output (in console from the controller):
```
Count is now 1. UI update requested.
Count is now 2. UI update requested.
...
```
The UI refreshes precisely when `update()` is invoked!

### Key Properties of `GetBuilder`

*   **`builder: (controller) { ... }` (Required):** This function takes the controller instance `T` and must return the widget that should be rebuilt.
*   **`init: YourController()` (Optional):** If you provide an `init` property, `GetBuilder` will create and manage a new instance of that controller. This instance will typically be scoped to this `GetBuilder`, meaning it's available to this `GetBuilder` and its children, and it's usually disposed of when the `GetBuilder` is removed from the widget tree (due to `autoRemove: true` by default).
    ```dart
    GetBuilder<MyScopedController>(
      init: MyScopedController(), // Creates a new controller instance here
      builder: (controller) => Text(controller.data),
    )
    ```
*   **Finding an Existing Controller:** If `init` is *not* provided, `GetBuilder` attempts to find an already existing controller.
    *   By default (`global: true`), it will effectively use `Get.find<T>()` or find it through the `Binder` it creates internally (which itself can use `Get.find()`).
    * If `global: false`, it relies more strictly on finding the controller from an ancestor `Binder` widget in the tree. This is useful for more localized state. (Refer to [Chapter 6](06_dependency_access__binder__bind_of__get_find_put__.md) for `Binder`).
*   **`id: 'someUniqueId'` (Optional):** For selective updates. If you have multiple `GetBuilder`s listening to the same controller, you can give them IDs. Then, in your controller, you can call `update(['someUniqueId'])` to only rebuild `GetBuilder`s that have matching IDs.
    ```dart
    // In controller:
    // void updateProfileSection() { update(['profile']); }
    // void updateSettingsSection() { update(['settings']); }

    // In UI:
    // GetBuilder<UserController>(id: 'profile', builder: ...)
    // GetBuilder<UserController>(id: 'settings', builder: ...)
    ```
*   **`autoRemove: true` (Default):** If `GetBuilder` initialized the controller (via `init`), this determines if the controller should be disposed when `GetBuilder` is removed from the widget tree. Usually, you want this to be `true` to prevent memory leaks.
*   **`global: true` (Default):** Controls how the `Binder` (used internally by `GetBuilder`) finds or registers the controller with GetX's dependency manager. For beginners, the default usually works well, allowing `GetBuilder` to find globally `put` controllers or manage its own if `init` is used.

## GetBuilder vs. Obx: When to Use Which?

This is a common question for newcomers!

*   **`Obx` ([Chapter 3: Obx / ObxWidget](03_obx___obxwidget_.md)):**
    *   Use with **reactive variables** (e.g., `name.obs`, `count.obs`).
    *   Updates **automatically** when the `.value` of an observed `Rx<T>` variable changes *inside* its builder.
    *   Typically simpler for purely reactive state.
    *   Syntax: `Obx(() => Text(controller.reactiveName.value))`

*   **`GetBuilder`:**
    *   Use with **any type of state** in your `GetxController`, including non-reactive variables (like plain `int`s or `String`s).
    *   Updates **manually** when you call `controller.update()`.
    *   Gives you more **explicit control** over when rebuilds occur.
    *   Can be useful if you want to batch multiple state changes and trigger a single UI update.
    *   Sometimes preferred for complex state logic or when migrating from other state management solutions that use manual refresh notifications.
    *   Syntax: `GetBuilder<MyController>(builder: (controller) => Text(controller.plainName))`

You can even use both in the same app, or even for the same controller, depending on the specific needs of different UI parts!

## Under the Hood: How Does `GetBuilder` Work?

`GetBuilder` might seem simple on the surface, but it leverages some clever GetX mechanics:

1.  **Controller Access:**
    *   As seen in the internal `build` method of `GetBuilder` (in `get_state_manager/src/simple/get_state.dart`), it actually wraps its `child` (defined by your `builder` function) with a `Binder` widget.
    ```dart
    // Simplified from GetBuilder's build method in get_state.dart
    @override
    Widget build(BuildContext context) {
      return Binder( // GetBuilder uses a Binder internally!
        init: init == null ? null : () => init!, // Passes your init
        global: global, // And other properties...
        // ...
        child: Builder(builder: (context) {
          // It then uses Bind.of to get the controller
          // 'rebuild: true' means it subscribes for updates
          final controller = Bind.of<T>(context, rebuild: true);
          return builder(controller); // Calls your builder function
        }),
      );
    }
    ```
    *   This `Binder` is responsible for either creating a new controller instance (if `init` is provided) or finding an existing one (as explained in [Chapter 6: Dependency Access (Binder, Bind.of, Get.find/put)](06_dependency_access__binder__bind_of__get_find_put__.md)).
    *   The `Bind.of<T>(context, rebuild: true)` part is crucial. It not only gets the controller instance but also tells Flutter that this widget (the `Builder` inside `GetBuilder`) depends on the `Binder`. If the `Binder` signals an update, this widget should rebuild.

2.  **Listening for `update()`:**
    *   When `Bind.of(context, rebuild: true)` connects to the controller (managed by the `Binder`), the `BinderElement` (the `Element` for the `Binder` widget) adds a listener to the controller.
    *   Remember from [Chapter 5: GetxController](05_getxcontroller_.md) that `GetxController` extends `ListNotifier`? This `ListNotifier` is what manages a list of "update functions" (listeners).
    *   The `BinderElement` effectively gives its own "rebuild me" function to the controller's `ListNotifier`.

3.  **The `update()` Call:**
    *   When you call `controller.update()` in your `GetxController`, this internally calls `refresh()` on its `ListNotifier`.
    *   `refresh()` then iterates through all its registered listeners (including the one from `GetBuilder`'s internal `BinderElement`) and executes them.

4.  **UI Rebuild:**
    *   When `GetBuilder`'s `BinderElement` listener is called, it marks itself as needing a rebuild.
    *   Flutter then schedules a rebuild for that part of the widget tree.
    *   `GetBuilder`'s main `build` method runs again, which in turn calls your `builder: (controller) { ... }` function with the same controller instance (which now has the updated state).

Here's a simplified sequence:

```mermaid
sequenceDiagram
    participant UserAction as User Taps Button
    participant Controller as YourController
    participant ControllerNotifier as Controller's ListNotifier
    participant GetBuilderInternal as GetBuilder (Binder/Bind.of)
    participant YourUIBuilder as Your builder: (ctrl) => Text(...)

    Note over ControllerNotifier, GetBuilderInternal: GetBuilder (via Binder) has subscribed to Controller's Notifier

    UserAction->>Controller: Calls controller.increment()
    Controller->>Controller: Updates its internal state (e.g., `count++`)
    Controller->>ControllerNotifier: Calls this.update() which calls refresh()
    ControllerNotifier-->>GetBuilderInternal: Notifies its listener (the BinderElement)
    GetBuilderInternal->>GetBuilderInternal: Marks itself for rebuild
    GetBuilderInternal-->>YourUIBuilder: Invokes your builder function
    YourUIBuilder->>Controller: Accesses controller.count (new value)
    YourUIBuilder-->>UserAction: UI displays updated count
```

So, `GetBuilder` provides a structured way to manually trigger UI updates by cleverly using `Binder` and the `ListNotifier` capabilities of `GetxController`.

## Conclusion

You've now learned about `GetBuilder`, your tool for manually controlling UI updates in GetX. It's ideal when you're not using reactive `.obs` variables for a piece of state, or when you need fine-grained control over *when* your UI should refresh in response to changes in a `GetxController`. By calling `controller.update()`, you tell all listening `GetBuilder` widgets it's time to redraw themselves.

While `GetBuilder` deals with general state and manual updates, GetX also offers specialized tools for handling more complex state scenarios, like loading data from a server, showing error messages, or displaying empty states. One such tool is the `StateMixin`.

Let's explore this powerful mixin in the [next chapter, Chapter 8: StateMixin](08_statemixin_.md).

Relevant Code Snippets (Code itself remains unchanged):
--- File: get_state_manager/src/simple/get_controllers.dart ---
// ignore: prefer_mixin
import 'package:flutter/widgets.dart';

import '../../../instance_manager.dart';
import '../rx_flutter/rx_notifier.dart';
import 'list_notifier.dart';

// ignore: prefer_mixin
abstract class GetxController extends ListNotifier with GetLifeCycleMixin {
  /// Rebuilds `GetBuilder` each time you call `update()`;
  /// Can take a List of [ids], that will only update the matching
  /// `GetBuilder( id: )`,
  /// [ids] can be reused among `GetBuilders` like group tags.
  /// The update will only notify the Widgets, if [condition] is true.
  void update([List<Object>? ids, bool condition = true]) {
    if (!condition) {
      return;
    }
    if (ids == null) {
      refresh();
    } else {
      for (final id in ids) {
        refreshGroup(id);
      }
    }
  }
}

/// this mixin allow to fetch data when the scroll is at the bottom or on the
/// top
mixin ScrollMixin on GetLifeCycleMixin {
  final ScrollController scroll = ScrollController();

  @override
  void onInit() {
    super.onInit();
    scroll.addListener(_listener);
  }

  bool _canFetchBottom = true;

  bool _canFetchTop = true;

  void _listener() {
    if (scroll.position.atEdge) {
      _checkIfCanLoadMore();
    }
  }

  Future<void> _checkIfCanLoadMore() async {
    if (scroll.position.pixels == 0) {
      if (!_canFetchTop) return;
      _canFetchTop = false;
      await onTopScroll();
      _canFetchTop = true;
    } else {
      if (!_canFetchBottom) return;
      _canFetchBottom = false;
      await onEndScroll();
      _canFetchBottom = true;
    }
  }

  /// this method is called when the scroll is at the bottom
  Future<void> onEndScroll();

  /// this method is called when the scroll is at the top
  Future<void> onTopScroll();

  @override
  void onClose() {
    scroll.removeListener(_listener);
    super.onClose();
  }
}

/// A clean controller to be used with only Rx variables
abstract class RxController with GetLifeCycleMixin {}

/// A recommended way to use Getx with Future fetching
abstract class StateController<T> extends GetxController with StateMixin<T> {}

/// A controller with super lifecycles (including native lifecycles)
/// and StateMixins
abstract class SuperController<T> extends FullLifeCycleController
    with FullLifeCycleMixin, StateMixin<T> {}

/// A controller with super lifecycles (including native lifecycles)
abstract class FullLifeCycleController extends GetxController
    with
        // ignore: prefer_mixin
        WidgetsBindingObserver {}

mixin FullLifeCycleMixin on FullLifeCycleController {
  @mustCallSuper
  @override
  void onInit() {
    super.onInit();
    Engine.instance.addObserver(this);
  }

  @mustCallSuper
  @override
  void onClose() {
    Engine.instance.removeObserver(this);
    super.onClose();
  }

  @mustCallSuper
  @override
  void didChangeAppLifecycleState(AppLifecycleState state) {
    switch (state) {
      case AppLifecycleState.resumed:
        onResumed();
        break;
      case AppLifecycleState.inactive:
        onInactive();
        break;
      case AppLifecycleState.paused:
        onPaused();
        break;
      case AppLifecycleState.detached:
        onDetached();
        break;
      case AppLifecycleState.hidden:
        onHidden();
        break;
    }
  }

  void onResumed() {}
  void onPaused() {}
  void onInactive() {}
  void onDetached() {}
  void onHidden() {}
}


--- File: get_state_manager/src/rx_flutter/rx_notifier.dart ---
import 'dart:async';

import 'package:flutter/foundation.dart';
import 'package:flutter/material.dart';
import 'package:get/utils.dart';

import '../../../get_rx/src/rx_types/rx_types.dart';
import '../../../instance_manager.dart';
import '../../get_state_manager.dart';
import '../simple/list_notifier.dart';

extension _Empty on Object {
  bool _isEmpty() {
    final val = this;
    // if (val == null) return true;
    var result = false;
    if (val is Iterable) {
      result = val.isEmpty;
    } else if (val is String) {
      result = val.trim().isEmpty;
    } else if (val is Map) {
      result = val.isEmpty;
    }
    return result;
  }
}

mixin StateMixin<T> on ListNotifier {
  T? _value;
  GetStatus<T>? _status;

  void _fillInitialStatus() {
    _status = (_value == null || _value!._isEmpty())
        ? GetStatus<T>.loading()
        : GetStatus<T>.success(_value as T);
  }

  GetStatus<T> get status {
    reportRead();
    return _status ??= _status = GetStatus.loading();
  }

  T get state => value;

  set status(GetStatus<T> newStatus) {
    if (newStatus == status) return;
    _status = newStatus;
    if (newStatus is SuccessStatus<T>) {
      _value = newStatus.data;
    }
    refresh();
  }

  @protected
  T get value {
    reportRead();
    return _value as T;
  }

  @protected
  set value(T newValue) {
    if (_value == newValue) return;
    _value = newValue;
    refresh();
  }

  @protected
  void change(GetStatus<T> status) {
    if (status != this.status) {
      this.status = status;
    }
  }

  void setSuccess(T data) {
    change(GetStatus<T>.success(data));
  }

  void setError(Object error) {
    change(GetStatus<T>.error(error));
  }

  void setLoading() {
    change(GetStatus<T>.loading());
  }

  void setEmpty() {
    change(GetStatus<T>.empty());
  }

  void futurize(Future<T> Function() body,
      {T? initialData, String? errorMessage, bool useEmpty = true}) {
    final compute = body;
    _value ??= initialData;
    status = GetStatus<T>.loading();
    compute().then((newValue) {
      if ((newValue == null || newValue._isEmpty()) && useEmpty) {
        status = GetStatus<T>.empty();
      } else {
        status = GetStatus<T>.success(newValue);
      }

      refresh();
    }, onError: (err) {
      status = GetStatus.error(
          err is Exception ? err : Exception(errorMessage ?? err.toString()));
      refresh();
    });
  }
}

typedef FuturizeCallback<T> = Future<T> Function(VoidCallback fn);

typedef VoidCallback = void Function();

class GetListenable<T> extends ListNotifierSingle implements RxInterface<T> {
  GetListenable(T val) : _value = val;

  StreamController<T>? _controller;

  StreamController<T> get subject {
    if (_controller == null) {
      _controller =
          StreamController<T>.broadcast(onCancel: addListener(_streamListener));
      _controller?.add(_value);

      ///TODO: report to controller dispose
    }
    return _controller!;
  }

  void _streamListener() {
    _controller?.add(_value);
  }

  @override
  @mustCallSuper
  void close() {
    removeListener(_streamListener);
    _controller?.close();
    dispose();
  }

  Stream<T> get stream {
    return subject.stream;
  }

  T _value;

  @override
  T get value {
    reportRead();
    return _value;
  }

  void _notify() {
    refresh();
  }

  set value(T newValue) {
    if (_value == newValue) return;
    _value = newValue;
    _notify();
  }

  T? call([T? v]) {
    if (v != null) {
      value = v;
    }
    return value;
  }

  @override
  StreamSubscription<T> listen(
    void Function(T)? onData, {
    Function? onError,
    void Function()? onDone,
    bool? cancelOnError,
  }) =>
      stream.listen(
        onData,
        onError: onError,
        onDone: onDone,
        cancelOnError: cancelOnError ?? false,
      );

  @override
  String toString() => value.toString();
}

class Value<T> extends ListNotifier
    with StateMixin<T>
    implements ValueListenable<T?> {
  Value(T val) {
    _value = val;
    _fillInitialStatus();
  }

  @override
  T get value {
    reportRead();
    return _value as T;
  }

  @override
  set value(T newValue) {
    if (_value == newValue) return;
    _value = newValue;
    refresh();
  }

  T? call([T? v]) {
    if (v != null) {
      value = v;
    }
    return value;
  }

  void update(T Function(T? value) fn) {
    value = fn(value);
    // refresh();
  }

  @override
  String toString() => value.toString();

  dynamic toJson() => (value as dynamic)?.toJson();
}

/// GetNotifier has a native status and state implementation, with the
/// Get Lifecycle
abstract class GetNotifier<T> extends Value<T> with GetLifeCycleMixin {
  GetNotifier(super.initial);
}

extension StateExt<T> on StateMixin<T> {
  Widget obx(
    NotifierBuilder<T> widget, {
    Widget Function(String? error)? onError,
    Widget? onLoading,
    Widget? onEmpty,
    WidgetBuilder? onCustom,
  }) {
    return Observer(builder: (context) {
      if (status.isLoading) {
        return onLoading ?? const Center(child: CircularProgressIndicator());
      } else if (status.isError) {
        return onError != null
            ? onError(status.errorMessage)
            : Center(child: Text('A error occurred: ${status.errorMessage}'));
      } else if (status.isEmpty) {
        return onEmpty ??
            const SizedBox.shrink(); // Also can be widget(null); but is risky
      } else if (status.isSuccess) {
        return widget(value);
      } else if (status.isCustom) {
        return onCustom?.call(context) ??
            const SizedBox.shrink(); // Also can be widget(null); but is risky
      }
      return widget(value);
    });
  }
}

typedef NotifierBuilder<T> = Widget Function(T state);

abstract class GetStatus<T> with Equality {
  const GetStatus();

  factory GetStatus.loading() => LoadingStatus<T>();

  factory GetStatus.error(Object message) => ErrorStatus<T, Object>(message);

  factory GetStatus.empty() => EmptyStatus<T>();

  factory GetStatus.success(T data) => SuccessStatus<T>(data);

  factory GetStatus.custom() => CustomStatus<T>();
}

class CustomStatus<T> extends GetStatus<T> {
  @override
  List get props => [];
}

class LoadingStatus<T> extends GetStatus<T> {
  @override
  List get props => [];
}

class SuccessStatus<T> extends GetStatus<T> {
  final T data;

  const SuccessStatus(this.data);

  @override
  List get props => [data];
}

class ErrorStatus<T, S> extends GetStatus<T> {
  final S? error;

  const ErrorStatus([this.error]);

  @override
  List get props => [error];
}

class EmptyStatus<T> extends GetStatus<T> {
  @override
  List get props => [];
}

extension StatusDataExt<T> on GetStatus<T> {
  bool get isLoading => this is LoadingStatus;

  bool get isSuccess => this is SuccessStatus;

  bool get isError => this is ErrorStatus;

  bool get isEmpty => this is EmptyStatus;

  bool get isCustom => !isLoading && !isSuccess && !isError && !isEmpty;

  dynamic get error {
    if (this is ErrorStatus) {
      return (this as ErrorStatus).error;
    }
    return null;
  }

  String get errorMessage {
    final isError = this is ErrorStatus;
    if (isError) {
      final err = this as ErrorStatus;
      if (err.error != null) {
        if (err.error is String) {
          return err.error as String;
        }
        return err.error.toString();
      }
    }

    return '';
  }

  T? get data {
    if (this is SuccessStatus<T>) {
      final success = this as SuccessStatus<T>;
      return success.data;
    }
    return null;
  }
}


Instructions for the chapter (Generate content in English unless specified otherwise):
- Start with a clear heading (e.g., `# Chapter 8: StateMixin
`). Use the provided concept name.

- If this is not the first chapter, begin with a brief transition from the previous chapter, referencing it with a proper Markdown link using its name.

- Begin with a high-level motivation explaining what problem this abstraction solves. Start with a central use case as a concrete example. The whole chapter should guide the reader to understand how to solve this use case. Make it very minimal and friendly to beginners.

- If the abstraction is complex, break it down into key concepts. Explain each concept one-by-one in a very beginner-friendly way.

- Explain how to use this abstraction to solve the use case. Give example inputs and outputs for code snippets (if the output isn't values, describe at a high level what will happen).

- Each code block should be BELOW 10 lines! If longer code blocks are needed, break them down into smaller pieces and walk through them one-by-one. Aggresively simplify the code to make it minimal. Use comments to skip non-important implementation details. Each code block should have a beginner friendly explanation right after it.

- Describe the internal implementation to help understand what's under the hood. First provide a non-code or code-light walkthrough on what happens step-by-step when the abstraction is called. It's recommended to use a simple sequenceDiagram with a dummy example - keep it minimal with at most 5 participants to ensure clarity. If participant name has space, use: `participant QP as Query Processing`. .

- Then dive deeper into code for the internal implementation with references to files. Provide example code blocks, but make them similarly simple and beginner-friendly. Explain.

- IMPORTANT: When you need to refer to other core abstractions covered in other chapters, ALWAYS use proper Markdown links like this: [Chapter Title](filename.md). Use the Complete Tutorial Structure above to find the correct filename and the chapter title. Translate the surrounding text.

- Use mermaid diagrams to illustrate complex concepts (```mermaid``` format). .

- Heavily use analogies and examples throughout to help beginners understand.

- End the chapter with a brief conclusion that summarizes what was learned and provides a transition to the next chapter. If there is a next chapter, use a proper Markdown link: [Next Chapter Title](next_chapter_filename).

- Ensure the tone is welcoming and easy for a newcomer to understand.

- Output *only* the Markdown content for this chapter.

Now, directly provide a super beginner-friendly Markdown output (DON'T need ```markdown``` tags):

2025-05-12 13:39:32,882 - INFO - RESPONSE: # Chapter 8: StateMixin

Welcome to Chapter 8! In [Chapter 7: GetBuilder](07_getbuilder_.md), we saw how `GetBuilder` gives us manual control over UI updates for our `GetxController`. Now, what if we have a common pattern: fetching data from a server or performing some long task, and we want to show different screens for "loading," "data successfully loaded," "an error occurred," or "no data found"? Managing all these UI states manually can be repetitive. GetX provides a wonderful utility for this: `StateMixin`!

## What Problem Does `StateMixin` Solve? The Asynchronous UI Dance!

Imagine you're building a screen that needs to show a user's profile. To do this, your app needs to:
1.  **Start fetching:** Show a loading spinner while it asks the server for data.
2.  **Success:** If data comes back, display the user's profile.
3.  **Empty:** If data comes back but it's empty (e.g., a new user with no profile details yet), show a "Profile is empty" message.
4.  **Error:** If something goes wrong (no internet, server error), show an error message with perhaps a retry button.

This "loading -> success/empty/error" flow is extremely common in apps. `StateMixin` is a helper (a "mixin") that you add to your [GetxController](05_getxcontroller_.md) to make managing these UI states incredibly simple. It acts like a **standardized status panel for your data**, clearly indicating its current condition, and makes it easy to show the right widget for that condition.

## Meet `StateMixin`: Your Controller's Status Manager

`StateMixin` provides your controller with:
1.  A **`status` property**: This tells you the current state (e.g., `status.isLoading`, `status.isSuccess`, `status.isError`, `status.isEmpty`).
2.  A **`state` property**: If the status is "success," this holds the actual data you've loaded (e.g., the user profile object).
3.  **Helper methods**: Functions like `setLoading()`, `setSuccess(yourData)`, `setError('oops')`, and `setEmpty()` to easily change the current status.
4.  A special **`obx` method (on the controller itself)**: This method is a widget builder that automatically shows different UI sections based on the current `status`.

### How to Use `StateMixin`

Let's see it in action with a simple example of fetching a welcome message.

#### 1. Create a Controller with `StateMixin`

First, you create your [GetxController](05_getxcontroller_.md) and add `with StateMixin<YourDataType>` to it. The `YourDataType` is the type of data you expect to load (e.g., `String` for a message, `User` for a user object).

```dart
// welcome_controller.dart
import 'package:get/get.dart';

class WelcomeController extends GetxController with StateMixin<String> {
  // The <String> means our successful 'state' will be a String.

  @override
  void onInit() {
    super.onInit();
    fetchWelcomeMessage(); // Let's fetch data when the controller starts
  }

  Future<void> fetchWelcomeMessage() async {
    // 1. Start with loading state
    setLoading(); // This updates status to loading and tells UI to refresh

    try {
      // Simulate fetching data from a server
      await Future.delayed(Duration(seconds: 2));
      String message = "Hello, GetX User!";
      // String message = ""; // Uncomment to test empty state
      // throw Exception("Network Error!"); // Uncomment to test error state

      if (message.isEmpty) {
        // 2a. Data is empty
        setEmpty();
      } else {
        // 2b. Data fetched successfully!
        setSuccess(message); // 'message' is our String data
      }
    } catch (e) {
      // 3. An error occurred
      setError(e.toString());
    }
  }
}
```
**Explanation:**
*   `class WelcomeController extends GetxController with StateMixin<String>`: We're creating a controller that will manage a state of type `String`.
*   `setLoading()`: We call this method to tell `StateMixin` that we've started loading. The `status` becomes `isLoading`.
*   `setSuccess(message)`: If data is fetched, we call this with the actual data. The `status` becomes `isSuccess`, and `state` will now hold `message`.
*   `setEmpty()`: If the fetched data represents an "empty" condition, we call this. The `status` becomes `isEmpty`.
*   `setError(e.toString())`: If an error occurs, we call this with an error message. The `status` becomes `isError`.

Behind the scenes, calling `setLoading()`, `setSuccess()`, etc., updates the internal `status` and then calls `refresh()` (which we know from [GetxController](05_getxcontroller_.md) and [GetBuilder](07_getbuilder_.md) triggers UI updates for listening widgets).

#### 2. Make Your Controller Available

As usual, you need to make your controller available, for instance, using `Get.put()`:
```dart
// Initialize your controller, e.g., in main.dart or a binding
Get.put(WelcomeController());
```

#### 3. Displaying UI with `controller.obx()`

`StateMixin` gives your controller a handy `obx()` method (not to be confused with the `Obx()` widget from [Chapter 3: Obx / ObxWidget](03_obx___obxwidget_.md)). This method is a widget builder that takes different functions to render UI for each state:

```dart
// welcome_page.dart
import 'package:flutter/material.dart';
import 'package:get/get.dart';
import 'welcome_controller.dart'; // Import your controller

class WelcomePage extends StatelessWidget {
  final WelcomeController controller = Get.find<WelcomeController>();

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(title: Text("StateMixin Demo")),
      body: Center(
        // Use the controller's own .obx() method
        child: controller.obx(
          // (state) is the data you passed to setSuccess(data)
          (state) => Text(
            "Success: $state", // 'state' is the "Hello, GetX User!" message
            style: TextStyle(fontSize: 24, color: Colors.green),
          ),
          onLoading: CircularProgressIndicator(),
          onError: (error) => Text(
            "Error: $error",
            style: TextStyle(fontSize: 18, color: Colors.red),
          ),
          onEmpty: Text(
            "No message found.",
            style: TextStyle(fontSize: 18, color: Colors.orange),
          ),
        ),
      ),
      floatingActionButton: FloatingActionButton(
        onPressed: () => controller.fetchWelcomeMessage(), // Retry
        child: Icon(Icons.refresh),
      ),
    );
  }
}
```
**What happens:**
1.  When `WelcomePage` loads, `controller.fetchWelcomeMessage()` is called (from `onInit`).
2.  `setLoading()` is called. The `controller.obx` widget sees `status.isLoading` is true and displays the `CircularProgressIndicator` you provided in `onLoading`.
3.  After 2 seconds (simulated delay):
    *   **If successful:** `setSuccess("Hello, GetX User!")` is called. `controller.obx` sees `status.isSuccess` is true. It then calls your main builder `(state) => ...` where `state` is "Hello, GetX User!", and displays your success `Text` widget.
    *   **If empty:** `setEmpty()` is called. `controller.obx` sees `status.isEmpty` and displays the `Text` from `onEmpty`.
    *   **If error:** `setError("some error")` is called. `controller.obx` sees `status.isError` and calls `(error) => ...` from `onError`, displaying the error message.

You have a clean way to handle all common async UI states with minimal boilerplate!

The parameters for `controller.obx()` are:
*   **`NotifierBuilder<T> widget` (Required):** A function `(T state) => Widget`. This is called when `status.isSuccess`. The `state` argument is your data.
*   **`onLoading` (Optional):** A `Widget` to display when `status.isLoading`. Defaults to `Center(child: CircularProgressIndicator())`.
*   **`onError` (Optional):** A function `(String? error) => Widget`. Called when `status.isError`. The `error` argument is the message you passed to `setError()`. Defaults to `Center(child: Text('An error occurred: ...'))`.
*   **`onEmpty` (Optional):** A `Widget` to display when `status.isEmpty`. Defaults to `SizedBox.shrink()`.

## Under the Hood: The Magic of `StateMixin` and `GetStatus`

`StateMixin` isn't black magic; it's a well-thought-out combination of existing GetX concepts.

```mermaid
sequenceDiagram
    participant UserAction as Page Loads / Refresh Button
    participant Controller as WelcomeController (with StateMixin)
    participant StateMixinInternals as (Part of Controller)
    participant ControllerObxWidget as controller.obx() in UI

    UserAction->>Controller: Calls controller.fetchWelcomeMessage()
    Controller->>StateMixinInternals: Calls setLoading()
    StateMixinInternals->>StateMixinInternals: Sets internal _status to LoadingStatus, calls refresh()
    StateMixinInternals-->>ControllerObxWidget: Notifies listeners (obx widget rebuilds)
    ControllerObxWidget->>StateMixinInternals: Reads controller.status (isLoading == true)
    ControllerObxWidget-->>UserAction: Shows 'onLoading' widget (e.g., Spinner)

    Note over Controller, StateMixinInternals: Simulating API call...
    Controller->>StateMixinInternals: API success, calls setSuccess("Hello!")
    StateMixinInternals->>StateMixinInternals: Sets _status to SuccessStatus("Hello!"), _value to "Hello!", calls refresh()
    StateMixinInternals-->>ControllerObxWidget: Notifies listeners (obx widget rebuilds)
    ControllerObxWidget->>StateMixinInternals: Reads controller.status (isSuccess == true), reads controller.state ("Hello!")
    ControllerObxWidget-->>UserAction: Shows main success widget (e.g., Text("Hello!"))
```

1.  **The Mixin Itself (`StateMixin<T>`):**
    *   Located in `get_state_manager/src/rx_flutter/rx_notifier.dart`.
    *   It's declared as `mixin StateMixin<T> on ListNotifier`. This means it must be mixed into a class that is also a `ListNotifier` (like [GetxController](05_getxcontroller_.md), which extends `ListNotifier`).
    *   It internally stores:
        *   `T? _value;`: This holds your actual data (e.g., "Hello, GetX User!").
        *   `GetStatus<T>? _status;`: This holds the current status.
    *   When you call `setLoading()`, `setSuccess(data)`, `setError(errorMsg)`, or `setEmpty()`, these methods:
        *   Create an appropriate `GetStatus` object (e.g., `LoadingStatus<T>()`, `SuccessStatus<T>(data)`).
        *   Call an internal `change(newStatus)` method.
        *   The `change()` method updates the internal `_status` (and `_value` if it's a success status).
        *   Crucially, after updating, it calls `refresh()`. Since `StateMixin` is `on ListNotifier`, this `refresh()` call notifies any listeners that the state has changed.

2.  **`GetStatus<T>`:**
    *   Also in `get_state_manager/src/rx_flutter/rx_notifier.dart`.
    *   This is like an advanced enum. It has factory constructors:
        *   `GetStatus.loading()`: Creates a `LoadingStatus<T>`.
        *   `GetStatus.success(T data)`: Creates a `SuccessStatus<T>` holding your data.
        *   `GetStatus.error(Object message)`: Creates an `ErrorStatus<T, Object>` holding the error.
        *   `GetStatus.empty()`: Creates an `EmptyStatus<T>`.
    *   Extensions on `GetStatus<T>` (like `StatusDataExt<T>`) provide handy boolean getters: `isLoading`, `isSuccess`, `isError`, `isEmpty`, and also access to `data` or `errorMessage`.

3.  **The Controller's `obx()` Method:**
    *   This method is *not* part of `StateMixin` itself but is an extension method defined as `StateExt<T> on StateMixin<T>` (also in `rx_notifier.dart`).
    *   `Widget obx(NotifierBuilder<T> widget, { ... }) { return Observer(builder: (context) { ... }); }`
    *   It returns an `Observer` widget. This `Observer` widget is a reactive widget (similar in principle to `Obx` or `GetBuilder`). It listens to the `StateMixin` (because the controller it's on is a `ListNotifier`).
    *   When `refresh()` is called by `StateMixin`, the `Observer` rebuilds.
    *   Inside the `Observer`'s `builder` function, it checks the `controller.status` (e.g., `controller.status.isLoading`, `controller.status.isSuccess`) and then executes the appropriate rendering function you provided (`onLoading`, main builder, `onError`, or `onEmpty`).

So, `StateMixin` provides the state management logic, and the `obx` extension method provides a convenient way to render UI based on that managed state.

## Conclusion

`StateMixin` is a powerful and convenient tool for managing the common UI states of asynchronous operations: loading, success (with data), error, and empty. By mixing it into your `GetxController` and using the controller's `obx()` method in your UI, you can write cleaner, more readable code for these frequent scenarios. It elegantly handles the "status panel" for your data, letting you focus on what to display in each case.

We've covered various ways to manage and display state. Sometimes, your state involves lists of items, and you might need specific logic for managing those lists reactively. GetX offers specialized tools for this too.

In the [next chapter, Chapter 9: ListNotifier (and Mixins)](09_listnotifier__and_mixins__.md), we'll delve into `ListNotifier` itself, which is the foundation for many of GetX's state management primitives, and see how it can be used with other mixins for more advanced list management.
2025-05-12 13:39:32,952 - INFO - PROMPT: 
Write a very beginner-friendly tutorial chapter (in Markdown format) for the project `lib` about the concept: "ListNotifier (and Mixins)
". This is Chapter 9.

Concept Details:
- Name: ListNotifier (and Mixins)

- Description:
`ListNotifier` is the fundamental engine for managing lists of listeners and dispatching update notifications.
Think of it as a highly efficient town crier. When a `GetxController`
needs to announce a state change (via `update()`), it uses its `ListNotifier` to alert all subscribed
widgets (like `GetBuilder`) that they need to refresh. This is a cornerstone of
GetX's simple state management.


Complete Tutorial Structure:
1. [Get (Global Access Facade)
](01_get__global_access_facade__.md)
2. [Rx<T> (Reactive Variables)
](02_rx_t___reactive_variables__.md)
3. [Obx / ObxWidget
](03_obx___obxwidget_.md)
4. [Workers
](04_workers_.md)
5. [GetxController
](05_getxcontroller_.md)
6. [Dependency Access (Binder, Bind.of, Get.find/put)
](06_dependency_access__binder__bind_of__get_find_put__.md)
7. [GetBuilder
](07_getbuilder_.md)
8. [StateMixin
](08_statemixin_.md)
9. [ListNotifier (and Mixins)
](09_listnotifier__and_mixins__.md)

Context from previous chapters:
# Chapter 1: Get (Global Access Facade)

Welcome to your GetX journey! In this first chapter, we'll explore one of the most fundamental and frequently used parts of the GetX ecosystem: the `Get` object.

## What is `Get` and Why Do You Need It?

Imagine you're building a Flutter app. You often need to perform common tasks like:
*   Showing a quick message (a "snackbar") to the user.
*   Navigating to a new screen.
*   Accessing a shared service, like a settings manager, from various parts of your app.

Traditionally, in Flutter, many of these tasks require access to something called `BuildContext`. `BuildContext` tells Flutter "where" you are in your widget tree, which is necessary for operations like finding the nearest `Navigator` or `Scaffold`. Getting `BuildContext` to the exact spot where you need it can sometimes be cumbersome, especially in deeper parts of your app's logic that aren't directly part of a widget.

This is where `Get` comes to the rescue!

The `Get` object is your main entry point for most GetX features. Think of it as a **universal remote control** for your application. It provides super easy-to-use tools (called static methods) for:

*   **Dependency Management:** Storing and retrieving your app's services or "managers" (like a `UserSettingsManager` or `ApiService`).
*   **Navigation:** Moving between screens with simple commands.
*   **Showing UI Elements:** Displaying dialogs, snackbars, or bottom sheets.
*   ...and much more!

The beauty of `Get` is that it often lets you do these things **without needing `BuildContext`**, making your code cleaner and simplifying access to GetX functionalities from virtually anywhere in your app.

## How to Use `Get`

Using `Get` is incredibly straightforward because its methods are `static`. This means you don't need to create an instance of a `Get` class; you just type `Get.` followed by the feature you want to use.

Let's look at a few common use cases:

### 1. Showing a Snackbar

Need to show a quick notification to the user?

```dart
import 'package:get/get.dart'; // Make sure to import GetX

// ...somewhere in your code, even inside a business logic class
void showSuccessMessage() {
  Get.snackbar(
    "Success!", // title
    "Your profile was updated successfully.", // message
    snackPosition: SnackPosition.BOTTOM
  );
}
```

**What happens?**
When `showSuccessMessage()` is called, GetX will display a snackbar at the bottom of the current screen with the title "Success!" and the given message. Notice you didn't need to pass any `BuildContext`!

### 2. Navigating to a New Screen

Want to open a new page?

```dart
import 'package:flutter/material.dart';
import 'package:get/get.dart';

class HomeScreen extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(title: Text("Home")),
      body: Center(
        child: ElevatedButton(
          onPressed: () {
            Get.to(DetailScreen()); // Navigate to DetailScreen
          },
          child: Text("Go to Details"),
        ),
      ),
    );
  }
}

class DetailScreen extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(title: Text("Details")),
      body: Center(
        child: ElevatedButton(
          onPressed: () {
            Get.back(); // Go back to the previous screen
          },
          child: Text("Go Back"),
        ),
      ),
    );
  }
}
```
**What happens?**
*   Tapping the "Go to Details" button on `HomeScreen` will push `DetailScreen` onto the navigation stack, making it visible.
*   Tapping the "Go Back" button on `DetailScreen` will pop it from the stack, revealing `HomeScreen` again.

Again, simple and no `BuildContext` needed for `Get.to()` or `Get.back()`. (Note: To use GetX navigation, your main app widget should be `GetMaterialApp` instead of `MaterialApp`).

### 3. Basic Dependency Management (Service Locator)

Imagine you have a class that manages user preferences:

```dart
class UserPreferencesService {
  bool _isDarkMode = false;

  bool get isDarkMode => _isDarkMode;

  void toggleDarkMode() {
    _isDarkMode = !_isDarkMode;
    print("Dark mode is now: $_isDarkMode");
    // In a real app, you'd save this preference
  }
}
```

You can "register" an instance of this service with GetX using `Get.put()`:

```dart
// Usually done at app startup or in a specific setup area
void initializeServices() {
  Get.put(UserPreferencesService());
  print("UserPreferencesService registered!");
}
```

Later, from anywhere in your app, you can retrieve this instance using `Get.find()`:

```dart
// ... in some widget or controller
void onThemeToggleButtonPressed() {
  final prefsService = Get.find<UserPreferencesService>();
  prefsService.toggleDarkMode();
  // You might then update your UI based on prefsService.isDarkMode
}
```

**What happens?**
*   `Get.put(UserPreferencesService());` creates an instance of `UserPreferencesService` and stores it in a global container managed by GetX.
*   `Get.find<UserPreferencesService>();` looks up and returns that stored instance.

This allows you to easily access shared services without passing instances around manually or using complex InheritedWidgets. We'll dive much deeper into dependency management in [Chapter 6: Dependency Access (Binder, Bind.of, Get.find/put)](06_dependency_access__binder__bind_of__get_find_put__.md).

## Under the Hood: How Does `Get` Work?

You might be wondering how `Get` can perform these actions, especially UI-related ones like showing snackbars, without `BuildContext`.

At its core, `Get` is a cleverly designed global static instance. When you use GetX (typically by wrapping your app with `GetMaterialApp`), GetX sets up the necessary infrastructure.

Here's a simplified conceptual flow for showing a snackbar:

```mermaid
sequenceDiagram
    participant YourCode as Your App Code
    participant Get as Get Object
    participant GetXCore as GetX Internal Logic
    participant FlutterFramework as Flutter Framework

    YourCode->>Get: Calls Get.snackbar("Title", "Message")
    Get->>GetXCore: Forwards request to internal snackbar logic
    GetXCore->>FlutterFramework: Uses Flutter's Overlay (or similar) to display UI
    FlutterFramework-->>YourCode: Snackbar appears on screen
```

**1. The `Get` Object Itself:**
The `Get` object you use is actually a global instance of a class. This is defined very simply in the GetX core:

```dart
// From: get_core/src/get_main.dart

// (_GetImpl is a class that implements GetInterface,
// where all the actual methods are defined or extended)
class _GetImpl extends GetInterface {}

// This creates a single, globally accessible instance named 'Get'
// ignore: non_constant_identifier_names
final Get = _GetImpl();
```
This `Get` variable is what you're accessing when you type `Get.something()`.

**2. `GetInterface` and Extensions:**
The `_GetImpl` class extends `GetInterface`.
```dart
// From: get_core/src/get_interface.dart
abstract class GetInterface {
  // Basic configurations like smartManagement and logging
  SmartManagement smartManagement = SmartManagement.full;
  bool isLogEnable = kDebugMode;
  LogWriterCallback log = defaultLogWriterCallback;
  // ... other core properties might be declared here
}
```
Many of GetX's functionalities (like `Get.to`, `Get.snackbar`, `Get.put`, `Get.find`) are added to this `GetInterface` through Dart's extension methods or are mixed into `_GetImpl`. These extensions contain the actual logic. For example, the navigation methods know how to find the `Navigator` provided by `GetMaterialApp`, and the snackbar methods know how to tap into Flutter's `Overlay` to display UI elements globally.

**3. For Dependency Management (`Get.put` / `Get.find`):**
When you use `Get.put(MyService())`, GetX stores this `MyService` instance in an internal data structure (like a map), often an_instance manager. When you later call `Get.find<MyService>()`, GetX looks up `MyService` in this internal storage by its type (and optionally by a tag) and returns the stored instance. We'll cover the `InstanceManager` in more detail in [Chapter 6: Dependency Access (Binder, Bind.of, Get.find/put)](06_dependency_access__binder__bind_of__get_find_put__.md).

The key takeaway is that `Get` acts as a **facade**  a simplified, unified interface to a more complex underlying system. It hides the complexities of interacting directly with Flutter's deeper systems or managing global instances, providing you with clean, easy-to-use static methods.

## Conclusion

You've now met `Get`, your go-to helper for many common tasks in GetX. It's a powerful yet simple facade that provides global access to navigation, UI utilities, dependency management, and more, often without the need for `BuildContext`. This keeps your code clean and makes development faster.

As you continue your GetX journey, you'll see `Get` being used in various contexts. Understanding its role as a global access point is key to mastering GetX.

In the next chapter, we'll explore a core GetX concept for making your application's data dynamic and responsive: [Rx<T> (Reactive Variables)](02_rx_t___reactive_variables__.md).
---
# Chapter 2: Rx<T> (Reactive Variables)

Welcome to Chapter 2! In [Chapter 1: Get (Global Access Facade)](01_get__global_access_facade__.md), we learned how the `Get` object acts as a handy "universal remote" for common app tasks. Now, we're going to dive into one of the most exciting features of GetX: making your app's data "reactive."

## What's the Big Deal with "Reactive"?

Imagine you're building an app that shows a user's score. When the score changes, you want the text on the screen displaying that score to update *automatically*, without you having to write a lot of complicated code to manually refresh the screen. This "automatic updating" is what reactive programming is all about.

`Rx<T>` variables are GetX's way of achieving this magic.

## Introducing `Rx<T>`: Your Magic Whiteboard

`Rx<T>` types (like `RxInt`, `RxString`, or pretty much anything you see ending with `.obs`) represent variables that can be "observed."

Think of an `Rx<T>` variable as a special number (or text, or any data) written on a **magic whiteboard**:
*   You write your initial data on this whiteboard (e.g., the number `0`).
*   Whenever someone erases the number and writes a new one (e.g., changes it to `1`), a bell automatically rings!
*   Anyone (or any part of your app's UI) specifically "watching" that number on the whiteboard instantly sees the change and reacts to it.

These `Rx<T>` variables are the heart of GetX's reactive programming. They allow your User Interface (UI), especially when used with widgets like `Obx` (which we'll cover in the [next chapter](03_obx___obxwidget_.md)), to automatically update whenever the underlying data changes.

The `T` in `Rx<T>` is a placeholder for the type of data the variable will hold, like `int`, `String`, `bool`, or even your own custom classes.

## How to Create and Use Reactive Variables

Let's see how to create and use these "magic" variables. The most common way is by using the `.obs` extension on a standard Dart value.

### 1. Creating a Reactive Variable

To make a regular variable reactive, you simply add `.obs` to its initial value.

**For a number (integer):**

```dart
import 'package:get/get.dart'; // Don't forget to import GetX

final count = 0.obs; // This is now an RxInt holding 0
// You could also write: final count = RxInt(0);
```
Here, `count` isn't just a regular `int`. It's now a special `RxInt` object that holds the integer value `0` and can notify others when it changes.

**For text (string):**

```dart
final userName = "Guest".obs; // This is an RxString holding "Guest"
// You could also write: final userName = RxString("Guest");
```
Similarly, `userName` is an `RxString`.

**For a boolean (true/false):**

```dart
final isLoggedIn = false.obs; // This is an RxBool holding false
// You could also write: final isLoggedIn = RxBool(false);
```

### 2. Getting the Value

If `count` is an `RxInt`, how do you get the actual integer value out of it? You use the `.value` property.

```dart
final count = 0.obs;
print(count.value); // Output: 0

final userName = "Guest".obs;
print(userName.value); // Output: Guest
```
Think of `.value` as looking at the magic whiteboard to read what's currently written on it.

### 3. Changing the Value (and Ringing the Bell!)

To change the value of a reactive variable, you also assign a new value to its `.value` property. This is the action that "rings the bell."

```dart
final count = 0.obs;
print("Initial count: ${count.value}"); // Output: Initial count: 0

count.value = 5; // You changed the number on the whiteboard!
print("New count: ${count.value}"); // Output: New count: 5
```
When you do `count.value = 5;`, the `count` variable not only updates its internal number but also sends out a notification that its value has changed.

You can also change the value by calling the `Rx` variable like a function:
```dart
final anotherCount = 10.obs;
anotherCount(15); // Same as anotherCount.value = 15;
print(anotherCount.value); // Output: 15
```
This is just a shorthand. Both ways achieve the same result.

### A Simple Example: The Counter Logic

Let's imagine the logic for a simple counter. We won't build the UI yet, just the data part.

```dart
import 'package:get/get.dart';

// 1. Create a reactive variable for our count
final magicCounter = 0.obs;

void incrementCounter() {
  // 2. Change its value
  magicCounter.value++; // This rings the bell!
  print("Counter is now: ${magicCounter.value}");
}

void main() {
  print("Counter starts at: ${magicCounter.value}");
  incrementCounter(); // Call the function to change the value
  incrementCounter();
}
```
**What happens?**
1.  `magicCounter` is created as an `RxInt` initialized to `0`.
2.  When `incrementCounter()` is called, `magicCounter.value++` increases the stored integer and notifies any listeners.
3.  The `print` statement shows the updated value.

Output:
```
Counter starts at: 0
Counter is now: 1
Counter is now: 2
```
Right now, only our `print` statements are "listening" in a very basic way. In the [next chapter](03_obx___obxwidget_.md), we'll see how to make Flutter UI widgets listen and update automatically!

## Under the Hood: How Does `.obs` Work?

You might wonder what `.obs` actually does. It's a clever use of Dart's "extension methods."

When you write `0.obs`, GetX has an extension on the `int` type that looks something like this (simplified):

```dart
// From: get_rx/src/rx_types/rx_core/rx_impl.dart (simplified concept)
extension IntExtension on int {
  RxInt get obs => RxInt(this); // 'this' refers to the integer itself
}
```
This code basically says: "If you see `.obs` after an integer, create a new `RxInt` object and give it that integer's value." Similar extensions exist for `String`, `bool`, `double`, and even a generic `Rx<T>` for any object via `T.obs`.

The `RxInt`, `RxString`, etc., classes (which generally inherit from `_RxImpl<T>`) are special classes that manage an internal value and have a built-in mechanism to notify listeners.

Here's a simplified step-by-step of what happens when you change an `Rx` variable's value:

```mermaid
sequenceDiagram
    participant YourCode as Your App Code
    participant RxVariable as count (RxInt)
    participant RxImpl as Internal Logic (_RxImpl)
    participant Listeners as Potential UI (e.g., Obx)

    YourCode->>RxVariable: count.value = 1
    Note over RxVariable: This calls the 'set value' logic
    RxVariable->>RxImpl: Pass new value (1)
    RxImpl->>RxImpl: Store new value (1) internally
    RxImpl->>RxImpl: Check: Has value actually changed?
    alt Value Changed
        RxImpl-->>Listeners: Notifies all listeners (rings the bell!)
        Listeners-->>RxVariable: (Later) Asks RxVariable for its new .value
    end
```

1.  **You assign to `.value`**: `count.value = 1;`
2.  **Setter is called**: The `RxInt` class (or its parent `_RxImpl` found in `get_rx/src/rx_types/rx_core/rx_impl.dart`) has a special `set value(newValue)` method.
3.  **Value Check**: This setter first checks if the `newValue` is actually different from the current stored value. If it's the same, it usually does nothing to avoid unnecessary notifications.
4.  **Store New Value**: If the value is different, it updates its internal storage.
5.  **Notify Listeners**: This is the magic part! The class then triggers a notification. Internally, it often uses a `StreamController` (from `dart:async`). When you change `.value`, it essentially adds the new value to its stream using something like `subject.add(newValue)` after updating its internal `_value`.
    ```dart
    // Highly simplified concept from RxObjectMixin in get_rx/src/rx_types/rx_core/rx_impl.dart
    // and GetListenable in get_state_manager/src/rx_flutter/rx_notifier.dart

    // In GetListenable:
    // StreamController<T>? _controller;
    // T _value;
    // void refresh() { _controller?.add(_value); }

    // In RxObjectMixin (which uses GetListenable):
    set value(T val) {
      if (_value == val && !firstRebuild) return; // _value is from GetListenable
      firstRebuild = false;
      super.value = val; // This typically calls GetListenable's setter, which then calls refresh()
                         // `super.value = val;` roughly does:_value = val; refresh();
    }
    ```
    The `super.value = val;` line in `RxObjectMixin`'s setter calls the setter in its parent class (`GetListenable`), which updates the internal `_value` and then calls `refresh()`. The `refresh()` method then typically adds the new value to an internal stream (`_controller?.add(_value);`), effectively "ringing the bell."

Any widget designed to listen to these streams (like `Obx`) will then pick up this notification.

## Different Kinds of Rx Variables

GetX provides several pre-built `Rx` types for convenience:

*   **Primitives:**
    *   `RxInt(initialValue)` or `initialValue.obs` for integers.
    *   `RxDouble(initialValue)` or `initialValue.obs` for doubles.
    *   `RxString(initialValue)` or `initialValue.obs` for strings.
    *   `RxBool(initialValue)` or `initialValue.obs` for booleans.
*   **Collections (these are a bit more advanced as they react to internal changes too):**
    *   `RxList<T>([])` or `[].obs` for lists.
    *   `RxMap<K, V>({})` or `{}.obs` for maps.
    *   `RxSet<T>({})` or `{}.obs` for sets.
*   **Generic `Rx<T>`:**
    *   For any other type, including your custom classes:
        ```dart
        class User {
          String name;
          User(this.name);
        }

        final user = User("Alice").obs; // user is now an Rx<User>
        // or: final user = Rx<User>(User("Alice"));

        print(user.value.name); // Output: Alice
        user.value.name = "Bob";
        user.refresh(); // For complex objects, you might need to call refresh()
                        // or use user.update((val) { val.name = "Bob"; });
                        // to ensure listeners are notified of internal changes.
        print(user.value.name); // Output: Bob
        ```
    For changes *inside* a custom object held by `Rx<T>`, like changing `user.value.name`, GetX might not automatically know the object's internal state changed. In such cases, you can call `user.refresh()` to manually trigger the "bell," or use the `update()` method: `user.update((currentUser) { currentUser.name = "Bob"; });` which handles the refresh for you.

## Conclusion

You've now learned about `Rx<T>` variables  the "magic whiteboards" of GetX! They are special variables, easily created with `.obs`, that automatically notify anyone interested when their `.value` changes. This is the foundation of reactive programming in GetX and is crucial for building UIs that update themselves effortlessly.

These reactive variables are often managed within [GetxController](05_getxcontroller_.md) classes (which we'll cover later), making state management clean and powerful.

In the [next chapter, Chapter 3: Obx / ObxWidget](03_obx___obxwidget_.md), we'll see how to use `Obx` widgets to make your UI actually listen to these `Rx<T>` variables and update automatically when that magic bell rings!
---
# Chapter 3: Obx / ObxWidget

In [Chapter 2: Rx<T> (Reactive Variables)](02_rx_t___reactive_variables__.md), we discovered `Rx<T>` variables, our "magic whiteboards" that can signal when their data changes. That's fantastic for managing data, but how do we make our app's screen (the User Interface or UI) automatically show these changes?

Imagine you have a score in your game, stored in an `RxInt`. When the score increases, you want the score display on the screen to update instantly, without you having to write complex code to manually refresh it. This is where `Obx` comes in!

## Meet `Obx`: The Smart Picture Frame for Your UI

`Obx` (and its underlying base, `ObxWidget`) is a special Flutter widget provided by GetX. Its job is simple but powerful: it "watches" any reactive variables (`Rx<T>`) you use inside it and automatically rebuilds itself to show the new data whenever those variables change.

Remember our "magic whiteboard" (`Rx<T>`) from the last chapter?
Think of `Obx` as a **smart digital picture frame** that's wirelessly connected to that whiteboard.
*   You tell the `Obx` frame which part of the whiteboard to display (e.g., the score).
*   Whenever someone updates the score on the whiteboard (`Rx<T>` variable changes), the `Obx` frame *instantly* gets the new score and displays it.

This means your UI stays perfectly in sync with your app's state, efficiently and with very little code.

## How to Use `Obx`

Using `Obx` is wonderfully straightforward. You wrap the part of your UI that depends on a reactive variable with an `Obx` widget.

Let's build a very simple counter app to see it in action.

### 1. First, We Need a Reactive Variable

As we learned in [Chapter 2: Rx<T> (Reactive Variables)](02_rx_t___reactive_variables__.md), we create a reactive variable using `.obs`. Let's make a counter:

```dart
import 'package:get/get.dart'; // For .obs and Obx

final counter = 0.obs; // Our reactive integer, starting at 0
```
This `counter` is our "magic whiteboard" that will hold the current count.

### 2. Use `Obx` to Display the Reactive Variable

Now, let's use the `Obx` widget to display the value of `counter`. `Obx` takes a builder function. This function should return the widget(s) that depend on your reactive data.

Crucially, you **must** access the `.value` of your `Rx` variable *inside* this builder function for `Obx` to know which variable to watch.

```dart
// Inside your widget's build method:
Obx(() {
  // This Text widget will rebuild whenever 'counter.value' changes
  return Text("Button presses: ${counter.value}");
})
```
Here, `Obx` is our "smart picture frame." The builder function `() { return Text(...); }` tells the frame *what* to display. Because we used `counter.value` inside it, `Obx` knows to watch the `counter` variable.

### 3. Putting It All Together: A Simple Reactive Page

Let's see a complete, minimal example. We'll have a text display for the counter and a button to increment it.

```dart
import 'package:flutter/material.dart';
import 'package:get/get.dart';

// 1. Our reactive variable (could be in a GetxController later)
final counter = 0.obs;

class CounterPage extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(title: Text("Obx Counter Demo")),
      body: Center(
        // 2. Use Obx to wrap the widget that displays reactive data
        child: Obx(() {
          return Text(
            "Count: ${counter.value}", // Access .value here!
            style: TextStyle(fontSize: 28),
          );
        }),
      ),
      floatingActionButton: FloatingActionButton(
        onPressed: () {
          // 3. Change the reactive variable's value
          counter.value++;
        },
        child: Icon(Icons.add),
      ),
    );
  }
}
```

**What happens?**

1.  The page loads, `counter.value` is `0`. The `Obx` widget runs its builder function for the first time, and `Text("Count: 0")` is displayed.
2.  You tap the `+` button.
3.  The `onPressed` callback executes: `counter.value++`.
    *   The value of `counter` changes (e.g., from `0` to `1`).
    *   Because `counter` is an `RxInt` (a "magic whiteboard"), it "rings a bell," notifying its listeners that it has changed.
4.  The `Obx` widget, being a "smart picture frame" listening to `counter`, hears this bell!
5.  `Obx` automatically re-runs its builder function: `() { return Text("Count: ${counter.value}"); }`.
6.  This time, `counter.value` is `1`, so a new `Text("Count: 1")` widget is created and displayed.

The UI updates automatically, just like magic! You didn't have to call `setState()` or manually tell the UI to refresh.

### Important: Only Use Rx Variables *Inside* `Obx`'s Builder

`Obx` is smart, but it's not a mind reader. It only knows to rebuild if a reactive variable *that it has been told to observe* changes. It figures this out by tracking which reactive variables have their `.value` accessed *directly within its builder function*.

```dart
// GOOD: 'name.value' is inside Obx's builder
final name = "User".obs;
Obx(() => Text(name.value))

// BAD: If 'name.value' is not accessed inside, Obx won't react.
// (This would likely throw an ObxError if no other Rx var is accessed)
final name = "User".obs;
String currentName = name.value; // Accessed outside Obx's scope of observation
Obx(() => Text(currentName)) // Obx doesn't know about 'name' here
```

If you use an `Obx` widget and don't access any `.value` of an `Rx` variable inside its builder, GetX will usually show you an `ObxError` in the console, reminding you that `Obx` isn't observing anything.

```
[Get] the improper use of a GetX has been detected.
You should only use GetX or Obx for the specific widget that will be updated.
If you are seeing this error, you probably did not insert any observable variables into GetX/Obx...
```
This error message comes from the `ObxError` class defined in `get_state_manager/src/simple/list_notifier.dart`.

## Under the Hood: How Does `Obx` Work Its Magic?

It might seem like magic, but it's clever programming. Here's a simplified idea:

1.  **Subscription:** When an `Obx` widget is built for the first time, it prepares to listen. As its builder function executes, any `RxVariable.value` you access signals back to the `Obx` (via an internal `Notifier` system) saying, "Hey, Obx, I'm being read here! Please listen to me for changes." The `Obx` widget then subscribes to that `RxVariable`.
2.  **Value Change:** You change an `RxVariable` (e.g., `counter.value++`).
3.  **Notification:** The `RxVariable` "rings its bell" and notifies all its subscribers (including our `Obx` widget) that its value has changed.
4.  **Rebuild:** The `Obx` widget, upon receiving this notification, knows it needs to update. It schedules a rebuild, which simply means it calls its builder function again. Because the builder function now gets the new value from the `RxVariable`, the UI updates.

Here's a visual representation:

```mermaid
sequenceDiagram
    participant UserAction as User Taps Button
    participant RxVariable as counter (RxInt)
    participant ObxWidget as Obx Widget
    participant FlutterEngine as Flutter Engine

    Note over ObxWidget, RxVariable: Initial build: Obx reads counter.value, subscribes to counter.
    UserAction->>RxVariable: counter.value++
    RxVariable->>RxVariable: Internal value updates
    RxVariable-->>ObxWidget: Notifies Obx about the change
    ObxWidget->>ObxWidget: Schedules its builder to re-run
    ObxWidget->>RxVariable: Reads new counter.value (e.g., 1)
    ObxWidget-->>FlutterEngine: Provides new UI (e.g., Text("Count: 1"))
    FlutterEngine-->>UserAction: UI Updates on Screen
```

Let's peek at some (simplified) relevant code snippets:

`Obx` itself is quite simple. It extends `ObxWidget` (which extends `ObxStatelessWidget`).
```dart
// From: get_state_manager/src/rx_flutter/rx_obx_widget.dart
class Obx extends ObxWidget {
  final WidgetCallback builder; // Your () => Widget function
  const Obx(this.builder, {super.key});

  @override
  Widget build(BuildContext context) {
    return builder(); // It just calls your function!
  }
}
```
The real magic happens in `ObxStatelessWidget` and its `ObxElement`, which uses a mixin called `StatelessObserverComponent` (from `get_state_manager/src/simple/simple_builder.dart`).

```dart
// From: get_state_manager/src/simple/simple_builder.dart (simplified)
mixin StatelessObserverComponent on StatelessElement {
  List<Disposer>? disposers = <Disposer>[]; // To store cleanup functions

  void getUpdate() {
    // If I'm told to update, I tell Flutter to rebuild me!
    scheduleMicrotask(markNeedsBuild);
  }

  @override
  Widget build() {
    // Before calling the user's Obx builder (super.build),
    // set up the Notifier to catch Rx reads.
    return Notifier.instance.append(
        NotifyData(disposers: disposers!, updater: getUpdate),
        super.build // This eventually calls your Obx(() => Text(...))
    );
  }

  @override
  void unmount() { // When Obx is removed from the screen
    super.unmount();
    for (final disposer in disposers!) {
      disposer(); // Clean up subscriptions
    }
    disposers!.clear();
    disposers = null;
  }
}
```
When `yourRxVariable.value` is accessed *inside* the `Obx` builder (during `super.build` call above):
1.  The `Rx` variable's getter calls `reportRead()`. This method is mixed into `Rx` types from `ListNotifierSingleMixin` (in `get_state_manager/src/simple/list_notifier.dart`).
    ```dart
    // From: get_rx/src/rx_types/rx_core/rx_impl.dart (RxObjectMixin's value getter)
    // Simplified concept of what Rx's .value getter does
    T get value {
      reportRead(); // "I'm being read!"
      return _internalValue;
    }
    ```
2.  `reportRead()` calls `Notifier.instance.read(this)` (`this` refers to the `Rx` variable itself).
    ```dart
    // From: get_state_manager/src/simple/list_notifier.dart
    // (Inside ListNotifierSingleMixin)
    @protected
    void reportRead() {
      Notifier.instance.read(this);
    }
    ```
3.  `Notifier.instance.read()` checks the `_notifyData` that `StatelessObserverComponent.build()` set up. It finds the `getUpdate` method of our `Obx` widget and subscribes it to the `Rx` variable.
    ```dart
    // From: get_state_manager/src/simple/list_notifier.dart (Notifier class)
    void read(ListNotifierSingleMixin rxVariable) {
      final getStateUpdateFn = _notifyData?.updater; // This is Obx's getUpdate()
       // If Obx's getUpdate is available and not already listening to this rxVariable:
      if (getStateUpdateFn != null && !rxVariable.containsListener(getStateUpdateFn)) {
        // Tell rxVariable: "When you change, call Obx's getUpdate()"
        Disposer disposer = rxVariable.addListener(getStateUpdateFn);
        // And remember how to unsubscribe later
        _notifyData?.disposers.add(disposer);
      }
    }
    ```
So, when `RxVariable.value` changes later, it calls `refresh()` (from `ListNotifierSingleMixin`), which notifies its listeners. One of these listeners is the `Obx` widget's `getUpdate` method, causing the `Obx` widget to rebuild!

## What is `ObxWidget` then?

You'll mostly use `Obx`. `ObxWidget` is simply the base class that `Obx` (and `ObxValue`, another similar widget) extends. It provides the common reactive machinery. Advanced users could extend `ObxWidget` to create their own custom reactive widgets, but for most day-to-day tasks, `Obx` is all you need.

## Conclusion

You've now unlocked a cornerstone of GetX's reactivity: the `Obx` widget! It's your "smart picture frame" that automatically updates your UI when the underlying `Rx<T>` reactive variables change. This makes building dynamic and responsive UIs incredibly simple and efficient.

Typically, your `Rx<T>` variables will live inside a [GetxController](05_getxcontroller_.md) (which we'll cover soon) to keep your UI logic neatly organized. `Obx` then becomes the bridge that connects your controller's state to your visual widgets.

But what if you want to react to changes in `Rx<T>` variables *without* updating the UI? For example, maybe you want to log a message or make an API call when a value changes. For that, GetX provides something called "Workers." Let's explore those in the [next chapter, Chapter 4: Workers](04_workers_.md).
---
# Chapter 4: Workers

In [Chapter 3: Obx / ObxWidget](03_obx___obxwidget_.md), we saw how `Obx` acts like a smart picture frame, automatically updating our UI when reactive variables change. That's perfect for what users see! But what if we want to perform actions *behind the scenes* when our data changes? For instance, what if we need to fetch new data from the internet when a user's ID changes, or automatically save their input after they've stopped typing for a moment? This is where GetX Workers come in!

## What Problem Do Workers Solve?

Imagine you have a reactive variable, say, `userId.obs`. When this `userId` changes, you might want to:
*   Log the change for debugging.
*   Fetch the new user's profile from a server.
*   Update some other non-UI related data.

You don't want to put this logic directly in your UI-building code because it's not about drawing pixels on the screen. It's about reacting to data changes with *side effects*.

**Workers** are your dedicated helpers for exactly this. They are functions that "listen" to your [Rx<T> (Reactive Variables)](02_rx_t___reactive_variables__.md) and execute a callback function when specific events or conditions occur on those variables. Think of them as automated sentinels, tirelessly watching your reactive data streams. When a predefined rule is met (like "the data changed!" or "the user stopped typing!"), they spring into action, independent of direct UI rendering.

## Meet the Workers: Your Automated Sentinels

GetX provides a few different types of Workers, each designed for a specific kind of listening task. Let's meet the main ones: `ever`, `once`, `debounce`, and `interval`.

All these workers are typically set up within the `onInit()` method of a [GetxController](05_getxcontroller_.md) (which we'll cover in the next chapter), or anywhere you have access to your reactive variables and need to react to their changes.

### 1. `ever`: The Ever-Watchful Sentinel

The `ever` worker executes its callback function **every time** the reactive variable it's watching changes.

Let's say we have a reactive variable for a username:
```dart
import 'package:get/get.dart';

final username = 'Guest'.obs; // Our reactive username
```
Now, let's set up an `ever` worker to print a message whenever `username` changes:
```dart
// Typically, you'd do this in onInit() of a GetxController
ever(username, (String newName) {
  print("Username changed to: $newName");
});

// Let's simulate some changes:
username.value = 'Alice';
username.value = 'Bob';
```
**What happens?**
Every time `username.value` is assigned a new value, the `ever` worker's callback `(String newName) { ... }` is triggered.
Output:
```
Username changed to: Alice
Username changed to: Bob
```

You can also add a `condition` to `ever`. The callback will only run if the condition is true when the main variable changes.
```dart
final count = 0.obs;

ever(count, (int newCount) {
  print("Count is now $newCount (and it's greater than 2!)");
}, condition: () => count.value > 2); // Only run if count > 2

count.value = 1; // No output
count.value = 3; // Output: Count is now 3 (and it's greater than 2!)
count.value = 4; // Output: Count is now 4 (and it's greater than 2!)
```

### 2. `once`: The One-Time Sentinel

The `once` worker executes its callback function **only the first time** a specific condition (related to the reactive variable) is met. After it runs once, it automatically stops listening.

Imagine you want to show a welcome message only the very first time a user logs in (i.e., `isLoggedIn.value` becomes `true`).
```dart
final isLoggedIn = false.obs;

once(isLoggedIn, (bool loggedInStatus) {
  if (loggedInStatus == true) {
    print("Welcome! You've logged in for the first time (during this session).");
  }
}, condition: () => isLoggedIn.value == true); // Condition to trigger

isLoggedIn.value = true;  // Triggers 'once'
isLoggedIn.value = false; // 'once' won't trigger again
isLoggedIn.value = true;  // 'once' won't trigger again
```
**What happens?**
The callback is executed only when `isLoggedIn.value` changes *and* the condition `isLoggedIn.value == true` is met for the *first time*.
Output:
```
Welcome! You've logged in for the first time (during this session).
```
Even if `isLoggedIn` becomes `true` again later, `once` has done its job and won't fire again.

### 3. `debounce`: The "Wait-and-See" Sentinel

The `debounce` worker is super useful for scenarios like search fields. It waits for a certain period of inactivity before executing the callback. If the variable changes again before the waiting period is over, the timer resets.

Imagine a search bar. You don't want to make an API call for every single letter the user types. Instead, you want to wait until they pause typing.
```dart
final searchQuery = ''.obs;

debounce(searchQuery, (String query) {
  print("User stopped typing. Search for: $query");
  // In a real app, you'd make an API call here: fetchResults(query);
}, time: Duration(milliseconds: 500)); // Wait for 500ms of inactivity

// Simulate typing quickly, then pausing
searchQuery.value = 'h';
searchQuery.value = 'he';
searchQuery.value = 'hel'; // Timer resets each time
// User pauses... after 500ms:
// Output: User stopped typing. Search for: hel
```
**What happens?**
*   User types 'h', then 'e', then 'l' quickly. The `debounce` timer keeps resetting.
*   After 'hel', if the user pauses for 500 milliseconds, the callback `(String query) { ... }` is executed with the latest value ('hel').
*   If they type 'lo' next, the same process repeats.

### 4. `interval`: The "Periodic Check-up" Sentinel

The `interval` worker is a bit like `debounce` but it triggers its callback with the value that the reactive variable had at the *beginning* of the interval, after a specified duration has passed, and *only if* no new changes occurred during that interval (this behavior can be subtle, often `debounce` is what people want for "after a delay"). It's more like "if nothing changes for X time, then act on the value from X time ago".

A more common use of a timed worker might be "check something every X seconds while a condition is true." `interval` is designed to trigger *after* a period of stability. If you rapidly change the value, `interval` might not fire for each change because a new event interrupts the "quiet period" it's waiting for.

Let's consider a scenario where you want to perform an action if a value remains stable for a certain period.
```dart
final status = 'idle'.obs;

interval(status, (String currentStatus) {
  print("Status has been '$currentStatus' for 1 second.");
}, time: Duration(seconds: 1));

status.value = 'processing'; // Worker starts listening
// If 'status' remains 'processing' for 1 second:
// Output: Status has been 'processing' for 1 second.

// If you change it quickly:
// status.value = 'A';
// await Future.delayed(Duration(milliseconds: 200));
// status.value = 'B'; // 'A' might not trigger the interval callback
```
**What happens?**
If `status.value` becomes 'processing' and stays 'processing' for 1 second without any other changes to `status`, the callback will fire. If `status` changes again *within* that 1-second window, the timer for the *previous* value is essentially reset/ignored, and a new interval evaluation potentially begins for the new value. `debounce` is often more intuitive for "do something after a pause."

For `interval`, the primary mechanism is: when an event arrives, it waits for `time`. If another event arrives *before* `time` is up, the first event is effectively ignored by that specific `interval`'s timer. When `time` *does* elapse without a new event, the callback is fired with the value that was present when the `time` period began.


## Disposing of Workers

Workers, like `StreamSubscription`s in Dart, need to be disposed of when they are no longer needed. This is crucial to prevent memory leaks and unwanted behavior, especially if the reactive variable they are listening to outlives the context where the worker was created.

When you create a worker, it returns a `Worker` object. This object has a `dispose()` method:
```dart
final count = 0.obs;
late Worker everWorker; // Declare the worker variable

// In onInit() or similar setup:
everWorker = ever(count, (_) => print('Count changed!'));

// ... later, when this logic is no longer needed (e.g., in onClose() of a GetxController):
void cleanup() {
  everWorker.dispose();
  print("Ever worker disposed.");
}

count.value = 1; // Output: Count changed!
cleanup();
count.value = 2; // No output, because the worker is disposed.
```

It's a common pattern to initialize workers in the `onInit()` method of a [GetxController](05_getxcontroller_.md) and dispose of them in its `onClose()` method. GetX also provides a way to automatically manage this if workers are declared inside a controller, but manual disposal is good practice to understand.

## Under the Hood: How Do Workers... Work?

Workers function by subscribing to the underlying stream of an [Rx<T> (Reactive Variables)](02_rx_t___reactive_variables__.md). Remember from Chapter 2 that `Rx` variables can notify listeners when they change? Workers are specialized listeners.

1.  **Subscription:** When you create a worker (e.g., `ever(myRxVar, callback)`), the worker function internally calls `myRxVar.listen(...)`. This is similar to listening to a Dart `Stream`.
2.  **Event Emission:** When `myRxVar.value` changes, `myRxVar` emits this new value to its listeners.
3.  **Worker Logic:** The worker receives this new value.
    *   For `ever`, it typically checks an optional condition and then calls your callback.
    *   For `once`, it does the same but also cancels its own subscription after the first valid trigger.
    *   For `debounce`, it uses a timer (like the `Debouncer` utility class in GetX). Each new event resets the timer. If the timer completes, the callback is called with the *last* event received.
    *   For `interval`, it also uses a timer. When an event arrives, it starts a timer. If the timer completes *without* a new event arriving, it calls the callback with the event that started that timer.
4.  **Callback Execution:** If the worker's specific logic decides it's time, your provided callback function is executed with the relevant value.

Heres a simplified sequence diagram showing a `debounce` worker in action:

```mermaid
sequenceDiagram
    participant UserAction as User Typing
    participant SearchRx as searchQuery.obs
    participant DebounceWorker as Debounce Logic
    participant YourCallback as (query) => API.search(query)

    UserAction->>SearchRx: searchQuery.value = "flut"
    SearchRx-->>DebounceWorker: Notifies with "flut"
    DebounceWorker->>DebounceWorker: Starts/Resets 500ms timer
    UserAction->>SearchRx: searchQuery.value = "flutter"
    SearchRx-->>DebounceWorker: Notifies with "flutter"
    DebounceWorker->>DebounceWorker: Resets 500ms timer (for "flutter")
    Note over DebounceWorker: User pauses typing...
    DebounceWorker-->>YourCallback: After 500ms, calls YourCallback("flutter")
```

The actual implementation can be found in `get_rx/src/rx_workers/rx_workers.dart`.
For example, the `ever` worker (simplified):
```dart
// From: get_rx/src/rx_workers/rx_workers.dart (conceptual)
Worker ever<T>(
  GetListenable<T> listener, // This is your Rx variable
  WorkerCallback<T> callback, {
  dynamic condition = true, // Optional condition
  /* ... other params ... */
}) {
  // 1. Listen to the Rx variable's stream
  StreamSubscription sub = listener.listen(
    (event) { // 'event' is the new value from the Rx variable
      // 2. Check the condition
      if (_conditional(condition)) { // _conditional is a helper
        // 3. Execute your callback
        callback(event);
      }
    },
    /* ... onError, onDone ... */
  );
  // 4. Return a Worker object that can be used to cancel the subscription
  return Worker(sub.cancel, '[ever]');
}
```
The `_conditional` function (also in `rx_workers.dart`) is a utility that evaluates the `condition` argument, which can be a `bool` or a `bool Function()`.

The `debounce` worker uses a `Debouncer` utility class (found in `get_rx/src/rx_workers/utils/debouncer.dart`):
```dart
// From: get_rx/src/rx_workers/rx_workers.dart (conceptual)
Worker debounce<T>(
  GetListenable<T> listener,
  WorkerCallback<T> callback, {
  Duration? time, /* ... */
}) {
  // 1. Create a Debouncer instance
  final newDebouncer = Debouncer(delay: time ?? Duration(milliseconds: 800));
  StreamSubscription sub = listener.listen(
    (event) {
      // 2. When Rx variable changes, call the debouncer
      newDebouncer(() {
        // 3. Debouncer will execute this only after the 'delay'
        callback(event);
      });
    }, /* ... */
  );
  return Worker(sub.cancel, '[debounce]');
}
```
The `Debouncer` class itself manages a `Timer` to achieve the "wait for inactivity" behavior.

## Conclusion

Workers (`ever`, `once`,  `debounce`, `interval`) are powerful tools in GetX for reacting to changes in your [Rx<T> (Reactive Variables)](02_rx_t___reactive_variables__.md) by performing side effects like API calls, logging, or triggering other logic that isn't directly tied to UI updates. They help you keep your code clean by separating these concerns. Remember to always `dispose()` your workers when they're no longer needed to keep your app running smoothly.

Now that we've seen how to create reactive data (`Rx<T>`), how to make our UI react to it (`Obx`), and how to perform side effects based on it (Workers), it's time to look at how to organize all this reactive goodness. In the [next chapter, Chapter 5: GetxController](05_getxcontroller_.md), we'll explore `GetxController`, the recommended way to encapsulate your business logic and reactive state.
---
# Chapter 5: GetxController

In [Chapter 4: Workers](04_workers_.md), we learned how to perform actions behind the scenes when_our_reactive data changes. That's great for side effects! But as your app grows, you'll find yourself asking:
*   Where should I keep my app's data (like that `counter.obs` or `searchQuery.obs`)?
*   Where should the functions that change this data (like `incrementCounter()` or `performSearch()`) live?
*   How can I neatly organize all this for a specific feature or screen?

Simply putting reactive variables and functions globally or directly in UI widgets can get messy quickly. We need a dedicated "manager" for different parts of our application. That's where `GetxController` shines!

## What is a GetxController? The Brain of Your Feature!

A `GetxController` is like the **manager** or **"brain"** for a specific part of your app's screen or a particular feature. Think of it as a dedicated organizer. Its main jobs are:

1.  **Holding Data (State):** It stores the variables (often [Rx<T> (Reactive Variables)](02_rx_t___reactive_variables__.md)) that your feature needs. For example, in a counter feature, it would hold the current count.
2.  **Holding Business Logic (Functions):** It contains the functions that operate on this data or perform actions related to the feature. For the counter, this would be the `increment()` function.
3.  **Managing Lifecycle:** It has special methods that get called at different points in its life (like when it's created or destroyed), allowing you to set things up or clean up resources.
4.  **Notifying UI (with `update()`):** When its data changes (especially non-reactive data, or if you need more control), the controller can tell the UI to update by calling its `update()` method. This is primarily used with a widget called `GetBuilder`, which we'll explore in [Chapter 7: GetBuilder](07_getbuilder_.md).

Imagine a scene in a play. The `GetxController` is like the **director** of that scene. It knows the script (logic), manages the actors' states (data), and tells them when and how to change their appearance or behavior.

## How to Use a GetxController

Let's go back to our simple counter example and see how we can organize it using a `GetxController`.

### 1. Creating Your Controller

First, you create a new Dart class that `extends GetxController`.

```dart
// counter_controller.dart
import 'package:get/get.dart';

class CounterController extends GetxController {
  // 1. Hold your reactive data (state)
  final count = 0.obs; // Our familiar RxInt

  // 2. Define your business logic (functions)
  void increment() {
    count.value++;
    // If we were using GetBuilder and non-Rx state, we might call update() here.
  }
}
```
**Explanation:**
*   We created `CounterController` that inherits from `GetxController`.
*   Inside it, we moved our reactive `count` variable.
*   We also moved the `increment` logic into a method within the controller. Now, all things related to the counter's state and logic are neatly bundled together!

### 2. Making the Controller Available (Quick Peek at Dependency Injection)

Before your UI can use the controller, GetX needs to know about it. You "register" your controller, usually when the feature or screen is first needed. The most common way is using `Get.put()`:

```dart
// Somewhere before you need the controller, e.g., when navigating to the page
Get.put(CounterController());
```
**Explanation:**
*   `Get.put(CounterController());` creates an instance of `CounterController` and makes it available for other parts of your app to find.
*   We'll dive deep into `Get.put()` and other ways to manage controllers in [Chapter 6: Dependency Access (Binder, Bind.of, Get.find/put)](06_dependency_access__binder__bind_of__get_find_put__.md). For now, just know this step is necessary.

### 3. Accessing and Using the Controller in Your UI

Once the controller is "put", your UI widgets can find and use it. You use `Get.find()` for this:

```dart
// In your widget file (e.g., counter_page.dart)
import 'package:flutter/material.dart';
import 'package:get/get.dart';
import 'counter_controller.dart'; // Import your controller fine

class CounterPage extends StatelessWidget {
  // Find the instance of CounterController that GetX is managing
  final CounterController controller = Get.find<CounterController>();

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(title: Text("GetxController Counter")),
      body: Center(
        child: Obx(() { // Obx watches reactive variables
          return Text(
            "Count: ${controller.count.value}", // Use controller's data
            style: TextStyle(fontSize: 28),
          );
        }),
      ),
      floatingActionButton: FloatingActionButton(
        onPressed: () {
          controller.increment(); // Call controller's method
        },
        child: Icon(Icons.add),
      ),
    );
  }
}
```
**Explanation:**
*   `final CounterController controller = Get.find<CounterController>();` asks GetX to give us the instance of `CounterController` it's managing.
*   Inside the `Obx` widget (from [Chapter 3: Obx / ObxWidget](03_obx___obxwidget_.md)), we access `controller.count.value` to display the reactive count.
*   In `onPressed` for the button, we call `controller.increment()` to execute the logic defined in our controller.

Now, run this app. It works just like our previous counter, but the state and logic are much better organized within `CounterController`!

### Controller Lifecycle: `onInit()`, `onReady()`, `onClose()`

`GetxController`s have a lifecycle, meaning special methods are called automatically at certain points:

*   **`onInit()`:** Called right after the controller is allocated in memory (after its constructor) but *before* the widget that uses it is built for the first time. This is the perfect place to:
    *   Initialize data.
    *   Set up [Workers](04_workers_.md) to listen to reactive variable changes.
    *   Make initial API calls.

    ```dart
    class MyController extends GetxController {
      var data = ''.obs;

      @override
      void onInit() {
        super.onInit(); // Always call super.onInit()
        print("MyController onInit!");
        // Example: Fetch initial data or set up a worker
        ever(data, (_) => print("Data changed in MyController: ${data.value}"));
        data.value = "Initial Data";
      }
    }
    ```
    Output (when `MyController` is `put`):
    ```
    MyController onInit!
    Data changed in MyController: Initial Data
    ```

*   **`onReady()`:** Called a moment *after* the widget associated with this controller is rendered on screen for the first time. Useful if you need to do something *after* the UI is visible (e.g., show an intro animation or dialog).

    ```dart
    class MyController extends GetxController {
      @override
      void onReady() {
        super.onReady(); // Always call super.onReady()
        print("MyController onReady! UI is now visible.");
        // Get.snackbar("Hint", "Controller is ready and UI is built!");
      }
    }
    ```

*   **`onClose()`:** Called just before the controller is removed from memory. This happens when it's no longer needed (e.g., the screen is closed, or `Get.delete<MyController>()` is called). This is crucial for:
    *   Cleaning up resources.
    *   Disposing of [Workers](04_workers_.md).
    *   Canceling stream subscriptions or closing database connections to prevent memory leaks.

    ```dart
    class MyController extends GetxController {
      late Worker _dataWorker;
      var data = ''.obs;

      @override
      void onInit() {
        super.onInit();
        _dataWorker = ever(data, (_) => print("Data: ${data.value}"));
      }

      @override
      void onClose() {
        print("MyController onClose! Cleaning up.");
        _dataWorker.dispose(); // IMPORTANT: Dispose workers!
        super.onClose(); // Always call super.onClose()
      }
    }
    ```
    **Explanation:** If you create workers, timers, or other listeners in `onInit()`, you *must* clean them up in `onClose()` to avoid problems.

### The `update()` Method: For Manual UI Refreshes

So far, our counter UI updates automatically because `count` is an `RxInt` and we're using `Obx`. `Obx` rebuilds when `count.value` changes.

However, sometimes you might have:
*   Regular Dart variables (not `.obs`) in your controller.
*   Complex logic where you want to decide *exactly* when to tell the UI to refresh.

For these "manual" updates, `GetxController` provides the `update()` method. When you call `update()` from within your controller, it signals to any `GetBuilder` widgets listening to this controller that they should rebuild.

```dart
class ManualUpdateController extends GetxController {
  int manualCount = 0; // A regular int, not reactive

  void incrementManualCount() {
    manualCount++;
    update(); // Tell listening GetBuilders to refresh!
    print("Manual count incremented: $manualCount. Update called.");
  }
}
```
**Explanation:**
*   `manualCount` is just a normal integer.
*   When `incrementManualCount()` is called, it changes `manualCount` and then calls `update()`.
*   This `update()` call will trigger any `GetBuilder` associated with this `ManualUpdateController` to rebuild itself and display the new `manualCount`.

We'll learn all about `GetBuilder` in [Chapter 7: GetBuilder](07_getbuilder_.md). For now, understand that `update()` is the controller's way of manually triggering UI refreshes for widgets that use `GetBuilder`.

## Under the Hood: What Makes a GetxController Tick?

A `GetxController` isn't just an empty class. It gets its powers from a few key pieces in the GetX framework:

*   It `extends ListNotifier` (from `get_state_manager/src/simple/list_notifier.dart`).
*   `ListNotifier` mixes in `GetLifeCycleMixin` (from `get_state_manager/src/rx_flutter/rx_notifier.dart` indirectly through its own mixins or base classes).

Let's see what these provide:

1.  **`GetLifeCycleMixin`:** This mixin is responsible for the lifecycle methods (`onInit`, `onReady`, `onClose`). When a controller is `put` using `Get.put()`, GetX's dependency management system knows it's a `GetLifeCycleMixin` and hooks into its lifecycle, calling these methods at the appropriate times. It also handles cleaning up the controller (calling `onClose`) when it's deleted (e.g., with `Get.delete()`).

2.  **`ListNotifier` (and its `ListNotifierSingleMixin`):** This is the heart of the manual `update()` mechanism.
    *   It maintains a list of listeners (callbacks).
    *   When you call `update()` in your controller, it actually calls `refresh()` (a method from `ListNotifierSingleMixin`).
    *   `refresh()` then iterates through all its registered listeners and calls them.
    *   Widgets like `GetBuilder` (which we'll see in [Chapter 7: GetBuilder](07_getbuilder_.md)) add themselves as listeners to the controller. So, when `refresh()` is called, the `GetBuilder`'s "update me" function gets executed, causing it to rebuild.

Here's a simplified conceptual flow for the `update()` mechanism:

```mermaid
sequenceDiagram
    participant UserAction as User Taps Button
    participant YourController as MyController
    participant ListNotifierMixin as (Part of MyController)
    participant GetBuilderWidget as GetBuilder (UI Widget)

    UserAction->>YourController: Calls controller.someMethod()
    YourController->>YourController: Logic updates non-Rx state (e.g., `manualCount++`)
    YourController->>ListNotifierMixin: Calls this.update()
    Note over ListNotifierMixin: update() internally calls refresh()
    ListNotifierMixin-->>GetBuilderWidget: Notifies its listener (the GetBuilder's update function)
    GetBuilderWidget->>GetBuilderWidget: Rebuilds itself to show new state
```

The actual code in `GetxController` for `update()` is quite simple:
```dart
// From: get_state_manager/src/simple/get_controllers.dart
abstract class GetxController extends ListNotifier with GetLifeCycleMixin {
  void update([List<Object>? ids, bool condition = true]) {
    if (!condition) {
      return;
    }
    if (ids == null) {
      refresh(); // From ListNotifierSingleMixin
    } else {
      for (final id in ids) {
        refreshGroup(id); // Also from ListNotifier, for targeted updates
      }
    }
  }
}
```
And `refresh()` in `ListNotifierSingleMixin` (simplified):
```dart
// From: get_state_manager/src/simple/list_notifier.dart
mixin ListNotifierSingleMixin on Listenable {
  List<GetStateUpdate>? _updaters = <GetStateUpdate>[]; // List of listeners

  // ... other methods ...

  @protected
  void refresh() {
    // Take a copy of listeners, in case list changes during iteration
    final list = _updaters?.toList() ?? [];
    for (var element in list) {
      element(); // Call each listener (e.g., GetBuilder's update function)
    }
  }
}
```
So, `GetxController` elegantly combines lifecycle management with a notification system to manage state and communicate changes to the UI.

## Conclusion

You've now met `GetxController`, the cornerstone for organizing your application's state and logic in GetX! It acts as a dedicated manager for your features or screen sections, holding data (often reactive), business logic, and providing lifecycle hooks (`onInit`, `onClose`) for setup and cleanup. You also learned about its `update()` method, which is essential for manually refreshing UI parts when using `GetBuilder`.

By using `GetxController`, you can create cleaner, more maintainable, and better-structured Flutter applications.

We've seen how to *create* controllers and *make them available* with a quick `Get.put()`. But how exactly does GetX manage these controllers? How many ways are there to "put" and "find" them? That's what we'll explore next in [Chapter 6: Dependency Access (Binder, Bind.of, Get.find/put)](06_dependency_access__binder__bind_of__get_find_put__.md).
---
# Chapter 6: Dependency Access (Binder, Bind.of, Get.find/put)

In [Chapter 5: GetxController](05_getxcontroller_.md), we learned how to organize our app's "brains"its data and logicinto `GetxController` classes. Now, once we have these controllers (our dependencies), how do we make them available to the parts of our app (usually widgets) that need them? How does a widget get a "wire" to its controller?

GetX provides a flexible system for this, acting like a combination of a central warehouse and local delivery services for your app's dependencies. Let's explore the main ways: `Get.put()`, `Get.find()`, `Binder`, and `Bind.of(context)`.

## What Problem Are We Solving?

Imagine you have a `UserProfileController` that manages user data.
```dart
// A simple controller (more details in Chapter 5)
class UserProfileController extends GetxController {
  final userName = 'Guest'.obs;
  void login(String name) {
    userName.value = name;
  }
}
```
Several different widgets in your app might need to display the `userName` or call the `login` method:
*   A `ProfileHeaderWidget` in the app bar.
*   A `SettingsScreenWidget` deep in the navigation stack.

How do these widgets get access to the *same instance* of `UserProfileController` without manually passing it down through many widget constructors (which is called "prop drilling" and can be messy)? This is where GetX's dependency access tools come in.

## 1. The Global Warehouse: `Get.put()` and `Get.find()`

Think of `Get.put()` and `Get.find()` as your app's central, global warehouse for important items (your controllers or other services).

### `Get.put()`: Storing Your Dependency

`Get.put(SomeClass())` is like taking an instance of `SomeClass` and placing it into a secure, well-organized global storage area managed by GetX. Once "put," this instance is generally available throughout your app. You usually do this when your app starts, or when a feature that needs the controller is first initialized.

```dart
// main.dart or an initialization file
void main() {
  // Put an instance of UserProfileController into GetX's global storage
  Get.put(UserProfileController());
  runApp(MyApp());
}
```
**What happens?**
An instance of `UserProfileController` is created and registered with GetX. By default, `Get.put()` creates a **singleton**, meaning there will only be one instance of `UserProfileController` managed by this global `put`.

### `Get.find()`: Retrieving Your Dependency

`Get.find<SomeClass>()` is like going to the warehouse and asking for the instance of `SomeClass` you stored earlier. GetX will locate it and give it to you.

Any widget, anywhere in your app (after the `Get.put()` has happened), can then get access to that controller:

```dart
// profile_header_widget.dart
class ProfileHeaderWidget extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    // Find the globally available UserProfileController
    final userController = Get.find<UserProfileController>();

    return Obx(() => Text("User: ${userController.userName.value}"));
  }
}

// settings_screen_widget.dart
class SettingsScreenWidget extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    // Find the same globally available UserProfileController
    final userController = Get.find<UserProfileController>();

    return ElevatedButton(
      onPressed: () => userController.login("Alice"),
      child: Text("Login as Alice"),
    );
  }
}
```
**What happens?**
Both `ProfileHeaderWidget` and `SettingsScreenWidget` will receive the *exact same instance* of `UserProfileController` that was registered with `Get.put()`. Changes made through one widget (like logging in) will be reflected in the other (the username display updates).

**When to use `Get.put()`/`Get.find()`?**
This global approach is great for dependencies that:
*   Need to be singletons (only one instance throughout the app).
*   Need to be easily accessible from many disparate parts of your application without complex wiring.

### Under the Hood: `Get.put()` and `Get.find()`

As we touched upon in [Chapter 1: Get (Global Access Facade)](01_get__global_access_facade__.md), GetX maintains an internal "Instance Manager" (conceptually, a map where keys are often types and values are the instances).

```mermaid
sequenceDiagram
    participant YourApp as Your App Startup
    participant GetPut as Get.put(UserProfileController())
    participant InstanceManager as GetX Instance Manager
    participant WidgetA as ProfileHeaderWidget
    participant GetFind as Get.find<UserProfileController>()

    YourApp->>GetPut: Calls Get.put(new UserProfileController())
    GetPut->>InstanceManager: Stores UserProfileController instance (e.g., by Type)
    Note over InstanceManager: UserProfileController now in global storage

    WidgetA->>GetFind: Calls Get.find<UserProfileController>()
    GetFind->>InstanceManager: Looks up UserProfileController by Type
    InstanceManager-->>GetFind: Returns stored instance
    GetFind-->>WidgetA: Provides instance to WidgetA
```

1.  **`Get.put(MyController())`**: When you call this, `Get` (via its `GetInstance` powers, mostly in `get_instance/src/get_instance.dart`) takes the `MyController` instance and stores it in a central collection (like a `Map<String, InstanceInternal>`). It often uses the Type of the controller (e.g., "MyController") and an optional "tag" to create a unique key for storage.
2.  **`Get.find<MyController>()`**: This method also uses `GetInstance` to look up the key (Type or Type+tag) in that central collection. If found, it returns the stored instance. If not found, it will throw an error.

This simple yet powerful mechanism is what allows `Get.find()` to retrieve dependencies from anywhere.

## 2. Local Delivery Service: `Binder` and `Bind.of(context)`

Sometimes, a global singleton isn't what you need.
*   What if a specific section of your app requires its *own*, independent instance of a controller?
*   What if you want to provide a dependency only to a specific widget and its children, without polluting the global scope?

This is where `Binder` and `Bind.of(context)` come in, acting like a "local delivery service" for your dependencies. `Binder` is a special widget from GetX (an `InheritedWidget` under the hood) that makes an instance of a controller available to all its descendant widgets in the tree.

### `Binder`: Providing a Dependency Locally

You wrap a part of your widget tree with `Binder` and tell it how to create or find the dependency it should provide.

Let's say you have a `ProductDetailController` that should only exist for a specific `ProductDetailScreen`.

```dart
// product_detail_controller.dart
class ProductDetailController extends GetxController {
  final productId;
  ProductDetailController(this.productId);

  void loadProductDetails() {
    print("Loading details for product ID: $productId");
    // ... fetch details ...
  }
  // ... other product specific logic ...
}

// product_detail_screen.dart
class ProductDetailScreen extends StatelessWidget {
  final String productId;
  ProductDetailScreen({required this.productId});

  @override
  Widget build(BuildContext context) {
    // Binder provides ProductDetailController to its children
    return Binder<ProductDetailController>(
      // 'init' creates the controller when Binder is built
      init: () => ProductDetailController(productId),
      // 'autoRemove: true' (default) means controller is disposed when screen is removed
      child: Scaffold(
        appBar: AppBar(title: Text("Product $productId")),
        body: ProductInfoDisplay(), // A child widget
      ),
    );
  }
}
```
**What happens?**
*   When `ProductDetailScreen` is built, the `Binder` widget is created.
*   The `init: () => ProductDetailController(productId)` function is called, creating a *new* instance of `ProductDetailController` specifically for this screen.
*   This instance is now available to `ProductInfoDisplay` and any other widgets inside this `Binder`'s `child` subtree.

### `Bind.of(context)`: Accessing the Locally Provided Dependency

Descendant widgets can then access this controller using `Bind.of<ControllerType>(context)`.

```dart
// product_info_display.dart (child of ProductDetailScreen's Binder)
class ProductInfoDisplay extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    // Access the ProductDetailController provided by an ancestor Binder
    final controller = Bind.of<ProductDetailController>(context);
    // Or, more conveniently, using an extension:
    // final controller = context.get<ProductDetailController>();

    controller.loadProductDetails(); // Call method on the local controller

    return Center(
      child: Text("Displaying info for product: ${controller.productId}"),
    );
  }
}
```
**What happens?**
*   `Bind.of<ProductDetailController>(context)` (or `context.get<ProductDetailController>()`) looks *up* the widget tree from `ProductInfoDisplay`.
*   It finds the nearest `Binder<ProductDetailController>` ancestor and retrieves the controller instance held by that `Binder`.
*   If you had two different `ProductDetailScreen`s on screen at once (e.g., in a split view), each would have its *own* `ProductDetailController` instance thanks to their respective `Binder`s.

**Important:** `Bind.of(context)` retrieves the dependency. If you also want the widget to rebuild when the controller calls `update()` (as discussed in [Chapter 5: GetxController](05_getxcontroller_.md) for `GetBuilder`), you would typically use `Bind.of(context, rebuild: true)` or its shorthand `context.listen<ProductDetailController>()`. This is what `GetBuilder` uses internally, as we'll see in [Chapter 7: GetBuilder](07_getbuilder_.md).


### Under the Hood: `Binder` and `Bind.of(context)`

`Binder` is essentially a specialized `InheritedWidget`. `InheritedWidget` is Flutter's standard way of passing data down the widget tree efficiently.

```mermaid
sequenceDiagram
    participant WidgetTree as ProductDetailScreen Builds
    participant BinderWidget as Binder<ProductDetailController>
    participant Flutter as Flutter Framework
    participant ChildWidget as ProductInfoDisplay
    participant BindOf as Bind.of(context) / context.get()

    WidgetTree->>BinderWidget: Creates Binder(init: () => ProductDetailController(...))
    BinderWidget->>BinderWidget: Initializes controller via 'init'
    Note over BinderWidget: Stores controller instance internally

    ChildWidget->>BindOf: Calls Bind.of<ProductDetailController>(context)
    BindOf->>Flutter: Asks Flutter: "Find nearest Binder<ProductDetailController> ancestor"
    Flutter-->>BindOf: Returns the found Binder's element
    BindOf->>BinderWidget: Accesses controller from Binder's element
    BinderWidget-->>BindOf: Returns controller instance
    BindOf-->>ChildWidget: Provides instance to ChildWidget
```

1.  **`Binder<T>(init: ..., child: ...)`**:
    *   This widget, defined in `get_state_manager/src/simple/get_state.dart`, extends `InheritedWidget`.
    *   When it's inserted into the tree, its `init` function is called (if provided and the controller isn't already globally available via `Get.put` in some configurations). It creates and holds an instance of your controller `T`.
    *   The `BindElement<T>` (its `Element`) holds the actual controller instance.

2.  **`Bind.of<T>(context)`**:
    *   This static method uses `context.getElementForInheritedWidgetOfExactType<Binder<T>>()`.
    *   This is a standard Flutter mechanism to efficiently find the nearest ancestor `Binder<T>` in the widget tree.
    *   Once found, it retrieves the controller instance from that `Binder`'s element.
    *   If `rebuild: true` is passed (or `context.listen<T>()` is used), it also establishes a dependency, so if that `Binder` later signals an update (because the controller called `update()`), this widget will rebuild.

## Global Warehouse vs. Local Delivery: Which to Choose?

*   **`Get.put()` / `Get.find()` (Global Warehouse):**
    *   **Pros:** Very easy to access truly global singletons from anywhere. Less boilerplate for simple global access.
    *   **Cons:** Can make it harder to track where a dependency is used. Testing can be trickier if everything relies on global state. Can be "too global" if a dependency is only needed in one section.
    *   **Use when:** For app-wide services (ThemeService, ApiService, UserSessionController) that are inherently singletons.

*   **`Binder` / `Bind.of(context)` (Local Delivery):**
    *   **Pros:** Dependencies are scoped to a specific part of the widget tree. Clearer where a dependency comes from (an ancestor `Binder`). Easier to have multiple, independent instances of the same controller type for different UI sections. Integrates naturally with Flutter's widget system and `BuildContext`. Better for testability of individual UI sections.
    *   **Cons:** Requires `BuildContext`. Slightly more verbose for providing the dependency (wrapping with `Binder`).
    *   **Use when:** A controller/dependency is specific to a particular screen or feature area. When you need multiple instancesManaging state for list items where each item might have its own controller. When you want to leverage Flutter's `InheritedWidget` patterns more directly.

Often, a GetX app will use a mix of both!

## Conclusion

You've now learned the key ways GetX helps you manage and access your dependencies:
*   `Get.put()` registers a dependency globally, making it like an item in a central warehouse.
*   `Get.find()` retrieves these globally registered dependencies.
*   `Binder` is an `InheritedWidget` that acts like a local delivery service, providing dependencies to a specific part of your widget tree.
*   `Bind.of(context)` (or context extensions like `context.get<T>()` and `context.listen<T>()`) allows descendant widgets to access these locally provided dependencies.

Understanding these mechanisms is crucial for building well-structured and maintainable GetX applications. You can now choose the right tool for the job, whether it's providing a global service or a locally scoped controller.

In the next chapter, we'll look at [Chapter 7: GetBuilder](07_getbuilder_.md). `GetBuilder` is a widget that often uses `Binder` and `Bind.of(context)` (or `Get.find()` implicitly) to listen to your `GetxController`'s manual `update()` calls and rebuild the UI efficiently.
---
# Chapter 7: GetBuilder

Welcome to Chapter 7! In [Chapter 6: Dependency Access (Binder, Bind.of, Get.find/put)](06_dependency_access__binder__bind_of__get_find_put__.md), we explored how to make our `GetxController` instances (our app's "brains") available to different parts of our UI. Now, let's look at another way to connect our UI to these controllers, specifically when we want more *manual* control over UI updates.

## What's the Problem? "I Want to Update My Screen *Only* When I Say So!"

Imagine you have an app screen displaying a count.
*   In [Chapter 3: Obx / ObxWidget](03_obx___obxwidget_.md), we learned about `Obx` which is fantastic for automatically updating the UI whenever an `Rx<T>` (reactive) variable changes.
*   But what if your count is just a regular `int` variable inside your `GetxController`, not an `RxInt`?
*   Or what if you want to perform several state changes and then update the UI only once, at the very end, for performance reasons or finer control?

This is where `GetBuilder` comes in. It's like having a digital display in a store that only refreshes its content when the store manager explicitly presses an "update display" button. It gives you precise, manual control.

## Meet GetBuilder: The Manually Triggered UI Refresher

`GetBuilder` is a Flutter widget provided by GetX. Its primary job is to:
1.  Listen to a specific [GetxController](05_getxcontroller_.md).
2.  Rebuild the part of your UI it wraps *only* when you explicitly call the `update()` method on that controller.

This is different from `Obx`, which reacts automatically to changes in `.obs` variables. `GetBuilder` responds to the manual `controller.update()` command.

## How to Use `GetBuilder`

Let's build a simple counter app where the count is a plain `int` in our controller, and we use `GetBuilder` to update the display.

### 1. Create Your Controller with Manual Updates

First, let's define a `GetxController`. Inside, we'll have a regular integer for our count and a method to increment it. Crucially, this method will call `update()` after changing the count.

```dart
// counter_controller.dart
import 'package:get/get.dart';

class ManualCounterController extends GetxController {
  int count = 0; // A regular integer, NOT reactive (.obs)

  void increment() {
    count++;
    update(); // THIS is the "update display" button!
    print("Count is now $count. UI update requested.");
  }
}
```
**Explanation:**
*   `count` is a simple `int`. Changes to it won't automatically trigger UI updates.
*   The `increment()` method increases `count` and then calls `update()`. This `update()` call is what `GetBuilder` will listen for.

### 2. Make Your Controller Available

As we learned in [Chapter 6: Dependency Access (Binder, Bind.of, Get.find/put)](06_dependency_access__binder__bind_of__get_find_put__.md), your controller needs to be made available. For simplicity, we can use `Get.put()` if it's a global controller, or it could be provided by an ancestor `Binder` widget.

```dart
// In your main.dart or an initialization file
Get.put(ManualCounterController());
```
This makes an instance of `ManualCounterController` available for `GetBuilder` to find.

### 3. Use `GetBuilder` in Your UI

Now, in your widget, you wrap the part of the UI that needs to display the `count` with `GetBuilder`.

```dart
// counter_page.dart
import 'package:flutter/material.dart';
import 'package:get/get.dart';
import 'counter_controller.dart'; // Your controller file

class ManualCounterPage extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(title: Text("GetBuilder Counter")),
      body: Center(
        // 1. Wrap your UI with GetBuilder
        child: GetBuilder<ManualCounterController>(
          // It will find the controller put by Get.put()
          // Or you could provide 'init: ManualCounterController()' here
          // to create a new instance scoped to this GetBuilder.

          builder: (controller) { // 2. The builder gives you the controller
            return Text(
              "Count: ${controller.count}", // 3. Access controller's state
              style: TextStyle(fontSize: 30),
            );
          },
        ),
      ),
      floatingActionButton: FloatingActionButton(
        onPressed: () {
          // Find the controller and call its method
          final ManualCounterController c = Get.find();
          c.increment();
        },
        child: Icon(Icons.add),
      ),
    );
  }
}
```
**What happens?**
1.  The `ManualCounterPage` loads. `GetBuilder` finds the `ManualCounterController` instance (the one we registered with `Get.put()`). It runs its `builder` function, and `Text("Count: 0")` is displayed.
2.  You tap the `+` button.
3.  The `onPressed` callback calls `controller.increment()`.
4.  Inside `increment()`, `count` becomes `1`, and then `update()` is called.
5.  The `GetBuilder` widget, which is listening to this specific `ManualCounterController`, "hears" the `update()` call.
6.  `GetBuilder` re-runs its `builder` function. This time, `controller.count` is `1`, so a new `Text("Count: 1")` is created and displayed.
Output (in console from the controller):
```
Count is now 1. UI update requested.
Count is now 2. UI update requested.
...
```
The UI refreshes precisely when `update()` is invoked!

### Key Properties of `GetBuilder`

*   **`builder: (controller) { ... }` (Required):** This function takes the controller instance `T` and must return the widget that should be rebuilt.
*   **`init: YourController()` (Optional):** If you provide an `init` property, `GetBuilder` will create and manage a new instance of that controller. This instance will typically be scoped to this `GetBuilder`, meaning it's available to this `GetBuilder` and its children, and it's usually disposed of when the `GetBuilder` is removed from the widget tree (due to `autoRemove: true` by default).
    ```dart
    GetBuilder<MyScopedController>(
      init: MyScopedController(), // Creates a new controller instance here
      builder: (controller) => Text(controller.data),
    )
    ```
*   **Finding an Existing Controller:** If `init` is *not* provided, `GetBuilder` attempts to find an already existing controller.
    *   By default (`global: true`), it will effectively use `Get.find<T>()` or find it through the `Binder` it creates internally (which itself can use `Get.find()`).
    * If `global: false`, it relies more strictly on finding the controller from an ancestor `Binder` widget in the tree. This is useful for more localized state. (Refer to [Chapter 6](06_dependency_access__binder__bind_of__get_find_put__.md) for `Binder`).
*   **`id: 'someUniqueId'` (Optional):** For selective updates. If you have multiple `GetBuilder`s listening to the same controller, you can give them IDs. Then, in your controller, you can call `update(['someUniqueId'])` to only rebuild `GetBuilder`s that have matching IDs.
    ```dart
    // In controller:
    // void updateProfileSection() { update(['profile']); }
    // void updateSettingsSection() { update(['settings']); }

    // In UI:
    // GetBuilder<UserController>(id: 'profile', builder: ...)
    // GetBuilder<UserController>(id: 'settings', builder: ...)
    ```
*   **`autoRemove: true` (Default):** If `GetBuilder` initialized the controller (via `init`), this determines if the controller should be disposed when `GetBuilder` is removed from the widget tree. Usually, you want this to be `true` to prevent memory leaks.
*   **`global: true` (Default):** Controls how the `Binder` (used internally by `GetBuilder`) finds or registers the controller with GetX's dependency manager. For beginners, the default usually works well, allowing `GetBuilder` to find globally `put` controllers or manage its own if `init` is used.

## GetBuilder vs. Obx: When to Use Which?

This is a common question for newcomers!

*   **`Obx` ([Chapter 3: Obx / ObxWidget](03_obx___obxwidget_.md)):**
    *   Use with **reactive variables** (e.g., `name.obs`, `count.obs`).
    *   Updates **automatically** when the `.value` of an observed `Rx<T>` variable changes *inside* its builder.
    *   Typically simpler for purely reactive state.
    *   Syntax: `Obx(() => Text(controller.reactiveName.value))`

*   **`GetBuilder`:**
    *   Use with **any type of state** in your `GetxController`, including non-reactive variables (like plain `int`s or `String`s).
    *   Updates **manually** when you call `controller.update()`.
    *   Gives you more **explicit control** over when rebuilds occur.
    *   Can be useful if you want to batch multiple state changes and trigger a single UI update.
    *   Sometimes preferred for complex state logic or when migrating from other state management solutions that use manual refresh notifications.
    *   Syntax: `GetBuilder<MyController>(builder: (controller) => Text(controller.plainName))`

You can even use both in the same app, or even for the same controller, depending on the specific needs of different UI parts!

## Under the Hood: How Does `GetBuilder` Work?

`GetBuilder` might seem simple on the surface, but it leverages some clever GetX mechanics:

1.  **Controller Access:**
    *   As seen in the internal `build` method of `GetBuilder` (in `get_state_manager/src/simple/get_state.dart`), it actually wraps its `child` (defined by your `builder` function) with a `Binder` widget.
    ```dart
    // Simplified from GetBuilder's build method in get_state.dart
    @override
    Widget build(BuildContext context) {
      return Binder( // GetBuilder uses a Binder internally!
        init: init == null ? null : () => init!, // Passes your init
        global: global, // And other properties...
        // ...
        child: Builder(builder: (context) {
          // It then uses Bind.of to get the controller
          // 'rebuild: true' means it subscribes for updates
          final controller = Bind.of<T>(context, rebuild: true);
          return builder(controller); // Calls your builder function
        }),
      );
    }
    ```
    *   This `Binder` is responsible for either creating a new controller instance (if `init` is provided) or finding an existing one (as explained in [Chapter 6: Dependency Access (Binder, Bind.of, Get.find/put)](06_dependency_access__binder__bind_of__get_find_put__.md)).
    *   The `Bind.of<T>(context, rebuild: true)` part is crucial. It not only gets the controller instance but also tells Flutter that this widget (the `Builder` inside `GetBuilder`) depends on the `Binder`. If the `Binder` signals an update, this widget should rebuild.

2.  **Listening for `update()`:**
    *   When `Bind.of(context, rebuild: true)` connects to the controller (managed by the `Binder`), the `BinderElement` (the `Element` for the `Binder` widget) adds a listener to the controller.
    *   Remember from [Chapter 5: GetxController](05_getxcontroller_.md) that `GetxController` extends `ListNotifier`? This `ListNotifier` is what manages a list of "update functions" (listeners).
    *   The `BinderElement` effectively gives its own "rebuild me" function to the controller's `ListNotifier`.

3.  **The `update()` Call:**
    *   When you call `controller.update()` in your `GetxController`, this internally calls `refresh()` on its `ListNotifier`.
    *   `refresh()` then iterates through all its registered listeners (including the one from `GetBuilder`'s internal `BinderElement`) and executes them.

4.  **UI Rebuild:**
    *   When `GetBuilder`'s `BinderElement` listener is called, it marks itself as needing a rebuild.
    *   Flutter then schedules a rebuild for that part of the widget tree.
    *   `GetBuilder`'s main `build` method runs again, which in turn calls your `builder: (controller) { ... }` function with the same controller instance (which now has the updated state).

Here's a simplified sequence:

```mermaid
sequenceDiagram
    participant UserAction as User Taps Button
    participant Controller as YourController
    participant ControllerNotifier as Controller's ListNotifier
    participant GetBuilderInternal as GetBuilder (Binder/Bind.of)
    participant YourUIBuilder as Your builder: (ctrl) => Text(...)

    Note over ControllerNotifier, GetBuilderInternal: GetBuilder (via Binder) has subscribed to Controller's Notifier

    UserAction->>Controller: Calls controller.increment()
    Controller->>Controller: Updates its internal state (e.g., `count++`)
    Controller->>ControllerNotifier: Calls this.update() which calls refresh()
    ControllerNotifier-->>GetBuilderInternal: Notifies its listener (the BinderElement)
    GetBuilderInternal->>GetBuilderInternal: Marks itself for rebuild
    GetBuilderInternal-->>YourUIBuilder: Invokes your builder function
    YourUIBuilder->>Controller: Accesses controller.count (new value)
    YourUIBuilder-->>UserAction: UI displays updated count
```

So, `GetBuilder` provides a structured way to manually trigger UI updates by cleverly using `Binder` and the `ListNotifier` capabilities of `GetxController`.

## Conclusion

You've now learned about `GetBuilder`, your tool for manually controlling UI updates in GetX. It's ideal when you're not using reactive `.obs` variables for a piece of state, or when you need fine-grained control over *when* your UI should refresh in response to changes in a `GetxController`. By calling `controller.update()`, you tell all listening `GetBuilder` widgets it's time to redraw themselves.

While `GetBuilder` deals with general state and manual updates, GetX also offers specialized tools for handling more complex state scenarios, like loading data from a server, showing error messages, or displaying empty states. One such tool is the `StateMixin`.

Let's explore this powerful mixin in the [next chapter, Chapter 8: StateMixin](08_statemixin_.md).
---
# Chapter 8: StateMixin

Welcome to Chapter 8! In [Chapter 7: GetBuilder](07_getbuilder_.md), we saw how `GetBuilder` gives us manual control over UI updates for our `GetxController`. Now, what if we have a common pattern: fetching data from a server or performing some long task, and we want to show different screens for "loading," "data successfully loaded," "an error occurred," or "no data found"? Managing all these UI states manually can be repetitive. GetX provides a wonderful utility for this: `StateMixin`!

## What Problem Does `StateMixin` Solve? The Asynchronous UI Dance!

Imagine you're building a screen that needs to show a user's profile. To do this, your app needs to:
1.  **Start fetching:** Show a loading spinner while it asks the server for data.
2.  **Success:** If data comes back, display the user's profile.
3.  **Empty:** If data comes back but it's empty (e.g., a new user with no profile details yet), show a "Profile is empty" message.
4.  **Error:** If something goes wrong (no internet, server error), show an error message with perhaps a retry button.

This "loading -> success/empty/error" flow is extremely common in apps. `StateMixin` is a helper (a "mixin") that you add to your [GetxController](05_getxcontroller_.md) to make managing these UI states incredibly simple. It acts like a **standardized status panel for your data**, clearly indicating its current condition, and makes it easy to show the right widget for that condition.

## Meet `StateMixin`: Your Controller's Status Manager

`StateMixin` provides your controller with:
1.  A **`status` property**: This tells you the current state (e.g., `status.isLoading`, `status.isSuccess`, `status.isError`, `status.isEmpty`).
2.  A **`state` property**: If the status is "success," this holds the actual data you've loaded (e.g., the user profile object).
3.  **Helper methods**: Functions like `setLoading()`, `setSuccess(yourData)`, `setError('oops')`, and `setEmpty()` to easily change the current status.
4.  A special **`obx` method (on the controller itself)**: This method is a widget builder that automatically shows different UI sections based on the current `status`.

### How to Use `StateMixin`

Let's see it in action with a simple example of fetching a welcome message.

#### 1. Create a Controller with `StateMixin`

First, you create your [GetxController](05_getxcontroller_.md) and add `with StateMixin<YourDataType>` to it. The `YourDataType` is the type of data you expect to load (e.g., `String` for a message, `User` for a user object).

```dart
// welcome_controller.dart
import 'package:get/get.dart';

class WelcomeController extends GetxController with StateMixin<String> {
  // The <String> means our successful 'state' will be a String.

  @override
  void onInit() {
    super.onInit();
    fetchWelcomeMessage(); // Let's fetch data when the controller starts
  }

  Future<void> fetchWelcomeMessage() async {
    // 1. Start with loading state
    setLoading(); // This updates status to loading and tells UI to refresh

    try {
      // Simulate fetching data from a server
      await Future.delayed(Duration(seconds: 2));
      String message = "Hello, GetX User!";
      // String message = ""; // Uncomment to test empty state
      // throw Exception("Network Error!"); // Uncomment to test error state

      if (message.isEmpty) {
        // 2a. Data is empty
        setEmpty();
      } else {
        // 2b. Data fetched successfully!
        setSuccess(message); // 'message' is our String data
      }
    } catch (e) {
      // 3. An error occurred
      setError(e.toString());
    }
  }
}
```
**Explanation:**
*   `class WelcomeController extends GetxController with StateMixin<String>`: We're creating a controller that will manage a state of type `String`.
*   `setLoading()`: We call this method to tell `StateMixin` that we've started loading. The `status` becomes `isLoading`.
*   `setSuccess(message)`: If data is fetched, we call this with the actual data. The `status` becomes `isSuccess`, and `state` will now hold `message`.
*   `setEmpty()`: If the fetched data represents an "empty" condition, we call this. The `status` becomes `isEmpty`.
*   `setError(e.toString())`: If an error occurs, we call this with an error message. The `status` becomes `isError`.

Behind the scenes, calling `setLoading()`, `setSuccess()`, etc., updates the internal `status` and then calls `refresh()` (which we know from [GetxController](05_getxcontroller_.md) and [GetBuilder](07_getbuilder_.md) triggers UI updates for listening widgets).

#### 2. Make Your Controller Available

As usual, you need to make your controller available, for instance, using `Get.put()`:
```dart
// Initialize your controller, e.g., in main.dart or a binding
Get.put(WelcomeController());
```

#### 3. Displaying UI with `controller.obx()`

`StateMixin` gives your controller a handy `obx()` method (not to be confused with the `Obx()` widget from [Chapter 3: Obx / ObxWidget](03_obx___obxwidget_.md)). This method is a widget builder that takes different functions to render UI for each state:

```dart
// welcome_page.dart
import 'package:flutter/material.dart';
import 'package:get/get.dart';
import 'welcome_controller.dart'; // Import your controller

class WelcomePage extends StatelessWidget {
  final WelcomeController controller = Get.find<WelcomeController>();

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(title: Text("StateMixin Demo")),
      body: Center(
        // Use the controller's own .obx() method
        child: controller.obx(
          // (state) is the data you passed to setSuccess(data)
          (state) => Text(
            "Success: $state", // 'state' is the "Hello, GetX User!" message
            style: TextStyle(fontSize: 24, color: Colors.green),
          ),
          onLoading: CircularProgressIndicator(),
          onError: (error) => Text(
            "Error: $error",
            style: TextStyle(fontSize: 18, color: Colors.red),
          ),
          onEmpty: Text(
            "No message found.",
            style: TextStyle(fontSize: 18, color: Colors.orange),
          ),
        ),
      ),
      floatingActionButton: FloatingActionButton(
        onPressed: () => controller.fetchWelcomeMessage(), // Retry
        child: Icon(Icons.refresh),
      ),
    );
  }
}
```
**What happens:**
1.  When `WelcomePage` loads, `controller.fetchWelcomeMessage()` is called (from `onInit`).
2.  `setLoading()` is called. The `controller.obx` widget sees `status.isLoading` is true and displays the `CircularProgressIndicator` you provided in `onLoading`.
3.  After 2 seconds (simulated delay):
    *   **If successful:** `setSuccess("Hello, GetX User!")` is called. `controller.obx` sees `status.isSuccess` is true. It then calls your main builder `(state) => ...` where `state` is "Hello, GetX User!", and displays your success `Text` widget.
    *   **If empty:** `setEmpty()` is called. `controller.obx` sees `status.isEmpty` and displays the `Text` from `onEmpty`.
    *   **If error:** `setError("some error")` is called. `controller.obx` sees `status.isError` and calls `(error) => ...` from `onError`, displaying the error message.

You have a clean way to handle all common async UI states with minimal boilerplate!

The parameters for `controller.obx()` are:
*   **`NotifierBuilder<T> widget` (Required):** A function `(T state) => Widget`. This is called when `status.isSuccess`. The `state` argument is your data.
*   **`onLoading` (Optional):** A `Widget` to display when `status.isLoading`. Defaults to `Center(child: CircularProgressIndicator())`.
*   **`onError` (Optional):** A function `(String? error) => Widget`. Called when `status.isError`. The `error` argument is the message you passed to `setError()`. Defaults to `Center(child: Text('An error occurred: ...'))`.
*   **`onEmpty` (Optional):** A `Widget` to display when `status.isEmpty`. Defaults to `SizedBox.shrink()`.

## Under the Hood: The Magic of `StateMixin` and `GetStatus`

`StateMixin` isn't black magic; it's a well-thought-out combination of existing GetX concepts.

```mermaid
sequenceDiagram
    participant UserAction as Page Loads / Refresh Button
    participant Controller as WelcomeController (with StateMixin)
    participant StateMixinInternals as (Part of Controller)
    participant ControllerObxWidget as controller.obx() in UI

    UserAction->>Controller: Calls controller.fetchWelcomeMessage()
    Controller->>StateMixinInternals: Calls setLoading()
    StateMixinInternals->>StateMixinInternals: Sets internal _status to LoadingStatus, calls refresh()
    StateMixinInternals-->>ControllerObxWidget: Notifies listeners (obx widget rebuilds)
    ControllerObxWidget->>StateMixinInternals: Reads controller.status (isLoading == true)
    ControllerObxWidget-->>UserAction: Shows 'onLoading' widget (e.g., Spinner)

    Note over Controller, StateMixinInternals: Simulating API call...
    Controller->>StateMixinInternals: API success, calls setSuccess("Hello!")
    StateMixinInternals->>StateMixinInternals: Sets _status to SuccessStatus("Hello!"), _value to "Hello!", calls refresh()
    StateMixinInternals-->>ControllerObxWidget: Notifies listeners (obx widget rebuilds)
    ControllerObxWidget->>StateMixinInternals: Reads controller.status (isSuccess == true), reads controller.state ("Hello!")
    ControllerObxWidget-->>UserAction: Shows main success widget (e.g., Text("Hello!"))
```

1.  **The Mixin Itself (`StateMixin<T>`):**
    *   Located in `get_state_manager/src/rx_flutter/rx_notifier.dart`.
    *   It's declared as `mixin StateMixin<T> on ListNotifier`. This means it must be mixed into a class that is also a `ListNotifier` (like [GetxController](05_getxcontroller_.md), which extends `ListNotifier`).
    *   It internally stores:
        *   `T? _value;`: This holds your actual data (e.g., "Hello, GetX User!").
        *   `GetStatus<T>? _status;`: This holds the current status.
    *   When you call `setLoading()`, `setSuccess(data)`, `setError(errorMsg)`, or `setEmpty()`, these methods:
        *   Create an appropriate `GetStatus` object (e.g., `LoadingStatus<T>()`, `SuccessStatus<T>(data)`).
        *   Call an internal `change(newStatus)` method.
        *   The `change()` method updates the internal `_status` (and `_value` if it's a success status).
        *   Crucially, after updating, it calls `refresh()`. Since `StateMixin` is `on ListNotifier`, this `refresh()` call notifies any listeners that the state has changed.

2.  **`GetStatus<T>`:**
    *   Also in `get_state_manager/src/rx_flutter/rx_notifier.dart`.
    *   This is like an advanced enum. It has factory constructors:
        *   `GetStatus.loading()`: Creates a `LoadingStatus<T>`.
        *   `GetStatus.success(T data)`: Creates a `SuccessStatus<T>` holding your data.
        *   `GetStatus.error(Object message)`: Creates an `ErrorStatus<T, Object>` holding the error.
        *   `GetStatus.empty()`: Creates an `EmptyStatus<T>`.
    *   Extensions on `GetStatus<T>` (like `StatusDataExt<T>`) provide handy boolean getters: `isLoading`, `isSuccess`, `isError`, `isEmpty`, and also access to `data` or `errorMessage`.

3.  **The Controller's `obx()` Method:**
    *   This method is *not* part of `StateMixin` itself but is an extension method defined as `StateExt<T> on StateMixin<T>` (also in `rx_notifier.dart`).
    *   `Widget obx(NotifierBuilder<T> widget, { ... }) { return Observer(builder: (context) { ... }); }`
    *   It returns an `Observer` widget. This `Observer` widget is a reactive widget (similar in principle to `Obx` or `GetBuilder`). It listens to the `StateMixin` (because the controller it's on is a `ListNotifier`).
    *   When `refresh()` is called by `StateMixin`, the `Observer` rebuilds.
    *   Inside the `Observer`'s `builder` function, it checks the `controller.status` (e.g., `controller.status.isLoading`, `controller.status.isSuccess`) and then executes the appropriate rendering function you provided (`onLoading`, main builder, `onError`, or `onEmpty`).

So, `StateMixin` provides the state management logic, and the `obx` extension method provides a convenient way to render UI based on that managed state.

## Conclusion

`StateMixin` is a powerful and convenient tool for managing the common UI states of asynchronous operations: loading, success (with data), error, and empty. By mixing it into your `GetxController` and using the controller's `obx()` method in your UI, you can write cleaner, more readable code for these frequent scenarios. It elegantly handles the "status panel" for your data, letting you focus on what to display in each case.

We've covered various ways to manage and display state. Sometimes, your state involves lists of items, and you might need specific logic for managing those lists reactively. GetX offers specialized tools for this too.

In the [next chapter, Chapter 9: ListNotifier (and Mixins)](09_listnotifier__and_mixins__.md), we'll delve into `ListNotifier` itself, which is the foundation for many of GetX's state management primitives, and see how it can be used with other mixins for more advanced list management.

Relevant Code Snippets (Code itself remains unchanged):
--- File: get_state_manager/src/simple/list_notifier.dart ---
import 'dart:collection';

import 'package:flutter/foundation.dart';

// This callback remove the listener on addListener function
typedef Disposer = void Function();

// replacing StateSetter, return if the Widget is mounted for extra validation.
// if it brings overhead the extra call,
typedef GetStateUpdate = void Function();

class ListNotifier extends Listenable
    with ListNotifierSingleMixin, ListNotifierGroupMixin {}

/// A Notifier with single listeners
class ListNotifierSingle = ListNotifier with ListNotifierSingleMixin;

/// A notifier with group of listeners identified by id
class ListNotifierGroup = ListNotifier with ListNotifierGroupMixin;

/// This mixin add to Listenable the addListener, removerListener and
/// containsListener implementation
mixin ListNotifierSingleMixin on Listenable {
  List<GetStateUpdate>? _updaters = <GetStateUpdate>[];

  // final int _version = 0;
  // final int _microtaskVersion = 0;

  @override
  Disposer addListener(GetStateUpdate listener) {
    assert(_debugAssertNotDisposed());
    _updaters!.add(listener);
    return () => _updaters!.remove(listener);
  }

  bool containsListener(GetStateUpdate listener) {
    return _updaters?.contains(listener) ?? false;
  }

  @override
  void removeListener(VoidCallback listener) {
    assert(_debugAssertNotDisposed());
    _updaters!.remove(listener);
  }

  @protected
  void refresh() {
    assert(_debugAssertNotDisposed());
    _notifyUpdate();
  }

  @protected
  void reportRead() {
    Notifier.instance.read(this);
  }

  @protected
  void reportAdd(VoidCallback disposer) {
    Notifier.instance.add(disposer);
  }

  void _notifyUpdate() {
    // if (_microtaskVersion == _version) {
    //   _microtaskVersion++;
    //   scheduleMicrotask(() {
    //     _version++;
    //     _microtaskVersion = _version;
    final list = _updaters?.toList() ?? [];

    for (var element in list) {
      element();
    }
    //   });
    // }
  }

  bool get isDisposed => _updaters == null;

  bool _debugAssertNotDisposed() {
    assert(() {
      if (isDisposed) {
        throw FlutterError('''A $runtimeType was used after being disposed.\n
'Once you have called dispose() on a $runtimeType, it can no longer be used.''');
      }
      return true;
    }());
    return true;
  }

  int get listenersLength {
    assert(_debugAssertNotDisposed());
    return _updaters!.length;
  }

  @mustCallSuper
  void dispose() {
    assert(_debugAssertNotDisposed());
    _updaters = null;
  }
}

mixin ListNotifierGroupMixin on Listenable {
  HashMap<Object?, ListNotifierSingleMixin>? _updatersGroupIds =
      HashMap<Object?, ListNotifierSingleMixin>();

  void _notifyGroupUpdate(Object id) {
    if (_updatersGroupIds!.containsKey(id)) {
      _updatersGroupIds![id]!._notifyUpdate();
    }
  }

  @protected
  void notifyGroupChildrens(Object id) {
    assert(_debugAssertNotDisposed());
    Notifier.instance.read(_updatersGroupIds![id]!);
  }

  bool containsId(Object id) {
    return _updatersGroupIds?.containsKey(id) ?? false;
  }

  @protected
  void refreshGroup(Object id) {
    assert(_debugAssertNotDisposed());
    _notifyGroupUpdate(id);
  }

  bool _debugAssertNotDisposed() {
    assert(() {
      if (_updatersGroupIds == null) {
        throw FlutterError('''A $runtimeType was used after being disposed.\n
'Once you have called dispose() on a $runtimeType, it can no longer be used.''');
      }
      return true;
    }());
    return true;
  }

  void removeListenerId(Object id, VoidCallback listener) {
    assert(_debugAssertNotDisposed());
    if (_updatersGroupIds!.containsKey(id)) {
      _updatersGroupIds![id]!.removeListener(listener);
    }
  }

  @mustCallSuper
  void dispose() {
    assert(_debugAssertNotDisposed());
    _updatersGroupIds?.forEach((key, value) => value.dispose());
    _updatersGroupIds = null;
  }

  Disposer addListenerId(Object? key, GetStateUpdate listener) {
    _updatersGroupIds![key] ??= ListNotifierSingle();
    return _updatersGroupIds![key]!.addListener(listener);
  }

  /// To dispose an [id] from future updates(), this ids are registered
  /// by `GetBuilder()` or similar, so is a way to unlink the state change with
  /// the Widget from the Controller.
  void disposeId(Object id) {
    _updatersGroupIds?[id]?.dispose();
    _updatersGroupIds!.remove(id);
  }
}

class Notifier {
  Notifier._();

  static Notifier? _instance;
  static Notifier get instance => _instance ??= Notifier._();

  NotifyData? _notifyData;

  void add(VoidCallback listener) {
    _notifyData?.disposers.add(listener);
  }

  void read(ListNotifierSingleMixin updaters) {
    final listener = _notifyData?.updater;
    if (listener != null && !updaters.containsListener(listener)) {
      updaters.addListener(listener);
      add(() => updaters.removeListener(listener));
    }
  }

  T append<T>(NotifyData data, T Function() builder) {
    _notifyData = data;
    final result = builder();
    if (data.disposers.isEmpty && data.throwException) {
      throw const ObxError();
    }
    _notifyData = null;
    return result;
  }
}

class NotifyData {
  const NotifyData(
      {required this.updater,
      required this.disposers,
      this.throwException = true});
  final GetStateUpdate updater;
  final List<VoidCallback> disposers;
  final bool throwException;
}

class ObxError {
  const ObxError();
  @override
  String toString() {
    return """
      [Get] the improper use of a GetX has been detected. 
      You should only use GetX or Obx for the specific widget that will be updated.
      If you are seeing this error, you probably did not insert any observable variables into GetX/Obx 
      or insert them outside the scope that GetX considers suitable for an update 
      (example: GetX => HeavyWidget => variableObservable).
      If you need to update a parent widget and a child widget, wrap each one in an Obx/GetX.
      """;
  }
}


--- File: get_state_manager/src/simple/get_controllers.dart ---
// ignore: prefer_mixin
import 'package:flutter/widgets.dart';

import '../../../instance_manager.dart';
import '../rx_flutter/rx_notifier.dart';
import 'list_notifier.dart';

// ignore: prefer_mixin
abstract class GetxController extends ListNotifier with GetLifeCycleMixin {
  /// Rebuilds `GetBuilder` each time you call `update()`;
  /// Can take a List of [ids], that will only update the matching
  /// `GetBuilder( id: )`,
  /// [ids] can be reused among `GetBuilders` like group tags.
  /// The update will only notify the Widgets, if [condition] is true.
  void update([List<Object>? ids, bool condition = true]) {
    if (!condition) {
      return;
    }
    if (ids == null) {
      refresh();
    } else {
      for (final id in ids) {
        refreshGroup(id);
      }
    }
  }
}

/// this mixin allow to fetch data when the scroll is at the bottom or on the
/// top
mixin ScrollMixin on GetLifeCycleMixin {
  final ScrollController scroll = ScrollController();

  @override
  void onInit() {
    super.onInit();
    scroll.addListener(_listener);
  }

  bool _canFetchBottom = true;

  bool _canFetchTop = true;

  void _listener() {
    if (scroll.position.atEdge) {
      _checkIfCanLoadMore();
    }
  }

  Future<void> _checkIfCanLoadMore() async {
    if (scroll.position.pixels == 0) {
      if (!_canFetchTop) return;
      _canFetchTop = false;
      await onTopScroll();
      _canFetchTop = true;
    } else {
      if (!_canFetchBottom) return;
      _canFetchBottom = false;
      await onEndScroll();
      _canFetchBottom = true;
    }
  }

  /// this method is called when the scroll is at the bottom
  Future<void> onEndScroll();

  /// this method is called when the scroll is at the top
  Future<void> onTopScroll();

  @override
  void onClose() {
    scroll.removeListener(_listener);
    super.onClose();
  }
}

/// A clean controller to be used with only Rx variables
abstract class RxController with GetLifeCycleMixin {}

/// A recommended way to use Getx with Future fetching
abstract class StateController<T> extends GetxController with StateMixin<T> {}

/// A controller with super lifecycles (including native lifecycles)
/// and StateMixins
abstract class SuperController<T> extends FullLifeCycleController
    with FullLifeCycleMixin, StateMixin<T> {}

/// A controller with super lifecycles (including native lifecycles)
abstract class FullLifeCycleController extends GetxController
    with
        // ignore: prefer_mixin
        WidgetsBindingObserver {}

mixin FullLifeCycleMixin on FullLifeCycleController {
  @mustCallSuper
  @override
  void onInit() {
    super.onInit();
    Engine.instance.addObserver(this);
  }

  @mustCallSuper
  @override
  void onClose() {
    Engine.instance.removeObserver(this);
    super.onClose();
  }

  @mustCallSuper
  @override
  void didChangeAppLifecycleState(AppLifecycleState state) {
    switch (state) {
      case AppLifecycleState.resumed:
        onResumed();
        break;
      case AppLifecycleState.inactive:
        onInactive();
        break;
      case AppLifecycleState.paused:
        onPaused();
        break;
      case AppLifecycleState.detached:
        onDetached();
        break;
      case AppLifecycleState.hidden:
        onHidden();
        break;
    }
  }

  void onResumed() {}
  void onPaused() {}
  void onInactive() {}
  void onDetached() {}
  void onHidden() {}
}


--- File: get_state_manager/src/rx_flutter/rx_notifier.dart ---
import 'dart:async';

import 'package:flutter/foundation.dart';
import 'package:flutter/material.dart';
import 'package:get/utils.dart';

import '../../../get_rx/src/rx_types/rx_types.dart';
import '../../../instance_manager.dart';
import '../../get_state_manager.dart';
import '../simple/list_notifier.dart';

extension _Empty on Object {
  bool _isEmpty() {
    final val = this;
    // if (val == null) return true;
    var result = false;
    if (val is Iterable) {
      result = val.isEmpty;
    } else if (val is String) {
      result = val.trim().isEmpty;
    } else if (val is Map) {
      result = val.isEmpty;
    }
    return result;
  }
}

mixin StateMixin<T> on ListNotifier {
  T? _value;
  GetStatus<T>? _status;

  void _fillInitialStatus() {
    _status = (_value == null || _value!._isEmpty())
        ? GetStatus<T>.loading()
        : GetStatus<T>.success(_value as T);
  }

  GetStatus<T> get status {
    reportRead();
    return _status ??= _status = GetStatus.loading();
  }

  T get state => value;

  set status(GetStatus<T> newStatus) {
    if (newStatus == status) return;
    _status = newStatus;
    if (newStatus is SuccessStatus<T>) {
      _value = newStatus.data;
    }
    refresh();
  }

  @protected
  T get value {
    reportRead();
    return _value as T;
  }

  @protected
  set value(T newValue) {
    if (_value == newValue) return;
    _value = newValue;
    refresh();
  }

  @protected
  void change(GetStatus<T> status) {
    if (status != this.status) {
      this.status = status;
    }
  }

  void setSuccess(T data) {
    change(GetStatus<T>.success(data));
  }

  void setError(Object error) {
    change(GetStatus<T>.error(error));
  }

  void setLoading() {
    change(GetStatus<T>.loading());
  }

  void setEmpty() {
    change(GetStatus<T>.empty());
  }

  void futurize(Future<T> Function() body,
      {T? initialData, String? errorMessage, bool useEmpty = true}) {
    final compute = body;
    _value ??= initialData;
    status = GetStatus<T>.loading();
    compute().then((newValue) {
      if ((newValue == null || newValue._isEmpty()) && useEmpty) {
        status = GetStatus<T>.empty();
      } else {
        status = GetStatus<T>.success(newValue);
      }

      refresh();
    }, onError: (err) {
      status = GetStatus.error(
          err is Exception ? err : Exception(errorMessage ?? err.toString()));
      refresh();
    });
  }
}

typedef FuturizeCallback<T> = Future<T> Function(VoidCallback fn);

typedef VoidCallback = void Function();

class GetListenable<T> extends ListNotifierSingle implements RxInterface<T> {
  GetListenable(T val) : _value = val;

  StreamController<T>? _controller;

  StreamController<T> get subject {
    if (_controller == null) {
      _controller =
          StreamController<T>.broadcast(onCancel: addListener(_streamListener));
      _controller?.add(_value);

      ///TODO: report to controller dispose
    }
    return _controller!;
  }

  void _streamListener() {
    _controller?.add(_value);
  }

  @override
  @mustCallSuper
  void close() {
    removeListener(_streamListener);
    _controller?.close();
    dispose();
  }

  Stream<T> get stream {
    return subject.stream;
  }

  T _value;

  @override
  T get value {
    reportRead();
    return _value;
  }

  void _notify() {
    refresh();
  }

  set value(T newValue) {
    if (_value == newValue) return;
    _value = newValue;
    _notify();
  }

  T? call([T? v]) {
    if (v != null) {
      value = v;
    }
    return value;
  }

  @override
  StreamSubscription<T> listen(
    void Function(T)? onData, {
    Function? onError,
    void Function()? onDone,
    bool? cancelOnError,
  }) =>
      stream.listen(
        onData,
        onError: onError,
        onDone: onDone,
        cancelOnError: cancelOnError ?? false,
      );

  @override
  String toString() => value.toString();
}

class Value<T> extends ListNotifier
    with StateMixin<T>
    implements ValueListenable<T?> {
  Value(T val) {
    _value = val;
    _fillInitialStatus();
  }

  @override
  T get value {
    reportRead();
    return _value as T;
  }

  @override
  set value(T newValue) {
    if (_value == newValue) return;
    _value = newValue;
    refresh();
  }

  T? call([T? v]) {
    if (v != null) {
      value = v;
    }
    return value;
  }

  void update(T Function(T? value) fn) {
    value = fn(value);
    // refresh();
  }

  @override
  String toString() => value.toString();

  dynamic toJson() => (value as dynamic)?.toJson();
}

/// GetNotifier has a native status and state implementation, with the
/// Get Lifecycle
abstract class GetNotifier<T> extends Value<T> with GetLifeCycleMixin {
  GetNotifier(super.initial);
}

extension StateExt<T> on StateMixin<T> {
  Widget obx(
    NotifierBuilder<T> widget, {
    Widget Function(String? error)? onError,
    Widget? onLoading,
    Widget? onEmpty,
    WidgetBuilder? onCustom,
  }) {
    return Observer(builder: (context) {
      if (status.isLoading) {
        return onLoading ?? const Center(child: CircularProgressIndicator());
      } else if (status.isError) {
        return onError != null
            ? onError(status.errorMessage)
            : Center(child: Text('A error occurred: ${status.errorMessage}'));
      } else if (status.isEmpty) {
        return onEmpty ??
            const SizedBox.shrink(); // Also can be widget(null); but is risky
      } else if (status.isSuccess) {
        return widget(value);
      } else if (status.isCustom) {
        return onCustom?.call(context) ??
            const SizedBox.shrink(); // Also can be widget(null); but is risky
      }
      return widget(value);
    });
  }
}

typedef NotifierBuilder<T> = Widget Function(T state);

abstract class GetStatus<T> with Equality {
  const GetStatus();

  factory GetStatus.loading() => LoadingStatus<T>();

  factory GetStatus.error(Object message) => ErrorStatus<T, Object>(message);

  factory GetStatus.empty() => EmptyStatus<T>();

  factory GetStatus.success(T data) => SuccessStatus<T>(data);

  factory GetStatus.custom() => CustomStatus<T>();
}

class CustomStatus<T> extends GetStatus<T> {
  @override
  List get props => [];
}

class LoadingStatus<T> extends GetStatus<T> {
  @override
  List get props => [];
}

class SuccessStatus<T> extends GetStatus<T> {
  final T data;

  const SuccessStatus(this.data);

  @override
  List get props => [data];
}

class ErrorStatus<T, S> extends GetStatus<T> {
  final S? error;

  const ErrorStatus([this.error]);

  @override
  List get props => [error];
}

class EmptyStatus<T> extends GetStatus<T> {
  @override
  List get props => [];
}

extension StatusDataExt<T> on GetStatus<T> {
  bool get isLoading => this is LoadingStatus;

  bool get isSuccess => this is SuccessStatus;

  bool get isError => this is ErrorStatus;

  bool get isEmpty => this is EmptyStatus;

  bool get isCustom => !isLoading && !isSuccess && !isError && !isEmpty;

  dynamic get error {
    if (this is ErrorStatus) {
      return (this as ErrorStatus).error;
    }
    return null;
  }

  String get errorMessage {
    final isError = this is ErrorStatus;
    if (isError) {
      final err = this as ErrorStatus;
      if (err.error != null) {
        if (err.error is String) {
          return err.error as String;
        }
        return err.error.toString();
      }
    }

    return '';
  }

  T? get data {
    if (this is SuccessStatus<T>) {
      final success = this as SuccessStatus<T>;
      return success.data;
    }
    return null;
  }
}


Instructions for the chapter (Generate content in English unless specified otherwise):
- Start with a clear heading (e.g., `# Chapter 9: ListNotifier (and Mixins)
`). Use the provided concept name.

- If this is not the first chapter, begin with a brief transition from the previous chapter, referencing it with a proper Markdown link using its name.

- Begin with a high-level motivation explaining what problem this abstraction solves. Start with a central use case as a concrete example. The whole chapter should guide the reader to understand how to solve this use case. Make it very minimal and friendly to beginners.

- If the abstraction is complex, break it down into key concepts. Explain each concept one-by-one in a very beginner-friendly way.

- Explain how to use this abstraction to solve the use case. Give example inputs and outputs for code snippets (if the output isn't values, describe at a high level what will happen).

- Each code block should be BELOW 10 lines! If longer code blocks are needed, break them down into smaller pieces and walk through them one-by-one. Aggresively simplify the code to make it minimal. Use comments to skip non-important implementation details. Each code block should have a beginner friendly explanation right after it.

- Describe the internal implementation to help understand what's under the hood. First provide a non-code or code-light walkthrough on what happens step-by-step when the abstraction is called. It's recommended to use a simple sequenceDiagram with a dummy example - keep it minimal with at most 5 participants to ensure clarity. If participant name has space, use: `participant QP as Query Processing`. .

- Then dive deeper into code for the internal implementation with references to files. Provide example code blocks, but make them similarly simple and beginner-friendly. Explain.

- IMPORTANT: When you need to refer to other core abstractions covered in other chapters, ALWAYS use proper Markdown links like this: [Chapter Title](filename.md). Use the Complete Tutorial Structure above to find the correct filename and the chapter title. Translate the surrounding text.

- Use mermaid diagrams to illustrate complex concepts (```mermaid``` format). .

- Heavily use analogies and examples throughout to help beginners understand.

- End the chapter with a brief conclusion that summarizes what was learned and provides a transition to the next chapter. If there is a next chapter, use a proper Markdown link: [Next Chapter Title](next_chapter_filename).

- Ensure the tone is welcoming and easy for a newcomer to understand.

- Output *only* the Markdown content for this chapter.

Now, directly provide a super beginner-friendly Markdown output (DON'T need ```markdown``` tags):

2025-05-12 13:40:19,159 - INFO - RESPONSE: # Chapter 9: ListNotifier (and Mixins)

Welcome to Chapter 9! In [Chapter 8: StateMixin](08_statemixin_.md), we saw how `StateMixin` helps manage UI states like loading, success, and error for asynchronous operations. You might have wondered: when the mixin calls "refresh," how does that magically update the screen? The answer lies in a fundamental GetX component: `ListNotifier`.

## What Problem Does `ListNotifier` Solve? The Town Crier!

Imagine you're building a Flutter app. You have a [GetxController](05_getxcontroller_.md) managing some data. When this data changes (e.g., after a button press that calls a method in your controller), you want to tell certain parts of your UI (like a `GetBuilder` widget from [Chapter 7: GetBuilder](07_getbuilder_.md)) that they need to refresh and show the new information.

How does the controller "talk" to these UI widgets? This is where `ListNotifier` comes in.

Think of `ListNotifier` as a highly efficient **town crier** for your application.
*   **Listeners are the Townspeople:** Widgets like `GetBuilder` are like townspeople who are interested in certain announcements. They "subscribe" to the town crier (the `ListNotifier` within a `GetxController`).
*   **`update()` is the Announcement:** When a `GetxController` needs to announce a state change (typically by calling its `update()` method), it's like giving the town crier a message.
*   **`ListNotifier` Rings the Bell:** The `ListNotifier` component within the controller then goes through its list of subscribed "townspeople" (listeners) and alerts each one that they need to react (e.g., refresh their display).

`ListNotifier` is the fundamental engine for managing lists of these listeners and dispatching update notifications. It's a cornerstone of GetX's simple state management, particularly for `GetBuilder`.

## Key Concepts: Understanding `ListNotifier`

While you usually won't use `ListNotifier` *directly* as a beginner (you'll use it indirectly through `GetxController`), understanding its parts helps demystify GetX:

1.  **`ListNotifier` itself:** This is the main class (found in `get_state_manager/src/simple/list_notifier.dart`). A `GetxController` actually *is* a `ListNotifier` because it extends it. It's designed to hold a list of listeners.

2.  **Listeners (`GetStateUpdate`):**
    A listener is just a function that knows what to do when it's notified. In the context of `GetBuilder`, this function tells the `GetBuilder` widget to rebuild itself. `GetStateUpdate` is just a type alias for `void Function()`.
    ```dart
    // Conceptual: A listener is like this
    // void tellMyWidgetToRebuild() {
    //   myWidget.rebuildItself();
    // }
    ```
    This function is what a `GetBuilder` gives to the `ListNotifier`.

3.  **`addListener(GetStateUpdate listener)`:**
    This is how a "townsperson" (like a `GetBuilder`) subscribes to the "town crier" (`ListNotifier`). It adds the listener's function to an internal list. `addListener` returns a `Disposer` function, which can be called to remove the listener.

    ```dart
    // Conceptual: Inside GetBuilder when it initializes
    // Disposer cleanupFunction = myController.addListener(myRebuildFunction);
    ```

4.  **`removeListener(VoidCallback listener)`:**
    This is how a listener unsubscribes, for example, when `GetBuilder` is removed from the screen.

5.  **`refresh()`:**
    This is the method that the "town crier" uses to make a general announcement. When `refresh()` is called (which happens when you call `update()` in your `GetxController` without any IDs), it loops through all its registered listeners and calls each one.

6.  **Mixins (`ListNotifierSingleMixin`, `ListNotifierGroupMixin`):**
    The term "Mixin" in Dart refers to a way of reusing a class's code in multiple class hierarchies. `ListNotifier` uses mixins to get its functionality:
    *   `ListNotifierSingleMixin`: This mixin provides the logic for managing a single, general list of listeners. The `refresh()` method comes from here.
    *   `ListNotifierGroupMixin`: This mixin provides logic for managing listeners grouped by IDs. When you call `controller.update(['myId'])`, it uses this mixin's `refreshGroup('myId')` method to notify only the listeners interested in 'myId'.

    A `GetxController` benefits from both because `ListNotifier` itself is defined as:
    ```dart
    // From: get_state_manager/src/simple/list_notifier.dart
    class ListNotifier extends Listenable
        with ListNotifierSingleMixin, ListNotifierGroupMixin {}
    ```
    This means a `GetxController` can do both general updates and ID-specific updates.

## How It's Used (Indirectly by You)

As a beginner, you're already using `ListNotifier` when you use `GetxController` and `GetBuilder`!

Let's revisit our `ManualCounterController` from [Chapter 7: GetBuilder](07_getbuilder_.md):
```dart
// Simplified GetxController
class ManualCounterController extends GetxController { // GetxController is a ListNotifier!
  int count = 0;
  void increment() {
    count++;
    update(); // This calls refresh() on the ListNotifier part
  }
}
```
When `update()` is called, the `ListNotifier` machinery inside `ManualCounterController` kicks in.

And in your UI:
```dart
// Simplified GetBuilder usage
GetBuilder<ManualCounterController>(
  builder: (controller) { // This builder function is the core of the listener
    return Text("Count: ${controller.count}");
  },
)
```
When this `GetBuilder` is created, it internally calls `addListener` on the `ManualCounterController` instance, registering its own "rebuild me" function.

## Under the Hood: The Notification Flow

Let's trace what happens when you tap a button that calls `controller.increment()` which then calls `controller.update()`:

1.  **Subscription (Happens Earlier):** When `GetBuilder<ManualCounterController>` is initialized, it finds the `ManualCounterController` instance. It then calls `controller.addListener(rebuildFunction)`, where `rebuildFunction` is a function that, when called, will cause the `GetBuilder` to re-run its `builder`. This `rebuildFunction` is added to an internal list (`_updaters`) inside the controller's `ListNotifierSingleMixin`.

2.  **User Action:** You tap a button.

3.  **Controller Logic:** The button's `onPressed` calls `controller.increment()`.

4.  **`controller.increment()`:**
    *   `count` is incremented.
    *   `controller.update()` is called.

5.  **`controller.update()`:** (From `get_state_manager/src/simple/get_controllers.dart`)
    ```dart
    // Inside GetxController
    void update([List<Object>? ids, bool condition = true]) {
      // ... (checks condition, handles ids with refreshGroup) ...
      if (ids == null) {
        refresh(); // Calls refresh() from ListNotifierSingleMixin
      } else {
        // ... logic for refreshGroup(id)
      }
    }
    ```
    This calls `refresh()` because we didn't provide any IDs.

6.  **`refresh()` in `ListNotifierSingleMixin`:** (From `get_state_manager/src/simple/list_notifier.dart`)
    ```dart
    // Inside ListNotifierSingleMixin
    @protected
    void refresh() {
      assert(_debugAssertNotDisposed()); // Checks if disposed
      _notifyUpdate();
    }

    void _notifyUpdate() {
      final list = _updaters?.toList() ?? []; // Gets a copy of listeners
      for (var element in list) {
        element(); // Calls each listener's function!
      }
    }
    ```
    `_notifyUpdate()` iterates through the `_updaters` list (which contains `GetBuilder`'s `rebuildFunction`) and executes each function.

7.  **`GetBuilder` Rebuilds:** `GetBuilder`'s registered `rebuildFunction` is called. This schedules the `GetBuilder` to re-run its own `builder` UI code, which now picks up the new `controller.count`.

Here's a visual:

```mermaid
sequenceDiagram
    participant YourCode as Button Tap
    participant Controller as ManualCounterController
    participant ListNotifierLogic as Controller's ListNotifier (Mixin)
    participant GetBuilderWidget as GetBuilder

    Note over ListNotifierLogic, GetBuilderWidget: GetBuilder previously subscribed (addListener)

    YourCode->>Controller: Calls controller.increment()
    Controller->>Controller: count++
    Controller->>ListNotifierLogic: Calls this.update() -> this.refresh()
    ListNotifierLogic->>ListNotifierLogic: Iterates _updaters (list of functions)
    ListNotifierLogic-->>GetBuilderWidget: Calls GetBuilder's registered rebuild function
    GetBuilderWidget->>GetBuilderWidget: Re-runs its 'builder', UI updates
```

The core data structure for `ListNotifierSingleMixin` is simple:
```dart
// From: get_state_manager/src/simple/list_notifier.dart
mixin ListNotifierSingleMixin on Listenable {
  List<GetStateUpdate>? _updaters = <GetStateUpdate>[]; // The list of listeners!

  // ... addListener, removeListener, refresh, _notifyUpdate ...
}
```
This `_updaters` list is where `GetBuilder` (and other similar listeners) register their callbacks. When `refresh()` is called, these callbacks are executed.

Similarly, `ListNotifierGroupMixin` manages a `HashMap<Object?, ListNotifierSingleMixin>` to store listeners associated with specific IDs, allowing `refreshGroup(id)` to be efficient.

## Why is `ListNotifier` Important for Beginners?

Even though you won't often type `ListNotifier` directly, understanding it:
*   **Demystifies `update()`:** You now know that when `controller.update()` is called, it's using this `ListNotifier` engine to broadcast the change.
*   **Explains `GetBuilder`:** You understand *how* `GetBuilder` knows when to rebuild. It's not magic; it's a listener subscribed to a `ListNotifier`.
*   **Shows GetX's Efficiency:** This system is lightweight. It's just managing lists of functions and calling them. No complex streams or heavy overhead for this basic update mechanism.
*   **Foundation for More:** Many parts of GetX's state management, including `StateMixin`'s internal refresh calls, ultimately leverage this `ListNotifier` pattern or similar reactive primitives.

It's like knowing how the engine in a car works. You don't need to build the engine to drive, but knowing it's there and its basic function helps you understand the car better.

## Conclusion

`ListNotifier` is the quiet, hardworking engine behind GetX's manual UI update system, making it the "town crier" that efficiently alerts interested parts of your UI (like `GetBuilder`) when a `GetxController` signals a change via its `update()` method. The mixins (`ListNotifierSingleMixin` and `ListNotifierGroupMixin`) provide the specific tools for these announcements.

With this foundational understanding of `ListNotifier`, you've now explored the key building blocks of GetX's state management system, from reactive variables and UI observers to controllers and dependency management. You're well-equipped to build responsive and well-structured Flutter applications with GetX!

This concludes our core concepts journey through GetX's fundamental state management and utility features. Happy coding!
