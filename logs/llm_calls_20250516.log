2025-05-16 11:04:10,241 - INFO - PROMPT: 
For the project `getx`:

Codebase Context:
--- File Index 0: lib/get_navigation/get_navigation.dart ---
library;

export 'src/bottomsheet/bottomsheet.dart';
export 'src/extension_navigation.dart';
export 'src/root/get_cupertino_app.dart';
export 'src/root/get_material_app.dart';
export 'src/root/internacionalization.dart';
export 'src/routes/custom_transition.dart';
export 'src/routes/default_route.dart';
export 'src/routes/get_route.dart';
export 'src/routes/index.dart';
export 'src/routes/observers/route_observer.dart';
export 'src/routes/route_middleware.dart';
export 'src/routes/transitions_type.dart';
export 'src/snackbar/snackbar.dart';
export 'src/snackbar/snackbar_controller.dart';


--- File Index 1: lib/get_navigation/src/router_report.dart ---
import 'dart:collection';

import '../../get.dart';

class RouterReportManager<T> {
  /// Holds a reference to `Get.reference` when the Instance was
  /// created to manage the memory.
  final Map<T?, List<String>> _routesKey = {};

  /// Stores the onClose() references of instances created with `Get.create()`
  /// using the `Get.reference`.
  /// Experimental feature to keep the lifecycle and memory management with
  /// non-singleton instances.
  final Map<T?, HashSet<Function>> _routesByCreate = {};

  static RouterReportManager? _instance;

  RouterReportManager._();

  static RouterReportManager get instance =>
      _instance ??= RouterReportManager._();

  static void dispose() {
    _instance = null;
  }

  void printInstanceStack() {
    Get.log(_routesKey.toString());
  }

  T? _current;

  // ignore: use_setters_to_change_properties
  void reportCurrentRoute(T newRoute) {
    _current = newRoute;
  }

  /// Links a Class instance [S] (or [tag]) to the current route.
  /// Requires usage of `GetMaterialApp`.
  void reportDependencyLinkedToRoute(String dependencyKey) {
    if (_current == null) return;
    if (_routesKey.containsKey(_current)) {
      _routesKey[_current!]!.add(dependencyKey);
    } else {
      _routesKey[_current] = <String>[dependencyKey];
    }
  }

  void clearRouteKeys() {
    _routesKey.clear();
    _routesByCreate.clear();
  }

  void appendRouteByCreate(GetLifeCycleMixin i) {
    _routesByCreate[_current] ??= HashSet<Function>();
    // _routesByCreate[Get.reference]!.add(i.onDelete as Function);
    _routesByCreate[_current]!.add(i.onDelete);
  }

  void reportRouteDispose(T disposed) {
    if (Get.smartManagement != SmartManagement.onlyBuilder) {
      // Engine.instance.addPostFrameCallback((_) {
      // Future.microtask(() {
      _removeDependencyByRoute(disposed);
      // });
    }
  }

  void reportRouteWillDispose(T disposed) {
    final keysToRemove = <String>[];

    _routesKey[disposed]?.forEach(keysToRemove.add);

    /// Removes `Get.create()` instances registered in `routeName`.
    if (_routesByCreate.containsKey(disposed)) {
      for (final onClose in _routesByCreate[disposed]!) {
        // assure the [DisposableInterface] instance holding a reference
        // to onClose() wasn't disposed.
        onClose();
      }
      _routesByCreate[disposed]!.clear();
      _routesByCreate.remove(disposed);
    }

    for (final element in keysToRemove) {
      Get.markAsDirty(key: element);

      //_routesKey.remove(element);
    }

    keysToRemove.clear();
  }

  /// Clears from memory registered Instances associated with [routeName] when
  /// using `Get.smartManagement` as [SmartManagement.full] or
  /// [SmartManagement.keepFactory]
  /// Meant for internal usage of `GetPageRoute` and `GetDialogRoute`
  void _removeDependencyByRoute(T routeName) {
    final keysToRemove = <String>[];

    _routesKey[routeName]?.forEach(keysToRemove.add);

    /// Removes `Get.create()` instances registered in `routeName`.
    if (_routesByCreate.containsKey(routeName)) {
      for (final onClose in _routesByCreate[routeName]!) {
        // assure the [DisposableInterface] instance holding a reference
        // to onClose() wasn't disposed.
        onClose();
      }
      _routesByCreate[routeName]!.clear();
      _routesByCreate.remove(routeName);
    }

    for (final element in keysToRemove) {
      final value = Get.delete(key: element);
      if (value) {
        _routesKey[routeName]?.remove(element);
      }
    }

    _routesKey.remove(routeName);

    keysToRemove.clear();
  }
}


--- File Index 2: lib/get_navigation/src/extension_navigation.dart ---
import 'dart:ui' as ui;

import 'package:flutter/material.dart';
import 'package:get/get_navigation/src/routes/test_kit.dart';

import '../../get.dart';
import 'dialog/dialog_route.dart';
import 'root/get_root.dart';

/// It replaces the Flutter Navigator, but needs no context.
/// You can to use navigator.push(YourRoute()) rather
/// Navigator.push(context, YourRoute());
NavigatorState? get navigator => GetNavigationExt(Get).key.currentState;

extension ExtensionBottomSheet on GetInterface {
  Future<T?> bottomSheet<T>(
    Widget bottomsheet, {
    Color? backgroundColor,
    double? elevation,
    bool persistent = true,
    ShapeBorder? shape,
    Clip? clipBehavior,
    Color? barrierColor,
    bool? ignoreSafeArea,
    bool isScrollControlled = false,
    bool useRootNavigator = false,
    bool isDismissible = true,
    bool enableDrag = true,
    RouteSettings? settings,
    Duration? enterBottomSheetDuration,
    Duration? exitBottomSheetDuration,
    Curve? curve,
  }) {
    return Navigator.of(overlayContext!, rootNavigator: useRootNavigator)
        .push(GetModalBottomSheetRoute<T>(
      builder: (_) => bottomsheet,
      isPersistent: persistent,
      // theme: Theme.of(key.currentContext, shadowThemeOnly: true),
      theme: Theme.of(key.currentContext!),
      isScrollControlled: isScrollControlled,

      barrierLabel: MaterialLocalizations.of(key.currentContext!)
          .modalBarrierDismissLabel,

      backgroundColor: backgroundColor ?? Colors.transparent,
      elevation: elevation,
      shape: shape,
      removeTop: ignoreSafeArea ?? true,
      clipBehavior: clipBehavior,
      isDismissible: isDismissible,
      modalBarrierColor: barrierColor,
      settings: settings,
      enableDrag: enableDrag,
      enterBottomSheetDuration:
          enterBottomSheetDuration ?? const Duration(milliseconds: 250),
      exitBottomSheetDuration:
          exitBottomSheetDuration ?? const Duration(milliseconds: 200),
      curve: curve,
    ));
  }
}

extension ExtensionDialog on GetInterface {
  /// Show a dialog.
  /// You can pass a [transitionDuration] and/or [transitionCurve],
  /// overriding the defaults when the dialog shows up and closes.
  /// When the dialog closes, uses those animations in reverse.
  Future<T?> dialog<T>(
    Widget widget, {
    bool barrierDismissible = true,
    Color? barrierColor,
    bool useSafeArea = true,
    GlobalKey<NavigatorState>? navigatorKey,
    Object? arguments,
    Duration? transitionDuration,
    Curve? transitionCurve,
    String? name,
    RouteSettings? routeSettings,
    String? id,
  }) {
    assert(debugCheckHasMaterialLocalizations(context!));

    //  final theme = Theme.of(context, shadowThemeOnly: true);
    final theme = Theme.of(context!);
    return generalDialog<T>(
      pageBuilder: (buildContext, animation, secondaryAnimation) {
        final pageChild = widget;
        Widget dialog = Builder(builder: (context) {
          return Theme(data: theme, child: pageChild);
        });
        if (useSafeArea) {
          dialog = SafeArea(child: dialog);
        }
        return dialog;
      },
      barrierDismissible: barrierDismissible,
      barrierLabel: MaterialLocalizations.of(context!).modalBarrierDismissLabel,
      barrierColor: barrierColor ?? Colors.black54,
      transitionDuration: transitionDuration ?? defaultDialogTransitionDuration,
      transitionBuilder: (context, animation, secondaryAnimation, child) {
        return FadeTransition(
          opacity: CurvedAnimation(
            parent: animation,
            curve: transitionCurve ?? defaultDialogTransitionCurve,
          ),
          child: child,
        );
      },
      navigatorKey: navigatorKey,
      routeSettings:
          routeSettings ?? RouteSettings(arguments: arguments, name: name),
      id: id,
    );
  }

  /// Api from showGeneralDialog with no context
  Future<T?> generalDialog<T>(
      {required RoutePageBuilder pageBuilder,
      bool barrierDismissible = false,
      String? barrierLabel,
      Color barrierColor = const Color(0x80000000),
      Duration transitionDuration = const Duration(milliseconds: 200),
      RouteTransitionsBuilder? transitionBuilder,
      GlobalKey<NavigatorState>? navigatorKey,
      RouteSettings? routeSettings,
      String? id}) {
    assert(!barrierDismissible || barrierLabel != null);
    final key = navigatorKey ?? Get.nestedKey(id)?.navigatorKey;
    final nav = key?.currentState ??
        Navigator.of(overlayContext!,
            rootNavigator:
                true); //overlay context will always return the root navigator
    return nav.push<T>(
      GetDialogRoute<T>(
        pageBuilder: pageBuilder,
        barrierDismissible: barrierDismissible,
        barrierLabel: barrierLabel,
        barrierColor: barrierColor,
        transitionDuration: transitionDuration,
        transitionBuilder: transitionBuilder,
        settings: routeSettings,
      ),
    );
  }

  /// Custom UI Dialog.
  Future<T?> defaultDialog<T>({
    String title = "Alert",
    EdgeInsetsGeometry? titlePadding,
    TextStyle? titleStyle,
    Widget? content,
    String? id,
    EdgeInsetsGeometry? contentPadding,
    VoidCallback? onConfirm,
    VoidCallback? onCancel,
    VoidCallback? onCustom,
    Color? cancelTextColor,
    Color? confirmTextColor,
    String? textConfirm,
    String? textCancel,
    String? textCustom,
    Widget? confirm,
    Widget? cancel,
    Widget? custom,
    Color? backgroundColor,
    bool barrierDismissible = true,
    Color? buttonColor,
    String middleText = "\n",
    TextStyle? middleTextStyle,
    double radius = 20.0,
    //   ThemeData themeData,
    List<Widget>? actions,

    // onWillPop Scope
    PopInvokedWithResultCallback<T>? onWillPop,

    // the navigator used to push the dialog
    GlobalKey<NavigatorState>? navigatorKey,
  }) {
    var leanCancel = onCancel != null || textCancel != null;
    var leanConfirm = onConfirm != null || textConfirm != null;
    actions ??= [];

    if (cancel != null) {
      actions.add(cancel);
    } else {
      if (leanCancel) {
        actions.add(TextButton(
          style: TextButton.styleFrom(
            tapTargetSize: MaterialTapTargetSize.shrinkWrap,
            padding: const EdgeInsets.symmetric(horizontal: 10, vertical: 8),
            shape: RoundedRectangleBorder(
                side: BorderSide(
                    color: buttonColor ?? theme.colorScheme.secondary,
                    width: 2,
                    style: BorderStyle.solid),
                borderRadius: BorderRadius.circular(radius)),
          ),
          onPressed: () {
            if (onCancel == null) {
              //TODO: Close current dialog after api change
              closeAllDialogs();
            } else {
              onCancel.call();
            }
          },
          child: Text(
            textCancel ?? "Cancel",
            style: TextStyle(
                color: cancelTextColor ?? theme.colorScheme.secondary),
          ),
        ));
      }
    }
    if (confirm != null) {
      actions.add(confirm);
    } else {
      if (leanConfirm) {
        actions.add(TextButton(
            style: TextButton.styleFrom(
              tapTargetSize: MaterialTapTargetSize.shrinkWrap,
              backgroundColor: buttonColor ?? theme.colorScheme.secondary,
              shape: RoundedRectangleBorder(
                  borderRadius: BorderRadius.circular(radius)),
            ),
            child: Text(
              textConfirm ?? "Ok",
              style: TextStyle(
                  color: confirmTextColor ?? theme.colorScheme.surface),
            ),
            onPressed: () {
              onConfirm?.call();
            }));
      }
    }

    Widget baseAlertDialog = Builder(builder: (context) {
      return AlertDialog(
        titlePadding: titlePadding ?? const EdgeInsets.all(8),
        contentPadding: contentPadding ?? const EdgeInsets.all(8),

        backgroundColor:
            backgroundColor ?? DialogTheme.of(context).backgroundColor,
        shape: RoundedRectangleBorder(
            borderRadius: BorderRadius.all(Radius.circular(radius))),
        title: Text(title, textAlign: TextAlign.center, style: titleStyle),
        content: Column(
          crossAxisAlignment: CrossAxisAlignment.center,
          mainAxisSize: MainAxisSize.min,
          children: [
            content ??
                Text(middleText,
                    textAlign: TextAlign.center, style: middleTextStyle),
            const SizedBox(height: 16),
            ButtonTheme(
              minWidth: 78.0,
              height: 34.0,
              child: Wrap(
                alignment: WrapAlignment.center,
                spacing: 8,
                runSpacing: 8,
                children: actions!,
              ),
            )
          ],
        ),
        // actions: actions, // ?? <Widget>[cancelButton, confirmButton],
        buttonPadding: EdgeInsets.zero,
      );
    });

    return dialog<T>(
      onWillPop != null
          ? PopScope<T>(
              onPopInvokedWithResult: (didPop, result) =>
                  onWillPop(didPop, result),
              // onPopInvoked: onWillPop,
              child: baseAlertDialog,
            )
          : baseAlertDialog,
      barrierDismissible: barrierDismissible,
      navigatorKey: navigatorKey,
      id: id,
    );
  }
}

extension ExtensionSnackbar on GetInterface {
  SnackbarController rawSnackbar({
    String? title,
    String? message,
    Widget? titleText,
    Widget? messageText,
    Widget? icon,
    bool instantInit = true,
    bool shouldIconPulse = true,
    double? maxWidth,
    EdgeInsets margin = const EdgeInsets.all(0.0),
    EdgeInsets padding = const EdgeInsets.all(16),
    double borderRadius = 0.0,
    Color? borderColor,
    double borderWidth = 1.0,
    Color backgroundColor = const Color(0xFF303030),
    Color? leftBarIndicatorColor,
    List<BoxShadow>? boxShadows,
    Gradient? backgroundGradient,
    Widget? mainButton,
    OnTap? onTap,
    Duration? duration = const Duration(seconds: 3),
    bool isDismissible = true,
    DismissDirection? dismissDirection,
    bool showProgressIndicator = false,
    AnimationController? progressIndicatorController,
    Color? progressIndicatorBackgroundColor,
    Animation<Color>? progressIndicatorValueColor,
    SnackPosition snackPosition = SnackPosition.bottom,
    SnackStyle snackStyle = SnackStyle.floating,
    Curve forwardAnimationCurve = Curves.easeOutCirc,
    Curve reverseAnimationCurve = Curves.easeOutCirc,
    Duration animationDuration = const Duration(seconds: 1),
    SnackbarStatusCallback? snackbarStatus,
    double barBlur = 0.0,
    double overlayBlur = 0.0,
    Color? overlayColor,
    Form? userInputForm,
  }) {
    final getSnackBar = GetSnackBar(
      snackbarStatus: snackbarStatus,
      title: title,
      message: message,
      titleText: titleText,
      messageText: messageText,
      snackPosition: snackPosition,
      borderRadius: borderRadius,
      margin: margin,
      duration: duration,
      barBlur: barBlur,
      backgroundColor: backgroundColor,
      icon: icon,
      shouldIconPulse: shouldIconPulse,
      maxWidth: maxWidth,
      padding: padding,
      borderColor: borderColor,
      borderWidth: borderWidth,
      leftBarIndicatorColor: leftBarIndicatorColor,
      boxShadows: boxShadows,
      backgroundGradient: backgroundGradient,
      mainButton: mainButton,
      onTap: onTap,
      isDismissible: isDismissible,
      dismissDirection: dismissDirection,
      showProgressIndicator: showProgressIndicator,
      progressIndicatorController: progressIndicatorController,
      progressIndicatorBackgroundColor: progressIndicatorBackgroundColor,
      progressIndicatorValueColor: progressIndicatorValueColor,
      snackStyle: snackStyle,
      forwardAnimationCurve: forwardAnimationCurve,
      reverseAnimationCurve: reverseAnimationCurve,
      animationDuration: animationDuration,
      overlayBlur: overlayBlur,
      overlayColor: overlayColor,
      userInputForm: userInputForm,
    );

    final controller = SnackbarController(getSnackBar);

    if (instantInit) {
      controller.show();
    } else {
      Engine.instance.addPostFrameCallback((_) {
        controller.show();
      });
    }
    return controller;
  }

  SnackbarController showSnackbar(GetSnackBar snackbar) {
    final controller = SnackbarController(snackbar);
    controller.show();
    return controller;
  }

  SnackbarController snackbar(
    String title,
    String message, {
    Color? colorText,
    Duration? duration = const Duration(seconds: 3),

    /// with instantInit = false you can put snackbar on initState
    bool instantInit = true,
    SnackPosition? snackPosition,
    Widget? titleText,
    Widget? messageText,
    Widget? icon,
    bool? shouldIconPulse,
    double? maxWidth,
    EdgeInsets? margin,
    EdgeInsets? padding,
    double? borderRadius,
    Color? borderColor,
    double? borderWidth,
    Color? backgroundColor,
    Color? leftBarIndicatorColor,
    List<BoxShadow>? boxShadows,
    Gradient? backgroundGradient,
    TextButton? mainButton,
    OnTap? onTap,
    OnHover? onHover,
    bool? isDismissible,
    bool? showProgressIndicator,
    DismissDirection? dismissDirection,
    AnimationController? progressIndicatorController,
    Color? progressIndicatorBackgroundColor,
    Animation<Color>? progressIndicatorValueColor,
    SnackStyle? snackStyle,
    Curve? forwardAnimationCurve,
    Curve? reverseAnimationCurve,
    Duration? animationDuration,
    double? barBlur,
    double? overlayBlur,
    SnackbarStatusCallback? snackbarStatus,
    Color? overlayColor,
    Form? userInputForm,
  }) {
    final getSnackBar = GetSnackBar(
        snackbarStatus: snackbarStatus,
        titleText: titleText ??
            Text(
              title,
              style: TextStyle(
                color: colorText ?? iconColor ?? Colors.black,
                fontWeight: FontWeight.w800,
                fontSize: 16,
              ),
            ),
        messageText: messageText ??
            Text(
              message,
              style: TextStyle(
                color: colorText ?? iconColor ?? Colors.black,
                fontWeight: FontWeight.w300,
                fontSize: 14,
              ),
            ),
        snackPosition: snackPosition ?? SnackPosition.top,
        borderRadius: borderRadius ?? 15,
        margin: margin ?? const EdgeInsets.symmetric(horizontal: 10),
        duration: duration,
        barBlur: barBlur ?? 7.0,
        backgroundColor: backgroundColor ?? Colors.grey.withValues(alpha: 0.2),
        icon: icon,
        shouldIconPulse: shouldIconPulse ?? true,
        maxWidth: maxWidth,
        padding: padding ?? const EdgeInsets.all(16),
        borderColor: borderColor,
        borderWidth: borderWidth,
        leftBarIndicatorColor: leftBarIndicatorColor,
        boxShadows: boxShadows,
        backgroundGradient: backgroundGradient,
        mainButton: mainButton,
        onTap: onTap,
        onHover: onHover,
        isDismissible: isDismissible ?? true,
        dismissDirection: dismissDirection,
        showProgressIndicator: showProgressIndicator ?? false,
        progressIndicatorController: progressIndicatorController,
        progressIndicatorBackgroundColor: progressIndicatorBackgroundColor,
        progressIndicatorValueColor: progressIndicatorValueColor,
        snackStyle: snackStyle ?? SnackStyle.floating,
        forwardAnimationCurve: forwardAnimationCurve ?? Curves.easeOutCirc,
        reverseAnimationCurve: reverseAnimationCurve ?? Curves.easeOutCirc,
        animationDuration: animationDuration ?? const Duration(seconds: 1),
        overlayBlur: overlayBlur ?? 0.0,
        overlayColor: overlayColor ?? Colors.transparent,
        userInputForm: userInputForm);

    final controller = SnackbarController(getSnackBar);

    if (instantInit) {
      controller.show();
    } else {
      //routing.isSnackbar = true;
      Engine.instance.addPostFrameCallback((_) {
        controller.show();
      });
    }
    return controller;
  }
}

extension GetNavigationExt on GetInterface {
  /// **Navigation.push()** shortcut.<br><br>
  ///
  /// Pushes a new `page` to the stack
  ///
  /// It has the advantage of not needing context,
  /// so you can call from your business logic
  ///
  /// You can set a custom [transition], and a transition [duration].
  ///
  /// You can send any type of value to the other route in the [arguments].
  ///
  /// Just like native routing in Flutter, you can push a route
  /// as a [fullscreenDialog],
  ///
  /// [id] is for when you are using nested navigation,
  /// as explained in documentation
  ///
  /// If you want the same behavior of ios that pops a route when the user drag,
  /// you can set [popGesture] to true
  ///
  /// If you're using the [BindingsInterface] api, you must define it here
  ///
  /// By default, GetX will prevent you from push a route that you already in,
  /// if you want to push anyway, set [preventDuplicates] to false
  Future<T?>? to<T extends Object?>(Widget Function() page,
      {bool? opaque,
      Transition? transition,
      Curve? curve,
      Duration? duration,
      String? id,
      String? routeName,
      bool fullscreenDialog = false,
      dynamic arguments,
      List<BindingsInterface> bindings = const [],
      bool preventDuplicates = true,
      bool? popGesture,
      bool showCupertinoParallax = true,
      double Function(BuildContext context)? gestureWidth,
      bool rebuildStack = true,
      PreventDuplicateHandlingMode preventDuplicateHandlingMode =
          PreventDuplicateHandlingMode.reorderRoutes}) {
    return searchDelegate(id).to(
      page,
      opaque: opaque,
      transition: transition,
      curve: curve,
      duration: duration,
      id: id,
      routeName: routeName,
      fullscreenDialog: fullscreenDialog,
      arguments: arguments,
      bindings: bindings,
      preventDuplicates: preventDuplicates,
      popGesture: popGesture,
      showCupertinoParallax: showCupertinoParallax,
      gestureWidth: gestureWidth,
      rebuildStack: rebuildStack,
      preventDuplicateHandlingMode: preventDuplicateHandlingMode,
    );
  }

//   GetPageBuilder _resolvePage(dynamic page, String method) {
//     if (page is GetPageBuilder) {
//       return page;
//     } else if (page is Widget) {
//       Get.log(
//           '''WARNING, consider using: "Get.$method(() => Page())"
//instead of "Get.$method(Page())".
// Using a widget function instead of a widget fully guarantees that the widget
//and its controllers will be removed from memory when they are no longer used.
//       ''');
//       return () => page;
//     } else if (page is String) {
//       throw '''Unexpected String,
// use toNamed() instead''';
//     } else {
//       throw '''Unexpected format,
// you can only use widgets and widget functions here''';
//     }
//   }

  /// **Navigation.pushNamed()** shortcut.<br><br>
  ///
  /// Pushes a new named `page` to the stack.
  ///
  /// It has the advantage of not needing context, so you can call
  /// from your business logic.
  ///
  /// You can send any type of value to the other route in the [arguments].
  ///
  /// [id] is for when you are using nested navigation,
  /// as explained in documentation
  ///
  /// By default, GetX will prevent you from push a route that you already in,
  /// if you want to push anyway, set [preventDuplicates] to false
  ///
  /// Note: Always put a slash on the route ('/page1'), to avoid unexpected errors
  Future<T?>? toNamed<T>(
    String page, {
    dynamic arguments,
    dynamic id,
    bool preventDuplicates = true,
    Map<String, String>? parameters,
  }) {
    // if (preventDuplicates && page == currentRoute) {
    //   return null;
    // }

    if (parameters != null) {
      final uri = Uri(path: page, queryParameters: parameters);
      page = uri.toString();
    }

    return searchDelegate(id).toNamed(
      page,
      arguments: arguments,
      id: id,
      preventDuplicates: preventDuplicates,
      parameters: parameters,
    );
  }

  /// **Navigation.pushReplacementNamed()** shortcut.<br><br>
  ///
  /// Pop the current named `page` in the stack and push a new one in its place
  ///
  /// It has the advantage of not needing context, so you can call
  /// from your business logic.
  ///
  /// You can send any type of value to the other route in the [arguments].
  ///
  /// [id] is for when you are using nested navigation,
  /// as explained in documentation
  ///
  /// By default, GetX will prevent you from push a route that you already in,
  /// if you want to push anyway, set [preventDuplicates] to false
  ///
  /// Note: Always put a slash on the route ('/page1'), to avoid unexpected errors
  Future<T?>? offNamed<T>(
    String page, {
    dynamic arguments,
    String? id,
    Map<String, String>? parameters,
  }) {
    // if (preventDuplicates && page == currentRoute) {
    //   return null;
    // }

    if (parameters != null) {
      final uri = Uri(path: page, queryParameters: parameters);
      page = uri.toString();
    }
    return searchDelegate(id).offNamed(
      page,
      arguments: arguments,
      id: id,
      // preventDuplicates: preventDuplicates,
      parameters: parameters,
    );
  }

  /// **Navigation.popUntil()** shortcut.<br><br>
  ///
  /// Calls pop several times in the stack until [predicate] returns true
  ///
  /// [id] is for when you are using nested navigation,
  /// as explained in documentation
  ///
  /// [predicate] can be used like this:
  /// `Get.until((route) => Get.currentRoute == '/home')`so when you get to home page,
  ///
  /// or also like this:
  /// `Get.until((route) => !Get.isDialogOpen())`, to make sure the
  /// dialog is closed
  void until(bool Function(GetPage<dynamic>) predicate, {String? id}) {
    // if (key.currentState.mounted) // add this if appear problems on future with route navigate
    // when widget don't mounted
    return searchDelegate(id).backUntil(predicate);
  }

  /// **Navigation.pushNamedAndRemoveUntil()** shortcut.<br><br>
  ///
  /// Push the given named `page`, and then pop several pages in the stack
  /// until [predicate] returns true
  ///
  /// You can send any type of value to the other route in the [arguments].
  ///
  /// [id] is for when you are using nested navigation,
  /// as explained in documentation
  ///
  /// [predicate] can be used like this:
  /// `Get.offNamedUntil(page, ModalRoute.withName('/home'))`
  /// to pop routes in stack until home,
  /// or like this:
  /// `Get.offNamedUntil((route) => !Get.isDialogOpen())`,
  /// to make sure the dialog is closed
  ///
  /// Note: Always put a slash on the route name ('/page1'), to avoid unexpected errors
  Future<T?>? offNamedUntil<T>(
    String page,
    bool Function(GetPage<dynamic>)? predicate, {
    String? id,
    dynamic arguments,
    Map<String, String>? parameters,
  }) {
    if (parameters != null) {
      final uri = Uri(path: page, queryParameters: parameters);
      page = uri.toString();
    }

    return searchDelegate(id).offNamedUntil<T>(
      page,
      predicate: predicate,
      id: id,
      arguments: arguments,
      parameters: parameters,
    );
  }

  /// **Navigation.popAndPushNamed()** shortcut.<br><br>
  ///
  /// Pop the current named page and pushes a new `page` to the stack
  /// in its place
  ///
  /// You can send any type of value to the other route in the [arguments].
  /// It is very similar to `offNamed()` but use a different approach
  ///
  /// The `offNamed()` pop a page, and goes to the next. The
  /// `offAndToNamed()` goes to the next page, and removes the previous one.
  /// The route transition animation is different.
  Future<T?>? offAndToNamed<T>(
    String page, {
    dynamic arguments,
    String? id,
    dynamic result,
    Map<String, String>? parameters,
  }) {
    if (parameters != null) {
      final uri = Uri(path: page, queryParameters: parameters);
      page = uri.toString();
    }
    return searchDelegate(id).backAndtoNamed(
      page,
      arguments: arguments,
      result: result,
    );
  }

  /// **Navigation.removeRoute()** shortcut.<br><br>
  ///
  /// Remove a specific [route] from the stack
  ///
  /// [id] is for when you are using nested navigation,
  /// as explained in documentation
  void removeRoute(String name, {String? id}) {
    return searchDelegate(id).removeRoute(name);
  }

  /// **Navigation.pushNamedAndRemoveUntil()** shortcut.<br><br>
  ///
  /// Push a named `page` and pop several pages in the stack
  /// until [predicate] returns true. [predicate] is optional
  ///
  /// It has the advantage of not needing context, so you can
  /// call from your business logic.
  ///
  /// You can send any type of value to the other route in the [arguments].
  ///
  /// [predicate] can be used like this:
  /// `Get.until((route) => Get.currentRoute == '/home')`so when you get to home page,
  /// or also like
  /// `Get.until((route) => !Get.isDialogOpen())`, to make sure the dialog
  /// is closed
  ///
  /// [id] is for when you are using nested navigation,
  /// as explained in documentation
  ///
  /// Note: Always put a slash on the route ('/page1'), to avoid unexpected errors
  Future<T?>? offAllNamed<T>(
    String newRouteName, {
    // bool Function(GetPage<dynamic>)? predicate,
    dynamic arguments,
    String? id,
    Map<String, String>? parameters,
  }) {
    if (parameters != null) {
      final uri = Uri(path: newRouteName, queryParameters: parameters);
      newRouteName = uri.toString();
    }

    return searchDelegate(id).offAllNamed<T>(
      newRouteName,
      //predicate: predicate ?? (_) => false,
      arguments: arguments,
      id: id,
      parameters: parameters,
    );
  }

  /// Returns true if a Snackbar, Dialog or BottomSheet is currently OPEN
  bool get isOverlaysOpen =>
      (isSnackbarOpen || isDialogOpen! || isBottomSheetOpen!);

  /// Returns true if there is no Snackbar, Dialog or BottomSheet open
  bool get isOverlaysClosed =>
      (!isSnackbarOpen && !isDialogOpen! && !isBottomSheetOpen!);

  /// **Navigation.popUntil()** shortcut.<br><br>
  ///
  /// Pop the current page, snackbar, dialog or bottomsheet in the stack
  ///
  /// if your set [closeOverlays] to true, Get.back() will close the
  /// currently open snackbar/dialog/bottomsheet AND the current page
  ///
  /// [id] is for when you are using nested navigation,
  /// as explained in documentation
  ///
  /// It has the advantage of not needing context, so you can call
  /// from your business logic.
  void back<T>({
    T? result,
    bool canPop = true,
    int times = 1,
    String? id,
  }) {
    if (times < 1) {
      times = 1;
    }

    if (times > 1) {
      var count = 0;
      return searchDelegate(id).backUntil((route) => count++ == times);
    } else {
      if (canPop) {
        if (searchDelegate(id).canBack == true) {
          return searchDelegate(id).back<T>(result);
        }
      } else {
        return searchDelegate(id).back<T>(result);
      }
    }
  }

  /// Pop the current page, snackbar, dialog or bottomsheet in the stack
  ///
  /// if your set [closeOverlays] to true, Get.back() will close the
  /// currently open snackbar/dialog/bottomsheet AND the current page
  ///
  /// [id] is for when you are using nested navigation,
  /// as explained in documentation
  ///
  /// It has the advantage of not needing context, so you can call
  /// from your business logic.
  void backLegacy<T>({
    T? result,
    bool closeOverlays = false,
    bool canPop = true,
    int times = 1,
    String? id,
  }) {
    if (closeOverlays) {
      closeAllOverlays();
    }

    if (times < 1) {
      times = 1;
    }

    if (times > 1) {
      var count = 0;
      return searchDelegate(id).navigatorKey.currentState?.popUntil((route) {
        return count++ == times;
      });
    } else {
      if (canPop) {
        if (searchDelegate(id).navigatorKey.currentState?.canPop() == true) {
          return searchDelegate(id).navigatorKey.currentState?.pop<T>(result);
        }
      } else {
        return searchDelegate(id).navigatorKey.currentState?.pop<T>(result);
      }
    }
  }

  void closeAllDialogsAndBottomSheets(
    String? id,
  ) {
    // It can not be divided, because dialogs and bottomsheets can not be consecutive
    while ((isDialogOpen! && isBottomSheetOpen!)) {
      closeOverlay(id: id);
    }
  }

  void closeAllDialogs({
    String? id,
  }) {
    while ((isDialogOpen!)) {
      closeOverlay(id: id);
    }
  }

  /// Close the currently open dialog, returning a [result], if provided
  void closeDialog<T>({String? id, T? result}) {
    // Stop if there is no dialog open
    if (isDialogOpen == null || !isDialogOpen!) return;

    closeOverlay(id: id, result: result);
  }

  void closeBottomSheet<T>({String? id, T? result}) {
    // Stop if there is no bottomsheet open
    if (isBottomSheetOpen == null || !isBottomSheetOpen!) return;

    closeOverlay(id: id, result: result);
  }

  /// Close the current overlay returning the [result], if provided
  void closeOverlay<T>({
    String? id,
    T? result,
  }) {
    searchDelegate(id).navigatorKey.currentState?.pop(result);
  }

  void closeAllBottomSheets({
    String? id,
  }) {
    while ((isBottomSheetOpen!)) {
      searchDelegate(id).navigatorKey.currentState?.pop();
    }
  }

  void closeAllOverlays() {
    closeAllDialogsAndBottomSheets(null);
    closeAllSnackbars();
  }

  /// **Navigation.popUntil()** (with predicate) shortcut .<br><br>
  ///
  /// Close as many routes as defined by [times]
  ///
  /// [id] is for when you are using nested navigation,
  /// as explained in documentation
  void close<T extends Object>({
    bool closeAll = true,
    bool closeSnackbar = true,
    bool closeDialog = true,
    bool closeBottomSheet = true,
    String? id,
    T? result,
  }) {
    void handleClose(bool closeCondition, Function closeAllFunction,
        Function closeSingleFunction,
        [bool? isOpenCondition]) {
      if (closeCondition) {
        if (closeAll) {
          closeAllFunction();
        } else if (isOpenCondition == true) {
          closeSingleFunction();
        }
      }
    }

    handleClose(closeSnackbar, closeAllSnackbars, closeCurrentSnackbar);
    handleClose(closeDialog, closeAllDialogs, closeOverlay, isDialogOpen);
    handleClose(closeBottomSheet, closeAllBottomSheets, closeOverlay,
        isBottomSheetOpen);
  }

  /// **Navigation.pushReplacement()** shortcut .<br><br>
  ///
  /// Pop the current page and pushes a new `page` to the stack
  ///
  /// It has the advantage of not needing context,
  /// so you can call from your business logic
  ///
  /// You can set a custom [transition], define a Tween [curve],
  /// and a transition [duration].
  ///
  /// You can send any type of value to the other route in the [arguments].
  ///
  /// Just like native routing in Flutter, you can push a route
  /// as a [fullscreenDialog],
  ///
  /// [id] is for when you are using nested navigation,
  /// as explained in documentation
  ///
  /// If you want the same behavior of ios that pops a route when the user drag,
  /// you can set [popGesture] to true
  ///
  /// If you're using the [BindingsInterface] api, you must define it here
  ///
  /// By default, GetX will prevent you from push a route that you already in,
  /// if you want to push anyway, set [preventDuplicates] to false
  Future<T?>? off<T>(
    Widget Function() page, {
    bool? opaque,
    Transition? transition,
    Curve? curve,
    bool? popGesture,
    String? id,
    String? routeName,
    dynamic arguments,
    List<BindingsInterface> bindings = const [],
    bool fullscreenDialog = false,
    bool preventDuplicates = true,
    Duration? duration,
    double Function(BuildContext context)? gestureWidth,
  }) {
    routeName ??= "/${page.runtimeType.toString()}";
    routeName = _cleanRouteName(routeName);
    if (preventDuplicates && routeName == currentRoute) {
      return null;
    }
    return searchDelegate(id).off(
      page,
      opaque: opaque ?? true,
      transition: transition,
      curve: curve,
      popGesture: popGesture,
      id: id,
      routeName: routeName,
      arguments: arguments,
      bindings: bindings,
      fullscreenDialog: fullscreenDialog,
      preventDuplicates: preventDuplicates,
      duration: duration,
      gestureWidth: gestureWidth,
    );
  }

  Future<T?> offUntil<T>(
    Widget Function() page,
    bool Function(GetPage) predicate, [
    Object? arguments,
    String? id,
  ]) {
    return searchDelegate(id).offUntil(
      page,
      predicate,
      arguments,
    );
  }

  ///
  /// Push a `page` and pop several pages in the stack
  /// until [predicate] returns true. [predicate] is optional
  ///
  /// It has the advantage of not needing context,
  /// so you can call from your business logic
  ///
  /// You can set a custom [transition], a [curve] and a transition [duration].
  ///
  /// You can send any type of value to the other route in the [arguments].
  ///
  /// Just like native routing in Flutter, you can push a route
  /// as a [fullscreenDialog],
  ///
  /// [predicate] can be used like this:
  /// `Get.until((route) => Get.currentRoute == '/home')`so when you get to home page,
  /// or also like
  /// `Get.until((route) => !Get.isDialogOpen())`, to make sure the dialog
  /// is closed
  ///
  /// [id] is for when you are using nested navigation,
  /// as explained in documentation
  ///
  /// If you want the same behavior of ios that pops a route when the user drag,
  /// you can set [popGesture] to true
  ///
  /// If you're using the [BindingsInterface] api, you must define it here
  ///
  /// By default, GetX will prevent you from push a route that you already in,
  /// if you want to push anyway, set [preventDuplicates] to false
  Future<T?>? offAll<T>(
    Widget Function() page, {
    bool Function(GetPage<dynamic>)? predicate,
    bool? opaque,
    bool? popGesture,
    String? id,
    String? routeName,
    dynamic arguments,
    List<BindingsInterface> bindings = const [],
    bool fullscreenDialog = false,
    Transition? transition,
    Curve? curve,
    Duration? duration,
    double Function(BuildContext context)? gestureWidth,
  }) {
    routeName ??= "/${page.runtimeType.toString()}";
    routeName = _cleanRouteName(routeName);
    return searchDelegate(id).offAll<T>(
      page,
      predicate: predicate,
      opaque: opaque ?? true,
      popGesture: popGesture,
      id: id,
      //  routeName routeName,
      arguments: arguments,
      bindings: bindings,
      fullscreenDialog: fullscreenDialog,
      transition: transition,
      curve: curve,
      duration: duration,
      gestureWidth: gestureWidth,
    );
  }

  /// Takes a route [name] String generated by [to], [off], [offAll]
  /// (and similar context navigation methods), cleans the extra chars and
  /// accommodates the format.
  /// TODO: check for a more "appealing" URL naming convention.
  /// `() => MyHomeScreenView` becomes `/my-home-screen-view`.
  String _cleanRouteName(String name) {
    name = name.replaceAll('() => ', '');

    /// uncomment for URL styling.
    // name = name.paramCase!;
    if (!name.startsWith('/')) {
      name = '/$name';
    }
    return Uri.tryParse(name)?.toString() ?? name;
  }
  //TODO: Deprecated
  // /// change default config of Get
  // void config(
  //     {bool? enableLog,
  //     LogWriterCallback? logWriterCallback,
  //     bool? defaultPopGesture,
  //     bool? defaultOpaqueRoute,
  //     Duration? defaultDurationTransition,
  //     bool? defaultGlobalState,
  //     Transition? defaultTransition}) {
  //   if (enableLog != null) {
  //     Get.isLogEnable = enableLog;
  //   }
  //   if (logWriterCallback != null) {
  //     Get.log = logWriterCallback;
  //   }
  //   if (defaultPopGesture != null) {
  //     _getxController.defaultPopGesture = defaultPopGesture;
  //   }
  //   if (defaultOpaqueRoute != null) {
  //     _getxController.defaultOpaqueRoute = defaultOpaqueRoute;
  //   }
  //   if (defaultTransition != null) {
  //     _getxController.defaultTransition = defaultTransition;
  //   }

  //   if (defaultDurationTransition != null) {
  //     _getxController.defaultTransitionDuration = defaultDurationTransition;
  //   }
  // }

  Future<void> updateLocale(Locale l) async {
    Get.locale = l;
    await forceAppUpdate();
  }

  /// As a rule, Flutter knows which widget to update,
  /// so this command is rarely needed. We can mention situations
  /// where you use const so that widgets are not updated with setState,
  /// but you want it to be forcefully updated when an event like
  /// language change happens. using context to make the widget dirty
  /// for performRebuild() is a viable solution.
  /// However, in situations where this is not possible, or at least,
  /// is not desired by the developer, the only solution for updating
  /// widgets that Flutter does not want to update is to use reassemble
  /// to forcibly rebuild all widgets. Attention: calling this function will
  /// reconstruct the application from the sketch, use this with caution.
  /// Your entire application will be rebuilt, and touch events will not
  /// work until the end of rendering.
  Future<void> forceAppUpdate() async {
    await engine.performReassemble();
  }

  void appUpdate() => rootController.update();

  void changeTheme(ThemeData theme) {
    rootController.setTheme(theme);
  }

  void changeThemeMode(ThemeMode themeMode) {
    rootController.setThemeMode(themeMode);
  }

  GlobalKey<NavigatorState>? addKey(GlobalKey<NavigatorState> newKey) {
    return rootController.addKey(newKey);
  }

  GetDelegate? nestedKey(String? key) {
    return rootController.nestedKey(key);
  }

  GetDelegate searchDelegate(String? k) {
    GetDelegate key;
    if (k == null) {
      key = Get.rootController.rootDelegate;
    } else {
      if (!keys.containsKey(k)) {
        throw 'Route id ($k) not found';
      }
      key = keys[k]!;
    }

    // if (_key.listenersLength == 0 && !testMode) {
    //   throw """You are trying to use contextless navigation without
    //   a GetMaterialApp or Get.key.
    //   If you are testing your app, you can use:
    //   [Get.testMode = true], or if you are running your app on
    //   a physical device or emulator, you must exchange your [MaterialApp]
    //   for a [GetMaterialApp].
    //   """;
    // }

    return key;
  }

  /// give name from current route
  String get currentRoute => routing.current;

  /// give name from previous route
  String get previousRoute => routing.previous;

  /// check if snackbar is open
  bool get isSnackbarOpen =>
      SnackbarController.isSnackbarBeingShown; //routing.isSnackbar;

  void closeAllSnackbars() {
    SnackbarController.cancelAllSnackbars();
  }

  Future<void> closeCurrentSnackbar() async {
    await SnackbarController.closeCurrentSnackbar();
  }

  /// check if dialog is open
  bool? get isDialogOpen => routing.isDialog;

  /// check if bottomsheet is open
  bool? get isBottomSheetOpen => routing.isBottomSheet;

  /// check a raw current route
  Route<dynamic>? get rawRoute => routing.route;

  /// check if default opaque route is enable
  bool get isOpaqueRouteDefault => defaultOpaqueRoute;

  /// give access to currentContext
  BuildContext? get context => key.currentContext;

  /// give access to current Overlay Context
  BuildContext? get overlayContext {
    BuildContext? overlay;
    key.currentState?.overlay?.context.visitChildElements((element) {
      overlay = element;
    });
    return overlay;
  }

  /// give access to Theme.of(context)
  ThemeData get theme {
    var theme = ThemeData.fallback();
    if (context != null) {
      theme = Theme.of(context!);
    }
    return theme;
  }

  /// The current null safe [WidgetsBinding]
  WidgetsBinding get engine {
    return WidgetsFlutterBinding.ensureInitialized();
  }

  /// The window to which this binding is bound.
  ui.PlatformDispatcher get window => engine.platformDispatcher;

  Locale? get deviceLocale => window.locale;

  ///The number of device pixels for each logical pixel.
  double get pixelRatio => window.implicitView!.devicePixelRatio;

  Size get size => window.implicitView!.physicalSize / pixelRatio;

  ///The horizontal extent of this size.
  double get width => size.width;

  ///The vertical extent of this size
  double get height => size.height;

  ///The distance from the top edge to the first unpadded pixel,
  ///in physical pixels.
  double get statusBarHeight => window.implicitView!.padding.top;

  ///The distance from the bottom edge to the first unpadded pixel,
  ///in physical pixels.
  double get bottomBarHeight => window.implicitView!.padding.bottom;

  ///The system-reported text scale.
  double get textScaleFactor => window.textScaleFactor;

  /// give access to TextTheme.of(context)
  TextTheme get textTheme => theme.textTheme;

  /// give access to Mediaquery.of(context)
  MediaQueryData get mediaQuery => MediaQuery.of(context!);

  /// Check if dark mode theme is enable
  bool get isDarkMode => (theme.brightness == Brightness.dark);

  /// Check if dark mode theme is enable on platform on android Q+
  bool get isPlatformDarkMode =>
      (ui.PlatformDispatcher.instance.platformBrightness == Brightness.dark);

  /// give access to Theme.of(context).iconTheme.color
  Color? get iconColor => theme.iconTheme.color;

  /// give access to FocusScope.of(context)
  FocusNode? get focusScope => FocusManager.instance.primaryFocus;

  // /// give access to Immutable MediaQuery.of(context).size.height
  // double get height => MediaQuery.of(context).size.height;

  // /// give access to Immutable MediaQuery.of(context).size.width
  // double get width => MediaQuery.of(context).size.width;

  GlobalKey<NavigatorState> get key => rootController.key;

  Map<String, GetDelegate> get keys => rootController.keys;

  GetRootState get rootController => GetRootState.controller;

  ConfigData get _getxController => GetRootState.controller.config;

  bool? get defaultPopGesture => _getxController.defaultPopGesture;
  bool get defaultOpaqueRoute => _getxController.defaultOpaqueRoute;

  Transition? get defaultTransition => _getxController.defaultTransition;

  Duration get defaultTransitionDuration {
    return _getxController.defaultTransitionDuration;
  }

  Curve get defaultTransitionCurve => _getxController.defaultTransitionCurve;

  Curve get defaultDialogTransitionCurve {
    return _getxController.defaultDialogTransitionCurve;
  }

  Duration get defaultDialogTransitionDuration {
    return _getxController.defaultDialogTransitionDuration;
  }

  Routing get routing => _getxController.routing;

  bool get _shouldUseMock => GetTestMode.active && !GetRoot.treeInitialized;

  /// give current arguments
  dynamic get arguments {
    return args();
  }

  T args<T>() {
    if (_shouldUseMock) {
      return GetTestMode.arguments as T;
    }
    return rootController.rootDelegate.arguments<T>();
  }

  // set parameters(Map<String, String?> newParameters) {
  //   rootController.parameters = newParameters;
  // }

  // @Deprecated('Use GetTestMode.active=true instead')
  set testMode(bool isTest) => GetTestMode.active = isTest;

  // @Deprecated('Use GetTestMode.active instead')
  bool get testMode => GetTestMode.active;

  Map<String, String?> get parameters {
    if (_shouldUseMock) {
      return GetTestMode.parameters;
    }

    return rootController.rootDelegate.parameters;
  }

  /// Casts the stored router delegate to a desired type
  TDelegate? delegate<TDelegate extends RouterDelegate<TPage>, TPage>() =>
      _getxController.routerDelegate as TDelegate?;
}

extension OverlayExt on GetInterface {
  Future<T> showOverlay<T>({
    required Future<T> Function() asyncFunction,
    Color opacityColor = Colors.black,
    Widget? loadingWidget,
    double opacity = .5,
  }) async {
    final navigatorState =
        Navigator.of(Get.overlayContext!, rootNavigator: false);
    final overlayState = navigatorState.overlay!;

    final overlayEntryOpacity = OverlayEntry(builder: (context) {
      return Opacity(
          opacity: opacity,
          child: Container(
            color: opacityColor,
          ));
    });
    final overlayEntryLoader = OverlayEntry(builder: (context) {
      return loadingWidget ??
          const Center(
              child: SizedBox(
            height: 90,
            width: 90,
            child: Text('Loading...'),
          ));
    });
    overlayState.insert(overlayEntryOpacity);
    overlayState.insert(overlayEntryLoader);

    T data;

    try {
      data = await asyncFunction();
    } on Exception catch (_) {
      overlayEntryLoader.remove();
      overlayEntryOpacity.remove();
      rethrow;
    }

    overlayEntryLoader.remove();
    overlayEntryOpacity.remove();
    return data;
  }
}


--- File Index 3: lib/get_navigation/src/snackbar/snackbar_controller.dart ---
import 'dart:async';
import 'dart:math';
import 'dart:ui';

import 'package:flutter/material.dart';

import '../../../get.dart';
import '../root/get_root.dart';

class SnackbarController {
  final key = GlobalKey<GetSnackBarState>();

  static bool get isSnackbarBeingShown =>
      GetRootState.controller.config.snackBarQueue.isJobInProgress;

  late Animation<double> _filterBlurAnimation;
  late Animation<Color?> _filterColorAnimation;

  final GetSnackBar snackbar;
  final _transitionCompleter = Completer();

  late SnackbarStatusCallback? _snackbarStatus;
  late final Alignment? _initialAlignment;
  late final Alignment? _endAlignment;

  bool _wasDismissedBySwipe = false;

  bool _onTappedDismiss = false;

  Timer? _timer;

  /// The animation that drives the route's transition and the previous route's
  /// forward transition.
  late final Animation<Alignment> _animation;

  /// The animation controller that the route uses to drive the transitions.
  ///
  /// The animation itself is exposed by the [animation] property.
  late final AnimationController _controller;

  SnackbarStatus? _currentStatus;

  final _overlayEntries = <OverlayEntry>[];

  OverlayState? _overlayState;

  SnackbarController(this.snackbar);

  Future<void> get future => _transitionCompleter.future;

  /// Close the snackbar with animation
  Future<void> close({bool withAnimations = true}) async {
    if (!withAnimations) {
      _removeOverlay();
      return;
    }
    _removeEntry();
    await future;
  }

  /// Adds GetSnackbar to a view queue.
  /// Only one GetSnackbar will be displayed at a time, and this method returns
  /// a future to when the snackbar disappears.
  Future<void> show() {
    return GetRootState.controller.config.snackBarQueue.addJob(this);
  }

  void _cancelTimer() {
    if (_timer != null && _timer!.isActive) {
      _timer!.cancel();
    }
  }

  // ignore: avoid_returning_this
  void _configureAlignment(SnackPosition snackPosition) {
    switch (snackbar.snackPosition) {
      case SnackPosition.top:
        {
          _initialAlignment = const Alignment(-1.0, -2.0);
          _endAlignment = const Alignment(-1.0, -1.0);
          break;
        }
      case SnackPosition.bottom:
        {
          _initialAlignment = const Alignment(-1.0, 2.0);
          _endAlignment = const Alignment(-1.0, 1.0);
          break;
        }
    }
  }

  bool _isTesting = false;

  void _configureOverlay() {
    final overlayContext = Get.overlayContext;
    _isTesting = overlayContext == null;
    _overlayState =
        _isTesting ? OverlayState() : Overlay.of(Get.overlayContext!);
    _overlayEntries.clear();
    _overlayEntries.addAll(_createOverlayEntries(_getBodyWidget()));
    if (!_isTesting) {
      _overlayState!.insertAll(_overlayEntries);
    }

    _configureSnackBarDisplay();
  }

  void _configureSnackBarDisplay() {
    assert(!_transitionCompleter.isCompleted,
        'Cannot configure a snackbar after disposing it.');
    _controller = _createAnimationController();
    _configureAlignment(snackbar.snackPosition);
    _snackbarStatus = snackbar.snackbarStatus;
    _filterBlurAnimation = _createBlurFilterAnimation();
    _filterColorAnimation = _createColorOverlayColor();
    _animation = _createAnimation();
    _animation.addStatusListener(_handleStatusChanged);
    _configureTimer();
    _controller.forward();
  }

  void _configureTimer() {
    if (snackbar.duration != null) {
      if (_timer != null && _timer!.isActive) {
        _timer!.cancel();
      }
      _timer = Timer(snackbar.duration!, _removeEntry);
    } else {
      if (_timer != null) {
        _timer!.cancel();
      }
    }
  }

  /// Called to create the animation that exposes the current progress of
  /// the transition controlled by the animation controller created by
  /// `createAnimationController()`.
  Animation<Alignment> _createAnimation() {
    assert(!_transitionCompleter.isCompleted,
        'Cannot create a animation from a disposed snackbar');
    return AlignmentTween(begin: _initialAlignment, end: _endAlignment).animate(
      CurvedAnimation(
        parent: _controller,
        curve: snackbar.forwardAnimationCurve,
        reverseCurve: snackbar.reverseAnimationCurve,
      ),
    );
  }

  /// Called to create the animation controller that will drive the transitions
  /// to this route from the previous one, and back to the previous route
  /// from this one.
  AnimationController _createAnimationController() {
    assert(!_transitionCompleter.isCompleted,
        'Cannot create a animationController from a disposed snackbar');
    assert(snackbar.animationDuration >= Duration.zero);
    return AnimationController(
      duration: snackbar.animationDuration,
      debugLabel: '$runtimeType',
      vsync: _overlayState!,
    );
  }

  Animation<double> _createBlurFilterAnimation() {
    return Tween(begin: 0.0, end: snackbar.overlayBlur).animate(
      CurvedAnimation(
        parent: _controller,
        curve: const Interval(
          0.0,
          0.35,
          curve: Curves.easeInOutCirc,
        ),
      ),
    );
  }

  Animation<Color?> _createColorOverlayColor() {
    return ColorTween(
            begin: const Color(0x00000000), end: snackbar.overlayColor)
        .animate(
      CurvedAnimation(
        parent: _controller,
        curve: const Interval(
          0.0,
          0.35,
          curve: Curves.easeInOutCirc,
        ),
      ),
    );
  }

  Iterable<OverlayEntry> _createOverlayEntries(Widget child) {
    return <OverlayEntry>[
      if (snackbar.overlayBlur > 0.0) ...[
        OverlayEntry(
          builder: (context) => GestureDetector(
            onTap: () {
              if (snackbar.isDismissible && !_onTappedDismiss) {
                _onTappedDismiss = true;
                close();
              }
            },
            child: AnimatedBuilder(
              animation: _filterBlurAnimation,
              builder: (context, child) {
                return BackdropFilter(
                  filter: ImageFilter.blur(
                    sigmaX: max(0.001, _filterBlurAnimation.value),
                    sigmaY: max(0.001, _filterBlurAnimation.value),
                  ),
                  child: Container(
                    constraints: const BoxConstraints.expand(),
                    color: _filterColorAnimation.value,
                  ),
                );
              },
            ),
          ),
          maintainState: false,
          opaque: false,
        ),
      ],
      OverlayEntry(
        builder: (context) => Semantics(
          focused: false,
          container: true,
          explicitChildNodes: true,
          child: AlignTransition(
            alignment: _animation,
            child: snackbar.isDismissible
                ? _getDismissibleSnack(child)
                : _getSnackbarContainer(child),
          ),
        ),
        maintainState: false,
        opaque: false,
      ),
    ];
  }

  Widget _getBodyWidget() {
    return Builder(builder: (_) {
      return MouseRegion(
        onEnter: (_) =>
            snackbar.onHover?.call(snackbar, SnackHoverState.entered),
        onExit: (_) => snackbar.onHover?.call(snackbar, SnackHoverState.exited),
        child: GestureDetector(
          behavior: snackbar.hitTestBehavior ?? HitTestBehavior.deferToChild,
          onTap: snackbar.onTap != null
              ? () => snackbar.onTap?.call(snackbar)
              : null,
          child: snackbar,
        ),
      );
    });
  }

  DismissDirection _getDefaultDismissDirection() {
    if (snackbar.snackPosition == SnackPosition.top) {
      return DismissDirection.up;
    }
    return DismissDirection.down;
  }

  Widget _getDismissibleSnack(Widget child) {
    return Dismissible(
      behavior: snackbar.hitTestBehavior ?? HitTestBehavior.opaque,
      direction: snackbar.dismissDirection ?? _getDefaultDismissDirection(),
      resizeDuration: null,
      confirmDismiss: (_) {
        if (_currentStatus == SnackbarStatus.opening ||
            _currentStatus == SnackbarStatus.closing) {
          return Future.value(false);
        }
        return Future.value(true);
      },
      key: const Key('dismissible'),
      onDismissed: (_) {
        _wasDismissedBySwipe = true;
        _removeEntry();
      },
      child: _getSnackbarContainer(child),
    );
  }

  Widget _getSnackbarContainer(Widget child) {
    return Container(
      margin: snackbar.margin,
      child: child,
    );
  }

  void _handleStatusChanged(AnimationStatus status) {
    switch (status) {
      case AnimationStatus.completed:
        _currentStatus = SnackbarStatus.open;
        _snackbarStatus?.call(_currentStatus);
        if (_overlayEntries.isNotEmpty) _overlayEntries.first.opaque = false;

        break;
      case AnimationStatus.forward:
        _currentStatus = SnackbarStatus.opening;
        _snackbarStatus?.call(_currentStatus);
        break;
      case AnimationStatus.reverse:
        _currentStatus = SnackbarStatus.closing;
        _snackbarStatus?.call(_currentStatus);
        if (_overlayEntries.isNotEmpty) _overlayEntries.first.opaque = false;
        break;
      case AnimationStatus.dismissed:
        assert(!_overlayEntries.first.opaque);
        _currentStatus = SnackbarStatus.closed;
        _snackbarStatus?.call(_currentStatus);
        _removeOverlay();
        break;
    }
  }

  void _removeEntry() {
    assert(
      !_transitionCompleter.isCompleted,
      'Cannot remove entry from a disposed snackbar',
    );

    _cancelTimer();

    if (_wasDismissedBySwipe) {
      Timer(const Duration(milliseconds: 200), _controller.reset);
      _wasDismissedBySwipe = false;
    } else {
      _controller.reverse();
    }
  }

  void _removeOverlay() {
    if (!_isTesting) {
      for (var element in _overlayEntries) {
        element.remove();
      }
    }

    assert(!_transitionCompleter.isCompleted,
        'Cannot remove overlay from a disposed snackbar');
    _controller.dispose();
    _overlayEntries.clear();
    _transitionCompleter.complete();
  }

  Future<void> _show() {
    _configureOverlay();
    return future;
  }

  static Future<void> cancelAllSnackbars() async {
    await GetRootState.controller.config.snackBarQueue.cancelAllJobs();
  }

  static Future<void> closeCurrentSnackbar() async {
    await GetRootState.controller.config.snackBarQueue.closeCurrentJob();
  }
}

class SnackBarQueue {
  final _queue = GetQueue();
  final _snackbarList = <SnackbarController>[];

  SnackbarController? get _currentSnackbar {
    if (_snackbarList.isEmpty) return null;
    return _snackbarList.first;
  }

  bool get isJobInProgress => _snackbarList.isNotEmpty;

  Future<void> addJob(SnackbarController job) async {
    _snackbarList.add(job);
    final data = await _queue.add(job._show);
    _snackbarList.remove(job);
    return data;
  }

  Future<void> cancelAllJobs() async {
    await _currentSnackbar?.close();
    _queue.cancelAllJobs();
    _snackbarList.clear();
  }

  void disposeControllers() {
    if (_currentSnackbar != null) {
      _currentSnackbar?._removeOverlay();
      _currentSnackbar?._controller.dispose();
      _snackbarList.remove(_currentSnackbar);
    }

    _queue.cancelAllJobs();

    for (var element in _snackbarList) {
      element._controller.dispose();
    }
    _snackbarList.clear();
  }

  Future<void> closeCurrentJob() async {
    if (_currentSnackbar == null) return;
    await _currentSnackbar!.close();
  }
}


--- File Index 4: lib/get_navigation/src/snackbar/snackbar.dart ---
import 'dart:async';
import 'dart:ui';

import 'package:flutter/material.dart';

import '../../../get_core/get_core.dart';
import '../../get_navigation.dart';

typedef OnTap = void Function(GetSnackBar snack);
typedef OnHover = void Function(
    GetSnackBar snack, SnackHoverState snackHoverState);

typedef SnackbarStatusCallback = void Function(SnackbarStatus? status);

class GetSnackBar extends StatefulWidget {
  /// A callback for you to listen to the different Snack status
  final SnackbarStatusCallback? snackbarStatus;

  /// The title displayed to the user
  final String? title;

  /// Defines how the snack bar area, including margin, will behave during hit testing.
  ///
  /// If this property is null and [margin] is not null, then [HitTestBehavior.deferToChild] is used by default.
  ///
  /// Please refer to [HitTestBehavior] for a detailed explanation of every behavior.
  final HitTestBehavior? hitTestBehavior;

  /// The direction in which the SnackBar can be dismissed.
  ///
  /// Default is [DismissDirection.down] when
  /// [snackPosition] == [SnackPosition.BOTTOM] and [DismissDirection.up]
  /// when [snackPosition] == [SnackPosition.TOP]
  final DismissDirection? dismissDirection;

  /// The message displayed to the user.
  final String? message;

  /// Replaces [title]. Although this accepts a [Widget], it is meant
  /// to receive [Text] or [RichText]
  final Widget? titleText;

  /// Replaces [message]. Although this accepts a [Widget], it is meant
  /// to receive [Text] or  [RichText]
  final Widget? messageText;

  /// Will be ignored if [backgroundGradient] is not null
  final Color backgroundColor;

  /// If not null, shows a left vertical colored bar on notification.
  /// It is not possible to use it with a [Form] and I do not recommend
  /// using it with [LinearProgressIndicator]
  final Color? leftBarIndicatorColor;

  /// [boxShadows] The shadows generated by Snack. Leave it null
  /// if you don't want a shadow.
  /// You can use more than one if you feel the need.
  /// Check (this example)[https://github.com/flutter/flutter/blob/master/packages/flutter/lib/src/material/shadows.dart]
  final List<BoxShadow>? boxShadows;

  /// Give to GetSnackbar a gradient background.
  /// It Makes [backgroundColor] be ignored.
  final Gradient? backgroundGradient;

  /// You can use any widget here, but I recommend [Icon] or [Image] as
  /// indication of what kind
  /// of message you are displaying. Other widgets may break the layout
  final Widget? icon;

  /// An option to animate the icon (if present). Defaults to true.
  final bool shouldIconPulse;

  /// (optional) An action that the user can take based on the snack bar.
  ///
  /// For example, the snack bar might let the user undo the operation that
  /// prompted the snackbar.
  final Widget? mainButton;

  /// A callback that registers the user's click anywhere.
  /// An alternative to [mainButton]
  final OnTap? onTap;

  /// A callback that registers the user's hover anywhere over the Snackbar.
  final OnHover? onHover;

  /// How long until Snack will hide itself (be dismissed).
  /// To make it indefinite, leave it null.
  final Duration? duration;

  /// True if you want to show a [LinearProgressIndicator].
  final bool showProgressIndicator;

  /// An optional [AnimationController] when you want to control the
  /// progress of your [LinearProgressIndicator].
  final AnimationController? progressIndicatorController;

  /// A [LinearProgressIndicator] configuration parameter.
  final Color? progressIndicatorBackgroundColor;

  /// A [LinearProgressIndicator] configuration parameter.
  final Animation<Color>? progressIndicatorValueColor;

  /// Determines if the user can swipe or click the overlay
  /// (if [overlayBlur] > 0) to dismiss.
  /// It is recommended that you set [duration] != null if this is false.
  /// If the user swipes to dismiss or clicks the overlay, no value
  /// will be returned.
  final bool isDismissible;

  /// Used to limit Snack width (usually on large screens)
  final double? maxWidth;

  /// Adds a custom margin to Snack
  final EdgeInsets margin;

  /// Adds a custom padding to Snack
  /// The default follows material design guide line
  final EdgeInsets padding;

  /// Adds a radius to all corners of Snack. Best combined with [margin].
  /// I do not recommend using it with [showProgressIndicator]
  /// or [leftBarIndicatorColor].
  final double borderRadius;

  /// Adds a border to every side of Snack
  /// I do not recommend using it with [showProgressIndicator]
  /// or [leftBarIndicatorColor].
  final Color? borderColor;

  /// Changes the width of the border if [borderColor] is specified
  final double? borderWidth;

  /// Snack can be based on [SnackPosition.TOP] or on [SnackPosition.BOTTOM]
  /// of your screen.
  /// [SnackPosition.BOTTOM] is the default.
  final SnackPosition snackPosition;

  /// Snack can be floating or be grounded to the edge of the screen.
  /// If grounded, I do not recommend using [margin] or [borderRadius].
  /// [SnackStyle.FLOATING] is the default
  /// If grounded, I do not recommend using a [backgroundColor] with
  /// transparency or [barBlur]
  final SnackStyle snackStyle;

  /// The [Curve] animation used when show() is called.
  /// [Curves.easeOut] is default
  final Curve forwardAnimationCurve;

  /// The [Curve] animation used when dismiss() is called.
  /// [Curves.fastOutSlowIn] is default
  final Curve reverseAnimationCurve;

  /// Use it to speed up or slow down the animation duration
  final Duration animationDuration;

  /// Default is 0.0. If different than 0.0, blurs only Snack's background.
  /// To take effect, make sure your [backgroundColor] has some opacity.
  /// The greater the value, the greater the blur.
  final double barBlur;

  /// Default is 0.0. If different than 0.0, creates a blurred
  /// overlay that prevents the user from interacting with the screen.
  /// The greater the value, the greater the blur.
  final double overlayBlur;

  /// Default is [Colors.transparent]. Only takes effect if [overlayBlur] > 0.0.
  /// Make sure you use a color with transparency here e.g.
  /// Colors.grey[600].withValues(alpha:0.2).
  final Color? overlayColor;

  /// A [TextFormField] in case you want a simple user input.
  /// Every other widget is ignored if this is not null.
  final Form? userInputForm;

  const GetSnackBar({
    super.key,
    this.title,
    this.message,
    this.titleText,
    this.messageText,
    this.icon,
    this.shouldIconPulse = true,
    this.maxWidth,
    this.margin = const EdgeInsets.all(0.0),
    this.padding = const EdgeInsets.all(16),
    this.borderRadius = 0.0,
    this.borderColor,
    this.borderWidth = 1.0,
    this.backgroundColor = const Color(0xFF303030),
    this.leftBarIndicatorColor,
    this.boxShadows,
    this.backgroundGradient,
    this.mainButton,
    this.onTap,
    this.onHover,
    this.duration,
    this.isDismissible = true,
    this.dismissDirection,
    this.showProgressIndicator = false,
    this.progressIndicatorController,
    this.progressIndicatorBackgroundColor,
    this.progressIndicatorValueColor,
    this.snackPosition = SnackPosition.bottom,
    this.snackStyle = SnackStyle.floating,
    this.forwardAnimationCurve = Curves.easeOutCirc,
    this.reverseAnimationCurve = Curves.easeOutCirc,
    this.animationDuration = const Duration(seconds: 1),
    this.barBlur = 0.0,
    this.overlayBlur = 0.0,
    this.overlayColor = Colors.transparent,
    this.userInputForm,
    this.snackbarStatus,
    this.hitTestBehavior,
  });

  @override
  State createState() => GetSnackBarState();

  /// Show the snack. It's call [SnackbarStatus.OPENING] state
  /// followed by [SnackbarStatus.OPEN]
  SnackbarController show() {
    return Get.showSnackbar(this);
  }
}

class GetSnackBarState extends State<GetSnackBar>
    with TickerProviderStateMixin {
  AnimationController? _fadeController;
  late Animation<double> _fadeAnimation;

  final Widget _emptyWidget = const SizedBox(width: 0.0, height: 0.0);
  final double _initialOpacity = 1.0;
  final double _finalOpacity = 0.4;

  final Duration _pulseAnimationDuration = const Duration(seconds: 1);

  late bool _isTitlePresent;
  late double _messageTopMargin;

  FocusScopeNode? _focusNode;
  late FocusAttachment _focusAttachment;

  final Completer<Size> _boxHeightCompleter = Completer<Size>();

  late CurvedAnimation _progressAnimation;

  final _backgroundBoxKey = GlobalKey();

  double get buttonPadding {
    if (widget.padding.right - 12 < 0) {
      return 4;
    } else {
      return widget.padding.right - 12;
    }
  }

  RowStyle get _rowStyle {
    if (widget.mainButton != null && widget.icon == null) {
      return RowStyle.action;
    } else if (widget.mainButton == null && widget.icon != null) {
      return RowStyle.icon;
    } else if (widget.mainButton != null && widget.icon != null) {
      return RowStyle.all;
    } else {
      return RowStyle.none;
    }
  }

  @override
  Widget build(BuildContext context) {
    return Align(
      heightFactor: 1.0,
      child: Material(
        color: widget.snackStyle == SnackStyle.floating
            ? Colors.transparent
            : widget.backgroundColor,
        child: SafeArea(
          minimum: widget.snackPosition == SnackPosition.bottom
              ? EdgeInsets.only(
                  bottom: MediaQuery.of(context).viewInsets.bottom)
              : EdgeInsets.only(top: MediaQuery.of(context).padding.top),
          bottom: widget.snackPosition == SnackPosition.bottom,
          top: widget.snackPosition == SnackPosition.top,
          left: false,
          right: false,
          child: Stack(
            children: [
              FutureBuilder<Size>(
                future: _boxHeightCompleter.future,
                builder: (context, snapshot) {
                  if (snapshot.hasData) {
                    if (widget.barBlur == 0) {
                      return _emptyWidget;
                    }
                    return ClipRRect(
                      borderRadius: BorderRadius.circular(widget.borderRadius),
                      child: BackdropFilter(
                        filter: ImageFilter.blur(
                            sigmaX: widget.barBlur, sigmaY: widget.barBlur),
                        child: Container(
                          height: snapshot.data!.height,
                          width: snapshot.data!.width,
                          decoration: BoxDecoration(
                            color: Colors.transparent,
                            borderRadius:
                                BorderRadius.circular(widget.borderRadius),
                          ),
                        ),
                      ),
                    );
                  } else {
                    return _emptyWidget;
                  }
                },
              ),
              if (widget.userInputForm != null)
                _containerWithForm()
              else
                _containerWithoutForm()
            ],
          ),
        ),
      ),
    );
  }

  @override
  void dispose() {
    _fadeController?.dispose();
    widget.progressIndicatorController?.removeListener(_updateProgress);
    widget.progressIndicatorController?.dispose();

    _focusAttachment.detach();
    _focusNode!.dispose();
    super.dispose();
  }

  @override
  void initState() {
    super.initState();

    assert(
        widget.userInputForm != null ||
            ((widget.message != null && widget.message!.isNotEmpty) ||
                widget.messageText != null),
        '''
You need to either use message[String], or messageText[Widget] or define a userInputForm[Form] in GetSnackbar''');

    _isTitlePresent = (widget.title != null || widget.titleText != null);
    _messageTopMargin = _isTitlePresent ? 6.0 : widget.padding.top;

    _configureLeftBarFuture();
    _configureProgressIndicatorAnimation();

    if (widget.icon != null && widget.shouldIconPulse) {
      _configurePulseAnimation();
      _fadeController?.forward();
    }

    _focusNode = FocusScopeNode();
    _focusAttachment = _focusNode!.attach(context);
  }

  Widget _buildLeftBarIndicator() {
    if (widget.leftBarIndicatorColor != null) {
      return FutureBuilder<Size>(
        future: _boxHeightCompleter.future,
        builder: (buildContext, snapshot) {
          if (snapshot.hasData) {
            return Container(
              color: widget.leftBarIndicatorColor,
              width: 5.0,
              height: snapshot.data!.height,
            );
          } else {
            return _emptyWidget;
          }
        },
      );
    } else {
      return _emptyWidget;
    }
  }

  void _configureLeftBarFuture() {
    Engine.instance.addPostFrameCallback(
      (_) {
        final keyContext = _backgroundBoxKey.currentContext;
        if (keyContext != null) {
          final box = keyContext.findRenderObject() as RenderBox;
          _boxHeightCompleter.complete(box.size);
        }
      },
    );
  }

  void _configureProgressIndicatorAnimation() {
    if (widget.showProgressIndicator &&
        widget.progressIndicatorController != null) {
      widget.progressIndicatorController!.addListener(_updateProgress);

      _progressAnimation = CurvedAnimation(
          curve: Curves.linear, parent: widget.progressIndicatorController!);
    }
  }

  void _configurePulseAnimation() {
    _fadeController =
        AnimationController(vsync: this, duration: _pulseAnimationDuration);
    _fadeAnimation = Tween(begin: _initialOpacity, end: _finalOpacity).animate(
      CurvedAnimation(
        parent: _fadeController!,
        curve: Curves.linear,
      ),
    );

    _fadeController!.addStatusListener((status) {
      if (status == AnimationStatus.completed) {
        _fadeController!.reverse();
      }
      if (status == AnimationStatus.dismissed) {
        _fadeController!.forward();
      }
    });

    _fadeController!.forward();
  }

  Widget _containerWithForm() {
    return Container(
      key: _backgroundBoxKey,
      constraints: widget.maxWidth != null
          ? BoxConstraints(maxWidth: widget.maxWidth!)
          : null,
      decoration: BoxDecoration(
        color: widget.backgroundColor,
        gradient: widget.backgroundGradient,
        boxShadow: widget.boxShadows,
        borderRadius: BorderRadius.circular(widget.borderRadius),
        border: widget.borderColor != null
            ? Border.all(
                color: widget.borderColor!,
                width: widget.borderWidth!,
              )
            : null,
      ),
      child: Padding(
        padding: const EdgeInsets.only(
            left: 8.0, right: 8.0, bottom: 8.0, top: 16.0),
        child: FocusScope(
          node: _focusNode,
          autofocus: true,
          child: widget.userInputForm!,
        ),
      ),
    );
  }

  Widget _containerWithoutForm() {
    final iconPadding = widget.padding.left > 16.0 ? widget.padding.left : 0.0;
    final left = _rowStyle == RowStyle.icon || _rowStyle == RowStyle.all
        ? 4.0
        : widget.padding.left;
    final right = _rowStyle == RowStyle.action || _rowStyle == RowStyle.all
        ? 8.0
        : widget.padding.right;
    return Container(
      key: _backgroundBoxKey,
      constraints: widget.maxWidth != null
          ? BoxConstraints(maxWidth: widget.maxWidth!)
          : null,
      decoration: BoxDecoration(
        color: widget.backgroundColor,
        gradient: widget.backgroundGradient,
        boxShadow: widget.boxShadows,
        borderRadius: BorderRadius.circular(widget.borderRadius),
        border: widget.borderColor != null
            ? Border.all(color: widget.borderColor!, width: widget.borderWidth!)
            : null,
      ),
      child: Column(
        mainAxisSize: MainAxisSize.min,
        children: [
          widget.showProgressIndicator
              ? LinearProgressIndicator(
                  value: widget.progressIndicatorController != null
                      ? _progressAnimation.value
                      : null,
                  backgroundColor: widget.progressIndicatorBackgroundColor,
                  valueColor: widget.progressIndicatorValueColor,
                )
              : _emptyWidget,
          Row(
            mainAxisSize: MainAxisSize.max,
            children: [
              _buildLeftBarIndicator(),
              if (_rowStyle == RowStyle.icon || _rowStyle == RowStyle.all)
                ConstrainedBox(
                  constraints:
                      BoxConstraints.tightFor(width: 42.0 + iconPadding),
                  child: _getIcon(),
                ),
              Expanded(
                flex: 1,
                child: Column(
                  crossAxisAlignment: CrossAxisAlignment.stretch,
                  mainAxisSize: MainAxisSize.min,
                  children: <Widget>[
                    if (_isTitlePresent)
                      Padding(
                        padding: EdgeInsets.only(
                          top: widget.padding.top,
                          left: left,
                          right: right,
                        ),
                        child: widget.titleText ??
                            Text(
                              widget.title ?? "",
                              style: const TextStyle(
                                fontSize: 16.0,
                                color: Colors.white,
                                fontWeight: FontWeight.bold,
                              ),
                            ),
                      )
                    else
                      _emptyWidget,
                    Padding(
                      padding: EdgeInsets.only(
                        top: _messageTopMargin,
                        left: left,
                        right: right,
                        bottom: widget.padding.bottom,
                      ),
                      child: widget.messageText ??
                          Text(
                            widget.message ?? "",
                            style: const TextStyle(
                                fontSize: 14.0, color: Colors.white),
                          ),
                    ),
                  ],
                ),
              ),
              if (_rowStyle == RowStyle.action || _rowStyle == RowStyle.all)
                Padding(
                  padding: EdgeInsets.only(right: buttonPadding),
                  child: widget.mainButton,
                ),
            ],
          ),
        ],
      ),
    );
  }

  Widget? _getIcon() {
    if (widget.icon != null && widget.icon is Icon && widget.shouldIconPulse) {
      return FadeTransition(
        opacity: _fadeAnimation,
        child: widget.icon,
      );
    } else if (widget.icon != null) {
      return widget.icon;
    } else {
      return _emptyWidget;
    }
  }

  void _updateProgress() => setState(() {});
}

enum RowStyle {
  icon,
  action,
  all,
  none,
}

/// Indicates Status of snackbar
/// [SnackbarStatus.OPEN] Snack is fully open, [SnackbarStatus.CLOSED] Snackbar
/// has closed,
/// [SnackbarStatus.OPENING] Starts with the opening animation and ends
/// with the full
/// snackbar display, [SnackbarStatus.CLOSING] Starts with the closing animation
/// and ends
/// with the full snackbar dispose
enum SnackbarStatus { open, closed, opening, closing }

/// Indicates if snack is going to start at the [TOP] or at the [BOTTOM]
enum SnackPosition { top, bottom }

/// Indicates if snack will be attached to the edge of the screen or not
enum SnackStyle { floating, grounded }

/// Indicates if the mouse entered or exited
enum SnackHoverState { entered, exited }


--- File Index 5: lib/get_navigation/src/dialog/dialog_route.dart ---
import 'package:flutter/widgets.dart';

import '../router_report.dart';

class GetDialogRoute<T> extends PopupRoute<T> {
  GetDialogRoute({
    required RoutePageBuilder pageBuilder,
    bool barrierDismissible = true,
    String? barrierLabel,
    Color barrierColor = const Color(0x80000000),
    Duration transitionDuration = const Duration(milliseconds: 200),
    RouteTransitionsBuilder? transitionBuilder,
    super.settings,
  })  : widget = pageBuilder,
        _barrierDismissible = barrierDismissible,
        _barrierLabel = barrierLabel,
        _barrierColor = barrierColor,
        _transitionDuration = transitionDuration,
        _transitionBuilder = transitionBuilder {
    RouterReportManager.instance.reportCurrentRoute(this);
  }

  final RoutePageBuilder widget;

  @override
  bool get barrierDismissible => _barrierDismissible;
  final bool _barrierDismissible;

  @override
  void dispose() {
    RouterReportManager.instance.reportRouteDispose(this);
    super.dispose();
  }

  @override
  String? get barrierLabel => _barrierLabel;
  final String? _barrierLabel;

  @override
  Color get barrierColor => _barrierColor;
  final Color _barrierColor;

  @override
  Duration get transitionDuration => _transitionDuration;
  final Duration _transitionDuration;

  final RouteTransitionsBuilder? _transitionBuilder;

  @override
  Widget buildPage(BuildContext context, Animation<double> animation,
      Animation<double> secondaryAnimation) {
    return Semantics(
      scopesRoute: true,
      explicitChildNodes: true,
      child: widget(context, animation, secondaryAnimation),
    );
  }

  @override
  Widget buildTransitions(BuildContext context, Animation<double> animation,
      Animation<double> secondaryAnimation, Widget child) {
    if (_transitionBuilder == null) {
      return FadeTransition(
          opacity: CurvedAnimation(
            parent: animation,
            curve: Curves.linear,
          ),
          child: child);
    } // Some default transition
    return _transitionBuilder(context, animation, secondaryAnimation, child);
  }
}


--- File Index 6: lib/get_navigation/src/bottomsheet/bottomsheet.dart ---
import 'package:flutter/material.dart';

import '../../../get.dart';
import '../router_report.dart';

class GetModalBottomSheetRoute<T> extends PopupRoute<T> {
  GetModalBottomSheetRoute({
    this.builder,
    this.theme,
    this.barrierLabel,
    this.backgroundColor,
    this.isPersistent,
    this.elevation,
    this.shape,
    this.removeTop = true,
    this.clipBehavior,
    this.modalBarrierColor,
    this.isDismissible = true,
    this.enableDrag = true,
    required this.isScrollControlled,
    super.settings,
    this.enterBottomSheetDuration = const Duration(milliseconds: 250),
    this.exitBottomSheetDuration = const Duration(milliseconds: 200),
    this.curve,
  }) {
    RouterReportManager.instance.reportCurrentRoute(this);
  }
  final bool? isPersistent;
  final WidgetBuilder? builder;
  final ThemeData? theme;
  final bool isScrollControlled;
  final Color? backgroundColor;
  final double? elevation;
  final ShapeBorder? shape;
  final Clip? clipBehavior;
  final Color? modalBarrierColor;
  final bool isDismissible;
  final bool enableDrag;
  // final String name;
  final Duration enterBottomSheetDuration;
  final Duration exitBottomSheetDuration;
  final Curve? curve;
  // remove safearea from top
  final bool removeTop;

  @override
  Duration get transitionDuration => const Duration(milliseconds: 700);

  @override
  bool get barrierDismissible => isDismissible;

  @override
  final String? barrierLabel;

  @override
  Color get barrierColor => modalBarrierColor ?? Colors.black54;

  AnimationController? _animationController;

  @override
  void dispose() {
    RouterReportManager.instance.reportRouteDispose(this);
    super.dispose();
  }

  @override
  Animation<double> createAnimation() {
    if (curve != null) {
      return CurvedAnimation(curve: curve!, parent: _animationController!.view);
    }
    return _animationController!.view;
  }

  @override
  AnimationController createAnimationController() {
    assert(_animationController == null);
    _animationController =
        BottomSheet.createAnimationController(navigator!.overlay!);
    _animationController!.duration = enterBottomSheetDuration;
    _animationController!.reverseDuration = exitBottomSheetDuration;
    return _animationController!;
  }

  @override
  Widget buildPage(BuildContext context, Animation<double> animation,
      Animation<double> secondaryAnimation) {
    final sheetTheme =
        theme?.bottomSheetTheme ?? Theme.of(context).bottomSheetTheme;
    // By definition, the bottom sheet is aligned to the bottom of the page
    // and isn't exposed to the top padding of the MediaQuery.
    Widget bottomSheet = MediaQuery.removePadding(
      context: context,
      removeTop: removeTop,
      child: Padding(
        padding:
            EdgeInsets.only(bottom: MediaQuery.of(context).viewInsets.bottom),
        child: _GetModalBottomSheet<T>(
          route: this,
          backgroundColor: backgroundColor ??
              sheetTheme.modalBackgroundColor ??
              sheetTheme.backgroundColor,
          elevation:
              elevation ?? sheetTheme.modalElevation ?? sheetTheme.elevation,
          shape: shape,
          clipBehavior: clipBehavior,
          isScrollControlled: isScrollControlled,
          enableDrag: enableDrag,
        ),
      ),
    );
    if (theme != null) bottomSheet = Theme(data: theme!, child: bottomSheet);
    return bottomSheet;
  }
}

class _GetModalBottomSheet<T> extends StatefulWidget {
  const _GetModalBottomSheet({
    super.key,
    this.route,
    this.backgroundColor,
    this.elevation,
    this.shape,
    this.clipBehavior,
    this.isScrollControlled = false,
    this.enableDrag = true,
    this.isPersistent = false,
  });
  final bool isPersistent;
  final GetModalBottomSheetRoute<T>? route;
  final bool isScrollControlled;
  final Color? backgroundColor;
  final double? elevation;
  final ShapeBorder? shape;
  final Clip? clipBehavior;
  final bool enableDrag;

  @override
  _GetModalBottomSheetState<T> createState() => _GetModalBottomSheetState<T>();
}

class _GetModalBottomSheetState<T> extends State<_GetModalBottomSheet<T>> {
  String _getRouteLabel(MaterialLocalizations localizations) {
    if ((Theme.of(context).platform == TargetPlatform.android) ||
        (Theme.of(context).platform == TargetPlatform.fuchsia)) {
      return localizations.dialogLabel;
    } else {
      return '';
    }
  }

  @override
  Widget build(BuildContext context) {
    assert(debugCheckHasMediaQuery(context));
    assert(debugCheckHasMaterialLocalizations(context));
    final mediaQuery = MediaQuery.of(context);
    final localizations = MaterialLocalizations.of(context);
    final routeLabel = _getRouteLabel(localizations);

    return AnimatedBuilder(
      animation: widget.route!.animation!,
      builder: (context, child) {
        // Disable the initial animation when accessible navigation is on so
        // that the semantics are added to the tree at the correct time.
        final animationValue = mediaQuery.accessibleNavigation
            ? 1.0
            : widget.route!.animation!.value;
        return Semantics(
          scopesRoute: true,
          namesRoute: true,
          label: routeLabel,
          explicitChildNodes: true,
          child: ClipRect(
            child: CustomSingleChildLayout(
                delegate: _GetModalBottomSheetLayout(
                    animationValue, widget.isScrollControlled),
                child: widget.isPersistent == false
                    ? BottomSheet(
                        animationController: widget.route!._animationController,
                        onClosing: () {
                          if (widget.route!.isCurrent) {
                            Navigator.pop(context);
                          }
                        },
                        builder: widget.route!.builder!,
                        backgroundColor: widget.backgroundColor,
                        elevation: widget.elevation,
                        shape: widget.shape,
                        clipBehavior: widget.clipBehavior,
                        enableDrag: widget.enableDrag,
                      )
                    : Scaffold(
                        bottomSheet: BottomSheet(
                          animationController:
                              widget.route!._animationController,
                          onClosing: () {
                            // if (widget.route.isCurrent) {
                            //   Navigator.pop(context);
                            // }
                          },
                          builder: widget.route!.builder!,
                          backgroundColor: widget.backgroundColor,
                          elevation: widget.elevation,
                          shape: widget.shape,
                          clipBehavior: widget.clipBehavior,
                          enableDrag: widget.enableDrag,
                        ),
                      )),
          ),
        );
      },
    );
  }
}

class _GetPerModalBottomSheet<T> extends StatefulWidget {
  const _GetPerModalBottomSheet({
    super.key,
    this.route,
    this.isPersistent,
    this.backgroundColor,
    this.elevation,
    this.shape,
    this.clipBehavior,
    this.isScrollControlled = false,
    this.enableDrag = true,
  });
  final bool? isPersistent;
  final GetModalBottomSheetRoute<T>? route;
  final bool isScrollControlled;
  final Color? backgroundColor;
  final double? elevation;
  final ShapeBorder? shape;
  final Clip? clipBehavior;
  final bool enableDrag;

  @override
  // ignore: lines_longer_than_80_chars
  _GetPerModalBottomSheetState<T> createState() =>
      _GetPerModalBottomSheetState<T>();
}

// ignore: lines_longer_than_80_chars
class _GetPerModalBottomSheetState<T>
    extends State<_GetPerModalBottomSheet<T>> {
  String _getRouteLabel(MaterialLocalizations localizations) {
    if ((Theme.of(context).platform == TargetPlatform.android) ||
        (Theme.of(context).platform == TargetPlatform.fuchsia)) {
      return localizations.dialogLabel;
    } else {
      return '';
    }
  }

  @override
  Widget build(BuildContext context) {
    assert(debugCheckHasMediaQuery(context));
    assert(debugCheckHasMaterialLocalizations(context));
    final mediaQuery = MediaQuery.of(context);
    final localizations = MaterialLocalizations.of(context);
    final routeLabel = _getRouteLabel(localizations);

    return AnimatedBuilder(
      animation: widget.route!.animation!,
      builder: (context, child) {
        // Disable the initial animation when accessible navigation is on so
        // that the semantics are added to the tree at the correct time.
        final animationValue = mediaQuery.accessibleNavigation
            ? 1.0
            : widget.route!.animation!.value;
        return Semantics(
          scopesRoute: true,
          namesRoute: true,
          label: routeLabel,
          explicitChildNodes: true,
          child: ClipRect(
            child: CustomSingleChildLayout(
                delegate: _GetModalBottomSheetLayout(
                    animationValue, widget.isScrollControlled),
                child: widget.isPersistent == false
                    ? BottomSheet(
                        animationController: widget.route!._animationController,
                        onClosing: () {
                          if (widget.route!.isCurrent) {
                            Navigator.pop(context);
                          }
                        },
                        builder: widget.route!.builder!,
                        backgroundColor: widget.backgroundColor,
                        elevation: widget.elevation,
                        shape: widget.shape,
                        clipBehavior: widget.clipBehavior,
                        enableDrag: widget.enableDrag,
                      )
                    : Scaffold(
                        bottomSheet: BottomSheet(
                          animationController:
                              widget.route!._animationController,
                          onClosing: () {
                            // if (widget.route.isCurrent) {
                            //   Navigator.pop(context);
                            // }
                          },
                          builder: widget.route!.builder!,
                          backgroundColor: widget.backgroundColor,
                          elevation: widget.elevation,
                          shape: widget.shape,
                          clipBehavior: widget.clipBehavior,
                          enableDrag: widget.enableDrag,
                        ),
                      )),
          ),
        );
      },
    );
  }
}

class _GetModalBottomSheetLayout extends SingleChildLayoutDelegate {
  _GetModalBottomSheetLayout(this.progress, this.isScrollControlled);

  final double progress;
  final bool isScrollControlled;

  @override
  BoxConstraints getConstraintsForChild(BoxConstraints constraints) {
    return BoxConstraints(
      minWidth: constraints.maxWidth,
      maxWidth: constraints.maxWidth,
      minHeight: 0.0,
      maxHeight: isScrollControlled
          ? constraints.maxHeight
          : constraints.maxHeight * 9.0 / 16.0,
    );
  }

  @override
  Offset getPositionForChild(Size size, Size childSize) {
    return Offset(0.0, size.height - childSize.height * progress);
  }

  @override
  bool shouldRelayout(_GetModalBottomSheetLayout oldDelegate) {
    return progress != oldDelegate.progress;
  }
}


--- File Index 7: lib/get_navigation/src/root/get_cupertino_app.dart ---
import 'package:flutter/cupertino.dart';
import 'package:flutter/foundation.dart';
import 'package:flutter/material.dart';

import '../../../get_core/get_core.dart';
import '../../../get_instance/get_instance.dart';
import '../../../get_state_manager/get_state_manager.dart';
import '../../../get_utils/get_utils.dart';
import '../../get_navigation.dart';
import 'get_root.dart';

class GetCupertinoApp extends StatelessWidget {
  final GlobalKey<NavigatorState>? navigatorKey;
  final Widget? home;
  final Map<String, WidgetBuilder>? routes;
  final String? initialRoute;
  final RouteFactory? onGenerateRoute;
  final InitialRouteListFactory? onGenerateInitialRoutes;
  final RouteFactory? onUnknownRoute;
  final List<NavigatorObserver>? navigatorObservers;
  final TransitionBuilder? builder;
  final String title;
  final GenerateAppTitle? onGenerateTitle;
  final CustomTransition? customTransition;
  final Color? color;
  final Map<String, Map<String, String>>? translationsKeys;
  final Translations? translations;
  final TextDirection? textDirection;
  final Locale? locale;
  final Locale? fallbackLocale;
  final Iterable<LocalizationsDelegate<dynamic>>? localizationsDelegates;
  final LocaleListResolutionCallback? localeListResolutionCallback;
  final LocaleResolutionCallback? localeResolutionCallback;
  final Iterable<Locale> supportedLocales;
  final bool showPerformanceOverlay;
  final bool checkerboardRasterCacheImages;
  final bool checkerboardOffscreenLayers;
  final bool showSemanticsDebugger;
  final bool debugShowCheckedModeBanner;
  final Map<LogicalKeySet, Intent>? shortcuts;
  final ThemeData? highContrastTheme;
  final ThemeData? highContrastDarkTheme;
  final Map<Type, Action<Intent>>? actions;
  final Function(Routing?)? routingCallback;
  final Transition? defaultTransition;
  final bool? opaqueRoute;
  final VoidCallback? onInit;
  final VoidCallback? onReady;
  final VoidCallback? onDispose;
  final bool? enableLog;
  final LogWriterCallback? logWriterCallback;
  final bool? popGesture;
  final SmartManagement smartManagement;
  final BindingsInterface? initialBinding;
  final Duration? transitionDuration;
  final bool? defaultGlobalState;
  final List<GetPage>? getPages;
  final GetPage? unknownRoute;
  final RouteInformationProvider? routeInformationProvider;
  final RouteInformationParser<Object>? routeInformationParser;
  final RouterDelegate<Object>? routerDelegate;
  final RouterConfig<Object>? routerConfig;
  final BackButtonDispatcher? backButtonDispatcher;
  final CupertinoThemeData? theme;
  final bool useInheritedMediaQuery;
  final List<Bind> binds;
  final ScrollBehavior? scrollBehavior;

  const GetCupertinoApp({
    super.key,
    this.theme,
    this.navigatorKey,
    this.home,
    Map<String, Widget Function(BuildContext)> this.routes =
        const <String, WidgetBuilder>{},
    this.initialRoute,
    this.onGenerateRoute,
    this.onGenerateInitialRoutes,
    this.onUnknownRoute,
    List<NavigatorObserver> this.navigatorObservers =
        const <NavigatorObserver>[],
    this.builder,
    this.translationsKeys,
    this.translations,
    this.textDirection,
    this.title = '',
    this.onGenerateTitle,
    this.color,
    this.customTransition,
    this.onInit,
    this.onDispose,
    this.locale,
    this.binds = const [],
    this.scrollBehavior,
    this.fallbackLocale,
    this.localizationsDelegates,
    this.localeListResolutionCallback,
    this.localeResolutionCallback,
    this.supportedLocales = const <Locale>[Locale('en', 'US')],
    this.showPerformanceOverlay = false,
    this.checkerboardRasterCacheImages = false,
    this.checkerboardOffscreenLayers = false,
    this.showSemanticsDebugger = false,
    this.debugShowCheckedModeBanner = true,
    this.shortcuts,
    this.smartManagement = SmartManagement.full,
    this.initialBinding,
    this.useInheritedMediaQuery = false,
    this.unknownRoute,
    this.routingCallback,
    this.defaultTransition,
    this.onReady,
    this.getPages,
    this.opaqueRoute,
    this.enableLog = kDebugMode,
    this.logWriterCallback,
    this.popGesture,
    this.transitionDuration,
    this.defaultGlobalState,
    this.highContrastTheme,
    this.highContrastDarkTheme,
    this.actions,
  })  : routeInformationProvider = null,
        backButtonDispatcher = null,
        routeInformationParser = null,
        routerDelegate = null,
        routerConfig = null;

  const GetCupertinoApp.router({
    super.key,
    this.theme,
    this.routeInformationProvider,
    this.routeInformationParser,
    this.routerDelegate,
    this.routerConfig,
    this.backButtonDispatcher,
    this.builder,
    this.title = '',
    this.onGenerateTitle,
    this.useInheritedMediaQuery = false,
    this.color,
    this.highContrastTheme,
    this.highContrastDarkTheme,
    this.locale,
    this.localizationsDelegates,
    this.localeListResolutionCallback,
    this.localeResolutionCallback,
    this.supportedLocales = const <Locale>[Locale('en', 'US')],
    this.showPerformanceOverlay = false,
    this.checkerboardRasterCacheImages = false,
    this.checkerboardOffscreenLayers = false,
    this.showSemanticsDebugger = false,
    this.debugShowCheckedModeBanner = true,
    this.shortcuts,
    this.binds = const [],
    this.scrollBehavior,
    this.actions,
    this.customTransition,
    this.translationsKeys,
    this.translations,
    this.textDirection,
    this.fallbackLocale,
    this.routingCallback,
    this.defaultTransition,
    this.opaqueRoute,
    this.onInit,
    this.onReady,
    this.onDispose,
    this.enableLog = kDebugMode,
    this.logWriterCallback,
    this.popGesture,
    this.smartManagement = SmartManagement.full,
    this.initialBinding,
    this.transitionDuration,
    this.defaultGlobalState,
    this.getPages,
    this.navigatorObservers,
    this.unknownRoute,
  })  : navigatorKey = null,
        onGenerateRoute = null,
        home = null,
        onGenerateInitialRoutes = null,
        onUnknownRoute = null,
        routes = null,
        initialRoute = null;

  @override
  Widget build(BuildContext context) {
    return GetRoot(
      config: ConfigData(
        backButtonDispatcher: backButtonDispatcher,
        binds: binds,
        customTransition: customTransition,
        defaultGlobalState: defaultGlobalState,
        defaultTransition: defaultTransition,
        enableLog: enableLog,
        fallbackLocale: fallbackLocale,
        getPages: getPages,
        home: home,
        initialRoute: initialRoute,
        locale: locale,
        logWriterCallback: logWriterCallback,
        navigatorKey: navigatorKey,
        navigatorObservers: navigatorObservers,
        onDispose: onDispose,
        onInit: onInit,
        onReady: onReady,
        routeInformationParser: routeInformationParser,
        routeInformationProvider: routeInformationProvider,
        routerDelegate: routerDelegate,
        routingCallback: routingCallback,
        scaffoldMessengerKey: GlobalKey<ScaffoldMessengerState>(),
        smartManagement: smartManagement,
        transitionDuration: transitionDuration,
        translations: translations,
        translationsKeys: translationsKeys,
        unknownRoute: unknownRoute,
        defaultPopGesture: popGesture,
      ),
      child: Builder(builder: (context) {
        final controller = GetRoot.of(context);
        return CupertinoApp.router(
          routerDelegate: controller.config.routerDelegate,
          routeInformationParser: controller.config.routeInformationParser,
          backButtonDispatcher: backButtonDispatcher,
          routeInformationProvider: routeInformationProvider,
          routerConfig: routerConfig,
          key: controller.config.unikey,
          builder: (context, child) => Directionality(
            textDirection: textDirection ??
                (rtlLanguages.contains(Get.locale?.languageCode)
                    ? TextDirection.rtl
                    : TextDirection.ltr),
            child: builder == null
                ? (child ?? const Material())
                : builder!(context, child ?? const Material()),
          ),
          title: title,
          onGenerateTitle: onGenerateTitle,
          color: color,
          theme: theme,
          locale: Get.locale ?? locale,
          localizationsDelegates: localizationsDelegates,
          localeListResolutionCallback: localeListResolutionCallback,
          localeResolutionCallback: localeResolutionCallback,
          supportedLocales: supportedLocales,
          showPerformanceOverlay: showPerformanceOverlay,
          checkerboardRasterCacheImages: checkerboardRasterCacheImages,
          checkerboardOffscreenLayers: checkerboardOffscreenLayers,
          showSemanticsDebugger: showSemanticsDebugger,
          debugShowCheckedModeBanner: debugShowCheckedModeBanner,
          shortcuts: shortcuts,
          scrollBehavior: scrollBehavior,
        );
      }),
    );
  }
}


--- File Index 8: lib/get_navigation/src/root/get_material_app.dart ---
import 'package:flutter/foundation.dart';
import 'package:flutter/material.dart';
import 'package:get/instance_manager.dart';

import '../../../get_state_manager/get_state_manager.dart';
import '../../../get_utils/get_utils.dart';
import '../../get_navigation.dart';
import 'get_root.dart';

class GetMaterialApp extends StatelessWidget {
  final GlobalKey<NavigatorState>? navigatorKey;
  final GlobalKey<ScaffoldMessengerState>? scaffoldMessengerKey;
  final Widget? home;
  final Map<String, WidgetBuilder>? routes;
  final String? initialRoute;
  final RouteFactory? onGenerateRoute;
  final InitialRouteListFactory? onGenerateInitialRoutes;
  final RouteFactory? onUnknownRoute;
  final List<NavigatorObserver>? navigatorObservers;
  final TransitionBuilder? builder;
  final String title;
  final GenerateAppTitle? onGenerateTitle;
  final ThemeData? theme;
  final ThemeData? darkTheme;
  final ThemeMode themeMode;
  final CustomTransition? customTransition;
  final Color? color;
  final Map<String, Map<String, String>>? translationsKeys;
  final Translations? translations;
  final TextDirection? textDirection;
  final Locale? locale;
  final Locale? fallbackLocale;
  final Iterable<LocalizationsDelegate<dynamic>>? localizationsDelegates;
  final LocaleListResolutionCallback? localeListResolutionCallback;
  final LocaleResolutionCallback? localeResolutionCallback;
  final Iterable<Locale> supportedLocales;
  final bool showPerformanceOverlay;
  final bool checkerboardRasterCacheImages;
  final bool checkerboardOffscreenLayers;
  final bool showSemanticsDebugger;
  final bool debugShowCheckedModeBanner;
  final Map<LogicalKeySet, Intent>? shortcuts;
  final ScrollBehavior? scrollBehavior;
  final ThemeData? highContrastTheme;
  final ThemeData? highContrastDarkTheme;
  final Map<Type, Action<Intent>>? actions;
  final bool debugShowMaterialGrid;
  final ValueChanged<Routing?>? routingCallback;
  final Transition? defaultTransition;
  final bool? opaqueRoute;
  final VoidCallback? onInit;
  final VoidCallback? onReady;
  final VoidCallback? onDispose;
  final bool? enableLog;
  final LogWriterCallback? logWriterCallback;
  final bool? popGesture;
  final SmartManagement smartManagement;
  final List<Bind> binds;
  final Duration? transitionDuration;
  final bool? defaultGlobalState;
  final List<GetPage>? getPages;
  final GetPage? unknownRoute;
  final RouteInformationProvider? routeInformationProvider;
  final RouteInformationParser<Object>? routeInformationParser;
  final RouterDelegate<Object>? routerDelegate;
  final RouterConfig<Object>? routerConfig;
  final BackButtonDispatcher? backButtonDispatcher;
  final bool useInheritedMediaQuery;

  const GetMaterialApp({
    super.key,
    this.navigatorKey,
    this.scaffoldMessengerKey,
    this.home,
    Map<String, Widget Function(BuildContext)> this.routes =
        const <String, WidgetBuilder>{},
    this.initialRoute,
    this.onGenerateRoute,
    this.onGenerateInitialRoutes,
    this.onUnknownRoute,
    this.useInheritedMediaQuery = false,
    List<NavigatorObserver> this.navigatorObservers =
        const <NavigatorObserver>[],
    this.builder,
    this.textDirection,
    this.title = '',
    this.onGenerateTitle,
    this.color,
    this.theme,
    this.darkTheme,
    this.themeMode = ThemeMode.system,
    this.locale,
    this.fallbackLocale,
    this.localizationsDelegates,
    this.localeListResolutionCallback,
    this.localeResolutionCallback,
    this.supportedLocales = const <Locale>[Locale('en', 'US')],
    this.debugShowMaterialGrid = false,
    this.showPerformanceOverlay = false,
    this.checkerboardRasterCacheImages = false,
    this.checkerboardOffscreenLayers = false,
    this.showSemanticsDebugger = false,
    this.debugShowCheckedModeBanner = true,
    this.shortcuts,
    this.scrollBehavior,
    this.customTransition,
    this.translationsKeys,
    this.translations,
    this.onInit,
    this.onReady,
    this.onDispose,
    this.routingCallback,
    this.defaultTransition,
    this.getPages,
    this.opaqueRoute,
    this.enableLog = kDebugMode,
    this.logWriterCallback,
    this.popGesture,
    this.transitionDuration,
    this.defaultGlobalState,
    this.smartManagement = SmartManagement.full,
    this.binds = const [],
    this.unknownRoute,
    this.highContrastTheme,
    this.highContrastDarkTheme,
    this.actions,
  })  : routeInformationProvider = null,
        backButtonDispatcher = null,
        routeInformationParser = null,
        routerDelegate = null,
        routerConfig = null;

  const GetMaterialApp.router({
    super.key,
    this.routeInformationProvider,
    this.scaffoldMessengerKey,
    this.routeInformationParser,
    this.routerDelegate,
    this.routerConfig,
    this.backButtonDispatcher,
    this.builder,
    this.title = '',
    this.onGenerateTitle,
    this.color,
    this.theme,
    this.darkTheme,
    this.useInheritedMediaQuery = false,
    this.highContrastTheme,
    this.highContrastDarkTheme,
    this.themeMode = ThemeMode.system,
    this.locale,
    this.localizationsDelegates,
    this.localeListResolutionCallback,
    this.localeResolutionCallback,
    this.supportedLocales = const <Locale>[Locale('en', 'US')],
    this.debugShowMaterialGrid = false,
    this.showPerformanceOverlay = false,
    this.checkerboardRasterCacheImages = false,
    this.checkerboardOffscreenLayers = false,
    this.showSemanticsDebugger = false,
    this.debugShowCheckedModeBanner = true,
    this.shortcuts,
    this.scrollBehavior,
    this.actions,
    this.customTransition,
    this.translationsKeys,
    this.translations,
    this.textDirection,
    this.fallbackLocale,
    this.routingCallback,
    this.defaultTransition,
    this.opaqueRoute,
    this.onInit,
    this.onReady,
    this.onDispose,
    this.enableLog = kDebugMode,
    this.logWriterCallback,
    this.popGesture,
    this.smartManagement = SmartManagement.full,
    this.binds = const [],
    this.transitionDuration,
    this.defaultGlobalState,
    this.getPages,
    this.navigatorObservers,
    this.unknownRoute,
  })  : navigatorKey = null,
        onGenerateRoute = null,
        home = null,
        onGenerateInitialRoutes = null,
        onUnknownRoute = null,
        routes = null,
        initialRoute = null;

  @override
  Widget build(BuildContext context) {
    return GetRoot(
      config: ConfigData(
        backButtonDispatcher: backButtonDispatcher,
        binds: binds,
        customTransition: customTransition,
        defaultGlobalState: defaultGlobalState,
        defaultTransition: defaultTransition,
        enableLog: enableLog,
        fallbackLocale: fallbackLocale,
        getPages: getPages,
        home: home,
        initialRoute: initialRoute,
        locale: locale,
        logWriterCallback: logWriterCallback,
        navigatorKey: navigatorKey,
        navigatorObservers: navigatorObservers,
        onDispose: onDispose,
        onInit: onInit,
        onReady: onReady,
        routeInformationParser: routeInformationParser,
        routeInformationProvider: routeInformationProvider,
        routerDelegate: routerDelegate,
        routingCallback: routingCallback,
        scaffoldMessengerKey: scaffoldMessengerKey,
        smartManagement: smartManagement,
        transitionDuration: transitionDuration,
        translations: translations,
        translationsKeys: translationsKeys,
        unknownRoute: unknownRoute,
        theme: theme,
        darkTheme: darkTheme,
        themeMode: themeMode,
        defaultPopGesture: popGesture,
      ),
      // binds: [
      //   Bind.lazyPut<GetMaterialController>(
      //     () => GetMaterialController(

      //     ),
      //     onClose: () {
      //       Get.clearTranslations();
      //       RouterReportManager.dispose();
      //       Get.resetInstance(clearRouteBindings: true);
      //     },
      //   ),
      //   ...binds,
      // ],
      child: Builder(builder: (context) {
        final controller = GetRoot.of(context);
        return MaterialApp.router(
          routerDelegate: controller.config.routerDelegate,
          routeInformationParser: controller.config.routeInformationParser,
          backButtonDispatcher: backButtonDispatcher,
          routeInformationProvider: routeInformationProvider,
          routerConfig: routerConfig,
          key: controller.config.unikey,
          builder: (context, child) => Directionality(
            textDirection: textDirection ??
                (rtlLanguages.contains(Get.locale?.languageCode)
                    ? TextDirection.rtl
                    : TextDirection.ltr),
            child: builder == null
                ? (child ?? const Material())
                : builder!(context, child ?? const Material()),
          ),
          title: title,
          onGenerateTitle: onGenerateTitle,
          color: color,
          theme: controller.config.theme ?? ThemeData.fallback(),
          darkTheme: controller.config.darkTheme ??
              controller.config.theme ??
              ThemeData.fallback(),
          themeMode: controller.config.themeMode,
          locale: Get.locale ?? locale,
          scaffoldMessengerKey: controller.config.scaffoldMessengerKey,
          localizationsDelegates: localizationsDelegates,
          localeListResolutionCallback: localeListResolutionCallback,
          localeResolutionCallback: localeResolutionCallback,
          supportedLocales: supportedLocales,
          debugShowMaterialGrid: debugShowMaterialGrid,
          showPerformanceOverlay: showPerformanceOverlay,
          checkerboardRasterCacheImages: checkerboardRasterCacheImages,
          checkerboardOffscreenLayers: checkerboardOffscreenLayers,
          showSemanticsDebugger: showSemanticsDebugger,
          debugShowCheckedModeBanner: debugShowCheckedModeBanner,
          shortcuts: shortcuts,
          scrollBehavior: scrollBehavior,
        );
      }),
    );
  }
}


--- File Index 9: lib/get_navigation/src/root/internacionalization.dart ---
const List<String> rtlLanguages = <String>[
  'ar', // Arabic
  'fa', // Farsi
  'he', // Hebrew
  'ps', // Pashto
  'ur',
];

abstract class Translations {
  Map<String, Map<String, String>> get keys;
}


--- File Index 10: lib/get_navigation/src/root/get_root.dart ---
import 'package:flutter/foundation.dart';
import 'package:flutter/material.dart';
import 'package:get/get_navigation/src/routes/test_kit.dart';

import '../../../get.dart';
import '../router_report.dart';

class ConfigData {
  final ValueChanged<Routing?>? routingCallback;
  final Transition? defaultTransition;
  final VoidCallback? onInit;
  final VoidCallback? onReady;
  final VoidCallback? onDispose;
  final bool? enableLog;
  final LogWriterCallback? logWriterCallback;
  final SmartManagement smartManagement;
  final List<Bind> binds;
  final Duration? transitionDuration;
  final bool? defaultGlobalState;
  final List<GetPage>? getPages;
  final GetPage? unknownRoute;
  final RouteInformationProvider? routeInformationProvider;
  final RouteInformationParser<Object>? routeInformationParser;
  final RouterDelegate<Object>? routerDelegate;
  final BackButtonDispatcher? backButtonDispatcher;
  final List<NavigatorObserver>? navigatorObservers;
  final GlobalKey<NavigatorState>? navigatorKey;
  final GlobalKey<ScaffoldMessengerState>? scaffoldMessengerKey;
  final Map<String, Map<String, String>>? translationsKeys;
  final Translations? translations;
  final Locale? locale;
  final Locale? fallbackLocale;
  final String? initialRoute;
  final CustomTransition? customTransition;
  final Widget? home;
  final bool testMode;
  final Key? unikey;
  final ThemeData? theme;
  final ThemeData? darkTheme;
  final ThemeMode? themeMode;
  final bool? defaultPopGesture;
  final bool defaultOpaqueRoute;
  final Duration defaultTransitionDuration;
  final Curve defaultTransitionCurve;
  final Curve defaultDialogTransitionCurve;
  final Duration defaultDialogTransitionDuration;
  final Routing routing;
  final Map<String, String?> parameters;
  final SnackBarQueue snackBarQueue = SnackBarQueue();

  ConfigData({
    required this.routingCallback,
    required this.defaultTransition,
    required this.onInit,
    required this.onReady,
    required this.onDispose,
    required this.enableLog,
    required this.logWriterCallback,
    required this.smartManagement,
    required this.binds,
    required this.transitionDuration,
    required this.defaultGlobalState,
    required this.getPages,
    required this.unknownRoute,
    required this.routeInformationProvider,
    required this.routeInformationParser,
    required this.routerDelegate,
    required this.backButtonDispatcher,
    required this.navigatorObservers,
    required this.navigatorKey,
    required this.scaffoldMessengerKey,
    required this.translationsKeys,
    required this.translations,
    required this.locale,
    required this.fallbackLocale,
    required this.initialRoute,
    required this.customTransition,
    required this.home,
    this.theme,
    this.darkTheme,
    this.themeMode,
    this.unikey,
    this.testMode = false,
    this.defaultOpaqueRoute = true,
    this.defaultTransitionDuration = const Duration(milliseconds: 300),
    this.defaultTransitionCurve = Curves.easeOutQuad,
    this.defaultDialogTransitionCurve = Curves.easeOutQuad,
    this.defaultDialogTransitionDuration = const Duration(milliseconds: 300),
    this.parameters = const {},
    required this.defaultPopGesture,
    Routing? routing,
  }) : routing = routing ?? Routing();

  ConfigData copyWith({
    ValueChanged<Routing?>? routingCallback,
    Transition? defaultTransition,
    VoidCallback? onInit,
    VoidCallback? onReady,
    VoidCallback? onDispose,
    bool? enableLog,
    LogWriterCallback? logWriterCallback,
    SmartManagement? smartManagement,
    List<Bind>? binds,
    Duration? transitionDuration,
    bool? defaultGlobalState,
    List<GetPage>? getPages,
    GetPage? unknownRoute,
    RouteInformationProvider? routeInformationProvider,
    RouteInformationParser<Object>? routeInformationParser,
    RouterDelegate<Object>? routerDelegate,
    BackButtonDispatcher? backButtonDispatcher,
    List<NavigatorObserver>? navigatorObservers,
    GlobalKey<NavigatorState>? navigatorKey,
    GlobalKey<ScaffoldMessengerState>? scaffoldMessengerKey,
    Map<String, Map<String, String>>? translationsKeys,
    Translations? translations,
    Locale? locale,
    Locale? fallbackLocale,
    String? initialRoute,
    CustomTransition? customTransition,
    Widget? home,
    bool? testMode,
    Key? unikey,
    ThemeData? theme,
    ThemeData? darkTheme,
    ThemeMode? themeMode,
    bool? defaultPopGesture,
    bool? defaultOpaqueRoute,
    Duration? defaultTransitionDuration,
    Curve? defaultTransitionCurve,
    Curve? defaultDialogTransitionCurve,
    Duration? defaultDialogTransitionDuration,
    Routing? routing,
    Map<String, String?>? parameters,
  }) {
    return ConfigData(
      routingCallback: routingCallback ?? this.routingCallback,
      defaultTransition: defaultTransition ?? this.defaultTransition,
      onInit: onInit ?? this.onInit,
      onReady: onReady ?? this.onReady,
      onDispose: onDispose ?? this.onDispose,
      enableLog: enableLog ?? this.enableLog,
      logWriterCallback: logWriterCallback ?? this.logWriterCallback,
      smartManagement: smartManagement ?? this.smartManagement,
      binds: binds ?? this.binds,
      transitionDuration: transitionDuration ?? this.transitionDuration,
      defaultGlobalState: defaultGlobalState ?? this.defaultGlobalState,
      getPages: getPages ?? this.getPages,
      unknownRoute: unknownRoute ?? this.unknownRoute,
      routeInformationProvider:
          routeInformationProvider ?? this.routeInformationProvider,
      routeInformationParser:
          routeInformationParser ?? this.routeInformationParser,
      routerDelegate: routerDelegate ?? this.routerDelegate,
      backButtonDispatcher: backButtonDispatcher ?? this.backButtonDispatcher,
      navigatorObservers: navigatorObservers ?? this.navigatorObservers,
      navigatorKey: navigatorKey ?? this.navigatorKey,
      scaffoldMessengerKey: scaffoldMessengerKey ?? this.scaffoldMessengerKey,
      translationsKeys: translationsKeys ?? this.translationsKeys,
      translations: translations ?? this.translations,
      locale: locale ?? this.locale,
      fallbackLocale: fallbackLocale ?? this.fallbackLocale,
      initialRoute: initialRoute ?? this.initialRoute,
      customTransition: customTransition ?? this.customTransition,
      home: home ?? this.home,
      testMode: testMode ?? this.testMode,
      unikey: unikey ?? this.unikey,
      theme: theme ?? this.theme,
      darkTheme: darkTheme ?? this.darkTheme,
      themeMode: themeMode ?? this.themeMode,
      defaultPopGesture: defaultPopGesture ?? this.defaultPopGesture,
      defaultOpaqueRoute: defaultOpaqueRoute ?? this.defaultOpaqueRoute,
      defaultTransitionDuration:
          defaultTransitionDuration ?? this.defaultTransitionDuration,
      defaultTransitionCurve:
          defaultTransitionCurve ?? this.defaultTransitionCurve,
      defaultDialogTransitionCurve:
          defaultDialogTransitionCurve ?? this.defaultDialogTransitionCurve,
      defaultDialogTransitionDuration: defaultDialogTransitionDuration ??
          this.defaultDialogTransitionDuration,
      routing: routing ?? this.routing,
      parameters: parameters ?? this.parameters,
    );
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;

    return other is ConfigData &&
        other.routingCallback == routingCallback &&
        other.defaultTransition == defaultTransition &&
        other.onInit == onInit &&
        other.onReady == onReady &&
        other.onDispose == onDispose &&
        other.enableLog == enableLog &&
        other.logWriterCallback == logWriterCallback &&
        other.smartManagement == smartManagement &&
        listEquals(other.binds, binds) &&
        other.transitionDuration == transitionDuration &&
        other.defaultGlobalState == defaultGlobalState &&
        listEquals(other.getPages, getPages) &&
        other.unknownRoute == unknownRoute &&
        other.routeInformationProvider == routeInformationProvider &&
        other.routeInformationParser == routeInformationParser &&
        other.routerDelegate == routerDelegate &&
        other.backButtonDispatcher == backButtonDispatcher &&
        listEquals(other.navigatorObservers, navigatorObservers) &&
        other.navigatorKey == navigatorKey &&
        other.scaffoldMessengerKey == scaffoldMessengerKey &&
        mapEquals(other.translationsKeys, translationsKeys) &&
        other.translations == translations &&
        other.locale == locale &&
        other.fallbackLocale == fallbackLocale &&
        other.initialRoute == initialRoute &&
        other.customTransition == customTransition &&
        other.home == home &&
        other.testMode == testMode &&
        other.unikey == unikey &&
        other.theme == theme &&
        other.darkTheme == darkTheme &&
        other.themeMode == themeMode &&
        other.defaultPopGesture == defaultPopGesture &&
        other.defaultOpaqueRoute == defaultOpaqueRoute &&
        other.defaultTransitionDuration == defaultTransitionDuration &&
        other.defaultTransitionCurve == defaultTransitionCurve &&
        other.defaultDialogTransitionCurve == defaultDialogTransitionCurve &&
        other.defaultDialogTransitionDuration ==
            defaultDialogTransitionDuration &&
        other.routing == routing &&
        mapEquals(other.parameters, parameters);
  }

  @override
  int get hashCode {
    return routingCallback.hashCode ^
        defaultTransition.hashCode ^
        onInit.hashCode ^
        onReady.hashCode ^
        onDispose.hashCode ^
        enableLog.hashCode ^
        logWriterCallback.hashCode ^
        smartManagement.hashCode ^
        binds.hashCode ^
        transitionDuration.hashCode ^
        defaultGlobalState.hashCode ^
        getPages.hashCode ^
        unknownRoute.hashCode ^
        routeInformationProvider.hashCode ^
        routeInformationParser.hashCode ^
        routerDelegate.hashCode ^
        backButtonDispatcher.hashCode ^
        navigatorObservers.hashCode ^
        navigatorKey.hashCode ^
        scaffoldMessengerKey.hashCode ^
        translationsKeys.hashCode ^
        translations.hashCode ^
        locale.hashCode ^
        fallbackLocale.hashCode ^
        initialRoute.hashCode ^
        customTransition.hashCode ^
        home.hashCode ^
        testMode.hashCode ^
        unikey.hashCode ^
        theme.hashCode ^
        darkTheme.hashCode ^
        themeMode.hashCode ^
        defaultPopGesture.hashCode ^
        defaultOpaqueRoute.hashCode ^
        defaultTransitionDuration.hashCode ^
        defaultTransitionCurve.hashCode ^
        defaultDialogTransitionCurve.hashCode ^
        defaultDialogTransitionDuration.hashCode ^
        routing.hashCode ^
        parameters.hashCode;
  }
}

class GetRoot extends StatefulWidget {
  const GetRoot({
    super.key,
    required this.config,
    required this.child,
  });
  final ConfigData config;
  final Widget child;
  @override
  State<GetRoot> createState() => GetRootState();

  static bool get treeInitialized => GetRootState._controller != null;

  static GetRootState of(BuildContext context) {
    // Handles the case where the input context is a navigator element.
    GetRootState? root;
    if (context is StatefulElement && context.state is GetRootState) {
      root = context.state as GetRootState;
    }
    root = context.findRootAncestorStateOfType<GetRootState>() ?? root;
    assert(() {
      if (root == null) {
        throw FlutterError(
          'GetRoot operation requested with a context that does not include a GetRoot.\n'
          'The context used must be that of a '
          'widget that is a descendant of a GetRoot widget.',
        );
      }
      return true;
    }());
    return root!;
  }
}

class GetRootState extends State<GetRoot> with WidgetsBindingObserver {
  static GetRootState? _controller;
  static GetRootState get controller {
    if (_controller == null) {
      throw Exception('GetRoot is not part of the three');
    } else {
      return _controller!;
    }
  }

  late ConfigData config;

  @override
  void initState() {
    config = widget.config;
    GetRootState._controller = this;
    Engine.instance.addObserver(this);
    onInit();
    super.initState();
  }

  // @override
  // void didUpdateWidget(covariant GetRoot oldWidget) {
  //   if (oldWidget.config != widget.config) {
  //     config = widget.config;
  //   }

  //   super.didUpdateWidget(oldWidget);
  // }

  void onClose() {
    config.onDispose?.call();
    Get.clearTranslations();
    config.snackBarQueue.disposeControllers();
    RouterReportManager.instance.clearRouteKeys();
    RouterReportManager.dispose();
    Get.resetInstance(clearRouteBindings: true);
    _controller = null;
    Engine.instance.removeObserver(this);
  }

  @override
  void dispose() {
    onClose();
    super.dispose();
  }

  void onInit() {
    if (config.getPages == null && config.home == null) {
      throw 'You need add pages or home';
    }

    if (config.routerDelegate == null) {
      final newDelegate = GetDelegate.createDelegate(
        pages: config.getPages ??
            [
              GetPage(
                name: cleanRouteName("/${config.home.runtimeType}"),
                page: () => config.home!,
              ),
            ],
        notFoundRoute: config.unknownRoute,
        navigatorKey: config.navigatorKey,
        navigatorObservers: (config.navigatorObservers == null
            ? <NavigatorObserver>[
                GetObserver(config.routingCallback, Get.routing)
              ]
            : <NavigatorObserver>[
                GetObserver(config.routingCallback, config.routing),
                ...config.navigatorObservers!
              ]),
      );
      config = config.copyWith(routerDelegate: newDelegate);
    }

    if (config.routeInformationParser == null) {
      final newRouteInformationParser =
          GetInformationParser.createInformationParser(
        initialRoute: config.initialRoute ??
            config.getPages?.first.name ??
            cleanRouteName("/${config.home.runtimeType}"),
      );

      config =
          config.copyWith(routeInformationParser: newRouteInformationParser);
    }

    if (config.locale != null) Get.locale = config.locale;

    if (config.fallbackLocale != null) {
      Get.fallbackLocale = config.fallbackLocale;
    }

    if (config.translations != null) {
      Get.addTranslations(config.translations!.keys);
    } else if (config.translationsKeys != null) {
      Get.addTranslations(config.translationsKeys!);
    }

    Get.smartManagement = config.smartManagement;
    config.onInit?.call();

    Get.isLogEnable = config.enableLog ?? kDebugMode;
    Get.log = config.logWriterCallback ?? defaultLogWriterCallback;

    if (config.defaultTransition == null) {
      config = config.copyWith(defaultTransition: getThemeTransition());
    }

    // defaultOpaqueRoute = config.opaqueRoute ?? true;
    // defaultPopGesture = config.popGesture ?? GetPlatform.isIOS;
    // defaultTransitionDuration =
    //     config.transitionDuration ?? Duration(milliseconds: 300);

    Future(() => onReady());
  }

  set parameters(Map<String, String?> newParameters) {
    // rootController.parameters = newParameters;
    config = config.copyWith(parameters: newParameters);
  }

  set testMode(bool isTest) {
    config = config.copyWith(testMode: isTest);
    GetTestMode.active = isTest;
  }

  void onReady() {
    config.onReady?.call();
  }

  Transition? getThemeTransition() {
    final platform = context.theme.platform;
    final matchingTransition =
        Get.theme.pageTransitionsTheme.builders[platform];
    switch (matchingTransition) {
      case CupertinoPageTransitionsBuilder():
        return Transition.cupertino;
      case ZoomPageTransitionsBuilder():
        return Transition.zoom;
      case FadeUpwardsPageTransitionsBuilder():
        return Transition.fade;
      case OpenUpwardsPageTransitionsBuilder():
        return Transition.native;
      default:
        return null;
    }
  }

  @override
  void didChangeLocales(List<Locale>? locales) {
    Get.asap(() {
      final locale = Get.deviceLocale;
      if (locale != null) {
        Get.updateLocale(locale);
      }
    });
  }

  void setTheme(ThemeData value) {
    if (config.darkTheme == null) {
      config = config.copyWith(theme: value);
    } else {
      if (value.brightness == Brightness.light) {
        config = config.copyWith(theme: value);
      } else {
        config = config.copyWith(darkTheme: value);
      }
    }
    update();
  }

  void setThemeMode(ThemeMode value) {
    config = config.copyWith(themeMode: value);
    update();
  }

  void restartApp() {
    config = config.copyWith(unikey: UniqueKey());
    update();
  }

  void update() {
    context.visitAncestorElements((element) {
      element.markNeedsBuild();
      return false;
    });
  }

  GlobalKey<NavigatorState> get key => rootDelegate.navigatorKey;

  GetDelegate get rootDelegate => config.routerDelegate as GetDelegate;

  RouteInformationParser<Object> get informationParser =>
      config.routeInformationParser!;

  GlobalKey<NavigatorState>? addKey(GlobalKey<NavigatorState> newKey) {
    rootDelegate.navigatorKey = newKey;
    return key;
  }

  Map<String, GetDelegate> keys = {};

  GetDelegate? nestedKey(String? key) {
    if (key == null) {
      return rootDelegate;
    }
    keys.putIfAbsent(
      key,
      () => GetDelegate(
        showHashOnUrl: true,
        //debugLabel: 'Getx nested key: ${key.toString()}',
        pages: RouteDecoder.fromRoute(key).currentChildren ?? [],
      ),
    );
    return keys[key];
  }

  @override
  Widget build(BuildContext context) {
    return widget.child;
  }

  String cleanRouteName(String name) {
    name = name.replaceAll('() => ', '');

    /// uncomment for URL styling.
    // name = name.paramCase!;
    if (!name.startsWith('/')) {
      name = '/$name';
    }
    return Uri.tryParse(name)?.toString() ?? name;
  }
}


--- File Index 11: lib/get_navigation/src/routes/default_transitions.dart ---
import 'package:flutter/cupertino.dart';
import 'package:flutter/material.dart';

import 'circular_reveal_clipper.dart';

class LeftToRightFadeTransition {
  Widget buildTransitions(
      BuildContext context,
      Curve? curve,
      Alignment? alignment,
      Animation<double> animation,
      Animation<double> secondaryAnimation,
      Widget child) {
    return SlideTransition(
      position: Tween<Offset>(
        begin: const Offset(-1.0, 0.0),
        end: Offset.zero,
      ).animate(animation),
      child: FadeTransition(
        opacity: animation,
        child: SlideTransition(
            position: Tween<Offset>(
              begin: Offset.zero,
              end: const Offset(1.0, 0.0),
            ).animate(secondaryAnimation),
            child: child),
      ),
    );
  }
}

class RightToLeftFadeTransition {
  Widget buildTransitions(
      BuildContext context,
      Curve? curve,
      Alignment? alignment,
      Animation<double> animation,
      Animation<double> secondaryAnimation,
      Widget child) {
    return SlideTransition(
      position: Tween<Offset>(
        begin: const Offset(1.0, 0.0),
        end: Offset.zero,
      ).animate(animation),
      child: FadeTransition(
        opacity: animation,
        child: SlideTransition(
            position: Tween<Offset>(
              begin: Offset.zero,
              end: const Offset(-1.0, 0.0),
            ).animate(secondaryAnimation),
            child: child),
      ),
    );
  }
}

class NoTransition {
  Widget buildTransitions(
      BuildContext context,
      Curve curve,
      Alignment alignment,
      Animation<double> animation,
      Animation<double> secondaryAnimation,
      Widget child) {
    return child;
  }
}

class FadeInTransition {
  Widget buildTransitions(
      BuildContext context,
      Curve? curve,
      Alignment? alignment,
      Animation<double> animation,
      Animation<double> secondaryAnimation,
      Widget child) {
    return FadeTransition(opacity: animation, child: child);
  }
}

class SlideDownTransition {
  Widget buildTransitions(
      BuildContext context,
      Curve? curve,
      Alignment? alignment,
      Animation<double> animation,
      Animation<double> secondaryAnimation,
      Widget child) {
    return SlideTransition(
      position: Tween<Offset>(
        begin: const Offset(0.0, 1.0),
        end: Offset.zero,
      ).animate(animation),
      child: child,
    );
  }
}

class SlideLeftTransition {
  Widget buildTransitions(
      BuildContext context,
      Curve? curve,
      Alignment? alignment,
      Animation<double> animation,
      Animation<double> secondaryAnimation,
      Widget child) {
    return SlideTransition(
      position: Tween<Offset>(
        begin: const Offset(-1.0, 0.0),
        end: Offset.zero,
      ).animate(animation),
      child: child,
    );
  }
}

class SlideRightTransition {
  Widget buildTransitions(
      BuildContext context,
      Curve? curve,
      Alignment? alignment,
      Animation<double> animation,
      Animation<double> secondaryAnimation,
      Widget child) {
    return SlideTransition(
      position: Tween<Offset>(
        begin: const Offset(1.0, 0.0),
        end: Offset.zero,
      ).animate(animation),
      child: child,
    );
  }
}

class SlideTopTransition {
  Widget buildTransitions(
      BuildContext context,
      Curve? curve,
      Alignment? alignment,
      Animation<double> animation,
      Animation<double> secondaryAnimation,
      Widget child) {
    return SlideTransition(
      position: Tween<Offset>(
        begin: const Offset(0.0, -1.0),
        end: Offset.zero,
      ).animate(animation),
      child: child,
    );
  }
}

class ZoomInTransition {
  Widget buildTransitions(
      BuildContext context,
      Curve? curve,
      Alignment? alignment,
      Animation<double> animation,
      Animation<double> secondaryAnimation,
      Widget child) {
    return ScaleTransition(
      scale: animation,
      child: child,
    );
  }
}

class SizeTransitions {
  Widget buildTransitions(
      BuildContext context,
      Curve curve,
      Alignment? alignment,
      Animation<double> animation,
      Animation<double> secondaryAnimation,
      Widget child) {
    return Align(
      alignment: Alignment.center,
      child: SizeTransition(
        sizeFactor: CurvedAnimation(
          parent: animation,
          curve: curve,
        ),
        child: child,
      ),
    );
  }
}

class CircularRevealTransition {
  Widget buildTransitions(
      BuildContext context,
      Curve? curve,
      Alignment? alignment,
      Animation<double> animation,
      Animation<double> secondaryAnimation,
      Widget child) {
    return ClipPath(
      clipper: CircularRevealClipper(
        fraction: animation.value,
        centerAlignment: Alignment.center,
        centerOffset: Offset.zero,
        minRadius: 0,
        maxRadius: 800,
      ),
      child: child,
    );
  }
}


--- File Index 12: lib/get_navigation/src/routes/get_router_delegate.dart ---
import 'dart:async';

import 'package:flutter/foundation.dart';
import 'package:flutter/material.dart';

import '../../../get_instance/src/bindings_interface.dart';
import '../../../get_utils/src/platform/platform.dart';
import '../../../route_manager.dart';

class GetDelegate extends RouterDelegate<RouteDecoder>
    with
        ChangeNotifier,
        PopNavigatorRouterDelegateMixin<RouteDecoder>,
        IGetNavigation {
  factory GetDelegate.createDelegate({
    GetPage<dynamic>? notFoundRoute,
    List<GetPage> pages = const [],
    List<NavigatorObserver>? navigatorObservers,
    TransitionDelegate<dynamic>? transitionDelegate,
    PopMode backButtonPopMode = PopMode.history,
    PreventDuplicateHandlingMode preventDuplicateHandlingMode =
        PreventDuplicateHandlingMode.reorderRoutes,
    GlobalKey<NavigatorState>? navigatorKey,
  }) {
    return GetDelegate(
      notFoundRoute: notFoundRoute,
      navigatorObservers: navigatorObservers,
      transitionDelegate: transitionDelegate,
      backButtonPopMode: backButtonPopMode,
      preventDuplicateHandlingMode: preventDuplicateHandlingMode,
      pages: pages,
      navigatorKey: navigatorKey,
    );
  }

  final List<RouteDecoder> _activePages = <RouteDecoder>[];
  final PopMode backButtonPopMode;
  final PreventDuplicateHandlingMode preventDuplicateHandlingMode;

  final GetPage notFoundRoute;

  final List<NavigatorObserver>? navigatorObservers;
  final TransitionDelegate<dynamic>? transitionDelegate;

  final Iterable<GetPage> Function(RouteDecoder currentNavStack)?
      pickPagesForRootNavigator;

  List<RouteDecoder> get activePages => _activePages;

  final _routeTree = ParseRouteTree(routes: []);

  List<GetPage> get registeredRoutes => _routeTree.routes;

  void addPages(List<GetPage> getPages) {
    _routeTree.addRoutes(getPages);
  }

  void clearRouteTree() {
    _routeTree.routes.clear();
  }

  void addPage(GetPage getPage) {
    _routeTree.addRoute(getPage);
  }

  void removePage(GetPage getPage) {
    _routeTree.removeRoute(getPage);
  }

  RouteDecoder matchRoute(String name, {PageSettings? arguments}) {
    return _routeTree.matchRoute(name, arguments: arguments);
  }

  // GlobalKey<NavigatorState> get navigatorKey => Get.key;

  @override
  GlobalKey<NavigatorState> navigatorKey;

  final String? restorationScopeId;

  GetDelegate({
    GetPage? notFoundRoute,
    this.navigatorObservers,
    this.transitionDelegate,
    this.backButtonPopMode = PopMode.history,
    this.preventDuplicateHandlingMode =
        PreventDuplicateHandlingMode.reorderRoutes,
    this.pickPagesForRootNavigator,
    this.restorationScopeId,
    bool showHashOnUrl = false,
    GlobalKey<NavigatorState>? navigatorKey,
    required List<GetPage> pages,
  })  : navigatorKey = navigatorKey ?? GlobalKey<NavigatorState>(),
        notFoundRoute = notFoundRoute ??= GetPage(
          name: '/404',
          page: () => const Scaffold(
            body: Center(child: Text('Route not found')),
          ),
        ) {
    if (!showHashOnUrl && GetPlatform.isWeb) setUrlStrategy();
    addPages(pages);
    addPage(notFoundRoute);
    Get.log('GetDelegate is created !');
  }

  Future<RouteDecoder?> runMiddleware(RouteDecoder config) async {
    final middlewares = config.currentTreeBranch.last.middlewares;
    if (middlewares.isEmpty) {
      return config;
    }
    var iterator = config;
    for (var item in middlewares) {
      var redirectRes = await item.redirectDelegate(iterator);

      if (redirectRes == null) {
        config.route?.completer?.complete();
        return null;
      }
      if (config != redirectRes) {
        config.route?.completer?.complete();
        Get.log('Redirect to ${redirectRes.pageSettings?.name}');
      }

      iterator = redirectRes;
      // Stop the iteration over the middleware if we changed page
      // and that redirectRes is not the same as the current config.
      if (config != redirectRes) {
        break;
      }
    }
    // If the target is not the same as the source, we need
    // to run the middlewares for the new route.
    if (iterator != config) {
      return await runMiddleware(iterator);
    }
    return iterator;
  }

  Future<void> _unsafeHistoryAdd(RouteDecoder config) async {
    final res = await runMiddleware(config);
    if (res == null) return;
    _activePages.add(res);
  }

  // Future<T?> _unsafeHistoryRemove<T>(RouteDecoder config, T result) async {
  //   var index = _activePages.indexOf(config);
  //   if (index >= 0) return _unsafeHistoryRemoveAt(index, result);
  //   return null;
  // }

  Future<T?> _unsafeHistoryRemoveAt<T>(int index, T result) async {
    if (index == _activePages.length - 1 && _activePages.length > 1) {
      //removing WILL update the current route
      final toCheck = _activePages[_activePages.length - 2];
      final resMiddleware = await runMiddleware(toCheck);
      if (resMiddleware == null) return null;
      _activePages[_activePages.length - 2] = resMiddleware;
    }

    final completer = _activePages.removeAt(index).route?.completer;
    if (completer?.isCompleted == false) completer!.complete(result);

    return completer?.future as T?;
  }

  T arguments<T>() {
    return currentConfiguration?.pageSettings?.arguments as T;
  }

  Map<String, String> get parameters {
    return currentConfiguration?.pageSettings?.params ?? {};
  }

  PageSettings? get pageSettings {
    return currentConfiguration?.pageSettings;
  }

  Future<void> _pushHistory(RouteDecoder config) async {
    if (config.route!.preventDuplicates) {
      final originalEntryIndex = _activePages.indexWhere(
          (element) => element.pageSettings?.name == config.pageSettings?.name);
      if (originalEntryIndex >= 0) {
        switch (preventDuplicateHandlingMode) {
          case PreventDuplicateHandlingMode.popUntilOriginalRoute:
            popModeUntil(config.pageSettings!.name, popMode: PopMode.page);
            break;
          case PreventDuplicateHandlingMode.reorderRoutes:
            await _unsafeHistoryRemoveAt(originalEntryIndex, null);
            await _unsafeHistoryAdd(config);
            break;
          case PreventDuplicateHandlingMode.doNothing:
          default:
            break;
        }
        return;
      }
    }
    await _unsafeHistoryAdd(config);
  }

  Future<T?> _popHistory<T>(T result) async {
    if (!_canPopHistory()) return null;
    return await _doPopHistory(result);
  }

  Future<T?> _doPopHistory<T>(T result) async {
    return _unsafeHistoryRemoveAt<T>(_activePages.length - 1, result);
  }

  Future<T?> _popPage<T>(T result) async {
    if (!_canPopPage()) return null;
    return await _doPopPage(result);
  }

  // returns the popped page
  Future<T?> _doPopPage<T>(T result) async {
    final currentBranch = currentConfiguration?.currentTreeBranch;
    if (currentBranch != null && currentBranch.length > 1) {
      //remove last part only
      final remaining = currentBranch.take(currentBranch.length - 1);
      final prevHistoryEntry = _activePages.length > 1
          ? _activePages[_activePages.length - 2]
          : null;

      //check if current route is the same as the previous route
      if (prevHistoryEntry != null) {
        //if so, pop the entire _activePages entry
        final newLocation = remaining.last.name;
        final prevLocation = prevHistoryEntry.pageSettings?.name;
        if (newLocation == prevLocation) {
          //pop the entire _activePages entry
          return await _popHistory(result);
        }
      }

      //create a new route with the remaining tree branch
      final res = await _popHistory<T>(result);
      await _pushHistory(
        RouteDecoder(
          remaining.toList(),
          null,
          //TOOD: persist state??
        ),
      );
      return res;
    } else {
      //remove entire entry
      return await _popHistory(result);
    }
  }

  Future<T?> _pop<T>(PopMode mode, T result) async {
    switch (mode) {
      case PopMode.history:
        return await _popHistory<T>(result);
      case PopMode.page:
        return await _popPage<T>(result);
    }
  }

  Future<T?> popHistory<T>(T result) async {
    return await _popHistory<T>(result);
  }

  bool _canPopHistory() {
    return _activePages.length > 1;
  }

  Future<bool> canPopHistory() {
    return SynchronousFuture(_canPopHistory());
  }

  bool _canPopPage() {
    final currentTreeBranch = currentConfiguration?.currentTreeBranch;
    if (currentTreeBranch == null) return false;
    return currentTreeBranch.length > 1 ? true : _canPopHistory();
  }

  Future<bool> canPopPage() {
    return SynchronousFuture(_canPopPage());
  }

  bool _canPop(mode) {
    switch (mode) {
      case PopMode.history:
        return _canPopHistory();
      case PopMode.page:
      default:
        return _canPopPage();
    }
  }

  /// gets the visual pages from the current _activePages entry
  ///
  /// visual pages must have [GetPage.participatesInRootNavigator] set to true
  Iterable<GetPage> getVisualPages(RouteDecoder? currentHistory) {
    final res = currentHistory!.currentTreeBranch
        .where((r) => r.participatesInRootNavigator != null);
    if (res.isEmpty) {
      //default behavior, all routes participate in root navigator
      return _activePages.map((e) => e.route!);
    } else {
      //user specified at least one participatesInRootNavigator
      return res
          .where((element) => element.participatesInRootNavigator == true);
    }
  }

  @override
  Widget build(BuildContext context) {
    final currentHistory = currentConfiguration;
    final pages = currentHistory == null
        ? <GetPage>[]
        : pickPagesForRootNavigator?.call(currentHistory).toList() ??
            getVisualPages(currentHistory).toList();
    if (pages.isEmpty) {
      return ColoredBox(
        color: Theme.of(context).scaffoldBackgroundColor,
      );
    }
    return GetNavigator(
      key: navigatorKey,
      onPopPage: _onPopVisualRoute,
      pages: pages,
      observers: navigatorObservers,
      transitionDelegate:
          transitionDelegate ?? const DefaultTransitionDelegate<dynamic>(),
    );
  }

  @override
  Future<void> goToUnknownPage([bool clearPages = false]) async {
    if (clearPages) _activePages.clear();

    final pageSettings = _buildPageSettings(notFoundRoute.name);
    final routeDecoder = _getRouteDecoder(pageSettings);

    _push(routeDecoder!);
  }

  @protected
  void _popWithResult<T>([T? result]) {
    final completer = _activePages.removeLast().route?.completer;
    if (completer?.isCompleted == false) completer!.complete(result);
  }

  @override
  Future<T?> toNamed<T>(
    String page, {
    dynamic arguments,
    dynamic id,
    bool preventDuplicates = true,
    Map<String, String>? parameters,
  }) async {
    final args = _buildPageSettings(page, arguments);
    final route = _getRouteDecoder<T>(args);
    if (route != null) {
      return _push<T>(route);
    } else {
      goToUnknownPage();
    }
    return null;
  }

  @override
  Future<T?> to<T>(
    Widget Function() page, {
    bool? opaque,
    Transition? transition,
    Curve? curve,
    Duration? duration,
    String? id,
    String? routeName,
    bool fullscreenDialog = false,
    dynamic arguments,
    List<BindingsInterface> bindings = const [],
    bool preventDuplicates = true,
    bool? popGesture,
    bool showCupertinoParallax = true,
    double Function(BuildContext context)? gestureWidth,
    bool rebuildStack = true,
    PreventDuplicateHandlingMode preventDuplicateHandlingMode =
        PreventDuplicateHandlingMode.reorderRoutes,
  }) async {
    routeName ??= _cleanRouteName("/${page.runtimeType}");
    // if (preventDuplicateHandlingMode ==
    //PreventDuplicateHandlingMode.Recreate) {
    //   routeName = routeName + page.hashCode.toString();
    // }

    final getPage = GetPage<T>(
      name: routeName,
      opaque: opaque ?? true,
      page: page,
      gestureWidth: gestureWidth,
      showCupertinoParallax: showCupertinoParallax,
      popGesture: popGesture ?? Get.defaultPopGesture,
      transition: transition ?? Get.defaultTransition,
      curve: curve ?? Get.defaultTransitionCurve,
      fullscreenDialog: fullscreenDialog,
      bindings: bindings,
      transitionDuration: duration ?? Get.defaultTransitionDuration,
      preventDuplicateHandlingMode: preventDuplicateHandlingMode,
    );

    _routeTree.addRoute(getPage);
    final args = _buildPageSettings(routeName, arguments);
    final route = _getRouteDecoder<T>(args);
    final result = await _push<T>(
      route!,
      rebuildStack: rebuildStack,
    );
    _routeTree.removeRoute(getPage);
    return result;
  }

  @override
  Future<T?> off<T>(
    Widget Function() page, {
    bool? opaque,
    Transition? transition,
    Curve? curve,
    Duration? duration,
    String? id,
    String? routeName,
    bool fullscreenDialog = false,
    dynamic arguments,
    List<BindingsInterface> bindings = const [],
    bool preventDuplicates = true,
    bool? popGesture,
    bool showCupertinoParallax = true,
    double Function(BuildContext context)? gestureWidth,
  }) async {
    routeName ??= _cleanRouteName("/${page.runtimeType}");
    final route = GetPage<T>(
      name: routeName,
      opaque: opaque ?? true,
      page: page,
      gestureWidth: gestureWidth,
      showCupertinoParallax: showCupertinoParallax,
      popGesture: popGesture ?? Get.defaultPopGesture,
      transition: transition ?? Get.defaultTransition,
      curve: curve ?? Get.defaultTransitionCurve,
      fullscreenDialog: fullscreenDialog,
      bindings: bindings,
      transitionDuration: duration ?? Get.defaultTransitionDuration,
    );

    final args = _buildPageSettings(routeName, arguments);
    return _replace(args, route);
  }

  @override
  Future<T?>? offAll<T>(
    Widget Function() page, {
    bool Function(GetPage route)? predicate,
    bool opaque = true,
    bool? popGesture,
    String? id,
    String? routeName,
    dynamic arguments,
    List<BindingsInterface> bindings = const [],
    bool fullscreenDialog = false,
    Transition? transition,
    Curve? curve,
    Duration? duration,
    bool showCupertinoParallax = true,
    double Function(BuildContext context)? gestureWidth,
  }) async {
    routeName ??= _cleanRouteName("/${page.runtimeType}");
    final route = GetPage<T>(
      name: routeName,
      opaque: opaque,
      page: page,
      gestureWidth: gestureWidth,
      showCupertinoParallax: showCupertinoParallax,
      popGesture: popGesture ?? Get.defaultPopGesture,
      transition: transition ?? Get.defaultTransition,
      curve: curve ?? Get.defaultTransitionCurve,
      fullscreenDialog: fullscreenDialog,
      bindings: bindings,
      transitionDuration: duration ?? Get.defaultTransitionDuration,
    );

    final args = _buildPageSettings(routeName, arguments);

    final newPredicate = predicate ?? (route) => false;

    while (_activePages.length > 1 && !newPredicate(_activePages.last.route!)) {
      _popWithResult();
    }

    return _replace(args, route);
  }

  @override
  Future<T?>? offAllNamed<T>(
    String newRouteName, {
    // bool Function(GetPage route)? predicate,
    dynamic arguments,
    String? id,
    Map<String, String>? parameters,
  }) async {
    final args = _buildPageSettings(newRouteName, arguments);
    final route = _getRouteDecoder<T>(args);
    if (route == null) return null;

    while (_activePages.length > 1) {
      _activePages.removeLast();
    }

    return _replaceNamed(route);
  }

  @override
  Future<T?>? offNamedUntil<T>(
    String page, {
    bool Function(GetPage route)? predicate,
    dynamic arguments,
    String? id,
    Map<String, String>? parameters,
  }) async {
    final args = _buildPageSettings(page, arguments);
    final route = _getRouteDecoder<T>(args);
    if (route == null) return null;

    final newPredicate = predicate ?? (route) => false;

    while (_activePages.length > 1 && !newPredicate(_activePages.last.route!)) {
      _activePages.removeLast();
    }

    return _push(route);
  }

  @override
  Future<T?> offNamed<T>(
    String page, {
    dynamic arguments,
    String? id,
    Map<String, String>? parameters,
  }) async {
    final args = _buildPageSettings(page, arguments);
    final route = _getRouteDecoder<T>(args);
    if (route == null) return null;
    _popWithResult();
    return _push<T>(route);
  }

  @override
  Future<T?> toNamedAndOffUntil<T>(
    String page,
    bool Function(GetPage) predicate, [
    Object? data,
  ]) async {
    final arguments = _buildPageSettings(page, data);

    final route = _getRouteDecoder<T>(arguments);

    if (route == null) return null;

    while (_activePages.isNotEmpty && !predicate(_activePages.last.route!)) {
      _popWithResult();
    }

    return _push<T>(route);
  }

  @override
  Future<T?> offUntil<T>(
    Widget Function() page,
    bool Function(GetPage) predicate, [
    Object? arguments,
  ]) async {
    while (_activePages.isNotEmpty && !predicate(_activePages.last.route!)) {
      _popWithResult();
    }

    return to<T>(page, arguments: arguments);
  }

  @override
  void removeRoute<T>(String name) {
    _activePages.remove(RouteDecoder.fromRoute(name));
  }

  bool get canBack {
    return _activePages.length > 1;
  }

  void _checkIfCanBack() {
    assert(() {
      if (!canBack) {
        final last = _activePages.last;
        final name = last.route?.name;
        throw 'The page $name cannot be popped';
      }
      return true;
    }());
  }

  @override
  Future<R?> backAndtoNamed<T, R>(String page,
      {T? result, Object? arguments}) async {
    final args = _buildPageSettings(page, arguments);
    final route = _getRouteDecoder<R>(args);
    if (route == null) return null;
    _popWithResult<T>(result);
    return _push<R>(route);
  }

  /// Removes routes according to [PopMode]
  /// until it reaches the specific [fullRoute],
  /// DOES NOT remove the [fullRoute]
  @override
  Future<void> popModeUntil(
    String fullRoute, {
    PopMode popMode = PopMode.history,
  }) async {
    // remove history or page entries until you meet route
    var iterator = currentConfiguration;
    while (_canPop(popMode) && iterator != null) {
      //the next line causes wasm compile error if included in the while loop
      //https://github.com/flutter/flutter/issues/140110
      if (iterator.pageSettings?.name == fullRoute) {
        break;
      }
      await _pop(popMode, null);
      // replace iterator
      iterator = currentConfiguration;
    }
    notifyListeners();
  }

  @override
  void backUntil(bool Function(GetPage) predicate) {
    while (_activePages.length > 1 && !predicate(_activePages.last.route!)) {
      _popWithResult();
    }

    notifyListeners();
  }

  Future<T?> _replace<T>(PageSettings arguments, GetPage<T> page) async {
    final index = _activePages.length > 1 ? _activePages.length - 1 : 0;
    _routeTree.addRoute(page);

    final activePage = _getRouteDecoder(arguments);

    // final activePage = _configureRouterDecoder<T>(route!, arguments);

    _activePages[index] = activePage!;

    notifyListeners();
    final result = await activePage.route?.completer?.future as Future<T?>?;
    _routeTree.removeRoute(page);

    return result;
  }

  Future<T?> _replaceNamed<T>(RouteDecoder activePage) async {
    final index = _activePages.length > 1 ? _activePages.length - 1 : 0;
    // final activePage = _configureRouterDecoder<T>(page, arguments);
    _activePages[index] = activePage;

    notifyListeners();
    final result = await activePage.route?.completer?.future as Future<T?>?;
    return result;
  }

  /// Takes a route [name] String generated by [to], [off], [offAll]
  /// (and similar context navigation methods), cleans the extra chars and
  /// accommodates the format.
  /// TODO: check for a more "appealing" URL naming convention.
  /// `() => MyHomeScreenView` becomes `/my-home-screen-view`.
  String _cleanRouteName(String name) {
    name = name.replaceAll('() => ', '');

    /// uncomment for URL styling.
    // name = name.paramCase!;
    if (!name.startsWith('/')) {
      name = '/$name';
    }
    return Uri.tryParse(name)?.toString() ?? name;
  }

  PageSettings _buildPageSettings(String page, [Object? data]) {
    var uri = Uri.parse(page);
    return PageSettings(uri, data);
  }

  @protected
  RouteDecoder? _getRouteDecoder<T>(PageSettings arguments) {
    var page = arguments.uri.path;
    final parameters = arguments.params;
    if (parameters.isNotEmpty) {
      final uri = Uri(path: page, queryParameters: parameters);
      page = uri.toString();
    }

    final decoder = _routeTree.matchRoute(page, arguments: arguments);
    final route = decoder.route;
    if (route == null) return null;

    return _configureRouterDecoder<T>(decoder, arguments);
  }

  @protected
  RouteDecoder _configureRouterDecoder<T>(
      RouteDecoder decoder, PageSettings arguments) {
    final parameters =
        arguments.params.isEmpty ? arguments.query : arguments.params;
    arguments.params.addAll(arguments.query);
    if (decoder.parameters.isEmpty) {
      decoder.parameters.addAll(parameters);
    }

    decoder.route = decoder.route?.copyWith(
      completer: _activePages.isEmpty ? null : Completer<T?>(),
      arguments: arguments,
      parameters: parameters,
      key: ValueKey(arguments.name),
    );

    return decoder;
  }

  Future<T?> _push<T>(RouteDecoder decoder, {bool rebuildStack = true}) async {
    var res = await runMiddleware(decoder);
    if (res == null) return null;
    // final res = mid ?? decoder;
    // if (res == null) res = decoder;

    final preventDuplicateHandlingMode =
        res.route?.preventDuplicateHandlingMode ??
            PreventDuplicateHandlingMode.reorderRoutes;

    final onStackPage = _activePages
        .firstWhereOrNull((element) => element.route?.key == res.route?.key);

    /// There are no duplicate routes in the stack
    if (onStackPage == null) {
      _activePages.add(res);
    } else {
      /// There are duplicate routes, reorder
      switch (preventDuplicateHandlingMode) {
        case PreventDuplicateHandlingMode.doNothing:
          break;
        case PreventDuplicateHandlingMode.reorderRoutes:
          _activePages.remove(onStackPage);
          _activePages.add(res);
          break;
        case PreventDuplicateHandlingMode.popUntilOriginalRoute:
          while (_activePages.last == onStackPage) {
            _popWithResult();
          }
          break;
        case PreventDuplicateHandlingMode.recreate:
          _activePages.remove(onStackPage);
          _activePages.add(res);
      }
    }
    if (rebuildStack) {
      notifyListeners();
    }

    return decoder.route?.completer?.future as Future<T?>?;
  }

  @override
  Future<void> setNewRoutePath(RouteDecoder configuration) async {
    final page = configuration.route;
    if (page == null) {
      goToUnknownPage();
      return;
    } else {
      _push(configuration);
    }
  }

  @override
  RouteDecoder? get currentConfiguration {
    if (_activePages.isEmpty) return null;
    final route = _activePages.last;
    return route;
  }

  Future<bool> handlePopupRoutes({
    Object? result,
  }) async {
    Route? currentRoute;
    navigatorKey.currentState!.popUntil((route) {
      currentRoute = route;
      return true;
    });
    if (currentRoute is PopupRoute) {
      return await navigatorKey.currentState!.maybePop(result);
    }
    return false;
  }

  @override
  Future<bool> popRoute({
    Object? result,
    PopMode? popMode,
  }) async {
    //Returning false will cause the entire app to be popped.
    final wasPopup = await handlePopupRoutes(result: result);
    if (wasPopup) return true;

    if (_canPop(popMode ?? backButtonPopMode)) {
      await _pop(popMode ?? backButtonPopMode, result);
      notifyListeners();
      return true;
    }

    return super.popRoute();
  }

  @override
  void back<T>([T? result]) {
    _checkIfCanBack();
    _popWithResult<T>(result);
    notifyListeners();
  }

  bool _onPopVisualRoute(Route<dynamic> route, dynamic result) {
    final didPop = route.didPop(result);
    if (!didPop) {
      return false;
    }
    _popWithResult(result);
    // final settings = route.settings;
    // if (settings is GetPage) {
    //   final config = _activePages.cast<RouteDecoder?>().firstWhere(
    //         (element) => element?.route == settings,
    //         orElse: () => null,
    //       );
    //   if (config != null) {
    //     _removeHistoryEntry(config, result);
    //   }
    // }
    notifyListeners();
    //return !route.navigator!.userGestureInProgress;
    return true;
  }
}


--- File Index 13: lib/get_navigation/src/routes/index.dart ---
export 'circular_reveal_clipper.dart';
export 'custom_transition.dart';
export 'default_route.dart';
export 'default_transitions.dart';
export 'get_information_parser.dart';
export 'get_navigation_interface.dart';
export 'get_navigator.dart';
export 'get_route.dart';
export 'get_router_delegate.dart';
export 'get_transition_mixin.dart';
export 'modules.dart';
export 'observers/route_observer.dart';
export 'page_settings.dart';
export 'parse_route.dart';
export 'route_middleware.dart';
export 'route_report.dart';
export 'router_outlet.dart';
export 'transitions_type.dart';
export 'url_strategy/url_strategy.dart';


--- File Index 14: lib/get_navigation/src/routes/modules.dart ---
import 'package:flutter/material.dart';

import '../../../instance_manager.dart';
import '../router_report.dart';

class Dependencies {
  void lazyPut<S>(InstanceBuilderCallback<S> builder,
      {String? tag, bool fenix = false}) {
    Get.lazyPut<S>(builder, tag: tag, fenix: fenix);
  }

  S call<S>() {
    return find<S>();
  }

  void spawn<S>(InstanceBuilderCallback<S> builder,
          {String? tag, bool permanent = true}) =>
      Get.spawn<S>(builder, tag: tag, permanent: permanent);

  S find<S>({String? tag}) => Get.find<S>(tag: tag);

  S put<S>(S dependency,
          {String? tag,
          bool permanent = false,
          InstanceBuilderCallback<S>? builder}) =>
      Get.put<S>(dependency, tag: tag, permanent: permanent);

  Future<bool> delete<S>({String? tag, bool force = false}) async =>
      Get.delete<S>(tag: tag, force: force);

  Future<void> deleteAll({bool force = false}) async =>
      Get.deleteAll(force: force);

  void reloadAll({bool force = false}) => Get.reloadAll(force: force);

  void reload<S>({String? tag, String? key, bool force = false}) =>
      Get.reload<S>(tag: tag, key: key, force: force);

  bool isRegistered<S>({String? tag}) => Get.isRegistered<S>(tag: tag);

  bool isPrepared<S>({String? tag}) => Get.isPrepared<S>(tag: tag);

  void replace<P>(P child, {String? tag}) {
    final info = Get.getInstanceInfo<P>(tag: tag);
    final permanent = (info.isPermanent ?? false);
    delete<P>(tag: tag, force: permanent);
    put(child, tag: tag, permanent: permanent);
  }

  void lazyReplace<P>(InstanceBuilderCallback<P> builder,
      {String? tag, bool? fenix}) {
    final info = Get.getInstanceInfo<P>(tag: tag);
    final permanent = (info.isPermanent ?? false);
    delete<P>(tag: tag, force: permanent);
    lazyPut(builder, tag: tag, fenix: fenix ?? permanent);
  }
}

abstract class Module extends StatefulWidget {
  const Module({super.key});

  Widget view(BuildContext context);

  void dependencies(Dependencies i);

  @override
  ModuleState createState() => ModuleState();
}

class ModuleState extends State<Module> {
  @override
  void initState() {
    RouterReportManager.instance.reportCurrentRoute(this);
    widget.dependencies(Dependencies());
    super.initState();
  }

  @override
  void dispose() {
    RouterReportManager.instance.reportRouteDispose(this);
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    return widget.view(context);
  }
}


--- File Index 15: lib/get_navigation/src/routes/circular_reveal_clipper.dart ---
import 'dart:math' show sqrt, max;
import 'dart:ui' show lerpDouble;

import 'package:flutter/material.dart';

class CircularRevealClipper extends CustomClipper<Path> {
  final double fraction;
  final Alignment? centerAlignment;
  final Offset? centerOffset;
  final double? minRadius;
  final double? maxRadius;

  CircularRevealClipper({
    required this.fraction,
    this.centerAlignment,
    this.centerOffset,
    this.minRadius,
    this.maxRadius,
  });

  @override
  Path getClip(Size size) {
    final center = centerAlignment?.alongSize(size) ??
        centerOffset ??
        Offset(size.width / 2, size.height / 2);
    final minRadius = this.minRadius ?? 0;
    final maxRadius = this.maxRadius ?? calcMaxRadius(size, center);

    return Path()
      ..addOval(
        Rect.fromCircle(
          center: center,
          radius: lerpDouble(minRadius, maxRadius, fraction)!,
        ),
      );
  }

  @override
  bool shouldReclip(CustomClipper<Path> oldClipper) => true;

  static double calcMaxRadius(Size size, Offset center) {
    final w = max(center.dx, size.width - center.dx);
    final h = max(center.dy, size.height - center.dy);
    return sqrt(w * w + h * h);
  }
}


--- File Index 16: lib/get_navigation/src/routes/route_report.dart ---
import 'package:flutter/material.dart';

import '../router_report.dart';
import 'default_route.dart';

class RouteReport extends StatefulWidget {
  const RouteReport({super.key, required this.builder});
  final WidgetBuilder builder;

  @override
  RouteReportState createState() => RouteReportState();
}

class RouteReportState extends State<RouteReport> with RouteReportMixin {
  @override
  void initState() {
    RouterReportManager.instance.reportCurrentRoute(this);
    super.initState();
  }

  @override
  void dispose() {
    RouterReportManager.instance.reportRouteDispose(this);
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    return widget.builder(context);
  }
}


--- File Index 17: lib/get_navigation/src/routes/get_information_parser.dart ---
import 'package:flutter/foundation.dart';
import 'package:flutter/widgets.dart';

import '../../../get.dart';

class GetInformationParser extends RouteInformationParser<RouteDecoder> {
  factory GetInformationParser.createInformationParser(
      {String initialRoute = '/'}) {
    return GetInformationParser(initialRoute: initialRoute);
  }

  final String initialRoute;

  GetInformationParser({
    required this.initialRoute,
  }) {
    Get.log('GetInformationParser is created !');
  }
  @override
  SynchronousFuture<RouteDecoder> parseRouteInformation(
    RouteInformation routeInformation,
  ) {
    final uri = routeInformation.uri;
    var location = uri.toString();
    if (location == '/') {
      //check if there is a corresponding page
      //if not, relocate to initialRoute
      if (!(Get.rootController.rootDelegate)
          .registeredRoutes
          .any((element) => element.name == '/')) {
        location = initialRoute;
      }
    } else if (location.isEmpty) {
      location = initialRoute;
    }

    Get.log('GetInformationParser: route location: $location');

    return SynchronousFuture(RouteDecoder.fromRoute(location));
  }

  @override
  RouteInformation restoreRouteInformation(RouteDecoder configuration) {
    return RouteInformation(
      uri: Uri.tryParse(configuration.pageSettings?.name ?? ''),
      state: null,
    );
  }
}


--- File Index 18: lib/get_navigation/src/routes/parse_route.dart ---
import 'package:flutter/foundation.dart';

import '../../../get.dart';

@immutable
class RouteDecoder {
  const RouteDecoder(
    this.currentTreeBranch,
    this.pageSettings,
  );
  final List<GetPage> currentTreeBranch;
  final PageSettings? pageSettings;

  factory RouteDecoder.fromRoute(String location) {
    var uri = Uri.parse(location);
    final args = PageSettings(uri);
    final decoder =
        (Get.rootController.rootDelegate).matchRoute(location, arguments: args);
    decoder.route = decoder.route?.copyWith(
      completer: null,
      arguments: args,
      parameters: args.params,
    );
    return decoder;
  }

  GetPage? get route =>
      currentTreeBranch.isEmpty ? null : currentTreeBranch.last;

  GetPage routeOrUnknown(GetPage onUnknow) =>
      currentTreeBranch.isEmpty ? onUnknow : currentTreeBranch.last;

  set route(GetPage? getPage) {
    if (getPage == null) return;
    if (currentTreeBranch.isEmpty) {
      currentTreeBranch.add(getPage);
    } else {
      currentTreeBranch[currentTreeBranch.length - 1] = getPage;
    }
  }

  List<GetPage>? get currentChildren => route?.children;

  Map<String, String> get parameters => pageSettings?.params ?? {};

  dynamic get args {
    return pageSettings?.arguments;
  }

  T? arguments<T>() {
    final args = pageSettings?.arguments;
    if (args is T) {
      return pageSettings?.arguments as T;
    } else {
      return null;
    }
  }

  // void replaceArguments(Object? arguments) {
  //   final newRoute = route;
  //   if (newRoute != null) {
  //     final index = currentTreeBranch.indexOf(newRoute);
  //     currentTreeBranch[index] = newRoute.copyWith(arguments: arguments);
  //   }
  // }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;

    return other is RouteDecoder &&
        listEquals(other.currentTreeBranch, currentTreeBranch) &&
        other.pageSettings == pageSettings;
  }

  @override
  int get hashCode => currentTreeBranch.hashCode ^ pageSettings.hashCode;

  @override
  String toString() =>
      'RouteDecoder(currentTreeBranch: $currentTreeBranch, pageSettings: $pageSettings)';
}

class ParseRouteTree {
  ParseRouteTree({
    required this.routes,
  });

  final List<GetPage> routes;

  RouteDecoder matchRoute(String name, {PageSettings? arguments}) {
    final uri = Uri.parse(name);
    final split = uri.path.split('/').where((element) => element.isNotEmpty);
    var curPath = '/';
    final cumulativePaths = <String>[
      '/',
    ];
    for (var item in split) {
      if (curPath.endsWith('/')) {
        curPath += item;
      } else {
        curPath += '/$item';
      }
      cumulativePaths.add(curPath);
    }

    final treeBranch = cumulativePaths
        .map((e) => MapEntry(e, _findRoute(e)))
        .where((element) => element.value != null)

        ///Prevent page be disposed
        .map((e) => MapEntry(e.key, e.value!.copyWith(key: ValueKey(e.key))))
        .toList();

    final params = Map<String, String>.from(uri.queryParameters);
    if (treeBranch.isNotEmpty) {
      //route is found, do further parsing to get nested query params
      final lastRoute = treeBranch.last;
      final parsedParams = _parseParams(name, lastRoute.value.path);
      if (parsedParams.isNotEmpty) {
        params.addAll(parsedParams);
      }
      //copy parameters to all pages.
      final mappedTreeBranch = treeBranch
          .map(
            (e) => e.value.copyWith(
              parameters: {
                if (e.value.parameters != null) ...e.value.parameters!,
                ...params,
              },
              name: e.key,
            ),
          )
          .toList();
      arguments?.params.clear();
      arguments?.params.addAll(params);
      return RouteDecoder(
        mappedTreeBranch,
        arguments,
      );
    }

    arguments?.params.clear();
    arguments?.params.addAll(params);

    //route not found
    return RouteDecoder(
      treeBranch.map((e) => e.value).toList(),
      arguments,
    );
  }

  void addRoutes<T>(List<GetPage<T>> getPages) {
    for (final route in getPages) {
      addRoute(route);
    }
  }

  void removeRoutes<T>(List<GetPage<T>> getPages) {
    for (final route in getPages) {
      removeRoute(route);
    }
  }

  void removeRoute<T>(GetPage<T> route) {
    routes.remove(route);
    for (var page in _flattenPage(route)) {
      removeRoute(page);
    }
  }

  void addRoute<T>(GetPage<T> route) {
    routes.add(route);

    // Add Page children.
    for (var page in _flattenPage(route)) {
      addRoute(page);
    }
  }

  List<GetPage> _flattenPage(GetPage route) {
    final result = <GetPage>[];
    if (route.children.isEmpty) {
      return result;
    }

    final parentPath = route.name;
    for (var page in route.children) {
      // Add Parent middlewares to children
      final parentMiddlewares = [
        if (page.middlewares.isNotEmpty) ...page.middlewares,
        if (route.middlewares.isNotEmpty) ...route.middlewares
      ];

      final parentBindings = [
        if (page.binding != null) page.binding!,
        if (page.bindings.isNotEmpty) ...page.bindings,
        if (route.bindings.isNotEmpty) ...route.bindings
      ];

      final parentBinds = [
        if (page.binds.isNotEmpty) ...page.binds,
        if (route.binds.isNotEmpty) ...route.binds
      ];

      result.add(
        _addChild(
          page,
          parentPath,
          parentMiddlewares,
          parentBindings,
          parentBinds,
        ),
      );

      final children = _flattenPage(page);
      for (var child in children) {
        result.add(_addChild(
          child,
          parentPath,
          [
            ...parentMiddlewares,
            if (child.middlewares.isNotEmpty) ...child.middlewares,
          ],
          [
            ...parentBindings,
            if (child.binding != null) child.binding!,
            if (child.bindings.isNotEmpty) ...child.bindings,
          ],
          [
            ...parentBinds,
            if (child.binds.isNotEmpty) ...child.binds,
          ],
        ));
      }
    }
    return result;
  }

  /// Change the Path for a [GetPage]
  GetPage _addChild(
    GetPage origin,
    String parentPath,
    List<GetMiddleware> middlewares,
    List<BindingsInterface> bindings,
    List<Bind> binds,
  ) {
    return origin.copyWith(
      middlewares: middlewares,
      name: origin.inheritParentPath
          ? (parentPath + origin.name).replaceAll(r'//', '/')
          : origin.name,
      bindings: bindings,
      binds: binds,
      // key:
    );
  }

  GetPage? _findRoute(String name) {
    final value = routes.firstWhereOrNull(
      (route) => route.path.regex.hasMatch(name),
    );

    return value;
  }

  Map<String, String> _parseParams(String path, PathDecoded routePath) {
    final params = <String, String>{};
    var idx = path.indexOf('?');
    final uri = Uri.tryParse(path);
    if (uri == null) return params;
    if (idx > -1) {
      params.addAll(uri.queryParameters);
    }
    var paramsMatch = routePath.regex.firstMatch(uri.path);
    if (paramsMatch == null) {
      return params;
    }
    for (var i = 0; i < routePath.keys.length; i++) {
      var param = Uri.decodeQueryComponent(paramsMatch[i + 1]!);
      params[routePath.keys[i]!] = param;
    }
    return params;
  }
}

extension FirstWhereOrNullExt<T> on List<T> {
  /// The first element satisfying [test], or `null` if there are none.
  T? firstWhereOrNull(bool Function(T element) test) {
    for (var element in this) {
      if (test(element)) return element;
    }
    return null;
  }
}


--- File Index 19: lib/get_navigation/src/routes/page_settings.dart ---
import 'package:flutter/widgets.dart';

import '../../../route_manager.dart';

extension PageArgExt on BuildContext {
  RouteSettings? get settings {
    return ModalRoute.of(this)!.settings;
  }

  PageSettings? get pageSettings {
    final args = ModalRoute.of(this)?.settings.arguments;
    if (args is PageSettings) {
      return args;
    }
    return null;
  }

  dynamic get arguments {
    final args = settings?.arguments;
    if (args is PageSettings) {
      return args.arguments;
    } else {
      return args;
    }
  }

  Map<String, String> get params {
    final args = settings?.arguments;
    if (args is PageSettings) {
      return args.params;
    } else {
      return {};
    }
  }

  Router get router {
    return Router.of(this);
  }

  String get location {
    final parser = router.routeInformationParser;
    final config = delegate.currentConfiguration;
    return parser?.restoreRouteInformation(config)?.uri.toString() ?? '/';
  }

  GetDelegate get delegate {
    return router.routerDelegate as GetDelegate;
  }
}

class PageSettings extends RouteSettings {
  PageSettings(
    this.uri, [
    Object? arguments,
  ]) : super(arguments: arguments);

  @override
  String get name => '$uri';

  final Uri uri;

  final params = <String, String>{};

  String get path => uri.path;

  List<String> get paths => uri.pathSegments;

  Map<String, String> get query => uri.queryParameters;

  Map<String, List<String>> get queries => uri.queryParametersAll;

  @override
  String toString() => name;

  PageSettings copy({
    Uri? uri,
    Object? arguments,
  }) {
    return PageSettings(
      uri ?? this.uri,
      arguments ?? this.arguments,
    );
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;

    return other is PageSettings &&
        other.uri == uri &&
        other.arguments == arguments;
  }

  @override
  int get hashCode => uri.hashCode ^ arguments.hashCode;
}


--- File Index 20: lib/get_navigation/src/routes/get_navigator.dart ---
import 'package:flutter/widgets.dart';

class GetNavigator extends Navigator {
  GetNavigator({
    super.key,
    bool Function(Route<dynamic>, dynamic)? onPopPage,
    required super.pages,
    List<NavigatorObserver>? observers,
    super.reportsRouteUpdateToEngine,
    TransitionDelegate? transitionDelegate,
    super.initialRoute,
    super.restorationScopeId,
  }) : super(
          // ignore: deprecated_member_use
          onPopPage: onPopPage ??
              (route, result) {
                final didPop = route.didPop(result);
                if (!didPop) {
                  return false;
                }
                return true;
              },
          observers: [
            // GetObserver(null, Get.routing),
            HeroController(),
            ...?observers,
          ],
          transitionDelegate:
              transitionDelegate ?? const DefaultTransitionDelegate<dynamic>(),
        );
}


--- File Index 21: lib/get_navigation/src/routes/route_middleware.dart ---
import 'dart:async';

import 'package:flutter/cupertino.dart';

import '../../../get.dart';

/// The Page Middlewares.
/// The Functions will be called in this order
/// (( [redirect] -> [onPageCalled] -> [onBindingsStart] ->
/// [onPageBuildStart] -> [onPageBuilt] -> [onPageDispose] ))
abstract class GetMiddleware {
  GetMiddleware({this.priority = 0});

  /// The Order of the Middlewares to run.
  ///
  /// {@tool snippet}
  /// This Middewares will be called in this order.
  /// ```dart
  /// final middlewares = [
  ///   GetMiddleware(priority: 2),
  ///   GetMiddleware(priority: 5),
  ///   GetMiddleware(priority: 4),
  ///   GetMiddleware(priority: -8),
  /// ];
  /// ```
  ///  -8 => 2 => 4 => 5
  /// {@end-tool}
  final int priority;

  /// This function will be called when the page of
  /// the called route is being searched for.
  /// It take RouteSettings as a result an redirect to the new settings or
  /// give it null and there will be no redirecting.
  /// {@tool snippet}
  /// ```dart
  /// GetPage redirect(String route) {
  ///   final authService = Get.find<AuthService>();
  ///   return authService.authed.value ? null : RouteSettings(name: '/login');
  /// }
  /// ```
  /// {@end-tool}
  RouteSettings? redirect(String? route) => null;

  /// Similar to [redirect],
  /// This function will be called when the router delegate changes the
  /// current route.
  ///
  /// The default implmentation is to navigate to
  /// the input route, with no redirection.
  ///
  /// if this returns null, the navigation is stopped,
  /// and no new routes are pushed.
  /// {@tool snippet}
  /// ```dart
  /// GetNavConfig? redirect(GetNavConfig route) {
  ///   final authService = Get.find<AuthService>();
  ///   return authService.authed.value ? null : RouteSettings(name: '/login');
  /// }
  /// ```
  /// {@end-tool}
  FutureOr<RouteDecoder?> redirectDelegate(RouteDecoder route) => (route);

  /// This function will be called when this Page is called
  /// you can use it to change something about the page or give it new page
  /// {@tool snippet}
  /// ```dart
  /// GetPage onPageCalled(GetPage page) {
  ///   final authService = Get.find<AuthService>();
  ///   return page.copyWith(title: 'Welcome ${authService.UserName}');
  /// }
  /// ```
  /// {@end-tool}
  GetPage? onPageCalled(GetPage? page) => page;

  /// This function will be called right before the [BindingsInterface] are initialize.
  /// Here you can change [BindingsInterface] for this page
  /// {@tool snippet}
  /// ```dart
  /// List<Bindings> onBindingsStart(List<Bindings> bindings) {
  ///   final authService = Get.find<AuthService>();
  ///   if (authService.isAdmin) {
  ///     bindings.add(AdminBinding());
  ///   }
  ///   return bindings;
  /// }
  /// ```
  /// {@end-tool}
  List<R>? onBindingsStart<R>(List<R>? bindings) => bindings;

  /// This function will be called right after the [BindingsInterface] are initialize.
  GetPageBuilder? onPageBuildStart(GetPageBuilder? page) => page;

  /// This function will be called right after the
  /// GetPage.page function is called and will give you the result
  /// of the function. and take the widget that will be showed.
  Widget onPageBuilt(Widget page) => page;

  void onPageDispose() {}
}

class MiddlewareRunner {
  MiddlewareRunner(List<GetMiddleware>? middlewares)
      : _middlewares = middlewares != null
            ? (List.of(middlewares)..sort(_compareMiddleware))
            : const [];

  final List<GetMiddleware> _middlewares;

  static int _compareMiddleware(GetMiddleware a, GetMiddleware b) =>
      a.priority.compareTo(b.priority);

  GetPage? runOnPageCalled(GetPage? page) {
    for (final middleware in _middlewares) {
      page = middleware.onPageCalled(page);
    }
    return page;
  }

  RouteSettings? runRedirect(String? route) {
    for (final middleware in _middlewares) {
      final redirectTo = middleware.redirect(route);
      if (redirectTo != null) {
        return redirectTo;
      }
    }
    return null;
  }

  List<R>? runOnBindingsStart<R>(List<R>? bindings) {
    for (final middleware in _middlewares) {
      bindings = middleware.onBindingsStart(bindings);
    }
    return bindings;
  }

  GetPageBuilder? runOnPageBuildStart(GetPageBuilder? page) {
    for (final middleware in _middlewares) {
      page = middleware.onPageBuildStart(page);
    }
    return page;
  }

  Widget runOnPageBuilt(Widget page) {
    for (final middleware in _middlewares) {
      page = middleware.onPageBuilt(page);
    }
    return page;
  }

  void runOnPageDispose() {
    for (final middleware in _middlewares) {
      middleware.onPageDispose();
    }
  }
}

class PageRedirect {
  GetPage? route;
  GetPage? unknownRoute;
  RouteSettings? settings;
  bool isUnknown;

  PageRedirect({
    this.route,
    this.unknownRoute,
    this.isUnknown = false,
    this.settings,
  });

  // redirect all pages that needes redirecting
  GetPageRoute<T> getPageToRoute<T>(
      GetPage rou, GetPage? unk, BuildContext context) {
    while (needRecheck(context)) {}
    final r = (isUnknown ? unk : rou)!;

    return GetPageRoute<T>(
      page: r.page,
      parameter: r.parameters,
      alignment: r.alignment,
      title: r.title,
      maintainState: r.maintainState,
      routeName: r.name,
      settings: r,
      curve: r.curve,
      showCupertinoParallax: r.showCupertinoParallax,
      gestureWidth: r.gestureWidth,
      opaque: r.opaque,
      customTransition: r.customTransition,
      bindings: r.bindings,
      binding: r.binding,
      binds: r.binds,
      transitionDuration: r.transitionDuration ?? Get.defaultTransitionDuration,
      reverseTransitionDuration:
          r.reverseTransitionDuration ?? Get.defaultTransitionDuration,
      // performIncomeAnimation: _r.performIncomeAnimation,
      // performOutGoingAnimation: _r.performOutGoingAnimation,
      transition: r.transition,
      popGesture: r.popGesture,
      fullscreenDialog: r.fullscreenDialog,
      middlewares: r.middlewares,
    );
  }

  /// check if redirect is needed
  bool needRecheck(BuildContext context) {
    if (settings == null && route != null) {
      settings = route;
    }
    final match = context.delegate.matchRoute(settings!.name!);

    // No Match found
    if (match.route == null) {
      isUnknown = true;
      return false;
    }

    // No middlewares found return match.
    if (match.route!.middlewares.isEmpty) {
      return false;
    }

    final runner = MiddlewareRunner(match.route!.middlewares);
    route = runner.runOnPageCalled(match.route);
    addPageParameter(route!);

    final newSettings = runner.runRedirect(settings!.name);
    if (newSettings == null) {
      return false;
    }
    settings = newSettings;
    return true;
  }

  void addPageParameter(GetPage route) {
    if (route.parameters == null) return;

    final parameters = Map<String, String?>.from(Get.parameters);
    parameters.addEntries(route.parameters!.entries);
    // Get.parameters = parameters;
  }
}


--- File Index 22: lib/get_navigation/src/routes/get_transition_mixin.dart ---
import 'dart:math';
import 'dart:ui';

import 'package:flutter/cupertino.dart';
import 'package:flutter/foundation.dart';
import 'package:flutter/gestures.dart';
import 'package:flutter/material.dart';

import '../../../get.dart';
import '../root/get_root.dart';

const double _kBackGestureWidth = 20.0;

const double _kMinFlingVelocity = 1; // Screen widths per second.

// An eyeballed value for the maximum time it takes for a page to animate
// forward if the user releases a page mid swipe.
const int _kMaxMidSwipePageForwardAnimationTime = 800; // Milliseconds.

// The maximum time for a page to get reset to it's original position if the
// user releases a page mid swipe.
const int _kMaxPageBackAnimationTime = 300; // Milliseconds.

class GetBackGestureDetector<T> extends StatefulWidget {
  const GetBackGestureDetector({
    super.key,
    required this.limitedSwipe,
    required this.gestureWidth,
    required this.initialOffset,
    required this.popGestureEnable,
    required this.onStartPopGesture,
    required this.child,
  });

  final bool limitedSwipe;
  final double gestureWidth;
  final double initialOffset;

  final Widget child;
  final ValueGetter<bool> popGestureEnable;
  final ValueGetter<GetBackGestureController<T>> onStartPopGesture;

  @override
  GetBackGestureDetectorState<T> createState() =>
      GetBackGestureDetectorState<T>();
}

class GetBackGestureDetectorState<T> extends State<GetBackGestureDetector<T>> {
  GetBackGestureController<T>? _backGestureController;

  void _handleDragStart(DragStartDetails details) {
    assert(mounted);
    assert(_backGestureController == null);
    _backGestureController = widget.onStartPopGesture();
  }

  void _handleDragUpdate(DragUpdateDetails details) {
    assert(mounted);
    assert(_backGestureController != null);
    _backGestureController!.dragUpdate(
      _convertToLogical(details.primaryDelta! / context.size!.width),
    );
  }

  void _handleDragEnd(DragEndDetails details) {
    assert(mounted);
    assert(_backGestureController != null);
    _backGestureController!.dragEnd(_convertToLogical(
      details.velocity.pixelsPerSecond.dx / context.size!.width,
    ));
    _backGestureController = null;
  }

  void _handleDragCancel() {
    assert(mounted);
    // This can be called even if start is not called, paired with the "down"
    // event that we don't consider here.
    _backGestureController?.dragEnd(0);
    _backGestureController = null;
  }

  double _convertToLogical(double value) {
    switch (Directionality.of(context)) {
      case TextDirection.rtl:
        return -value;
      case TextDirection.ltr:
        return value;
    }
  }

  @override
  Widget build(BuildContext context) {
    assert(debugCheckHasDirectionality(context));

    final gestureDetector = RawGestureDetector(
      behavior: HitTestBehavior.translucent,
      gestures: {
        _DirectionalityDragGestureRecognizer:
            GestureRecognizerFactoryWithHandlers<
                _DirectionalityDragGestureRecognizer>(
          () {
            final directionality = Directionality.of(context);
            return _DirectionalityDragGestureRecognizer(
              debugOwner: this,
              isRTL: directionality == TextDirection.rtl,
              isLTR: directionality == TextDirection.ltr,
              hasbackGestureController: () => _backGestureController != null,
              popGestureEnable: widget.popGestureEnable,
            );
          },
          (directionalityDragGesture) => directionalityDragGesture
            ..onStart = _handleDragStart
            ..onUpdate = _handleDragUpdate
            ..onEnd = _handleDragEnd
            ..onCancel = _handleDragCancel,
        )
      },
    );

    return Stack(
      fit: StackFit.passthrough,
      children: [
        widget.child,
        if (widget.limitedSwipe)
          PositionedDirectional(
            start: widget.initialOffset,
            width: _dragAreaWidth(context),
            top: 0,
            bottom: 0,
            child: gestureDetector,
          )
        else
          Positioned.fill(child: gestureDetector),
      ],
    );
  }

  double _dragAreaWidth(BuildContext context) {
    // For devices with notches, the drag area needs to be larger on the side
    // that has the notch.
    final dragAreaWidth = Directionality.of(context) == TextDirection.ltr
        ? context.mediaQuery.padding.left
        : context.mediaQuery.padding.right;
    return max(dragAreaWidth, widget.gestureWidth);
  }
}

class GetBackGestureController<T> {
  GetBackGestureController({
    required this.navigator,
    required this.controller,
  }) {
    navigator.didStartUserGesture();
  }

  final AnimationController controller;
  final NavigatorState navigator;

  /// The drag gesture has changed by [delta]. The total range of the
  /// drag should be 0.0 to 1.0.
  void dragUpdate(double delta) {
    controller.value -= delta;
  }

  /// The drag gesture has ended with a horizontal motion of [velocity] as a
  /// fraction of screen width per second.
  void dragEnd(double velocity) {
    // Fling in the appropriate direction.
    // AnimationController.fling is guaranteed to
    // take at least one frame.
    //
    // This curve has been determined through rigorously eyeballing native iOS
    // animations.
    const Curve animationCurve = Curves.fastLinearToSlowEaseIn;
    final bool animateForward;

    // If the user releases the page before mid screen with sufficient velocity,
    // or after mid screen, we should animate the page out. Otherwise, the page
    // should be animated back in.
    if (velocity.abs() >= _kMinFlingVelocity) {
      animateForward = velocity <= 0;
    } else {
      animateForward = controller.value > 0.5;
    }

    if (animateForward) {
      // The closer the panel is to dismissing, the shorter the animation is.
      // We want to cap the animation time, but we want to use a linear curve
      // to determine it.
      final droppedPageForwardAnimationTime = min(
        lerpDouble(_kMaxMidSwipePageForwardAnimationTime, 0, controller.value)!
            .floor(),
        _kMaxPageBackAnimationTime,
      );
      controller.animateTo(1.0,
          duration: Duration(milliseconds: droppedPageForwardAnimationTime),
          curve: animationCurve);
    } else {
      // This route is destined to pop at this point. Reuse navigator's pop.
      Get.back();

      // The popping may have finished inline if already at the
      // target destination.
      if (controller.isAnimating) {
        // Otherwise, use a custom popping animation duration and curve.
        final droppedPageBackAnimationTime = lerpDouble(
                0, _kMaxMidSwipePageForwardAnimationTime, controller.value)!
            .floor();
        controller.animateBack(0.0,
            duration: Duration(milliseconds: droppedPageBackAnimationTime),
            curve: animationCurve);
      }
    }

    if (controller.isAnimating) {
      // Keep the userGestureInProgress in true state so we don't change the
      // curve of the page transition mid-flight since CupertinoPageTransition
      // depends on userGestureInProgress.
      late AnimationStatusListener animationStatusCallback;
      animationStatusCallback = (status) {
        navigator.didStopUserGesture();
        controller.removeStatusListener(animationStatusCallback);
      };
      controller.addStatusListener(animationStatusCallback);
    } else {
      navigator.didStopUserGesture();
    }
  }
}

mixin GetPageRouteTransitionMixin<T> on PageRoute<T> {
  ValueNotifier<String?>? _previousTitle;

  @override
  Color? get barrierColor => null;

  @override
  String? get barrierLabel => null;

  double Function(BuildContext context)? get gestureWidth;

  /// True if an iOS-style back swipe pop gesture is currently
  /// underway for this route.
  ///
  /// See also:
  ///
  ///  * [isPopGestureInProgress], which returns true if a Cupertino pop gesture
  ///    is currently underway for specific route.
  ///  * [popGestureEnabled], which returns true if a user-triggered pop gesture
  ///    would be allowed.
  //bool get popGestureInProgress => isPopGestureInProgress(this);

  /// The title string of the previous [CupertinoPageRoute].
  ///
  /// The [ValueListenable]'s value is readable after the route is installed
  /// onto a [Navigator]. The [ValueListenable] will also notify its listeners
  /// if the value changes (such as by replacing the previous route).
  ///
  /// The [ValueListenable] itself will be null before the route is installed.
  /// Its content value will be null if the previous route has no title or
  /// is not a [CupertinoPageRoute].
  ///
  /// See also:
  ///
  ///  * [ValueListenableBuilder], which can be used to listen and rebuild
  ///    widgets based on a ValueListenable.
  ValueListenable<String?> get previousTitle {
    assert(
      _previousTitle != null,
      '''
Cannot read the previousTitle for a route that has not yet been installed''',
    );
    return _previousTitle!;
  }

  bool get showCupertinoParallax;

  /// {@template flutter.cupertino.CupertinoRouteTransitionMixin.title}
  /// A title string for this route.
  ///
  /// Used to auto-populate [CupertinoNavigationBar] and
  /// [CupertinoSliverNavigationBar]'s `middle`/`largeTitle` widgets when
  /// one is not manually supplied.
  /// {@endtemplate}
  String? get title;

  @override
  // A relatively rigorous eyeball estimation.
  Duration get transitionDuration;

  @override
  Duration get reverseTransitionDuration;

  /// Builds the primary contents of the route.
  @protected
  Widget buildContent(BuildContext context);

  @override
  Widget buildPage(BuildContext context, Animation<double> animation,
      Animation<double> secondaryAnimation) {
    final child = buildContent(context);
    final Widget result = Semantics(
      scopesRoute: true,
      explicitChildNodes: true,
      child: child,
    );
    return result;
  }

  @override
  Widget buildTransitions(BuildContext context, Animation<double> animation,
      Animation<double> secondaryAnimation, Widget child) {
    return buildPageTransitions<T>(
        this, context, animation, secondaryAnimation, child);
  }

  @override
  bool canTransitionTo(TransitionRoute<dynamic> nextRoute) {
    // Don't perform outgoing animation if the next route is a
    // fullscreen dialog.
    return (nextRoute is GetPageRouteTransitionMixin &&
            !nextRoute.fullscreenDialog &&
            nextRoute.showCupertinoParallax) ||
        (nextRoute is CupertinoRouteTransitionMixin &&
            !nextRoute.fullscreenDialog) ||
        (nextRoute is CupertinoSheetRoute &&
            !nextRoute.fullscreenDialog);
  }

  @override
  void didChangePrevious(Route<dynamic>? previousRoute) {
    final previousTitleString = previousRoute is CupertinoRouteTransitionMixin
        ? previousRoute.title
        : null;
    if (_previousTitle == null) {
      _previousTitle = ValueNotifier<String?>(previousTitleString);
    } else {
      _previousTitle!.value = previousTitleString;
    }
    super.didChangePrevious(previousRoute);
  }

  static bool canSwipe(GetPageRoute route) =>
      route.popGesture ?? Get.defaultPopGesture ?? GetPlatform.isIOS;

  /// Returns a [CupertinoFullscreenDialogTransition] if [route] is a full
  /// screen dialog, otherwise a [CupertinoPageTransition] is returned.
  ///
  /// Used by [CupertinoPageRoute.buildTransitions].
  ///
  /// This method can be applied to any [PageRoute], not just
  /// [CupertinoPageRoute]. It's typically used to provide a Cupertino style
  /// horizontal transition for material widgets when the target platform
  /// is [TargetPlatform.iOS].
  ///
  /// See also:
  ///
  ///  * [CupertinoPageTransitionsBuilder], which uses this method to define a
  ///    [PageTransitionsBuilder] for the [PageTransitionsTheme].
  static Widget buildPageTransitions<T>(
    PageRoute<T> rawRoute,
    BuildContext context,
    Animation<double> animation,
    Animation<double> secondaryAnimation,
    Widget child, {
    bool limitedSwipe = false,
    double initialOffset = 0,
  }) {
    // Check if the route has an animation that's currently participating
    // in a back swipe gesture.
    //
    // In the middle of a back gesture drag, let the transition be linear to
    // match finger motions.
    final route = rawRoute as GetPageRoute<T>;
    final linearTransition = route.popGestureInProgress;
    final finalCurve = route.curve ?? Get.defaultTransitionCurve;
    final hasCurve = route.curve != null;
    if (route.fullscreenDialog && route.transition == null) {
      return CupertinoFullscreenDialogTransition(
        primaryRouteAnimation: hasCurve
            ? CurvedAnimation(parent: animation, curve: finalCurve)
            : animation,
        secondaryRouteAnimation: secondaryAnimation,
        linearTransition: linearTransition,
        child: child,
      );
    } else {
      if (route.customTransition != null) {
        return route.customTransition!.buildTransition(
          context,
          finalCurve,
          route.alignment,
          animation,
          secondaryAnimation,
          GetBackGestureDetector<T>(
            popGestureEnable: () =>
                _isPopGestureEnabled(route, canSwipe(route), context),
            onStartPopGesture: () {
              assert(_isPopGestureEnabled(route, canSwipe(route), context));
              return _startPopGesture(route);
            },
            limitedSwipe: limitedSwipe,
            gestureWidth:
                route.gestureWidth?.call(context) ?? _kBackGestureWidth,
            initialOffset: initialOffset,
            child: child,
          ),
        );
      }

      /// Apply the curve by default...
      final iosAnimation = animation;
      animation = CurvedAnimation(parent: animation, curve: finalCurve);

      switch (route.transition ?? Get.defaultTransition) {
        case Transition.leftToRight:
          return SlideLeftTransition().buildTransitions(
              context,
              route.curve,
              route.alignment,
              animation,
              secondaryAnimation,
              GetBackGestureDetector<T>(
                popGestureEnable: () =>
                    _isPopGestureEnabled(route, canSwipe(route), context),
                onStartPopGesture: () {
                  assert(_isPopGestureEnabled(route, canSwipe(route), context));
                  return _startPopGesture(route);
                },
                limitedSwipe: limitedSwipe,
                gestureWidth:
                    route.gestureWidth?.call(context) ?? _kBackGestureWidth,
                initialOffset: initialOffset,
                child: child,
              ));

        case Transition.downToUp:
          return SlideDownTransition().buildTransitions(
              context,
              route.curve,
              route.alignment,
              animation,
              secondaryAnimation,
              GetBackGestureDetector<T>(
                popGestureEnable: () =>
                    _isPopGestureEnabled(route, canSwipe(route), context),
                onStartPopGesture: () {
                  assert(_isPopGestureEnabled(route, canSwipe(route), context));
                  return _startPopGesture(route);
                },
                limitedSwipe: limitedSwipe,
                gestureWidth:
                    route.gestureWidth?.call(context) ?? _kBackGestureWidth,
                initialOffset: initialOffset,
                child: child,
              ));

        case Transition.upToDown:
          return SlideTopTransition().buildTransitions(
              context,
              route.curve,
              route.alignment,
              animation,
              secondaryAnimation,
              GetBackGestureDetector<T>(
                popGestureEnable: () =>
                    _isPopGestureEnabled(route, canSwipe(route), context),
                onStartPopGesture: () {
                  assert(_isPopGestureEnabled(route, canSwipe(route), context));
                  return _startPopGesture(route);
                },
                limitedSwipe: limitedSwipe,
                gestureWidth:
                    route.gestureWidth?.call(context) ?? _kBackGestureWidth,
                initialOffset: initialOffset,
                child: child,
              ));

        case Transition.noTransition:
          return GetBackGestureDetector<T>(
            popGestureEnable: () =>
                _isPopGestureEnabled(route, canSwipe(route), context),
            onStartPopGesture: () {
              assert(_isPopGestureEnabled(route, canSwipe(route), context));
              return _startPopGesture(route);
            },
            limitedSwipe: limitedSwipe,
            gestureWidth:
                route.gestureWidth?.call(context) ?? _kBackGestureWidth,
            initialOffset: initialOffset,
            child: child,
          );

        case Transition.rightToLeft:
          return SlideRightTransition().buildTransitions(
              context,
              route.curve,
              route.alignment,
              animation,
              secondaryAnimation,
              GetBackGestureDetector<T>(
                popGestureEnable: () =>
                    _isPopGestureEnabled(route, canSwipe(route), context),
                onStartPopGesture: () {
                  assert(_isPopGestureEnabled(route, canSwipe(route), context));
                  return _startPopGesture(route);
                },
                limitedSwipe: limitedSwipe,
                gestureWidth:
                    route.gestureWidth?.call(context) ?? _kBackGestureWidth,
                initialOffset: initialOffset,
                child: child,
              ));

        case Transition.zoom:
          return ZoomInTransition().buildTransitions(
              context,
              route.curve,
              route.alignment,
              animation,
              secondaryAnimation,
              GetBackGestureDetector<T>(
                popGestureEnable: () =>
                    _isPopGestureEnabled(route, canSwipe(route), context),
                onStartPopGesture: () {
                  assert(_isPopGestureEnabled(route, canSwipe(route), context));
                  return _startPopGesture(route);
                },
                limitedSwipe: limitedSwipe,
                gestureWidth:
                    route.gestureWidth?.call(context) ?? _kBackGestureWidth,
                initialOffset: initialOffset,
                child: child,
              ));

        case Transition.fadeIn:
          return FadeInTransition().buildTransitions(
              context,
              route.curve,
              route.alignment,
              animation,
              secondaryAnimation,
              GetBackGestureDetector<T>(
                popGestureEnable: () =>
                    _isPopGestureEnabled(route, canSwipe(route), context),
                onStartPopGesture: () {
                  assert(_isPopGestureEnabled(route, canSwipe(route), context));
                  return _startPopGesture(route);
                },
                limitedSwipe: limitedSwipe,
                gestureWidth:
                    route.gestureWidth?.call(context) ?? _kBackGestureWidth,
                initialOffset: initialOffset,
                child: child,
              ));

        case Transition.rightToLeftWithFade:
          return RightToLeftFadeTransition().buildTransitions(
              context,
              route.curve,
              route.alignment,
              animation,
              secondaryAnimation,
              GetBackGestureDetector<T>(
                popGestureEnable: () =>
                    _isPopGestureEnabled(route, canSwipe(route), context),
                onStartPopGesture: () {
                  assert(_isPopGestureEnabled(route, canSwipe(route), context));
                  return _startPopGesture(route);
                },
                limitedSwipe: limitedSwipe,
                gestureWidth:
                    route.gestureWidth?.call(context) ?? _kBackGestureWidth,
                initialOffset: initialOffset,
                child: child,
              ));

        case Transition.leftToRightWithFade:
          return LeftToRightFadeTransition().buildTransitions(
              context,
              route.curve,
              route.alignment,
              animation,
              secondaryAnimation,
              GetBackGestureDetector<T>(
                popGestureEnable: () =>
                    _isPopGestureEnabled(route, canSwipe(route), context),
                onStartPopGesture: () {
                  assert(_isPopGestureEnabled(route, canSwipe(route), context));
                  return _startPopGesture(route);
                },
                limitedSwipe: limitedSwipe,
                gestureWidth:
                    route.gestureWidth?.call(context) ?? _kBackGestureWidth,
                initialOffset: initialOffset,
                child: child,
              ));

        case Transition.cupertino:
          return CupertinoPageTransition(
              primaryRouteAnimation: animation,
              secondaryRouteAnimation: secondaryAnimation,
              linearTransition: linearTransition,
              child: GetBackGestureDetector<T>(
                popGestureEnable: () =>
                    _isPopGestureEnabled(route, canSwipe(route), context),
                onStartPopGesture: () {
                  assert(_isPopGestureEnabled(route, canSwipe(route), context));
                  return _startPopGesture(route);
                },
                limitedSwipe: limitedSwipe,
                gestureWidth:
                    route.gestureWidth?.call(context) ?? _kBackGestureWidth,
                initialOffset: initialOffset,
                child: child,
              ));

        case Transition.size:
          return SizeTransitions().buildTransitions(
              context,
              route.curve!,
              route.alignment,
              animation,
              secondaryAnimation,
              GetBackGestureDetector<T>(
                popGestureEnable: () =>
                    _isPopGestureEnabled(route, canSwipe(route), context),
                onStartPopGesture: () {
                  assert(_isPopGestureEnabled(route, canSwipe(route), context));
                  return _startPopGesture(route);
                },
                limitedSwipe: limitedSwipe,
                gestureWidth:
                    route.gestureWidth?.call(context) ?? _kBackGestureWidth,
                initialOffset: initialOffset,
                child: child,
              ));

        case Transition.fade:
          return const FadeUpwardsPageTransitionsBuilder().buildTransitions(
              route,
              context,
              animation,
              secondaryAnimation,
              GetBackGestureDetector<T>(
                popGestureEnable: () =>
                    _isPopGestureEnabled(route, canSwipe(route), context),
                onStartPopGesture: () {
                  assert(_isPopGestureEnabled(route, canSwipe(route), context));
                  return _startPopGesture(route);
                },
                limitedSwipe: limitedSwipe,
                gestureWidth:
                    route.gestureWidth?.call(context) ?? _kBackGestureWidth,
                initialOffset: initialOffset,
                child: child,
              ));

        case Transition.topLevel:
          return const ZoomPageTransitionsBuilder().buildTransitions(
              route,
              context,
              animation,
              secondaryAnimation,
              GetBackGestureDetector<T>(
                popGestureEnable: () =>
                    _isPopGestureEnabled(route, canSwipe(route), context),
                onStartPopGesture: () {
                  assert(_isPopGestureEnabled(route, canSwipe(route), context));
                  return _startPopGesture(route);
                },
                limitedSwipe: limitedSwipe,
                gestureWidth:
                    route.gestureWidth?.call(context) ?? _kBackGestureWidth,
                initialOffset: initialOffset,
                child: child,
              ));

        case Transition.native:
          return const PageTransitionsTheme().buildTransitions(
              route,
              context,
              iosAnimation,
              secondaryAnimation,
              GetBackGestureDetector<T>(
                popGestureEnable: () =>
                    _isPopGestureEnabled(route, canSwipe(route), context),
                onStartPopGesture: () {
                  assert(_isPopGestureEnabled(route, canSwipe(route), context));
                  return _startPopGesture(route);
                },
                limitedSwipe: limitedSwipe,
                gestureWidth:
                    route.gestureWidth?.call(context) ?? _kBackGestureWidth,
                initialOffset: initialOffset,
                child: child,
              ));

        case Transition.circularReveal:
          return CircularRevealTransition().buildTransitions(
              context,
              route.curve,
              route.alignment,
              animation,
              secondaryAnimation,
              GetBackGestureDetector<T>(
                popGestureEnable: () =>
                    _isPopGestureEnabled(route, canSwipe(route), context),
                onStartPopGesture: () {
                  assert(_isPopGestureEnabled(route, canSwipe(route), context));
                  return _startPopGesture(route);
                },
                limitedSwipe: limitedSwipe,
                gestureWidth:
                    route.gestureWidth?.call(context) ?? _kBackGestureWidth,
                initialOffset: initialOffset,
                child: child,
              ));

        default:
          final customTransition = GetRoot.of(context).config.customTransition;

          if (customTransition != null) {
            return customTransition.buildTransition(context, route.curve,
                route.alignment, animation, secondaryAnimation, child);
          }

          PageTransitionsTheme pageTransitionsTheme =
              Theme.of(context).pageTransitionsTheme;

          return pageTransitionsTheme.buildTransitions(
              route,
              context,
              iosAnimation,
              secondaryAnimation,
              GetBackGestureDetector<T>(
                popGestureEnable: () =>
                    _isPopGestureEnabled(route, canSwipe(route), context),
                onStartPopGesture: () {
                  assert(
                    _isPopGestureEnabled(route, canSwipe(route), context),
                  );
                  return _startPopGesture(route);
                },
                limitedSwipe: limitedSwipe,
                gestureWidth:
                    route.gestureWidth?.call(context) ?? _kBackGestureWidth,
                initialOffset: initialOffset,
                child: child,
              ));
      }
    }
  }

  // Called by GetBackGestureDetector when a pop ("back") drag start
  // gesture is detected. The returned controller handles all of the subsequent
  // drag events.
  /// True if an iOS-style back swipe pop gesture is currently
  /// underway for [route].
  ///
  /// This just check the route's [NavigatorState.userGestureInProgress].
  ///
  /// See also:
  ///
  ///  * [popGestureEnabled], which returns true if a user-triggered pop gesture
  ///    would be allowed.
  static bool isPopGestureInProgress(BuildContext context) {
    final route = ModalRoute.of(context)!;
    return route.navigator!.userGestureInProgress;
  }

  static bool _isPopGestureEnabled<T>(
      PageRoute<T> route, bool canSwipe, BuildContext context) {
    // If there's nothing to go back to, then obviously we don't support
    // the back gesture.
    if (route.isFirst) return false;
    // If the route wouldn't actually pop if we popped it, then the gesture
    // would be really confusing (or would skip internal routes),
    // so disallow it.
    if (route.willHandlePopInternally) return false;
    // support [PopScope]
    if (route.popDisposition == RoutePopDisposition.doNotPop) return false;
    // Fullscreen dialogs aren't dismissible by back swipe.
    if (route.fullscreenDialog) return false;
    // If we're in an animation already, we cannot be manually swiped.
    if (route.animation!.status != AnimationStatus.completed) return false;
    // If we're being popped into, we also cannot be swiped until the pop above
    // it completes. This translates to our secondary animation being
    // dismissed.
    if (route.secondaryAnimation!.status != AnimationStatus.dismissed) {
      return false;
    }
    // If we're in a gesture already, we cannot start another.
    if (GetPageRouteTransitionMixin.isPopGestureInProgress(context)) {
      return false;
    }

    // Don't perfome swipe if canSwipe be false
    if (!canSwipe) return false;

    // Looks like a back gesture would be welcome!
    return true;
  }

  static GetBackGestureController<T> _startPopGesture<T>(
    PageRoute<T> route,
  ) {
    return GetBackGestureController<T>(
      navigator: route.navigator!,
      controller: route.controller!, // protected access
    );
  }
}

class _DirectionalityDragGestureRecognizer
    extends HorizontalDragGestureRecognizer {
  final ValueGetter<bool> popGestureEnable;
  final ValueGetter<bool> hasbackGestureController;
  final bool isRTL;
  final bool isLTR;

  _DirectionalityDragGestureRecognizer({
    required this.isRTL,
    required this.isLTR,
    required this.popGestureEnable,
    required this.hasbackGestureController,
    super.debugOwner,
  });

  @override
  void handleEvent(PointerEvent event) {
    final dx = event.delta.dx;
    if (hasbackGestureController() ||
        popGestureEnable() && (isRTL && dx < 0 || isLTR && dx > 0 || dx == 0)) {
      super.handleEvent(event);
    } else {
      stopTrackingPointer(event.pointer);
    }
  }
}


--- File Index 23: lib/get_navigation/src/routes/new_path_route.dart ---
import 'dart:async';

import 'package:flutter/widgets.dart';

import 'get_route.dart';

class RouteMatcher {
  final RouteNode _root = RouteNode('/', '/');

  RouteNode addRoute(String path) {
    final segments = _parsePath(path);
    var currentNode = _root;

    for (final segment in segments) {
      final existingChild = currentNode.findChild(segment);
      if (existingChild != null) {
        currentNode = existingChild;
      } else {
        final newChild = RouteNode(segment, path);
        currentNode.addChild(newChild);
        currentNode = newChild;
      }
    }
    return currentNode;
  }

  void removeRoute(String path) {
    final segments = _parsePath(path);
    var currentNode = _root;
    RouteNode? nodeToDelete;

    // Traverse the tree to find the node to delete
    for (final segment in segments) {
      final child = currentNode.findChild(segment);
      if (child == null) {
        return; // Node not found, nothing to delete
      }
      if (child.nodeSegments.length == segments.length) {
        nodeToDelete = child;
        break;
      }
      currentNode = child;
    }

    if (nodeToDelete == null) {
      return; // Node not found, nothing to delete
    }

    final parent = nodeToDelete.parent!;
    parent.nodeSegments.remove(nodeToDelete);
  }

  RouteNode? _findChild(RouteNode currentNode, String segment) {
    return currentNode.nodeSegments
        .firstWhereOrNull((node) => node.matches(segment));
  }

  MatchResult? matchRoute(String path) {
    final uri = Uri.parse(path);
    final segments = _parsePath(uri.path);
    var currentNode = _root;
    final parameters = <String, String>{};
    final urlParameters = uri.queryParameters;

    for (final segment in segments) {
      if (segment.isEmpty) continue;
      final child = _findChild(currentNode, segment);
      if (child == null) {
        return null;
      } else {
        if (child.path.startsWith(':')) {
          parameters[child.path.substring(1)] = segment;
        }

        if (child.nodeSegments.length == segments.length) {
          return null;
        }

        currentNode = child;
      }
    }

    return MatchResult(
      currentNode,
      parameters,
      path,
      urlParameters: urlParameters,
    );
  }

  List<String> _parsePath(String path) {
    return path.split('/').where((segment) => segment.isNotEmpty).toList();
  }
}

class RouteTreeResult {
  final GetPage? route;
  final MatchResult matchResult;

  RouteTreeResult({
    required this.route,
    required this.matchResult,
  });

  @override
  String toString() {
    return 'RouteTreeResult(route: $route, matchResult: $matchResult)';
  }

  RouteTreeResult configure(String page, Object? arguments) {
    return copyWith(
        route: route?.copyWith(
      key: ValueKey(page),
      settings: RouteSettings(name: page, arguments: arguments),
      completer: Completer(),
      arguments: arguments,
    ));
  }

  RouteTreeResult copyWith({
    GetPage? route,
    MatchResult? matchResult,
  }) {
    return RouteTreeResult(
      route: route ?? this.route,
      matchResult: matchResult ?? this.matchResult,
    );
  }
}

class RouteTree {
  static final instance = RouteTree();
  final Map<String, GetPage> tree = {};
  final RouteMatcher matcher = RouteMatcher();

  void addRoute(GetPage route) {
    matcher.addRoute(route.name);
    tree[route.name] = route;
    handleChild(route);
  }

  void addRoutes(List<GetPage> routes) {
    for (var route in routes) {
      addRoute(route);
    }
  }

  void handleChild(GetPage route) {
    final children = route.children;
    for (var child in children) {
      final middlewares = List.of(route.middlewares);
      final bindings = List.of(route.bindings);
      middlewares.addAll(child.middlewares);
      bindings.addAll(child.bindings);
      child = child.copyWith(middlewares: middlewares, bindings: bindings);
      if (child.inheritParentPath) {
        child = child.copyWith(
            name: ('${route.path}/${child.path}').replaceAll(r'//', '/'));
      }
      addRoute(child);
    }
  }

  void removeRoute(GetPage route) {
    matcher.removeRoute(route.name);
    tree.remove(route.name);
  }

  void removeRoutes(List<GetPage> routes) {
    for (var route in routes) {
      removeRoute(route);
    }
  }

  RouteTreeResult? matchRoute(String path) {
    final matchResult = matcher.matchRoute(path);
    if (matchResult != null) {
      final route = tree[matchResult.node.originalPath];
      return RouteTreeResult(
        route: route,
        matchResult: matchResult,
      );
    }
    return null;
  }
}

/// A class representing the result of a route matching operation.
class MatchResult {
  /// The route found that matches the result
  final RouteNode node;

  /// The current path of match, eg: adding 'user/:id' the match result for 'user/123' will be: 'user/123'
  final String currentPath;

  /// Route parameters eg: adding 'user/:id' the match result for 'user/123' will be: {id: 123}
  final Map<String, String> parameters;

  /// Route url parameters eg: adding 'user' the match result for 'user?foo=bar' will be: {foo: bar}
  final Map<String, String> urlParameters;

  MatchResult(this.node, this.parameters, this.currentPath,
      {this.urlParameters = const {}});

  @override
  String toString() =>
      'MatchResult(node: $node, currentPath: $currentPath, parameters: $parameters, urlParameters: $urlParameters)';
}

// A class representing a node in a routing tree.
class RouteNode {
  String path;
  String originalPath;
  RouteNode? parent;
  List<RouteNode> nodeSegments = [];

  RouteNode(this.path, this.originalPath, {this.parent});

  bool get isRoot => parent == null;

  String get fullPath {
    if (isRoot) {
      return '/';
    } else {
      final parentPath = parent?.fullPath == '/' ? '' : parent?.fullPath;
      return '$parentPath/$path';
    }
  }

  bool get hasChildren => nodeSegments.isNotEmpty;

  void addChild(RouteNode child) {
    nodeSegments.add(child);
    child.parent = this;
  }

  RouteNode? findChild(String name) {
    return nodeSegments.firstWhereOrNull((node) => node.path == name);
  }

  bool matches(String name) {
    return name == path || path == '*' || path.startsWith(':');
  }

  @override
  String toString() =>
      'RouteNode(name: $path, nodeSegments: $nodeSegments, fullPath: $fullPath )';
}

extension Foo<T> on Iterable<T> {
  T? firstWhereOrNull(bool Function(T element) test) {
    for (var element in this) {
      if (test(element)) return element;
    }
    return null;
  }
}


--- File Index 24: lib/get_navigation/src/routes/transitions_type.dart ---
import 'package:flutter/widgets.dart';

import 'default_route.dart';

enum Transition {
  fade,
  fadeIn,
  rightToLeft,
  leftToRight,
  upToDown,
  downToUp,
  rightToLeftWithFade,
  leftToRightWithFade,
  zoom,
  topLevel,
  noTransition,
  cupertino,
  cupertinoDialog,
  size,
  circularReveal,
  native,
}

typedef GetPageBuilder = Widget Function();
typedef GetRouteAwarePageBuilder<T> = Widget Function([GetPageRoute<T>? route]);


--- File Index 25: lib/get_navigation/src/routes/custom_transition.dart ---
import 'package:flutter/widgets.dart';

// ignore: one_member_abstracts
abstract class CustomTransition {
  Widget buildTransition(
    BuildContext context,
    Curve? curve,
    Alignment? alignment,
    Animation<double> animation,
    Animation<double> secondaryAnimation,
    Widget child,
  );
}


--- File Index 26: lib/get_navigation/src/routes/get_route.dart ---
// ignore_for_file: overridden_fields

import 'dart:async';

import 'package:flutter/cupertino.dart';
import 'package:flutter/foundation.dart';
import 'package:flutter/material.dart';

import '../../../get_instance/src/bindings_interface.dart';
import '../../../get_state_manager/src/simple/get_state.dart';
import '../../get_navigation.dart';

class GetPage<T> extends Page<T> {
  final GetPageBuilder page;
  final bool? popGesture;
  final Map<String, String>? parameters;
  final String? title;
  final Transition? transition;
  final Curve curve;
  final bool? participatesInRootNavigator;
  final Alignment? alignment;
  final bool maintainState;
  final bool opaque;
  final double Function(BuildContext context)? gestureWidth;
  final BindingsInterface? binding;
  final List<BindingsInterface> bindings;
  final List<Bind> binds;
  final CustomTransition? customTransition;
  final Duration? transitionDuration;
  final Duration? reverseTransitionDuration;
  final bool fullscreenDialog;
  final bool preventDuplicates;
  final Completer<T?>? completer;
  // @override
  // final LocalKey? key;

  // @override
  // RouteSettings get settings => this;

  @override
  final Object? arguments;

  @override
  final String name;

  final bool inheritParentPath;

  final List<GetPage> children;
  final List<GetMiddleware> middlewares;
  final PathDecoded path;
  final GetPage? unknownRoute;
  final bool showCupertinoParallax;

  final PreventDuplicateHandlingMode preventDuplicateHandlingMode;

  static void _defaultPopInvokedHandler(bool didPop, Object? result) {}

  GetPage({
    required this.name,
    required this.page,
    this.title,
    this.participatesInRootNavigator,
    this.gestureWidth,
    // RouteSettings settings,
    this.maintainState = true,
    this.curve = Curves.linear,
    this.alignment,
    this.parameters,
    this.opaque = true,
    this.transitionDuration,
    this.reverseTransitionDuration,
    this.popGesture,
    this.binding,
    this.bindings = const [],
    this.binds = const [],
    this.transition,
    this.customTransition,
    this.fullscreenDialog = false,
    this.children = const <GetPage>[],
    this.middlewares = const [],
    this.unknownRoute,
    this.arguments,
    this.showCupertinoParallax = true,
    this.preventDuplicates = true,
    this.preventDuplicateHandlingMode =
        PreventDuplicateHandlingMode.reorderRoutes,
    this.completer,
    this.inheritParentPath = true,
    LocalKey? key,
    super.canPop,
    super.onPopInvoked = _defaultPopInvokedHandler,
    super.restorationId,
  })  : path = _nameToRegex(name),
        assert(name.startsWith('/'),
            'It is necessary to start route name [$name] with a slash: /$name'),
        super(
          key: key ?? ValueKey(name),
          name: name,
          // arguments: Get.arguments,
        );
  // settings = RouteSettings(name: name, arguments: Get.arguments);

  GetPage<T> copyWith({
    LocalKey? key,
    String? name,
    GetPageBuilder? page,
    bool? popGesture,
    Map<String, String>? parameters,
    String? title,
    Transition? transition,
    Curve? curve,
    Alignment? alignment,
    bool? maintainState,
    bool? opaque,
    List<BindingsInterface>? bindings,
    BindingsInterface? binding,
    List<Bind>? binds,
    CustomTransition? customTransition,
    Duration? transitionDuration,
    Duration? reverseTransitionDuration,
    bool? fullscreenDialog,
    RouteSettings? settings,
    List<GetPage<T>>? children,
    GetPage? unknownRoute,
    List<GetMiddleware>? middlewares,
    bool? preventDuplicates,
    final double Function(BuildContext context)? gestureWidth,
    bool? participatesInRootNavigator,
    Object? arguments,
    bool? showCupertinoParallax,
    Completer<T?>? completer,
    bool? inheritParentPath,
    bool? canPop,
    PopInvokedWithResultCallback<T>? onPopInvoked,
    String? restorationId,
  }) {
    return GetPage(
      key: key ?? this.key,
      participatesInRootNavigator:
          participatesInRootNavigator ?? this.participatesInRootNavigator,
      preventDuplicates: preventDuplicates ?? this.preventDuplicates,
      name: name ?? this.name,
      page: page ?? this.page,
      popGesture: popGesture ?? this.popGesture,
      parameters: parameters ?? this.parameters,
      title: title ?? this.title,
      transition: transition ?? this.transition,
      curve: curve ?? this.curve,
      alignment: alignment ?? this.alignment,
      maintainState: maintainState ?? this.maintainState,
      opaque: opaque ?? this.opaque,
      bindings: bindings ?? this.bindings,
      binds: binds ?? this.binds,
      binding: binding ?? this.binding,
      customTransition: customTransition ?? this.customTransition,
      transitionDuration: transitionDuration ?? this.transitionDuration,
      reverseTransitionDuration:
          reverseTransitionDuration ?? this.reverseTransitionDuration,
      fullscreenDialog: fullscreenDialog ?? this.fullscreenDialog,
      children: children ?? this.children,
      unknownRoute: unknownRoute ?? this.unknownRoute,
      middlewares: middlewares ?? this.middlewares,
      gestureWidth: gestureWidth ?? this.gestureWidth,
      arguments: arguments ?? this.arguments,
      showCupertinoParallax:
          showCupertinoParallax ?? this.showCupertinoParallax,
      completer: completer ?? this.completer,
      inheritParentPath: inheritParentPath ?? this.inheritParentPath,
      canPop: canPop ?? this.canPop,
      onPopInvoked: onPopInvoked ?? this.onPopInvoked,
      restorationId: restorationId ?? restorationId,
    );
  }

  @override
  Route<T> createRoute(BuildContext context) {
    // return GetPageRoute<T>(settings: this, page: page);
    final page = PageRedirect(
      route: this,
      settings: this,
      unknownRoute: unknownRoute,
    ).getPageToRoute<T>(this, unknownRoute, context);

    return page;
  }

  static PathDecoded _nameToRegex(String path) {
    var keys = <String?>[];

    String recursiveReplace(Match pattern) {
      var buffer = StringBuffer('(?:');

      if (pattern[1] != null) buffer.write('.');
      buffer.write('([\\w%+-._~!\$&\'()*,;=:@]+))');
      if (pattern[3] != null) buffer.write('?');

      keys.add(pattern[2]);
      return "$buffer";
    }

    var stringPath = '$path/?'
        .replaceAllMapped(RegExp(r'(\.)?:(\w+)(\?)?'), recursiveReplace)
        .replaceAll('//', '/');

    return PathDecoded(RegExp('^$stringPath\$'), keys);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    return other is GetPage<T> && other.key == key;
  }

  @override
  String toString() =>
      '${objectRuntimeType(this, 'Page')}("$name", $key, $arguments)';

  @override
  int get hashCode {
    return key.hashCode;
  }
}

@immutable
class PathDecoded {
  final RegExp regex;
  final List<String?> keys;
  const PathDecoded(this.regex, this.keys);

  @override
  int get hashCode => regex.hashCode;

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;

    return other is PathDecoded &&
        other.regex == regex; // && listEquals(other.keys, keys);
  }
}


--- File Index 27: lib/get_navigation/src/routes/router_outlet.dart ---
import 'package:flutter/material.dart';

import '../../../get.dart';

class RouterOutlet<TDelegate extends RouterDelegate<T>, T extends Object>
    extends StatefulWidget {
  final TDelegate routerDelegate;
  final Widget Function(BuildContext context) builder;

  RouterOutlet.builder({
    super.key,
    TDelegate? delegate,
    required this.builder,
  }) : routerDelegate = delegate ?? Get.delegate<TDelegate, T>()!;

  RouterOutlet({
    Key? key,
    TDelegate? delegate,
    required Iterable<GetPage> Function(T currentNavStack) pickPages,
    required Widget Function(
      BuildContext context,
      TDelegate,
      Iterable<GetPage>? page,
    ) pageBuilder,
  }) : this.builder(
            builder: (context) {
              final currentConfig = context.delegate.currentConfiguration as T?;
              final rDelegate = context.delegate as TDelegate;
              var picked =
                  currentConfig == null ? null : pickPages(currentConfig);
              if (picked?.isEmpty ?? true) {
                picked = null;
              }
              return pageBuilder(context, rDelegate, picked);
            },
            delegate: delegate,
            key: key);
  @override
  RouterOutletState<TDelegate, T> createState() =>
      RouterOutletState<TDelegate, T>();
}

class RouterOutletState<TDelegate extends RouterDelegate<T>, T extends Object>
    extends State<RouterOutlet<TDelegate, T>> {
  RouterDelegate? delegate;
  late ChildBackButtonDispatcher _backButtonDispatcher;

  void _listener() {
    setState(() {});
  }

  VoidCallback? disposer;

  @override
  void didChangeDependencies() {
    super.didChangeDependencies();
    disposer?.call();
    final router = Router.of(context);
    delegate ??= router.routerDelegate;
    delegate?.addListener(_listener);
    disposer = () => delegate?.removeListener(_listener);

    _backButtonDispatcher =
        router.backButtonDispatcher!.createChildBackButtonDispatcher();
  }

  @override
  void dispose() {
    super.dispose();
    disposer?.call();
  }

  @override
  Widget build(BuildContext context) {
    _backButtonDispatcher.takePriority();
    return widget.builder(context);
  }
}

class GetRouterOutlet extends RouterOutlet<GetDelegate, RouteDecoder> {
  GetRouterOutlet({
    Key? key,
    String? anchorRoute,
    required String initialRoute,
    Iterable<GetPage> Function(Iterable<GetPage> afterAnchor)? filterPages,
    GetDelegate? delegate,
    String? restorationScopeId,
  }) : this.pickPages(
          restorationScopeId: restorationScopeId,
          pickPages: (config) {
            Iterable<GetPage<dynamic>> ret;
            if (anchorRoute == null) {
              // jump the ancestor path
              final length = Uri.parse(initialRoute).pathSegments.length;

              return config.currentTreeBranch
                  .skip(length)
                  .take(length)
                  .toList();
            }
            ret = config.currentTreeBranch.pickAfterRoute(anchorRoute);
            if (filterPages != null) {
              ret = filterPages(ret);
            }
            return ret;
          },
          key: key,
          emptyPage: (delegate) =>
              delegate.matchRoute(initialRoute).route ?? delegate.notFoundRoute,
          navigatorKey: Get.nestedKey(anchorRoute)?.navigatorKey,
          delegate: delegate,
        );
  GetRouterOutlet.pickPages({
    super.key,
    Widget Function(GetDelegate delegate)? emptyWidget,
    GetPage Function(GetDelegate delegate)? emptyPage,
    required super.pickPages,
    bool Function(Route<dynamic>, dynamic)? onPopPage,
    String? restorationScopeId,
    GlobalKey<NavigatorState>? navigatorKey,
    GetDelegate? delegate,
  }) : super(
          pageBuilder: (context, rDelegate, pages) {
            final pageRes = <GetPage?>[
              ...?pages,
              if (pages == null || pages.isEmpty) emptyPage?.call(rDelegate),
            ].whereType<GetPage>();

            if (pageRes.isNotEmpty) {
              return InheritedNavigator(
                navigatorKey: navigatorKey ??
                    Get.rootController.rootDelegate.navigatorKey,
                child: GetNavigator(
                  restorationScopeId: restorationScopeId,
                  onPopPage: onPopPage ??
                      (route, result) {
                        final didPop = route.didPop(result);
                        if (!didPop) {
                          return false;
                        }
                        return true;
                      },
                  pages: pageRes.toList(),
                  key: navigatorKey,
                ),
              );
            }
            return (emptyWidget?.call(rDelegate) ?? const SizedBox.shrink());
          },
          delegate: delegate ?? Get.rootController.rootDelegate,
        );

  GetRouterOutlet.builder({
    super.key,
    required super.builder,
    String? route,
    GetDelegate? routerDelegate,
  }) : super.builder(
          delegate: routerDelegate ??
              (route != null
                  ? Get.nestedKey(route)
                  : Get.rootController.rootDelegate),
        );
}

class InheritedNavigator extends InheritedWidget {
  const InheritedNavigator({
    super.key,
    required super.child,
    required this.navigatorKey,
  });
  final GlobalKey<NavigatorState> navigatorKey;

  static InheritedNavigator? of(BuildContext context) {
    return context.dependOnInheritedWidgetOfExactType<InheritedNavigator>();
  }

  @override
  bool updateShouldNotify(InheritedNavigator oldWidget) {
    return true;
  }
}

extension NavKeyExt on BuildContext {
  GlobalKey<NavigatorState>? get parentNavigatorKey {
    return InheritedNavigator.of(this)?.navigatorKey;
  }
}

extension PagesListExt on List<GetPage> {
  /// Returns the route and all following routes after the given route.
  Iterable<GetPage> pickFromRoute(String route) {
    return skipWhile((value) => value.name != route);
  }

  /// Returns the routes after the given route.
  Iterable<GetPage> pickAfterRoute(String route) {
    // If the provided route is root, we take the first route after root.
    if (route == '/') {
      return pickFromRoute(route).skip(1).take(1);
    }
    // Otherwise, we skip the route and take all routes after it.
    return pickFromRoute(route).skip(1);
  }
}

typedef NavigatorItemBuilderBuilder = Widget Function(
    BuildContext context, List<String> routes, int index);

class IndexedRouteBuilder<T> extends StatelessWidget {
  const IndexedRouteBuilder({
    super.key,
    required this.builder,
    required this.routes,
  });
  final List<String> routes;
  final NavigatorItemBuilderBuilder builder;

// Method to get the current index based on the route
  int _getCurrentIndex(String currentLocation) {
    for (int i = 0; i < routes.length; i++) {
      if (currentLocation.startsWith(routes[i])) {
        return i;
      }
    }
    return 0; // default index
  }

  @override
  Widget build(BuildContext context) {
    final location = context.location;
    final index = _getCurrentIndex(location);

    return builder(context, routes, index);
  }
}

mixin RouterListenerMixin<T extends StatefulWidget> on State<T> {
  RouterDelegate? delegate;

  void _listener() {
    setState(() {});
  }

  VoidCallback? disposer;

  @override
  void didChangeDependencies() {
    super.didChangeDependencies();
    disposer?.call();
    final router = Router.of(context);
    delegate ??= router.routerDelegate as GetDelegate;

    delegate?.addListener(_listener);
    disposer = () => delegate?.removeListener(_listener);
  }

  @override
  void dispose() {
    super.dispose();
    disposer?.call();
  }
}

class RouterListenerInherited extends InheritedWidget {
  const RouterListenerInherited({
    super.key,
    required super.child,
  });

  static RouterListenerInherited? of(BuildContext context) {
    return context
        .dependOnInheritedWidgetOfExactType<RouterListenerInherited>();
  }

  @override
  bool updateShouldNotify(covariant InheritedWidget oldWidget) {
    return true;
  }
}

class RouterListener extends StatefulWidget {
  const RouterListener({
    super.key,
    required this.builder,
  });
  final WidgetBuilder builder;

  @override
  State<RouterListener> createState() => RouteListenerState();
}

class RouteListenerState extends State<RouterListener>
    with RouterListenerMixin {
  @override
  Widget build(BuildContext context) {
    return RouterListenerInherited(child: Builder(builder: widget.builder));
  }
}

class BackButtonCallback extends StatefulWidget {
  const BackButtonCallback({super.key, required this.builder});
  final WidgetBuilder builder;

  @override
  State<BackButtonCallback> createState() => RouterListenerState();
}

class RouterListenerState extends State<BackButtonCallback>
    with RouterListenerMixin {
  late ChildBackButtonDispatcher backButtonDispatcher;

  @override
  void didChangeDependencies() {
    super.didChangeDependencies();
    final router = Router.of(context);
    backButtonDispatcher =
        router.backButtonDispatcher!.createChildBackButtonDispatcher();
  }

  @override
  Widget build(BuildContext context) {
    backButtonDispatcher.takePriority();
    return widget.builder(context);
  }
}


--- File Index 28: lib/get_navigation/src/routes/get_navigation_interface.dart ---
import 'package:flutter/widgets.dart';

import '../../../get_instance/src/bindings_interface.dart';
import '../routes/get_route.dart';
import '../routes/transitions_type.dart';

/// Enables the user to customize the intended pop behavior
///
/// Goes to either the previous _activePages entry or the previous page entry
///
/// e.g. if the user navigates to these pages
/// 1) /home
/// 2) /home/products/1234
///
/// when popping on [History] mode, it will emulate a browser back button.
///
/// so the new _activePages stack will be:
/// 1) /home
///
/// when popping on [Page] mode, it will only remove the last part of the route
/// so the new _activePages stack will be:
/// 1) /home
/// 2) /home/products
///
/// another pop will change the _activePages stack to:
/// 1) /home
enum PopMode {
  history,
  page,
}

/// Enables the user to customize the behavior when pushing multiple routes that
/// shouldn't be duplicates
enum PreventDuplicateHandlingMode {
  /// Removes the _activePages entries until it reaches the old route
  popUntilOriginalRoute,

  /// Simply don't push the new route
  doNothing,

  /// Recommended - Moves the old route entry to the front
  ///
  /// With this mode, you guarantee there will be only one
  /// route entry for each location
  reorderRoutes,

  recreate,
}

mixin IGetNavigation {
  Future<T?> to<T>(
    Widget Function() page, {
    bool? opaque,
    Transition? transition,
    Curve? curve,
    Duration? duration,
    String? id,
    String? routeName,
    bool fullscreenDialog = false,
    dynamic arguments,
    List<BindingsInterface> bindings = const [],
    bool preventDuplicates = true,
    bool? popGesture,
    bool showCupertinoParallax = true,
    double Function(BuildContext context)? gestureWidth,
  });

  Future<void> popModeUntil(
    String fullRoute, {
    PopMode popMode = PopMode.history,
  });

  Future<T?> off<T>(
    Widget Function() page, {
    bool? opaque,
    Transition? transition,
    Curve? curve,
    Duration? duration,
    String? id,
    String? routeName,
    bool fullscreenDialog = false,
    dynamic arguments,
    List<BindingsInterface> bindings = const [],
    bool preventDuplicates = true,
    bool? popGesture,
    bool showCupertinoParallax = true,
    double Function(BuildContext context)? gestureWidth,
  });

  Future<T?>? offAll<T>(
    Widget Function() page, {
    bool Function(GetPage route)? predicate,
    bool opaque = true,
    bool? popGesture,
    String? id,
    String? routeName,
    dynamic arguments,
    List<BindingsInterface> bindings = const [],
    bool fullscreenDialog = false,
    Transition? transition,
    Curve? curve,
    Duration? duration,
    bool showCupertinoParallax = true,
    double Function(BuildContext context)? gestureWidth,
  });

  Future<T?> toNamed<T>(
    String page, {
    dynamic arguments,
    String? id,
    bool preventDuplicates = true,
    Map<String, String>? parameters,
  });

  Future<T?> offNamed<T>(
    String page, {
    dynamic arguments,
    String? id,
    Map<String, String>? parameters,
  });

  Future<T?>? offAllNamed<T>(
    String newRouteName, {
    // bool Function(GetPage route)? predicate,
    dynamic arguments,
    String? id,
    Map<String, String>? parameters,
  });

  Future<T?>? offNamedUntil<T>(
    String page, {
    bool Function(GetPage route)? predicate,
    dynamic arguments,
    String? id,
    Map<String, String>? parameters,
  });

  Future<T?> toNamedAndOffUntil<T>(
    String page,
    bool Function(GetPage) predicate, [
    Object? data,
  ]);

  Future<T?> offUntil<T>(
    Widget Function() page,
    bool Function(GetPage) predicate, [
    Object? arguments,
  ]);

  void removeRoute<T>(String name);

  void back<T>([T? result]);

  Future<R?> backAndtoNamed<T, R>(String page, {T? result, Object? arguments});

  void backUntil(bool Function(GetPage) predicate);

  void goToUnknownPage([bool clearPages = true]);
}


--- File Index 29: lib/get_navigation/src/routes/default_route.dart ---
import 'package:flutter/cupertino.dart';

import '../../../get.dart';
import '../router_report.dart';

@optionalTypeArgs
mixin RouteReportMixin<T extends StatefulWidget> on State<T> {
  @override
  void initState() {
    super.initState();
    RouterReportManager.instance.reportCurrentRoute(this);
  }

  @override
  void dispose() {
    super.dispose();
    RouterReportManager.instance.reportRouteDispose(this);
  }
}

mixin PageRouteReportMixin<T> on Route<T> {
  @override
  void install() {
    super.install();
    RouterReportManager.instance.reportCurrentRoute(this);
  }

  @override
  void dispose() {
    super.dispose();
    RouterReportManager.instance.reportRouteDispose(this);
  }
}

class GetPageRoute<T> extends PageRoute<T>
    with GetPageRouteTransitionMixin<T>, PageRouteReportMixin {
  /// Creates a page route for use in an iOS designed app.
  ///
  /// The [builder], [maintainState], and [fullscreenDialog] arguments must not
  /// be null.
  GetPageRoute({
    super.settings,
    this.transitionDuration = const Duration(milliseconds: 300),
    this.reverseTransitionDuration = const Duration(milliseconds: 300),
    this.opaque = true,
    this.parameter,
    this.gestureWidth,
    this.curve,
    this.alignment,
    this.transition,
    this.popGesture,
    this.customTransition,
    this.barrierDismissible = false,
    this.barrierColor,
    BindingsInterface? binding,
    List<BindingsInterface> bindings = const [],
    this.binds,
    this.routeName,
    this.page,
    this.title,
    this.showCupertinoParallax = true,
    this.barrierLabel,
    this.maintainState = true,
    super.fullscreenDialog,
    this.middlewares,
  })  : bindings = (binding == null) ? bindings : [...bindings, binding],
        _middlewareRunner = MiddlewareRunner(middlewares);

  @override
  final Duration transitionDuration;
  @override
  final Duration reverseTransitionDuration;

  final GetPageBuilder? page;
  final String? routeName;
  //final String reference;
  final CustomTransition? customTransition;
  final List<BindingsInterface> bindings;
  final Map<String, String>? parameter;
  final List<Bind>? binds;

  @override
  final bool showCupertinoParallax;

  @override
  final bool opaque;
  final bool? popGesture;

  @override
  final bool barrierDismissible;
  final Transition? transition;
  final Curve? curve;
  final Alignment? alignment;
  final List<GetMiddleware>? middlewares;

  @override
  final Color? barrierColor;

  @override
  final String? barrierLabel;

  @override
  final bool maintainState;

  final MiddlewareRunner _middlewareRunner;

  @override
  void dispose() {
    super.dispose();
    _middlewareRunner.runOnPageDispose();
    _child = null;
  }

  Widget? _child;

  Widget _getChild() {
    if (_child != null) return _child!;

    final localBinds = [if (binds != null) ...binds!];

    final bindingsToBind = _middlewareRunner
        .runOnBindingsStart(bindings.isNotEmpty ? bindings : localBinds);

    final pageToBuild = _middlewareRunner.runOnPageBuildStart(page)!;

    if (bindingsToBind != null && bindingsToBind.isNotEmpty) {
      if (bindingsToBind is List<BindingsInterface>) {
        for (final item in bindingsToBind) {
          final dep = item.dependencies();
          if (dep is List<Bind>) {
            _child = Binds(
              binds: dep,
              child: _middlewareRunner.runOnPageBuilt(pageToBuild()),
            );
          }
        }
      } else if (bindingsToBind is List<Bind>) {
        _child = Binds(
          binds: bindingsToBind,
          child: _middlewareRunner.runOnPageBuilt(pageToBuild()),
        );
      }
    }

    return _child ??= _middlewareRunner.runOnPageBuilt(pageToBuild());
  }

  @override
  Widget buildContent(BuildContext context) {
    return _getChild();
  }

  @override
  final String? title;

  @override
  String get debugLabel => '${super.debugLabel}(${settings.name})';

  @override
  final double Function(BuildContext context)? gestureWidth;
}


--- File Index 30: lib/get_navigation/src/routes/url_strategy/url_strategy.dart ---
import 'impl/stub_url.dart'
    if (dart.library.js_interop) 'impl/web_url.dart'
    if (dart.library.io) 'impl/io_url.dart';

void setUrlStrategy() {
  removeHash();
}

void removeLastHistory(String? url) {
  removeLastHistory(url);
}


--- File Index 31: lib/get_navigation/src/routes/url_strategy/impl/web_url.dart ---
import 'package:flutter_web_plugins/flutter_web_plugins.dart';

void removeHash() {
  setUrlStrategy(PathUrlStrategy());
}


--- File Index 32: lib/get_navigation/src/routes/url_strategy/impl/io_url.dart ---
void removeHash() {}


--- File Index 33: lib/get_navigation/src/routes/url_strategy/impl/stub_url.dart ---
void removeHash() {
  throw UnimplementedError();
}


--- File Index 34: lib/get_navigation/src/routes/observers/route_observer.dart ---
import 'package:flutter/widgets.dart';

import '../../../../get_core/get_core.dart';
import '../../../../instance_manager.dart';
import '../../../get_navigation.dart';
import '../../dialog/dialog_route.dart';
import '../../router_report.dart';

/// Extracts the name of a route based on it's instance type
/// or null if not possible.
String? _extractRouteName(Route? route) {
  if (route?.settings.name != null) {
    return route!.settings.name;
  }

  if (route is GetPageRoute) {
    return route.routeName;
  }

  if (route is GetDialogRoute) {
    return 'DIALOG ${route.hashCode}';
  }

  if (route is GetModalBottomSheetRoute) {
    return 'BOTTOMSHEET ${route.hashCode}';
  }

  return null;
}

class GetObserver extends NavigatorObserver {
  final Function(Routing?)? routing;

  final Routing? _routeSend;

  GetObserver([this.routing, this._routeSend]);

  @override
  void didPop(Route route, Route? previousRoute) {
    super.didPop(route, previousRoute);
    final currentRoute = _RouteData.ofRoute(route);
    final newRoute = _RouteData.ofRoute(previousRoute);

    if (currentRoute.isBottomSheet || currentRoute.isDialog) {
      Get.log("CLOSE ${currentRoute.name}");
    } else if (currentRoute.isGetPageRoute) {
      Get.log("CLOSE TO ROUTE ${currentRoute.name}");
    }
    if (previousRoute != null) {
      RouterReportManager.instance.reportCurrentRoute(previousRoute);
    }

    // Here we use a 'inverse didPush set', meaning that we use
    // previous route instead of 'route' because this is
    // a 'inverse push'
    _routeSend?.update((value) {
      // Only PageRoute is allowed to change current value
      if (previousRoute is PageRoute) {
        value.current = _extractRouteName(previousRoute) ?? '';
        value.previous = newRoute.name ?? '';
      } else if (value.previous.isNotEmpty) {
        value.current = value.previous;
      }

      value.args = previousRoute?.settings.arguments;
      value.route = previousRoute;
      value.isBack = true;
      value.removed = '';
      value.isBottomSheet = newRoute.isBottomSheet;
      value.isDialog = newRoute.isDialog;
    });

    routing?.call(_routeSend);
  }

  @override
  void didPush(Route route, Route? previousRoute) {
    super.didPush(route, previousRoute);
    final newRoute = _RouteData.ofRoute(route);

    if (newRoute.isBottomSheet || newRoute.isDialog) {
      Get.log("OPEN ${newRoute.name}");
    } else if (newRoute.isGetPageRoute) {
      Get.log("GOING TO ROUTE ${newRoute.name}");
    }

    RouterReportManager.instance.reportCurrentRoute(route);
    _routeSend?.update((value) {
      if (route is PageRoute) {
        value.current = newRoute.name ?? '';
      }
      final previousRouteName = _extractRouteName(previousRoute);
      if (previousRouteName != null) {
        value.previous = previousRouteName;
      }

      value.args = route.settings.arguments;
      value.route = route;
      value.isBack = false;
      value.removed = '';
      value.isBottomSheet =
          newRoute.isBottomSheet ? true : value.isBottomSheet ?? false;
      value.isDialog = newRoute.isDialog ? true : value.isDialog ?? false;
    });

    if (routing != null) {
      routing!(_routeSend);
    }
  }

  @override
  void didRemove(Route route, Route? previousRoute) {
    super.didRemove(route, previousRoute);
    final routeName = _extractRouteName(route);
    final currentRoute = _RouteData.ofRoute(route);
    final previousRouteName = _extractRouteName(previousRoute);

    Get.log("REMOVING ROUTE $routeName");
    Get.log("PREVIOUS ROUTE $previousRouteName");

    _routeSend?.update((value) {
      value.route = previousRoute;
      value.isBack = false;
      value.removed = routeName ?? '';
      value.previous = previousRouteName ?? '';
      value.isBottomSheet =
          currentRoute.isBottomSheet ? false : value.isBottomSheet;
      value.isDialog = currentRoute.isDialog ? false : value.isDialog;
    });

    if (route is GetPageRoute) {
      RouterReportManager.instance.reportRouteWillDispose(route);
    }
    routing?.call(_routeSend);
  }

  @override
  void didReplace({Route? newRoute, Route? oldRoute}) {
    super.didReplace(newRoute: newRoute, oldRoute: oldRoute);
    final newName = _extractRouteName(newRoute);
    final oldName = _extractRouteName(oldRoute);
    final currentRoute = _RouteData.ofRoute(oldRoute);

    Get.log("REPLACE ROUTE $oldName");
    Get.log("NEW ROUTE $newName");

    if (newRoute != null) {
      RouterReportManager.instance.reportCurrentRoute(newRoute);
    }

    _routeSend?.update((value) {
      // Only PageRoute is allowed to change current value
      if (newRoute is PageRoute) {
        value.current = newName ?? '';
      }

      value.args = newRoute?.settings.arguments;
      value.route = newRoute;
      value.isBack = false;
      value.removed = '';
      value.previous = oldName ?? '';
      value.isBottomSheet =
          currentRoute.isBottomSheet ? false : value.isBottomSheet;
      value.isDialog = currentRoute.isDialog ? false : value.isDialog;
    });
    if (oldRoute is GetPageRoute) {
      RouterReportManager.instance.reportRouteWillDispose(oldRoute);
    }

    routing?.call(_routeSend);
  }
}

//TODO: Use copyWith, and remove mutate variables
class Routing {
  String current;
  String previous;
  dynamic args;
  String removed;
  Route<dynamic>? route;
  bool? isBack;
  bool? isBottomSheet;
  bool? isDialog;

  Routing({
    this.current = '',
    this.previous = '',
    this.args,
    this.removed = '',
    this.route,
    this.isBack,
    this.isBottomSheet,
    this.isDialog,
  });

  void update(void Function(Routing value) fn) {
    fn(this);
  }
}

/// This is basically a util for rules about 'what a route is'
class _RouteData {
  final bool isGetPageRoute;
  final bool isBottomSheet;
  final bool isDialog;
  final String? name;

  const _RouteData({
    required this.name,
    required this.isGetPageRoute,
    required this.isBottomSheet,
    required this.isDialog,
  });

  factory _RouteData.ofRoute(Route? route) {
    return _RouteData(
      name: _extractRouteName(route),
      isGetPageRoute: route is GetPageRoute,
      isDialog: route is GetDialogRoute,
      isBottomSheet: route is GetModalBottomSheetRoute,
    );
  }
}




Analyze the codebase context.
Identify the top 5-10 core most important abstractions to help those new to the codebase.

For each abstraction, provide:
1. A concise `name`.
2. A beginner-friendly `description` explaining what it is with a simple analogy, in around 100 words.
3. A list of relevant `file_indices` (integers) using the format `idx # path/comment`.

List of file indices and paths present in the context:
- 0 # lib/get_navigation/get_navigation.dart
- 1 # lib/get_navigation/src/router_report.dart
- 2 # lib/get_navigation/src/extension_navigation.dart
- 3 # lib/get_navigation/src/snackbar/snackbar_controller.dart
- 4 # lib/get_navigation/src/snackbar/snackbar.dart
- 5 # lib/get_navigation/src/dialog/dialog_route.dart
- 6 # lib/get_navigation/src/bottomsheet/bottomsheet.dart
- 7 # lib/get_navigation/src/root/get_cupertino_app.dart
- 8 # lib/get_navigation/src/root/get_material_app.dart
- 9 # lib/get_navigation/src/root/internacionalization.dart
- 10 # lib/get_navigation/src/root/get_root.dart
- 11 # lib/get_navigation/src/routes/default_transitions.dart
- 12 # lib/get_navigation/src/routes/get_router_delegate.dart
- 13 # lib/get_navigation/src/routes/index.dart
- 14 # lib/get_navigation/src/routes/modules.dart
- 15 # lib/get_navigation/src/routes/circular_reveal_clipper.dart
- 16 # lib/get_navigation/src/routes/route_report.dart
- 17 # lib/get_navigation/src/routes/get_information_parser.dart
- 18 # lib/get_navigation/src/routes/parse_route.dart
- 19 # lib/get_navigation/src/routes/page_settings.dart
- 20 # lib/get_navigation/src/routes/get_navigator.dart
- 21 # lib/get_navigation/src/routes/route_middleware.dart
- 22 # lib/get_navigation/src/routes/get_transition_mixin.dart
- 23 # lib/get_navigation/src/routes/new_path_route.dart
- 24 # lib/get_navigation/src/routes/transitions_type.dart
- 25 # lib/get_navigation/src/routes/custom_transition.dart
- 26 # lib/get_navigation/src/routes/get_route.dart
- 27 # lib/get_navigation/src/routes/router_outlet.dart
- 28 # lib/get_navigation/src/routes/get_navigation_interface.dart
- 29 # lib/get_navigation/src/routes/default_route.dart
- 30 # lib/get_navigation/src/routes/url_strategy/url_strategy.dart
- 31 # lib/get_navigation/src/routes/url_strategy/impl/web_url.dart
- 32 # lib/get_navigation/src/routes/url_strategy/impl/io_url.dart
- 33 # lib/get_navigation/src/routes/url_strategy/impl/stub_url.dart
- 34 # lib/get_navigation/src/routes/observers/route_observer.dart

Format the output as a YAML list of dictionaries:

```yaml
- name: |
    Query Processing
  description: |
    Explains what the abstraction does.
    It's like a central dispatcher routing requests.
  file_indices:
    - 0 # path/to/file1.py
    - 3 # path/to/related.py
- name: |
    Query Optimization
  description: |
    Another core concept, similar to a blueprint for objects.
  file_indices:
    - 5 # path/to/another.js
# ... up to 10 abstractions
```
2025-05-16 11:04:46,397 - INFO - RESPONSE: ```yaml
- name: |
    GetPage & GetRouterDelegate
  description: |
    `GetPage` is like a blueprint for a screen in your app. It defines the screen's name (URL path), what content to show, and any special behaviors like transitions or data bindings.
    `GetRouterDelegate` is the captain of your app's navigation. It takes these `GetPage` blueprints and manages the actual stack of screens, deciding which page is currently visible, how to go to new pages, and how to go back. It's the core engine that powers Flutter's modern Navigator 2.0 system within GetX.
  file_indices:
    - 12 # lib/get_navigation/src/routes/get_router_delegate.dart
    - 26 # lib/get_navigation/src/routes/get_route.dart
    - 17 # lib/get_navigation/src/routes/get_information_parser.dart (Parses route info for the delegate)
    - 18 # lib/get_navigation/src/routes/parse_route.dart (Defines RouteDecoder used by delegate)

- name: |
    GetNavigation Extensions (e.g., Get.toNamed, Get.snackbar)
  description: |
    These are convenient shortcut methods attached to the `Get` interface, allowing you to navigate or show UI elements like dialogs, snackbars, and bottom sheets from anywhere in your code without needing a `BuildContext`.
    Think of it as a universal remote control for your app's navigation and common UI pop-ups. Instead of finding the specific local remote (BuildContext) for the TV in a room, you use one master remote (`Get`) to control any TV (navigation, dialog) in the house.
  file_indices:
    - 2 # lib/get_navigation/src/extension_navigation.dart
    - 0 # lib/get_navigation/get_navigation.dart (Exports these extensions)

- name: |
    GetMaterialApp / GetCupertinoApp & GetRoot
  description: |
    `GetMaterialApp` (for Material Design) and `GetCupertinoApp` (for iOS-style apps) are special versions of Flutter's root app widgets. They initialize the GetX framework, setting up the necessary infrastructure for routing, dependency management, and internationalization.
    `GetRoot` is the underlying widget that `GetMaterialApp` and `GetCupertinoApp` use to manage global configurations and state for the GetX system. It's like the main power supply and configuration panel for the entire GetX ecosystem in your app.
  file_indices:
    - 8 # lib/get_navigation/src/root/get_material_app.dart
    - 7 # lib/get_navigation/src/root/get_cupertino_app.dart
    - 10 # lib/get_navigation/src/root/get_root.dart

- name: |
    Overlay Management (Snackbar, Dialog, BottomSheet)
  description: |
    This refers to the system for displaying temporary, non-page UI elements like snackbars, dialogs, and bottom sheets. `SnackbarController` specifically manages the lifecycle and queue of snackbars. Dialogs and BottomSheets are presented using custom `PopupRoute` implementations (`GetDialogRoute`, `GetModalBottomSheetRoute`).
    Imagine a concierge service in a hotel. You can ask them to deliver a quick note (snackbar), arrange a meeting in a private room (dialog), or pull up a special information panel from below (bottom sheet), all without changing your main location (current page).
  file_indices:
    - 3 # lib/get_navigation/src/snackbar/snackbar_controller.dart
    - 4 # lib/get_navigation/src/snackbar/snackbar.dart (The Snackbar widget itself)
    - 5 # lib/get_navigation/src/dialog/dialog_route.dart
    - 6 # lib/get_navigation/src/bottomsheet/bottomsheet.dart
    - 2 # lib/get_navigation/src/extension_navigation.dart (Provides API for these)

- name: |
    Route Parsing & Configuration (RouteDecoder, PageSettings, ParseRouteTree)
  description: |
    This system is responsible for understanding and interpreting route paths (like URLs). `PageSettings` holds information for a specific route instance, like arguments and parameters. `ParseRouteTree` builds a structured representation of all defined routes and their children. `RouteDecoder` then uses this tree to find the correct `GetPage` and its hierarchy based on a given string path.
    It's like your app's address book and postal service. `ParseRouteTree` is the complete address book. When you want to "go to" `/users/123?mode=edit`, `RouteDecoder` looks up this address, figures out it's for `UserScreen` with ID `123` and mode `edit`, and prepares the `PageSettings`.
  file_indices:
    - 18 # lib/get_navigation/src/routes/parse_route.dart (Contains RouteDecoder and ParseRouteTree)
    - 19 # lib/get_navigation/src/routes/page_settings.dart
    - 17 # lib/get_navigation/src/routes/get_information_parser.dart (Uses RouteDecoder)
    - 12 # lib/get_navigation/src/routes/get_router_delegate.dart (Uses RouteDecoder)

- name: |
    GetMiddleware
  description: |
    Middlewares are like checkpoints or gatekeepers for your routes. Before a page is displayed, or its dependencies are set up, middlewares can intercept the navigation request. They can redirect to a different page (e.g., a login screen if not authenticated), modify the page's properties, or set up specific bindings.
    Think of them as security guards or receptionists at different points in a building. They might check your ID, give you a visitor's pass, or direct you to a different office based on their rules.
  file_indices:
    - 21 # lib/get_navigation/src/routes/route_middleware.dart
    - 26 # lib/get_navigation/src/routes/get_route.dart (GetPage can define middlewares)
    - 12 # lib/get_navigation/src/routes/get_router_delegate.dart (Executes middlewares)

- name: |
    RouterReportManager
  description: |
    This class acts as a central observer for route navigation events and dependency lifecycles within GetX. It tracks when routes are created, disposed, or when dependencies are linked to routes. This is crucial for GetX's smart memory management, ensuring that controllers and services are correctly initialized and cleaned up as users navigate through the app.
    It's like an air traffic controller for your app's routes and their associated resources (dependencies). It logs arrivals, departures, and ensures resources are allocated and deallocated efficiently.
  file_indices:
    - 1 # lib/get_navigation/src/router_report.dart
    - 34 # lib/get_navigation/src/routes/observers/route_observer.dart (Uses RouterReportManager)
    - 5 # lib/get_navigation/src/dialog/dialog_route.dart (Reports to RouterReportManager)
    - 6 # lib/get_navigation/src/bottomsheet/bottomsheet.dart (Reports to RouterReportManager)
    - 29 # lib/get_navigation/src/routes/default_route.dart (PageRouteReportMixin uses it)

- name: |
    Transition System (GetPageRouteTransitionMixin, CustomTransition, Transitions)
  description: |
    This system defines how screens animate when navigating from one to another. `GetPageRouteTransitionMixin` provides the core logic for page transitions, including standard Material/Cupertino transitions and back-swipe gestures. `Transitions` enum lists pre-defined animation types (fade, slide, etc.). `CustomTransition` allows developers to implement entirely unique animations.
    Think of it as the special effects director for your app's scene changes. It dictates whether a new scene slides in, fades in, zooms, or uses a custom choreographed entrance.
  file_indices:
    - 22 # lib/get_navigation/src/routes/get_transition_mixin.dart
    - 25 # lib/get_navigation/src/routes/custom_transition.dart
    - 24 # lib/get_navigation/src/routes/transitions_type.dart
    - 11 # lib/get_navigation/src/routes/default_transitions.dart
    - 29 # lib/get_navigation/src/routes/default_route.dart (GetPageRoute uses the mixin)
```
2025-05-16 11:04:46,476 - INFO - PROMPT: 
Based on the following abstractions and relevant code snippets from the project `getx`:

List of Abstraction Indices and Names:
0 # GetPage & GetRouterDelegate

1 # GetNavigation Extensions (e.g., Get.toNamed, Get.snackbar)

2 # GetMaterialApp / GetCupertinoApp & GetRoot

3 # Overlay Management (Snackbar, Dialog, BottomSheet)

4 # Route Parsing & Configuration (RouteDecoder, PageSettings, ParseRouteTree)

5 # GetMiddleware

6 # RouterReportManager

7 # Transition System (GetPageRouteTransitionMixin, CustomTransition, Transitions)


Context (Abstractions, Descriptions, Code):
Identified Abstractions:\n- Index 0: GetPage & GetRouterDelegate
 (Relevant file indices: [12, 17, 18, 26])\n  Description: `GetPage` is like a blueprint for a screen in your app. It defines the screen's name (URL path), what content to show, and any special behaviors like transitions or data bindings.
`GetRouterDelegate` is the captain of your app's navigation. It takes these `GetPage` blueprints and manages the actual stack of screens, deciding which page is currently visible, how to go to new pages, and how to go back. It's the core engine that powers Flutter's modern Navigator 2.0 system within GetX.
\n- Index 1: GetNavigation Extensions (e.g., Get.toNamed, Get.snackbar)
 (Relevant file indices: [0, 2])\n  Description: These are convenient shortcut methods attached to the `Get` interface, allowing you to navigate or show UI elements like dialogs, snackbars, and bottom sheets from anywhere in your code without needing a `BuildContext`.
Think of it as a universal remote control for your app's navigation and common UI pop-ups. Instead of finding the specific local remote (BuildContext) for the TV in a room, you use one master remote (`Get`) to control any TV (navigation, dialog) in the house.
\n- Index 2: GetMaterialApp / GetCupertinoApp & GetRoot
 (Relevant file indices: [7, 8, 10])\n  Description: `GetMaterialApp` (for Material Design) and `GetCupertinoApp` (for iOS-style apps) are special versions of Flutter's root app widgets. They initialize the GetX framework, setting up the necessary infrastructure for routing, dependency management, and internationalization.
`GetRoot` is the underlying widget that `GetMaterialApp` and `GetCupertinoApp` use to manage global configurations and state for the GetX system. It's like the main power supply and configuration panel for the entire GetX ecosystem in your app.
\n- Index 3: Overlay Management (Snackbar, Dialog, BottomSheet)
 (Relevant file indices: [2, 3, 4, 5, 6])\n  Description: This refers to the system for displaying temporary, non-page UI elements like snackbars, dialogs, and bottom sheets. `SnackbarController` specifically manages the lifecycle and queue of snackbars. Dialogs and BottomSheets are presented using custom `PopupRoute` implementations (`GetDialogRoute`, `GetModalBottomSheetRoute`).
Imagine a concierge service in a hotel. You can ask them to deliver a quick note (snackbar), arrange a meeting in a private room (dialog), or pull up a special information panel from below (bottom sheet), all without changing your main location (current page).
\n- Index 4: Route Parsing & Configuration (RouteDecoder, PageSettings, ParseRouteTree)
 (Relevant file indices: [12, 17, 18, 19])\n  Description: This system is responsible for understanding and interpreting route paths (like URLs). `PageSettings` holds information for a specific route instance, like arguments and parameters. `ParseRouteTree` builds a structured representation of all defined routes and their children. `RouteDecoder` then uses this tree to find the correct `GetPage` and its hierarchy based on a given string path.
It's like your app's address book and postal service. `ParseRouteTree` is the complete address book. When you want to "go to" `/users/123?mode=edit`, `RouteDecoder` looks up this address, figures out it's for `UserScreen` with ID `123` and mode `edit`, and prepares the `PageSettings`.
\n- Index 5: GetMiddleware
 (Relevant file indices: [12, 21, 26])\n  Description: Middlewares are like checkpoints or gatekeepers for your routes. Before a page is displayed, or its dependencies are set up, middlewares can intercept the navigation request. They can redirect to a different page (e.g., a login screen if not authenticated), modify the page's properties, or set up specific bindings.
Think of them as security guards or receptionists at different points in a building. They might check your ID, give you a visitor's pass, or direct you to a different office based on their rules.
\n- Index 6: RouterReportManager
 (Relevant file indices: [1, 5, 6, 29, 34])\n  Description: This class acts as a central observer for route navigation events and dependency lifecycles within GetX. It tracks when routes are created, disposed, or when dependencies are linked to routes. This is crucial for GetX's smart memory management, ensuring that controllers and services are correctly initialized and cleaned up as users navigate through the app.
It's like an air traffic controller for your app's routes and their associated resources (dependencies). It logs arrivals, departures, and ensures resources are allocated and deallocated efficiently.
\n- Index 7: Transition System (GetPageRouteTransitionMixin, CustomTransition, Transitions)
 (Relevant file indices: [11, 22, 24, 25, 29])\n  Description: This system defines how screens animate when navigating from one to another. `GetPageRouteTransitionMixin` provides the core logic for page transitions, including standard Material/Cupertino transitions and back-swipe gestures. `Transitions` enum lists pre-defined animation types (fade, slide, etc.). `CustomTransition` allows developers to implement entirely unique animations.
Think of it as the special effects director for your app's scene changes. It dictates whether a new scene slides in, fades in, zooms, or uses a custom choreographed entrance.
\n\nRelevant File Snippets (Referenced by Index and Path):\n--- File: 0 # lib/get_navigation/get_navigation.dart ---\nlibrary;

export 'src/bottomsheet/bottomsheet.dart';
export 'src/extension_navigation.dart';
export 'src/root/get_cupertino_app.dart';
export 'src/root/get_material_app.dart';
export 'src/root/internacionalization.dart';
export 'src/routes/custom_transition.dart';
export 'src/routes/default_route.dart';
export 'src/routes/get_route.dart';
export 'src/routes/index.dart';
export 'src/routes/observers/route_observer.dart';
export 'src/routes/route_middleware.dart';
export 'src/routes/transitions_type.dart';
export 'src/snackbar/snackbar.dart';
export 'src/snackbar/snackbar_controller.dart';
\n\n--- File: 1 # lib/get_navigation/src/router_report.dart ---\nimport 'dart:collection';

import '../../get.dart';

class RouterReportManager<T> {
  /// Holds a reference to `Get.reference` when the Instance was
  /// created to manage the memory.
  final Map<T?, List<String>> _routesKey = {};

  /// Stores the onClose() references of instances created with `Get.create()`
  /// using the `Get.reference`.
  /// Experimental feature to keep the lifecycle and memory management with
  /// non-singleton instances.
  final Map<T?, HashSet<Function>> _routesByCreate = {};

  static RouterReportManager? _instance;

  RouterReportManager._();

  static RouterReportManager get instance =>
      _instance ??= RouterReportManager._();

  static void dispose() {
    _instance = null;
  }

  void printInstanceStack() {
    Get.log(_routesKey.toString());
  }

  T? _current;

  // ignore: use_setters_to_change_properties
  void reportCurrentRoute(T newRoute) {
    _current = newRoute;
  }

  /// Links a Class instance [S] (or [tag]) to the current route.
  /// Requires usage of `GetMaterialApp`.
  void reportDependencyLinkedToRoute(String dependencyKey) {
    if (_current == null) return;
    if (_routesKey.containsKey(_current)) {
      _routesKey[_current!]!.add(dependencyKey);
    } else {
      _routesKey[_current] = <String>[dependencyKey];
    }
  }

  void clearRouteKeys() {
    _routesKey.clear();
    _routesByCreate.clear();
  }

  void appendRouteByCreate(GetLifeCycleMixin i) {
    _routesByCreate[_current] ??= HashSet<Function>();
    // _routesByCreate[Get.reference]!.add(i.onDelete as Function);
    _routesByCreate[_current]!.add(i.onDelete);
  }

  void reportRouteDispose(T disposed) {
    if (Get.smartManagement != SmartManagement.onlyBuilder) {
      // Engine.instance.addPostFrameCallback((_) {
      // Future.microtask(() {
      _removeDependencyByRoute(disposed);
      // });
    }
  }

  void reportRouteWillDispose(T disposed) {
    final keysToRemove = <String>[];

    _routesKey[disposed]?.forEach(keysToRemove.add);

    /// Removes `Get.create()` instances registered in `routeName`.
    if (_routesByCreate.containsKey(disposed)) {
      for (final onClose in _routesByCreate[disposed]!) {
        // assure the [DisposableInterface] instance holding a reference
        // to onClose() wasn't disposed.
        onClose();
      }
      _routesByCreate[disposed]!.clear();
      _routesByCreate.remove(disposed);
    }

    for (final element in keysToRemove) {
      Get.markAsDirty(key: element);

      //_routesKey.remove(element);
    }

    keysToRemove.clear();
  }

  /// Clears from memory registered Instances associated with [routeName] when
  /// using `Get.smartManagement` as [SmartManagement.full] or
  /// [SmartManagement.keepFactory]
  /// Meant for internal usage of `GetPageRoute` and `GetDialogRoute`
  void _removeDependencyByRoute(T routeName) {
    final keysToRemove = <String>[];

    _routesKey[routeName]?.forEach(keysToRemove.add);

    /// Removes `Get.create()` instances registered in `routeName`.
    if (_routesByCreate.containsKey(routeName)) {
      for (final onClose in _routesByCreate[routeName]!) {
        // assure the [DisposableInterface] instance holding a reference
        // to onClose() wasn't disposed.
        onClose();
      }
      _routesByCreate[routeName]!.clear();
      _routesByCreate.remove(routeName);
    }

    for (final element in keysToRemove) {
      final value = Get.delete(key: element);
      if (value) {
        _routesKey[routeName]?.remove(element);
      }
    }

    _routesKey.remove(routeName);

    keysToRemove.clear();
  }
}
\n\n--- File: 2 # lib/get_navigation/src/extension_navigation.dart ---\nimport 'dart:ui' as ui;

import 'package:flutter/material.dart';
import 'package:get/get_navigation/src/routes/test_kit.dart';

import '../../get.dart';
import 'dialog/dialog_route.dart';
import 'root/get_root.dart';

/// It replaces the Flutter Navigator, but needs no context.
/// You can to use navigator.push(YourRoute()) rather
/// Navigator.push(context, YourRoute());
NavigatorState? get navigator => GetNavigationExt(Get).key.currentState;

extension ExtensionBottomSheet on GetInterface {
  Future<T?> bottomSheet<T>(
    Widget bottomsheet, {
    Color? backgroundColor,
    double? elevation,
    bool persistent = true,
    ShapeBorder? shape,
    Clip? clipBehavior,
    Color? barrierColor,
    bool? ignoreSafeArea,
    bool isScrollControlled = false,
    bool useRootNavigator = false,
    bool isDismissible = true,
    bool enableDrag = true,
    RouteSettings? settings,
    Duration? enterBottomSheetDuration,
    Duration? exitBottomSheetDuration,
    Curve? curve,
  }) {
    return Navigator.of(overlayContext!, rootNavigator: useRootNavigator)
        .push(GetModalBottomSheetRoute<T>(
      builder: (_) => bottomsheet,
      isPersistent: persistent,
      // theme: Theme.of(key.currentContext, shadowThemeOnly: true),
      theme: Theme.of(key.currentContext!),
      isScrollControlled: isScrollControlled,

      barrierLabel: MaterialLocalizations.of(key.currentContext!)
          .modalBarrierDismissLabel,

      backgroundColor: backgroundColor ?? Colors.transparent,
      elevation: elevation,
      shape: shape,
      removeTop: ignoreSafeArea ?? true,
      clipBehavior: clipBehavior,
      isDismissible: isDismissible,
      modalBarrierColor: barrierColor,
      settings: settings,
      enableDrag: enableDrag,
      enterBottomSheetDuration:
          enterBottomSheetDuration ?? const Duration(milliseconds: 250),
      exitBottomSheetDuration:
          exitBottomSheetDuration ?? const Duration(milliseconds: 200),
      curve: curve,
    ));
  }
}

extension ExtensionDialog on GetInterface {
  /// Show a dialog.
  /// You can pass a [transitionDuration] and/or [transitionCurve],
  /// overriding the defaults when the dialog shows up and closes.
  /// When the dialog closes, uses those animations in reverse.
  Future<T?> dialog<T>(
    Widget widget, {
    bool barrierDismissible = true,
    Color? barrierColor,
    bool useSafeArea = true,
    GlobalKey<NavigatorState>? navigatorKey,
    Object? arguments,
    Duration? transitionDuration,
    Curve? transitionCurve,
    String? name,
    RouteSettings? routeSettings,
    String? id,
  }) {
    assert(debugCheckHasMaterialLocalizations(context!));

    //  final theme = Theme.of(context, shadowThemeOnly: true);
    final theme = Theme.of(context!);
    return generalDialog<T>(
      pageBuilder: (buildContext, animation, secondaryAnimation) {
        final pageChild = widget;
        Widget dialog = Builder(builder: (context) {
          return Theme(data: theme, child: pageChild);
        });
        if (useSafeArea) {
          dialog = SafeArea(child: dialog);
        }
        return dialog;
      },
      barrierDismissible: barrierDismissible,
      barrierLabel: MaterialLocalizations.of(context!).modalBarrierDismissLabel,
      barrierColor: barrierColor ?? Colors.black54,
      transitionDuration: transitionDuration ?? defaultDialogTransitionDuration,
      transitionBuilder: (context, animation, secondaryAnimation, child) {
        return FadeTransition(
          opacity: CurvedAnimation(
            parent: animation,
            curve: transitionCurve ?? defaultDialogTransitionCurve,
          ),
          child: child,
        );
      },
      navigatorKey: navigatorKey,
      routeSettings:
          routeSettings ?? RouteSettings(arguments: arguments, name: name),
      id: id,
    );
  }

  /// Api from showGeneralDialog with no context
  Future<T?> generalDialog<T>(
      {required RoutePageBuilder pageBuilder,
      bool barrierDismissible = false,
      String? barrierLabel,
      Color barrierColor = const Color(0x80000000),
      Duration transitionDuration = const Duration(milliseconds: 200),
      RouteTransitionsBuilder? transitionBuilder,
      GlobalKey<NavigatorState>? navigatorKey,
      RouteSettings? routeSettings,
      String? id}) {
    assert(!barrierDismissible || barrierLabel != null);
    final key = navigatorKey ?? Get.nestedKey(id)?.navigatorKey;
    final nav = key?.currentState ??
        Navigator.of(overlayContext!,
            rootNavigator:
                true); //overlay context will always return the root navigator
    return nav.push<T>(
      GetDialogRoute<T>(
        pageBuilder: pageBuilder,
        barrierDismissible: barrierDismissible,
        barrierLabel: barrierLabel,
        barrierColor: barrierColor,
        transitionDuration: transitionDuration,
        transitionBuilder: transitionBuilder,
        settings: routeSettings,
      ),
    );
  }

  /// Custom UI Dialog.
  Future<T?> defaultDialog<T>({
    String title = "Alert",
    EdgeInsetsGeometry? titlePadding,
    TextStyle? titleStyle,
    Widget? content,
    String? id,
    EdgeInsetsGeometry? contentPadding,
    VoidCallback? onConfirm,
    VoidCallback? onCancel,
    VoidCallback? onCustom,
    Color? cancelTextColor,
    Color? confirmTextColor,
    String? textConfirm,
    String? textCancel,
    String? textCustom,
    Widget? confirm,
    Widget? cancel,
    Widget? custom,
    Color? backgroundColor,
    bool barrierDismissible = true,
    Color? buttonColor,
    String middleText = "\n",
    TextStyle? middleTextStyle,
    double radius = 20.0,
    //   ThemeData themeData,
    List<Widget>? actions,

    // onWillPop Scope
    PopInvokedWithResultCallback<T>? onWillPop,

    // the navigator used to push the dialog
    GlobalKey<NavigatorState>? navigatorKey,
  }) {
    var leanCancel = onCancel != null || textCancel != null;
    var leanConfirm = onConfirm != null || textConfirm != null;
    actions ??= [];

    if (cancel != null) {
      actions.add(cancel);
    } else {
      if (leanCancel) {
        actions.add(TextButton(
          style: TextButton.styleFrom(
            tapTargetSize: MaterialTapTargetSize.shrinkWrap,
            padding: const EdgeInsets.symmetric(horizontal: 10, vertical: 8),
            shape: RoundedRectangleBorder(
                side: BorderSide(
                    color: buttonColor ?? theme.colorScheme.secondary,
                    width: 2,
                    style: BorderStyle.solid),
                borderRadius: BorderRadius.circular(radius)),
          ),
          onPressed: () {
            if (onCancel == null) {
              //TODO: Close current dialog after api change
              closeAllDialogs();
            } else {
              onCancel.call();
            }
          },
          child: Text(
            textCancel ?? "Cancel",
            style: TextStyle(
                color: cancelTextColor ?? theme.colorScheme.secondary),
          ),
        ));
      }
    }
    if (confirm != null) {
      actions.add(confirm);
    } else {
      if (leanConfirm) {
        actions.add(TextButton(
            style: TextButton.styleFrom(
              tapTargetSize: MaterialTapTargetSize.shrinkWrap,
              backgroundColor: buttonColor ?? theme.colorScheme.secondary,
              shape: RoundedRectangleBorder(
                  borderRadius: BorderRadius.circular(radius)),
            ),
            child: Text(
              textConfirm ?? "Ok",
              style: TextStyle(
                  color: confirmTextColor ?? theme.colorScheme.surface),
            ),
            onPressed: () {
              onConfirm?.call();
            }));
      }
    }

    Widget baseAlertDialog = Builder(builder: (context) {
      return AlertDialog(
        titlePadding: titlePadding ?? const EdgeInsets.all(8),
        contentPadding: contentPadding ?? const EdgeInsets.all(8),

        backgroundColor:
            backgroundColor ?? DialogTheme.of(context).backgroundColor,
        shape: RoundedRectangleBorder(
            borderRadius: BorderRadius.all(Radius.circular(radius))),
        title: Text(title, textAlign: TextAlign.center, style: titleStyle),
        content: Column(
          crossAxisAlignment: CrossAxisAlignment.center,
          mainAxisSize: MainAxisSize.min,
          children: [
            content ??
                Text(middleText,
                    textAlign: TextAlign.center, style: middleTextStyle),
            const SizedBox(height: 16),
            ButtonTheme(
              minWidth: 78.0,
              height: 34.0,
              child: Wrap(
                alignment: WrapAlignment.center,
                spacing: 8,
                runSpacing: 8,
                children: actions!,
              ),
            )
          ],
        ),
        // actions: actions, // ?? <Widget>[cancelButton, confirmButton],
        buttonPadding: EdgeInsets.zero,
      );
    });

    return dialog<T>(
      onWillPop != null
          ? PopScope<T>(
              onPopInvokedWithResult: (didPop, result) =>
                  onWillPop(didPop, result),
              // onPopInvoked: onWillPop,
              child: baseAlertDialog,
            )
          : baseAlertDialog,
      barrierDismissible: barrierDismissible,
      navigatorKey: navigatorKey,
      id: id,
    );
  }
}

extension ExtensionSnackbar on GetInterface {
  SnackbarController rawSnackbar({
    String? title,
    String? message,
    Widget? titleText,
    Widget? messageText,
    Widget? icon,
    bool instantInit = true,
    bool shouldIconPulse = true,
    double? maxWidth,
    EdgeInsets margin = const EdgeInsets.all(0.0),
    EdgeInsets padding = const EdgeInsets.all(16),
    double borderRadius = 0.0,
    Color? borderColor,
    double borderWidth = 1.0,
    Color backgroundColor = const Color(0xFF303030),
    Color? leftBarIndicatorColor,
    List<BoxShadow>? boxShadows,
    Gradient? backgroundGradient,
    Widget? mainButton,
    OnTap? onTap,
    Duration? duration = const Duration(seconds: 3),
    bool isDismissible = true,
    DismissDirection? dismissDirection,
    bool showProgressIndicator = false,
    AnimationController? progressIndicatorController,
    Color? progressIndicatorBackgroundColor,
    Animation<Color>? progressIndicatorValueColor,
    SnackPosition snackPosition = SnackPosition.bottom,
    SnackStyle snackStyle = SnackStyle.floating,
    Curve forwardAnimationCurve = Curves.easeOutCirc,
    Curve reverseAnimationCurve = Curves.easeOutCirc,
    Duration animationDuration = const Duration(seconds: 1),
    SnackbarStatusCallback? snackbarStatus,
    double barBlur = 0.0,
    double overlayBlur = 0.0,
    Color? overlayColor,
    Form? userInputForm,
  }) {
    final getSnackBar = GetSnackBar(
      snackbarStatus: snackbarStatus,
      title: title,
      message: message,
      titleText: titleText,
      messageText: messageText,
      snackPosition: snackPosition,
      borderRadius: borderRadius,
      margin: margin,
      duration: duration,
      barBlur: barBlur,
      backgroundColor: backgroundColor,
      icon: icon,
      shouldIconPulse: shouldIconPulse,
      maxWidth: maxWidth,
      padding: padding,
      borderColor: borderColor,
      borderWidth: borderWidth,
      leftBarIndicatorColor: leftBarIndicatorColor,
      boxShadows: boxShadows,
      backgroundGradient: backgroundGradient,
      mainButton: mainButton,
      onTap: onTap,
      isDismissible: isDismissible,
      dismissDirection: dismissDirection,
      showProgressIndicator: showProgressIndicator,
      progressIndicatorController: progressIndicatorController,
      progressIndicatorBackgroundColor: progressIndicatorBackgroundColor,
      progressIndicatorValueColor: progressIndicatorValueColor,
      snackStyle: snackStyle,
      forwardAnimationCurve: forwardAnimationCurve,
      reverseAnimationCurve: reverseAnimationCurve,
      animationDuration: animationDuration,
      overlayBlur: overlayBlur,
      overlayColor: overlayColor,
      userInputForm: userInputForm,
    );

    final controller = SnackbarController(getSnackBar);

    if (instantInit) {
      controller.show();
    } else {
      Engine.instance.addPostFrameCallback((_) {
        controller.show();
      });
    }
    return controller;
  }

  SnackbarController showSnackbar(GetSnackBar snackbar) {
    final controller = SnackbarController(snackbar);
    controller.show();
    return controller;
  }

  SnackbarController snackbar(
    String title,
    String message, {
    Color? colorText,
    Duration? duration = const Duration(seconds: 3),

    /// with instantInit = false you can put snackbar on initState
    bool instantInit = true,
    SnackPosition? snackPosition,
    Widget? titleText,
    Widget? messageText,
    Widget? icon,
    bool? shouldIconPulse,
    double? maxWidth,
    EdgeInsets? margin,
    EdgeInsets? padding,
    double? borderRadius,
    Color? borderColor,
    double? borderWidth,
    Color? backgroundColor,
    Color? leftBarIndicatorColor,
    List<BoxShadow>? boxShadows,
    Gradient? backgroundGradient,
    TextButton? mainButton,
    OnTap? onTap,
    OnHover? onHover,
    bool? isDismissible,
    bool? showProgressIndicator,
    DismissDirection? dismissDirection,
    AnimationController? progressIndicatorController,
    Color? progressIndicatorBackgroundColor,
    Animation<Color>? progressIndicatorValueColor,
    SnackStyle? snackStyle,
    Curve? forwardAnimationCurve,
    Curve? reverseAnimationCurve,
    Duration? animationDuration,
    double? barBlur,
    double? overlayBlur,
    SnackbarStatusCallback? snackbarStatus,
    Color? overlayColor,
    Form? userInputForm,
  }) {
    final getSnackBar = GetSnackBar(
        snackbarStatus: snackbarStatus,
        titleText: titleText ??
            Text(
              title,
              style: TextStyle(
                color: colorText ?? iconColor ?? Colors.black,
                fontWeight: FontWeight.w800,
                fontSize: 16,
              ),
            ),
        messageText: messageText ??
            Text(
              message,
              style: TextStyle(
                color: colorText ?? iconColor ?? Colors.black,
                fontWeight: FontWeight.w300,
                fontSize: 14,
              ),
            ),
        snackPosition: snackPosition ?? SnackPosition.top,
        borderRadius: borderRadius ?? 15,
        margin: margin ?? const EdgeInsets.symmetric(horizontal: 10),
        duration: duration,
        barBlur: barBlur ?? 7.0,
        backgroundColor: backgroundColor ?? Colors.grey.withValues(alpha: 0.2),
        icon: icon,
        shouldIconPulse: shouldIconPulse ?? true,
        maxWidth: maxWidth,
        padding: padding ?? const EdgeInsets.all(16),
        borderColor: borderColor,
        borderWidth: borderWidth,
        leftBarIndicatorColor: leftBarIndicatorColor,
        boxShadows: boxShadows,
        backgroundGradient: backgroundGradient,
        mainButton: mainButton,
        onTap: onTap,
        onHover: onHover,
        isDismissible: isDismissible ?? true,
        dismissDirection: dismissDirection,
        showProgressIndicator: showProgressIndicator ?? false,
        progressIndicatorController: progressIndicatorController,
        progressIndicatorBackgroundColor: progressIndicatorBackgroundColor,
        progressIndicatorValueColor: progressIndicatorValueColor,
        snackStyle: snackStyle ?? SnackStyle.floating,
        forwardAnimationCurve: forwardAnimationCurve ?? Curves.easeOutCirc,
        reverseAnimationCurve: reverseAnimationCurve ?? Curves.easeOutCirc,
        animationDuration: animationDuration ?? const Duration(seconds: 1),
        overlayBlur: overlayBlur ?? 0.0,
        overlayColor: overlayColor ?? Colors.transparent,
        userInputForm: userInputForm);

    final controller = SnackbarController(getSnackBar);

    if (instantInit) {
      controller.show();
    } else {
      //routing.isSnackbar = true;
      Engine.instance.addPostFrameCallback((_) {
        controller.show();
      });
    }
    return controller;
  }
}

extension GetNavigationExt on GetInterface {
  /// **Navigation.push()** shortcut.<br><br>
  ///
  /// Pushes a new `page` to the stack
  ///
  /// It has the advantage of not needing context,
  /// so you can call from your business logic
  ///
  /// You can set a custom [transition], and a transition [duration].
  ///
  /// You can send any type of value to the other route in the [arguments].
  ///
  /// Just like native routing in Flutter, you can push a route
  /// as a [fullscreenDialog],
  ///
  /// [id] is for when you are using nested navigation,
  /// as explained in documentation
  ///
  /// If you want the same behavior of ios that pops a route when the user drag,
  /// you can set [popGesture] to true
  ///
  /// If you're using the [BindingsInterface] api, you must define it here
  ///
  /// By default, GetX will prevent you from push a route that you already in,
  /// if you want to push anyway, set [preventDuplicates] to false
  Future<T?>? to<T extends Object?>(Widget Function() page,
      {bool? opaque,
      Transition? transition,
      Curve? curve,
      Duration? duration,
      String? id,
      String? routeName,
      bool fullscreenDialog = false,
      dynamic arguments,
      List<BindingsInterface> bindings = const [],
      bool preventDuplicates = true,
      bool? popGesture,
      bool showCupertinoParallax = true,
      double Function(BuildContext context)? gestureWidth,
      bool rebuildStack = true,
      PreventDuplicateHandlingMode preventDuplicateHandlingMode =
          PreventDuplicateHandlingMode.reorderRoutes}) {
    return searchDelegate(id).to(
      page,
      opaque: opaque,
      transition: transition,
      curve: curve,
      duration: duration,
      id: id,
      routeName: routeName,
      fullscreenDialog: fullscreenDialog,
      arguments: arguments,
      bindings: bindings,
      preventDuplicates: preventDuplicates,
      popGesture: popGesture,
      showCupertinoParallax: showCupertinoParallax,
      gestureWidth: gestureWidth,
      rebuildStack: rebuildStack,
      preventDuplicateHandlingMode: preventDuplicateHandlingMode,
    );
  }

//   GetPageBuilder _resolvePage(dynamic page, String method) {
//     if (page is GetPageBuilder) {
//       return page;
//     } else if (page is Widget) {
//       Get.log(
//           '''WARNING, consider using: "Get.$method(() => Page())"
//instead of "Get.$method(Page())".
// Using a widget function instead of a widget fully guarantees that the widget
//and its controllers will be removed from memory when they are no longer used.
//       ''');
//       return () => page;
//     } else if (page is String) {
//       throw '''Unexpected String,
// use toNamed() instead''';
//     } else {
//       throw '''Unexpected format,
// you can only use widgets and widget functions here''';
//     }
//   }

  /// **Navigation.pushNamed()** shortcut.<br><br>
  ///
  /// Pushes a new named `page` to the stack.
  ///
  /// It has the advantage of not needing context, so you can call
  /// from your business logic.
  ///
  /// You can send any type of value to the other route in the [arguments].
  ///
  /// [id] is for when you are using nested navigation,
  /// as explained in documentation
  ///
  /// By default, GetX will prevent you from push a route that you already in,
  /// if you want to push anyway, set [preventDuplicates] to false
  ///
  /// Note: Always put a slash on the route ('/page1'), to avoid unexpected errors
  Future<T?>? toNamed<T>(
    String page, {
    dynamic arguments,
    dynamic id,
    bool preventDuplicates = true,
    Map<String, String>? parameters,
  }) {
    // if (preventDuplicates && page == currentRoute) {
    //   return null;
    // }

    if (parameters != null) {
      final uri = Uri(path: page, queryParameters: parameters);
      page = uri.toString();
    }

    return searchDelegate(id).toNamed(
      page,
      arguments: arguments,
      id: id,
      preventDuplicates: preventDuplicates,
      parameters: parameters,
    );
  }

  /// **Navigation.pushReplacementNamed()** shortcut.<br><br>
  ///
  /// Pop the current named `page` in the stack and push a new one in its place
  ///
  /// It has the advantage of not needing context, so you can call
  /// from your business logic.
  ///
  /// You can send any type of value to the other route in the [arguments].
  ///
  /// [id] is for when you are using nested navigation,
  /// as explained in documentation
  ///
  /// By default, GetX will prevent you from push a route that you already in,
  /// if you want to push anyway, set [preventDuplicates] to false
  ///
  /// Note: Always put a slash on the route ('/page1'), to avoid unexpected errors
  Future<T?>? offNamed<T>(
    String page, {
    dynamic arguments,
    String? id,
    Map<String, String>? parameters,
  }) {
    // if (preventDuplicates && page == currentRoute) {
    //   return null;
    // }

    if (parameters != null) {
      final uri = Uri(path: page, queryParameters: parameters);
      page = uri.toString();
    }
    return searchDelegate(id).offNamed(
      page,
      arguments: arguments,
      id: id,
      // preventDuplicates: preventDuplicates,
      parameters: parameters,
    );
  }

  /// **Navigation.popUntil()** shortcut.<br><br>
  ///
  /// Calls pop several times in the stack until [predicate] returns true
  ///
  /// [id] is for when you are using nested navigation,
  /// as explained in documentation
  ///
  /// [predicate] can be used like this:
  /// `Get.until((route) => Get.currentRoute == '/home')`so when you get to home page,
  ///
  /// or also like this:
  /// `Get.until((route) => !Get.isDialogOpen())`, to make sure the
  /// dialog is closed
  void until(bool Function(GetPage<dynamic>) predicate, {String? id}) {
    // if (key.currentState.mounted) // add this if appear problems on future with route navigate
    // when widget don't mounted
    return searchDelegate(id).backUntil(predicate);
  }

  /// **Navigation.pushNamedAndRemoveUntil()** shortcut.<br><br>
  ///
  /// Push the given named `page`, and then pop several pages in the stack
  /// until [predicate] returns true
  ///
  /// You can send any type of value to the other route in the [arguments].
  ///
  /// [id] is for when you are using nested navigation,
  /// as explained in documentation
  ///
  /// [predicate] can be used like this:
  /// `Get.offNamedUntil(page, ModalRoute.withName('/home'))`
  /// to pop routes in stack until home,
  /// or like this:
  /// `Get.offNamedUntil((route) => !Get.isDialogOpen())`,
  /// to make sure the dialog is closed
  ///
  /// Note: Always put a slash on the route name ('/page1'), to avoid unexpected errors
  Future<T?>? offNamedUntil<T>(
    String page,
    bool Function(GetPage<dynamic>)? predicate, {
    String? id,
    dynamic arguments,
    Map<String, String>? parameters,
  }) {
    if (parameters != null) {
      final uri = Uri(path: page, queryParameters: parameters);
      page = uri.toString();
    }

    return searchDelegate(id).offNamedUntil<T>(
      page,
      predicate: predicate,
      id: id,
      arguments: arguments,
      parameters: parameters,
    );
  }

  /// **Navigation.popAndPushNamed()** shortcut.<br><br>
  ///
  /// Pop the current named page and pushes a new `page` to the stack
  /// in its place
  ///
  /// You can send any type of value to the other route in the [arguments].
  /// It is very similar to `offNamed()` but use a different approach
  ///
  /// The `offNamed()` pop a page, and goes to the next. The
  /// `offAndToNamed()` goes to the next page, and removes the previous one.
  /// The route transition animation is different.
  Future<T?>? offAndToNamed<T>(
    String page, {
    dynamic arguments,
    String? id,
    dynamic result,
    Map<String, String>? parameters,
  }) {
    if (parameters != null) {
      final uri = Uri(path: page, queryParameters: parameters);
      page = uri.toString();
    }
    return searchDelegate(id).backAndtoNamed(
      page,
      arguments: arguments,
      result: result,
    );
  }

  /// **Navigation.removeRoute()** shortcut.<br><br>
  ///
  /// Remove a specific [route] from the stack
  ///
  /// [id] is for when you are using nested navigation,
  /// as explained in documentation
  void removeRoute(String name, {String? id}) {
    return searchDelegate(id).removeRoute(name);
  }

  /// **Navigation.pushNamedAndRemoveUntil()** shortcut.<br><br>
  ///
  /// Push a named `page` and pop several pages in the stack
  /// until [predicate] returns true. [predicate] is optional
  ///
  /// It has the advantage of not needing context, so you can
  /// call from your business logic.
  ///
  /// You can send any type of value to the other route in the [arguments].
  ///
  /// [predicate] can be used like this:
  /// `Get.until((route) => Get.currentRoute == '/home')`so when you get to home page,
  /// or also like
  /// `Get.until((route) => !Get.isDialogOpen())`, to make sure the dialog
  /// is closed
  ///
  /// [id] is for when you are using nested navigation,
  /// as explained in documentation
  ///
  /// Note: Always put a slash on the route ('/page1'), to avoid unexpected errors
  Future<T?>? offAllNamed<T>(
    String newRouteName, {
    // bool Function(GetPage<dynamic>)? predicate,
    dynamic arguments,
    String? id,
    Map<String, String>? parameters,
  }) {
    if (parameters != null) {
      final uri = Uri(path: newRouteName, queryParameters: parameters);
      newRouteName = uri.toString();
    }

    return searchDelegate(id).offAllNamed<T>(
      newRouteName,
      //predicate: predicate ?? (_) => false,
      arguments: arguments,
      id: id,
      parameters: parameters,
    );
  }

  /// Returns true if a Snackbar, Dialog or BottomSheet is currently OPEN
  bool get isOverlaysOpen =>
      (isSnackbarOpen || isDialogOpen! || isBottomSheetOpen!);

  /// Returns true if there is no Snackbar, Dialog or BottomSheet open
  bool get isOverlaysClosed =>
      (!isSnackbarOpen && !isDialogOpen! && !isBottomSheetOpen!);

  /// **Navigation.popUntil()** shortcut.<br><br>
  ///
  /// Pop the current page, snackbar, dialog or bottomsheet in the stack
  ///
  /// if your set [closeOverlays] to true, Get.back() will close the
  /// currently open snackbar/dialog/bottomsheet AND the current page
  ///
  /// [id] is for when you are using nested navigation,
  /// as explained in documentation
  ///
  /// It has the advantage of not needing context, so you can call
  /// from your business logic.
  void back<T>({
    T? result,
    bool canPop = true,
    int times = 1,
    String? id,
  }) {
    if (times < 1) {
      times = 1;
    }

    if (times > 1) {
      var count = 0;
      return searchDelegate(id).backUntil((route) => count++ == times);
    } else {
      if (canPop) {
        if (searchDelegate(id).canBack == true) {
          return searchDelegate(id).back<T>(result);
        }
      } else {
        return searchDelegate(id).back<T>(result);
      }
    }
  }

  /// Pop the current page, snackbar, dialog or bottomsheet in the stack
  ///
  /// if your set [closeOverlays] to true, Get.back() will close the
  /// currently open snackbar/dialog/bottomsheet AND the current page
  ///
  /// [id] is for when you are using nested navigation,
  /// as explained in documentation
  ///
  /// It has the advantage of not needing context, so you can call
  /// from your business logic.
  void backLegacy<T>({
    T? result,
    bool closeOverlays = false,
    bool canPop = true,
    int times = 1,
    String? id,
  }) {
    if (closeOverlays) {
      closeAllOverlays();
    }

    if (times < 1) {
      times = 1;
    }

    if (times > 1) {
      var count = 0;
      return searchDelegate(id).navigatorKey.currentState?.popUntil((route) {
        return count++ == times;
      });
    } else {
      if (canPop) {
        if (searchDelegate(id).navigatorKey.currentState?.canPop() == true) {
          return searchDelegate(id).navigatorKey.currentState?.pop<T>(result);
        }
      } else {
        return searchDelegate(id).navigatorKey.currentState?.pop<T>(result);
      }
    }
  }

  void closeAllDialogsAndBottomSheets(
    String? id,
  ) {
    // It can not be divided, because dialogs and bottomsheets can not be consecutive
    while ((isDialogOpen! && isBottomSheetOpen!)) {
      closeOverlay(id: id);
    }
  }

  void closeAllDialogs({
    String? id,
  }) {
    while ((isDialogOpen!)) {
      closeOverlay(id: id);
    }
  }

  /// Close the currently open dialog, returning a [result], if provided
  void closeDialog<T>({String? id, T? result}) {
    // Stop if there is no dialog open
    if (isDialogOpen == null || !isDialogOpen!) return;

    closeOverlay(id: id, result: result);
  }

  void closeBottomSheet<T>({String? id, T? result}) {
    // Stop if there is no bottomsheet open
    if (isBottomSheetOpen == null || !isBottomSheetOpen!) return;

    closeOverlay(id: id, result: result);
  }

  /// Close the current overlay returning the [result], if provided
  void closeOverlay<T>({
    String? id,
    T? result,
  }) {
    searchDelegate(id).navigatorKey.currentState?.pop(result);
  }

  void closeAllBottomSheets({
    String? id,
  }) {
    while ((isBottomSheetOpen!)) {
      searchDelegate(id).navigatorKey.currentState?.pop();
    }
  }

  void closeAllOverlays() {
    closeAllDialogsAndBottomSheets(null);
    closeAllSnackbars();
  }

  /// **Navigation.popUntil()** (with predicate) shortcut .<br><br>
  ///
  /// Close as many routes as defined by [times]
  ///
  /// [id] is for when you are using nested navigation,
  /// as explained in documentation
  void close<T extends Object>({
    bool closeAll = true,
    bool closeSnackbar = true,
    bool closeDialog = true,
    bool closeBottomSheet = true,
    String? id,
    T? result,
  }) {
    void handleClose(bool closeCondition, Function closeAllFunction,
        Function closeSingleFunction,
        [bool? isOpenCondition]) {
      if (closeCondition) {
        if (closeAll) {
          closeAllFunction();
        } else if (isOpenCondition == true) {
          closeSingleFunction();
        }
      }
    }

    handleClose(closeSnackbar, closeAllSnackbars, closeCurrentSnackbar);
    handleClose(closeDialog, closeAllDialogs, closeOverlay, isDialogOpen);
    handleClose(closeBottomSheet, closeAllBottomSheets, closeOverlay,
        isBottomSheetOpen);
  }

  /// **Navigation.pushReplacement()** shortcut .<br><br>
  ///
  /// Pop the current page and pushes a new `page` to the stack
  ///
  /// It has the advantage of not needing context,
  /// so you can call from your business logic
  ///
  /// You can set a custom [transition], define a Tween [curve],
  /// and a transition [duration].
  ///
  /// You can send any type of value to the other route in the [arguments].
  ///
  /// Just like native routing in Flutter, you can push a route
  /// as a [fullscreenDialog],
  ///
  /// [id] is for when you are using nested navigation,
  /// as explained in documentation
  ///
  /// If you want the same behavior of ios that pops a route when the user drag,
  /// you can set [popGesture] to true
  ///
  /// If you're using the [BindingsInterface] api, you must define it here
  ///
  /// By default, GetX will prevent you from push a route that you already in,
  /// if you want to push anyway, set [preventDuplicates] to false
  Future<T?>? off<T>(
    Widget Function() page, {
    bool? opaque,
    Transition? transition,
    Curve? curve,
    bool? popGesture,
    String? id,
    String? routeName,
    dynamic arguments,
    List<BindingsInterface> bindings = const [],
    bool fullscreenDialog = false,
    bool preventDuplicates = true,
    Duration? duration,
    double Function(BuildContext context)? gestureWidth,
  }) {
    routeName ??= "/${page.runtimeType.toString()}";
    routeName = _cleanRouteName(routeName);
    if (preventDuplicates && routeName == currentRoute) {
      return null;
    }
    return searchDelegate(id).off(
      page,
      opaque: opaque ?? true,
      transition: transition,
      curve: curve,
      popGesture: popGesture,
      id: id,
      routeName: routeName,
      arguments: arguments,
      bindings: bindings,
      fullscreenDialog: fullscreenDialog,
      preventDuplicates: preventDuplicates,
      duration: duration,
      gestureWidth: gestureWidth,
    );
  }

  Future<T?> offUntil<T>(
    Widget Function() page,
    bool Function(GetPage) predicate, [
    Object? arguments,
    String? id,
  ]) {
    return searchDelegate(id).offUntil(
      page,
      predicate,
      arguments,
    );
  }

  ///
  /// Push a `page` and pop several pages in the stack
  /// until [predicate] returns true. [predicate] is optional
  ///
  /// It has the advantage of not needing context,
  /// so you can call from your business logic
  ///
  /// You can set a custom [transition], a [curve] and a transition [duration].
  ///
  /// You can send any type of value to the other route in the [arguments].
  ///
  /// Just like native routing in Flutter, you can push a route
  /// as a [fullscreenDialog],
  ///
  /// [predicate] can be used like this:
  /// `Get.until((route) => Get.currentRoute == '/home')`so when you get to home page,
  /// or also like
  /// `Get.until((route) => !Get.isDialogOpen())`, to make sure the dialog
  /// is closed
  ///
  /// [id] is for when you are using nested navigation,
  /// as explained in documentation
  ///
  /// If you want the same behavior of ios that pops a route when the user drag,
  /// you can set [popGesture] to true
  ///
  /// If you're using the [BindingsInterface] api, you must define it here
  ///
  /// By default, GetX will prevent you from push a route that you already in,
  /// if you want to push anyway, set [preventDuplicates] to false
  Future<T?>? offAll<T>(
    Widget Function() page, {
    bool Function(GetPage<dynamic>)? predicate,
    bool? opaque,
    bool? popGesture,
    String? id,
    String? routeName,
    dynamic arguments,
    List<BindingsInterface> bindings = const [],
    bool fullscreenDialog = false,
    Transition? transition,
    Curve? curve,
    Duration? duration,
    double Function(BuildContext context)? gestureWidth,
  }) {
    routeName ??= "/${page.runtimeType.toString()}";
    routeName = _cleanRouteName(routeName);
    return searchDelegate(id).offAll<T>(
      page,
      predicate: predicate,
      opaque: opaque ?? true,
      popGesture: popGesture,
      id: id,
      //  routeName routeName,
      arguments: arguments,
      bindings: bindings,
      fullscreenDialog: fullscreenDialog,
      transition: transition,
      curve: curve,
      duration: duration,
      gestureWidth: gestureWidth,
    );
  }

  /// Takes a route [name] String generated by [to], [off], [offAll]
  /// (and similar context navigation methods), cleans the extra chars and
  /// accommodates the format.
  /// TODO: check for a more "appealing" URL naming convention.
  /// `() => MyHomeScreenView` becomes `/my-home-screen-view`.
  String _cleanRouteName(String name) {
    name = name.replaceAll('() => ', '');

    /// uncomment for URL styling.
    // name = name.paramCase!;
    if (!name.startsWith('/')) {
      name = '/$name';
    }
    return Uri.tryParse(name)?.toString() ?? name;
  }
  //TODO: Deprecated
  // /// change default config of Get
  // void config(
  //     {bool? enableLog,
  //     LogWriterCallback? logWriterCallback,
  //     bool? defaultPopGesture,
  //     bool? defaultOpaqueRoute,
  //     Duration? defaultDurationTransition,
  //     bool? defaultGlobalState,
  //     Transition? defaultTransition}) {
  //   if (enableLog != null) {
  //     Get.isLogEnable = enableLog;
  //   }
  //   if (logWriterCallback != null) {
  //     Get.log = logWriterCallback;
  //   }
  //   if (defaultPopGesture != null) {
  //     _getxController.defaultPopGesture = defaultPopGesture;
  //   }
  //   if (defaultOpaqueRoute != null) {
  //     _getxController.defaultOpaqueRoute = defaultOpaqueRoute;
  //   }
  //   if (defaultTransition != null) {
  //     _getxController.defaultTransition = defaultTransition;
  //   }

  //   if (defaultDurationTransition != null) {
  //     _getxController.defaultTransitionDuration = defaultDurationTransition;
  //   }
  // }

  Future<void> updateLocale(Locale l) async {
    Get.locale = l;
    await forceAppUpdate();
  }

  /// As a rule, Flutter knows which widget to update,
  /// so this command is rarely needed. We can mention situations
  /// where you use const so that widgets are not updated with setState,
  /// but you want it to be forcefully updated when an event like
  /// language change happens. using context to make the widget dirty
  /// for performRebuild() is a viable solution.
  /// However, in situations where this is not possible, or at least,
  /// is not desired by the developer, the only solution for updating
  /// widgets that Flutter does not want to update is to use reassemble
  /// to forcibly rebuild all widgets. Attention: calling this function will
  /// reconstruct the application from the sketch, use this with caution.
  /// Your entire application will be rebuilt, and touch events will not
  /// work until the end of rendering.
  Future<void> forceAppUpdate() async {
    await engine.performReassemble();
  }

  void appUpdate() => rootController.update();

  void changeTheme(ThemeData theme) {
    rootController.setTheme(theme);
  }

  void changeThemeMode(ThemeMode themeMode) {
    rootController.setThemeMode(themeMode);
  }

  GlobalKey<NavigatorState>? addKey(GlobalKey<NavigatorState> newKey) {
    return rootController.addKey(newKey);
  }

  GetDelegate? nestedKey(String? key) {
    return rootController.nestedKey(key);
  }

  GetDelegate searchDelegate(String? k) {
    GetDelegate key;
    if (k == null) {
      key = Get.rootController.rootDelegate;
    } else {
      if (!keys.containsKey(k)) {
        throw 'Route id ($k) not found';
      }
      key = keys[k]!;
    }

    // if (_key.listenersLength == 0 && !testMode) {
    //   throw """You are trying to use contextless navigation without
    //   a GetMaterialApp or Get.key.
    //   If you are testing your app, you can use:
    //   [Get.testMode = true], or if you are running your app on
    //   a physical device or emulator, you must exchange your [MaterialApp]
    //   for a [GetMaterialApp].
    //   """;
    // }

    return key;
  }

  /// give name from current route
  String get currentRoute => routing.current;

  /// give name from previous route
  String get previousRoute => routing.previous;

  /// check if snackbar is open
  bool get isSnackbarOpen =>
      SnackbarController.isSnackbarBeingShown; //routing.isSnackbar;

  void closeAllSnackbars() {
    SnackbarController.cancelAllSnackbars();
  }

  Future<void> closeCurrentSnackbar() async {
    await SnackbarController.closeCurrentSnackbar();
  }

  /// check if dialog is open
  bool? get isDialogOpen => routing.isDialog;

  /// check if bottomsheet is open
  bool? get isBottomSheetOpen => routing.isBottomSheet;

  /// check a raw current route
  Route<dynamic>? get rawRoute => routing.route;

  /// check if default opaque route is enable
  bool get isOpaqueRouteDefault => defaultOpaqueRoute;

  /// give access to currentContext
  BuildContext? get context => key.currentContext;

  /// give access to current Overlay Context
  BuildContext? get overlayContext {
    BuildContext? overlay;
    key.currentState?.overlay?.context.visitChildElements((element) {
      overlay = element;
    });
    return overlay;
  }

  /// give access to Theme.of(context)
  ThemeData get theme {
    var theme = ThemeData.fallback();
    if (context != null) {
      theme = Theme.of(context!);
    }
    return theme;
  }

  /// The current null safe [WidgetsBinding]
  WidgetsBinding get engine {
    return WidgetsFlutterBinding.ensureInitialized();
  }

  /// The window to which this binding is bound.
  ui.PlatformDispatcher get window => engine.platformDispatcher;

  Locale? get deviceLocale => window.locale;

  ///The number of device pixels for each logical pixel.
  double get pixelRatio => window.implicitView!.devicePixelRatio;

  Size get size => window.implicitView!.physicalSize / pixelRatio;

  ///The horizontal extent of this size.
  double get width => size.width;

  ///The vertical extent of this size
  double get height => size.height;

  ///The distance from the top edge to the first unpadded pixel,
  ///in physical pixels.
  double get statusBarHeight => window.implicitView!.padding.top;

  ///The distance from the bottom edge to the first unpadded pixel,
  ///in physical pixels.
  double get bottomBarHeight => window.implicitView!.padding.bottom;

  ///The system-reported text scale.
  double get textScaleFactor => window.textScaleFactor;

  /// give access to TextTheme.of(context)
  TextTheme get textTheme => theme.textTheme;

  /// give access to Mediaquery.of(context)
  MediaQueryData get mediaQuery => MediaQuery.of(context!);

  /// Check if dark mode theme is enable
  bool get isDarkMode => (theme.brightness == Brightness.dark);

  /// Check if dark mode theme is enable on platform on android Q+
  bool get isPlatformDarkMode =>
      (ui.PlatformDispatcher.instance.platformBrightness == Brightness.dark);

  /// give access to Theme.of(context).iconTheme.color
  Color? get iconColor => theme.iconTheme.color;

  /// give access to FocusScope.of(context)
  FocusNode? get focusScope => FocusManager.instance.primaryFocus;

  // /// give access to Immutable MediaQuery.of(context).size.height
  // double get height => MediaQuery.of(context).size.height;

  // /// give access to Immutable MediaQuery.of(context).size.width
  // double get width => MediaQuery.of(context).size.width;

  GlobalKey<NavigatorState> get key => rootController.key;

  Map<String, GetDelegate> get keys => rootController.keys;

  GetRootState get rootController => GetRootState.controller;

  ConfigData get _getxController => GetRootState.controller.config;

  bool? get defaultPopGesture => _getxController.defaultPopGesture;
  bool get defaultOpaqueRoute => _getxController.defaultOpaqueRoute;

  Transition? get defaultTransition => _getxController.defaultTransition;

  Duration get defaultTransitionDuration {
    return _getxController.defaultTransitionDuration;
  }

  Curve get defaultTransitionCurve => _getxController.defaultTransitionCurve;

  Curve get defaultDialogTransitionCurve {
    return _getxController.defaultDialogTransitionCurve;
  }

  Duration get defaultDialogTransitionDuration {
    return _getxController.defaultDialogTransitionDuration;
  }

  Routing get routing => _getxController.routing;

  bool get _shouldUseMock => GetTestMode.active && !GetRoot.treeInitialized;

  /// give current arguments
  dynamic get arguments {
    return args();
  }

  T args<T>() {
    if (_shouldUseMock) {
      return GetTestMode.arguments as T;
    }
    return rootController.rootDelegate.arguments<T>();
  }

  // set parameters(Map<String, String?> newParameters) {
  //   rootController.parameters = newParameters;
  // }

  // @Deprecated('Use GetTestMode.active=true instead')
  set testMode(bool isTest) => GetTestMode.active = isTest;

  // @Deprecated('Use GetTestMode.active instead')
  bool get testMode => GetTestMode.active;

  Map<String, String?> get parameters {
    if (_shouldUseMock) {
      return GetTestMode.parameters;
    }

    return rootController.rootDelegate.parameters;
  }

  /// Casts the stored router delegate to a desired type
  TDelegate? delegate<TDelegate extends RouterDelegate<TPage>, TPage>() =>
      _getxController.routerDelegate as TDelegate?;
}

extension OverlayExt on GetInterface {
  Future<T> showOverlay<T>({
    required Future<T> Function() asyncFunction,
    Color opacityColor = Colors.black,
    Widget? loadingWidget,
    double opacity = .5,
  }) async {
    final navigatorState =
        Navigator.of(Get.overlayContext!, rootNavigator: false);
    final overlayState = navigatorState.overlay!;

    final overlayEntryOpacity = OverlayEntry(builder: (context) {
      return Opacity(
          opacity: opacity,
          child: Container(
            color: opacityColor,
          ));
    });
    final overlayEntryLoader = OverlayEntry(builder: (context) {
      return loadingWidget ??
          const Center(
              child: SizedBox(
            height: 90,
            width: 90,
            child: Text('Loading...'),
          ));
    });
    overlayState.insert(overlayEntryOpacity);
    overlayState.insert(overlayEntryLoader);

    T data;

    try {
      data = await asyncFunction();
    } on Exception catch (_) {
      overlayEntryLoader.remove();
      overlayEntryOpacity.remove();
      rethrow;
    }

    overlayEntryLoader.remove();
    overlayEntryOpacity.remove();
    return data;
  }
}
\n\n--- File: 3 # lib/get_navigation/src/snackbar/snackbar_controller.dart ---\nimport 'dart:async';
import 'dart:math';
import 'dart:ui';

import 'package:flutter/material.dart';

import '../../../get.dart';
import '../root/get_root.dart';

class SnackbarController {
  final key = GlobalKey<GetSnackBarState>();

  static bool get isSnackbarBeingShown =>
      GetRootState.controller.config.snackBarQueue.isJobInProgress;

  late Animation<double> _filterBlurAnimation;
  late Animation<Color?> _filterColorAnimation;

  final GetSnackBar snackbar;
  final _transitionCompleter = Completer();

  late SnackbarStatusCallback? _snackbarStatus;
  late final Alignment? _initialAlignment;
  late final Alignment? _endAlignment;

  bool _wasDismissedBySwipe = false;

  bool _onTappedDismiss = false;

  Timer? _timer;

  /// The animation that drives the route's transition and the previous route's
  /// forward transition.
  late final Animation<Alignment> _animation;

  /// The animation controller that the route uses to drive the transitions.
  ///
  /// The animation itself is exposed by the [animation] property.
  late final AnimationController _controller;

  SnackbarStatus? _currentStatus;

  final _overlayEntries = <OverlayEntry>[];

  OverlayState? _overlayState;

  SnackbarController(this.snackbar);

  Future<void> get future => _transitionCompleter.future;

  /// Close the snackbar with animation
  Future<void> close({bool withAnimations = true}) async {
    if (!withAnimations) {
      _removeOverlay();
      return;
    }
    _removeEntry();
    await future;
  }

  /// Adds GetSnackbar to a view queue.
  /// Only one GetSnackbar will be displayed at a time, and this method returns
  /// a future to when the snackbar disappears.
  Future<void> show() {
    return GetRootState.controller.config.snackBarQueue.addJob(this);
  }

  void _cancelTimer() {
    if (_timer != null && _timer!.isActive) {
      _timer!.cancel();
    }
  }

  // ignore: avoid_returning_this
  void _configureAlignment(SnackPosition snackPosition) {
    switch (snackbar.snackPosition) {
      case SnackPosition.top:
        {
          _initialAlignment = const Alignment(-1.0, -2.0);
          _endAlignment = const Alignment(-1.0, -1.0);
          break;
        }
      case SnackPosition.bottom:
        {
          _initialAlignment = const Alignment(-1.0, 2.0);
          _endAlignment = const Alignment(-1.0, 1.0);
          break;
        }
    }
  }

  bool _isTesting = false;

  void _configureOverlay() {
    final overlayContext = Get.overlayContext;
    _isTesting = overlayContext == null;
    _overlayState =
        _isTesting ? OverlayState() : Overlay.of(Get.overlayContext!);
    _overlayEntries.clear();
    _overlayEntries.addAll(_createOverlayEntries(_getBodyWidget()));
    if (!_isTesting) {
      _overlayState!.insertAll(_overlayEntries);
    }

    _configureSnackBarDisplay();
  }

  void _configureSnackBarDisplay() {
    assert(!_transitionCompleter.isCompleted,
        'Cannot configure a snackbar after disposing it.');
    _controller = _createAnimationController();
    _configureAlignment(snackbar.snackPosition);
    _snackbarStatus = snackbar.snackbarStatus;
    _filterBlurAnimation = _createBlurFilterAnimation();
    _filterColorAnimation = _createColorOverlayColor();
    _animation = _createAnimation();
    _animation.addStatusListener(_handleStatusChanged);
    _configureTimer();
    _controller.forward();
  }

  void _configureTimer() {
    if (snackbar.duration != null) {
      if (_timer != null && _timer!.isActive) {
        _timer!.cancel();
      }
      _timer = Timer(snackbar.duration!, _removeEntry);
    } else {
      if (_timer != null) {
        _timer!.cancel();
      }
    }
  }

  /// Called to create the animation that exposes the current progress of
  /// the transition controlled by the animation controller created by
  /// `createAnimationController()`.
  Animation<Alignment> _createAnimation() {
    assert(!_transitionCompleter.isCompleted,
        'Cannot create a animation from a disposed snackbar');
    return AlignmentTween(begin: _initialAlignment, end: _endAlignment).animate(
      CurvedAnimation(
        parent: _controller,
        curve: snackbar.forwardAnimationCurve,
        reverseCurve: snackbar.reverseAnimationCurve,
      ),
    );
  }

  /// Called to create the animation controller that will drive the transitions
  /// to this route from the previous one, and back to the previous route
  /// from this one.
  AnimationController _createAnimationController() {
    assert(!_transitionCompleter.isCompleted,
        'Cannot create a animationController from a disposed snackbar');
    assert(snackbar.animationDuration >= Duration.zero);
    return AnimationController(
      duration: snackbar.animationDuration,
      debugLabel: '$runtimeType',
      vsync: _overlayState!,
    );
  }

  Animation<double> _createBlurFilterAnimation() {
    return Tween(begin: 0.0, end: snackbar.overlayBlur).animate(
      CurvedAnimation(
        parent: _controller,
        curve: const Interval(
          0.0,
          0.35,
          curve: Curves.easeInOutCirc,
        ),
      ),
    );
  }

  Animation<Color?> _createColorOverlayColor() {
    return ColorTween(
            begin: const Color(0x00000000), end: snackbar.overlayColor)
        .animate(
      CurvedAnimation(
        parent: _controller,
        curve: const Interval(
          0.0,
          0.35,
          curve: Curves.easeInOutCirc,
        ),
      ),
    );
  }

  Iterable<OverlayEntry> _createOverlayEntries(Widget child) {
    return <OverlayEntry>[
      if (snackbar.overlayBlur > 0.0) ...[
        OverlayEntry(
          builder: (context) => GestureDetector(
            onTap: () {
              if (snackbar.isDismissible && !_onTappedDismiss) {
                _onTappedDismiss = true;
                close();
              }
            },
            child: AnimatedBuilder(
              animation: _filterBlurAnimation,
              builder: (context, child) {
                return BackdropFilter(
                  filter: ImageFilter.blur(
                    sigmaX: max(0.001, _filterBlurAnimation.value),
                    sigmaY: max(0.001, _filterBlurAnimation.value),
                  ),
                  child: Container(
                    constraints: const BoxConstraints.expand(),
                    color: _filterColorAnimation.value,
                  ),
                );
              },
            ),
          ),
          maintainState: false,
          opaque: false,
        ),
      ],
      OverlayEntry(
        builder: (context) => Semantics(
          focused: false,
          container: true,
          explicitChildNodes: true,
          child: AlignTransition(
            alignment: _animation,
            child: snackbar.isDismissible
                ? _getDismissibleSnack(child)
                : _getSnackbarContainer(child),
          ),
        ),
        maintainState: false,
        opaque: false,
      ),
    ];
  }

  Widget _getBodyWidget() {
    return Builder(builder: (_) {
      return MouseRegion(
        onEnter: (_) =>
            snackbar.onHover?.call(snackbar, SnackHoverState.entered),
        onExit: (_) => snackbar.onHover?.call(snackbar, SnackHoverState.exited),
        child: GestureDetector(
          behavior: snackbar.hitTestBehavior ?? HitTestBehavior.deferToChild,
          onTap: snackbar.onTap != null
              ? () => snackbar.onTap?.call(snackbar)
              : null,
          child: snackbar,
        ),
      );
    });
  }

  DismissDirection _getDefaultDismissDirection() {
    if (snackbar.snackPosition == SnackPosition.top) {
      return DismissDirection.up;
    }
    return DismissDirection.down;
  }

  Widget _getDismissibleSnack(Widget child) {
    return Dismissible(
      behavior: snackbar.hitTestBehavior ?? HitTestBehavior.opaque,
      direction: snackbar.dismissDirection ?? _getDefaultDismissDirection(),
      resizeDuration: null,
      confirmDismiss: (_) {
        if (_currentStatus == SnackbarStatus.opening ||
            _currentStatus == SnackbarStatus.closing) {
          return Future.value(false);
        }
        return Future.value(true);
      },
      key: const Key('dismissible'),
      onDismissed: (_) {
        _wasDismissedBySwipe = true;
        _removeEntry();
      },
      child: _getSnackbarContainer(child),
    );
  }

  Widget _getSnackbarContainer(Widget child) {
    return Container(
      margin: snackbar.margin,
      child: child,
    );
  }

  void _handleStatusChanged(AnimationStatus status) {
    switch (status) {
      case AnimationStatus.completed:
        _currentStatus = SnackbarStatus.open;
        _snackbarStatus?.call(_currentStatus);
        if (_overlayEntries.isNotEmpty) _overlayEntries.first.opaque = false;

        break;
      case AnimationStatus.forward:
        _currentStatus = SnackbarStatus.opening;
        _snackbarStatus?.call(_currentStatus);
        break;
      case AnimationStatus.reverse:
        _currentStatus = SnackbarStatus.closing;
        _snackbarStatus?.call(_currentStatus);
        if (_overlayEntries.isNotEmpty) _overlayEntries.first.opaque = false;
        break;
      case AnimationStatus.dismissed:
        assert(!_overlayEntries.first.opaque);
        _currentStatus = SnackbarStatus.closed;
        _snackbarStatus?.call(_currentStatus);
        _removeOverlay();
        break;
    }
  }

  void _removeEntry() {
    assert(
      !_transitionCompleter.isCompleted,
      'Cannot remove entry from a disposed snackbar',
    );

    _cancelTimer();

    if (_wasDismissedBySwipe) {
      Timer(const Duration(milliseconds: 200), _controller.reset);
      _wasDismissedBySwipe = false;
    } else {
      _controller.reverse();
    }
  }

  void _removeOverlay() {
    if (!_isTesting) {
      for (var element in _overlayEntries) {
        element.remove();
      }
    }

    assert(!_transitionCompleter.isCompleted,
        'Cannot remove overlay from a disposed snackbar');
    _controller.dispose();
    _overlayEntries.clear();
    _transitionCompleter.complete();
  }

  Future<void> _show() {
    _configureOverlay();
    return future;
  }

  static Future<void> cancelAllSnackbars() async {
    await GetRootState.controller.config.snackBarQueue.cancelAllJobs();
  }

  static Future<void> closeCurrentSnackbar() async {
    await GetRootState.controller.config.snackBarQueue.closeCurrentJob();
  }
}

class SnackBarQueue {
  final _queue = GetQueue();
  final _snackbarList = <SnackbarController>[];

  SnackbarController? get _currentSnackbar {
    if (_snackbarList.isEmpty) return null;
    return _snackbarList.first;
  }

  bool get isJobInProgress => _snackbarList.isNotEmpty;

  Future<void> addJob(SnackbarController job) async {
    _snackbarList.add(job);
    final data = await _queue.add(job._show);
    _snackbarList.remove(job);
    return data;
  }

  Future<void> cancelAllJobs() async {
    await _currentSnackbar?.close();
    _queue.cancelAllJobs();
    _snackbarList.clear();
  }

  void disposeControllers() {
    if (_currentSnackbar != null) {
      _currentSnackbar?._removeOverlay();
      _currentSnackbar?._controller.dispose();
      _snackbarList.remove(_currentSnackbar);
    }

    _queue.cancelAllJobs();

    for (var element in _snackbarList) {
      element._controller.dispose();
    }
    _snackbarList.clear();
  }

  Future<void> closeCurrentJob() async {
    if (_currentSnackbar == null) return;
    await _currentSnackbar!.close();
  }
}
\n\n--- File: 4 # lib/get_navigation/src/snackbar/snackbar.dart ---\nimport 'dart:async';
import 'dart:ui';

import 'package:flutter/material.dart';

import '../../../get_core/get_core.dart';
import '../../get_navigation.dart';

typedef OnTap = void Function(GetSnackBar snack);
typedef OnHover = void Function(
    GetSnackBar snack, SnackHoverState snackHoverState);

typedef SnackbarStatusCallback = void Function(SnackbarStatus? status);

class GetSnackBar extends StatefulWidget {
  /// A callback for you to listen to the different Snack status
  final SnackbarStatusCallback? snackbarStatus;

  /// The title displayed to the user
  final String? title;

  /// Defines how the snack bar area, including margin, will behave during hit testing.
  ///
  /// If this property is null and [margin] is not null, then [HitTestBehavior.deferToChild] is used by default.
  ///
  /// Please refer to [HitTestBehavior] for a detailed explanation of every behavior.
  final HitTestBehavior? hitTestBehavior;

  /// The direction in which the SnackBar can be dismissed.
  ///
  /// Default is [DismissDirection.down] when
  /// [snackPosition] == [SnackPosition.BOTTOM] and [DismissDirection.up]
  /// when [snackPosition] == [SnackPosition.TOP]
  final DismissDirection? dismissDirection;

  /// The message displayed to the user.
  final String? message;

  /// Replaces [title]. Although this accepts a [Widget], it is meant
  /// to receive [Text] or [RichText]
  final Widget? titleText;

  /// Replaces [message]. Although this accepts a [Widget], it is meant
  /// to receive [Text] or  [RichText]
  final Widget? messageText;

  /// Will be ignored if [backgroundGradient] is not null
  final Color backgroundColor;

  /// If not null, shows a left vertical colored bar on notification.
  /// It is not possible to use it with a [Form] and I do not recommend
  /// using it with [LinearProgressIndicator]
  final Color? leftBarIndicatorColor;

  /// [boxShadows] The shadows generated by Snack. Leave it null
  /// if you don't want a shadow.
  /// You can use more than one if you feel the need.
  /// Check (this example)[https://github.com/flutter/flutter/blob/master/packages/flutter/lib/src/material/shadows.dart]
  final List<BoxShadow>? boxShadows;

  /// Give to GetSnackbar a gradient background.
  /// It Makes [backgroundColor] be ignored.
  final Gradient? backgroundGradient;

  /// You can use any widget here, but I recommend [Icon] or [Image] as
  /// indication of what kind
  /// of message you are displaying. Other widgets may break the layout
  final Widget? icon;

  /// An option to animate the icon (if present). Defaults to true.
  final bool shouldIconPulse;

  /// (optional) An action that the user can take based on the snack bar.
  ///
  /// For example, the snack bar might let the user undo the operation that
  /// prompted the snackbar.
  final Widget? mainButton;

  /// A callback that registers the user's click anywhere.
  /// An alternative to [mainButton]
  final OnTap? onTap;

  /// A callback that registers the user's hover anywhere over the Snackbar.
  final OnHover? onHover;

  /// How long until Snack will hide itself (be dismissed).
  /// To make it indefinite, leave it null.
  final Duration? duration;

  /// True if you want to show a [LinearProgressIndicator].
  final bool showProgressIndicator;

  /// An optional [AnimationController] when you want to control the
  /// progress of your [LinearProgressIndicator].
  final AnimationController? progressIndicatorController;

  /// A [LinearProgressIndicator] configuration parameter.
  final Color? progressIndicatorBackgroundColor;

  /// A [LinearProgressIndicator] configuration parameter.
  final Animation<Color>? progressIndicatorValueColor;

  /// Determines if the user can swipe or click the overlay
  /// (if [overlayBlur] > 0) to dismiss.
  /// It is recommended that you set [duration] != null if this is false.
  /// If the user swipes to dismiss or clicks the overlay, no value
  /// will be returned.
  final bool isDismissible;

  /// Used to limit Snack width (usually on large screens)
  final double? maxWidth;

  /// Adds a custom margin to Snack
  final EdgeInsets margin;

  /// Adds a custom padding to Snack
  /// The default follows material design guide line
  final EdgeInsets padding;

  /// Adds a radius to all corners of Snack. Best combined with [margin].
  /// I do not recommend using it with [showProgressIndicator]
  /// or [leftBarIndicatorColor].
  final double borderRadius;

  /// Adds a border to every side of Snack
  /// I do not recommend using it with [showProgressIndicator]
  /// or [leftBarIndicatorColor].
  final Color? borderColor;

  /// Changes the width of the border if [borderColor] is specified
  final double? borderWidth;

  /// Snack can be based on [SnackPosition.TOP] or on [SnackPosition.BOTTOM]
  /// of your screen.
  /// [SnackPosition.BOTTOM] is the default.
  final SnackPosition snackPosition;

  /// Snack can be floating or be grounded to the edge of the screen.
  /// If grounded, I do not recommend using [margin] or [borderRadius].
  /// [SnackStyle.FLOATING] is the default
  /// If grounded, I do not recommend using a [backgroundColor] with
  /// transparency or [barBlur]
  final SnackStyle snackStyle;

  /// The [Curve] animation used when show() is called.
  /// [Curves.easeOut] is default
  final Curve forwardAnimationCurve;

  /// The [Curve] animation used when dismiss() is called.
  /// [Curves.fastOutSlowIn] is default
  final Curve reverseAnimationCurve;

  /// Use it to speed up or slow down the animation duration
  final Duration animationDuration;

  /// Default is 0.0. If different than 0.0, blurs only Snack's background.
  /// To take effect, make sure your [backgroundColor] has some opacity.
  /// The greater the value, the greater the blur.
  final double barBlur;

  /// Default is 0.0. If different than 0.0, creates a blurred
  /// overlay that prevents the user from interacting with the screen.
  /// The greater the value, the greater the blur.
  final double overlayBlur;

  /// Default is [Colors.transparent]. Only takes effect if [overlayBlur] > 0.0.
  /// Make sure you use a color with transparency here e.g.
  /// Colors.grey[600].withValues(alpha:0.2).
  final Color? overlayColor;

  /// A [TextFormField] in case you want a simple user input.
  /// Every other widget is ignored if this is not null.
  final Form? userInputForm;

  const GetSnackBar({
    super.key,
    this.title,
    this.message,
    this.titleText,
    this.messageText,
    this.icon,
    this.shouldIconPulse = true,
    this.maxWidth,
    this.margin = const EdgeInsets.all(0.0),
    this.padding = const EdgeInsets.all(16),
    this.borderRadius = 0.0,
    this.borderColor,
    this.borderWidth = 1.0,
    this.backgroundColor = const Color(0xFF303030),
    this.leftBarIndicatorColor,
    this.boxShadows,
    this.backgroundGradient,
    this.mainButton,
    this.onTap,
    this.onHover,
    this.duration,
    this.isDismissible = true,
    this.dismissDirection,
    this.showProgressIndicator = false,
    this.progressIndicatorController,
    this.progressIndicatorBackgroundColor,
    this.progressIndicatorValueColor,
    this.snackPosition = SnackPosition.bottom,
    this.snackStyle = SnackStyle.floating,
    this.forwardAnimationCurve = Curves.easeOutCirc,
    this.reverseAnimationCurve = Curves.easeOutCirc,
    this.animationDuration = const Duration(seconds: 1),
    this.barBlur = 0.0,
    this.overlayBlur = 0.0,
    this.overlayColor = Colors.transparent,
    this.userInputForm,
    this.snackbarStatus,
    this.hitTestBehavior,
  });

  @override
  State createState() => GetSnackBarState();

  /// Show the snack. It's call [SnackbarStatus.OPENING] state
  /// followed by [SnackbarStatus.OPEN]
  SnackbarController show() {
    return Get.showSnackbar(this);
  }
}

class GetSnackBarState extends State<GetSnackBar>
    with TickerProviderStateMixin {
  AnimationController? _fadeController;
  late Animation<double> _fadeAnimation;

  final Widget _emptyWidget = const SizedBox(width: 0.0, height: 0.0);
  final double _initialOpacity = 1.0;
  final double _finalOpacity = 0.4;

  final Duration _pulseAnimationDuration = const Duration(seconds: 1);

  late bool _isTitlePresent;
  late double _messageTopMargin;

  FocusScopeNode? _focusNode;
  late FocusAttachment _focusAttachment;

  final Completer<Size> _boxHeightCompleter = Completer<Size>();

  late CurvedAnimation _progressAnimation;

  final _backgroundBoxKey = GlobalKey();

  double get buttonPadding {
    if (widget.padding.right - 12 < 0) {
      return 4;
    } else {
      return widget.padding.right - 12;
    }
  }

  RowStyle get _rowStyle {
    if (widget.mainButton != null && widget.icon == null) {
      return RowStyle.action;
    } else if (widget.mainButton == null && widget.icon != null) {
      return RowStyle.icon;
    } else if (widget.mainButton != null && widget.icon != null) {
      return RowStyle.all;
    } else {
      return RowStyle.none;
    }
  }

  @override
  Widget build(BuildContext context) {
    return Align(
      heightFactor: 1.0,
      child: Material(
        color: widget.snackStyle == SnackStyle.floating
            ? Colors.transparent
            : widget.backgroundColor,
        child: SafeArea(
          minimum: widget.snackPosition == SnackPosition.bottom
              ? EdgeInsets.only(
                  bottom: MediaQuery.of(context).viewInsets.bottom)
              : EdgeInsets.only(top: MediaQuery.of(context).padding.top),
          bottom: widget.snackPosition == SnackPosition.bottom,
          top: widget.snackPosition == SnackPosition.top,
          left: false,
          right: false,
          child: Stack(
            children: [
              FutureBuilder<Size>(
                future: _boxHeightCompleter.future,
                builder: (context, snapshot) {
                  if (snapshot.hasData) {
                    if (widget.barBlur == 0) {
                      return _emptyWidget;
                    }
                    return ClipRRect(
                      borderRadius: BorderRadius.circular(widget.borderRadius),
                      child: BackdropFilter(
                        filter: ImageFilter.blur(
                            sigmaX: widget.barBlur, sigmaY: widget.barBlur),
                        child: Container(
                          height: snapshot.data!.height,
                          width: snapshot.data!.width,
                          decoration: BoxDecoration(
                            color: Colors.transparent,
                            borderRadius:
                                BorderRadius.circular(widget.borderRadius),
                          ),
                        ),
                      ),
                    );
                  } else {
                    return _emptyWidget;
                  }
                },
              ),
              if (widget.userInputForm != null)
                _containerWithForm()
              else
                _containerWithoutForm()
            ],
          ),
        ),
      ),
    );
  }

  @override
  void dispose() {
    _fadeController?.dispose();
    widget.progressIndicatorController?.removeListener(_updateProgress);
    widget.progressIndicatorController?.dispose();

    _focusAttachment.detach();
    _focusNode!.dispose();
    super.dispose();
  }

  @override
  void initState() {
    super.initState();

    assert(
        widget.userInputForm != null ||
            ((widget.message != null && widget.message!.isNotEmpty) ||
                widget.messageText != null),
        '''
You need to either use message[String], or messageText[Widget] or define a userInputForm[Form] in GetSnackbar''');

    _isTitlePresent = (widget.title != null || widget.titleText != null);
    _messageTopMargin = _isTitlePresent ? 6.0 : widget.padding.top;

    _configureLeftBarFuture();
    _configureProgressIndicatorAnimation();

    if (widget.icon != null && widget.shouldIconPulse) {
      _configurePulseAnimation();
      _fadeController?.forward();
    }

    _focusNode = FocusScopeNode();
    _focusAttachment = _focusNode!.attach(context);
  }

  Widget _buildLeftBarIndicator() {
    if (widget.leftBarIndicatorColor != null) {
      return FutureBuilder<Size>(
        future: _boxHeightCompleter.future,
        builder: (buildContext, snapshot) {
          if (snapshot.hasData) {
            return Container(
              color: widget.leftBarIndicatorColor,
              width: 5.0,
              height: snapshot.data!.height,
            );
          } else {
            return _emptyWidget;
          }
        },
      );
    } else {
      return _emptyWidget;
    }
  }

  void _configureLeftBarFuture() {
    Engine.instance.addPostFrameCallback(
      (_) {
        final keyContext = _backgroundBoxKey.currentContext;
        if (keyContext != null) {
          final box = keyContext.findRenderObject() as RenderBox;
          _boxHeightCompleter.complete(box.size);
        }
      },
    );
  }

  void _configureProgressIndicatorAnimation() {
    if (widget.showProgressIndicator &&
        widget.progressIndicatorController != null) {
      widget.progressIndicatorController!.addListener(_updateProgress);

      _progressAnimation = CurvedAnimation(
          curve: Curves.linear, parent: widget.progressIndicatorController!);
    }
  }

  void _configurePulseAnimation() {
    _fadeController =
        AnimationController(vsync: this, duration: _pulseAnimationDuration);
    _fadeAnimation = Tween(begin: _initialOpacity, end: _finalOpacity).animate(
      CurvedAnimation(
        parent: _fadeController!,
        curve: Curves.linear,
      ),
    );

    _fadeController!.addStatusListener((status) {
      if (status == AnimationStatus.completed) {
        _fadeController!.reverse();
      }
      if (status == AnimationStatus.dismissed) {
        _fadeController!.forward();
      }
    });

    _fadeController!.forward();
  }

  Widget _containerWithForm() {
    return Container(
      key: _backgroundBoxKey,
      constraints: widget.maxWidth != null
          ? BoxConstraints(maxWidth: widget.maxWidth!)
          : null,
      decoration: BoxDecoration(
        color: widget.backgroundColor,
        gradient: widget.backgroundGradient,
        boxShadow: widget.boxShadows,
        borderRadius: BorderRadius.circular(widget.borderRadius),
        border: widget.borderColor != null
            ? Border.all(
                color: widget.borderColor!,
                width: widget.borderWidth!,
              )
            : null,
      ),
      child: Padding(
        padding: const EdgeInsets.only(
            left: 8.0, right: 8.0, bottom: 8.0, top: 16.0),
        child: FocusScope(
          node: _focusNode,
          autofocus: true,
          child: widget.userInputForm!,
        ),
      ),
    );
  }

  Widget _containerWithoutForm() {
    final iconPadding = widget.padding.left > 16.0 ? widget.padding.left : 0.0;
    final left = _rowStyle == RowStyle.icon || _rowStyle == RowStyle.all
        ? 4.0
        : widget.padding.left;
    final right = _rowStyle == RowStyle.action || _rowStyle == RowStyle.all
        ? 8.0
        : widget.padding.right;
    return Container(
      key: _backgroundBoxKey,
      constraints: widget.maxWidth != null
          ? BoxConstraints(maxWidth: widget.maxWidth!)
          : null,
      decoration: BoxDecoration(
        color: widget.backgroundColor,
        gradient: widget.backgroundGradient,
        boxShadow: widget.boxShadows,
        borderRadius: BorderRadius.circular(widget.borderRadius),
        border: widget.borderColor != null
            ? Border.all(color: widget.borderColor!, width: widget.borderWidth!)
            : null,
      ),
      child: Column(
        mainAxisSize: MainAxisSize.min,
        children: [
          widget.showProgressIndicator
              ? LinearProgressIndicator(
                  value: widget.progressIndicatorController != null
                      ? _progressAnimation.value
                      : null,
                  backgroundColor: widget.progressIndicatorBackgroundColor,
                  valueColor: widget.progressIndicatorValueColor,
                )
              : _emptyWidget,
          Row(
            mainAxisSize: MainAxisSize.max,
            children: [
              _buildLeftBarIndicator(),
              if (_rowStyle == RowStyle.icon || _rowStyle == RowStyle.all)
                ConstrainedBox(
                  constraints:
                      BoxConstraints.tightFor(width: 42.0 + iconPadding),
                  child: _getIcon(),
                ),
              Expanded(
                flex: 1,
                child: Column(
                  crossAxisAlignment: CrossAxisAlignment.stretch,
                  mainAxisSize: MainAxisSize.min,
                  children: <Widget>[
                    if (_isTitlePresent)
                      Padding(
                        padding: EdgeInsets.only(
                          top: widget.padding.top,
                          left: left,
                          right: right,
                        ),
                        child: widget.titleText ??
                            Text(
                              widget.title ?? "",
                              style: const TextStyle(
                                fontSize: 16.0,
                                color: Colors.white,
                                fontWeight: FontWeight.bold,
                              ),
                            ),
                      )
                    else
                      _emptyWidget,
                    Padding(
                      padding: EdgeInsets.only(
                        top: _messageTopMargin,
                        left: left,
                        right: right,
                        bottom: widget.padding.bottom,
                      ),
                      child: widget.messageText ??
                          Text(
                            widget.message ?? "",
                            style: const TextStyle(
                                fontSize: 14.0, color: Colors.white),
                          ),
                    ),
                  ],
                ),
              ),
              if (_rowStyle == RowStyle.action || _rowStyle == RowStyle.all)
                Padding(
                  padding: EdgeInsets.only(right: buttonPadding),
                  child: widget.mainButton,
                ),
            ],
          ),
        ],
      ),
    );
  }

  Widget? _getIcon() {
    if (widget.icon != null && widget.icon is Icon && widget.shouldIconPulse) {
      return FadeTransition(
        opacity: _fadeAnimation,
        child: widget.icon,
      );
    } else if (widget.icon != null) {
      return widget.icon;
    } else {
      return _emptyWidget;
    }
  }

  void _updateProgress() => setState(() {});
}

enum RowStyle {
  icon,
  action,
  all,
  none,
}

/// Indicates Status of snackbar
/// [SnackbarStatus.OPEN] Snack is fully open, [SnackbarStatus.CLOSED] Snackbar
/// has closed,
/// [SnackbarStatus.OPENING] Starts with the opening animation and ends
/// with the full
/// snackbar display, [SnackbarStatus.CLOSING] Starts with the closing animation
/// and ends
/// with the full snackbar dispose
enum SnackbarStatus { open, closed, opening, closing }

/// Indicates if snack is going to start at the [TOP] or at the [BOTTOM]
enum SnackPosition { top, bottom }

/// Indicates if snack will be attached to the edge of the screen or not
enum SnackStyle { floating, grounded }

/// Indicates if the mouse entered or exited
enum SnackHoverState { entered, exited }
\n\n--- File: 5 # lib/get_navigation/src/dialog/dialog_route.dart ---\nimport 'package:flutter/widgets.dart';

import '../router_report.dart';

class GetDialogRoute<T> extends PopupRoute<T> {
  GetDialogRoute({
    required RoutePageBuilder pageBuilder,
    bool barrierDismissible = true,
    String? barrierLabel,
    Color barrierColor = const Color(0x80000000),
    Duration transitionDuration = const Duration(milliseconds: 200),
    RouteTransitionsBuilder? transitionBuilder,
    super.settings,
  })  : widget = pageBuilder,
        _barrierDismissible = barrierDismissible,
        _barrierLabel = barrierLabel,
        _barrierColor = barrierColor,
        _transitionDuration = transitionDuration,
        _transitionBuilder = transitionBuilder {
    RouterReportManager.instance.reportCurrentRoute(this);
  }

  final RoutePageBuilder widget;

  @override
  bool get barrierDismissible => _barrierDismissible;
  final bool _barrierDismissible;

  @override
  void dispose() {
    RouterReportManager.instance.reportRouteDispose(this);
    super.dispose();
  }

  @override
  String? get barrierLabel => _barrierLabel;
  final String? _barrierLabel;

  @override
  Color get barrierColor => _barrierColor;
  final Color _barrierColor;

  @override
  Duration get transitionDuration => _transitionDuration;
  final Duration _transitionDuration;

  final RouteTransitionsBuilder? _transitionBuilder;

  @override
  Widget buildPage(BuildContext context, Animation<double> animation,
      Animation<double> secondaryAnimation) {
    return Semantics(
      scopesRoute: true,
      explicitChildNodes: true,
      child: widget(context, animation, secondaryAnimation),
    );
  }

  @override
  Widget buildTransitions(BuildContext context, Animation<double> animation,
      Animation<double> secondaryAnimation, Widget child) {
    if (_transitionBuilder == null) {
      return FadeTransition(
          opacity: CurvedAnimation(
            parent: animation,
            curve: Curves.linear,
          ),
          child: child);
    } // Some default transition
    return _transitionBuilder(context, animation, secondaryAnimation, child);
  }
}
\n\n--- File: 6 # lib/get_navigation/src/bottomsheet/bottomsheet.dart ---\nimport 'package:flutter/material.dart';

import '../../../get.dart';
import '../router_report.dart';

class GetModalBottomSheetRoute<T> extends PopupRoute<T> {
  GetModalBottomSheetRoute({
    this.builder,
    this.theme,
    this.barrierLabel,
    this.backgroundColor,
    this.isPersistent,
    this.elevation,
    this.shape,
    this.removeTop = true,
    this.clipBehavior,
    this.modalBarrierColor,
    this.isDismissible = true,
    this.enableDrag = true,
    required this.isScrollControlled,
    super.settings,
    this.enterBottomSheetDuration = const Duration(milliseconds: 250),
    this.exitBottomSheetDuration = const Duration(milliseconds: 200),
    this.curve,
  }) {
    RouterReportManager.instance.reportCurrentRoute(this);
  }
  final bool? isPersistent;
  final WidgetBuilder? builder;
  final ThemeData? theme;
  final bool isScrollControlled;
  final Color? backgroundColor;
  final double? elevation;
  final ShapeBorder? shape;
  final Clip? clipBehavior;
  final Color? modalBarrierColor;
  final bool isDismissible;
  final bool enableDrag;
  // final String name;
  final Duration enterBottomSheetDuration;
  final Duration exitBottomSheetDuration;
  final Curve? curve;
  // remove safearea from top
  final bool removeTop;

  @override
  Duration get transitionDuration => const Duration(milliseconds: 700);

  @override
  bool get barrierDismissible => isDismissible;

  @override
  final String? barrierLabel;

  @override
  Color get barrierColor => modalBarrierColor ?? Colors.black54;

  AnimationController? _animationController;

  @override
  void dispose() {
    RouterReportManager.instance.reportRouteDispose(this);
    super.dispose();
  }

  @override
  Animation<double> createAnimation() {
    if (curve != null) {
      return CurvedAnimation(curve: curve!, parent: _animationController!.view);
    }
    return _animationController!.view;
  }

  @override
  AnimationController createAnimationController() {
    assert(_animationController == null);
    _animationController =
        BottomSheet.createAnimationController(navigator!.overlay!);
    _animationController!.duration = enterBottomSheetDuration;
    _animationController!.reverseDuration = exitBottomSheetDuration;
    return _animationController!;
  }

  @override
  Widget buildPage(BuildContext context, Animation<double> animation,
      Animation<double> secondaryAnimation) {
    final sheetTheme =
        theme?.bottomSheetTheme ?? Theme.of(context).bottomSheetTheme;
    // By definition, the bottom sheet is aligned to the bottom of the page
    // and isn't exposed to the top padding of the MediaQuery.
    Widget bottomSheet = MediaQuery.removePadding(
      context: context,
      removeTop: removeTop,
      child: Padding(
        padding:
            EdgeInsets.only(bottom: MediaQuery.of(context).viewInsets.bottom),
        child: _GetModalBottomSheet<T>(
          route: this,
          backgroundColor: backgroundColor ??
              sheetTheme.modalBackgroundColor ??
              sheetTheme.backgroundColor,
          elevation:
              elevation ?? sheetTheme.modalElevation ?? sheetTheme.elevation,
          shape: shape,
          clipBehavior: clipBehavior,
          isScrollControlled: isScrollControlled,
          enableDrag: enableDrag,
        ),
      ),
    );
    if (theme != null) bottomSheet = Theme(data: theme!, child: bottomSheet);
    return bottomSheet;
  }
}

class _GetModalBottomSheet<T> extends StatefulWidget {
  const _GetModalBottomSheet({
    super.key,
    this.route,
    this.backgroundColor,
    this.elevation,
    this.shape,
    this.clipBehavior,
    this.isScrollControlled = false,
    this.enableDrag = true,
    this.isPersistent = false,
  });
  final bool isPersistent;
  final GetModalBottomSheetRoute<T>? route;
  final bool isScrollControlled;
  final Color? backgroundColor;
  final double? elevation;
  final ShapeBorder? shape;
  final Clip? clipBehavior;
  final bool enableDrag;

  @override
  _GetModalBottomSheetState<T> createState() => _GetModalBottomSheetState<T>();
}

class _GetModalBottomSheetState<T> extends State<_GetModalBottomSheet<T>> {
  String _getRouteLabel(MaterialLocalizations localizations) {
    if ((Theme.of(context).platform == TargetPlatform.android) ||
        (Theme.of(context).platform == TargetPlatform.fuchsia)) {
      return localizations.dialogLabel;
    } else {
      return '';
    }
  }

  @override
  Widget build(BuildContext context) {
    assert(debugCheckHasMediaQuery(context));
    assert(debugCheckHasMaterialLocalizations(context));
    final mediaQuery = MediaQuery.of(context);
    final localizations = MaterialLocalizations.of(context);
    final routeLabel = _getRouteLabel(localizations);

    return AnimatedBuilder(
      animation: widget.route!.animation!,
      builder: (context, child) {
        // Disable the initial animation when accessible navigation is on so
        // that the semantics are added to the tree at the correct time.
        final animationValue = mediaQuery.accessibleNavigation
            ? 1.0
            : widget.route!.animation!.value;
        return Semantics(
          scopesRoute: true,
          namesRoute: true,
          label: routeLabel,
          explicitChildNodes: true,
          child: ClipRect(
            child: CustomSingleChildLayout(
                delegate: _GetModalBottomSheetLayout(
                    animationValue, widget.isScrollControlled),
                child: widget.isPersistent == false
                    ? BottomSheet(
                        animationController: widget.route!._animationController,
                        onClosing: () {
                          if (widget.route!.isCurrent) {
                            Navigator.pop(context);
                          }
                        },
                        builder: widget.route!.builder!,
                        backgroundColor: widget.backgroundColor,
                        elevation: widget.elevation,
                        shape: widget.shape,
                        clipBehavior: widget.clipBehavior,
                        enableDrag: widget.enableDrag,
                      )
                    : Scaffold(
                        bottomSheet: BottomSheet(
                          animationController:
                              widget.route!._animationController,
                          onClosing: () {
                            // if (widget.route.isCurrent) {
                            //   Navigator.pop(context);
                            // }
                          },
                          builder: widget.route!.builder!,
                          backgroundColor: widget.backgroundColor,
                          elevation: widget.elevation,
                          shape: widget.shape,
                          clipBehavior: widget.clipBehavior,
                          enableDrag: widget.enableDrag,
                        ),
                      )),
          ),
        );
      },
    );
  }
}

class _GetPerModalBottomSheet<T> extends StatefulWidget {
  const _GetPerModalBottomSheet({
    super.key,
    this.route,
    this.isPersistent,
    this.backgroundColor,
    this.elevation,
    this.shape,
    this.clipBehavior,
    this.isScrollControlled = false,
    this.enableDrag = true,
  });
  final bool? isPersistent;
  final GetModalBottomSheetRoute<T>? route;
  final bool isScrollControlled;
  final Color? backgroundColor;
  final double? elevation;
  final ShapeBorder? shape;
  final Clip? clipBehavior;
  final bool enableDrag;

  @override
  // ignore: lines_longer_than_80_chars
  _GetPerModalBottomSheetState<T> createState() =>
      _GetPerModalBottomSheetState<T>();
}

// ignore: lines_longer_than_80_chars
class _GetPerModalBottomSheetState<T>
    extends State<_GetPerModalBottomSheet<T>> {
  String _getRouteLabel(MaterialLocalizations localizations) {
    if ((Theme.of(context).platform == TargetPlatform.android) ||
        (Theme.of(context).platform == TargetPlatform.fuchsia)) {
      return localizations.dialogLabel;
    } else {
      return '';
    }
  }

  @override
  Widget build(BuildContext context) {
    assert(debugCheckHasMediaQuery(context));
    assert(debugCheckHasMaterialLocalizations(context));
    final mediaQuery = MediaQuery.of(context);
    final localizations = MaterialLocalizations.of(context);
    final routeLabel = _getRouteLabel(localizations);

    return AnimatedBuilder(
      animation: widget.route!.animation!,
      builder: (context, child) {
        // Disable the initial animation when accessible navigation is on so
        // that the semantics are added to the tree at the correct time.
        final animationValue = mediaQuery.accessibleNavigation
            ? 1.0
            : widget.route!.animation!.value;
        return Semantics(
          scopesRoute: true,
          namesRoute: true,
          label: routeLabel,
          explicitChildNodes: true,
          child: ClipRect(
            child: CustomSingleChildLayout(
                delegate: _GetModalBottomSheetLayout(
                    animationValue, widget.isScrollControlled),
                child: widget.isPersistent == false
                    ? BottomSheet(
                        animationController: widget.route!._animationController,
                        onClosing: () {
                          if (widget.route!.isCurrent) {
                            Navigator.pop(context);
                          }
                        },
                        builder: widget.route!.builder!,
                        backgroundColor: widget.backgroundColor,
                        elevation: widget.elevation,
                        shape: widget.shape,
                        clipBehavior: widget.clipBehavior,
                        enableDrag: widget.enableDrag,
                      )
                    : Scaffold(
                        bottomSheet: BottomSheet(
                          animationController:
                              widget.route!._animationController,
                          onClosing: () {
                            // if (widget.route.isCurrent) {
                            //   Navigator.pop(context);
                            // }
                          },
                          builder: widget.route!.builder!,
                          backgroundColor: widget.backgroundColor,
                          elevation: widget.elevation,
                          shape: widget.shape,
                          clipBehavior: widget.clipBehavior,
                          enableDrag: widget.enableDrag,
                        ),
                      )),
          ),
        );
      },
    );
  }
}

class _GetModalBottomSheetLayout extends SingleChildLayoutDelegate {
  _GetModalBottomSheetLayout(this.progress, this.isScrollControlled);

  final double progress;
  final bool isScrollControlled;

  @override
  BoxConstraints getConstraintsForChild(BoxConstraints constraints) {
    return BoxConstraints(
      minWidth: constraints.maxWidth,
      maxWidth: constraints.maxWidth,
      minHeight: 0.0,
      maxHeight: isScrollControlled
          ? constraints.maxHeight
          : constraints.maxHeight * 9.0 / 16.0,
    );
  }

  @override
  Offset getPositionForChild(Size size, Size childSize) {
    return Offset(0.0, size.height - childSize.height * progress);
  }

  @override
  bool shouldRelayout(_GetModalBottomSheetLayout oldDelegate) {
    return progress != oldDelegate.progress;
  }
}
\n\n--- File: 7 # lib/get_navigation/src/root/get_cupertino_app.dart ---\nimport 'package:flutter/cupertino.dart';
import 'package:flutter/foundation.dart';
import 'package:flutter/material.dart';

import '../../../get_core/get_core.dart';
import '../../../get_instance/get_instance.dart';
import '../../../get_state_manager/get_state_manager.dart';
import '../../../get_utils/get_utils.dart';
import '../../get_navigation.dart';
import 'get_root.dart';

class GetCupertinoApp extends StatelessWidget {
  final GlobalKey<NavigatorState>? navigatorKey;
  final Widget? home;
  final Map<String, WidgetBuilder>? routes;
  final String? initialRoute;
  final RouteFactory? onGenerateRoute;
  final InitialRouteListFactory? onGenerateInitialRoutes;
  final RouteFactory? onUnknownRoute;
  final List<NavigatorObserver>? navigatorObservers;
  final TransitionBuilder? builder;
  final String title;
  final GenerateAppTitle? onGenerateTitle;
  final CustomTransition? customTransition;
  final Color? color;
  final Map<String, Map<String, String>>? translationsKeys;
  final Translations? translations;
  final TextDirection? textDirection;
  final Locale? locale;
  final Locale? fallbackLocale;
  final Iterable<LocalizationsDelegate<dynamic>>? localizationsDelegates;
  final LocaleListResolutionCallback? localeListResolutionCallback;
  final LocaleResolutionCallback? localeResolutionCallback;
  final Iterable<Locale> supportedLocales;
  final bool showPerformanceOverlay;
  final bool checkerboardRasterCacheImages;
  final bool checkerboardOffscreenLayers;
  final bool showSemanticsDebugger;
  final bool debugShowCheckedModeBanner;
  final Map<LogicalKeySet, Intent>? shortcuts;
  final ThemeData? highContrastTheme;
  final ThemeData? highContrastDarkTheme;
  final Map<Type, Action<Intent>>? actions;
  final Function(Routing?)? routingCallback;
  final Transition? defaultTransition;
  final bool? opaqueRoute;
  final VoidCallback? onInit;
  final VoidCallback? onReady;
  final VoidCallback? onDispose;
  final bool? enableLog;
  final LogWriterCallback? logWriterCallback;
  final bool? popGesture;
  final SmartManagement smartManagement;
  final BindingsInterface? initialBinding;
  final Duration? transitionDuration;
  final bool? defaultGlobalState;
  final List<GetPage>? getPages;
  final GetPage? unknownRoute;
  final RouteInformationProvider? routeInformationProvider;
  final RouteInformationParser<Object>? routeInformationParser;
  final RouterDelegate<Object>? routerDelegate;
  final RouterConfig<Object>? routerConfig;
  final BackButtonDispatcher? backButtonDispatcher;
  final CupertinoThemeData? theme;
  final bool useInheritedMediaQuery;
  final List<Bind> binds;
  final ScrollBehavior? scrollBehavior;

  const GetCupertinoApp({
    super.key,
    this.theme,
    this.navigatorKey,
    this.home,
    Map<String, Widget Function(BuildContext)> this.routes =
        const <String, WidgetBuilder>{},
    this.initialRoute,
    this.onGenerateRoute,
    this.onGenerateInitialRoutes,
    this.onUnknownRoute,
    List<NavigatorObserver> this.navigatorObservers =
        const <NavigatorObserver>[],
    this.builder,
    this.translationsKeys,
    this.translations,
    this.textDirection,
    this.title = '',
    this.onGenerateTitle,
    this.color,
    this.customTransition,
    this.onInit,
    this.onDispose,
    this.locale,
    this.binds = const [],
    this.scrollBehavior,
    this.fallbackLocale,
    this.localizationsDelegates,
    this.localeListResolutionCallback,
    this.localeResolutionCallback,
    this.supportedLocales = const <Locale>[Locale('en', 'US')],
    this.showPerformanceOverlay = false,
    this.checkerboardRasterCacheImages = false,
    this.checkerboardOffscreenLayers = false,
    this.showSemanticsDebugger = false,
    this.debugShowCheckedModeBanner = true,
    this.shortcuts,
    this.smartManagement = SmartManagement.full,
    this.initialBinding,
    this.useInheritedMediaQuery = false,
    this.unknownRoute,
    this.routingCallback,
    this.defaultTransition,
    this.onReady,
    this.getPages,
    this.opaqueRoute,
    this.enableLog = kDebugMode,
    this.logWriterCallback,
    this.popGesture,
    this.transitionDuration,
    this.defaultGlobalState,
    this.highContrastTheme,
    this.highContrastDarkTheme,
    this.actions,
  })  : routeInformationProvider = null,
        backButtonDispatcher = null,
        routeInformationParser = null,
        routerDelegate = null,
        routerConfig = null;

  const GetCupertinoApp.router({
    super.key,
    this.theme,
    this.routeInformationProvider,
    this.routeInformationParser,
    this.routerDelegate,
    this.routerConfig,
    this.backButtonDispatcher,
    this.builder,
    this.title = '',
    this.onGenerateTitle,
    this.useInheritedMediaQuery = false,
    this.color,
    this.highContrastTheme,
    this.highContrastDarkTheme,
    this.locale,
    this.localizationsDelegates,
    this.localeListResolutionCallback,
    this.localeResolutionCallback,
    this.supportedLocales = const <Locale>[Locale('en', 'US')],
    this.showPerformanceOverlay = false,
    this.checkerboardRasterCacheImages = false,
    this.checkerboardOffscreenLayers = false,
    this.showSemanticsDebugger = false,
    this.debugShowCheckedModeBanner = true,
    this.shortcuts,
    this.binds = const [],
    this.scrollBehavior,
    this.actions,
    this.customTransition,
    this.translationsKeys,
    this.translations,
    this.textDirection,
    this.fallbackLocale,
    this.routingCallback,
    this.defaultTransition,
    this.opaqueRoute,
    this.onInit,
    this.onReady,
    this.onDispose,
    this.enableLog = kDebugMode,
    this.logWriterCallback,
    this.popGesture,
    this.smartManagement = SmartManagement.full,
    this.initialBinding,
    this.transitionDuration,
    this.defaultGlobalState,
    this.getPages,
    this.navigatorObservers,
    this.unknownRoute,
  })  : navigatorKey = null,
        onGenerateRoute = null,
        home = null,
        onGenerateInitialRoutes = null,
        onUnknownRoute = null,
        routes = null,
        initialRoute = null;

  @override
  Widget build(BuildContext context) {
    return GetRoot(
      config: ConfigData(
        backButtonDispatcher: backButtonDispatcher,
        binds: binds,
        customTransition: customTransition,
        defaultGlobalState: defaultGlobalState,
        defaultTransition: defaultTransition,
        enableLog: enableLog,
        fallbackLocale: fallbackLocale,
        getPages: getPages,
        home: home,
        initialRoute: initialRoute,
        locale: locale,
        logWriterCallback: logWriterCallback,
        navigatorKey: navigatorKey,
        navigatorObservers: navigatorObservers,
        onDispose: onDispose,
        onInit: onInit,
        onReady: onReady,
        routeInformationParser: routeInformationParser,
        routeInformationProvider: routeInformationProvider,
        routerDelegate: routerDelegate,
        routingCallback: routingCallback,
        scaffoldMessengerKey: GlobalKey<ScaffoldMessengerState>(),
        smartManagement: smartManagement,
        transitionDuration: transitionDuration,
        translations: translations,
        translationsKeys: translationsKeys,
        unknownRoute: unknownRoute,
        defaultPopGesture: popGesture,
      ),
      child: Builder(builder: (context) {
        final controller = GetRoot.of(context);
        return CupertinoApp.router(
          routerDelegate: controller.config.routerDelegate,
          routeInformationParser: controller.config.routeInformationParser,
          backButtonDispatcher: backButtonDispatcher,
          routeInformationProvider: routeInformationProvider,
          routerConfig: routerConfig,
          key: controller.config.unikey,
          builder: (context, child) => Directionality(
            textDirection: textDirection ??
                (rtlLanguages.contains(Get.locale?.languageCode)
                    ? TextDirection.rtl
                    : TextDirection.ltr),
            child: builder == null
                ? (child ?? const Material())
                : builder!(context, child ?? const Material()),
          ),
          title: title,
          onGenerateTitle: onGenerateTitle,
          color: color,
          theme: theme,
          locale: Get.locale ?? locale,
          localizationsDelegates: localizationsDelegates,
          localeListResolutionCallback: localeListResolutionCallback,
          localeResolutionCallback: localeResolutionCallback,
          supportedLocales: supportedLocales,
          showPerformanceOverlay: showPerformanceOverlay,
          checkerboardRasterCacheImages: checkerboardRasterCacheImages,
          checkerboardOffscreenLayers: checkerboardOffscreenLayers,
          showSemanticsDebugger: showSemanticsDebugger,
          debugShowCheckedModeBanner: debugShowCheckedModeBanner,
          shortcuts: shortcuts,
          scrollBehavior: scrollBehavior,
        );
      }),
    );
  }
}
\n\n--- File: 8 # lib/get_navigation/src/root/get_material_app.dart ---\nimport 'package:flutter/foundation.dart';
import 'package:flutter/material.dart';
import 'package:get/instance_manager.dart';

import '../../../get_state_manager/get_state_manager.dart';
import '../../../get_utils/get_utils.dart';
import '../../get_navigation.dart';
import 'get_root.dart';

class GetMaterialApp extends StatelessWidget {
  final GlobalKey<NavigatorState>? navigatorKey;
  final GlobalKey<ScaffoldMessengerState>? scaffoldMessengerKey;
  final Widget? home;
  final Map<String, WidgetBuilder>? routes;
  final String? initialRoute;
  final RouteFactory? onGenerateRoute;
  final InitialRouteListFactory? onGenerateInitialRoutes;
  final RouteFactory? onUnknownRoute;
  final List<NavigatorObserver>? navigatorObservers;
  final TransitionBuilder? builder;
  final String title;
  final GenerateAppTitle? onGenerateTitle;
  final ThemeData? theme;
  final ThemeData? darkTheme;
  final ThemeMode themeMode;
  final CustomTransition? customTransition;
  final Color? color;
  final Map<String, Map<String, String>>? translationsKeys;
  final Translations? translations;
  final TextDirection? textDirection;
  final Locale? locale;
  final Locale? fallbackLocale;
  final Iterable<LocalizationsDelegate<dynamic>>? localizationsDelegates;
  final LocaleListResolutionCallback? localeListResolutionCallback;
  final LocaleResolutionCallback? localeResolutionCallback;
  final Iterable<Locale> supportedLocales;
  final bool showPerformanceOverlay;
  final bool checkerboardRasterCacheImages;
  final bool checkerboardOffscreenLayers;
  final bool showSemanticsDebugger;
  final bool debugShowCheckedModeBanner;
  final Map<LogicalKeySet, Intent>? shortcuts;
  final ScrollBehavior? scrollBehavior;
  final ThemeData? highContrastTheme;
  final ThemeData? highContrastDarkTheme;
  final Map<Type, Action<Intent>>? actions;
  final bool debugShowMaterialGrid;
  final ValueChanged<Routing?>? routingCallback;
  final Transition? defaultTransition;
  final bool? opaqueRoute;
  final VoidCallback? onInit;
  final VoidCallback? onReady;
  final VoidCallback? onDispose;
  final bool? enableLog;
  final LogWriterCallback? logWriterCallback;
  final bool? popGesture;
  final SmartManagement smartManagement;
  final List<Bind> binds;
  final Duration? transitionDuration;
  final bool? defaultGlobalState;
  final List<GetPage>? getPages;
  final GetPage? unknownRoute;
  final RouteInformationProvider? routeInformationProvider;
  final RouteInformationParser<Object>? routeInformationParser;
  final RouterDelegate<Object>? routerDelegate;
  final RouterConfig<Object>? routerConfig;
  final BackButtonDispatcher? backButtonDispatcher;
  final bool useInheritedMediaQuery;

  const GetMaterialApp({
    super.key,
    this.navigatorKey,
    this.scaffoldMessengerKey,
    this.home,
    Map<String, Widget Function(BuildContext)> this.routes =
        const <String, WidgetBuilder>{},
    this.initialRoute,
    this.onGenerateRoute,
    this.onGenerateInitialRoutes,
    this.onUnknownRoute,
    this.useInheritedMediaQuery = false,
    List<NavigatorObserver> this.navigatorObservers =
        const <NavigatorObserver>[],
    this.builder,
    this.textDirection,
    this.title = '',
    this.onGenerateTitle,
    this.color,
    this.theme,
    this.darkTheme,
    this.themeMode = ThemeMode.system,
    this.locale,
    this.fallbackLocale,
    this.localizationsDelegates,
    this.localeListResolutionCallback,
    this.localeResolutionCallback,
    this.supportedLocales = const <Locale>[Locale('en', 'US')],
    this.debugShowMaterialGrid = false,
    this.showPerformanceOverlay = false,
    this.checkerboardRasterCacheImages = false,
    this.checkerboardOffscreenLayers = false,
    this.showSemanticsDebugger = false,
    this.debugShowCheckedModeBanner = true,
    this.shortcuts,
    this.scrollBehavior,
    this.customTransition,
    this.translationsKeys,
    this.translations,
    this.onInit,
    this.onReady,
    this.onDispose,
    this.routingCallback,
    this.defaultTransition,
    this.getPages,
    this.opaqueRoute,
    this.enableLog = kDebugMode,
    this.logWriterCallback,
    this.popGesture,
    this.transitionDuration,
    this.defaultGlobalState,
    this.smartManagement = SmartManagement.full,
    this.binds = const [],
    this.unknownRoute,
    this.highContrastTheme,
    this.highContrastDarkTheme,
    this.actions,
  })  : routeInformationProvider = null,
        backButtonDispatcher = null,
        routeInformationParser = null,
        routerDelegate = null,
        routerConfig = null;

  const GetMaterialApp.router({
    super.key,
    this.routeInformationProvider,
    this.scaffoldMessengerKey,
    this.routeInformationParser,
    this.routerDelegate,
    this.routerConfig,
    this.backButtonDispatcher,
    this.builder,
    this.title = '',
    this.onGenerateTitle,
    this.color,
    this.theme,
    this.darkTheme,
    this.useInheritedMediaQuery = false,
    this.highContrastTheme,
    this.highContrastDarkTheme,
    this.themeMode = ThemeMode.system,
    this.locale,
    this.localizationsDelegates,
    this.localeListResolutionCallback,
    this.localeResolutionCallback,
    this.supportedLocales = const <Locale>[Locale('en', 'US')],
    this.debugShowMaterialGrid = false,
    this.showPerformanceOverlay = false,
    this.checkerboardRasterCacheImages = false,
    this.checkerboardOffscreenLayers = false,
    this.showSemanticsDebugger = false,
    this.debugShowCheckedModeBanner = true,
    this.shortcuts,
    this.scrollBehavior,
    this.actions,
    this.customTransition,
    this.translationsKeys,
    this.translations,
    this.textDirection,
    this.fallbackLocale,
    this.routingCallback,
    this.defaultTransition,
    this.opaqueRoute,
    this.onInit,
    this.onReady,
    this.onDispose,
    this.enableLog = kDebugMode,
    this.logWriterCallback,
    this.popGesture,
    this.smartManagement = SmartManagement.full,
    this.binds = const [],
    this.transitionDuration,
    this.defaultGlobalState,
    this.getPages,
    this.navigatorObservers,
    this.unknownRoute,
  })  : navigatorKey = null,
        onGenerateRoute = null,
        home = null,
        onGenerateInitialRoutes = null,
        onUnknownRoute = null,
        routes = null,
        initialRoute = null;

  @override
  Widget build(BuildContext context) {
    return GetRoot(
      config: ConfigData(
        backButtonDispatcher: backButtonDispatcher,
        binds: binds,
        customTransition: customTransition,
        defaultGlobalState: defaultGlobalState,
        defaultTransition: defaultTransition,
        enableLog: enableLog,
        fallbackLocale: fallbackLocale,
        getPages: getPages,
        home: home,
        initialRoute: initialRoute,
        locale: locale,
        logWriterCallback: logWriterCallback,
        navigatorKey: navigatorKey,
        navigatorObservers: navigatorObservers,
        onDispose: onDispose,
        onInit: onInit,
        onReady: onReady,
        routeInformationParser: routeInformationParser,
        routeInformationProvider: routeInformationProvider,
        routerDelegate: routerDelegate,
        routingCallback: routingCallback,
        scaffoldMessengerKey: scaffoldMessengerKey,
        smartManagement: smartManagement,
        transitionDuration: transitionDuration,
        translations: translations,
        translationsKeys: translationsKeys,
        unknownRoute: unknownRoute,
        theme: theme,
        darkTheme: darkTheme,
        themeMode: themeMode,
        defaultPopGesture: popGesture,
      ),
      // binds: [
      //   Bind.lazyPut<GetMaterialController>(
      //     () => GetMaterialController(

      //     ),
      //     onClose: () {
      //       Get.clearTranslations();
      //       RouterReportManager.dispose();
      //       Get.resetInstance(clearRouteBindings: true);
      //     },
      //   ),
      //   ...binds,
      // ],
      child: Builder(builder: (context) {
        final controller = GetRoot.of(context);
        return MaterialApp.router(
          routerDelegate: controller.config.routerDelegate,
          routeInformationParser: controller.config.routeInformationParser,
          backButtonDispatcher: backButtonDispatcher,
          routeInformationProvider: routeInformationProvider,
          routerConfig: routerConfig,
          key: controller.config.unikey,
          builder: (context, child) => Directionality(
            textDirection: textDirection ??
                (rtlLanguages.contains(Get.locale?.languageCode)
                    ? TextDirection.rtl
                    : TextDirection.ltr),
            child: builder == null
                ? (child ?? const Material())
                : builder!(context, child ?? const Material()),
          ),
          title: title,
          onGenerateTitle: onGenerateTitle,
          color: color,
          theme: controller.config.theme ?? ThemeData.fallback(),
          darkTheme: controller.config.darkTheme ??
              controller.config.theme ??
              ThemeData.fallback(),
          themeMode: controller.config.themeMode,
          locale: Get.locale ?? locale,
          scaffoldMessengerKey: controller.config.scaffoldMessengerKey,
          localizationsDelegates: localizationsDelegates,
          localeListResolutionCallback: localeListResolutionCallback,
          localeResolutionCallback: localeResolutionCallback,
          supportedLocales: supportedLocales,
          debugShowMaterialGrid: debugShowMaterialGrid,
          showPerformanceOverlay: showPerformanceOverlay,
          checkerboardRasterCacheImages: checkerboardRasterCacheImages,
          checkerboardOffscreenLayers: checkerboardOffscreenLayers,
          showSemanticsDebugger: showSemanticsDebugger,
          debugShowCheckedModeBanner: debugShowCheckedModeBanner,
          shortcuts: shortcuts,
          scrollBehavior: scrollBehavior,
        );
      }),
    );
  }
}
\n\n--- File: 10 # lib/get_navigation/src/root/get_root.dart ---\nimport 'package:flutter/foundation.dart';
import 'package:flutter/material.dart';
import 'package:get/get_navigation/src/routes/test_kit.dart';

import '../../../get.dart';
import '../router_report.dart';

class ConfigData {
  final ValueChanged<Routing?>? routingCallback;
  final Transition? defaultTransition;
  final VoidCallback? onInit;
  final VoidCallback? onReady;
  final VoidCallback? onDispose;
  final bool? enableLog;
  final LogWriterCallback? logWriterCallback;
  final SmartManagement smartManagement;
  final List<Bind> binds;
  final Duration? transitionDuration;
  final bool? defaultGlobalState;
  final List<GetPage>? getPages;
  final GetPage? unknownRoute;
  final RouteInformationProvider? routeInformationProvider;
  final RouteInformationParser<Object>? routeInformationParser;
  final RouterDelegate<Object>? routerDelegate;
  final BackButtonDispatcher? backButtonDispatcher;
  final List<NavigatorObserver>? navigatorObservers;
  final GlobalKey<NavigatorState>? navigatorKey;
  final GlobalKey<ScaffoldMessengerState>? scaffoldMessengerKey;
  final Map<String, Map<String, String>>? translationsKeys;
  final Translations? translations;
  final Locale? locale;
  final Locale? fallbackLocale;
  final String? initialRoute;
  final CustomTransition? customTransition;
  final Widget? home;
  final bool testMode;
  final Key? unikey;
  final ThemeData? theme;
  final ThemeData? darkTheme;
  final ThemeMode? themeMode;
  final bool? defaultPopGesture;
  final bool defaultOpaqueRoute;
  final Duration defaultTransitionDuration;
  final Curve defaultTransitionCurve;
  final Curve defaultDialogTransitionCurve;
  final Duration defaultDialogTransitionDuration;
  final Routing routing;
  final Map<String, String?> parameters;
  final SnackBarQueue snackBarQueue = SnackBarQueue();

  ConfigData({
    required this.routingCallback,
    required this.defaultTransition,
    required this.onInit,
    required this.onReady,
    required this.onDispose,
    required this.enableLog,
    required this.logWriterCallback,
    required this.smartManagement,
    required this.binds,
    required this.transitionDuration,
    required this.defaultGlobalState,
    required this.getPages,
    required this.unknownRoute,
    required this.routeInformationProvider,
    required this.routeInformationParser,
    required this.routerDelegate,
    required this.backButtonDispatcher,
    required this.navigatorObservers,
    required this.navigatorKey,
    required this.scaffoldMessengerKey,
    required this.translationsKeys,
    required this.translations,
    required this.locale,
    required this.fallbackLocale,
    required this.initialRoute,
    required this.customTransition,
    required this.home,
    this.theme,
    this.darkTheme,
    this.themeMode,
    this.unikey,
    this.testMode = false,
    this.defaultOpaqueRoute = true,
    this.defaultTransitionDuration = const Duration(milliseconds: 300),
    this.defaultTransitionCurve = Curves.easeOutQuad,
    this.defaultDialogTransitionCurve = Curves.easeOutQuad,
    this.defaultDialogTransitionDuration = const Duration(milliseconds: 300),
    this.parameters = const {},
    required this.defaultPopGesture,
    Routing? routing,
  }) : routing = routing ?? Routing();

  ConfigData copyWith({
    ValueChanged<Routing?>? routingCallback,
    Transition? defaultTransition,
    VoidCallback? onInit,
    VoidCallback? onReady,
    VoidCallback? onDispose,
    bool? enableLog,
    LogWriterCallback? logWriterCallback,
    SmartManagement? smartManagement,
    List<Bind>? binds,
    Duration? transitionDuration,
    bool? defaultGlobalState,
    List<GetPage>? getPages,
    GetPage? unknownRoute,
    RouteInformationProvider? routeInformationProvider,
    RouteInformationParser<Object>? routeInformationParser,
    RouterDelegate<Object>? routerDelegate,
    BackButtonDispatcher? backButtonDispatcher,
    List<NavigatorObserver>? navigatorObservers,
    GlobalKey<NavigatorState>? navigatorKey,
    GlobalKey<ScaffoldMessengerState>? scaffoldMessengerKey,
    Map<String, Map<String, String>>? translationsKeys,
    Translations? translations,
    Locale? locale,
    Locale? fallbackLocale,
    String? initialRoute,
    CustomTransition? customTransition,
    Widget? home,
    bool? testMode,
    Key? unikey,
    ThemeData? theme,
    ThemeData? darkTheme,
    ThemeMode? themeMode,
    bool? defaultPopGesture,
    bool? defaultOpaqueRoute,
    Duration? defaultTransitionDuration,
    Curve? defaultTransitionCurve,
    Curve? defaultDialogTransitionCurve,
    Duration? defaultDialogTransitionDuration,
    Routing? routing,
    Map<String, String?>? parameters,
  }) {
    return ConfigData(
      routingCallback: routingCallback ?? this.routingCallback,
      defaultTransition: defaultTransition ?? this.defaultTransition,
      onInit: onInit ?? this.onInit,
      onReady: onReady ?? this.onReady,
      onDispose: onDispose ?? this.onDispose,
      enableLog: enableLog ?? this.enableLog,
      logWriterCallback: logWriterCallback ?? this.logWriterCallback,
      smartManagement: smartManagement ?? this.smartManagement,
      binds: binds ?? this.binds,
      transitionDuration: transitionDuration ?? this.transitionDuration,
      defaultGlobalState: defaultGlobalState ?? this.defaultGlobalState,
      getPages: getPages ?? this.getPages,
      unknownRoute: unknownRoute ?? this.unknownRoute,
      routeInformationProvider:
          routeInformationProvider ?? this.routeInformationProvider,
      routeInformationParser:
          routeInformationParser ?? this.routeInformationParser,
      routerDelegate: routerDelegate ?? this.routerDelegate,
      backButtonDispatcher: backButtonDispatcher ?? this.backButtonDispatcher,
      navigatorObservers: navigatorObservers ?? this.navigatorObservers,
      navigatorKey: navigatorKey ?? this.navigatorKey,
      scaffoldMessengerKey: scaffoldMessengerKey ?? this.scaffoldMessengerKey,
      translationsKeys: translationsKeys ?? this.translationsKeys,
      translations: translations ?? this.translations,
      locale: locale ?? this.locale,
      fallbackLocale: fallbackLocale ?? this.fallbackLocale,
      initialRoute: initialRoute ?? this.initialRoute,
      customTransition: customTransition ?? this.customTransition,
      home: home ?? this.home,
      testMode: testMode ?? this.testMode,
      unikey: unikey ?? this.unikey,
      theme: theme ?? this.theme,
      darkTheme: darkTheme ?? this.darkTheme,
      themeMode: themeMode ?? this.themeMode,
      defaultPopGesture: defaultPopGesture ?? this.defaultPopGesture,
      defaultOpaqueRoute: defaultOpaqueRoute ?? this.defaultOpaqueRoute,
      defaultTransitionDuration:
          defaultTransitionDuration ?? this.defaultTransitionDuration,
      defaultTransitionCurve:
          defaultTransitionCurve ?? this.defaultTransitionCurve,
      defaultDialogTransitionCurve:
          defaultDialogTransitionCurve ?? this.defaultDialogTransitionCurve,
      defaultDialogTransitionDuration: defaultDialogTransitionDuration ??
          this.defaultDialogTransitionDuration,
      routing: routing ?? this.routing,
      parameters: parameters ?? this.parameters,
    );
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;

    return other is ConfigData &&
        other.routingCallback == routingCallback &&
        other.defaultTransition == defaultTransition &&
        other.onInit == onInit &&
        other.onReady == onReady &&
        other.onDispose == onDispose &&
        other.enableLog == enableLog &&
        other.logWriterCallback == logWriterCallback &&
        other.smartManagement == smartManagement &&
        listEquals(other.binds, binds) &&
        other.transitionDuration == transitionDuration &&
        other.defaultGlobalState == defaultGlobalState &&
        listEquals(other.getPages, getPages) &&
        other.unknownRoute == unknownRoute &&
        other.routeInformationProvider == routeInformationProvider &&
        other.routeInformationParser == routeInformationParser &&
        other.routerDelegate == routerDelegate &&
        other.backButtonDispatcher == backButtonDispatcher &&
        listEquals(other.navigatorObservers, navigatorObservers) &&
        other.navigatorKey == navigatorKey &&
        other.scaffoldMessengerKey == scaffoldMessengerKey &&
        mapEquals(other.translationsKeys, translationsKeys) &&
        other.translations == translations &&
        other.locale == locale &&
        other.fallbackLocale == fallbackLocale &&
        other.initialRoute == initialRoute &&
        other.customTransition == customTransition &&
        other.home == home &&
        other.testMode == testMode &&
        other.unikey == unikey &&
        other.theme == theme &&
        other.darkTheme == darkTheme &&
        other.themeMode == themeMode &&
        other.defaultPopGesture == defaultPopGesture &&
        other.defaultOpaqueRoute == defaultOpaqueRoute &&
        other.defaultTransitionDuration == defaultTransitionDuration &&
        other.defaultTransitionCurve == defaultTransitionCurve &&
        other.defaultDialogTransitionCurve == defaultDialogTransitionCurve &&
        other.defaultDialogTransitionDuration ==
            defaultDialogTransitionDuration &&
        other.routing == routing &&
        mapEquals(other.parameters, parameters);
  }

  @override
  int get hashCode {
    return routingCallback.hashCode ^
        defaultTransition.hashCode ^
        onInit.hashCode ^
        onReady.hashCode ^
        onDispose.hashCode ^
        enableLog.hashCode ^
        logWriterCallback.hashCode ^
        smartManagement.hashCode ^
        binds.hashCode ^
        transitionDuration.hashCode ^
        defaultGlobalState.hashCode ^
        getPages.hashCode ^
        unknownRoute.hashCode ^
        routeInformationProvider.hashCode ^
        routeInformationParser.hashCode ^
        routerDelegate.hashCode ^
        backButtonDispatcher.hashCode ^
        navigatorObservers.hashCode ^
        navigatorKey.hashCode ^
        scaffoldMessengerKey.hashCode ^
        translationsKeys.hashCode ^
        translations.hashCode ^
        locale.hashCode ^
        fallbackLocale.hashCode ^
        initialRoute.hashCode ^
        customTransition.hashCode ^
        home.hashCode ^
        testMode.hashCode ^
        unikey.hashCode ^
        theme.hashCode ^
        darkTheme.hashCode ^
        themeMode.hashCode ^
        defaultPopGesture.hashCode ^
        defaultOpaqueRoute.hashCode ^
        defaultTransitionDuration.hashCode ^
        defaultTransitionCurve.hashCode ^
        defaultDialogTransitionCurve.hashCode ^
        defaultDialogTransitionDuration.hashCode ^
        routing.hashCode ^
        parameters.hashCode;
  }
}

class GetRoot extends StatefulWidget {
  const GetRoot({
    super.key,
    required this.config,
    required this.child,
  });
  final ConfigData config;
  final Widget child;
  @override
  State<GetRoot> createState() => GetRootState();

  static bool get treeInitialized => GetRootState._controller != null;

  static GetRootState of(BuildContext context) {
    // Handles the case where the input context is a navigator element.
    GetRootState? root;
    if (context is StatefulElement && context.state is GetRootState) {
      root = context.state as GetRootState;
    }
    root = context.findRootAncestorStateOfType<GetRootState>() ?? root;
    assert(() {
      if (root == null) {
        throw FlutterError(
          'GetRoot operation requested with a context that does not include a GetRoot.\n'
          'The context used must be that of a '
          'widget that is a descendant of a GetRoot widget.',
        );
      }
      return true;
    }());
    return root!;
  }
}

class GetRootState extends State<GetRoot> with WidgetsBindingObserver {
  static GetRootState? _controller;
  static GetRootState get controller {
    if (_controller == null) {
      throw Exception('GetRoot is not part of the three');
    } else {
      return _controller!;
    }
  }

  late ConfigData config;

  @override
  void initState() {
    config = widget.config;
    GetRootState._controller = this;
    Engine.instance.addObserver(this);
    onInit();
    super.initState();
  }

  // @override
  // void didUpdateWidget(covariant GetRoot oldWidget) {
  //   if (oldWidget.config != widget.config) {
  //     config = widget.config;
  //   }

  //   super.didUpdateWidget(oldWidget);
  // }

  void onClose() {
    config.onDispose?.call();
    Get.clearTranslations();
    config.snackBarQueue.disposeControllers();
    RouterReportManager.instance.clearRouteKeys();
    RouterReportManager.dispose();
    Get.resetInstance(clearRouteBindings: true);
    _controller = null;
    Engine.instance.removeObserver(this);
  }

  @override
  void dispose() {
    onClose();
    super.dispose();
  }

  void onInit() {
    if (config.getPages == null && config.home == null) {
      throw 'You need add pages or home';
    }

    if (config.routerDelegate == null) {
      final newDelegate = GetDelegate.createDelegate(
        pages: config.getPages ??
            [
              GetPage(
                name: cleanRouteName("/${config.home.runtimeType}"),
                page: () => config.home!,
              ),
            ],
        notFoundRoute: config.unknownRoute,
        navigatorKey: config.navigatorKey,
        navigatorObservers: (config.navigatorObservers == null
            ? <NavigatorObserver>[
                GetObserver(config.routingCallback, Get.routing)
              ]
            : <NavigatorObserver>[
                GetObserver(config.routingCallback, config.routing),
                ...config.navigatorObservers!
              ]),
      );
      config = config.copyWith(routerDelegate: newDelegate);
    }

    if (config.routeInformationParser == null) {
      final newRouteInformationParser =
          GetInformationParser.createInformationParser(
        initialRoute: config.initialRoute ??
            config.getPages?.first.name ??
            cleanRouteName("/${config.home.runtimeType}"),
      );

      config =
          config.copyWith(routeInformationParser: newRouteInformationParser);
    }

    if (config.locale != null) Get.locale = config.locale;

    if (config.fallbackLocale != null) {
      Get.fallbackLocale = config.fallbackLocale;
    }

    if (config.translations != null) {
      Get.addTranslations(config.translations!.keys);
    } else if (config.translationsKeys != null) {
      Get.addTranslations(config.translationsKeys!);
    }

    Get.smartManagement = config.smartManagement;
    config.onInit?.call();

    Get.isLogEnable = config.enableLog ?? kDebugMode;
    Get.log = config.logWriterCallback ?? defaultLogWriterCallback;

    if (config.defaultTransition == null) {
      config = config.copyWith(defaultTransition: getThemeTransition());
    }

    // defaultOpaqueRoute = config.opaqueRoute ?? true;
    // defaultPopGesture = config.popGesture ?? GetPlatform.isIOS;
    // defaultTransitionDuration =
    //     config.transitionDuration ?? Duration(milliseconds: 300);

    Future(() => onReady());
  }

  set parameters(Map<String, String?> newParameters) {
    // rootController.parameters = newParameters;
    config = config.copyWith(parameters: newParameters);
  }

  set testMode(bool isTest) {
    config = config.copyWith(testMode: isTest);
    GetTestMode.active = isTest;
  }

  void onReady() {
    config.onReady?.call();
  }

  Transition? getThemeTransition() {
    final platform = context.theme.platform;
    final matchingTransition =
        Get.theme.pageTransitionsTheme.builders[platform];
    switch (matchingTransition) {
      case CupertinoPageTransitionsBuilder():
        return Transition.cupertino;
      case ZoomPageTransitionsBuilder():
        return Transition.zoom;
      case FadeUpwardsPageTransitionsBuilder():
        return Transition.fade;
      case OpenUpwardsPageTransitionsBuilder():
        return Transition.native;
      default:
        return null;
    }
  }

  @override
  void didChangeLocales(List<Locale>? locales) {
    Get.asap(() {
      final locale = Get.deviceLocale;
      if (locale != null) {
        Get.updateLocale(locale);
      }
    });
  }

  void setTheme(ThemeData value) {
    if (config.darkTheme == null) {
      config = config.copyWith(theme: value);
    } else {
      if (value.brightness == Brightness.light) {
        config = config.copyWith(theme: value);
      } else {
        config = config.copyWith(darkTheme: value);
      }
    }
    update();
  }

  void setThemeMode(ThemeMode value) {
    config = config.copyWith(themeMode: value);
    update();
  }

  void restartApp() {
    config = config.copyWith(unikey: UniqueKey());
    update();
  }

  void update() {
    context.visitAncestorElements((element) {
      element.markNeedsBuild();
      return false;
    });
  }

  GlobalKey<NavigatorState> get key => rootDelegate.navigatorKey;

  GetDelegate get rootDelegate => config.routerDelegate as GetDelegate;

  RouteInformationParser<Object> get informationParser =>
      config.routeInformationParser!;

  GlobalKey<NavigatorState>? addKey(GlobalKey<NavigatorState> newKey) {
    rootDelegate.navigatorKey = newKey;
    return key;
  }

  Map<String, GetDelegate> keys = {};

  GetDelegate? nestedKey(String? key) {
    if (key == null) {
      return rootDelegate;
    }
    keys.putIfAbsent(
      key,
      () => GetDelegate(
        showHashOnUrl: true,
        //debugLabel: 'Getx nested key: ${key.toString()}',
        pages: RouteDecoder.fromRoute(key).currentChildren ?? [],
      ),
    );
    return keys[key];
  }

  @override
  Widget build(BuildContext context) {
    return widget.child;
  }

  String cleanRouteName(String name) {
    name = name.replaceAll('() => ', '');

    /// uncomment for URL styling.
    // name = name.paramCase!;
    if (!name.startsWith('/')) {
      name = '/$name';
    }
    return Uri.tryParse(name)?.toString() ?? name;
  }
}
\n\n--- File: 11 # lib/get_navigation/src/routes/default_transitions.dart ---\nimport 'package:flutter/cupertino.dart';
import 'package:flutter/material.dart';

import 'circular_reveal_clipper.dart';

class LeftToRightFadeTransition {
  Widget buildTransitions(
      BuildContext context,
      Curve? curve,
      Alignment? alignment,
      Animation<double> animation,
      Animation<double> secondaryAnimation,
      Widget child) {
    return SlideTransition(
      position: Tween<Offset>(
        begin: const Offset(-1.0, 0.0),
        end: Offset.zero,
      ).animate(animation),
      child: FadeTransition(
        opacity: animation,
        child: SlideTransition(
            position: Tween<Offset>(
              begin: Offset.zero,
              end: const Offset(1.0, 0.0),
            ).animate(secondaryAnimation),
            child: child),
      ),
    );
  }
}

class RightToLeftFadeTransition {
  Widget buildTransitions(
      BuildContext context,
      Curve? curve,
      Alignment? alignment,
      Animation<double> animation,
      Animation<double> secondaryAnimation,
      Widget child) {
    return SlideTransition(
      position: Tween<Offset>(
        begin: const Offset(1.0, 0.0),
        end: Offset.zero,
      ).animate(animation),
      child: FadeTransition(
        opacity: animation,
        child: SlideTransition(
            position: Tween<Offset>(
              begin: Offset.zero,
              end: const Offset(-1.0, 0.0),
            ).animate(secondaryAnimation),
            child: child),
      ),
    );
  }
}

class NoTransition {
  Widget buildTransitions(
      BuildContext context,
      Curve curve,
      Alignment alignment,
      Animation<double> animation,
      Animation<double> secondaryAnimation,
      Widget child) {
    return child;
  }
}

class FadeInTransition {
  Widget buildTransitions(
      BuildContext context,
      Curve? curve,
      Alignment? alignment,
      Animation<double> animation,
      Animation<double> secondaryAnimation,
      Widget child) {
    return FadeTransition(opacity: animation, child: child);
  }
}

class SlideDownTransition {
  Widget buildTransitions(
      BuildContext context,
      Curve? curve,
      Alignment? alignment,
      Animation<double> animation,
      Animation<double> secondaryAnimation,
      Widget child) {
    return SlideTransition(
      position: Tween<Offset>(
        begin: const Offset(0.0, 1.0),
        end: Offset.zero,
      ).animate(animation),
      child: child,
    );
  }
}

class SlideLeftTransition {
  Widget buildTransitions(
      BuildContext context,
      Curve? curve,
      Alignment? alignment,
      Animation<double> animation,
      Animation<double> secondaryAnimation,
      Widget child) {
    return SlideTransition(
      position: Tween<Offset>(
        begin: const Offset(-1.0, 0.0),
        end: Offset.zero,
      ).animate(animation),
      child: child,
    );
  }
}

class SlideRightTransition {
  Widget buildTransitions(
      BuildContext context,
      Curve? curve,
      Alignment? alignment,
      Animation<double> animation,
      Animation<double> secondaryAnimation,
      Widget child) {
    return SlideTransition(
      position: Tween<Offset>(
        begin: const Offset(1.0, 0.0),
        end: Offset.zero,
      ).animate(animation),
      child: child,
    );
  }
}

class SlideTopTransition {
  Widget buildTransitions(
      BuildContext context,
      Curve? curve,
      Alignment? alignment,
      Animation<double> animation,
      Animation<double> secondaryAnimation,
      Widget child) {
    return SlideTransition(
      position: Tween<Offset>(
        begin: const Offset(0.0, -1.0),
        end: Offset.zero,
      ).animate(animation),
      child: child,
    );
  }
}

class ZoomInTransition {
  Widget buildTransitions(
      BuildContext context,
      Curve? curve,
      Alignment? alignment,
      Animation<double> animation,
      Animation<double> secondaryAnimation,
      Widget child) {
    return ScaleTransition(
      scale: animation,
      child: child,
    );
  }
}

class SizeTransitions {
  Widget buildTransitions(
      BuildContext context,
      Curve curve,
      Alignment? alignment,
      Animation<double> animation,
      Animation<double> secondaryAnimation,
      Widget child) {
    return Align(
      alignment: Alignment.center,
      child: SizeTransition(
        sizeFactor: CurvedAnimation(
          parent: animation,
          curve: curve,
        ),
        child: child,
      ),
    );
  }
}

class CircularRevealTransition {
  Widget buildTransitions(
      BuildContext context,
      Curve? curve,
      Alignment? alignment,
      Animation<double> animation,
      Animation<double> secondaryAnimation,
      Widget child) {
    return ClipPath(
      clipper: CircularRevealClipper(
        fraction: animation.value,
        centerAlignment: Alignment.center,
        centerOffset: Offset.zero,
        minRadius: 0,
        maxRadius: 800,
      ),
      child: child,
    );
  }
}
\n\n--- File: 12 # lib/get_navigation/src/routes/get_router_delegate.dart ---\nimport 'dart:async';

import 'package:flutter/foundation.dart';
import 'package:flutter/material.dart';

import '../../../get_instance/src/bindings_interface.dart';
import '../../../get_utils/src/platform/platform.dart';
import '../../../route_manager.dart';

class GetDelegate extends RouterDelegate<RouteDecoder>
    with
        ChangeNotifier,
        PopNavigatorRouterDelegateMixin<RouteDecoder>,
        IGetNavigation {
  factory GetDelegate.createDelegate({
    GetPage<dynamic>? notFoundRoute,
    List<GetPage> pages = const [],
    List<NavigatorObserver>? navigatorObservers,
    TransitionDelegate<dynamic>? transitionDelegate,
    PopMode backButtonPopMode = PopMode.history,
    PreventDuplicateHandlingMode preventDuplicateHandlingMode =
        PreventDuplicateHandlingMode.reorderRoutes,
    GlobalKey<NavigatorState>? navigatorKey,
  }) {
    return GetDelegate(
      notFoundRoute: notFoundRoute,
      navigatorObservers: navigatorObservers,
      transitionDelegate: transitionDelegate,
      backButtonPopMode: backButtonPopMode,
      preventDuplicateHandlingMode: preventDuplicateHandlingMode,
      pages: pages,
      navigatorKey: navigatorKey,
    );
  }

  final List<RouteDecoder> _activePages = <RouteDecoder>[];
  final PopMode backButtonPopMode;
  final PreventDuplicateHandlingMode preventDuplicateHandlingMode;

  final GetPage notFoundRoute;

  final List<NavigatorObserver>? navigatorObservers;
  final TransitionDelegate<dynamic>? transitionDelegate;

  final Iterable<GetPage> Function(RouteDecoder currentNavStack)?
      pickPagesForRootNavigator;

  List<RouteDecoder> get activePages => _activePages;

  final _routeTree = ParseRouteTree(routes: []);

  List<GetPage> get registeredRoutes => _routeTree.routes;

  void addPages(List<GetPage> getPages) {
    _routeTree.addRoutes(getPages);
  }

  void clearRouteTree() {
    _routeTree.routes.clear();
  }

  void addPage(GetPage getPage) {
    _routeTree.addRoute(getPage);
  }

  void removePage(GetPage getPage) {
    _routeTree.removeRoute(getPage);
  }

  RouteDecoder matchRoute(String name, {PageSettings? arguments}) {
    return _routeTree.matchRoute(name, arguments: arguments);
  }

  // GlobalKey<NavigatorState> get navigatorKey => Get.key;

  @override
  GlobalKey<NavigatorState> navigatorKey;

  final String? restorationScopeId;

  GetDelegate({
    GetPage? notFoundRoute,
    this.navigatorObservers,
    this.transitionDelegate,
    this.backButtonPopMode = PopMode.history,
    this.preventDuplicateHandlingMode =
        PreventDuplicateHandlingMode.reorderRoutes,
    this.pickPagesForRootNavigator,
    this.restorationScopeId,
    bool showHashOnUrl = false,
    GlobalKey<NavigatorState>? navigatorKey,
    required List<GetPage> pages,
  })  : navigatorKey = navigatorKey ?? GlobalKey<NavigatorState>(),
        notFoundRoute = notFoundRoute ??= GetPage(
          name: '/404',
          page: () => const Scaffold(
            body: Center(child: Text('Route not found')),
          ),
        ) {
    if (!showHashOnUrl && GetPlatform.isWeb) setUrlStrategy();
    addPages(pages);
    addPage(notFoundRoute);
    Get.log('GetDelegate is created !');
  }

  Future<RouteDecoder?> runMiddleware(RouteDecoder config) async {
    final middlewares = config.currentTreeBranch.last.middlewares;
    if (middlewares.isEmpty) {
      return config;
    }
    var iterator = config;
    for (var item in middlewares) {
      var redirectRes = await item.redirectDelegate(iterator);

      if (redirectRes == null) {
        config.route?.completer?.complete();
        return null;
      }
      if (config != redirectRes) {
        config.route?.completer?.complete();
        Get.log('Redirect to ${redirectRes.pageSettings?.name}');
      }

      iterator = redirectRes;
      // Stop the iteration over the middleware if we changed page
      // and that redirectRes is not the same as the current config.
      if (config != redirectRes) {
        break;
      }
    }
    // If the target is not the same as the source, we need
    // to run the middlewares for the new route.
    if (iterator != config) {
      return await runMiddleware(iterator);
    }
    return iterator;
  }

  Future<void> _unsafeHistoryAdd(RouteDecoder config) async {
    final res = await runMiddleware(config);
    if (res == null) return;
    _activePages.add(res);
  }

  // Future<T?> _unsafeHistoryRemove<T>(RouteDecoder config, T result) async {
  //   var index = _activePages.indexOf(config);
  //   if (index >= 0) return _unsafeHistoryRemoveAt(index, result);
  //   return null;
  // }

  Future<T?> _unsafeHistoryRemoveAt<T>(int index, T result) async {
    if (index == _activePages.length - 1 && _activePages.length > 1) {
      //removing WILL update the current route
      final toCheck = _activePages[_activePages.length - 2];
      final resMiddleware = await runMiddleware(toCheck);
      if (resMiddleware == null) return null;
      _activePages[_activePages.length - 2] = resMiddleware;
    }

    final completer = _activePages.removeAt(index).route?.completer;
    if (completer?.isCompleted == false) completer!.complete(result);

    return completer?.future as T?;
  }

  T arguments<T>() {
    return currentConfiguration?.pageSettings?.arguments as T;
  }

  Map<String, String> get parameters {
    return currentConfiguration?.pageSettings?.params ?? {};
  }

  PageSettings? get pageSettings {
    return currentConfiguration?.pageSettings;
  }

  Future<void> _pushHistory(RouteDecoder config) async {
    if (config.route!.preventDuplicates) {
      final originalEntryIndex = _activePages.indexWhere(
          (element) => element.pageSettings?.name == config.pageSettings?.name);
      if (originalEntryIndex >= 0) {
        switch (preventDuplicateHandlingMode) {
          case PreventDuplicateHandlingMode.popUntilOriginalRoute:
            popModeUntil(config.pageSettings!.name, popMode: PopMode.page);
            break;
          case PreventDuplicateHandlingMode.reorderRoutes:
            await _unsafeHistoryRemoveAt(originalEntryIndex, null);
            await _unsafeHistoryAdd(config);
            break;
          case PreventDuplicateHandlingMode.doNothing:
          default:
            break;
        }
        return;
      }
    }
    await _unsafeHistoryAdd(config);
  }

  Future<T?> _popHistory<T>(T result) async {
    if (!_canPopHistory()) return null;
    return await _doPopHistory(result);
  }

  Future<T?> _doPopHistory<T>(T result) async {
    return _unsafeHistoryRemoveAt<T>(_activePages.length - 1, result);
  }

  Future<T?> _popPage<T>(T result) async {
    if (!_canPopPage()) return null;
    return await _doPopPage(result);
  }

  // returns the popped page
  Future<T?> _doPopPage<T>(T result) async {
    final currentBranch = currentConfiguration?.currentTreeBranch;
    if (currentBranch != null && currentBranch.length > 1) {
      //remove last part only
      final remaining = currentBranch.take(currentBranch.length - 1);
      final prevHistoryEntry = _activePages.length > 1
          ? _activePages[_activePages.length - 2]
          : null;

      //check if current route is the same as the previous route
      if (prevHistoryEntry != null) {
        //if so, pop the entire _activePages entry
        final newLocation = remaining.last.name;
        final prevLocation = prevHistoryEntry.pageSettings?.name;
        if (newLocation == prevLocation) {
          //pop the entire _activePages entry
          return await _popHistory(result);
        }
      }

      //create a new route with the remaining tree branch
      final res = await _popHistory<T>(result);
      await _pushHistory(
        RouteDecoder(
          remaining.toList(),
          null,
          //TOOD: persist state??
        ),
      );
      return res;
    } else {
      //remove entire entry
      return await _popHistory(result);
    }
  }

  Future<T?> _pop<T>(PopMode mode, T result) async {
    switch (mode) {
      case PopMode.history:
        return await _popHistory<T>(result);
      case PopMode.page:
        return await _popPage<T>(result);
    }
  }

  Future<T?> popHistory<T>(T result) async {
    return await _popHistory<T>(result);
  }

  bool _canPopHistory() {
    return _activePages.length > 1;
  }

  Future<bool> canPopHistory() {
    return SynchronousFuture(_canPopHistory());
  }

  bool _canPopPage() {
    final currentTreeBranch = currentConfiguration?.currentTreeBranch;
    if (currentTreeBranch == null) return false;
    return currentTreeBranch.length > 1 ? true : _canPopHistory();
  }

  Future<bool> canPopPage() {
    return SynchronousFuture(_canPopPage());
  }

  bool _canPop(mode) {
    switch (mode) {
      case PopMode.history:
        return _canPopHistory();
      case PopMode.page:
      default:
        return _canPopPage();
    }
  }

  /// gets the visual pages from the current _activePages entry
  ///
  /// visual pages must have [GetPage.participatesInRootNavigator] set to true
  Iterable<GetPage> getVisualPages(RouteDecoder? currentHistory) {
    final res = currentHistory!.currentTreeBranch
        .where((r) => r.participatesInRootNavigator != null);
    if (res.isEmpty) {
      //default behavior, all routes participate in root navigator
      return _activePages.map((e) => e.route!);
    } else {
      //user specified at least one participatesInRootNavigator
      return res
          .where((element) => element.participatesInRootNavigator == true);
    }
  }

  @override
  Widget build(BuildContext context) {
    final currentHistory = currentConfiguration;
    final pages = currentHistory == null
        ? <GetPage>[]
        : pickPagesForRootNavigator?.call(currentHistory).toList() ??
            getVisualPages(currentHistory).toList();
    if (pages.isEmpty) {
      return ColoredBox(
        color: Theme.of(context).scaffoldBackgroundColor,
      );
    }
    return GetNavigator(
      key: navigatorKey,
      onPopPage: _onPopVisualRoute,
      pages: pages,
      observers: navigatorObservers,
      transitionDelegate:
          transitionDelegate ?? const DefaultTransitionDelegate<dynamic>(),
    );
  }

  @override
  Future<void> goToUnknownPage([bool clearPages = false]) async {
    if (clearPages) _activePages.clear();

    final pageSettings = _buildPageSettings(notFoundRoute.name);
    final routeDecoder = _getRouteDecoder(pageSettings);

    _push(routeDecoder!);
  }

  @protected
  void _popWithResult<T>([T? result]) {
    final completer = _activePages.removeLast().route?.completer;
    if (completer?.isCompleted == false) completer!.complete(result);
  }

  @override
  Future<T?> toNamed<T>(
    String page, {
    dynamic arguments,
    dynamic id,
    bool preventDuplicates = true,
    Map<String, String>? parameters,
  }) async {
    final args = _buildPageSettings(page, arguments);
    final route = _getRouteDecoder<T>(args);
    if (route != null) {
      return _push<T>(route);
    } else {
      goToUnknownPage();
    }
    return null;
  }

  @override
  Future<T?> to<T>(
    Widget Function() page, {
    bool? opaque,
    Transition? transition,
    Curve? curve,
    Duration? duration,
    String? id,
    String? routeName,
    bool fullscreenDialog = false,
    dynamic arguments,
    List<BindingsInterface> bindings = const [],
    bool preventDuplicates = true,
    bool? popGesture,
    bool showCupertinoParallax = true,
    double Function(BuildContext context)? gestureWidth,
    bool rebuildStack = true,
    PreventDuplicateHandlingMode preventDuplicateHandlingMode =
        PreventDuplicateHandlingMode.reorderRoutes,
  }) async {
    routeName ??= _cleanRouteName("/${page.runtimeType}");
    // if (preventDuplicateHandlingMode ==
    //PreventDuplicateHandlingMode.Recreate) {
    //   routeName = routeName + page.hashCode.toString();
    // }

    final getPage = GetPage<T>(
      name: routeName,
      opaque: opaque ?? true,
      page: page,
      gestureWidth: gestureWidth,
      showCupertinoParallax: showCupertinoParallax,
      popGesture: popGesture ?? Get.defaultPopGesture,
      transition: transition ?? Get.defaultTransition,
      curve: curve ?? Get.defaultTransitionCurve,
      fullscreenDialog: fullscreenDialog,
      bindings: bindings,
      transitionDuration: duration ?? Get.defaultTransitionDuration,
      preventDuplicateHandlingMode: preventDuplicateHandlingMode,
    );

    _routeTree.addRoute(getPage);
    final args = _buildPageSettings(routeName, arguments);
    final route = _getRouteDecoder<T>(args);
    final result = await _push<T>(
      route!,
      rebuildStack: rebuildStack,
    );
    _routeTree.removeRoute(getPage);
    return result;
  }

  @override
  Future<T?> off<T>(
    Widget Function() page, {
    bool? opaque,
    Transition? transition,
    Curve? curve,
    Duration? duration,
    String? id,
    String? routeName,
    bool fullscreenDialog = false,
    dynamic arguments,
    List<BindingsInterface> bindings = const [],
    bool preventDuplicates = true,
    bool? popGesture,
    bool showCupertinoParallax = true,
    double Function(BuildContext context)? gestureWidth,
  }) async {
    routeName ??= _cleanRouteName("/${page.runtimeType}");
    final route = GetPage<T>(
      name: routeName,
      opaque: opaque ?? true,
      page: page,
      gestureWidth: gestureWidth,
      showCupertinoParallax: showCupertinoParallax,
      popGesture: popGesture ?? Get.defaultPopGesture,
      transition: transition ?? Get.defaultTransition,
      curve: curve ?? Get.defaultTransitionCurve,
      fullscreenDialog: fullscreenDialog,
      bindings: bindings,
      transitionDuration: duration ?? Get.defaultTransitionDuration,
    );

    final args = _buildPageSettings(routeName, arguments);
    return _replace(args, route);
  }

  @override
  Future<T?>? offAll<T>(
    Widget Function() page, {
    bool Function(GetPage route)? predicate,
    bool opaque = true,
    bool? popGesture,
    String? id,
    String? routeName,
    dynamic arguments,
    List<BindingsInterface> bindings = const [],
    bool fullscreenDialog = false,
    Transition? transition,
    Curve? curve,
    Duration? duration,
    bool showCupertinoParallax = true,
    double Function(BuildContext context)? gestureWidth,
  }) async {
    routeName ??= _cleanRouteName("/${page.runtimeType}");
    final route = GetPage<T>(
      name: routeName,
      opaque: opaque,
      page: page,
      gestureWidth: gestureWidth,
      showCupertinoParallax: showCupertinoParallax,
      popGesture: popGesture ?? Get.defaultPopGesture,
      transition: transition ?? Get.defaultTransition,
      curve: curve ?? Get.defaultTransitionCurve,
      fullscreenDialog: fullscreenDialog,
      bindings: bindings,
      transitionDuration: duration ?? Get.defaultTransitionDuration,
    );

    final args = _buildPageSettings(routeName, arguments);

    final newPredicate = predicate ?? (route) => false;

    while (_activePages.length > 1 && !newPredicate(_activePages.last.route!)) {
      _popWithResult();
    }

    return _replace(args, route);
  }

  @override
  Future<T?>? offAllNamed<T>(
    String newRouteName, {
    // bool Function(GetPage route)? predicate,
    dynamic arguments,
    String? id,
    Map<String, String>? parameters,
  }) async {
    final args = _buildPageSettings(newRouteName, arguments);
    final route = _getRouteDecoder<T>(args);
    if (route == null) return null;

    while (_activePages.length > 1) {
      _activePages.removeLast();
    }

    return _replaceNamed(route);
  }

  @override
  Future<T?>? offNamedUntil<T>(
    String page, {
    bool Function(GetPage route)? predicate,
    dynamic arguments,
    String? id,
    Map<String, String>? parameters,
  }) async {
    final args = _buildPageSettings(page, arguments);
    final route = _getRouteDecoder<T>(args);
    if (route == null) return null;

    final newPredicate = predicate ?? (route) => false;

    while (_activePages.length > 1 && !newPredicate(_activePages.last.route!)) {
      _activePages.removeLast();
    }

    return _push(route);
  }

  @override
  Future<T?> offNamed<T>(
    String page, {
    dynamic arguments,
    String? id,
    Map<String, String>? parameters,
  }) async {
    final args = _buildPageSettings(page, arguments);
    final route = _getRouteDecoder<T>(args);
    if (route == null) return null;
    _popWithResult();
    return _push<T>(route);
  }

  @override
  Future<T?> toNamedAndOffUntil<T>(
    String page,
    bool Function(GetPage) predicate, [
    Object? data,
  ]) async {
    final arguments = _buildPageSettings(page, data);

    final route = _getRouteDecoder<T>(arguments);

    if (route == null) return null;

    while (_activePages.isNotEmpty && !predicate(_activePages.last.route!)) {
      _popWithResult();
    }

    return _push<T>(route);
  }

  @override
  Future<T?> offUntil<T>(
    Widget Function() page,
    bool Function(GetPage) predicate, [
    Object? arguments,
  ]) async {
    while (_activePages.isNotEmpty && !predicate(_activePages.last.route!)) {
      _popWithResult();
    }

    return to<T>(page, arguments: arguments);
  }

  @override
  void removeRoute<T>(String name) {
    _activePages.remove(RouteDecoder.fromRoute(name));
  }

  bool get canBack {
    return _activePages.length > 1;
  }

  void _checkIfCanBack() {
    assert(() {
      if (!canBack) {
        final last = _activePages.last;
        final name = last.route?.name;
        throw 'The page $name cannot be popped';
      }
      return true;
    }());
  }

  @override
  Future<R?> backAndtoNamed<T, R>(String page,
      {T? result, Object? arguments}) async {
    final args = _buildPageSettings(page, arguments);
    final route = _getRouteDecoder<R>(args);
    if (route == null) return null;
    _popWithResult<T>(result);
    return _push<R>(route);
  }

  /// Removes routes according to [PopMode]
  /// until it reaches the specific [fullRoute],
  /// DOES NOT remove the [fullRoute]
  @override
  Future<void> popModeUntil(
    String fullRoute, {
    PopMode popMode = PopMode.history,
  }) async {
    // remove history or page entries until you meet route
    var iterator = currentConfiguration;
    while (_canPop(popMode) && iterator != null) {
      //the next line causes wasm compile error if included in the while loop
      //https://github.com/flutter/flutter/issues/140110
      if (iterator.pageSettings?.name == fullRoute) {
        break;
      }
      await _pop(popMode, null);
      // replace iterator
      iterator = currentConfiguration;
    }
    notifyListeners();
  }

  @override
  void backUntil(bool Function(GetPage) predicate) {
    while (_activePages.length > 1 && !predicate(_activePages.last.route!)) {
      _popWithResult();
    }

    notifyListeners();
  }

  Future<T?> _replace<T>(PageSettings arguments, GetPage<T> page) async {
    final index = _activePages.length > 1 ? _activePages.length - 1 : 0;
    _routeTree.addRoute(page);

    final activePage = _getRouteDecoder(arguments);

    // final activePage = _configureRouterDecoder<T>(route!, arguments);

    _activePages[index] = activePage!;

    notifyListeners();
    final result = await activePage.route?.completer?.future as Future<T?>?;
    _routeTree.removeRoute(page);

    return result;
  }

  Future<T?> _replaceNamed<T>(RouteDecoder activePage) async {
    final index = _activePages.length > 1 ? _activePages.length - 1 : 0;
    // final activePage = _configureRouterDecoder<T>(page, arguments);
    _activePages[index] = activePage;

    notifyListeners();
    final result = await activePage.route?.completer?.future as Future<T?>?;
    return result;
  }

  /// Takes a route [name] String generated by [to], [off], [offAll]
  /// (and similar context navigation methods), cleans the extra chars and
  /// accommodates the format.
  /// TODO: check for a more "appealing" URL naming convention.
  /// `() => MyHomeScreenView` becomes `/my-home-screen-view`.
  String _cleanRouteName(String name) {
    name = name.replaceAll('() => ', '');

    /// uncomment for URL styling.
    // name = name.paramCase!;
    if (!name.startsWith('/')) {
      name = '/$name';
    }
    return Uri.tryParse(name)?.toString() ?? name;
  }

  PageSettings _buildPageSettings(String page, [Object? data]) {
    var uri = Uri.parse(page);
    return PageSettings(uri, data);
  }

  @protected
  RouteDecoder? _getRouteDecoder<T>(PageSettings arguments) {
    var page = arguments.uri.path;
    final parameters = arguments.params;
    if (parameters.isNotEmpty) {
      final uri = Uri(path: page, queryParameters: parameters);
      page = uri.toString();
    }

    final decoder = _routeTree.matchRoute(page, arguments: arguments);
    final route = decoder.route;
    if (route == null) return null;

    return _configureRouterDecoder<T>(decoder, arguments);
  }

  @protected
  RouteDecoder _configureRouterDecoder<T>(
      RouteDecoder decoder, PageSettings arguments) {
    final parameters =
        arguments.params.isEmpty ? arguments.query : arguments.params;
    arguments.params.addAll(arguments.query);
    if (decoder.parameters.isEmpty) {
      decoder.parameters.addAll(parameters);
    }

    decoder.route = decoder.route?.copyWith(
      completer: _activePages.isEmpty ? null : Completer<T?>(),
      arguments: arguments,
      parameters: parameters,
      key: ValueKey(arguments.name),
    );

    return decoder;
  }

  Future<T?> _push<T>(RouteDecoder decoder, {bool rebuildStack = true}) async {
    var res = await runMiddleware(decoder);
    if (res == null) return null;
    // final res = mid ?? decoder;
    // if (res == null) res = decoder;

    final preventDuplicateHandlingMode =
        res.route?.preventDuplicateHandlingMode ??
            PreventDuplicateHandlingMode.reorderRoutes;

    final onStackPage = _activePages
        .firstWhereOrNull((element) => element.route?.key == res.route?.key);

    /// There are no duplicate routes in the stack
    if (onStackPage == null) {
      _activePages.add(res);
    } else {
      /// There are duplicate routes, reorder
      switch (preventDuplicateHandlingMode) {
        case PreventDuplicateHandlingMode.doNothing:
          break;
        case PreventDuplicateHandlingMode.reorderRoutes:
          _activePages.remove(onStackPage);
          _activePages.add(res);
          break;
        case PreventDuplicateHandlingMode.popUntilOriginalRoute:
          while (_activePages.last == onStackPage) {
            _popWithResult();
          }
          break;
        case PreventDuplicateHandlingMode.recreate:
          _activePages.remove(onStackPage);
          _activePages.add(res);
      }
    }
    if (rebuildStack) {
      notifyListeners();
    }

    return decoder.route?.completer?.future as Future<T?>?;
  }

  @override
  Future<void> setNewRoutePath(RouteDecoder configuration) async {
    final page = configuration.route;
    if (page == null) {
      goToUnknownPage();
      return;
    } else {
      _push(configuration);
    }
  }

  @override
  RouteDecoder? get currentConfiguration {
    if (_activePages.isEmpty) return null;
    final route = _activePages.last;
    return route;
  }

  Future<bool> handlePopupRoutes({
    Object? result,
  }) async {
    Route? currentRoute;
    navigatorKey.currentState!.popUntil((route) {
      currentRoute = route;
      return true;
    });
    if (currentRoute is PopupRoute) {
      return await navigatorKey.currentState!.maybePop(result);
    }
    return false;
  }

  @override
  Future<bool> popRoute({
    Object? result,
    PopMode? popMode,
  }) async {
    //Returning false will cause the entire app to be popped.
    final wasPopup = await handlePopupRoutes(result: result);
    if (wasPopup) return true;

    if (_canPop(popMode ?? backButtonPopMode)) {
      await _pop(popMode ?? backButtonPopMode, result);
      notifyListeners();
      return true;
    }

    return super.popRoute();
  }

  @override
  void back<T>([T? result]) {
    _checkIfCanBack();
    _popWithResult<T>(result);
    notifyListeners();
  }

  bool _onPopVisualRoute(Route<dynamic> route, dynamic result) {
    final didPop = route.didPop(result);
    if (!didPop) {
      return false;
    }
    _popWithResult(result);
    // final settings = route.settings;
    // if (settings is GetPage) {
    //   final config = _activePages.cast<RouteDecoder?>().firstWhere(
    //         (element) => element?.route == settings,
    //         orElse: () => null,
    //       );
    //   if (config != null) {
    //     _removeHistoryEntry(config, result);
    //   }
    // }
    notifyListeners();
    //return !route.navigator!.userGestureInProgress;
    return true;
  }
}
\n\n--- File: 17 # lib/get_navigation/src/routes/get_information_parser.dart ---\nimport 'package:flutter/foundation.dart';
import 'package:flutter/widgets.dart';

import '../../../get.dart';

class GetInformationParser extends RouteInformationParser<RouteDecoder> {
  factory GetInformationParser.createInformationParser(
      {String initialRoute = '/'}) {
    return GetInformationParser(initialRoute: initialRoute);
  }

  final String initialRoute;

  GetInformationParser({
    required this.initialRoute,
  }) {
    Get.log('GetInformationParser is created !');
  }
  @override
  SynchronousFuture<RouteDecoder> parseRouteInformation(
    RouteInformation routeInformation,
  ) {
    final uri = routeInformation.uri;
    var location = uri.toString();
    if (location == '/') {
      //check if there is a corresponding page
      //if not, relocate to initialRoute
      if (!(Get.rootController.rootDelegate)
          .registeredRoutes
          .any((element) => element.name == '/')) {
        location = initialRoute;
      }
    } else if (location.isEmpty) {
      location = initialRoute;
    }

    Get.log('GetInformationParser: route location: $location');

    return SynchronousFuture(RouteDecoder.fromRoute(location));
  }

  @override
  RouteInformation restoreRouteInformation(RouteDecoder configuration) {
    return RouteInformation(
      uri: Uri.tryParse(configuration.pageSettings?.name ?? ''),
      state: null,
    );
  }
}
\n\n--- File: 18 # lib/get_navigation/src/routes/parse_route.dart ---\nimport 'package:flutter/foundation.dart';

import '../../../get.dart';

@immutable
class RouteDecoder {
  const RouteDecoder(
    this.currentTreeBranch,
    this.pageSettings,
  );
  final List<GetPage> currentTreeBranch;
  final PageSettings? pageSettings;

  factory RouteDecoder.fromRoute(String location) {
    var uri = Uri.parse(location);
    final args = PageSettings(uri);
    final decoder =
        (Get.rootController.rootDelegate).matchRoute(location, arguments: args);
    decoder.route = decoder.route?.copyWith(
      completer: null,
      arguments: args,
      parameters: args.params,
    );
    return decoder;
  }

  GetPage? get route =>
      currentTreeBranch.isEmpty ? null : currentTreeBranch.last;

  GetPage routeOrUnknown(GetPage onUnknow) =>
      currentTreeBranch.isEmpty ? onUnknow : currentTreeBranch.last;

  set route(GetPage? getPage) {
    if (getPage == null) return;
    if (currentTreeBranch.isEmpty) {
      currentTreeBranch.add(getPage);
    } else {
      currentTreeBranch[currentTreeBranch.length - 1] = getPage;
    }
  }

  List<GetPage>? get currentChildren => route?.children;

  Map<String, String> get parameters => pageSettings?.params ?? {};

  dynamic get args {
    return pageSettings?.arguments;
  }

  T? arguments<T>() {
    final args = pageSettings?.arguments;
    if (args is T) {
      return pageSettings?.arguments as T;
    } else {
      return null;
    }
  }

  // void replaceArguments(Object? arguments) {
  //   final newRoute = route;
  //   if (newRoute != null) {
  //     final index = currentTreeBranch.indexOf(newRoute);
  //     currentTreeBranch[index] = newRoute.copyWith(arguments: arguments);
  //   }
  // }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;

    return other is RouteDecoder &&
        listEquals(other.currentTreeBranch, currentTreeBranch) &&
        other.pageSettings == pageSettings;
  }

  @override
  int get hashCode => currentTreeBranch.hashCode ^ pageSettings.hashCode;

  @override
  String toString() =>
      'RouteDecoder(currentTreeBranch: $currentTreeBranch, pageSettings: $pageSettings)';
}

class ParseRouteTree {
  ParseRouteTree({
    required this.routes,
  });

  final List<GetPage> routes;

  RouteDecoder matchRoute(String name, {PageSettings? arguments}) {
    final uri = Uri.parse(name);
    final split = uri.path.split('/').where((element) => element.isNotEmpty);
    var curPath = '/';
    final cumulativePaths = <String>[
      '/',
    ];
    for (var item in split) {
      if (curPath.endsWith('/')) {
        curPath += item;
      } else {
        curPath += '/$item';
      }
      cumulativePaths.add(curPath);
    }

    final treeBranch = cumulativePaths
        .map((e) => MapEntry(e, _findRoute(e)))
        .where((element) => element.value != null)

        ///Prevent page be disposed
        .map((e) => MapEntry(e.key, e.value!.copyWith(key: ValueKey(e.key))))
        .toList();

    final params = Map<String, String>.from(uri.queryParameters);
    if (treeBranch.isNotEmpty) {
      //route is found, do further parsing to get nested query params
      final lastRoute = treeBranch.last;
      final parsedParams = _parseParams(name, lastRoute.value.path);
      if (parsedParams.isNotEmpty) {
        params.addAll(parsedParams);
      }
      //copy parameters to all pages.
      final mappedTreeBranch = treeBranch
          .map(
            (e) => e.value.copyWith(
              parameters: {
                if (e.value.parameters != null) ...e.value.parameters!,
                ...params,
              },
              name: e.key,
            ),
          )
          .toList();
      arguments?.params.clear();
      arguments?.params.addAll(params);
      return RouteDecoder(
        mappedTreeBranch,
        arguments,
      );
    }

    arguments?.params.clear();
    arguments?.params.addAll(params);

    //route not found
    return RouteDecoder(
      treeBranch.map((e) => e.value).toList(),
      arguments,
    );
  }

  void addRoutes<T>(List<GetPage<T>> getPages) {
    for (final route in getPages) {
      addRoute(route);
    }
  }

  void removeRoutes<T>(List<GetPage<T>> getPages) {
    for (final route in getPages) {
      removeRoute(route);
    }
  }

  void removeRoute<T>(GetPage<T> route) {
    routes.remove(route);
    for (var page in _flattenPage(route)) {
      removeRoute(page);
    }
  }

  void addRoute<T>(GetPage<T> route) {
    routes.add(route);

    // Add Page children.
    for (var page in _flattenPage(route)) {
      addRoute(page);
    }
  }

  List<GetPage> _flattenPage(GetPage route) {
    final result = <GetPage>[];
    if (route.children.isEmpty) {
      return result;
    }

    final parentPath = route.name;
    for (var page in route.children) {
      // Add Parent middlewares to children
      final parentMiddlewares = [
        if (page.middlewares.isNotEmpty) ...page.middlewares,
        if (route.middlewares.isNotEmpty) ...route.middlewares
      ];

      final parentBindings = [
        if (page.binding != null) page.binding!,
        if (page.bindings.isNotEmpty) ...page.bindings,
        if (route.bindings.isNotEmpty) ...route.bindings
      ];

      final parentBinds = [
        if (page.binds.isNotEmpty) ...page.binds,
        if (route.binds.isNotEmpty) ...route.binds
      ];

      result.add(
        _addChild(
          page,
          parentPath,
          parentMiddlewares,
          parentBindings,
          parentBinds,
        ),
      );

      final children = _flattenPage(page);
      for (var child in children) {
        result.add(_addChild(
          child,
          parentPath,
          [
            ...parentMiddlewares,
            if (child.middlewares.isNotEmpty) ...child.middlewares,
          ],
          [
            ...parentBindings,
            if (child.binding != null) child.binding!,
            if (child.bindings.isNotEmpty) ...child.bindings,
          ],
          [
            ...parentBinds,
            if (child.binds.isNotEmpty) ...child.binds,
          ],
        ));
      }
    }
    return result;
  }

  /// Change the Path for a [GetPage]
  GetPage _addChild(
    GetPage origin,
    String parentPath,
    List<GetMiddleware> middlewares,
    List<BindingsInterface> bindings,
    List<Bind> binds,
  ) {
    return origin.copyWith(
      middlewares: middlewares,
      name: origin.inheritParentPath
          ? (parentPath + origin.name).replaceAll(r'//', '/')
          : origin.name,
      bindings: bindings,
      binds: binds,
      // key:
    );
  }

  GetPage? _findRoute(String name) {
    final value = routes.firstWhereOrNull(
      (route) => route.path.regex.hasMatch(name),
    );

    return value;
  }

  Map<String, String> _parseParams(String path, PathDecoded routePath) {
    final params = <String, String>{};
    var idx = path.indexOf('?');
    final uri = Uri.tryParse(path);
    if (uri == null) return params;
    if (idx > -1) {
      params.addAll(uri.queryParameters);
    }
    var paramsMatch = routePath.regex.firstMatch(uri.path);
    if (paramsMatch == null) {
      return params;
    }
    for (var i = 0; i < routePath.keys.length; i++) {
      var param = Uri.decodeQueryComponent(paramsMatch[i + 1]!);
      params[routePath.keys[i]!] = param;
    }
    return params;
  }
}

extension FirstWhereOrNullExt<T> on List<T> {
  /// The first element satisfying [test], or `null` if there are none.
  T? firstWhereOrNull(bool Function(T element) test) {
    for (var element in this) {
      if (test(element)) return element;
    }
    return null;
  }
}
\n\n--- File: 19 # lib/get_navigation/src/routes/page_settings.dart ---\nimport 'package:flutter/widgets.dart';

import '../../../route_manager.dart';

extension PageArgExt on BuildContext {
  RouteSettings? get settings {
    return ModalRoute.of(this)!.settings;
  }

  PageSettings? get pageSettings {
    final args = ModalRoute.of(this)?.settings.arguments;
    if (args is PageSettings) {
      return args;
    }
    return null;
  }

  dynamic get arguments {
    final args = settings?.arguments;
    if (args is PageSettings) {
      return args.arguments;
    } else {
      return args;
    }
  }

  Map<String, String> get params {
    final args = settings?.arguments;
    if (args is PageSettings) {
      return args.params;
    } else {
      return {};
    }
  }

  Router get router {
    return Router.of(this);
  }

  String get location {
    final parser = router.routeInformationParser;
    final config = delegate.currentConfiguration;
    return parser?.restoreRouteInformation(config)?.uri.toString() ?? '/';
  }

  GetDelegate get delegate {
    return router.routerDelegate as GetDelegate;
  }
}

class PageSettings extends RouteSettings {
  PageSettings(
    this.uri, [
    Object? arguments,
  ]) : super(arguments: arguments);

  @override
  String get name => '$uri';

  final Uri uri;

  final params = <String, String>{};

  String get path => uri.path;

  List<String> get paths => uri.pathSegments;

  Map<String, String> get query => uri.queryParameters;

  Map<String, List<String>> get queries => uri.queryParametersAll;

  @override
  String toString() => name;

  PageSettings copy({
    Uri? uri,
    Object? arguments,
  }) {
    return PageSettings(
      uri ?? this.uri,
      arguments ?? this.arguments,
    );
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;

    return other is PageSettings &&
        other.uri == uri &&
        other.arguments == arguments;
  }

  @override
  int get hashCode => uri.hashCode ^ arguments.hashCode;
}
\n\n--- File: 21 # lib/get_navigation/src/routes/route_middleware.dart ---\nimport 'dart:async';

import 'package:flutter/cupertino.dart';

import '../../../get.dart';

/// The Page Middlewares.
/// The Functions will be called in this order
/// (( [redirect] -> [onPageCalled] -> [onBindingsStart] ->
/// [onPageBuildStart] -> [onPageBuilt] -> [onPageDispose] ))
abstract class GetMiddleware {
  GetMiddleware({this.priority = 0});

  /// The Order of the Middlewares to run.
  ///
  /// {@tool snippet}
  /// This Middewares will be called in this order.
  /// ```dart
  /// final middlewares = [
  ///   GetMiddleware(priority: 2),
  ///   GetMiddleware(priority: 5),
  ///   GetMiddleware(priority: 4),
  ///   GetMiddleware(priority: -8),
  /// ];
  /// ```
  ///  -8 => 2 => 4 => 5
  /// {@end-tool}
  final int priority;

  /// This function will be called when the page of
  /// the called route is being searched for.
  /// It take RouteSettings as a result an redirect to the new settings or
  /// give it null and there will be no redirecting.
  /// {@tool snippet}
  /// ```dart
  /// GetPage redirect(String route) {
  ///   final authService = Get.find<AuthService>();
  ///   return authService.authed.value ? null : RouteSettings(name: '/login');
  /// }
  /// ```
  /// {@end-tool}
  RouteSettings? redirect(String? route) => null;

  /// Similar to [redirect],
  /// This function will be called when the router delegate changes the
  /// current route.
  ///
  /// The default implmentation is to navigate to
  /// the input route, with no redirection.
  ///
  /// if this returns null, the navigation is stopped,
  /// and no new routes are pushed.
  /// {@tool snippet}
  /// ```dart
  /// GetNavConfig? redirect(GetNavConfig route) {
  ///   final authService = Get.find<AuthService>();
  ///   return authService.authed.value ? null : RouteSettings(name: '/login');
  /// }
  /// ```
  /// {@end-tool}
  FutureOr<RouteDecoder?> redirectDelegate(RouteDecoder route) => (route);

  /// This function will be called when this Page is called
  /// you can use it to change something about the page or give it new page
  /// {@tool snippet}
  /// ```dart
  /// GetPage onPageCalled(GetPage page) {
  ///   final authService = Get.find<AuthService>();
  ///   return page.copyWith(title: 'Welcome ${authService.UserName}');
  /// }
  /// ```
  /// {@end-tool}
  GetPage? onPageCalled(GetPage? page) => page;

  /// This function will be called right before the [BindingsInterface] are initialize.
  /// Here you can change [BindingsInterface] for this page
  /// {@tool snippet}
  /// ```dart
  /// List<Bindings> onBindingsStart(List<Bindings> bindings) {
  ///   final authService = Get.find<AuthService>();
  ///   if (authService.isAdmin) {
  ///     bindings.add(AdminBinding());
  ///   }
  ///   return bindings;
  /// }
  /// ```
  /// {@end-tool}
  List<R>? onBindingsStart<R>(List<R>? bindings) => bindings;

  /// This function will be called right after the [BindingsInterface] are initialize.
  GetPageBuilder? onPageBuildStart(GetPageBuilder? page) => page;

  /// This function will be called right after the
  /// GetPage.page function is called and will give you the result
  /// of the function. and take the widget that will be showed.
  Widget onPageBuilt(Widget page) => page;

  void onPageDispose() {}
}

class MiddlewareRunner {
  MiddlewareRunner(List<GetMiddleware>? middlewares)
      : _middlewares = middlewares != null
            ? (List.of(middlewares)..sort(_compareMiddleware))
            : const [];

  final List<GetMiddleware> _middlewares;

  static int _compareMiddleware(GetMiddleware a, GetMiddleware b) =>
      a.priority.compareTo(b.priority);

  GetPage? runOnPageCalled(GetPage? page) {
    for (final middleware in _middlewares) {
      page = middleware.onPageCalled(page);
    }
    return page;
  }

  RouteSettings? runRedirect(String? route) {
    for (final middleware in _middlewares) {
      final redirectTo = middleware.redirect(route);
      if (redirectTo != null) {
        return redirectTo;
      }
    }
    return null;
  }

  List<R>? runOnBindingsStart<R>(List<R>? bindings) {
    for (final middleware in _middlewares) {
      bindings = middleware.onBindingsStart(bindings);
    }
    return bindings;
  }

  GetPageBuilder? runOnPageBuildStart(GetPageBuilder? page) {
    for (final middleware in _middlewares) {
      page = middleware.onPageBuildStart(page);
    }
    return page;
  }

  Widget runOnPageBuilt(Widget page) {
    for (final middleware in _middlewares) {
      page = middleware.onPageBuilt(page);
    }
    return page;
  }

  void runOnPageDispose() {
    for (final middleware in _middlewares) {
      middleware.onPageDispose();
    }
  }
}

class PageRedirect {
  GetPage? route;
  GetPage? unknownRoute;
  RouteSettings? settings;
  bool isUnknown;

  PageRedirect({
    this.route,
    this.unknownRoute,
    this.isUnknown = false,
    this.settings,
  });

  // redirect all pages that needes redirecting
  GetPageRoute<T> getPageToRoute<T>(
      GetPage rou, GetPage? unk, BuildContext context) {
    while (needRecheck(context)) {}
    final r = (isUnknown ? unk : rou)!;

    return GetPageRoute<T>(
      page: r.page,
      parameter: r.parameters,
      alignment: r.alignment,
      title: r.title,
      maintainState: r.maintainState,
      routeName: r.name,
      settings: r,
      curve: r.curve,
      showCupertinoParallax: r.showCupertinoParallax,
      gestureWidth: r.gestureWidth,
      opaque: r.opaque,
      customTransition: r.customTransition,
      bindings: r.bindings,
      binding: r.binding,
      binds: r.binds,
      transitionDuration: r.transitionDuration ?? Get.defaultTransitionDuration,
      reverseTransitionDuration:
          r.reverseTransitionDuration ?? Get.defaultTransitionDuration,
      // performIncomeAnimation: _r.performIncomeAnimation,
      // performOutGoingAnimation: _r.performOutGoingAnimation,
      transition: r.transition,
      popGesture: r.popGesture,
      fullscreenDialog: r.fullscreenDialog,
      middlewares: r.middlewares,
    );
  }

  /// check if redirect is needed
  bool needRecheck(BuildContext context) {
    if (settings == null && route != null) {
      settings = route;
    }
    final match = context.delegate.matchRoute(settings!.name!);

    // No Match found
    if (match.route == null) {
      isUnknown = true;
      return false;
    }

    // No middlewares found return match.
    if (match.route!.middlewares.isEmpty) {
      return false;
    }

    final runner = MiddlewareRunner(match.route!.middlewares);
    route = runner.runOnPageCalled(match.route);
    addPageParameter(route!);

    final newSettings = runner.runRedirect(settings!.name);
    if (newSettings == null) {
      return false;
    }
    settings = newSettings;
    return true;
  }

  void addPageParameter(GetPage route) {
    if (route.parameters == null) return;

    final parameters = Map<String, String?>.from(Get.parameters);
    parameters.addEntries(route.parameters!.entries);
    // Get.parameters = parameters;
  }
}
\n\n--- File: 22 # lib/get_navigation/src/routes/get_transition_mixin.dart ---\nimport 'dart:math';
import 'dart:ui';

import 'package:flutter/cupertino.dart';
import 'package:flutter/foundation.dart';
import 'package:flutter/gestures.dart';
import 'package:flutter/material.dart';

import '../../../get.dart';
import '../root/get_root.dart';

const double _kBackGestureWidth = 20.0;

const double _kMinFlingVelocity = 1; // Screen widths per second.

// An eyeballed value for the maximum time it takes for a page to animate
// forward if the user releases a page mid swipe.
const int _kMaxMidSwipePageForwardAnimationTime = 800; // Milliseconds.

// The maximum time for a page to get reset to it's original position if the
// user releases a page mid swipe.
const int _kMaxPageBackAnimationTime = 300; // Milliseconds.

class GetBackGestureDetector<T> extends StatefulWidget {
  const GetBackGestureDetector({
    super.key,
    required this.limitedSwipe,
    required this.gestureWidth,
    required this.initialOffset,
    required this.popGestureEnable,
    required this.onStartPopGesture,
    required this.child,
  });

  final bool limitedSwipe;
  final double gestureWidth;
  final double initialOffset;

  final Widget child;
  final ValueGetter<bool> popGestureEnable;
  final ValueGetter<GetBackGestureController<T>> onStartPopGesture;

  @override
  GetBackGestureDetectorState<T> createState() =>
      GetBackGestureDetectorState<T>();
}

class GetBackGestureDetectorState<T> extends State<GetBackGestureDetector<T>> {
  GetBackGestureController<T>? _backGestureController;

  void _handleDragStart(DragStartDetails details) {
    assert(mounted);
    assert(_backGestureController == null);
    _backGestureController = widget.onStartPopGesture();
  }

  void _handleDragUpdate(DragUpdateDetails details) {
    assert(mounted);
    assert(_backGestureController != null);
    _backGestureController!.dragUpdate(
      _convertToLogical(details.primaryDelta! / context.size!.width),
    );
  }

  void _handleDragEnd(DragEndDetails details) {
    assert(mounted);
    assert(_backGestureController != null);
    _backGestureController!.dragEnd(_convertToLogical(
      details.velocity.pixelsPerSecond.dx / context.size!.width,
    ));
    _backGestureController = null;
  }

  void _handleDragCancel() {
    assert(mounted);
    // This can be called even if start is not called, paired with the "down"
    // event that we don't consider here.
    _backGestureController?.dragEnd(0);
    _backGestureController = null;
  }

  double _convertToLogical(double value) {
    switch (Directionality.of(context)) {
      case TextDirection.rtl:
        return -value;
      case TextDirection.ltr:
        return value;
    }
  }

  @override
  Widget build(BuildContext context) {
    assert(debugCheckHasDirectionality(context));

    final gestureDetector = RawGestureDetector(
      behavior: HitTestBehavior.translucent,
      gestures: {
        _DirectionalityDragGestureRecognizer:
            GestureRecognizerFactoryWithHandlers<
                _DirectionalityDragGestureRecognizer>(
          () {
            final directionality = Directionality.of(context);
            return _DirectionalityDragGestureRecognizer(
              debugOwner: this,
              isRTL: directionality == TextDirection.rtl,
              isLTR: directionality == TextDirection.ltr,
              hasbackGestureController: () => _backGestureController != null,
              popGestureEnable: widget.popGestureEnable,
            );
          },
          (directionalityDragGesture) => directionalityDragGesture
            ..onStart = _handleDragStart
            ..onUpdate = _handleDragUpdate
            ..onEnd = _handleDragEnd
            ..onCancel = _handleDragCancel,
        )
      },
    );

    return Stack(
      fit: StackFit.passthrough,
      children: [
        widget.child,
        if (widget.limitedSwipe)
          PositionedDirectional(
            start: widget.initialOffset,
            width: _dragAreaWidth(context),
            top: 0,
            bottom: 0,
            child: gestureDetector,
          )
        else
          Positioned.fill(child: gestureDetector),
      ],
    );
  }

  double _dragAreaWidth(BuildContext context) {
    // For devices with notches, the drag area needs to be larger on the side
    // that has the notch.
    final dragAreaWidth = Directionality.of(context) == TextDirection.ltr
        ? context.mediaQuery.padding.left
        : context.mediaQuery.padding.right;
    return max(dragAreaWidth, widget.gestureWidth);
  }
}

class GetBackGestureController<T> {
  GetBackGestureController({
    required this.navigator,
    required this.controller,
  }) {
    navigator.didStartUserGesture();
  }

  final AnimationController controller;
  final NavigatorState navigator;

  /// The drag gesture has changed by [delta]. The total range of the
  /// drag should be 0.0 to 1.0.
  void dragUpdate(double delta) {
    controller.value -= delta;
  }

  /// The drag gesture has ended with a horizontal motion of [velocity] as a
  /// fraction of screen width per second.
  void dragEnd(double velocity) {
    // Fling in the appropriate direction.
    // AnimationController.fling is guaranteed to
    // take at least one frame.
    //
    // This curve has been determined through rigorously eyeballing native iOS
    // animations.
    const Curve animationCurve = Curves.fastLinearToSlowEaseIn;
    final bool animateForward;

    // If the user releases the page before mid screen with sufficient velocity,
    // or after mid screen, we should animate the page out. Otherwise, the page
    // should be animated back in.
    if (velocity.abs() >= _kMinFlingVelocity) {
      animateForward = velocity <= 0;
    } else {
      animateForward = controller.value > 0.5;
    }

    if (animateForward) {
      // The closer the panel is to dismissing, the shorter the animation is.
      // We want to cap the animation time, but we want to use a linear curve
      // to determine it.
      final droppedPageForwardAnimationTime = min(
        lerpDouble(_kMaxMidSwipePageForwardAnimationTime, 0, controller.value)!
            .floor(),
        _kMaxPageBackAnimationTime,
      );
      controller.animateTo(1.0,
          duration: Duration(milliseconds: droppedPageForwardAnimationTime),
          curve: animationCurve);
    } else {
      // This route is destined to pop at this point. Reuse navigator's pop.
      Get.back();

      // The popping may have finished inline if already at the
      // target destination.
      if (controller.isAnimating) {
        // Otherwise, use a custom popping animation duration and curve.
        final droppedPageBackAnimationTime = lerpDouble(
                0, _kMaxMidSwipePageForwardAnimationTime, controller.value)!
            .floor();
        controller.animateBack(0.0,
            duration: Duration(milliseconds: droppedPageBackAnimationTime),
            curve: animationCurve);
      }
    }

    if (controller.isAnimating) {
      // Keep the userGestureInProgress in true state so we don't change the
      // curve of the page transition mid-flight since CupertinoPageTransition
      // depends on userGestureInProgress.
      late AnimationStatusListener animationStatusCallback;
      animationStatusCallback = (status) {
        navigator.didStopUserGesture();
        controller.removeStatusListener(animationStatusCallback);
      };
      controller.addStatusListener(animationStatusCallback);
    } else {
      navigator.didStopUserGesture();
    }
  }
}

mixin GetPageRouteTransitionMixin<T> on PageRoute<T> {
  ValueNotifier<String?>? _previousTitle;

  @override
  Color? get barrierColor => null;

  @override
  String? get barrierLabel => null;

  double Function(BuildContext context)? get gestureWidth;

  /// True if an iOS-style back swipe pop gesture is currently
  /// underway for this route.
  ///
  /// See also:
  ///
  ///  * [isPopGestureInProgress], which returns true if a Cupertino pop gesture
  ///    is currently underway for specific route.
  ///  * [popGestureEnabled], which returns true if a user-triggered pop gesture
  ///    would be allowed.
  //bool get popGestureInProgress => isPopGestureInProgress(this);

  /// The title string of the previous [CupertinoPageRoute].
  ///
  /// The [ValueListenable]'s value is readable after the route is installed
  /// onto a [Navigator]. The [ValueListenable] will also notify its listeners
  /// if the value changes (such as by replacing the previous route).
  ///
  /// The [ValueListenable] itself will be null before the route is installed.
  /// Its content value will be null if the previous route has no title or
  /// is not a [CupertinoPageRoute].
  ///
  /// See also:
  ///
  ///  * [ValueListenableBuilder], which can be used to listen and rebuild
  ///    widgets based on a ValueListenable.
  ValueListenable<String?> get previousTitle {
    assert(
      _previousTitle != null,
      '''
Cannot read the previousTitle for a route that has not yet been installed''',
    );
    return _previousTitle!;
  }

  bool get showCupertinoParallax;

  /// {@template flutter.cupertino.CupertinoRouteTransitionMixin.title}
  /// A title string for this route.
  ///
  /// Used to auto-populate [CupertinoNavigationBar] and
  /// [CupertinoSliverNavigationBar]'s `middle`/`largeTitle` widgets when
  /// one is not manually supplied.
  /// {@endtemplate}
  String? get title;

  @override
  // A relatively rigorous eyeball estimation.
  Duration get transitionDuration;

  @override
  Duration get reverseTransitionDuration;

  /// Builds the primary contents of the route.
  @protected
  Widget buildContent(BuildContext context);

  @override
  Widget buildPage(BuildContext context, Animation<double> animation,
      Animation<double> secondaryAnimation) {
    final child = buildContent(context);
    final Widget result = Semantics(
      scopesRoute: true,
      explicitChildNodes: true,
      child: child,
    );
    return result;
  }

  @override
  Widget buildTransitions(BuildContext context, Animation<double> animation,
      Animation<double> secondaryAnimation, Widget child) {
    return buildPageTransitions<T>(
        this, context, animation, secondaryAnimation, child);
  }

  @override
  bool canTransitionTo(TransitionRoute<dynamic> nextRoute) {
    // Don't perform outgoing animation if the next route is a
    // fullscreen dialog.
    return (nextRoute is GetPageRouteTransitionMixin &&
            !nextRoute.fullscreenDialog &&
            nextRoute.showCupertinoParallax) ||
        (nextRoute is CupertinoRouteTransitionMixin &&
            !nextRoute.fullscreenDialog) ||
        (nextRoute is CupertinoSheetRoute &&
            !nextRoute.fullscreenDialog);
  }

  @override
  void didChangePrevious(Route<dynamic>? previousRoute) {
    final previousTitleString = previousRoute is CupertinoRouteTransitionMixin
        ? previousRoute.title
        : null;
    if (_previousTitle == null) {
      _previousTitle = ValueNotifier<String?>(previousTitleString);
    } else {
      _previousTitle!.value = previousTitleString;
    }
    super.didChangePrevious(previousRoute);
  }

  static bool canSwipe(GetPageRoute route) =>
      route.popGesture ?? Get.defaultPopGesture ?? GetPlatform.isIOS;

  /// Returns a [CupertinoFullscreenDialogTransition] if [route] is a full
  /// screen dialog, otherwise a [CupertinoPageTransition] is returned.
  ///
  /// Used by [CupertinoPageRoute.buildTransitions].
  ///
  /// This method can be applied to any [PageRoute], not just
  /// [CupertinoPageRoute]. It's typically used to provide a Cupertino style
  /// horizontal transition for material widgets when the target platform
  /// is [TargetPlatform.iOS].
  ///
  /// See also:
  ///
  ///  * [CupertinoPageTransitionsBuilder], which uses this method to define a
  ///    [PageTransitionsBuilder] for the [PageTransitionsTheme].
  static Widget buildPageTransitions<T>(
    PageRoute<T> rawRoute,
    BuildContext context,
    Animation<double> animation,
    Animation<double> secondaryAnimation,
    Widget child, {
    bool limitedSwipe = false,
    double initialOffset = 0,
  }) {
    // Check if the route has an animation that's currently participating
    // in a back swipe gesture.
    //
    // In the middle of a back gesture drag, let the transition be linear to
    // match finger motions.
    final route = rawRoute as GetPageRoute<T>;
    final linearTransition = route.popGestureInProgress;
    final finalCurve = route.curve ?? Get.defaultTransitionCurve;
    final hasCurve = route.curve != null;
    if (route.fullscreenDialog && route.transition == null) {
      return CupertinoFullscreenDialogTransition(
        primaryRouteAnimation: hasCurve
            ? CurvedAnimation(parent: animation, curve: finalCurve)
            : animation,
        secondaryRouteAnimation: secondaryAnimation,
        linearTransition: linearTransition,
        child: child,
      );
    } else {
      if (route.customTransition != null) {
        return route.customTransition!.buildTransition(
          context,
          finalCurve,
          route.alignment,
          animation,
          secondaryAnimation,
          GetBackGestureDetector<T>(
            popGestureEnable: () =>
                _isPopGestureEnabled(route, canSwipe(route), context),
            onStartPopGesture: () {
              assert(_isPopGestureEnabled(route, canSwipe(route), context));
              return _startPopGesture(route);
            },
            limitedSwipe: limitedSwipe,
            gestureWidth:
                route.gestureWidth?.call(context) ?? _kBackGestureWidth,
            initialOffset: initialOffset,
            child: child,
          ),
        );
      }

      /// Apply the curve by default...
      final iosAnimation = animation;
      animation = CurvedAnimation(parent: animation, curve: finalCurve);

      switch (route.transition ?? Get.defaultTransition) {
        case Transition.leftToRight:
          return SlideLeftTransition().buildTransitions(
              context,
              route.curve,
              route.alignment,
              animation,
              secondaryAnimation,
              GetBackGestureDetector<T>(
                popGestureEnable: () =>
                    _isPopGestureEnabled(route, canSwipe(route), context),
                onStartPopGesture: () {
                  assert(_isPopGestureEnabled(route, canSwipe(route), context));
                  return _startPopGesture(route);
                },
                limitedSwipe: limitedSwipe,
                gestureWidth:
                    route.gestureWidth?.call(context) ?? _kBackGestureWidth,
                initialOffset: initialOffset,
                child: child,
              ));

        case Transition.downToUp:
          return SlideDownTransition().buildTransitions(
              context,
              route.curve,
              route.alignment,
              animation,
              secondaryAnimation,
              GetBackGestureDetector<T>(
                popGestureEnable: () =>
                    _isPopGestureEnabled(route, canSwipe(route), context),
                onStartPopGesture: () {
                  assert(_isPopGestureEnabled(route, canSwipe(route), context));
                  return _startPopGesture(route);
                },
                limitedSwipe: limitedSwipe,
                gestureWidth:
                    route.gestureWidth?.call(context) ?? _kBackGestureWidth,
                initialOffset: initialOffset,
                child: child,
              ));

        case Transition.upToDown:
          return SlideTopTransition().buildTransitions(
              context,
              route.curve,
              route.alignment,
              animation,
              secondaryAnimation,
              GetBackGestureDetector<T>(
                popGestureEnable: () =>
                    _isPopGestureEnabled(route, canSwipe(route), context),
                onStartPopGesture: () {
                  assert(_isPopGestureEnabled(route, canSwipe(route), context));
                  return _startPopGesture(route);
                },
                limitedSwipe: limitedSwipe,
                gestureWidth:
                    route.gestureWidth?.call(context) ?? _kBackGestureWidth,
                initialOffset: initialOffset,
                child: child,
              ));

        case Transition.noTransition:
          return GetBackGestureDetector<T>(
            popGestureEnable: () =>
                _isPopGestureEnabled(route, canSwipe(route), context),
            onStartPopGesture: () {
              assert(_isPopGestureEnabled(route, canSwipe(route), context));
              return _startPopGesture(route);
            },
            limitedSwipe: limitedSwipe,
            gestureWidth:
                route.gestureWidth?.call(context) ?? _kBackGestureWidth,
            initialOffset: initialOffset,
            child: child,
          );

        case Transition.rightToLeft:
          return SlideRightTransition().buildTransitions(
              context,
              route.curve,
              route.alignment,
              animation,
              secondaryAnimation,
              GetBackGestureDetector<T>(
                popGestureEnable: () =>
                    _isPopGestureEnabled(route, canSwipe(route), context),
                onStartPopGesture: () {
                  assert(_isPopGestureEnabled(route, canSwipe(route), context));
                  return _startPopGesture(route);
                },
                limitedSwipe: limitedSwipe,
                gestureWidth:
                    route.gestureWidth?.call(context) ?? _kBackGestureWidth,
                initialOffset: initialOffset,
                child: child,
              ));

        case Transition.zoom:
          return ZoomInTransition().buildTransitions(
              context,
              route.curve,
              route.alignment,
              animation,
              secondaryAnimation,
              GetBackGestureDetector<T>(
                popGestureEnable: () =>
                    _isPopGestureEnabled(route, canSwipe(route), context),
                onStartPopGesture: () {
                  assert(_isPopGestureEnabled(route, canSwipe(route), context));
                  return _startPopGesture(route);
                },
                limitedSwipe: limitedSwipe,
                gestureWidth:
                    route.gestureWidth?.call(context) ?? _kBackGestureWidth,
                initialOffset: initialOffset,
                child: child,
              ));

        case Transition.fadeIn:
          return FadeInTransition().buildTransitions(
              context,
              route.curve,
              route.alignment,
              animation,
              secondaryAnimation,
              GetBackGestureDetector<T>(
                popGestureEnable: () =>
                    _isPopGestureEnabled(route, canSwipe(route), context),
                onStartPopGesture: () {
                  assert(_isPopGestureEnabled(route, canSwipe(route), context));
                  return _startPopGesture(route);
                },
                limitedSwipe: limitedSwipe,
                gestureWidth:
                    route.gestureWidth?.call(context) ?? _kBackGestureWidth,
                initialOffset: initialOffset,
                child: child,
              ));

        case Transition.rightToLeftWithFade:
          return RightToLeftFadeTransition().buildTransitions(
              context,
              route.curve,
              route.alignment,
              animation,
              secondaryAnimation,
              GetBackGestureDetector<T>(
                popGestureEnable: () =>
                    _isPopGestureEnabled(route, canSwipe(route), context),
                onStartPopGesture: () {
                  assert(_isPopGestureEnabled(route, canSwipe(route), context));
                  return _startPopGesture(route);
                },
                limitedSwipe: limitedSwipe,
                gestureWidth:
                    route.gestureWidth?.call(context) ?? _kBackGestureWidth,
                initialOffset: initialOffset,
                child: child,
              ));

        case Transition.leftToRightWithFade:
          return LeftToRightFadeTransition().buildTransitions(
              context,
              route.curve,
              route.alignment,
              animation,
              secondaryAnimation,
              GetBackGestureDetector<T>(
                popGestureEnable: () =>
                    _isPopGestureEnabled(route, canSwipe(route), context),
                onStartPopGesture: () {
                  assert(_isPopGestureEnabled(route, canSwipe(route), context));
                  return _startPopGesture(route);
                },
                limitedSwipe: limitedSwipe,
                gestureWidth:
                    route.gestureWidth?.call(context) ?? _kBackGestureWidth,
                initialOffset: initialOffset,
                child: child,
              ));

        case Transition.cupertino:
          return CupertinoPageTransition(
              primaryRouteAnimation: animation,
              secondaryRouteAnimation: secondaryAnimation,
              linearTransition: linearTransition,
              child: GetBackGestureDetector<T>(
                popGestureEnable: () =>
                    _isPopGestureEnabled(route, canSwipe(route), context),
                onStartPopGesture: () {
                  assert(_isPopGestureEnabled(route, canSwipe(route), context));
                  return _startPopGesture(route);
                },
                limitedSwipe: limitedSwipe,
                gestureWidth:
                    route.gestureWidth?.call(context) ?? _kBackGestureWidth,
                initialOffset: initialOffset,
                child: child,
              ));

        case Transition.size:
          return SizeTransitions().buildTransitions(
              context,
              route.curve!,
              route.alignment,
              animation,
              secondaryAnimation,
              GetBackGestureDetector<T>(
                popGestureEnable: () =>
                    _isPopGestureEnabled(route, canSwipe(route), context),
                onStartPopGesture: () {
                  assert(_isPopGestureEnabled(route, canSwipe(route), context));
                  return _startPopGesture(route);
                },
                limitedSwipe: limitedSwipe,
                gestureWidth:
                    route.gestureWidth?.call(context) ?? _kBackGestureWidth,
                initialOffset: initialOffset,
                child: child,
              ));

        case Transition.fade:
          return const FadeUpwardsPageTransitionsBuilder().buildTransitions(
              route,
              context,
              animation,
              secondaryAnimation,
              GetBackGestureDetector<T>(
                popGestureEnable: () =>
                    _isPopGestureEnabled(route, canSwipe(route), context),
                onStartPopGesture: () {
                  assert(_isPopGestureEnabled(route, canSwipe(route), context));
                  return _startPopGesture(route);
                },
                limitedSwipe: limitedSwipe,
                gestureWidth:
                    route.gestureWidth?.call(context) ?? _kBackGestureWidth,
                initialOffset: initialOffset,
                child: child,
              ));

        case Transition.topLevel:
          return const ZoomPageTransitionsBuilder().buildTransitions(
              route,
              context,
              animation,
              secondaryAnimation,
              GetBackGestureDetector<T>(
                popGestureEnable: () =>
                    _isPopGestureEnabled(route, canSwipe(route), context),
                onStartPopGesture: () {
                  assert(_isPopGestureEnabled(route, canSwipe(route), context));
                  return _startPopGesture(route);
                },
                limitedSwipe: limitedSwipe,
                gestureWidth:
                    route.gestureWidth?.call(context) ?? _kBackGestureWidth,
                initialOffset: initialOffset,
                child: child,
              ));

        case Transition.native:
          return const PageTransitionsTheme().buildTransitions(
              route,
              context,
              iosAnimation,
              secondaryAnimation,
              GetBackGestureDetector<T>(
                popGestureEnable: () =>
                    _isPopGestureEnabled(route, canSwipe(route), context),
                onStartPopGesture: () {
                  assert(_isPopGestureEnabled(route, canSwipe(route), context));
                  return _startPopGesture(route);
                },
                limitedSwipe: limitedSwipe,
                gestureWidth:
                    route.gestureWidth?.call(context) ?? _kBackGestureWidth,
                initialOffset: initialOffset,
                child: child,
              ));

        case Transition.circularReveal:
          return CircularRevealTransition().buildTransitions(
              context,
              route.curve,
              route.alignment,
              animation,
              secondaryAnimation,
              GetBackGestureDetector<T>(
                popGestureEnable: () =>
                    _isPopGestureEnabled(route, canSwipe(route), context),
                onStartPopGesture: () {
                  assert(_isPopGestureEnabled(route, canSwipe(route), context));
                  return _startPopGesture(route);
                },
                limitedSwipe: limitedSwipe,
                gestureWidth:
                    route.gestureWidth?.call(context) ?? _kBackGestureWidth,
                initialOffset: initialOffset,
                child: child,
              ));

        default:
          final customTransition = GetRoot.of(context).config.customTransition;

          if (customTransition != null) {
            return customTransition.buildTransition(context, route.curve,
                route.alignment, animation, secondaryAnimation, child);
          }

          PageTransitionsTheme pageTransitionsTheme =
              Theme.of(context).pageTransitionsTheme;

          return pageTransitionsTheme.buildTransitions(
              route,
              context,
              iosAnimation,
              secondaryAnimation,
              GetBackGestureDetector<T>(
                popGestureEnable: () =>
                    _isPopGestureEnabled(route, canSwipe(route), context),
                onStartPopGesture: () {
                  assert(
                    _isPopGestureEnabled(route, canSwipe(route), context),
                  );
                  return _startPopGesture(route);
                },
                limitedSwipe: limitedSwipe,
                gestureWidth:
                    route.gestureWidth?.call(context) ?? _kBackGestureWidth,
                initialOffset: initialOffset,
                child: child,
              ));
      }
    }
  }

  // Called by GetBackGestureDetector when a pop ("back") drag start
  // gesture is detected. The returned controller handles all of the subsequent
  // drag events.
  /// True if an iOS-style back swipe pop gesture is currently
  /// underway for [route].
  ///
  /// This just check the route's [NavigatorState.userGestureInProgress].
  ///
  /// See also:
  ///
  ///  * [popGestureEnabled], which returns true if a user-triggered pop gesture
  ///    would be allowed.
  static bool isPopGestureInProgress(BuildContext context) {
    final route = ModalRoute.of(context)!;
    return route.navigator!.userGestureInProgress;
  }

  static bool _isPopGestureEnabled<T>(
      PageRoute<T> route, bool canSwipe, BuildContext context) {
    // If there's nothing to go back to, then obviously we don't support
    // the back gesture.
    if (route.isFirst) return false;
    // If the route wouldn't actually pop if we popped it, then the gesture
    // would be really confusing (or would skip internal routes),
    // so disallow it.
    if (route.willHandlePopInternally) return false;
    // support [PopScope]
    if (route.popDisposition == RoutePopDisposition.doNotPop) return false;
    // Fullscreen dialogs aren't dismissible by back swipe.
    if (route.fullscreenDialog) return false;
    // If we're in an animation already, we cannot be manually swiped.
    if (route.animation!.status != AnimationStatus.completed) return false;
    // If we're being popped into, we also cannot be swiped until the pop above
    // it completes. This translates to our secondary animation being
    // dismissed.
    if (route.secondaryAnimation!.status != AnimationStatus.dismissed) {
      return false;
    }
    // If we're in a gesture already, we cannot start another.
    if (GetPageRouteTransitionMixin.isPopGestureInProgress(context)) {
      return false;
    }

    // Don't perfome swipe if canSwipe be false
    if (!canSwipe) return false;

    // Looks like a back gesture would be welcome!
    return true;
  }

  static GetBackGestureController<T> _startPopGesture<T>(
    PageRoute<T> route,
  ) {
    return GetBackGestureController<T>(
      navigator: route.navigator!,
      controller: route.controller!, // protected access
    );
  }
}

class _DirectionalityDragGestureRecognizer
    extends HorizontalDragGestureRecognizer {
  final ValueGetter<bool> popGestureEnable;
  final ValueGetter<bool> hasbackGestureController;
  final bool isRTL;
  final bool isLTR;

  _DirectionalityDragGestureRecognizer({
    required this.isRTL,
    required this.isLTR,
    required this.popGestureEnable,
    required this.hasbackGestureController,
    super.debugOwner,
  });

  @override
  void handleEvent(PointerEvent event) {
    final dx = event.delta.dx;
    if (hasbackGestureController() ||
        popGestureEnable() && (isRTL && dx < 0 || isLTR && dx > 0 || dx == 0)) {
      super.handleEvent(event);
    } else {
      stopTrackingPointer(event.pointer);
    }
  }
}
\n\n--- File: 24 # lib/get_navigation/src/routes/transitions_type.dart ---\nimport 'package:flutter/widgets.dart';

import 'default_route.dart';

enum Transition {
  fade,
  fadeIn,
  rightToLeft,
  leftToRight,
  upToDown,
  downToUp,
  rightToLeftWithFade,
  leftToRightWithFade,
  zoom,
  topLevel,
  noTransition,
  cupertino,
  cupertinoDialog,
  size,
  circularReveal,
  native,
}

typedef GetPageBuilder = Widget Function();
typedef GetRouteAwarePageBuilder<T> = Widget Function([GetPageRoute<T>? route]);
\n\n--- File: 25 # lib/get_navigation/src/routes/custom_transition.dart ---\nimport 'package:flutter/widgets.dart';

// ignore: one_member_abstracts
abstract class CustomTransition {
  Widget buildTransition(
    BuildContext context,
    Curve? curve,
    Alignment? alignment,
    Animation<double> animation,
    Animation<double> secondaryAnimation,
    Widget child,
  );
}
\n\n--- File: 26 # lib/get_navigation/src/routes/get_route.dart ---\n// ignore_for_file: overridden_fields

import 'dart:async';

import 'package:flutter/cupertino.dart';
import 'package:flutter/foundation.dart';
import 'package:flutter/material.dart';

import '../../../get_instance/src/bindings_interface.dart';
import '../../../get_state_manager/src/simple/get_state.dart';
import '../../get_navigation.dart';

class GetPage<T> extends Page<T> {
  final GetPageBuilder page;
  final bool? popGesture;
  final Map<String, String>? parameters;
  final String? title;
  final Transition? transition;
  final Curve curve;
  final bool? participatesInRootNavigator;
  final Alignment? alignment;
  final bool maintainState;
  final bool opaque;
  final double Function(BuildContext context)? gestureWidth;
  final BindingsInterface? binding;
  final List<BindingsInterface> bindings;
  final List<Bind> binds;
  final CustomTransition? customTransition;
  final Duration? transitionDuration;
  final Duration? reverseTransitionDuration;
  final bool fullscreenDialog;
  final bool preventDuplicates;
  final Completer<T?>? completer;
  // @override
  // final LocalKey? key;

  // @override
  // RouteSettings get settings => this;

  @override
  final Object? arguments;

  @override
  final String name;

  final bool inheritParentPath;

  final List<GetPage> children;
  final List<GetMiddleware> middlewares;
  final PathDecoded path;
  final GetPage? unknownRoute;
  final bool showCupertinoParallax;

  final PreventDuplicateHandlingMode preventDuplicateHandlingMode;

  static void _defaultPopInvokedHandler(bool didPop, Object? result) {}

  GetPage({
    required this.name,
    required this.page,
    this.title,
    this.participatesInRootNavigator,
    this.gestureWidth,
    // RouteSettings settings,
    this.maintainState = true,
    this.curve = Curves.linear,
    this.alignment,
    this.parameters,
    this.opaque = true,
    this.transitionDuration,
    this.reverseTransitionDuration,
    this.popGesture,
    this.binding,
    this.bindings = const [],
    this.binds = const [],
    this.transition,
    this.customTransition,
    this.fullscreenDialog = false,
    this.children = const <GetPage>[],
    this.middlewares = const [],
    this.unknownRoute,
    this.arguments,
    this.showCupertinoParallax = true,
    this.preventDuplicates = true,
    this.preventDuplicateHandlingMode =
        PreventDuplicateHandlingMode.reorderRoutes,
    this.completer,
    this.inheritParentPath = true,
    LocalKey? key,
    super.canPop,
    super.onPopInvoked = _defaultPopInvokedHandler,
    super.restorationId,
  })  : path = _nameToRegex(name),
        assert(name.startsWith('/'),
            'It is necessary to start route name [$name] with a slash: /$name'),
        super(
          key: key ?? ValueKey(name),
          name: name,
          // arguments: Get.arguments,
        );
  // settings = RouteSettings(name: name, arguments: Get.arguments);

  GetPage<T> copyWith({
    LocalKey? key,
    String? name,
    GetPageBuilder? page,
    bool? popGesture,
    Map<String, String>? parameters,
    String? title,
    Transition? transition,
    Curve? curve,
    Alignment? alignment,
    bool? maintainState,
    bool? opaque,
    List<BindingsInterface>? bindings,
    BindingsInterface? binding,
    List<Bind>? binds,
    CustomTransition? customTransition,
    Duration? transitionDuration,
    Duration? reverseTransitionDuration,
    bool? fullscreenDialog,
    RouteSettings? settings,
    List<GetPage<T>>? children,
    GetPage? unknownRoute,
    List<GetMiddleware>? middlewares,
    bool? preventDuplicates,
    final double Function(BuildContext context)? gestureWidth,
    bool? participatesInRootNavigator,
    Object? arguments,
    bool? showCupertinoParallax,
    Completer<T?>? completer,
    bool? inheritParentPath,
    bool? canPop,
    PopInvokedWithResultCallback<T>? onPopInvoked,
    String? restorationId,
  }) {
    return GetPage(
      key: key ?? this.key,
      participatesInRootNavigator:
          participatesInRootNavigator ?? this.participatesInRootNavigator,
      preventDuplicates: preventDuplicates ?? this.preventDuplicates,
      name: name ?? this.name,
      page: page ?? this.page,
      popGesture: popGesture ?? this.popGesture,
      parameters: parameters ?? this.parameters,
      title: title ?? this.title,
      transition: transition ?? this.transition,
      curve: curve ?? this.curve,
      alignment: alignment ?? this.alignment,
      maintainState: maintainState ?? this.maintainState,
      opaque: opaque ?? this.opaque,
      bindings: bindings ?? this.bindings,
      binds: binds ?? this.binds,
      binding: binding ?? this.binding,
      customTransition: customTransition ?? this.customTransition,
      transitionDuration: transitionDuration ?? this.transitionDuration,
      reverseTransitionDuration:
          reverseTransitionDuration ?? this.reverseTransitionDuration,
      fullscreenDialog: fullscreenDialog ?? this.fullscreenDialog,
      children: children ?? this.children,
      unknownRoute: unknownRoute ?? this.unknownRoute,
      middlewares: middlewares ?? this.middlewares,
      gestureWidth: gestureWidth ?? this.gestureWidth,
      arguments: arguments ?? this.arguments,
      showCupertinoParallax:
          showCupertinoParallax ?? this.showCupertinoParallax,
      completer: completer ?? this.completer,
      inheritParentPath: inheritParentPath ?? this.inheritParentPath,
      canPop: canPop ?? this.canPop,
      onPopInvoked: onPopInvoked ?? this.onPopInvoked,
      restorationId: restorationId ?? restorationId,
    );
  }

  @override
  Route<T> createRoute(BuildContext context) {
    // return GetPageRoute<T>(settings: this, page: page);
    final page = PageRedirect(
      route: this,
      settings: this,
      unknownRoute: unknownRoute,
    ).getPageToRoute<T>(this, unknownRoute, context);

    return page;
  }

  static PathDecoded _nameToRegex(String path) {
    var keys = <String?>[];

    String recursiveReplace(Match pattern) {
      var buffer = StringBuffer('(?:');

      if (pattern[1] != null) buffer.write('.');
      buffer.write('([\\w%+-._~!\$&\'()*,;=:@]+))');
      if (pattern[3] != null) buffer.write('?');

      keys.add(pattern[2]);
      return "$buffer";
    }

    var stringPath = '$path/?'
        .replaceAllMapped(RegExp(r'(\.)?:(\w+)(\?)?'), recursiveReplace)
        .replaceAll('//', '/');

    return PathDecoded(RegExp('^$stringPath\$'), keys);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    return other is GetPage<T> && other.key == key;
  }

  @override
  String toString() =>
      '${objectRuntimeType(this, 'Page')}("$name", $key, $arguments)';

  @override
  int get hashCode {
    return key.hashCode;
  }
}

@immutable
class PathDecoded {
  final RegExp regex;
  final List<String?> keys;
  const PathDecoded(this.regex, this.keys);

  @override
  int get hashCode => regex.hashCode;

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;

    return other is PathDecoded &&
        other.regex == regex; // && listEquals(other.keys, keys);
  }
}
\n\n--- File: 29 # lib/get_navigation/src/routes/default_route.dart ---\nimport 'package:flutter/cupertino.dart';

import '../../../get.dart';
import '../router_report.dart';

@optionalTypeArgs
mixin RouteReportMixin<T extends StatefulWidget> on State<T> {
  @override
  void initState() {
    super.initState();
    RouterReportManager.instance.reportCurrentRoute(this);
  }

  @override
  void dispose() {
    super.dispose();
    RouterReportManager.instance.reportRouteDispose(this);
  }
}

mixin PageRouteReportMixin<T> on Route<T> {
  @override
  void install() {
    super.install();
    RouterReportManager.instance.reportCurrentRoute(this);
  }

  @override
  void dispose() {
    super.dispose();
    RouterReportManager.instance.reportRouteDispose(this);
  }
}

class GetPageRoute<T> extends PageRoute<T>
    with GetPageRouteTransitionMixin<T>, PageRouteReportMixin {
  /// Creates a page route for use in an iOS designed app.
  ///
  /// The [builder], [maintainState], and [fullscreenDialog] arguments must not
  /// be null.
  GetPageRoute({
    super.settings,
    this.transitionDuration = const Duration(milliseconds: 300),
    this.reverseTransitionDuration = const Duration(milliseconds: 300),
    this.opaque = true,
    this.parameter,
    this.gestureWidth,
    this.curve,
    this.alignment,
    this.transition,
    this.popGesture,
    this.customTransition,
    this.barrierDismissible = false,
    this.barrierColor,
    BindingsInterface? binding,
    List<BindingsInterface> bindings = const [],
    this.binds,
    this.routeName,
    this.page,
    this.title,
    this.showCupertinoParallax = true,
    this.barrierLabel,
    this.maintainState = true,
    super.fullscreenDialog,
    this.middlewares,
  })  : bindings = (binding == null) ? bindings : [...bindings, binding],
        _middlewareRunner = MiddlewareRunner(middlewares);

  @override
  final Duration transitionDuration;
  @override
  final Duration reverseTransitionDuration;

  final GetPageBuilder? page;
  final String? routeName;
  //final String reference;
  final CustomTransition? customTransition;
  final List<BindingsInterface> bindings;
  final Map<String, String>? parameter;
  final List<Bind>? binds;

  @override
  final bool showCupertinoParallax;

  @override
  final bool opaque;
  final bool? popGesture;

  @override
  final bool barrierDismissible;
  final Transition? transition;
  final Curve? curve;
  final Alignment? alignment;
  final List<GetMiddleware>? middlewares;

  @override
  final Color? barrierColor;

  @override
  final String? barrierLabel;

  @override
  final bool maintainState;

  final MiddlewareRunner _middlewareRunner;

  @override
  void dispose() {
    super.dispose();
    _middlewareRunner.runOnPageDispose();
    _child = null;
  }

  Widget? _child;

  Widget _getChild() {
    if (_child != null) return _child!;

    final localBinds = [if (binds != null) ...binds!];

    final bindingsToBind = _middlewareRunner
        .runOnBindingsStart(bindings.isNotEmpty ? bindings : localBinds);

    final pageToBuild = _middlewareRunner.runOnPageBuildStart(page)!;

    if (bindingsToBind != null && bindingsToBind.isNotEmpty) {
      if (bindingsToBind is List<BindingsInterface>) {
        for (final item in bindingsToBind) {
          final dep = item.dependencies();
          if (dep is List<Bind>) {
            _child = Binds(
              binds: dep,
              child: _middlewareRunner.runOnPageBuilt(pageToBuild()),
            );
          }
        }
      } else if (bindingsToBind is List<Bind>) {
        _child = Binds(
          binds: bindingsToBind,
          child: _middlewareRunner.runOnPageBuilt(pageToBuild()),
        );
      }
    }

    return _child ??= _middlewareRunner.runOnPageBuilt(pageToBuild());
  }

  @override
  Widget buildContent(BuildContext context) {
    return _getChild();
  }

  @override
  final String? title;

  @override
  String get debugLabel => '${super.debugLabel}(${settings.name})';

  @override
  final double Function(BuildContext context)? gestureWidth;
}
\n\n--- File: 34 # lib/get_navigation/src/routes/observers/route_observer.dart ---\nimport 'package:flutter/widgets.dart';

import '../../../../get_core/get_core.dart';
import '../../../../instance_manager.dart';
import '../../../get_navigation.dart';
import '../../dialog/dialog_route.dart';
import '../../router_report.dart';

/// Extracts the name of a route based on it's instance type
/// or null if not possible.
String? _extractRouteName(Route? route) {
  if (route?.settings.name != null) {
    return route!.settings.name;
  }

  if (route is GetPageRoute) {
    return route.routeName;
  }

  if (route is GetDialogRoute) {
    return 'DIALOG ${route.hashCode}';
  }

  if (route is GetModalBottomSheetRoute) {
    return 'BOTTOMSHEET ${route.hashCode}';
  }

  return null;
}

class GetObserver extends NavigatorObserver {
  final Function(Routing?)? routing;

  final Routing? _routeSend;

  GetObserver([this.routing, this._routeSend]);

  @override
  void didPop(Route route, Route? previousRoute) {
    super.didPop(route, previousRoute);
    final currentRoute = _RouteData.ofRoute(route);
    final newRoute = _RouteData.ofRoute(previousRoute);

    if (currentRoute.isBottomSheet || currentRoute.isDialog) {
      Get.log("CLOSE ${currentRoute.name}");
    } else if (currentRoute.isGetPageRoute) {
      Get.log("CLOSE TO ROUTE ${currentRoute.name}");
    }
    if (previousRoute != null) {
      RouterReportManager.instance.reportCurrentRoute(previousRoute);
    }

    // Here we use a 'inverse didPush set', meaning that we use
    // previous route instead of 'route' because this is
    // a 'inverse push'
    _routeSend?.update((value) {
      // Only PageRoute is allowed to change current value
      if (previousRoute is PageRoute) {
        value.current = _extractRouteName(previousRoute) ?? '';
        value.previous = newRoute.name ?? '';
      } else if (value.previous.isNotEmpty) {
        value.current = value.previous;
      }

      value.args = previousRoute?.settings.arguments;
      value.route = previousRoute;
      value.isBack = true;
      value.removed = '';
      value.isBottomSheet = newRoute.isBottomSheet;
      value.isDialog = newRoute.isDialog;
    });

    routing?.call(_routeSend);
  }

  @override
  void didPush(Route route, Route? previousRoute) {
    super.didPush(route, previousRoute);
    final newRoute = _RouteData.ofRoute(route);

    if (newRoute.isBottomSheet || newRoute.isDialog) {
      Get.log("OPEN ${newRoute.name}");
    } else if (newRoute.isGetPageRoute) {
      Get.log("GOING TO ROUTE ${newRoute.name}");
    }

    RouterReportManager.instance.reportCurrentRoute(route);
    _routeSend?.update((value) {
      if (route is PageRoute) {
        value.current = newRoute.name ?? '';
      }
      final previousRouteName = _extractRouteName(previousRoute);
      if (previousRouteName != null) {
        value.previous = previousRouteName;
      }

      value.args = route.settings.arguments;
      value.route = route;
      value.isBack = false;
      value.removed = '';
      value.isBottomSheet =
          newRoute.isBottomSheet ? true : value.isBottomSheet ?? false;
      value.isDialog = newRoute.isDialog ? true : value.isDialog ?? false;
    });

    if (routing != null) {
      routing!(_routeSend);
    }
  }

  @override
  void didRemove(Route route, Route? previousRoute) {
    super.didRemove(route, previousRoute);
    final routeName = _extractRouteName(route);
    final currentRoute = _RouteData.ofRoute(route);
    final previousRouteName = _extractRouteName(previousRoute);

    Get.log("REMOVING ROUTE $routeName");
    Get.log("PREVIOUS ROUTE $previousRouteName");

    _routeSend?.update((value) {
      value.route = previousRoute;
      value.isBack = false;
      value.removed = routeName ?? '';
      value.previous = previousRouteName ?? '';
      value.isBottomSheet =
          currentRoute.isBottomSheet ? false : value.isBottomSheet;
      value.isDialog = currentRoute.isDialog ? false : value.isDialog;
    });

    if (route is GetPageRoute) {
      RouterReportManager.instance.reportRouteWillDispose(route);
    }
    routing?.call(_routeSend);
  }

  @override
  void didReplace({Route? newRoute, Route? oldRoute}) {
    super.didReplace(newRoute: newRoute, oldRoute: oldRoute);
    final newName = _extractRouteName(newRoute);
    final oldName = _extractRouteName(oldRoute);
    final currentRoute = _RouteData.ofRoute(oldRoute);

    Get.log("REPLACE ROUTE $oldName");
    Get.log("NEW ROUTE $newName");

    if (newRoute != null) {
      RouterReportManager.instance.reportCurrentRoute(newRoute);
    }

    _routeSend?.update((value) {
      // Only PageRoute is allowed to change current value
      if (newRoute is PageRoute) {
        value.current = newName ?? '';
      }

      value.args = newRoute?.settings.arguments;
      value.route = newRoute;
      value.isBack = false;
      value.removed = '';
      value.previous = oldName ?? '';
      value.isBottomSheet =
          currentRoute.isBottomSheet ? false : value.isBottomSheet;
      value.isDialog = currentRoute.isDialog ? false : value.isDialog;
    });
    if (oldRoute is GetPageRoute) {
      RouterReportManager.instance.reportRouteWillDispose(oldRoute);
    }

    routing?.call(_routeSend);
  }
}

//TODO: Use copyWith, and remove mutate variables
class Routing {
  String current;
  String previous;
  dynamic args;
  String removed;
  Route<dynamic>? route;
  bool? isBack;
  bool? isBottomSheet;
  bool? isDialog;

  Routing({
    this.current = '',
    this.previous = '',
    this.args,
    this.removed = '',
    this.route,
    this.isBack,
    this.isBottomSheet,
    this.isDialog,
  });

  void update(void Function(Routing value) fn) {
    fn(this);
  }
}

/// This is basically a util for rules about 'what a route is'
class _RouteData {
  final bool isGetPageRoute;
  final bool isBottomSheet;
  final bool isDialog;
  final String? name;

  const _RouteData({
    required this.name,
    required this.isGetPageRoute,
    required this.isBottomSheet,
    required this.isDialog,
  });

  factory _RouteData.ofRoute(Route? route) {
    return _RouteData(
      name: _extractRouteName(route),
      isGetPageRoute: route is GetPageRoute,
      isDialog: route is GetDialogRoute,
      isBottomSheet: route is GetModalBottomSheetRoute,
    );
  }
}


Please provide:
1. A high-level `summary` of the project's main purpose and functionality in a few beginner-friendly sentences. Use markdown formatting with **bold** and *italic* text to highlight important concepts.
2. A list (`relationships`) describing the key interactions between these abstractions. For each relationship, specify:
    - `from_abstraction`: Index of the source abstraction (e.g., `0 # AbstractionName1`)
    - `to_abstraction`: Index of the target abstraction (e.g., `1 # AbstractionName2`)
    - `label`: A brief label for the interaction **in just a few words** (e.g., "Manages", "Inherits", "Uses").
    Ideally the relationship should be backed by one abstraction calling or passing parameters to another.
    Simplify the relationship and exclude those non-important ones.

IMPORTANT: Make sure EVERY abstraction is involved in at least ONE relationship (either as source or target). Each abstraction index must appear at least once across all relationships.

Format the output as YAML:

```yaml
summary: |
  A brief, simple explanation of the project.
  Can span multiple lines with **bold** and *italic* for emphasis.
relationships:
  - from_abstraction: 0 # AbstractionName1
    to_abstraction: 1 # AbstractionName2
    label: "Manages"
  - from_abstraction: 2 # AbstractionName3
    to_abstraction: 0 # AbstractionName1
    label: "Provides config"
  # ... other relationships
```

Now, provide the YAML output:

2025-05-16 11:05:18,080 - INFO - RESPONSE: ```yaml
summary: |
  GetX is a powerful and lightweight Flutter framework designed to simplify and accelerate app development.
  It provides an *extensible* and *easy-to-use* solution for **state management**, **dependency injection**, and **route management**,
  aiming for high *productivity* and *performance* without relying heavily on `BuildContext`.
relationships:
  - from_abstraction: 1 # GetNavigation Extensions (e.g., Get.toNamed, Get.snackbar)
    to_abstraction: 3 # Overlay Management (Snackbar, Dialog, BottomSheet)
    label: "Shows Overlays"
  - from_abstraction: 1 # GetNavigation Extensions (e.g., Get.toNamed, Get.snackbar)
    to_abstraction: 0 # GetPage & GetRouterDelegate
    label: "Initiates Navigation"
  - from_abstraction: 2 # GetMaterialApp / GetCupertinoApp & GetRoot
    to_abstraction: 0 # GetPage & GetRouterDelegate
    label: "Configures & Initializes"
  - from_abstraction: 0 # GetPage & GetRouterDelegate
    to_abstraction: 4 # Route Parsing & Configuration (RouteDecoder, PageSettings, ParseRouteTree)
    label: "Uses for Route Matching"
  - from_abstraction: 0 # GetPage & GetRouterDelegate
    to_abstraction: 5 # GetMiddleware
    label: "Executes Middlewares"
  - from_abstraction: 0 # GetPage & GetRouterDelegate
    to_abstraction: 7 # Transition System (GetPageRouteTransitionMixin, CustomTransition, Transitions)
    label: "Applies Transitions"
  - from_abstraction: 3 # Overlay Management (Snackbar, Dialog, BottomSheet)
    to_abstraction: 6 # RouterReportManager
    label: "Reports Lifecycle"
  - from_abstraction: 2 # GetMaterialApp / GetCupertinoApp & GetRoot
    to_abstraction: 3 # Overlay Management (Snackbar, Dialog, BottomSheet)
    label: "Provides Overlay Context"
  - from_abstraction: 7 # Transition System (GetPageRouteTransitionMixin, CustomTransition, Transitions)
    to_abstraction: 6 # RouterReportManager
    label: "Reports Lifecycle"
  - from_abstraction: 2 # GetMaterialApp / GetCupertinoApp & GetRoot
    to_abstraction: 6 # RouterReportManager
    label: "Manages Lifecycle"
```
2025-05-16 11:05:18,161 - INFO - PROMPT: 
Given the following project abstractions and their relationships for the project ```` getx ````:

Abstractions (Index # Name):
- 0 # GetPage & GetRouterDelegate

- 1 # GetNavigation Extensions (e.g., Get.toNamed, Get.snackbar)

- 2 # GetMaterialApp / GetCupertinoApp & GetRoot

- 3 # Overlay Management (Snackbar, Dialog, BottomSheet)

- 4 # Route Parsing & Configuration (RouteDecoder, PageSettings, ParseRouteTree)

- 5 # GetMiddleware

- 6 # RouterReportManager

- 7 # Transition System (GetPageRouteTransitionMixin, CustomTransition, Transitions)


Context about relationships and project summary:
Project Summary:
GetX is a powerful and lightweight Flutter framework designed to simplify and accelerate app development.
It provides an *extensible* and *easy-to-use* solution for **state management**, **dependency injection**, and **route management**,
aiming for high *productivity* and *performance* without relying heavily on `BuildContext`.


Relationships (Indices refer to abstractions above):
- From 1 (GetNavigation Extensions (e.g., Get.toNamed, Get.snackbar)
) to 3 (Overlay Management (Snackbar, Dialog, BottomSheet)
): Shows Overlays
- From 1 (GetNavigation Extensions (e.g., Get.toNamed, Get.snackbar)
) to 0 (GetPage & GetRouterDelegate
): Initiates Navigation
- From 2 (GetMaterialApp / GetCupertinoApp & GetRoot
) to 0 (GetPage & GetRouterDelegate
): Configures & Initializes
- From 0 (GetPage & GetRouterDelegate
) to 4 (Route Parsing & Configuration (RouteDecoder, PageSettings, ParseRouteTree)
): Uses for Route Matching
- From 0 (GetPage & GetRouterDelegate
) to 5 (GetMiddleware
): Executes Middlewares
- From 0 (GetPage & GetRouterDelegate
) to 7 (Transition System (GetPageRouteTransitionMixin, CustomTransition, Transitions)
): Applies Transitions
- From 3 (Overlay Management (Snackbar, Dialog, BottomSheet)
) to 6 (RouterReportManager
): Reports Lifecycle
- From 2 (GetMaterialApp / GetCupertinoApp & GetRoot
) to 3 (Overlay Management (Snackbar, Dialog, BottomSheet)
): Provides Overlay Context
- From 7 (Transition System (GetPageRouteTransitionMixin, CustomTransition, Transitions)
) to 6 (RouterReportManager
): Reports Lifecycle
- From 2 (GetMaterialApp / GetCupertinoApp & GetRoot
) to 6 (RouterReportManager
): Manages Lifecycle


If you are going to make a tutorial for ```` getx ````, what is the best order to explain these abstractions, from first to last?
Ideally, first explain those that are the most important or foundational, perhaps user-facing concepts or entry points. Then move to more detailed, lower-level implementation details or supporting concepts.

Output the ordered list of abstraction indices, including the name in a comment for clarity. Use the format `idx # AbstractionName`.

```yaml
- 2 # FoundationalConcept
- 0 # CoreClassA
- 1 # CoreClassB (uses CoreClassA)
- ...
```

Now, provide the YAML output:

2025-05-16 11:05:46,844 - INFO - RESPONSE: ```yaml
- 2 # GetMaterialApp / GetCupertinoApp & GetRoot
- 1 # GetNavigation Extensions (e.g., Get.toNamed, Get.snackbar)
- 0 # GetPage & GetRouterDelegate
- 3 # Overlay Management (Snackbar, Dialog, BottomSheet)
- 4 # Route Parsing & Configuration (RouteDecoder, PageSettings, ParseRouteTree)
- 5 # GetMiddleware
- 7 # Transition System (GetPageRouteTransitionMixin, CustomTransition, Transitions)
- 6 # RouterReportManager
```
2025-05-16 11:05:46,923 - INFO - PROMPT: 
Write a very beginner-friendly tutorial chapter (in Markdown format) for the project `getx` about the concept: "GetMaterialApp / GetCupertinoApp & GetRoot
". This is Chapter 1.

Concept Details:
- Name: GetMaterialApp / GetCupertinoApp & GetRoot

- Description:
`GetMaterialApp` (for Material Design) and `GetCupertinoApp` (for iOS-style apps) are special versions of Flutter's root app widgets. They initialize the GetX framework, setting up the necessary infrastructure for routing, dependency management, and internationalization.
`GetRoot` is the underlying widget that `GetMaterialApp` and `GetCupertinoApp` use to manage global configurations and state for the GetX system. It's like the main power supply and configuration panel for the entire GetX ecosystem in your app.


Complete Tutorial Structure:
1. [GetMaterialApp / GetCupertinoApp & GetRoot
](01_getmaterialapp___getcupertinoapp___getroot_.md)
2. [GetNavigation Extensions (e.g., Get.toNamed, Get.snackbar)
](02_getnavigation_extensions__e_g___get_tonamed__get_snackbar__.md)
3. [GetPage & GetRouterDelegate
](03_getpage___getrouterdelegate_.md)
4. [Overlay Management (Snackbar, Dialog, BottomSheet)
](04_overlay_management__snackbar__dialog__bottomsheet__.md)
5. [Route Parsing & Configuration (RouteDecoder, PageSettings, ParseRouteTree)
](05_route_parsing___configuration__routedecoder__pagesettings__parseroutetree__.md)
6. [GetMiddleware
](06_getmiddleware_.md)
7. [Transition System (GetPageRouteTransitionMixin, CustomTransition, Transitions)
](07_transition_system__getpageroutetransitionmixin__customtransition__transitions__.md)
8. [RouterReportManager
](08_routerreportmanager_.md)

Context from previous chapters:
This is the first chapter.

Relevant Code Snippets (Code itself remains unchanged):
--- File: lib/get_navigation/src/root/get_cupertino_app.dart ---
import 'package:flutter/cupertino.dart';
import 'package:flutter/foundation.dart';
import 'package:flutter/material.dart';

import '../../../get_core/get_core.dart';
import '../../../get_instance/get_instance.dart';
import '../../../get_state_manager/get_state_manager.dart';
import '../../../get_utils/get_utils.dart';
import '../../get_navigation.dart';
import 'get_root.dart';

class GetCupertinoApp extends StatelessWidget {
  final GlobalKey<NavigatorState>? navigatorKey;
  final Widget? home;
  final Map<String, WidgetBuilder>? routes;
  final String? initialRoute;
  final RouteFactory? onGenerateRoute;
  final InitialRouteListFactory? onGenerateInitialRoutes;
  final RouteFactory? onUnknownRoute;
  final List<NavigatorObserver>? navigatorObservers;
  final TransitionBuilder? builder;
  final String title;
  final GenerateAppTitle? onGenerateTitle;
  final CustomTransition? customTransition;
  final Color? color;
  final Map<String, Map<String, String>>? translationsKeys;
  final Translations? translations;
  final TextDirection? textDirection;
  final Locale? locale;
  final Locale? fallbackLocale;
  final Iterable<LocalizationsDelegate<dynamic>>? localizationsDelegates;
  final LocaleListResolutionCallback? localeListResolutionCallback;
  final LocaleResolutionCallback? localeResolutionCallback;
  final Iterable<Locale> supportedLocales;
  final bool showPerformanceOverlay;
  final bool checkerboardRasterCacheImages;
  final bool checkerboardOffscreenLayers;
  final bool showSemanticsDebugger;
  final bool debugShowCheckedModeBanner;
  final Map<LogicalKeySet, Intent>? shortcuts;
  final ThemeData? highContrastTheme;
  final ThemeData? highContrastDarkTheme;
  final Map<Type, Action<Intent>>? actions;
  final Function(Routing?)? routingCallback;
  final Transition? defaultTransition;
  final bool? opaqueRoute;
  final VoidCallback? onInit;
  final VoidCallback? onReady;
  final VoidCallback? onDispose;
  final bool? enableLog;
  final LogWriterCallback? logWriterCallback;
  final bool? popGesture;
  final SmartManagement smartManagement;
  final BindingsInterface? initialBinding;
  final Duration? transitionDuration;
  final bool? defaultGlobalState;
  final List<GetPage>? getPages;
  final GetPage? unknownRoute;
  final RouteInformationProvider? routeInformationProvider;
  final RouteInformationParser<Object>? routeInformationParser;
  final RouterDelegate<Object>? routerDelegate;
  final RouterConfig<Object>? routerConfig;
  final BackButtonDispatcher? backButtonDispatcher;
  final CupertinoThemeData? theme;
  final bool useInheritedMediaQuery;
  final List<Bind> binds;
  final ScrollBehavior? scrollBehavior;

  const GetCupertinoApp({
    super.key,
    this.theme,
    this.navigatorKey,
    this.home,
    Map<String, Widget Function(BuildContext)> this.routes =
        const <String, WidgetBuilder>{},
    this.initialRoute,
    this.onGenerateRoute,
    this.onGenerateInitialRoutes,
    this.onUnknownRoute,
    List<NavigatorObserver> this.navigatorObservers =
        const <NavigatorObserver>[],
    this.builder,
    this.translationsKeys,
    this.translations,
    this.textDirection,
    this.title = '',
    this.onGenerateTitle,
    this.color,
    this.customTransition,
    this.onInit,
    this.onDispose,
    this.locale,
    this.binds = const [],
    this.scrollBehavior,
    this.fallbackLocale,
    this.localizationsDelegates,
    this.localeListResolutionCallback,
    this.localeResolutionCallback,
    this.supportedLocales = const <Locale>[Locale('en', 'US')],
    this.showPerformanceOverlay = false,
    this.checkerboardRasterCacheImages = false,
    this.checkerboardOffscreenLayers = false,
    this.showSemanticsDebugger = false,
    this.debugShowCheckedModeBanner = true,
    this.shortcuts,
    this.smartManagement = SmartManagement.full,
    this.initialBinding,
    this.useInheritedMediaQuery = false,
    this.unknownRoute,
    this.routingCallback,
    this.defaultTransition,
    this.onReady,
    this.getPages,
    this.opaqueRoute,
    this.enableLog = kDebugMode,
    this.logWriterCallback,
    this.popGesture,
    this.transitionDuration,
    this.defaultGlobalState,
    this.highContrastTheme,
    this.highContrastDarkTheme,
    this.actions,
  })  : routeInformationProvider = null,
        backButtonDispatcher = null,
        routeInformationParser = null,
        routerDelegate = null,
        routerConfig = null;

  const GetCupertinoApp.router({
    super.key,
    this.theme,
    this.routeInformationProvider,
    this.routeInformationParser,
    this.routerDelegate,
    this.routerConfig,
    this.backButtonDispatcher,
    this.builder,
    this.title = '',
    this.onGenerateTitle,
    this.useInheritedMediaQuery = false,
    this.color,
    this.highContrastTheme,
    this.highContrastDarkTheme,
    this.locale,
    this.localizationsDelegates,
    this.localeListResolutionCallback,
    this.localeResolutionCallback,
    this.supportedLocales = const <Locale>[Locale('en', 'US')],
    this.showPerformanceOverlay = false,
    this.checkerboardRasterCacheImages = false,
    this.checkerboardOffscreenLayers = false,
    this.showSemanticsDebugger = false,
    this.debugShowCheckedModeBanner = true,
    this.shortcuts,
    this.binds = const [],
    this.scrollBehavior,
    this.actions,
    this.customTransition,
    this.translationsKeys,
    this.translations,
    this.textDirection,
    this.fallbackLocale,
    this.routingCallback,
    this.defaultTransition,
    this.opaqueRoute,
    this.onInit,
    this.onReady,
    this.onDispose,
    this.enableLog = kDebugMode,
    this.logWriterCallback,
    this.popGesture,
    this.smartManagement = SmartManagement.full,
    this.initialBinding,
    this.transitionDuration,
    this.defaultGlobalState,
    this.getPages,
    this.navigatorObservers,
    this.unknownRoute,
  })  : navigatorKey = null,
        onGenerateRoute = null,
        home = null,
        onGenerateInitialRoutes = null,
        onUnknownRoute = null,
        routes = null,
        initialRoute = null;

  @override
  Widget build(BuildContext context) {
    return GetRoot(
      config: ConfigData(
        backButtonDispatcher: backButtonDispatcher,
        binds: binds,
        customTransition: customTransition,
        defaultGlobalState: defaultGlobalState,
        defaultTransition: defaultTransition,
        enableLog: enableLog,
        fallbackLocale: fallbackLocale,
        getPages: getPages,
        home: home,
        initialRoute: initialRoute,
        locale: locale,
        logWriterCallback: logWriterCallback,
        navigatorKey: navigatorKey,
        navigatorObservers: navigatorObservers,
        onDispose: onDispose,
        onInit: onInit,
        onReady: onReady,
        routeInformationParser: routeInformationParser,
        routeInformationProvider: routeInformationProvider,
        routerDelegate: routerDelegate,
        routingCallback: routingCallback,
        scaffoldMessengerKey: GlobalKey<ScaffoldMessengerState>(),
        smartManagement: smartManagement,
        transitionDuration: transitionDuration,
        translations: translations,
        translationsKeys: translationsKeys,
        unknownRoute: unknownRoute,
        defaultPopGesture: popGesture,
      ),
      child: Builder(builder: (context) {
        final controller = GetRoot.of(context);
        return CupertinoApp.router(
          routerDelegate: controller.config.routerDelegate,
          routeInformationParser: controller.config.routeInformationParser,
          backButtonDispatcher: backButtonDispatcher,
          routeInformationProvider: routeInformationProvider,
          routerConfig: routerConfig,
          key: controller.config.unikey,
          builder: (context, child) => Directionality(
            textDirection: textDirection ??
                (rtlLanguages.contains(Get.locale?.languageCode)
                    ? TextDirection.rtl
                    : TextDirection.ltr),
            child: builder == null
                ? (child ?? const Material())
                : builder!(context, child ?? const Material()),
          ),
          title: title,
          onGenerateTitle: onGenerateTitle,
          color: color,
          theme: theme,
          locale: Get.locale ?? locale,
          localizationsDelegates: localizationsDelegates,
          localeListResolutionCallback: localeListResolutionCallback,
          localeResolutionCallback: localeResolutionCallback,
          supportedLocales: supportedLocales,
          showPerformanceOverlay: showPerformanceOverlay,
          checkerboardRasterCacheImages: checkerboardRasterCacheImages,
          checkerboardOffscreenLayers: checkerboardOffscreenLayers,
          showSemanticsDebugger: showSemanticsDebugger,
          debugShowCheckedModeBanner: debugShowCheckedModeBanner,
          shortcuts: shortcuts,
          scrollBehavior: scrollBehavior,
        );
      }),
    );
  }
}


--- File: lib/get_navigation/src/root/get_material_app.dart ---
import 'package:flutter/foundation.dart';
import 'package:flutter/material.dart';
import 'package:get/instance_manager.dart';

import '../../../get_state_manager/get_state_manager.dart';
import '../../../get_utils/get_utils.dart';
import '../../get_navigation.dart';
import 'get_root.dart';

class GetMaterialApp extends StatelessWidget {
  final GlobalKey<NavigatorState>? navigatorKey;
  final GlobalKey<ScaffoldMessengerState>? scaffoldMessengerKey;
  final Widget? home;
  final Map<String, WidgetBuilder>? routes;
  final String? initialRoute;
  final RouteFactory? onGenerateRoute;
  final InitialRouteListFactory? onGenerateInitialRoutes;
  final RouteFactory? onUnknownRoute;
  final List<NavigatorObserver>? navigatorObservers;
  final TransitionBuilder? builder;
  final String title;
  final GenerateAppTitle? onGenerateTitle;
  final ThemeData? theme;
  final ThemeData? darkTheme;
  final ThemeMode themeMode;
  final CustomTransition? customTransition;
  final Color? color;
  final Map<String, Map<String, String>>? translationsKeys;
  final Translations? translations;
  final TextDirection? textDirection;
  final Locale? locale;
  final Locale? fallbackLocale;
  final Iterable<LocalizationsDelegate<dynamic>>? localizationsDelegates;
  final LocaleListResolutionCallback? localeListResolutionCallback;
  final LocaleResolutionCallback? localeResolutionCallback;
  final Iterable<Locale> supportedLocales;
  final bool showPerformanceOverlay;
  final bool checkerboardRasterCacheImages;
  final bool checkerboardOffscreenLayers;
  final bool showSemanticsDebugger;
  final bool debugShowCheckedModeBanner;
  final Map<LogicalKeySet, Intent>? shortcuts;
  final ScrollBehavior? scrollBehavior;
  final ThemeData? highContrastTheme;
  final ThemeData? highContrastDarkTheme;
  final Map<Type, Action<Intent>>? actions;
  final bool debugShowMaterialGrid;
  final ValueChanged<Routing?>? routingCallback;
  final Transition? defaultTransition;
  final bool? opaqueRoute;
  final VoidCallback? onInit;
  final VoidCallback? onReady;
  final VoidCallback? onDispose;
  final bool? enableLog;
  final LogWriterCallback? logWriterCallback;
  final bool? popGesture;
  final SmartManagement smartManagement;
  final List<Bind> binds;
  final Duration? transitionDuration;
  final bool? defaultGlobalState;
  final List<GetPage>? getPages;
  final GetPage? unknownRoute;
  final RouteInformationProvider? routeInformationProvider;
  final RouteInformationParser<Object>? routeInformationParser;
  final RouterDelegate<Object>? routerDelegate;
  final RouterConfig<Object>? routerConfig;
  final BackButtonDispatcher? backButtonDispatcher;
  final bool useInheritedMediaQuery;

  const GetMaterialApp({
    super.key,
    this.navigatorKey,
    this.scaffoldMessengerKey,
    this.home,
    Map<String, Widget Function(BuildContext)> this.routes =
        const <String, WidgetBuilder>{},
    this.initialRoute,
    this.onGenerateRoute,
    this.onGenerateInitialRoutes,
    this.onUnknownRoute,
    this.useInheritedMediaQuery = false,
    List<NavigatorObserver> this.navigatorObservers =
        const <NavigatorObserver>[],
    this.builder,
    this.textDirection,
    this.title = '',
    this.onGenerateTitle,
    this.color,
    this.theme,
    this.darkTheme,
    this.themeMode = ThemeMode.system,
    this.locale,
    this.fallbackLocale,
    this.localizationsDelegates,
    this.localeListResolutionCallback,
    this.localeResolutionCallback,
    this.supportedLocales = const <Locale>[Locale('en', 'US')],
    this.debugShowMaterialGrid = false,
    this.showPerformanceOverlay = false,
    this.checkerboardRasterCacheImages = false,
    this.checkerboardOffscreenLayers = false,
    this.showSemanticsDebugger = false,
    this.debugShowCheckedModeBanner = true,
    this.shortcuts,
    this.scrollBehavior,
    this.customTransition,
    this.translationsKeys,
    this.translations,
    this.onInit,
    this.onReady,
    this.onDispose,
    this.routingCallback,
    this.defaultTransition,
    this.getPages,
    this.opaqueRoute,
    this.enableLog = kDebugMode,
    this.logWriterCallback,
    this.popGesture,
    this.transitionDuration,
    this.defaultGlobalState,
    this.smartManagement = SmartManagement.full,
    this.binds = const [],
    this.unknownRoute,
    this.highContrastTheme,
    this.highContrastDarkTheme,
    this.actions,
  })  : routeInformationProvider = null,
        backButtonDispatcher = null,
        routeInformationParser = null,
        routerDelegate = null,
        routerConfig = null;

  const GetMaterialApp.router({
    super.key,
    this.routeInformationProvider,
    this.scaffoldMessengerKey,
    this.routeInformationParser,
    this.routerDelegate,
    this.routerConfig,
    this.backButtonDispatcher,
    this.builder,
    this.title = '',
    this.onGenerateTitle,
    this.color,
    this.theme,
    this.darkTheme,
    this.useInheritedMediaQuery = false,
    this.highContrastTheme,
    this.highContrastDarkTheme,
    this.themeMode = ThemeMode.system,
    this.locale,
    this.localizationsDelegates,
    this.localeListResolutionCallback,
    this.localeResolutionCallback,
    this.supportedLocales = const <Locale>[Locale('en', 'US')],
    this.debugShowMaterialGrid = false,
    this.showPerformanceOverlay = false,
    this.checkerboardRasterCacheImages = false,
    this.checkerboardOffscreenLayers = false,
    this.showSemanticsDebugger = false,
    this.debugShowCheckedModeBanner = true,
    this.shortcuts,
    this.scrollBehavior,
    this.actions,
    this.customTransition,
    this.translationsKeys,
    this.translations,
    this.textDirection,
    this.fallbackLocale,
    this.routingCallback,
    this.defaultTransition,
    this.opaqueRoute,
    this.onInit,
    this.onReady,
    this.onDispose,
    this.enableLog = kDebugMode,
    this.logWriterCallback,
    this.popGesture,
    this.smartManagement = SmartManagement.full,
    this.binds = const [],
    this.transitionDuration,
    this.defaultGlobalState,
    this.getPages,
    this.navigatorObservers,
    this.unknownRoute,
  })  : navigatorKey = null,
        onGenerateRoute = null,
        home = null,
        onGenerateInitialRoutes = null,
        onUnknownRoute = null,
        routes = null,
        initialRoute = null;

  @override
  Widget build(BuildContext context) {
    return GetRoot(
      config: ConfigData(
        backButtonDispatcher: backButtonDispatcher,
        binds: binds,
        customTransition: customTransition,
        defaultGlobalState: defaultGlobalState,
        defaultTransition: defaultTransition,
        enableLog: enableLog,
        fallbackLocale: fallbackLocale,
        getPages: getPages,
        home: home,
        initialRoute: initialRoute,
        locale: locale,
        logWriterCallback: logWriterCallback,
        navigatorKey: navigatorKey,
        navigatorObservers: navigatorObservers,
        onDispose: onDispose,
        onInit: onInit,
        onReady: onReady,
        routeInformationParser: routeInformationParser,
        routeInformationProvider: routeInformationProvider,
        routerDelegate: routerDelegate,
        routingCallback: routingCallback,
        scaffoldMessengerKey: scaffoldMessengerKey,
        smartManagement: smartManagement,
        transitionDuration: transitionDuration,
        translations: translations,
        translationsKeys: translationsKeys,
        unknownRoute: unknownRoute,
        theme: theme,
        darkTheme: darkTheme,
        themeMode: themeMode,
        defaultPopGesture: popGesture,
      ),
      // binds: [
      //   Bind.lazyPut<GetMaterialController>(
      //     () => GetMaterialController(

      //     ),
      //     onClose: () {
      //       Get.clearTranslations();
      //       RouterReportManager.dispose();
      //       Get.resetInstance(clearRouteBindings: true);
      //     },
      //   ),
      //   ...binds,
      // ],
      child: Builder(builder: (context) {
        final controller = GetRoot.of(context);
        return MaterialApp.router(
          routerDelegate: controller.config.routerDelegate,
          routeInformationParser: controller.config.routeInformationParser,
          backButtonDispatcher: backButtonDispatcher,
          routeInformationProvider: routeInformationProvider,
          routerConfig: routerConfig,
          key: controller.config.unikey,
          builder: (context, child) => Directionality(
            textDirection: textDirection ??
                (rtlLanguages.contains(Get.locale?.languageCode)
                    ? TextDirection.rtl
                    : TextDirection.ltr),
            child: builder == null
                ? (child ?? const Material())
                : builder!(context, child ?? const Material()),
          ),
          title: title,
          onGenerateTitle: onGenerateTitle,
          color: color,
          theme: controller.config.theme ?? ThemeData.fallback(),
          darkTheme: controller.config.darkTheme ??
              controller.config.theme ??
              ThemeData.fallback(),
          themeMode: controller.config.themeMode,
          locale: Get.locale ?? locale,
          scaffoldMessengerKey: controller.config.scaffoldMessengerKey,
          localizationsDelegates: localizationsDelegates,
          localeListResolutionCallback: localeListResolutionCallback,
          localeResolutionCallback: localeResolutionCallback,
          supportedLocales: supportedLocales,
          debugShowMaterialGrid: debugShowMaterialGrid,
          showPerformanceOverlay: showPerformanceOverlay,
          checkerboardRasterCacheImages: checkerboardRasterCacheImages,
          checkerboardOffscreenLayers: checkerboardOffscreenLayers,
          showSemanticsDebugger: showSemanticsDebugger,
          debugShowCheckedModeBanner: debugShowCheckedModeBanner,
          shortcuts: shortcuts,
          scrollBehavior: scrollBehavior,
        );
      }),
    );
  }
}


--- File: lib/get_navigation/src/root/get_root.dart ---
import 'package:flutter/foundation.dart';
import 'package:flutter/material.dart';
import 'package:get/get_navigation/src/routes/test_kit.dart';

import '../../../get.dart';
import '../router_report.dart';

class ConfigData {
  final ValueChanged<Routing?>? routingCallback;
  final Transition? defaultTransition;
  final VoidCallback? onInit;
  final VoidCallback? onReady;
  final VoidCallback? onDispose;
  final bool? enableLog;
  final LogWriterCallback? logWriterCallback;
  final SmartManagement smartManagement;
  final List<Bind> binds;
  final Duration? transitionDuration;
  final bool? defaultGlobalState;
  final List<GetPage>? getPages;
  final GetPage? unknownRoute;
  final RouteInformationProvider? routeInformationProvider;
  final RouteInformationParser<Object>? routeInformationParser;
  final RouterDelegate<Object>? routerDelegate;
  final BackButtonDispatcher? backButtonDispatcher;
  final List<NavigatorObserver>? navigatorObservers;
  final GlobalKey<NavigatorState>? navigatorKey;
  final GlobalKey<ScaffoldMessengerState>? scaffoldMessengerKey;
  final Map<String, Map<String, String>>? translationsKeys;
  final Translations? translations;
  final Locale? locale;
  final Locale? fallbackLocale;
  final String? initialRoute;
  final CustomTransition? customTransition;
  final Widget? home;
  final bool testMode;
  final Key? unikey;
  final ThemeData? theme;
  final ThemeData? darkTheme;
  final ThemeMode? themeMode;
  final bool? defaultPopGesture;
  final bool defaultOpaqueRoute;
  final Duration defaultTransitionDuration;
  final Curve defaultTransitionCurve;
  final Curve defaultDialogTransitionCurve;
  final Duration defaultDialogTransitionDuration;
  final Routing routing;
  final Map<String, String?> parameters;
  final SnackBarQueue snackBarQueue = SnackBarQueue();

  ConfigData({
    required this.routingCallback,
    required this.defaultTransition,
    required this.onInit,
    required this.onReady,
    required this.onDispose,
    required this.enableLog,
    required this.logWriterCallback,
    required this.smartManagement,
    required this.binds,
    required this.transitionDuration,
    required this.defaultGlobalState,
    required this.getPages,
    required this.unknownRoute,
    required this.routeInformationProvider,
    required this.routeInformationParser,
    required this.routerDelegate,
    required this.backButtonDispatcher,
    required this.navigatorObservers,
    required this.navigatorKey,
    required this.scaffoldMessengerKey,
    required this.translationsKeys,
    required this.translations,
    required this.locale,
    required this.fallbackLocale,
    required this.initialRoute,
    required this.customTransition,
    required this.home,
    this.theme,
    this.darkTheme,
    this.themeMode,
    this.unikey,
    this.testMode = false,
    this.defaultOpaqueRoute = true,
    this.defaultTransitionDuration = const Duration(milliseconds: 300),
    this.defaultTransitionCurve = Curves.easeOutQuad,
    this.defaultDialogTransitionCurve = Curves.easeOutQuad,
    this.defaultDialogTransitionDuration = const Duration(milliseconds: 300),
    this.parameters = const {},
    required this.defaultPopGesture,
    Routing? routing,
  }) : routing = routing ?? Routing();

  ConfigData copyWith({
    ValueChanged<Routing?>? routingCallback,
    Transition? defaultTransition,
    VoidCallback? onInit,
    VoidCallback? onReady,
    VoidCallback? onDispose,
    bool? enableLog,
    LogWriterCallback? logWriterCallback,
    SmartManagement? smartManagement,
    List<Bind>? binds,
    Duration? transitionDuration,
    bool? defaultGlobalState,
    List<GetPage>? getPages,
    GetPage? unknownRoute,
    RouteInformationProvider? routeInformationProvider,
    RouteInformationParser<Object>? routeInformationParser,
    RouterDelegate<Object>? routerDelegate,
    BackButtonDispatcher? backButtonDispatcher,
    List<NavigatorObserver>? navigatorObservers,
    GlobalKey<NavigatorState>? navigatorKey,
    GlobalKey<ScaffoldMessengerState>? scaffoldMessengerKey,
    Map<String, Map<String, String>>? translationsKeys,
    Translations? translations,
    Locale? locale,
    Locale? fallbackLocale,
    String? initialRoute,
    CustomTransition? customTransition,
    Widget? home,
    bool? testMode,
    Key? unikey,
    ThemeData? theme,
    ThemeData? darkTheme,
    ThemeMode? themeMode,
    bool? defaultPopGesture,
    bool? defaultOpaqueRoute,
    Duration? defaultTransitionDuration,
    Curve? defaultTransitionCurve,
    Curve? defaultDialogTransitionCurve,
    Duration? defaultDialogTransitionDuration,
    Routing? routing,
    Map<String, String?>? parameters,
  }) {
    return ConfigData(
      routingCallback: routingCallback ?? this.routingCallback,
      defaultTransition: defaultTransition ?? this.defaultTransition,
      onInit: onInit ?? this.onInit,
      onReady: onReady ?? this.onReady,
      onDispose: onDispose ?? this.onDispose,
      enableLog: enableLog ?? this.enableLog,
      logWriterCallback: logWriterCallback ?? this.logWriterCallback,
      smartManagement: smartManagement ?? this.smartManagement,
      binds: binds ?? this.binds,
      transitionDuration: transitionDuration ?? this.transitionDuration,
      defaultGlobalState: defaultGlobalState ?? this.defaultGlobalState,
      getPages: getPages ?? this.getPages,
      unknownRoute: unknownRoute ?? this.unknownRoute,
      routeInformationProvider:
          routeInformationProvider ?? this.routeInformationProvider,
      routeInformationParser:
          routeInformationParser ?? this.routeInformationParser,
      routerDelegate: routerDelegate ?? this.routerDelegate,
      backButtonDispatcher: backButtonDispatcher ?? this.backButtonDispatcher,
      navigatorObservers: navigatorObservers ?? this.navigatorObservers,
      navigatorKey: navigatorKey ?? this.navigatorKey,
      scaffoldMessengerKey: scaffoldMessengerKey ?? this.scaffoldMessengerKey,
      translationsKeys: translationsKeys ?? this.translationsKeys,
      translations: translations ?? this.translations,
      locale: locale ?? this.locale,
      fallbackLocale: fallbackLocale ?? this.fallbackLocale,
      initialRoute: initialRoute ?? this.initialRoute,
      customTransition: customTransition ?? this.customTransition,
      home: home ?? this.home,
      testMode: testMode ?? this.testMode,
      unikey: unikey ?? this.unikey,
      theme: theme ?? this.theme,
      darkTheme: darkTheme ?? this.darkTheme,
      themeMode: themeMode ?? this.themeMode,
      defaultPopGesture: defaultPopGesture ?? this.defaultPopGesture,
      defaultOpaqueRoute: defaultOpaqueRoute ?? this.defaultOpaqueRoute,
      defaultTransitionDuration:
          defaultTransitionDuration ?? this.defaultTransitionDuration,
      defaultTransitionCurve:
          defaultTransitionCurve ?? this.defaultTransitionCurve,
      defaultDialogTransitionCurve:
          defaultDialogTransitionCurve ?? this.defaultDialogTransitionCurve,
      defaultDialogTransitionDuration: defaultDialogTransitionDuration ??
          this.defaultDialogTransitionDuration,
      routing: routing ?? this.routing,
      parameters: parameters ?? this.parameters,
    );
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;

    return other is ConfigData &&
        other.routingCallback == routingCallback &&
        other.defaultTransition == defaultTransition &&
        other.onInit == onInit &&
        other.onReady == onReady &&
        other.onDispose == onDispose &&
        other.enableLog == enableLog &&
        other.logWriterCallback == logWriterCallback &&
        other.smartManagement == smartManagement &&
        listEquals(other.binds, binds) &&
        other.transitionDuration == transitionDuration &&
        other.defaultGlobalState == defaultGlobalState &&
        listEquals(other.getPages, getPages) &&
        other.unknownRoute == unknownRoute &&
        other.routeInformationProvider == routeInformationProvider &&
        other.routeInformationParser == routeInformationParser &&
        other.routerDelegate == routerDelegate &&
        other.backButtonDispatcher == backButtonDispatcher &&
        listEquals(other.navigatorObservers, navigatorObservers) &&
        other.navigatorKey == navigatorKey &&
        other.scaffoldMessengerKey == scaffoldMessengerKey &&
        mapEquals(other.translationsKeys, translationsKeys) &&
        other.translations == translations &&
        other.locale == locale &&
        other.fallbackLocale == fallbackLocale &&
        other.initialRoute == initialRoute &&
        other.customTransition == customTransition &&
        other.home == home &&
        other.testMode == testMode &&
        other.unikey == unikey &&
        other.theme == theme &&
        other.darkTheme == darkTheme &&
        other.themeMode == themeMode &&
        other.defaultPopGesture == defaultPopGesture &&
        other.defaultOpaqueRoute == defaultOpaqueRoute &&
        other.defaultTransitionDuration == defaultTransitionDuration &&
        other.defaultTransitionCurve == defaultTransitionCurve &&
        other.defaultDialogTransitionCurve == defaultDialogTransitionCurve &&
        other.defaultDialogTransitionDuration ==
            defaultDialogTransitionDuration &&
        other.routing == routing &&
        mapEquals(other.parameters, parameters);
  }

  @override
  int get hashCode {
    return routingCallback.hashCode ^
        defaultTransition.hashCode ^
        onInit.hashCode ^
        onReady.hashCode ^
        onDispose.hashCode ^
        enableLog.hashCode ^
        logWriterCallback.hashCode ^
        smartManagement.hashCode ^
        binds.hashCode ^
        transitionDuration.hashCode ^
        defaultGlobalState.hashCode ^
        getPages.hashCode ^
        unknownRoute.hashCode ^
        routeInformationProvider.hashCode ^
        routeInformationParser.hashCode ^
        routerDelegate.hashCode ^
        backButtonDispatcher.hashCode ^
        navigatorObservers.hashCode ^
        navigatorKey.hashCode ^
        scaffoldMessengerKey.hashCode ^
        translationsKeys.hashCode ^
        translations.hashCode ^
        locale.hashCode ^
        fallbackLocale.hashCode ^
        initialRoute.hashCode ^
        customTransition.hashCode ^
        home.hashCode ^
        testMode.hashCode ^
        unikey.hashCode ^
        theme.hashCode ^
        darkTheme.hashCode ^
        themeMode.hashCode ^
        defaultPopGesture.hashCode ^
        defaultOpaqueRoute.hashCode ^
        defaultTransitionDuration.hashCode ^
        defaultTransitionCurve.hashCode ^
        defaultDialogTransitionCurve.hashCode ^
        defaultDialogTransitionDuration.hashCode ^
        routing.hashCode ^
        parameters.hashCode;
  }
}

class GetRoot extends StatefulWidget {
  const GetRoot({
    super.key,
    required this.config,
    required this.child,
  });
  final ConfigData config;
  final Widget child;
  @override
  State<GetRoot> createState() => GetRootState();

  static bool get treeInitialized => GetRootState._controller != null;

  static GetRootState of(BuildContext context) {
    // Handles the case where the input context is a navigator element.
    GetRootState? root;
    if (context is StatefulElement && context.state is GetRootState) {
      root = context.state as GetRootState;
    }
    root = context.findRootAncestorStateOfType<GetRootState>() ?? root;
    assert(() {
      if (root == null) {
        throw FlutterError(
          'GetRoot operation requested with a context that does not include a GetRoot.\n'
          'The context used must be that of a '
          'widget that is a descendant of a GetRoot widget.',
        );
      }
      return true;
    }());
    return root!;
  }
}

class GetRootState extends State<GetRoot> with WidgetsBindingObserver {
  static GetRootState? _controller;
  static GetRootState get controller {
    if (_controller == null) {
      throw Exception('GetRoot is not part of the three');
    } else {
      return _controller!;
    }
  }

  late ConfigData config;

  @override
  void initState() {
    config = widget.config;
    GetRootState._controller = this;
    Engine.instance.addObserver(this);
    onInit();
    super.initState();
  }

  // @override
  // void didUpdateWidget(covariant GetRoot oldWidget) {
  //   if (oldWidget.config != widget.config) {
  //     config = widget.config;
  //   }

  //   super.didUpdateWidget(oldWidget);
  // }

  void onClose() {
    config.onDispose?.call();
    Get.clearTranslations();
    config.snackBarQueue.disposeControllers();
    RouterReportManager.instance.clearRouteKeys();
    RouterReportManager.dispose();
    Get.resetInstance(clearRouteBindings: true);
    _controller = null;
    Engine.instance.removeObserver(this);
  }

  @override
  void dispose() {
    onClose();
    super.dispose();
  }

  void onInit() {
    if (config.getPages == null && config.home == null) {
      throw 'You need add pages or home';
    }

    if (config.routerDelegate == null) {
      final newDelegate = GetDelegate.createDelegate(
        pages: config.getPages ??
            [
              GetPage(
                name: cleanRouteName("/${config.home.runtimeType}"),
                page: () => config.home!,
              ),
            ],
        notFoundRoute: config.unknownRoute,
        navigatorKey: config.navigatorKey,
        navigatorObservers: (config.navigatorObservers == null
            ? <NavigatorObserver>[
                GetObserver(config.routingCallback, Get.routing)
              ]
            : <NavigatorObserver>[
                GetObserver(config.routingCallback, config.routing),
                ...config.navigatorObservers!
              ]),
      );
      config = config.copyWith(routerDelegate: newDelegate);
    }

    if (config.routeInformationParser == null) {
      final newRouteInformationParser =
          GetInformationParser.createInformationParser(
        initialRoute: config.initialRoute ??
            config.getPages?.first.name ??
            cleanRouteName("/${config.home.runtimeType}"),
      );

      config =
          config.copyWith(routeInformationParser: newRouteInformationParser);
    }

    if (config.locale != null) Get.locale = config.locale;

    if (config.fallbackLocale != null) {
      Get.fallbackLocale = config.fallbackLocale;
    }

    if (config.translations != null) {
      Get.addTranslations(config.translations!.keys);
    } else if (config.translationsKeys != null) {
      Get.addTranslations(config.translationsKeys!);
    }

    Get.smartManagement = config.smartManagement;
    config.onInit?.call();

    Get.isLogEnable = config.enableLog ?? kDebugMode;
    Get.log = config.logWriterCallback ?? defaultLogWriterCallback;

    if (config.defaultTransition == null) {
      config = config.copyWith(defaultTransition: getThemeTransition());
    }

    // defaultOpaqueRoute = config.opaqueRoute ?? true;
    // defaultPopGesture = config.popGesture ?? GetPlatform.isIOS;
    // defaultTransitionDuration =
    //     config.transitionDuration ?? Duration(milliseconds: 300);

    Future(() => onReady());
  }

  set parameters(Map<String, String?> newParameters) {
    // rootController.parameters = newParameters;
    config = config.copyWith(parameters: newParameters);
  }

  set testMode(bool isTest) {
    config = config.copyWith(testMode: isTest);
    GetTestMode.active = isTest;
  }

  void onReady() {
    config.onReady?.call();
  }

  Transition? getThemeTransition() {
    final platform = context.theme.platform;
    final matchingTransition =
        Get.theme.pageTransitionsTheme.builders[platform];
    switch (matchingTransition) {
      case CupertinoPageTransitionsBuilder():
        return Transition.cupertino;
      case ZoomPageTransitionsBuilder():
        return Transition.zoom;
      case FadeUpwardsPageTransitionsBuilder():
        return Transition.fade;
      case OpenUpwardsPageTransitionsBuilder():
        return Transition.native;
      default:
        return null;
    }
  }

  @override
  void didChangeLocales(List<Locale>? locales) {
    Get.asap(() {
      final locale = Get.deviceLocale;
      if (locale != null) {
        Get.updateLocale(locale);
      }
    });
  }

  void setTheme(ThemeData value) {
    if (config.darkTheme == null) {
      config = config.copyWith(theme: value);
    } else {
      if (value.brightness == Brightness.light) {
        config = config.copyWith(theme: value);
      } else {
        config = config.copyWith(darkTheme: value);
      }
    }
    update();
  }

  void setThemeMode(ThemeMode value) {
    config = config.copyWith(themeMode: value);
    update();
  }

  void restartApp() {
    config = config.copyWith(unikey: UniqueKey());
    update();
  }

  void update() {
    context.visitAncestorElements((element) {
      element.markNeedsBuild();
      return false;
    });
  }

  GlobalKey<NavigatorState> get key => rootDelegate.navigatorKey;

  GetDelegate get rootDelegate => config.routerDelegate as GetDelegate;

  RouteInformationParser<Object> get informationParser =>
      config.routeInformationParser!;

  GlobalKey<NavigatorState>? addKey(GlobalKey<NavigatorState> newKey) {
    rootDelegate.navigatorKey = newKey;
    return key;
  }

  Map<String, GetDelegate> keys = {};

  GetDelegate? nestedKey(String? key) {
    if (key == null) {
      return rootDelegate;
    }
    keys.putIfAbsent(
      key,
      () => GetDelegate(
        showHashOnUrl: true,
        //debugLabel: 'Getx nested key: ${key.toString()}',
        pages: RouteDecoder.fromRoute(key).currentChildren ?? [],
      ),
    );
    return keys[key];
  }

  @override
  Widget build(BuildContext context) {
    return widget.child;
  }

  String cleanRouteName(String name) {
    name = name.replaceAll('() => ', '');

    /// uncomment for URL styling.
    // name = name.paramCase!;
    if (!name.startsWith('/')) {
      name = '/$name';
    }
    return Uri.tryParse(name)?.toString() ?? name;
  }
}


Instructions for the chapter (Generate content in English unless specified otherwise):
- Start with a clear heading (e.g., `# Chapter 1: GetMaterialApp / GetCupertinoApp & GetRoot
`). Use the provided concept name.

- If this is not the first chapter, begin with a brief transition from the previous chapter, referencing it with a proper Markdown link using its name.

- Begin with a high-level motivation explaining what problem this abstraction solves. Start with a central use case as a concrete example. The whole chapter should guide the reader to understand how to solve this use case. Make it very minimal and friendly to beginners.

- If the abstraction is complex, break it down into key concepts. Explain each concept one-by-one in a very beginner-friendly way.

- Explain how to use this abstraction to solve the use case. Give example inputs and outputs for code snippets (if the output isn't values, describe at a high level what will happen).

- Each code block should be BELOW 10 lines! If longer code blocks are needed, break them down into smaller pieces and walk through them one-by-one. Aggresively simplify the code to make it minimal. Use comments to skip non-important implementation details. Each code block should have a beginner friendly explanation right after it.

- Describe the internal implementation to help understand what's under the hood. First provide a non-code or code-light walkthrough on what happens step-by-step when the abstraction is called. It's recommended to use a simple sequenceDiagram with a dummy example - keep it minimal with at most 5 participants to ensure clarity. If participant name has space, use: `participant QP as Query Processing`. .

- Then dive deeper into code for the internal implementation with references to files. Provide example code blocks, but make them similarly simple and beginner-friendly. Explain.

- IMPORTANT: When you need to refer to other core abstractions covered in other chapters, ALWAYS use proper Markdown links like this: [Chapter Title](filename.md). Use the Complete Tutorial Structure above to find the correct filename and the chapter title. Translate the surrounding text.

- Use mermaid diagrams to illustrate complex concepts (```mermaid``` format). .

- Heavily use analogies and examples throughout to help beginners understand.

- End the chapter with a brief conclusion that summarizes what was learned and provides a transition to the next chapter. If there is a next chapter, use a proper Markdown link: [Next Chapter Title](next_chapter_filename).

- Ensure the tone is welcoming and easy for a newcomer to understand.

- Output *only* the Markdown content for this chapter.

Now, directly provide a super beginner-friendly Markdown output (DON'T need ```markdown``` tags):

2025-05-16 11:06:29,350 - INFO - RESPONSE: # Chapter 1: GetMaterialApp / GetCupertinoApp & GetRoot

Welcome to your GetX journey! This is the very first step into a powerful and easy-to-use Flutter framework. In this chapter, we'll explore the foundational building blocks of any GetX application: `GetMaterialApp`, `GetCupertinoApp`, and the unsung hero, `GetRoot`.

## What's the Big Deal? Setting Up Your GetX App

Imagine you're building a house. Before you can add rooms, furniture, or even think about painting the walls, you need a solid foundation and the main structure, right? In a Flutter app using GetX, `GetMaterialApp` or `GetCupertinoApp` are like choosing the architectural style of your house (Material Design for Android-style or Cupertino for iOS-style), and they lay this essential groundwork.

Flutter apps usually start with `MaterialApp` (for Material Design) or `CupertinoApp` (for iOS-style design). GetX provides its own versions:

*   `GetMaterialApp`
*   `GetCupertinoApp`

Why use these instead of the standard Flutter ones? Because they do something crucial: **they initialize the GetX framework**. This "initialization" means they set up all the cool things GetX offers, like super-easy navigation, smart state management, and simple internationalization (showing your app in different languages).

Think of it like this: standard `MaterialApp` gives you a basic house blueprint. `GetMaterialApp` gives you that same blueprint but also installs the main electrical panel, plumbing system, and a smart home hub, all ready for you to use GetX features without extra setup.

## Meet the Stars of the Show

Let's break down these key components:

### 1. `GetMaterialApp` (for Material Design lovers)

If you're building an app that follows Google's Material Design guidelines (common for Android apps, but also widely used for cross-platform apps), you'll use `GetMaterialApp`. It's a direct replacement for Flutter's `MaterialApp`. By using it, you're telling your app, "Hey, I want to use GetX features!"

```dart
// main.dart
import 'package:flutter/material.dart';
import 'package:get/get.dart'; // Don't forget to import GetX!

void main() {
  runApp(MyApp());
}

class MyApp extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return GetMaterialApp( // <-- See? We use GetMaterialApp here!
      title: 'My First GetX App',
      home: MyHomePage(),
    );
  }
}

class MyHomePage extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(title: Text('GetX is Awesome!')),
      body: Center(child: Text('Hello, GetX World!')),
    );
  }
}
```
In this very simple app, just by changing `MaterialApp` to `GetMaterialApp`, we've unlocked the potential to use all of GetX's powerful features throughout our `MyApp`.

### 2. `GetCupertinoApp` (for iOS aficionados)

If you're aiming for an app that looks and feels like a native iOS application, you'll use `GetCupertinoApp`. It's the GetX equivalent of Flutter's `CupertinoApp`.

```dart
// main.dart
import 'package:flutter/cupertino.dart';
import 'package:get/get.dart'; // Import GetX

void main() {
  runApp(MyApp());
}

class MyApp extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return GetCupertinoApp( // <-- Using GetCupertinoApp for iOS style
      title: 'My First GetX iOS App',
      home: MyHomePage(),
    );
  }
}

class MyHomePage extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return CupertinoPageScaffold(
      navigationBar: CupertinoNavigationBar(
        middle: Text('Hello, GetX (iOS Style)!'),
      ),
      child: Center(child: Text('GetX on Cupertino!')),
    );
  }
}
```
Similar to `GetMaterialApp`, using `GetCupertinoApp` sets up your app for GetX functionalities but with an iOS-style foundation.

### 3. `GetRoot`: The Engine Under the Hood

You might not ever type `GetRoot` directly in your code, but it's super important to know it exists. `GetRoot` is the core widget that both `GetMaterialApp` and `GetCupertinoApp` use internally.

Think of `GetRoot` as the main power supply and central control panel for the GetX system in your app. It's responsible for:
*   Managing global configurations.
*   Setting up the routing system that GetX uses for navigation.
*   Initializing dependency management.
*   Handling internationalization settings (like current language).

So, when you use `GetMaterialApp` or `GetCupertinoApp`, they are essentially putting a `GetRoot` widget at the very top of your application's widget tree. This makes all the GetX features available to every part of your app.

## How Does It Work? A Peek Inside

You don't need to know the intricate details to use GetX effectively, but a little insight can be helpful!

1.  **You start your app:** You use `GetMaterialApp` (or `GetCupertinoApp`) as the root widget in your `main.dart` file.
2.  **`GetMaterialApp` takes charge:** When `GetMaterialApp` is built, its main job is to create and configure a `GetRoot` widget. It passes along all your app's configurations (like themes, initial routes, translations, etc.) to `GetRoot`.
3.  **`GetRoot` powers up:** `GetRoot` receives these configurations and initializes the entire GetX ecosystem. It sets up internal controllers, listeners for things like language changes, and provides the necessary context for GetX features to work.
4.  **Your app is ready!** With `GetRoot` in place, all other GetX functionalities (like `Get.to()` for navigation, `Get.put()` for dependency injection, `Get.snackbar()` for messages) can now find the necessary GetX infrastructure and work their magic.

Let's visualize this flow:

```mermaid
sequenceDiagram
    participant UserApp as main.dart
    participant GMA as GetMaterialApp
    participant GR as GetRoot
    participant GetXCore as GetX Core System

    UserApp->>GMA: Uses GetMaterialApp/GetCupertinoApp
    GMA->>GR: Wraps its child with GetRoot, passing configurations
    GR->>GetXCore: Initializes GetX services (routing, DI, locale)
    GMA->>UserApp: Renders app with GetX features enabled
```

**A Tiny Glimpse into the Code:**

You won't usually need to touch this code, but it helps to see it.

Here's a simplified look at what `GetMaterialApp` does in its `build` method (from `lib/get_navigation/src/root/get_material_app.dart`):

```dart
// Inside GetMaterialApp's build method
@override
Widget build(BuildContext context) {
  return GetRoot( // Notice! It returns a GetRoot widget.
    config: ConfigData( // Bundles up all configurations
      // ... like home, getPages, locale, theme ...
      home: home,
      getPages: getPages,
      locale: locale,
      theme: theme,
      // ... and many other settings you provide ...
    ),
    child: Builder(builder: (context) {
      // This inner part builds the actual MaterialApp,
      // now empowered by GetRoot and its configurations.
      final controller = GetRoot.of(context);
      return MaterialApp.router( /* ... uses controller.config ... */ );
    }),
  );
}
```
This code shows that `GetMaterialApp` essentially sets up `GetRoot` with all your app's settings. `GetRoot` then takes care of the nitty-gritty GetX initialization.

And here's a very simplified idea of what `GetRoot` does when it starts (from `lib/get_navigation/src/root/get_root.dart`):

```dart
// Inside GetRootState's initState method
@override
void initState() {
  config = widget.config; // Receives config from GetMaterialApp/GetCupertinoApp
  // ... other setup ...
  onInit(); // Calls a special GetX initialization method
  super.initState();
}

void onInit() {
  // Example: Sets up the current language (locale) for your app
  if (config.locale != null) Get.locale = config.locale;

  // Example: Initializes translations if you provide them
  if (config.translations != null) {
    Get.addTranslations(config.translations!.keys);
  }
  // ... and much more initialization for routing, logging, etc. ...
}
```
This `onInit()` method within `GetRoot` is where a lot of the GetX magic gets set up based on the properties you pass to `GetMaterialApp` or `GetCupertinoApp`.

## Why Bother? The Benefits

*   **Simplicity:** You just swap `MaterialApp` with `GetMaterialApp` (or `CupertinoApp` with `GetCupertinoApp`), and you're ready to use GetX. No complex setup rituals!
*   **Power:** This simple change unlocks a vast array of features:
    *   Effortless route management (covered in [GetNavigation Extensions (e.g., Get.toNamed, Get.snackbar)](02_getnavigation_extensions__e_g___get_tonamed__get_snackbar__.md) and [GetPage & GetRouterDelegate](03_getpage___getrouterdelegate__.md)).
    *   Simple state management.
    *   Easy dependency injection.
    *   Built-in internationalization.
    *   Dialogs, Snackbars, and BottomSheets without `context` (see [Overlay Management (Snackbar, Dialog, BottomSheet)](04_overlay_management__snackbar__dialog__bottomsheet__.md)).
*   **Performance:** GetX is designed to be lightweight and performant.

## Conclusion

You've just learned about the most fundamental step in building a GetX application: using `GetMaterialApp` or `GetCupertinoApp`. These widgets, powered by the underlying `GetRoot`, are your gateway to the GetX ecosystem. They seamlessly initialize everything you need, allowing you to focus on building amazing features rather than wrestling with boilerplate setup.

With this foundation laid, you're now ready to explore one of the most beloved features of GetX: its incredibly simple and powerful navigation system.

Ready to learn how to move between screens with ease? Let's dive into the [GetNavigation Extensions (e.g., Get.toNamed, Get.snackbar)](02_getnavigation_extensions__e_g___get_tonamed__get_snackbar__.md)!
2025-05-16 11:06:29,421 - INFO - PROMPT: 
Write a very beginner-friendly tutorial chapter (in Markdown format) for the project `getx` about the concept: "GetNavigation Extensions (e.g., Get.toNamed, Get.snackbar)
". This is Chapter 2.

Concept Details:
- Name: GetNavigation Extensions (e.g., Get.toNamed, Get.snackbar)

- Description:
These are convenient shortcut methods attached to the `Get` interface, allowing you to navigate or show UI elements like dialogs, snackbars, and bottom sheets from anywhere in your code without needing a `BuildContext`.
Think of it as a universal remote control for your app's navigation and common UI pop-ups. Instead of finding the specific local remote (BuildContext) for the TV in a room, you use one master remote (`Get`) to control any TV (navigation, dialog) in the house.


Complete Tutorial Structure:
1. [GetMaterialApp / GetCupertinoApp & GetRoot
](01_getmaterialapp___getcupertinoapp___getroot_.md)
2. [GetNavigation Extensions (e.g., Get.toNamed, Get.snackbar)
](02_getnavigation_extensions__e_g___get_tonamed__get_snackbar__.md)
3. [GetPage & GetRouterDelegate
](03_getpage___getrouterdelegate_.md)
4. [Overlay Management (Snackbar, Dialog, BottomSheet)
](04_overlay_management__snackbar__dialog__bottomsheet__.md)
5. [Route Parsing & Configuration (RouteDecoder, PageSettings, ParseRouteTree)
](05_route_parsing___configuration__routedecoder__pagesettings__parseroutetree__.md)
6. [GetMiddleware
](06_getmiddleware_.md)
7. [Transition System (GetPageRouteTransitionMixin, CustomTransition, Transitions)
](07_transition_system__getpageroutetransitionmixin__customtransition__transitions__.md)
8. [RouterReportManager
](08_routerreportmanager_.md)

Context from previous chapters:
# Chapter 1: GetMaterialApp / GetCupertinoApp & GetRoot

Welcome to your GetX journey! This is the very first step into a powerful and easy-to-use Flutter framework. In this chapter, we'll explore the foundational building blocks of any GetX application: `GetMaterialApp`, `GetCupertinoApp`, and the unsung hero, `GetRoot`.

## What's the Big Deal? Setting Up Your GetX App

Imagine you're building a house. Before you can add rooms, furniture, or even think about painting the walls, you need a solid foundation and the main structure, right? In a Flutter app using GetX, `GetMaterialApp` or `GetCupertinoApp` are like choosing the architectural style of your house (Material Design for Android-style or Cupertino for iOS-style), and they lay this essential groundwork.

Flutter apps usually start with `MaterialApp` (for Material Design) or `CupertinoApp` (for iOS-style design). GetX provides its own versions:

*   `GetMaterialApp`
*   `GetCupertinoApp`

Why use these instead of the standard Flutter ones? Because they do something crucial: **they initialize the GetX framework**. This "initialization" means they set up all the cool things GetX offers, like super-easy navigation, smart state management, and simple internationalization (showing your app in different languages).

Think of it like this: standard `MaterialApp` gives you a basic house blueprint. `GetMaterialApp` gives you that same blueprint but also installs the main electrical panel, plumbing system, and a smart home hub, all ready for you to use GetX features without extra setup.

## Meet the Stars of the Show

Let's break down these key components:

### 1. `GetMaterialApp` (for Material Design lovers)

If you're building an app that follows Google's Material Design guidelines (common for Android apps, but also widely used for cross-platform apps), you'll use `GetMaterialApp`. It's a direct replacement for Flutter's `MaterialApp`. By using it, you're telling your app, "Hey, I want to use GetX features!"

```dart
// main.dart
import 'package:flutter/material.dart';
import 'package:get/get.dart'; // Don't forget to import GetX!

void main() {
  runApp(MyApp());
}

class MyApp extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return GetMaterialApp( // <-- See? We use GetMaterialApp here!
      title: 'My First GetX App',
      home: MyHomePage(),
    );
  }
}

class MyHomePage extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(title: Text('GetX is Awesome!')),
      body: Center(child: Text('Hello, GetX World!')),
    );
  }
}
```
In this very simple app, just by changing `MaterialApp` to `GetMaterialApp`, we've unlocked the potential to use all of GetX's powerful features throughout our `MyApp`.

### 2. `GetCupertinoApp` (for iOS aficionados)

If you're aiming for an app that looks and feels like a native iOS application, you'll use `GetCupertinoApp`. It's the GetX equivalent of Flutter's `CupertinoApp`.

```dart
// main.dart
import 'package:flutter/cupertino.dart';
import 'package:get/get.dart'; // Import GetX

void main() {
  runApp(MyApp());
}

class MyApp extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return GetCupertinoApp( // <-- Using GetCupertinoApp for iOS style
      title: 'My First GetX iOS App',
      home: MyHomePage(),
    );
  }
}

class MyHomePage extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return CupertinoPageScaffold(
      navigationBar: CupertinoNavigationBar(
        middle: Text('Hello, GetX (iOS Style)!'),
      ),
      child: Center(child: Text('GetX on Cupertino!')),
    );
  }
}
```
Similar to `GetMaterialApp`, using `GetCupertinoApp` sets up your app for GetX functionalities but with an iOS-style foundation.

### 3. `GetRoot`: The Engine Under the Hood

You might not ever type `GetRoot` directly in your code, but it's super important to know it exists. `GetRoot` is the core widget that both `GetMaterialApp` and `GetCupertinoApp` use internally.

Think of `GetRoot` as the main power supply and central control panel for the GetX system in your app. It's responsible for:
*   Managing global configurations.
*   Setting up the routing system that GetX uses for navigation.
*   Initializing dependency management.
*   Handling internationalization settings (like current language).

So, when you use `GetMaterialApp` or `GetCupertinoApp`, they are essentially putting a `GetRoot` widget at the very top of your application's widget tree. This makes all the GetX features available to every part of your app.

## How Does It Work? A Peek Inside

You don't need to know the intricate details to use GetX effectively, but a little insight can be helpful!

1.  **You start your app:** You use `GetMaterialApp` (or `GetCupertinoApp`) as the root widget in your `main.dart` file.
2.  **`GetMaterialApp` takes charge:** When `GetMaterialApp` is built, its main job is to create and configure a `GetRoot` widget. It passes along all your app's configurations (like themes, initial routes, translations, etc.) to `GetRoot`.
3.  **`GetRoot` powers up:** `GetRoot` receives these configurations and initializes the entire GetX ecosystem. It sets up internal controllers, listeners for things like language changes, and provides the necessary context for GetX features to work.
4.  **Your app is ready!** With `GetRoot` in place, all other GetX functionalities (like `Get.to()` for navigation, `Get.put()` for dependency injection, `Get.snackbar()` for messages) can now find the necessary GetX infrastructure and work their magic.

Let's visualize this flow:

```mermaid
sequenceDiagram
    participant UserApp as main.dart
    participant GMA as GetMaterialApp
    participant GR as GetRoot
    participant GetXCore as GetX Core System

    UserApp->>GMA: Uses GetMaterialApp/GetCupertinoApp
    GMA->>GR: Wraps its child with GetRoot, passing configurations
    GR->>GetXCore: Initializes GetX services (routing, DI, locale)
    GMA->>UserApp: Renders app with GetX features enabled
```

**A Tiny Glimpse into the Code:**

You won't usually need to touch this code, but it helps to see it.

Here's a simplified look at what `GetMaterialApp` does in its `build` method (from `lib/get_navigation/src/root/get_material_app.dart`):

```dart
// Inside GetMaterialApp's build method
@override
Widget build(BuildContext context) {
  return GetRoot( // Notice! It returns a GetRoot widget.
    config: ConfigData( // Bundles up all configurations
      // ... like home, getPages, locale, theme ...
      home: home,
      getPages: getPages,
      locale: locale,
      theme: theme,
      // ... and many other settings you provide ...
    ),
    child: Builder(builder: (context) {
      // This inner part builds the actual MaterialApp,
      // now empowered by GetRoot and its configurations.
      final controller = GetRoot.of(context);
      return MaterialApp.router( /* ... uses controller.config ... */ );
    }),
  );
}
```
This code shows that `GetMaterialApp` essentially sets up `GetRoot` with all your app's settings. `GetRoot` then takes care of the nitty-gritty GetX initialization.

And here's a very simplified idea of what `GetRoot` does when it starts (from `lib/get_navigation/src/root/get_root.dart`):

```dart
// Inside GetRootState's initState method
@override
void initState() {
  config = widget.config; // Receives config from GetMaterialApp/GetCupertinoApp
  // ... other setup ...
  onInit(); // Calls a special GetX initialization method
  super.initState();
}

void onInit() {
  // Example: Sets up the current language (locale) for your app
  if (config.locale != null) Get.locale = config.locale;

  // Example: Initializes translations if you provide them
  if (config.translations != null) {
    Get.addTranslations(config.translations!.keys);
  }
  // ... and much more initialization for routing, logging, etc. ...
}
```
This `onInit()` method within `GetRoot` is where a lot of the GetX magic gets set up based on the properties you pass to `GetMaterialApp` or `GetCupertinoApp`.

## Why Bother? The Benefits

*   **Simplicity:** You just swap `MaterialApp` with `GetMaterialApp` (or `CupertinoApp` with `GetCupertinoApp`), and you're ready to use GetX. No complex setup rituals!
*   **Power:** This simple change unlocks a vast array of features:
    *   Effortless route management (covered in [GetNavigation Extensions (e.g., Get.toNamed, Get.snackbar)](02_getnavigation_extensions__e_g___get_tonamed__get_snackbar__.md) and [GetPage & GetRouterDelegate](03_getpage___getrouterdelegate__.md)).
    *   Simple state management.
    *   Easy dependency injection.
    *   Built-in internationalization.
    *   Dialogs, Snackbars, and BottomSheets without `context` (see [Overlay Management (Snackbar, Dialog, BottomSheet)](04_overlay_management__snackbar__dialog__bottomsheet__.md)).
*   **Performance:** GetX is designed to be lightweight and performant.

## Conclusion

You've just learned about the most fundamental step in building a GetX application: using `GetMaterialApp` or `GetCupertinoApp`. These widgets, powered by the underlying `GetRoot`, are your gateway to the GetX ecosystem. They seamlessly initialize everything you need, allowing you to focus on building amazing features rather than wrestling with boilerplate setup.

With this foundation laid, you're now ready to explore one of the most beloved features of GetX: its incredibly simple and powerful navigation system.

Ready to learn how to move between screens with ease? Let's dive into the [GetNavigation Extensions (e.g., Get.toNamed, Get.snackbar)](02_getnavigation_extensions__e_g___get_tonamed__get_snackbar__.md)!

Relevant Code Snippets (Code itself remains unchanged):
--- File: lib/get_navigation/get_navigation.dart ---
library;

export 'src/bottomsheet/bottomsheet.dart';
export 'src/extension_navigation.dart';
export 'src/root/get_cupertino_app.dart';
export 'src/root/get_material_app.dart';
export 'src/root/internacionalization.dart';
export 'src/routes/custom_transition.dart';
export 'src/routes/default_route.dart';
export 'src/routes/get_route.dart';
export 'src/routes/index.dart';
export 'src/routes/observers/route_observer.dart';
export 'src/routes/route_middleware.dart';
export 'src/routes/transitions_type.dart';
export 'src/snackbar/snackbar.dart';
export 'src/snackbar/snackbar_controller.dart';


--- File: lib/get_navigation/src/extension_navigation.dart ---
import 'dart:ui' as ui;

import 'package:flutter/material.dart';
import 'package:get/get_navigation/src/routes/test_kit.dart';

import '../../get.dart';
import 'dialog/dialog_route.dart';
import 'root/get_root.dart';

/// It replaces the Flutter Navigator, but needs no context.
/// You can to use navigator.push(YourRoute()) rather
/// Navigator.push(context, YourRoute());
NavigatorState? get navigator => GetNavigationExt(Get).key.currentState;

extension ExtensionBottomSheet on GetInterface {
  Future<T?> bottomSheet<T>(
    Widget bottomsheet, {
    Color? backgroundColor,
    double? elevation,
    bool persistent = true,
    ShapeBorder? shape,
    Clip? clipBehavior,
    Color? barrierColor,
    bool? ignoreSafeArea,
    bool isScrollControlled = false,
    bool useRootNavigator = false,
    bool isDismissible = true,
    bool enableDrag = true,
    RouteSettings? settings,
    Duration? enterBottomSheetDuration,
    Duration? exitBottomSheetDuration,
    Curve? curve,
  }) {
    return Navigator.of(overlayContext!, rootNavigator: useRootNavigator)
        .push(GetModalBottomSheetRoute<T>(
      builder: (_) => bottomsheet,
      isPersistent: persistent,
      // theme: Theme.of(key.currentContext, shadowThemeOnly: true),
      theme: Theme.of(key.currentContext!),
      isScrollControlled: isScrollControlled,

      barrierLabel: MaterialLocalizations.of(key.currentContext!)
          .modalBarrierDismissLabel,

      backgroundColor: backgroundColor ?? Colors.transparent,
      elevation: elevation,
      shape: shape,
      removeTop: ignoreSafeArea ?? true,
      clipBehavior: clipBehavior,
      isDismissible: isDismissible,
      modalBarrierColor: barrierColor,
      settings: settings,
      enableDrag: enableDrag,
      enterBottomSheetDuration:
          enterBottomSheetDuration ?? const Duration(milliseconds: 250),
      exitBottomSheetDuration:
          exitBottomSheetDuration ?? const Duration(milliseconds: 200),
      curve: curve,
    ));
  }
}

extension ExtensionDialog on GetInterface {
  /// Show a dialog.
  /// You can pass a [transitionDuration] and/or [transitionCurve],
  /// overriding the defaults when the dialog shows up and closes.
  /// When the dialog closes, uses those animations in reverse.
  Future<T?> dialog<T>(
    Widget widget, {
    bool barrierDismissible = true,
    Color? barrierColor,
    bool useSafeArea = true,
    GlobalKey<NavigatorState>? navigatorKey,
    Object? arguments,
    Duration? transitionDuration,
    Curve? transitionCurve,
    String? name,
    RouteSettings? routeSettings,
    String? id,
  }) {
    assert(debugCheckHasMaterialLocalizations(context!));

    //  final theme = Theme.of(context, shadowThemeOnly: true);
    final theme = Theme.of(context!);
    return generalDialog<T>(
      pageBuilder: (buildContext, animation, secondaryAnimation) {
        final pageChild = widget;
        Widget dialog = Builder(builder: (context) {
          return Theme(data: theme, child: pageChild);
        });
        if (useSafeArea) {
          dialog = SafeArea(child: dialog);
        }
        return dialog;
      },
      barrierDismissible: barrierDismissible,
      barrierLabel: MaterialLocalizations.of(context!).modalBarrierDismissLabel,
      barrierColor: barrierColor ?? Colors.black54,
      transitionDuration: transitionDuration ?? defaultDialogTransitionDuration,
      transitionBuilder: (context, animation, secondaryAnimation, child) {
        return FadeTransition(
          opacity: CurvedAnimation(
            parent: animation,
            curve: transitionCurve ?? defaultDialogTransitionCurve,
          ),
          child: child,
        );
      },
      navigatorKey: navigatorKey,
      routeSettings:
          routeSettings ?? RouteSettings(arguments: arguments, name: name),
      id: id,
    );
  }

  /// Api from showGeneralDialog with no context
  Future<T?> generalDialog<T>(
      {required RoutePageBuilder pageBuilder,
      bool barrierDismissible = false,
      String? barrierLabel,
      Color barrierColor = const Color(0x80000000),
      Duration transitionDuration = const Duration(milliseconds: 200),
      RouteTransitionsBuilder? transitionBuilder,
      GlobalKey<NavigatorState>? navigatorKey,
      RouteSettings? routeSettings,
      String? id}) {
    assert(!barrierDismissible || barrierLabel != null);
    final key = navigatorKey ?? Get.nestedKey(id)?.navigatorKey;
    final nav = key?.currentState ??
        Navigator.of(overlayContext!,
            rootNavigator:
                true); //overlay context will always return the root navigator
    return nav.push<T>(
      GetDialogRoute<T>(
        pageBuilder: pageBuilder,
        barrierDismissible: barrierDismissible,
        barrierLabel: barrierLabel,
        barrierColor: barrierColor,
        transitionDuration: transitionDuration,
        transitionBuilder: transitionBuilder,
        settings: routeSettings,
      ),
    );
  }

  /// Custom UI Dialog.
  Future<T?> defaultDialog<T>({
    String title = "Alert",
    EdgeInsetsGeometry? titlePadding,
    TextStyle? titleStyle,
    Widget? content,
    String? id,
    EdgeInsetsGeometry? contentPadding,
    VoidCallback? onConfirm,
    VoidCallback? onCancel,
    VoidCallback? onCustom,
    Color? cancelTextColor,
    Color? confirmTextColor,
    String? textConfirm,
    String? textCancel,
    String? textCustom,
    Widget? confirm,
    Widget? cancel,
    Widget? custom,
    Color? backgroundColor,
    bool barrierDismissible = true,
    Color? buttonColor,
    String middleText = "\n",
    TextStyle? middleTextStyle,
    double radius = 20.0,
    //   ThemeData themeData,
    List<Widget>? actions,

    // onWillPop Scope
    PopInvokedWithResultCallback<T>? onWillPop,

    // the navigator used to push the dialog
    GlobalKey<NavigatorState>? navigatorKey,
  }) {
    var leanCancel = onCancel != null || textCancel != null;
    var leanConfirm = onConfirm != null || textConfirm != null;
    actions ??= [];

    if (cancel != null) {
      actions.add(cancel);
    } else {
      if (leanCancel) {
        actions.add(TextButton(
          style: TextButton.styleFrom(
            tapTargetSize: MaterialTapTargetSize.shrinkWrap,
            padding: const EdgeInsets.symmetric(horizontal: 10, vertical: 8),
            shape: RoundedRectangleBorder(
                side: BorderSide(
                    color: buttonColor ?? theme.colorScheme.secondary,
                    width: 2,
                    style: BorderStyle.solid),
                borderRadius: BorderRadius.circular(radius)),
          ),
          onPressed: () {
            if (onCancel == null) {
              //TODO: Close current dialog after api change
              closeAllDialogs();
            } else {
              onCancel.call();
            }
          },
          child: Text(
            textCancel ?? "Cancel",
            style: TextStyle(
                color: cancelTextColor ?? theme.colorScheme.secondary),
          ),
        ));
      }
    }
    if (confirm != null) {
      actions.add(confirm);
    } else {
      if (leanConfirm) {
        actions.add(TextButton(
            style: TextButton.styleFrom(
              tapTargetSize: MaterialTapTargetSize.shrinkWrap,
              backgroundColor: buttonColor ?? theme.colorScheme.secondary,
              shape: RoundedRectangleBorder(
                  borderRadius: BorderRadius.circular(radius)),
            ),
            child: Text(
              textConfirm ?? "Ok",
              style: TextStyle(
                  color: confirmTextColor ?? theme.colorScheme.surface),
            ),
            onPressed: () {
              onConfirm?.call();
            }));
      }
    }

    Widget baseAlertDialog = Builder(builder: (context) {
      return AlertDialog(
        titlePadding: titlePadding ?? const EdgeInsets.all(8),
        contentPadding: contentPadding ?? const EdgeInsets.all(8),

        backgroundColor:
            backgroundColor ?? DialogTheme.of(context).backgroundColor,
        shape: RoundedRectangleBorder(
            borderRadius: BorderRadius.all(Radius.circular(radius))),
        title: Text(title, textAlign: TextAlign.center, style: titleStyle),
        content: Column(
          crossAxisAlignment: CrossAxisAlignment.center,
          mainAxisSize: MainAxisSize.min,
          children: [
            content ??
                Text(middleText,
                    textAlign: TextAlign.center, style: middleTextStyle),
            const SizedBox(height: 16),
            ButtonTheme(
              minWidth: 78.0,
              height: 34.0,
              child: Wrap(
                alignment: WrapAlignment.center,
                spacing: 8,
                runSpacing: 8,
                children: actions!,
              ),
            )
          ],
        ),
        // actions: actions, // ?? <Widget>[cancelButton, confirmButton],
        buttonPadding: EdgeInsets.zero,
      );
    });

    return dialog<T>(
      onWillPop != null
          ? PopScope<T>(
              onPopInvokedWithResult: (didPop, result) =>
                  onWillPop(didPop, result),
              // onPopInvoked: onWillPop,
              child: baseAlertDialog,
            )
          : baseAlertDialog,
      barrierDismissible: barrierDismissible,
      navigatorKey: navigatorKey,
      id: id,
    );
  }
}

extension ExtensionSnackbar on GetInterface {
  SnackbarController rawSnackbar({
    String? title,
    String? message,
    Widget? titleText,
    Widget? messageText,
    Widget? icon,
    bool instantInit = true,
    bool shouldIconPulse = true,
    double? maxWidth,
    EdgeInsets margin = const EdgeInsets.all(0.0),
    EdgeInsets padding = const EdgeInsets.all(16),
    double borderRadius = 0.0,
    Color? borderColor,
    double borderWidth = 1.0,
    Color backgroundColor = const Color(0xFF303030),
    Color? leftBarIndicatorColor,
    List<BoxShadow>? boxShadows,
    Gradient? backgroundGradient,
    Widget? mainButton,
    OnTap? onTap,
    Duration? duration = const Duration(seconds: 3),
    bool isDismissible = true,
    DismissDirection? dismissDirection,
    bool showProgressIndicator = false,
    AnimationController? progressIndicatorController,
    Color? progressIndicatorBackgroundColor,
    Animation<Color>? progressIndicatorValueColor,
    SnackPosition snackPosition = SnackPosition.bottom,
    SnackStyle snackStyle = SnackStyle.floating,
    Curve forwardAnimationCurve = Curves.easeOutCirc,
    Curve reverseAnimationCurve = Curves.easeOutCirc,
    Duration animationDuration = const Duration(seconds: 1),
    SnackbarStatusCallback? snackbarStatus,
    double barBlur = 0.0,
    double overlayBlur = 0.0,
    Color? overlayColor,
    Form? userInputForm,
  }) {
    final getSnackBar = GetSnackBar(
      snackbarStatus: snackbarStatus,
      title: title,
      message: message,
      titleText: titleText,
      messageText: messageText,
      snackPosition: snackPosition,
      borderRadius: borderRadius,
      margin: margin,
      duration: duration,
      barBlur: barBlur,
      backgroundColor: backgroundColor,
      icon: icon,
      shouldIconPulse: shouldIconPulse,
      maxWidth: maxWidth,
      padding: padding,
      borderColor: borderColor,
      borderWidth: borderWidth,
      leftBarIndicatorColor: leftBarIndicatorColor,
      boxShadows: boxShadows,
      backgroundGradient: backgroundGradient,
      mainButton: mainButton,
      onTap: onTap,
      isDismissible: isDismissible,
      dismissDirection: dismissDirection,
      showProgressIndicator: showProgressIndicator,
      progressIndicatorController: progressIndicatorController,
      progressIndicatorBackgroundColor: progressIndicatorBackgroundColor,
      progressIndicatorValueColor: progressIndicatorValueColor,
      snackStyle: snackStyle,
      forwardAnimationCurve: forwardAnimationCurve,
      reverseAnimationCurve: reverseAnimationCurve,
      animationDuration: animationDuration,
      overlayBlur: overlayBlur,
      overlayColor: overlayColor,
      userInputForm: userInputForm,
    );

    final controller = SnackbarController(getSnackBar);

    if (instantInit) {
      controller.show();
    } else {
      Engine.instance.addPostFrameCallback((_) {
        controller.show();
      });
    }
    return controller;
  }

  SnackbarController showSnackbar(GetSnackBar snackbar) {
    final controller = SnackbarController(snackbar);
    controller.show();
    return controller;
  }

  SnackbarController snackbar(
    String title,
    String message, {
    Color? colorText,
    Duration? duration = const Duration(seconds: 3),

    /// with instantInit = false you can put snackbar on initState
    bool instantInit = true,
    SnackPosition? snackPosition,
    Widget? titleText,
    Widget? messageText,
    Widget? icon,
    bool? shouldIconPulse,
    double? maxWidth,
    EdgeInsets? margin,
    EdgeInsets? padding,
    double? borderRadius,
    Color? borderColor,
    double? borderWidth,
    Color? backgroundColor,
    Color? leftBarIndicatorColor,
    List<BoxShadow>? boxShadows,
    Gradient? backgroundGradient,
    TextButton? mainButton,
    OnTap? onTap,
    OnHover? onHover,
    bool? isDismissible,
    bool? showProgressIndicator,
    DismissDirection? dismissDirection,
    AnimationController? progressIndicatorController,
    Color? progressIndicatorBackgroundColor,
    Animation<Color>? progressIndicatorValueColor,
    SnackStyle? snackStyle,
    Curve? forwardAnimationCurve,
    Curve? reverseAnimationCurve,
    Duration? animationDuration,
    double? barBlur,
    double? overlayBlur,
    SnackbarStatusCallback? snackbarStatus,
    Color? overlayColor,
    Form? userInputForm,
  }) {
    final getSnackBar = GetSnackBar(
        snackbarStatus: snackbarStatus,
        titleText: titleText ??
            Text(
              title,
              style: TextStyle(
                color: colorText ?? iconColor ?? Colors.black,
                fontWeight: FontWeight.w800,
                fontSize: 16,
              ),
            ),
        messageText: messageText ??
            Text(
              message,
              style: TextStyle(
                color: colorText ?? iconColor ?? Colors.black,
                fontWeight: FontWeight.w300,
                fontSize: 14,
              ),
            ),
        snackPosition: snackPosition ?? SnackPosition.top,
        borderRadius: borderRadius ?? 15,
        margin: margin ?? const EdgeInsets.symmetric(horizontal: 10),
        duration: duration,
        barBlur: barBlur ?? 7.0,
        backgroundColor: backgroundColor ?? Colors.grey.withValues(alpha: 0.2),
        icon: icon,
        shouldIconPulse: shouldIconPulse ?? true,
        maxWidth: maxWidth,
        padding: padding ?? const EdgeInsets.all(16),
        borderColor: borderColor,
        borderWidth: borderWidth,
        leftBarIndicatorColor: leftBarIndicatorColor,
        boxShadows: boxShadows,
        backgroundGradient: backgroundGradient,
        mainButton: mainButton,
        onTap: onTap,
        onHover: onHover,
        isDismissible: isDismissible ?? true,
        dismissDirection: dismissDirection,
        showProgressIndicator: showProgressIndicator ?? false,
        progressIndicatorController: progressIndicatorController,
        progressIndicatorBackgroundColor: progressIndicatorBackgroundColor,
        progressIndicatorValueColor: progressIndicatorValueColor,
        snackStyle: snackStyle ?? SnackStyle.floating,
        forwardAnimationCurve: forwardAnimationCurve ?? Curves.easeOutCirc,
        reverseAnimationCurve: reverseAnimationCurve ?? Curves.easeOutCirc,
        animationDuration: animationDuration ?? const Duration(seconds: 1),
        overlayBlur: overlayBlur ?? 0.0,
        overlayColor: overlayColor ?? Colors.transparent,
        userInputForm: userInputForm);

    final controller = SnackbarController(getSnackBar);

    if (instantInit) {
      controller.show();
    } else {
      //routing.isSnackbar = true;
      Engine.instance.addPostFrameCallback((_) {
        controller.show();
      });
    }
    return controller;
  }
}

extension GetNavigationExt on GetInterface {
  /// **Navigation.push()** shortcut.<br><br>
  ///
  /// Pushes a new `page` to the stack
  ///
  /// It has the advantage of not needing context,
  /// so you can call from your business logic
  ///
  /// You can set a custom [transition], and a transition [duration].
  ///
  /// You can send any type of value to the other route in the [arguments].
  ///
  /// Just like native routing in Flutter, you can push a route
  /// as a [fullscreenDialog],
  ///
  /// [id] is for when you are using nested navigation,
  /// as explained in documentation
  ///
  /// If you want the same behavior of ios that pops a route when the user drag,
  /// you can set [popGesture] to true
  ///
  /// If you're using the [BindingsInterface] api, you must define it here
  ///
  /// By default, GetX will prevent you from push a route that you already in,
  /// if you want to push anyway, set [preventDuplicates] to false
  Future<T?>? to<T extends Object?>(Widget Function() page,
      {bool? opaque,
      Transition? transition,
      Curve? curve,
      Duration? duration,
      String? id,
      String? routeName,
      bool fullscreenDialog = false,
      dynamic arguments,
      List<BindingsInterface> bindings = const [],
      bool preventDuplicates = true,
      bool? popGesture,
      bool showCupertinoParallax = true,
      double Function(BuildContext context)? gestureWidth,
      bool rebuildStack = true,
      PreventDuplicateHandlingMode preventDuplicateHandlingMode =
          PreventDuplicateHandlingMode.reorderRoutes}) {
    return searchDelegate(id).to(
      page,
      opaque: opaque,
      transition: transition,
      curve: curve,
      duration: duration,
      id: id,
      routeName: routeName,
      fullscreenDialog: fullscreenDialog,
      arguments: arguments,
      bindings: bindings,
      preventDuplicates: preventDuplicates,
      popGesture: popGesture,
      showCupertinoParallax: showCupertinoParallax,
      gestureWidth: gestureWidth,
      rebuildStack: rebuildStack,
      preventDuplicateHandlingMode: preventDuplicateHandlingMode,
    );
  }

//   GetPageBuilder _resolvePage(dynamic page, String method) {
//     if (page is GetPageBuilder) {
//       return page;
//     } else if (page is Widget) {
//       Get.log(
//           '''WARNING, consider using: "Get.$method(() => Page())"
//instead of "Get.$method(Page())".
// Using a widget function instead of a widget fully guarantees that the widget
//and its controllers will be removed from memory when they are no longer used.
//       ''');
//       return () => page;
//     } else if (page is String) {
//       throw '''Unexpected String,
// use toNamed() instead''';
//     } else {
//       throw '''Unexpected format,
// you can only use widgets and widget functions here''';
//     }
//   }

  /// **Navigation.pushNamed()** shortcut.<br><br>
  ///
  /// Pushes a new named `page` to the stack.
  ///
  /// It has the advantage of not needing context, so you can call
  /// from your business logic.
  ///
  /// You can send any type of value to the other route in the [arguments].
  ///
  /// [id] is for when you are using nested navigation,
  /// as explained in documentation
  ///
  /// By default, GetX will prevent you from push a route that you already in,
  /// if you want to push anyway, set [preventDuplicates] to false
  ///
  /// Note: Always put a slash on the route ('/page1'), to avoid unexpected errors
  Future<T?>? toNamed<T>(
    String page, {
    dynamic arguments,
    dynamic id,
    bool preventDuplicates = true,
    Map<String, String>? parameters,
  }) {
    // if (preventDuplicates && page == currentRoute) {
    //   return null;
    // }

    if (parameters != null) {
      final uri = Uri(path: page, queryParameters: parameters);
      page = uri.toString();
    }

    return searchDelegate(id).toNamed(
      page,
      arguments: arguments,
      id: id,
      preventDuplicates: preventDuplicates,
      parameters: parameters,
    );
  }

  /// **Navigation.pushReplacementNamed()** shortcut.<br><br>
  ///
  /// Pop the current named `page` in the stack and push a new one in its place
  ///
  /// It has the advantage of not needing context, so you can call
  /// from your business logic.
  ///
  /// You can send any type of value to the other route in the [arguments].
  ///
  /// [id] is for when you are using nested navigation,
  /// as explained in documentation
  ///
  /// By default, GetX will prevent you from push a route that you already in,
  /// if you want to push anyway, set [preventDuplicates] to false
  ///
  /// Note: Always put a slash on the route ('/page1'), to avoid unexpected errors
  Future<T?>? offNamed<T>(
    String page, {
    dynamic arguments,
    String? id,
    Map<String, String>? parameters,
  }) {
    // if (preventDuplicates && page == currentRoute) {
    //   return null;
    // }

    if (parameters != null) {
      final uri = Uri(path: page, queryParameters: parameters);
      page = uri.toString();
    }
    return searchDelegate(id).offNamed(
      page,
      arguments: arguments,
      id: id,
      // preventDuplicates: preventDuplicates,
      parameters: parameters,
    );
  }

  /// **Navigation.popUntil()** shortcut.<br><br>
  ///
  /// Calls pop several times in the stack until [predicate] returns true
  ///
  /// [id] is for when you are using nested navigation,
  /// as explained in documentation
  ///
  /// [predicate] can be used like this:
  /// `Get.until((route) => Get.currentRoute == '/home')`so when you get to home page,
  ///
  /// or also like this:
  /// `Get.until((route) => !Get.isDialogOpen())`, to make sure the
  /// dialog is closed
  void until(bool Function(GetPage<dynamic>) predicate, {String? id}) {
    // if (key.currentState.mounted) // add this if appear problems on future with route navigate
    // when widget don't mounted
    return searchDelegate(id).backUntil(predicate);
  }

  /// **Navigation.pushNamedAndRemoveUntil()** shortcut.<br><br>
  ///
  /// Push the given named `page`, and then pop several pages in the stack
  /// until [predicate] returns true
  ///
  /// You can send any type of value to the other route in the [arguments].
  ///
  /// [id] is for when you are using nested navigation,
  /// as explained in documentation
  ///
  /// [predicate] can be used like this:
  /// `Get.offNamedUntil(page, ModalRoute.withName('/home'))`
  /// to pop routes in stack until home,
  /// or like this:
  /// `Get.offNamedUntil((route) => !Get.isDialogOpen())`,
  /// to make sure the dialog is closed
  ///
  /// Note: Always put a slash on the route name ('/page1'), to avoid unexpected errors
  Future<T?>? offNamedUntil<T>(
    String page,
    bool Function(GetPage<dynamic>)? predicate, {
    String? id,
    dynamic arguments,
    Map<String, String>? parameters,
  }) {
    if (parameters != null) {
      final uri = Uri(path: page, queryParameters: parameters);
      page = uri.toString();
    }

    return searchDelegate(id).offNamedUntil<T>(
      page,
      predicate: predicate,
      id: id,
      arguments: arguments,
      parameters: parameters,
    );
  }

  /// **Navigation.popAndPushNamed()** shortcut.<br><br>
  ///
  /// Pop the current named page and pushes a new `page` to the stack
  /// in its place
  ///
  /// You can send any type of value to the other route in the [arguments].
  /// It is very similar to `offNamed()` but use a different approach
  ///
  /// The `offNamed()` pop a page, and goes to the next. The
  /// `offAndToNamed()` goes to the next page, and removes the previous one.
  /// The route transition animation is different.
  Future<T?>? offAndToNamed<T>(
    String page, {
    dynamic arguments,
    String? id,
    dynamic result,
    Map<String, String>? parameters,
  }) {
    if (parameters != null) {
      final uri = Uri(path: page, queryParameters: parameters);
      page = uri.toString();
    }
    return searchDelegate(id).backAndtoNamed(
      page,
      arguments: arguments,
      result: result,
    );
  }

  /// **Navigation.removeRoute()** shortcut.<br><br>
  ///
  /// Remove a specific [route] from the stack
  ///
  /// [id] is for when you are using nested navigation,
  /// as explained in documentation
  void removeRoute(String name, {String? id}) {
    return searchDelegate(id).removeRoute(name);
  }

  /// **Navigation.pushNamedAndRemoveUntil()** shortcut.<br><br>
  ///
  /// Push a named `page` and pop several pages in the stack
  /// until [predicate] returns true. [predicate] is optional
  ///
  /// It has the advantage of not needing context, so you can
  /// call from your business logic.
  ///
  /// You can send any type of value to the other route in the [arguments].
  ///
  /// [predicate] can be used like this:
  /// `Get.until((route) => Get.currentRoute == '/home')`so when you get to home page,
  /// or also like
  /// `Get.until((route) => !Get.isDialogOpen())`, to make sure the dialog
  /// is closed
  ///
  /// [id] is for when you are using nested navigation,
  /// as explained in documentation
  ///
  /// Note: Always put a slash on the route ('/page1'), to avoid unexpected errors
  Future<T?>? offAllNamed<T>(
    String newRouteName, {
    // bool Function(GetPage<dynamic>)? predicate,
    dynamic arguments,
    String? id,
    Map<String, String>? parameters,
  }) {
    if (parameters != null) {
      final uri = Uri(path: newRouteName, queryParameters: parameters);
      newRouteName = uri.toString();
    }

    return searchDelegate(id).offAllNamed<T>(
      newRouteName,
      //predicate: predicate ?? (_) => false,
      arguments: arguments,
      id: id,
      parameters: parameters,
    );
  }

  /// Returns true if a Snackbar, Dialog or BottomSheet is currently OPEN
  bool get isOverlaysOpen =>
      (isSnackbarOpen || isDialogOpen! || isBottomSheetOpen!);

  /// Returns true if there is no Snackbar, Dialog or BottomSheet open
  bool get isOverlaysClosed =>
      (!isSnackbarOpen && !isDialogOpen! && !isBottomSheetOpen!);

  /// **Navigation.popUntil()** shortcut.<br><br>
  ///
  /// Pop the current page, snackbar, dialog or bottomsheet in the stack
  ///
  /// if your set [closeOverlays] to true, Get.back() will close the
  /// currently open snackbar/dialog/bottomsheet AND the current page
  ///
  /// [id] is for when you are using nested navigation,
  /// as explained in documentation
  ///
  /// It has the advantage of not needing context, so you can call
  /// from your business logic.
  void back<T>({
    T? result,
    bool canPop = true,
    int times = 1,
    String? id,
  }) {
    if (times < 1) {
      times = 1;
    }

    if (times > 1) {
      var count = 0;
      return searchDelegate(id).backUntil((route) => count++ == times);
    } else {
      if (canPop) {
        if (searchDelegate(id).canBack == true) {
          return searchDelegate(id).back<T>(result);
        }
      } else {
        return searchDelegate(id).back<T>(result);
      }
    }
  }

  /// Pop the current page, snackbar, dialog or bottomsheet in the stack
  ///
  /// if your set [closeOverlays] to true, Get.back() will close the
  /// currently open snackbar/dialog/bottomsheet AND the current page
  ///
  /// [id] is for when you are using nested navigation,
  /// as explained in documentation
  ///
  /// It has the advantage of not needing context, so you can call
  /// from your business logic.
  void backLegacy<T>({
    T? result,
    bool closeOverlays = false,
    bool canPop = true,
    int times = 1,
    String? id,
  }) {
    if (closeOverlays) {
      closeAllOverlays();
    }

    if (times < 1) {
      times = 1;
    }

    if (times > 1) {
      var count = 0;
      return searchDelegate(id).navigatorKey.currentState?.popUntil((route) {
        return count++ == times;
      });
    } else {
      if (canPop) {
        if (searchDelegate(id).navigatorKey.currentState?.canPop() == true) {
          return searchDelegate(id).navigatorKey.currentState?.pop<T>(result);
        }
      } else {
        return searchDelegate(id).navigatorKey.currentState?.pop<T>(result);
      }
    }
  }

  void closeAllDialogsAndBottomSheets(
    String? id,
  ) {
    // It can not be divided, because dialogs and bottomsheets can not be consecutive
    while ((isDialogOpen! && isBottomSheetOpen!)) {
      closeOverlay(id: id);
    }
  }

  void closeAllDialogs({
    String? id,
  }) {
    while ((isDialogOpen!)) {
      closeOverlay(id: id);
    }
  }

  /// Close the currently open dialog, returning a [result], if provided
  void closeDialog<T>({String? id, T? result}) {
    // Stop if there is no dialog open
    if (isDialogOpen == null || !isDialogOpen!) return;

    closeOverlay(id: id, result: result);
  }

  void closeBottomSheet<T>({String? id, T? result}) {
    // Stop if there is no bottomsheet open
    if (isBottomSheetOpen == null || !isBottomSheetOpen!) return;

    closeOverlay(id: id, result: result);
  }

  /// Close the current overlay returning the [result], if provided
  void closeOverlay<T>({
    String? id,
    T? result,
  }) {
    searchDelegate(id).navigatorKey.currentState?.pop(result);
  }

  void closeAllBottomSheets({
    String? id,
  }) {
    while ((isBottomSheetOpen!)) {
      searchDelegate(id).navigatorKey.currentState?.pop();
    }
  }

  void closeAllOverlays() {
    closeAllDialogsAndBottomSheets(null);
    closeAllSnackbars();
  }

  /// **Navigation.popUntil()** (with predicate) shortcut .<br><br>
  ///
  /// Close as many routes as defined by [times]
  ///
  /// [id] is for when you are using nested navigation,
  /// as explained in documentation
  void close<T extends Object>({
    bool closeAll = true,
    bool closeSnackbar = true,
    bool closeDialog = true,
    bool closeBottomSheet = true,
    String? id,
    T? result,
  }) {
    void handleClose(bool closeCondition, Function closeAllFunction,
        Function closeSingleFunction,
        [bool? isOpenCondition]) {
      if (closeCondition) {
        if (closeAll) {
          closeAllFunction();
        } else if (isOpenCondition == true) {
          closeSingleFunction();
        }
      }
    }

    handleClose(closeSnackbar, closeAllSnackbars, closeCurrentSnackbar);
    handleClose(closeDialog, closeAllDialogs, closeOverlay, isDialogOpen);
    handleClose(closeBottomSheet, closeAllBottomSheets, closeOverlay,
        isBottomSheetOpen);
  }

  /// **Navigation.pushReplacement()** shortcut .<br><br>
  ///
  /// Pop the current page and pushes a new `page` to the stack
  ///
  /// It has the advantage of not needing context,
  /// so you can call from your business logic
  ///
  /// You can set a custom [transition], define a Tween [curve],
  /// and a transition [duration].
  ///
  /// You can send any type of value to the other route in the [arguments].
  ///
  /// Just like native routing in Flutter, you can push a route
  /// as a [fullscreenDialog],
  ///
  /// [id] is for when you are using nested navigation,
  /// as explained in documentation
  ///
  /// If you want the same behavior of ios that pops a route when the user drag,
  /// you can set [popGesture] to true
  ///
  /// If you're using the [BindingsInterface] api, you must define it here
  ///
  /// By default, GetX will prevent you from push a route that you already in,
  /// if you want to push anyway, set [preventDuplicates] to false
  Future<T?>? off<T>(
    Widget Function() page, {
    bool? opaque,
    Transition? transition,
    Curve? curve,
    bool? popGesture,
    String? id,
    String? routeName,
    dynamic arguments,
    List<BindingsInterface> bindings = const [],
    bool fullscreenDialog = false,
    bool preventDuplicates = true,
    Duration? duration,
    double Function(BuildContext context)? gestureWidth,
  }) {
    routeName ??= "/${page.runtimeType.toString()}";
    routeName = _cleanRouteName(routeName);
    if (preventDuplicates && routeName == currentRoute) {
      return null;
    }
    return searchDelegate(id).off(
      page,
      opaque: opaque ?? true,
      transition: transition,
      curve: curve,
      popGesture: popGesture,
      id: id,
      routeName: routeName,
      arguments: arguments,
      bindings: bindings,
      fullscreenDialog: fullscreenDialog,
      preventDuplicates: preventDuplicates,
      duration: duration,
      gestureWidth: gestureWidth,
    );
  }

  Future<T?> offUntil<T>(
    Widget Function() page,
    bool Function(GetPage) predicate, [
    Object? arguments,
    String? id,
  ]) {
    return searchDelegate(id).offUntil(
      page,
      predicate,
      arguments,
    );
  }

  ///
  /// Push a `page` and pop several pages in the stack
  /// until [predicate] returns true. [predicate] is optional
  ///
  /// It has the advantage of not needing context,
  /// so you can call from your business logic
  ///
  /// You can set a custom [transition], a [curve] and a transition [duration].
  ///
  /// You can send any type of value to the other route in the [arguments].
  ///
  /// Just like native routing in Flutter, you can push a route
  /// as a [fullscreenDialog],
  ///
  /// [predicate] can be used like this:
  /// `Get.until((route) => Get.currentRoute == '/home')`so when you get to home page,
  /// or also like
  /// `Get.until((route) => !Get.isDialogOpen())`, to make sure the dialog
  /// is closed
  ///
  /// [id] is for when you are using nested navigation,
  /// as explained in documentation
  ///
  /// If you want the same behavior of ios that pops a route when the user drag,
  /// you can set [popGesture] to true
  ///
  /// If you're using the [BindingsInterface] api, you must define it here
  ///
  /// By default, GetX will prevent you from push a route that you already in,
  /// if you want to push anyway, set [preventDuplicates] to false
  Future<T?>? offAll<T>(
    Widget Function() page, {
    bool Function(GetPage<dynamic>)? predicate,
    bool? opaque,
    bool? popGesture,
    String? id,
    String? routeName,
    dynamic arguments,
    List<BindingsInterface> bindings = const [],
    bool fullscreenDialog = false,
    Transition? transition,
    Curve? curve,
    Duration? duration,
    double Function(BuildContext context)? gestureWidth,
  }) {
    routeName ??= "/${page.runtimeType.toString()}";
    routeName = _cleanRouteName(routeName);
    return searchDelegate(id).offAll<T>(
      page,
      predicate: predicate,
      opaque: opaque ?? true,
      popGesture: popGesture,
      id: id,
      //  routeName routeName,
      arguments: arguments,
      bindings: bindings,
      fullscreenDialog: fullscreenDialog,
      transition: transition,
      curve: curve,
      duration: duration,
      gestureWidth: gestureWidth,
    );
  }

  /// Takes a route [name] String generated by [to], [off], [offAll]
  /// (and similar context navigation methods), cleans the extra chars and
  /// accommodates the format.
  /// TODO: check for a more "appealing" URL naming convention.
  /// `() => MyHomeScreenView` becomes `/my-home-screen-view`.
  String _cleanRouteName(String name) {
    name = name.replaceAll('() => ', '');

    /// uncomment for URL styling.
    // name = name.paramCase!;
    if (!name.startsWith('/')) {
      name = '/$name';
    }
    return Uri.tryParse(name)?.toString() ?? name;
  }
  //TODO: Deprecated
  // /// change default config of Get
  // void config(
  //     {bool? enableLog,
  //     LogWriterCallback? logWriterCallback,
  //     bool? defaultPopGesture,
  //     bool? defaultOpaqueRoute,
  //     Duration? defaultDurationTransition,
  //     bool? defaultGlobalState,
  //     Transition? defaultTransition}) {
  //   if (enableLog != null) {
  //     Get.isLogEnable = enableLog;
  //   }
  //   if (logWriterCallback != null) {
  //     Get.log = logWriterCallback;
  //   }
  //   if (defaultPopGesture != null) {
  //     _getxController.defaultPopGesture = defaultPopGesture;
  //   }
  //   if (defaultOpaqueRoute != null) {
  //     _getxController.defaultOpaqueRoute = defaultOpaqueRoute;
  //   }
  //   if (defaultTransition != null) {
  //     _getxController.defaultTransition = defaultTransition;
  //   }

  //   if (defaultDurationTransition != null) {
  //     _getxController.defaultTransitionDuration = defaultDurationTransition;
  //   }
  // }

  Future<void> updateLocale(Locale l) async {
    Get.locale = l;
    await forceAppUpdate();
  }

  /// As a rule, Flutter knows which widget to update,
  /// so this command is rarely needed. We can mention situations
  /// where you use const so that widgets are not updated with setState,
  /// but you want it to be forcefully updated when an event like
  /// language change happens. using context to make the widget dirty
  /// for performRebuild() is a viable solution.
  /// However, in situations where this is not possible, or at least,
  /// is not desired by the developer, the only solution for updating
  /// widgets that Flutter does not want to update is to use reassemble
  /// to forcibly rebuild all widgets. Attention: calling this function will
  /// reconstruct the application from the sketch, use this with caution.
  /// Your entire application will be rebuilt, and touch events will not
  /// work until the end of rendering.
  Future<void> forceAppUpdate() async {
    await engine.performReassemble();
  }

  void appUpdate() => rootController.update();

  void changeTheme(ThemeData theme) {
    rootController.setTheme(theme);
  }

  void changeThemeMode(ThemeMode themeMode) {
    rootController.setThemeMode(themeMode);
  }

  GlobalKey<NavigatorState>? addKey(GlobalKey<NavigatorState> newKey) {
    return rootController.addKey(newKey);
  }

  GetDelegate? nestedKey(String? key) {
    return rootController.nestedKey(key);
  }

  GetDelegate searchDelegate(String? k) {
    GetDelegate key;
    if (k == null) {
      key = Get.rootController.rootDelegate;
    } else {
      if (!keys.containsKey(k)) {
        throw 'Route id ($k) not found';
      }
      key = keys[k]!;
    }

    // if (_key.listenersLength == 0 && !testMode) {
    //   throw """You are trying to use contextless navigation without
    //   a GetMaterialApp or Get.key.
    //   If you are testing your app, you can use:
    //   [Get.testMode = true], or if you are running your app on
    //   a physical device or emulator, you must exchange your [MaterialApp]
    //   for a [GetMaterialApp].
    //   """;
    // }

    return key;
  }

  /// give name from current route
  String get currentRoute => routing.current;

  /// give name from previous route
  String get previousRoute => routing.previous;

  /// check if snackbar is open
  bool get isSnackbarOpen =>
      SnackbarController.isSnackbarBeingShown; //routing.isSnackbar;

  void closeAllSnackbars() {
    SnackbarController.cancelAllSnackbars();
  }

  Future<void> closeCurrentSnackbar() async {
    await SnackbarController.closeCurrentSnackbar();
  }

  /// check if dialog is open
  bool? get isDialogOpen => routing.isDialog;

  /// check if bottomsheet is open
  bool? get isBottomSheetOpen => routing.isBottomSheet;

  /// check a raw current route
  Route<dynamic>? get rawRoute => routing.route;

  /// check if default opaque route is enable
  bool get isOpaqueRouteDefault => defaultOpaqueRoute;

  /// give access to currentContext
  BuildContext? get context => key.currentContext;

  /// give access to current Overlay Context
  BuildContext? get overlayContext {
    BuildContext? overlay;
    key.currentState?.overlay?.context.visitChildElements((element) {
      overlay = element;
    });
    return overlay;
  }

  /// give access to Theme.of(context)
  ThemeData get theme {
    var theme = ThemeData.fallback();
    if (context != null) {
      theme = Theme.of(context!);
    }
    return theme;
  }

  /// The current null safe [WidgetsBinding]
  WidgetsBinding get engine {
    return WidgetsFlutterBinding.ensureInitialized();
  }

  /// The window to which this binding is bound.
  ui.PlatformDispatcher get window => engine.platformDispatcher;

  Locale? get deviceLocale => window.locale;

  ///The number of device pixels for each logical pixel.
  double get pixelRatio => window.implicitView!.devicePixelRatio;

  Size get size => window.implicitView!.physicalSize / pixelRatio;

  ///The horizontal extent of this size.
  double get width => size.width;

  ///The vertical extent of this size
  double get height => size.height;

  ///The distance from the top edge to the first unpadded pixel,
  ///in physical pixels.
  double get statusBarHeight => window.implicitView!.padding.top;

  ///The distance from the bottom edge to the first unpadded pixel,
  ///in physical pixels.
  double get bottomBarHeight => window.implicitView!.padding.bottom;

  ///The system-reported text scale.
  double get textScaleFactor => window.textScaleFactor;

  /// give access to TextTheme.of(context)
  TextTheme get textTheme => theme.textTheme;

  /// give access to Mediaquery.of(context)
  MediaQueryData get mediaQuery => MediaQuery.of(context!);

  /// Check if dark mode theme is enable
  bool get isDarkMode => (theme.brightness == Brightness.dark);

  /// Check if dark mode theme is enable on platform on android Q+
  bool get isPlatformDarkMode =>
      (ui.PlatformDispatcher.instance.platformBrightness == Brightness.dark);

  /// give access to Theme.of(context).iconTheme.color
  Color? get iconColor => theme.iconTheme.color;

  /// give access to FocusScope.of(context)
  FocusNode? get focusScope => FocusManager.instance.primaryFocus;

  // /// give access to Immutable MediaQuery.of(context).size.height
  // double get height => MediaQuery.of(context).size.height;

  // /// give access to Immutable MediaQuery.of(context).size.width
  // double get width => MediaQuery.of(context).size.width;

  GlobalKey<NavigatorState> get key => rootController.key;

  Map<String, GetDelegate> get keys => rootController.keys;

  GetRootState get rootController => GetRootState.controller;

  ConfigData get _getxController => GetRootState.controller.config;

  bool? get defaultPopGesture => _getxController.defaultPopGesture;
  bool get defaultOpaqueRoute => _getxController.defaultOpaqueRoute;

  Transition? get defaultTransition => _getxController.defaultTransition;

  Duration get defaultTransitionDuration {
    return _getxController.defaultTransitionDuration;
  }

  Curve get defaultTransitionCurve => _getxController.defaultTransitionCurve;

  Curve get defaultDialogTransitionCurve {
    return _getxController.defaultDialogTransitionCurve;
  }

  Duration get defaultDialogTransitionDuration {
    return _getxController.defaultDialogTransitionDuration;
  }

  Routing get routing => _getxController.routing;

  bool get _shouldUseMock => GetTestMode.active && !GetRoot.treeInitialized;

  /// give current arguments
  dynamic get arguments {
    return args();
  }

  T args<T>() {
    if (_shouldUseMock) {
      return GetTestMode.arguments as T;
    }
    return rootController.rootDelegate.arguments<T>();
  }

  // set parameters(Map<String, String?> newParameters) {
  //   rootController.parameters = newParameters;
  // }

  // @Deprecated('Use GetTestMode.active=true instead')
  set testMode(bool isTest) => GetTestMode.active = isTest;

  // @Deprecated('Use GetTestMode.active instead')
  bool get testMode => GetTestMode.active;

  Map<String, String?> get parameters {
    if (_shouldUseMock) {
      return GetTestMode.parameters;
    }

    return rootController.rootDelegate.parameters;
  }

  /// Casts the stored router delegate to a desired type
  TDelegate? delegate<TDelegate extends RouterDelegate<TPage>, TPage>() =>
      _getxController.routerDelegate as TDelegate?;
}

extension OverlayExt on GetInterface {
  Future<T> showOverlay<T>({
    required Future<T> Function() asyncFunction,
    Color opacityColor = Colors.black,
    Widget? loadingWidget,
    double opacity = .5,
  }) async {
    final navigatorState =
        Navigator.of(Get.overlayContext!, rootNavigator: false);
    final overlayState = navigatorState.overlay!;

    final overlayEntryOpacity = OverlayEntry(builder: (context) {
      return Opacity(
          opacity: opacity,
          child: Container(
            color: opacityColor,
          ));
    });
    final overlayEntryLoader = OverlayEntry(builder: (context) {
      return loadingWidget ??
          const Center(
              child: SizedBox(
            height: 90,
            width: 90,
            child: Text('Loading...'),
          ));
    });
    overlayState.insert(overlayEntryOpacity);
    overlayState.insert(overlayEntryLoader);

    T data;

    try {
      data = await asyncFunction();
    } on Exception catch (_) {
      overlayEntryLoader.remove();
      overlayEntryOpacity.remove();
      rethrow;
    }

    overlayEntryLoader.remove();
    overlayEntryOpacity.remove();
    return data;
  }
}


Instructions for the chapter (Generate content in English unless specified otherwise):
- Start with a clear heading (e.g., `# Chapter 2: GetNavigation Extensions (e.g., Get.toNamed, Get.snackbar)
`). Use the provided concept name.

- If this is not the first chapter, begin with a brief transition from the previous chapter, referencing it with a proper Markdown link using its name.

- Begin with a high-level motivation explaining what problem this abstraction solves. Start with a central use case as a concrete example. The whole chapter should guide the reader to understand how to solve this use case. Make it very minimal and friendly to beginners.

- If the abstraction is complex, break it down into key concepts. Explain each concept one-by-one in a very beginner-friendly way.

- Explain how to use this abstraction to solve the use case. Give example inputs and outputs for code snippets (if the output isn't values, describe at a high level what will happen).

- Each code block should be BELOW 10 lines! If longer code blocks are needed, break them down into smaller pieces and walk through them one-by-one. Aggresively simplify the code to make it minimal. Use comments to skip non-important implementation details. Each code block should have a beginner friendly explanation right after it.

- Describe the internal implementation to help understand what's under the hood. First provide a non-code or code-light walkthrough on what happens step-by-step when the abstraction is called. It's recommended to use a simple sequenceDiagram with a dummy example - keep it minimal with at most 5 participants to ensure clarity. If participant name has space, use: `participant QP as Query Processing`. .

- Then dive deeper into code for the internal implementation with references to files. Provide example code blocks, but make them similarly simple and beginner-friendly. Explain.

- IMPORTANT: When you need to refer to other core abstractions covered in other chapters, ALWAYS use proper Markdown links like this: [Chapter Title](filename.md). Use the Complete Tutorial Structure above to find the correct filename and the chapter title. Translate the surrounding text.

- Use mermaid diagrams to illustrate complex concepts (```mermaid``` format). .

- Heavily use analogies and examples throughout to help beginners understand.

- End the chapter with a brief conclusion that summarizes what was learned and provides a transition to the next chapter. If there is a next chapter, use a proper Markdown link: [Next Chapter Title](next_chapter_filename).

- Ensure the tone is welcoming and easy for a newcomer to understand.

- Output *only* the Markdown content for this chapter.

Now, directly provide a super beginner-friendly Markdown output (DON'T need ```markdown``` tags):

2025-05-16 11:07:16,847 - INFO - RESPONSE: # Chapter 2: GetNavigation Extensions (e.g., Get.toNamed, Get.snackbar)

Welcome back! In [Chapter 1: GetMaterialApp / GetCupertinoApp & GetRoot](01_getmaterialapp___getcupertinoapp___getroot_.md), we learned how to set up the foundation of our GetX app using `GetMaterialApp` or `GetCupertinoApp`. This simple step unlocked a world of powerful GetX features. Now, let's explore one of the most loved features: making navigation and showing pop-ups incredibly easy!

## The Old Way vs. The GetX Way

Imagine you're in your app, perhaps inside a settings page, and you want to navigate to a user profile page after a button tap. In standard Flutter, you'd typically need `BuildContext` to do this:

```dart
// Standard Flutter (needs context)
Navigator.push(context, MaterialPageRoute(builder: (context) => ProfileScreen()));
```

What if your button's logic is inside a separate class, like a ViewModel or a Controller, that doesn't have direct access to `BuildContext`? Passing `BuildContext` around can make your code a bit messy.

This is where GetX shines! GetX provides **GetNavigation Extensions**. These are convenient shortcut methods attached to the `Get` interface (think of `Get` as your GetX toolkit). They allow you to navigate or show UI elements like dialogs, snackbars, and bottom sheets from *anywhere* in your code without needing a `BuildContext`.

Think of it as a **universal remote control** for your app's navigation and common UI pop-ups. Instead of finding the specific local remote (`BuildContext`) for the TV in a room, you use one master remote (`Get`) to control any TV (navigation, dialog) in the house.

## Your Universal Remote: Meet `Get`

The `Get` object is your central access point for many GetX features. When you see `Get.something()`, you're using one of these handy extensions.

Let's see how this "universal remote" works for common tasks.

### 1. Navigating to a New Screen: `Get.to()`

Want to go to a new screen? Just use `Get.to()` and tell it which screen (widget) to build.

**Use Case:** Let's say we have a `HomeScreen` and we want to navigate to a `DetailScreen`.

First, your `main.dart` should be set up with `GetMaterialApp` (as learned in Chapter 1):

```dart
// main.dart
import 'package:flutter/material.dart';
import 'package:get/get.dart';
import 'home_screen.dart'; // We'll create this next

void main() {
  runApp(MyApp());
}

class MyApp extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return GetMaterialApp( // Using GetMaterialApp
      title: 'GetX Navigation',
      home: HomeScreen(),
    );
  }
}
```
This setup is crucial because `GetMaterialApp` prepares GetX for context-less navigation.

Now, let's create `HomeScreen` and `DetailScreen`:

```dart
// home_screen.dart
import 'package:flutter/material.dart';
import 'package:get/get.dart';
import 'detail_screen.dart'; // We'll create this

class HomeScreen extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(title: Text('Home')),
      body: Center(
        child: ElevatedButton(
          onPressed: () {
            // Look, no context needed!
            Get.to(() => DetailScreen());
          },
          child: Text('Go to Details'),
        ),
      ),
    );
  }
}
```
In `HomeScreen`, when the button is pressed, `Get.to(() => DetailScreen())` is called. This tells GetX to push `DetailScreen` onto the navigation stack.

```dart
// detail_screen.dart
import 'package:flutter/material.dart';

class DetailScreen extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(title: Text('Details')),
      body: Center(child: Text('This is the Detail Screen!')),
    );
  }
}
```
`DetailScreen` is just a simple page. When you tap the button on `HomeScreen`, you'll navigate to `DetailScreen`.

**What happened?**
`Get.to(() => DetailScreen())` pushed a new route displaying `DetailScreen` onto the navigation stack. The `() => DetailScreen()` part is a function that creates your new screen.

### 2. Navigating with Named Routes: `Get.toNamed()`

Sometimes, you prefer to navigate using names instead of creating widget instances directly. This is great for clean code and is essential for web routing. GetX makes this super easy with `Get.toNamed()`.

First, you need to define your named routes in `GetMaterialApp` using the `getPages` property. We'll dive deeper into `getPages` in [GetPage & GetRouterDelegate](03_getpage___getrouterdelegate__.md), but here's a sneak peek:

```dart
// main.dart (updated)
import 'package:flutter/material.dart';
import 'package:get/get.dart';
import 'home_screen.dart';
import 'detail_screen.dart'; // Import DetailScreen

void main() {
  runApp(MyApp());
}

class MyApp extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return GetMaterialApp(
      title: 'GetX Named Navigation',
      initialRoute: '/home', // Optional: set an initial route
      getPages: [
        GetPage(name: '/home', page: () => HomeScreen()),
        GetPage(name: '/detail', page: () => DetailScreen()),
      ],
    );
  }
}
```
We've defined two routes: `/home` pointing to `HomeScreen` and `/detail` pointing to `DetailScreen`.

Now, in your `HomeScreen`, you can navigate using the name:

```dart
// home_screen.dart (updated for named route)
// ... (imports remain the same)
class HomeScreen extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(title: Text('Home')),
      body: Center(
        child: ElevatedButton(
          onPressed: () {
            Get.toNamed('/detail'); // Navigate by name!
          },
          child: Text('Go to Details (Named)'),
        ),
      ),
    );
  }
}
```
When you tap the button, `Get.toNamed('/detail')` looks up the '/detail' route you defined in `getPages` and navigates to `DetailScreen`.

### 3. Going Back: `Get.back()`

To go back to the previous screen, it's as simple as:

```dart
// Inside DetailScreen, for example
ElevatedButton(
  onPressed: () {
    Get.back(); // Go back to HomeScreen
  },
  child: Text('Go Back'),
)
```
`Get.back()` pops the current screen from the navigation stack, just like Flutter's `Navigator.pop(context)`.

### 4. Showing a Quick Message: `Get.snackbar()`

Need to show a quick notification or message (a "snackbar")? GetX has you covered, again, without needing `BuildContext`.

```dart
// In any button's onPressed, or anywhere else:
ElevatedButton(
  onPressed: () {
    Get.snackbar(
      "Success!", // Title
      "Your action was completed.", // Message
      snackPosition: SnackPosition.BOTTOM, // Optional: position
    );
  },
  child: Text('Show Snackbar'),
)
```
This will display a sleek snackbar at the bottom (or top, depending on `snackPosition`) of your screen. It's that easy! We'll explore snackbars in more detail in [Overlay Management (Snackbar, Dialog, BottomSheet)](04_overlay_management__snackbar__dialog__bottomsheet__.md).

### 5. A Peek at Dialogs and Bottom Sheets

GetX also simplifies showing dialogs and bottom sheets without `BuildContext`.

*   **Dialogs with `Get.dialog()`**:
    ```dart
    // Example: Show a simple dialog
    Get.dialog(
      AlertDialog(
        title: Text('Alert!'),
        content: Text('This is a GetX dialog.'),
        actions: [TextButton(onPressed: () => Get.back(), child: Text('OK'))],
      )
    );
    ```

*   **Bottom Sheets with `Get.bottomSheet()`**:
    ```dart
    // Example: Show a simple bottom sheet
    Get.bottomSheet(
      Container(
        height: 200,
        color: Colors.white,
        child: Center(child: Text('This is a GetX bottom sheet!')),
      )
    );
    ```
These are very powerful, and you'll learn all about customizing them in [Overlay Management (Snackbar, Dialog, BottomSheet)](04_overlay_management__snackbar__dialog__bottomsheet__.md). For now, just know they exist and are super easy to call!

## How Does This Magic Work? Under the Hood

You might be wondering: "If I'm not giving it `BuildContext`, how does `Get.toNamed()` or `Get.snackbar()` know where to navigate or show the message?"

It's thanks to the setup we did in [Chapter 1: GetMaterialApp / GetCupertinoApp & GetRoot](01_getmaterialapp___getcupertinoapp___getroot_.md)!

1.  **The Foundation**: When you use `GetMaterialApp` (or `GetCupertinoApp`), it internally creates and configures a `GetRoot` widget. This `GetRoot` widget holds a global `NavigatorKey`. Think of this key as a direct phone line to Flutter's navigation system. It also manages an `OverlayKey` for things like snackbars and dialogs.

2.  **The Call**: When you call something like `Get.toNamed('/detail')`, the static `Get` interface uses this globally available `NavigatorKey` (managed by `GetRootController`) to access the current `NavigatorState`.

3.  **The Action**: Once it has the `NavigatorState`, it can then call the standard Flutter methods like `navigatorState.pushNamed('/detail')` or `navigatorState.push(MaterialPageRoute(...))`.

For snackbars, dialogs, and bottom sheets, `Get` uses a similar mechanism to access the `OverlayState` (via `Get.overlayContext`) to display these UI elements on top of your current screen.

Here's a simplified flow:

```mermaid
sequenceDiagram
    participant YourWidget as Your Widget (e.g., Button)
    participant GetStatic as Get (Static Interface)
    participant GetRootCtrl as GetRoot Controller (from GetMaterialApp)
    participant FlutterNavigator as Flutter Navigator/Overlay

    YourWidget->>GetStatic: Calls Get.toNamed("/details") or Get.snackbar(...)
    GetStatic->>GetRootCtrl: Accesses root NavigatorKey or OverlayContext
    GetRootCt<ctrl63>
2025-05-16 11:07:16,927 - INFO - PROMPT: 
Write a very beginner-friendly tutorial chapter (in Markdown format) for the project `getx` about the concept: "GetPage & GetRouterDelegate
". This is Chapter 3.

Concept Details:
- Name: GetPage & GetRouterDelegate

- Description:
`GetPage` is like a blueprint for a screen in your app. It defines the screen's name (URL path), what content to show, and any special behaviors like transitions or data bindings.
`GetRouterDelegate` is the captain of your app's navigation. It takes these `GetPage` blueprints and manages the actual stack of screens, deciding which page is currently visible, how to go to new pages, and how to go back. It's the core engine that powers Flutter's modern Navigator 2.0 system within GetX.


Complete Tutorial Structure:
1. [GetMaterialApp / GetCupertinoApp & GetRoot
](01_getmaterialapp___getcupertinoapp___getroot_.md)
2. [GetNavigation Extensions (e.g., Get.toNamed, Get.snackbar)
](02_getnavigation_extensions__e_g___get_tonamed__get_snackbar__.md)
3. [GetPage & GetRouterDelegate
](03_getpage___getrouterdelegate_.md)
4. [Overlay Management (Snackbar, Dialog, BottomSheet)
](04_overlay_management__snackbar__dialog__bottomsheet__.md)
5. [Route Parsing & Configuration (RouteDecoder, PageSettings, ParseRouteTree)
](05_route_parsing___configuration__routedecoder__pagesettings__parseroutetree__.md)
6. [GetMiddleware
](06_getmiddleware_.md)
7. [Transition System (GetPageRouteTransitionMixin, CustomTransition, Transitions)
](07_transition_system__getpageroutetransitionmixin__customtransition__transitions__.md)
8. [RouterReportManager
](08_routerreportmanager_.md)

Context from previous chapters:
# Chapter 1: GetMaterialApp / GetCupertinoApp & GetRoot

Welcome to your GetX journey! This is the very first step into a powerful and easy-to-use Flutter framework. In this chapter, we'll explore the foundational building blocks of any GetX application: `GetMaterialApp`, `GetCupertinoApp`, and the unsung hero, `GetRoot`.

## What's the Big Deal? Setting Up Your GetX App

Imagine you're building a house. Before you can add rooms, furniture, or even think about painting the walls, you need a solid foundation and the main structure, right? In a Flutter app using GetX, `GetMaterialApp` or `GetCupertinoApp` are like choosing the architectural style of your house (Material Design for Android-style or Cupertino for iOS-style), and they lay this essential groundwork.

Flutter apps usually start with `MaterialApp` (for Material Design) or `CupertinoApp` (for iOS-style design). GetX provides its own versions:

*   `GetMaterialApp`
*   `GetCupertinoApp`

Why use these instead of the standard Flutter ones? Because they do something crucial: **they initialize the GetX framework**. This "initialization" means they set up all the cool things GetX offers, like super-easy navigation, smart state management, and simple internationalization (showing your app in different languages).

Think of it like this: standard `MaterialApp` gives you a basic house blueprint. `GetMaterialApp` gives you that same blueprint but also installs the main electrical panel, plumbing system, and a smart home hub, all ready for you to use GetX features without extra setup.

## Meet the Stars of the Show

Let's break down these key components:

### 1. `GetMaterialApp` (for Material Design lovers)

If you're building an app that follows Google's Material Design guidelines (common for Android apps, but also widely used for cross-platform apps), you'll use `GetMaterialApp`. It's a direct replacement for Flutter's `MaterialApp`. By using it, you're telling your app, "Hey, I want to use GetX features!"

```dart
// main.dart
import 'package:flutter/material.dart';
import 'package:get/get.dart'; // Don't forget to import GetX!

void main() {
  runApp(MyApp());
}

class MyApp extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return GetMaterialApp( // <-- See? We use GetMaterialApp here!
      title: 'My First GetX App',
      home: MyHomePage(),
    );
  }
}

class MyHomePage extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(title: Text('GetX is Awesome!')),
      body: Center(child: Text('Hello, GetX World!')),
    );
  }
}
```
In this very simple app, just by changing `MaterialApp` to `GetMaterialApp`, we've unlocked the potential to use all of GetX's powerful features throughout our `MyApp`.

### 2. `GetCupertinoApp` (for iOS aficionados)

If you're aiming for an app that looks and feels like a native iOS application, you'll use `GetCupertinoApp`. It's the GetX equivalent of Flutter's `CupertinoApp`.

```dart
// main.dart
import 'package:flutter/cupertino.dart';
import 'package:get/get.dart'; // Import GetX

void main() {
  runApp(MyApp());
}

class MyApp extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return GetCupertinoApp( // <-- Using GetCupertinoApp for iOS style
      title: 'My First GetX iOS App',
      home: MyHomePage(),
    );
  }
}

class MyHomePage extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return CupertinoPageScaffold(
      navigationBar: CupertinoNavigationBar(
        middle: Text('Hello, GetX (iOS Style)!'),
      ),
      child: Center(child: Text('GetX on Cupertino!')),
    );
  }
}
```
Similar to `GetMaterialApp`, using `GetCupertinoApp` sets up your app for GetX functionalities but with an iOS-style foundation.

### 3. `GetRoot`: The Engine Under the Hood

You might not ever type `GetRoot` directly in your code, but it's super important to know it exists. `GetRoot` is the core widget that both `GetMaterialApp` and `GetCupertinoApp` use internally.

Think of `GetRoot` as the main power supply and central control panel for the GetX system in your app. It's responsible for:
*   Managing global configurations.
*   Setting up the routing system that GetX uses for navigation.
*   Initializing dependency management.
*   Handling internationalization settings (like current language).

So, when you use `GetMaterialApp` or `GetCupertinoApp`, they are essentially putting a `GetRoot` widget at the very top of your application's widget tree. This makes all the GetX features available to every part of your app.

## How Does It Work? A Peek Inside

You don't need to know the intricate details to use GetX effectively, but a little insight can be helpful!

1.  **You start your app:** You use `GetMaterialApp` (or `GetCupertinoApp`) as the root widget in your `main.dart` file.
2.  **`GetMaterialApp` takes charge:** When `GetMaterialApp` is built, its main job is to create and configure a `GetRoot` widget. It passes along all your app's configurations (like themes, initial routes, translations, etc.) to `GetRoot`.
3.  **`GetRoot` powers up:** `GetRoot` receives these configurations and initializes the entire GetX ecosystem. It sets up internal controllers, listeners for things like language changes, and provides the necessary context for GetX features to work.
4.  **Your app is ready!** With `GetRoot` in place, all other GetX functionalities (like `Get.to()` for navigation, `Get.put()` for dependency injection, `Get.snackbar()` for messages) can now find the necessary GetX infrastructure and work their magic.

Let's visualize this flow:

```mermaid
sequenceDiagram
    participant UserApp as main.dart
    participant GMA as GetMaterialApp
    participant GR as GetRoot
    participant GetXCore as GetX Core System

    UserApp->>GMA: Uses GetMaterialApp/GetCupertinoApp
    GMA->>GR: Wraps its child with GetRoot, passing configurations
    GR->>GetXCore: Initializes GetX services (routing, DI, locale)
    GMA->>UserApp: Renders app with GetX features enabled
```

**A Tiny Glimpse into the Code:**

You won't usually need to touch this code, but it helps to see it.

Here's a simplified look at what `GetMaterialApp` does in its `build` method (from `lib/get_navigation/src/root/get_material_app.dart`):

```dart
// Inside GetMaterialApp's build method
@override
Widget build(BuildContext context) {
  return GetRoot( // Notice! It returns a GetRoot widget.
    config: ConfigData( // Bundles up all configurations
      // ... like home, getPages, locale, theme ...
      home: home,
      getPages: getPages,
      locale: locale,
      theme: theme,
      // ... and many other settings you provide ...
    ),
    child: Builder(builder: (context) {
      // This inner part builds the actual MaterialApp,
      // now empowered by GetRoot and its configurations.
      final controller = GetRoot.of(context);
      return MaterialApp.router( /* ... uses controller.config ... */ );
    }),
  );
}
```
This code shows that `GetMaterialApp` essentially sets up `GetRoot` with all your app's settings. `GetRoot` then takes care of the nitty-gritty GetX initialization.

And here's a very simplified idea of what `GetRoot` does when it starts (from `lib/get_navigation/src/root/get_root.dart`):

```dart
// Inside GetRootState's initState method
@override
void initState() {
  config = widget.config; // Receives config from GetMaterialApp/GetCupertinoApp
  // ... other setup ...
  onInit(); // Calls a special GetX initialization method
  super.initState();
}

void onInit() {
  // Example: Sets up the current language (locale) for your app
  if (config.locale != null) Get.locale = config.locale;

  // Example: Initializes translations if you provide them
  if (config.translations != null) {
    Get.addTranslations(config.translations!.keys);
  }
  // ... and much more initialization for routing, logging, etc. ...
}
```
This `onInit()` method within `GetRoot` is where a lot of the GetX magic gets set up based on the properties you pass to `GetMaterialApp` or `GetCupertinoApp`.

## Why Bother? The Benefits

*   **Simplicity:** You just swap `MaterialApp` with `GetMaterialApp` (or `CupertinoApp` with `GetCupertinoApp`), and you're ready to use GetX. No complex setup rituals!
*   **Power:** This simple change unlocks a vast array of features:
    *   Effortless route management (covered in [GetNavigation Extensions (e.g., Get.toNamed, Get.snackbar)](02_getnavigation_extensions__e_g___get_tonamed__get_snackbar__.md) and [GetPage & GetRouterDelegate](03_getpage___getrouterdelegate__.md)).
    *   Simple state management.
    *   Easy dependency injection.
    *   Built-in internationalization.
    *   Dialogs, Snackbars, and BottomSheets without `context` (see [Overlay Management (Snackbar, Dialog, BottomSheet)](04_overlay_management__snackbar__dialog__bottomsheet__.md)).
*   **Performance:** GetX is designed to be lightweight and performant.

## Conclusion

You've just learned about the most fundamental step in building a GetX application: using `GetMaterialApp` or `GetCupertinoApp`. These widgets, powered by the underlying `GetRoot`, are your gateway to the GetX ecosystem. They seamlessly initialize everything you need, allowing you to focus on building amazing features rather than wrestling with boilerplate setup.

With this foundation laid, you're now ready to explore one of the most beloved features of GetX: its incredibly simple and powerful navigation system.

Ready to learn how to move between screens with ease? Let's dive into the [GetNavigation Extensions (e.g., Get.toNamed, Get.snackbar)](02_getnavigation_extensions__e_g___get_tonamed__get_snackbar__.md)!
---
# Chapter 2: GetNavigation Extensions (e.g., Get.toNamed, Get.snackbar)

Welcome back! In [Chapter 1: GetMaterialApp / GetCupertinoApp & GetRoot](01_getmaterialapp___getcupertinoapp___getroot_.md), we learned how to set up the foundation of our GetX app using `GetMaterialApp` or `GetCupertinoApp`. This simple step unlocked a world of powerful GetX features. Now, let's explore one of the most loved features: making navigation and showing pop-ups incredibly easy!

## The Old Way vs. The GetX Way

Imagine you're in your app, perhaps inside a settings page, and you want to navigate to a user profile page after a button tap. In standard Flutter, you'd typically need `BuildContext` to do this:

```dart
// Standard Flutter (needs context)
Navigator.push(context, MaterialPageRoute(builder: (context) => ProfileScreen()));
```

What if your button's logic is inside a separate class, like a ViewModel or a Controller, that doesn't have direct access to `BuildContext`? Passing `BuildContext` around can make your code a bit messy.

This is where GetX shines! GetX provides **GetNavigation Extensions**. These are convenient shortcut methods attached to the `Get` interface (think of `Get` as your GetX toolkit). They allow you to navigate or show UI elements like dialogs, snackbars, and bottom sheets from *anywhere* in your code without needing a `BuildContext`.

Think of it as a **universal remote control** for your app's navigation and common UI pop-ups. Instead of finding the specific local remote (`BuildContext`) for the TV in a room, you use one master remote (`Get`) to control any TV (navigation, dialog) in the house.

## Your Universal Remote: Meet `Get`

The `Get` object is your central access point for many GetX features. When you see `Get.something()`, you're using one of these handy extensions.

Let's see how this "universal remote" works for common tasks.

### 1. Navigating to a New Screen: `Get.to()`

Want to go to a new screen? Just use `Get.to()` and tell it which screen (widget) to build.

**Use Case:** Let's say we have a `HomeScreen` and we want to navigate to a `DetailScreen`.

First, your `main.dart` should be set up with `GetMaterialApp` (as learned in Chapter 1):

```dart
// main.dart
import 'package:flutter/material.dart';
import 'package:get/get.dart';
import 'home_screen.dart'; // We'll create this next

void main() {
  runApp(MyApp());
}

class MyApp extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return GetMaterialApp( // Using GetMaterialApp
      title: 'GetX Navigation',
      home: HomeScreen(),
    );
  }
}
```
This setup is crucial because `GetMaterialApp` prepares GetX for context-less navigation.

Now, let's create `HomeScreen` and `DetailScreen`:

```dart
// home_screen.dart
import 'package:flutter/material.dart';
import 'package:get/get.dart';
import 'detail_screen.dart'; // We'll create this

class HomeScreen extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(title: Text('Home')),
      body: Center(
        child: ElevatedButton(
          onPressed: () {
            // Look, no context needed!
            Get.to(() => DetailScreen());
          },
          child: Text('Go to Details'),
        ),
      ),
    );
  }
}
```
In `HomeScreen`, when the button is pressed, `Get.to(() => DetailScreen())` is called. This tells GetX to push `DetailScreen` onto the navigation stack.

```dart
// detail_screen.dart
import 'package:flutter/material.dart';

class DetailScreen extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(title: Text('Details')),
      body: Center(child: Text('This is the Detail Screen!')),
    );
  }
}
```
`DetailScreen` is just a simple page. When you tap the button on `HomeScreen`, you'll navigate to `DetailScreen`.

**What happened?**
`Get.to(() => DetailScreen())` pushed a new route displaying `DetailScreen` onto the navigation stack. The `() => DetailScreen()` part is a function that creates your new screen.

### 2. Navigating with Named Routes: `Get.toNamed()`

Sometimes, you prefer to navigate using names instead of creating widget instances directly. This is great for clean code and is essential for web routing. GetX makes this super easy with `Get.toNamed()`.

First, you need to define your named routes in `GetMaterialApp` using the `getPages` property. We'll dive deeper into `getPages` in [GetPage & GetRouterDelegate](03_getpage___getrouterdelegate__.md), but here's a sneak peek:

```dart
// main.dart (updated)
import 'package:flutter/material.dart';
import 'package:get/get.dart';
import 'home_screen.dart';
import 'detail_screen.dart'; // Import DetailScreen

void main() {
  runApp(MyApp());
}

class MyApp extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return GetMaterialApp(
      title: 'GetX Named Navigation',
      initialRoute: '/home', // Optional: set an initial route
      getPages: [
        GetPage(name: '/home', page: () => HomeScreen()),
        GetPage(name: '/detail', page: () => DetailScreen()),
      ],
    );
  }
}
```
We've defined two routes: `/home` pointing to `HomeScreen` and `/detail` pointing to `DetailScreen`.

Now, in your `HomeScreen`, you can navigate using the name:

```dart
// home_screen.dart (updated for named route)
// ... (imports remain the same)
class HomeScreen extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(title: Text('Home')),
      body: Center(
        child: ElevatedButton(
          onPressed: () {
            Get.toNamed('/detail'); // Navigate by name!
          },
          child: Text('Go to Details (Named)'),
        ),
      ),
    );
  }
}
```
When you tap the button, `Get.toNamed('/detail')` looks up the '/detail' route you defined in `getPages` and navigates to `DetailScreen`.

### 3. Going Back: `Get.back()`

To go back to the previous screen, it's as simple as:

```dart
// Inside DetailScreen, for example
ElevatedButton(
  onPressed: () {
    Get.back(); // Go back to HomeScreen
  },
  child: Text('Go Back'),
)
```
`Get.back()` pops the current screen from the navigation stack, just like Flutter's `Navigator.pop(context)`.

### 4. Showing a Quick Message: `Get.snackbar()`

Need to show a quick notification or message (a "snackbar")? GetX has you covered, again, without needing `BuildContext`.

```dart
// In any button's onPressed, or anywhere else:
ElevatedButton(
  onPressed: () {
    Get.snackbar(
      "Success!", // Title
      "Your action was completed.", // Message
      snackPosition: SnackPosition.BOTTOM, // Optional: position
    );
  },
  child: Text('Show Snackbar'),
)
```
This will display a sleek snackbar at the bottom (or top, depending on `snackPosition`) of your screen. It's that easy! We'll explore snackbars in more detail in [Overlay Management (Snackbar, Dialog, BottomSheet)](04_overlay_management__snackbar__dialog__bottomsheet__.md).

### 5. A Peek at Dialogs and Bottom Sheets

GetX also simplifies showing dialogs and bottom sheets without `BuildContext`.

*   **Dialogs with `Get.dialog()`**:
    ```dart
    // Example: Show a simple dialog
    Get.dialog(
      AlertDialog(
        title: Text('Alert!'),
        content: Text('This is a GetX dialog.'),
        actions: [TextButton(onPressed: () => Get.back(), child: Text('OK'))],
      )
    );
    ```

*   **Bottom Sheets with `Get.bottomSheet()`**:
    ```dart
    // Example: Show a simple bottom sheet
    Get.bottomSheet(
      Container(
        height: 200,
        color: Colors.white,
        child: Center(child: Text('This is a GetX bottom sheet!')),
      )
    );
    ```
These are very powerful, and you'll learn all about customizing them in [Overlay Management (Snackbar, Dialog, BottomSheet)](04_overlay_management__snackbar__dialog__bottomsheet__.md). For now, just know they exist and are super easy to call!

## How Does This Magic Work? Under the Hood

You might be wondering: "If I'm not giving it `BuildContext`, how does `Get.toNamed()` or `Get.snackbar()` know where to navigate or show the message?"

It's thanks to the setup we did in [Chapter 1: GetMaterialApp / GetCupertinoApp & GetRoot](01_getmaterialapp___getcupertinoapp___getroot_.md)!

1.  **The Foundation**: When you use `GetMaterialApp` (or `GetCupertinoApp`), it internally creates and configures a `GetRoot` widget. This `GetRoot` widget holds a global `NavigatorKey`. Think of this key as a direct phone line to Flutter's navigation system. It also manages an `OverlayKey` for things like snackbars and dialogs.

2.  **The Call**: When you call something like `Get.toNamed('/detail')`, the static `Get` interface uses this globally available `NavigatorKey` (managed by `GetRootController`) to access the current `NavigatorState`.

3.  **The Action**: Once it has the `NavigatorState`, it can then call the standard Flutter methods like `navigatorState.pushNamed('/detail')` or `navigatorState.push(MaterialPageRoute(...))`.

For snackbars, dialogs, and bottom sheets, `Get` uses a similar mechanism to access the `OverlayState` (via `Get.overlayContext`) to display these UI elements on top of your current screen.

Here's a simplified flow:

```mermaid
sequenceDiagram
    participant YourWidget as Your Widget (e.g., Button)
    participant GetStatic as Get (Static Interface)
    participant GetRootCtrl as GetRoot Controller (from GetMaterialApp)
    participant FlutterNavigator as Flutter Navigator/Overlay

    YourWidget->>GetStatic: Calls Get.toNamed("/details") or Get.snackbar(...)
    GetStatic->>GetRootCtrl: Accesses root NavigatorKey or OverlayContext
    GetRootCt<ctrl63>

Relevant Code Snippets (Code itself remains unchanged):
--- File: lib/get_navigation/src/routes/get_router_delegate.dart ---
import 'dart:async';

import 'package:flutter/foundation.dart';
import 'package:flutter/material.dart';

import '../../../get_instance/src/bindings_interface.dart';
import '../../../get_utils/src/platform/platform.dart';
import '../../../route_manager.dart';

class GetDelegate extends RouterDelegate<RouteDecoder>
    with
        ChangeNotifier,
        PopNavigatorRouterDelegateMixin<RouteDecoder>,
        IGetNavigation {
  factory GetDelegate.createDelegate({
    GetPage<dynamic>? notFoundRoute,
    List<GetPage> pages = const [],
    List<NavigatorObserver>? navigatorObservers,
    TransitionDelegate<dynamic>? transitionDelegate,
    PopMode backButtonPopMode = PopMode.history,
    PreventDuplicateHandlingMode preventDuplicateHandlingMode =
        PreventDuplicateHandlingMode.reorderRoutes,
    GlobalKey<NavigatorState>? navigatorKey,
  }) {
    return GetDelegate(
      notFoundRoute: notFoundRoute,
      navigatorObservers: navigatorObservers,
      transitionDelegate: transitionDelegate,
      backButtonPopMode: backButtonPopMode,
      preventDuplicateHandlingMode: preventDuplicateHandlingMode,
      pages: pages,
      navigatorKey: navigatorKey,
    );
  }

  final List<RouteDecoder> _activePages = <RouteDecoder>[];
  final PopMode backButtonPopMode;
  final PreventDuplicateHandlingMode preventDuplicateHandlingMode;

  final GetPage notFoundRoute;

  final List<NavigatorObserver>? navigatorObservers;
  final TransitionDelegate<dynamic>? transitionDelegate;

  final Iterable<GetPage> Function(RouteDecoder currentNavStack)?
      pickPagesForRootNavigator;

  List<RouteDecoder> get activePages => _activePages;

  final _routeTree = ParseRouteTree(routes: []);

  List<GetPage> get registeredRoutes => _routeTree.routes;

  void addPages(List<GetPage> getPages) {
    _routeTree.addRoutes(getPages);
  }

  void clearRouteTree() {
    _routeTree.routes.clear();
  }

  void addPage(GetPage getPage) {
    _routeTree.addRoute(getPage);
  }

  void removePage(GetPage getPage) {
    _routeTree.removeRoute(getPage);
  }

  RouteDecoder matchRoute(String name, {PageSettings? arguments}) {
    return _routeTree.matchRoute(name, arguments: arguments);
  }

  // GlobalKey<NavigatorState> get navigatorKey => Get.key;

  @override
  GlobalKey<NavigatorState> navigatorKey;

  final String? restorationScopeId;

  GetDelegate({
    GetPage? notFoundRoute,
    this.navigatorObservers,
    this.transitionDelegate,
    this.backButtonPopMode = PopMode.history,
    this.preventDuplicateHandlingMode =
        PreventDuplicateHandlingMode.reorderRoutes,
    this.pickPagesForRootNavigator,
    this.restorationScopeId,
    bool showHashOnUrl = false,
    GlobalKey<NavigatorState>? navigatorKey,
    required List<GetPage> pages,
  })  : navigatorKey = navigatorKey ?? GlobalKey<NavigatorState>(),
        notFoundRoute = notFoundRoute ??= GetPage(
          name: '/404',
          page: () => const Scaffold(
            body: Center(child: Text('Route not found')),
          ),
        ) {
    if (!showHashOnUrl && GetPlatform.isWeb) setUrlStrategy();
    addPages(pages);
    addPage(notFoundRoute);
    Get.log('GetDelegate is created !');
  }

  Future<RouteDecoder?> runMiddleware(RouteDecoder config) async {
    final middlewares = config.currentTreeBranch.last.middlewares;
    if (middlewares.isEmpty) {
      return config;
    }
    var iterator = config;
    for (var item in middlewares) {
      var redirectRes = await item.redirectDelegate(iterator);

      if (redirectRes == null) {
        config.route?.completer?.complete();
        return null;
      }
      if (config != redirectRes) {
        config.route?.completer?.complete();
        Get.log('Redirect to ${redirectRes.pageSettings?.name}');
      }

      iterator = redirectRes;
      // Stop the iteration over the middleware if we changed page
      // and that redirectRes is not the same as the current config.
      if (config != redirectRes) {
        break;
      }
    }
    // If the target is not the same as the source, we need
    // to run the middlewares for the new route.
    if (iterator != config) {
      return await runMiddleware(iterator);
    }
    return iterator;
  }

  Future<void> _unsafeHistoryAdd(RouteDecoder config) async {
    final res = await runMiddleware(config);
    if (res == null) return;
    _activePages.add(res);
  }

  // Future<T?> _unsafeHistoryRemove<T>(RouteDecoder config, T result) async {
  //   var index = _activePages.indexOf(config);
  //   if (index >= 0) return _unsafeHistoryRemoveAt(index, result);
  //   return null;
  // }

  Future<T?> _unsafeHistoryRemoveAt<T>(int index, T result) async {
    if (index == _activePages.length - 1 && _activePages.length > 1) {
      //removing WILL update the current route
      final toCheck = _activePages[_activePages.length - 2];
      final resMiddleware = await runMiddleware(toCheck);
      if (resMiddleware == null) return null;
      _activePages[_activePages.length - 2] = resMiddleware;
    }

    final completer = _activePages.removeAt(index).route?.completer;
    if (completer?.isCompleted == false) completer!.complete(result);

    return completer?.future as T?;
  }

  T arguments<T>() {
    return currentConfiguration?.pageSettings?.arguments as T;
  }

  Map<String, String> get parameters {
    return currentConfiguration?.pageSettings?.params ?? {};
  }

  PageSettings? get pageSettings {
    return currentConfiguration?.pageSettings;
  }

  Future<void> _pushHistory(RouteDecoder config) async {
    if (config.route!.preventDuplicates) {
      final originalEntryIndex = _activePages.indexWhere(
          (element) => element.pageSettings?.name == config.pageSettings?.name);
      if (originalEntryIndex >= 0) {
        switch (preventDuplicateHandlingMode) {
          case PreventDuplicateHandlingMode.popUntilOriginalRoute:
            popModeUntil(config.pageSettings!.name, popMode: PopMode.page);
            break;
          case PreventDuplicateHandlingMode.reorderRoutes:
            await _unsafeHistoryRemoveAt(originalEntryIndex, null);
            await _unsafeHistoryAdd(config);
            break;
          case PreventDuplicateHandlingMode.doNothing:
          default:
            break;
        }
        return;
      }
    }
    await _unsafeHistoryAdd(config);
  }

  Future<T?> _popHistory<T>(T result) async {
    if (!_canPopHistory()) return null;
    return await _doPopHistory(result);
  }

  Future<T?> _doPopHistory<T>(T result) async {
    return _unsafeHistoryRemoveAt<T>(_activePages.length - 1, result);
  }

  Future<T?> _popPage<T>(T result) async {
    if (!_canPopPage()) return null;
    return await _doPopPage(result);
  }

  // returns the popped page
  Future<T?> _doPopPage<T>(T result) async {
    final currentBranch = currentConfiguration?.currentTreeBranch;
    if (currentBranch != null && currentBranch.length > 1) {
      //remove last part only
      final remaining = currentBranch.take(currentBranch.length - 1);
      final prevHistoryEntry = _activePages.length > 1
          ? _activePages[_activePages.length - 2]
          : null;

      //check if current route is the same as the previous route
      if (prevHistoryEntry != null) {
        //if so, pop the entire _activePages entry
        final newLocation = remaining.last.name;
        final prevLocation = prevHistoryEntry.pageSettings?.name;
        if (newLocation == prevLocation) {
          //pop the entire _activePages entry
          return await _popHistory(result);
        }
      }

      //create a new route with the remaining tree branch
      final res = await _popHistory<T>(result);
      await _pushHistory(
        RouteDecoder(
          remaining.toList(),
          null,
          //TOOD: persist state??
        ),
      );
      return res;
    } else {
      //remove entire entry
      return await _popHistory(result);
    }
  }

  Future<T?> _pop<T>(PopMode mode, T result) async {
    switch (mode) {
      case PopMode.history:
        return await _popHistory<T>(result);
      case PopMode.page:
        return await _popPage<T>(result);
    }
  }

  Future<T?> popHistory<T>(T result) async {
    return await _popHistory<T>(result);
  }

  bool _canPopHistory() {
    return _activePages.length > 1;
  }

  Future<bool> canPopHistory() {
    return SynchronousFuture(_canPopHistory());
  }

  bool _canPopPage() {
    final currentTreeBranch = currentConfiguration?.currentTreeBranch;
    if (currentTreeBranch == null) return false;
    return currentTreeBranch.length > 1 ? true : _canPopHistory();
  }

  Future<bool> canPopPage() {
    return SynchronousFuture(_canPopPage());
  }

  bool _canPop(mode) {
    switch (mode) {
      case PopMode.history:
        return _canPopHistory();
      case PopMode.page:
      default:
        return _canPopPage();
    }
  }

  /// gets the visual pages from the current _activePages entry
  ///
  /// visual pages must have [GetPage.participatesInRootNavigator] set to true
  Iterable<GetPage> getVisualPages(RouteDecoder? currentHistory) {
    final res = currentHistory!.currentTreeBranch
        .where((r) => r.participatesInRootNavigator != null);
    if (res.isEmpty) {
      //default behavior, all routes participate in root navigator
      return _activePages.map((e) => e.route!);
    } else {
      //user specified at least one participatesInRootNavigator
      return res
          .where((element) => element.participatesInRootNavigator == true);
    }
  }

  @override
  Widget build(BuildContext context) {
    final currentHistory = currentConfiguration;
    final pages = currentHistory == null
        ? <GetPage>[]
        : pickPagesForRootNavigator?.call(currentHistory).toList() ??
            getVisualPages(currentHistory).toList();
    if (pages.isEmpty) {
      return ColoredBox(
        color: Theme.of(context).scaffoldBackgroundColor,
      );
    }
    return GetNavigator(
      key: navigatorKey,
      onPopPage: _onPopVisualRoute,
      pages: pages,
      observers: navigatorObservers,
      transitionDelegate:
          transitionDelegate ?? const DefaultTransitionDelegate<dynamic>(),
    );
  }

  @override
  Future<void> goToUnknownPage([bool clearPages = false]) async {
    if (clearPages) _activePages.clear();

    final pageSettings = _buildPageSettings(notFoundRoute.name);
    final routeDecoder = _getRouteDecoder(pageSettings);

    _push(routeDecoder!);
  }

  @protected
  void _popWithResult<T>([T? result]) {
    final completer = _activePages.removeLast().route?.completer;
    if (completer?.isCompleted == false) completer!.complete(result);
  }

  @override
  Future<T?> toNamed<T>(
    String page, {
    dynamic arguments,
    dynamic id,
    bool preventDuplicates = true,
    Map<String, String>? parameters,
  }) async {
    final args = _buildPageSettings(page, arguments);
    final route = _getRouteDecoder<T>(args);
    if (route != null) {
      return _push<T>(route);
    } else {
      goToUnknownPage();
    }
    return null;
  }

  @override
  Future<T?> to<T>(
    Widget Function() page, {
    bool? opaque,
    Transition? transition,
    Curve? curve,
    Duration? duration,
    String? id,
    String? routeName,
    bool fullscreenDialog = false,
    dynamic arguments,
    List<BindingsInterface> bindings = const [],
    bool preventDuplicates = true,
    bool? popGesture,
    bool showCupertinoParallax = true,
    double Function(BuildContext context)? gestureWidth,
    bool rebuildStack = true,
    PreventDuplicateHandlingMode preventDuplicateHandlingMode =
        PreventDuplicateHandlingMode.reorderRoutes,
  }) async {
    routeName ??= _cleanRouteName("/${page.runtimeType}");
    // if (preventDuplicateHandlingMode ==
    //PreventDuplicateHandlingMode.Recreate) {
    //   routeName = routeName + page.hashCode.toString();
    // }

    final getPage = GetPage<T>(
      name: routeName,
      opaque: opaque ?? true,
      page: page,
      gestureWidth: gestureWidth,
      showCupertinoParallax: showCupertinoParallax,
      popGesture: popGesture ?? Get.defaultPopGesture,
      transition: transition ?? Get.defaultTransition,
      curve: curve ?? Get.defaultTransitionCurve,
      fullscreenDialog: fullscreenDialog,
      bindings: bindings,
      transitionDuration: duration ?? Get.defaultTransitionDuration,
      preventDuplicateHandlingMode: preventDuplicateHandlingMode,
    );

    _routeTree.addRoute(getPage);
    final args = _buildPageSettings(routeName, arguments);
    final route = _getRouteDecoder<T>(args);
    final result = await _push<T>(
      route!,
      rebuildStack: rebuildStack,
    );
    _routeTree.removeRoute(getPage);
    return result;
  }

  @override
  Future<T?> off<T>(
    Widget Function() page, {
    bool? opaque,
    Transition? transition,
    Curve? curve,
    Duration? duration,
    String? id,
    String? routeName,
    bool fullscreenDialog = false,
    dynamic arguments,
    List<BindingsInterface> bindings = const [],
    bool preventDuplicates = true,
    bool? popGesture,
    bool showCupertinoParallax = true,
    double Function(BuildContext context)? gestureWidth,
  }) async {
    routeName ??= _cleanRouteName("/${page.runtimeType}");
    final route = GetPage<T>(
      name: routeName,
      opaque: opaque ?? true,
      page: page,
      gestureWidth: gestureWidth,
      showCupertinoParallax: showCupertinoParallax,
      popGesture: popGesture ?? Get.defaultPopGesture,
      transition: transition ?? Get.defaultTransition,
      curve: curve ?? Get.defaultTransitionCurve,
      fullscreenDialog: fullscreenDialog,
      bindings: bindings,
      transitionDuration: duration ?? Get.defaultTransitionDuration,
    );

    final args = _buildPageSettings(routeName, arguments);
    return _replace(args, route);
  }

  @override
  Future<T?>? offAll<T>(
    Widget Function() page, {
    bool Function(GetPage route)? predicate,
    bool opaque = true,
    bool? popGesture,
    String? id,
    String? routeName,
    dynamic arguments,
    List<BindingsInterface> bindings = const [],
    bool fullscreenDialog = false,
    Transition? transition,
    Curve? curve,
    Duration? duration,
    bool showCupertinoParallax = true,
    double Function(BuildContext context)? gestureWidth,
  }) async {
    routeName ??= _cleanRouteName("/${page.runtimeType}");
    final route = GetPage<T>(
      name: routeName,
      opaque: opaque,
      page: page,
      gestureWidth: gestureWidth,
      showCupertinoParallax: showCupertinoParallax,
      popGesture: popGesture ?? Get.defaultPopGesture,
      transition: transition ?? Get.defaultTransition,
      curve: curve ?? Get.defaultTransitionCurve,
      fullscreenDialog: fullscreenDialog,
      bindings: bindings,
      transitionDuration: duration ?? Get.defaultTransitionDuration,
    );

    final args = _buildPageSettings(routeName, arguments);

    final newPredicate = predicate ?? (route) => false;

    while (_activePages.length > 1 && !newPredicate(_activePages.last.route!)) {
      _popWithResult();
    }

    return _replace(args, route);
  }

  @override
  Future<T?>? offAllNamed<T>(
    String newRouteName, {
    // bool Function(GetPage route)? predicate,
    dynamic arguments,
    String? id,
    Map<String, String>? parameters,
  }) async {
    final args = _buildPageSettings(newRouteName, arguments);
    final route = _getRouteDecoder<T>(args);
    if (route == null) return null;

    while (_activePages.length > 1) {
      _activePages.removeLast();
    }

    return _replaceNamed(route);
  }

  @override
  Future<T?>? offNamedUntil<T>(
    String page, {
    bool Function(GetPage route)? predicate,
    dynamic arguments,
    String? id,
    Map<String, String>? parameters,
  }) async {
    final args = _buildPageSettings(page, arguments);
    final route = _getRouteDecoder<T>(args);
    if (route == null) return null;

    final newPredicate = predicate ?? (route) => false;

    while (_activePages.length > 1 && !newPredicate(_activePages.last.route!)) {
      _activePages.removeLast();
    }

    return _push(route);
  }

  @override
  Future<T?> offNamed<T>(
    String page, {
    dynamic arguments,
    String? id,
    Map<String, String>? parameters,
  }) async {
    final args = _buildPageSettings(page, arguments);
    final route = _getRouteDecoder<T>(args);
    if (route == null) return null;
    _popWithResult();
    return _push<T>(route);
  }

  @override
  Future<T?> toNamedAndOffUntil<T>(
    String page,
    bool Function(GetPage) predicate, [
    Object? data,
  ]) async {
    final arguments = _buildPageSettings(page, data);

    final route = _getRouteDecoder<T>(arguments);

    if (route == null) return null;

    while (_activePages.isNotEmpty && !predicate(_activePages.last.route!)) {
      _popWithResult();
    }

    return _push<T>(route);
  }

  @override
  Future<T?> offUntil<T>(
    Widget Function() page,
    bool Function(GetPage) predicate, [
    Object? arguments,
  ]) async {
    while (_activePages.isNotEmpty && !predicate(_activePages.last.route!)) {
      _popWithResult();
    }

    return to<T>(page, arguments: arguments);
  }

  @override
  void removeRoute<T>(String name) {
    _activePages.remove(RouteDecoder.fromRoute(name));
  }

  bool get canBack {
    return _activePages.length > 1;
  }

  void _checkIfCanBack() {
    assert(() {
      if (!canBack) {
        final last = _activePages.last;
        final name = last.route?.name;
        throw 'The page $name cannot be popped';
      }
      return true;
    }());
  }

  @override
  Future<R?> backAndtoNamed<T, R>(String page,
      {T? result, Object? arguments}) async {
    final args = _buildPageSettings(page, arguments);
    final route = _getRouteDecoder<R>(args);
    if (route == null) return null;
    _popWithResult<T>(result);
    return _push<R>(route);
  }

  /// Removes routes according to [PopMode]
  /// until it reaches the specific [fullRoute],
  /// DOES NOT remove the [fullRoute]
  @override
  Future<void> popModeUntil(
    String fullRoute, {
    PopMode popMode = PopMode.history,
  }) async {
    // remove history or page entries until you meet route
    var iterator = currentConfiguration;
    while (_canPop(popMode) && iterator != null) {
      //the next line causes wasm compile error if included in the while loop
      //https://github.com/flutter/flutter/issues/140110
      if (iterator.pageSettings?.name == fullRoute) {
        break;
      }
      await _pop(popMode, null);
      // replace iterator
      iterator = currentConfiguration;
    }
    notifyListeners();
  }

  @override
  void backUntil(bool Function(GetPage) predicate) {
    while (_activePages.length > 1 && !predicate(_activePages.last.route!)) {
      _popWithResult();
    }

    notifyListeners();
  }

  Future<T?> _replace<T>(PageSettings arguments, GetPage<T> page) async {
    final index = _activePages.length > 1 ? _activePages.length - 1 : 0;
    _routeTree.addRoute(page);

    final activePage = _getRouteDecoder(arguments);

    // final activePage = _configureRouterDecoder<T>(route!, arguments);

    _activePages[index] = activePage!;

    notifyListeners();
    final result = await activePage.route?.completer?.future as Future<T?>?;
    _routeTree.removeRoute(page);

    return result;
  }

  Future<T?> _replaceNamed<T>(RouteDecoder activePage) async {
    final index = _activePages.length > 1 ? _activePages.length - 1 : 0;
    // final activePage = _configureRouterDecoder<T>(page, arguments);
    _activePages[index] = activePage;

    notifyListeners();
    final result = await activePage.route?.completer?.future as Future<T?>?;
    return result;
  }

  /// Takes a route [name] String generated by [to], [off], [offAll]
  /// (and similar context navigation methods), cleans the extra chars and
  /// accommodates the format.
  /// TODO: check for a more "appealing" URL naming convention.
  /// `() => MyHomeScreenView` becomes `/my-home-screen-view`.
  String _cleanRouteName(String name) {
    name = name.replaceAll('() => ', '');

    /// uncomment for URL styling.
    // name = name.paramCase!;
    if (!name.startsWith('/')) {
      name = '/$name';
    }
    return Uri.tryParse(name)?.toString() ?? name;
  }

  PageSettings _buildPageSettings(String page, [Object? data]) {
    var uri = Uri.parse(page);
    return PageSettings(uri, data);
  }

  @protected
  RouteDecoder? _getRouteDecoder<T>(PageSettings arguments) {
    var page = arguments.uri.path;
    final parameters = arguments.params;
    if (parameters.isNotEmpty) {
      final uri = Uri(path: page, queryParameters: parameters);
      page = uri.toString();
    }

    final decoder = _routeTree.matchRoute(page, arguments: arguments);
    final route = decoder.route;
    if (route == null) return null;

    return _configureRouterDecoder<T>(decoder, arguments);
  }

  @protected
  RouteDecoder _configureRouterDecoder<T>(
      RouteDecoder decoder, PageSettings arguments) {
    final parameters =
        arguments.params.isEmpty ? arguments.query : arguments.params;
    arguments.params.addAll(arguments.query);
    if (decoder.parameters.isEmpty) {
      decoder.parameters.addAll(parameters);
    }

    decoder.route = decoder.route?.copyWith(
      completer: _activePages.isEmpty ? null : Completer<T?>(),
      arguments: arguments,
      parameters: parameters,
      key: ValueKey(arguments.name),
    );

    return decoder;
  }

  Future<T?> _push<T>(RouteDecoder decoder, {bool rebuildStack = true}) async {
    var res = await runMiddleware(decoder);
    if (res == null) return null;
    // final res = mid ?? decoder;
    // if (res == null) res = decoder;

    final preventDuplicateHandlingMode =
        res.route?.preventDuplicateHandlingMode ??
            PreventDuplicateHandlingMode.reorderRoutes;

    final onStackPage = _activePages
        .firstWhereOrNull((element) => element.route?.key == res.route?.key);

    /// There are no duplicate routes in the stack
    if (onStackPage == null) {
      _activePages.add(res);
    } else {
      /// There are duplicate routes, reorder
      switch (preventDuplicateHandlingMode) {
        case PreventDuplicateHandlingMode.doNothing:
          break;
        case PreventDuplicateHandlingMode.reorderRoutes:
          _activePages.remove(onStackPage);
          _activePages.add(res);
          break;
        case PreventDuplicateHandlingMode.popUntilOriginalRoute:
          while (_activePages.last == onStackPage) {
            _popWithResult();
          }
          break;
        case PreventDuplicateHandlingMode.recreate:
          _activePages.remove(onStackPage);
          _activePages.add(res);
      }
    }
    if (rebuildStack) {
      notifyListeners();
    }

    return decoder.route?.completer?.future as Future<T?>?;
  }

  @override
  Future<void> setNewRoutePath(RouteDecoder configuration) async {
    final page = configuration.route;
    if (page == null) {
      goToUnknownPage();
      return;
    } else {
      _push(configuration);
    }
  }

  @override
  RouteDecoder? get currentConfiguration {
    if (_activePages.isEmpty) return null;
    final route = _activePages.last;
    return route;
  }

  Future<bool> handlePopupRoutes({
    Object? result,
  }) async {
    Route? currentRoute;
    navigatorKey.currentState!.popUntil((route) {
      currentRoute = route;
      return true;
    });
    if (currentRoute is PopupRoute) {
      return await navigatorKey.currentState!.maybePop(result);
    }
    return false;
  }

  @override
  Future<bool> popRoute({
    Object? result,
    PopMode? popMode,
  }) async {
    //Returning false will cause the entire app to be popped.
    final wasPopup = await handlePopupRoutes(result: result);
    if (wasPopup) return true;

    if (_canPop(popMode ?? backButtonPopMode)) {
      await _pop(popMode ?? backButtonPopMode, result);
      notifyListeners();
      return true;
    }

    return super.popRoute();
  }

  @override
  void back<T>([T? result]) {
    _checkIfCanBack();
    _popWithResult<T>(result);
    notifyListeners();
  }

  bool _onPopVisualRoute(Route<dynamic> route, dynamic result) {
    final didPop = route.didPop(result);
    if (!didPop) {
      return false;
    }
    _popWithResult(result);
    // final settings = route.settings;
    // if (settings is GetPage) {
    //   final config = _activePages.cast<RouteDecoder?>().firstWhere(
    //         (element) => element?.route == settings,
    //         orElse: () => null,
    //       );
    //   if (config != null) {
    //     _removeHistoryEntry(config, result);
    //   }
    // }
    notifyListeners();
    //return !route.navigator!.userGestureInProgress;
    return true;
  }
}


--- File: lib/get_navigation/src/routes/get_information_parser.dart ---
import 'package:flutter/foundation.dart';
import 'package:flutter/widgets.dart';

import '../../../get.dart';

class GetInformationParser extends RouteInformationParser<RouteDecoder> {
  factory GetInformationParser.createInformationParser(
      {String initialRoute = '/'}) {
    return GetInformationParser(initialRoute: initialRoute);
  }

  final String initialRoute;

  GetInformationParser({
    required this.initialRoute,
  }) {
    Get.log('GetInformationParser is created !');
  }
  @override
  SynchronousFuture<RouteDecoder> parseRouteInformation(
    RouteInformation routeInformation,
  ) {
    final uri = routeInformation.uri;
    var location = uri.toString();
    if (location == '/') {
      //check if there is a corresponding page
      //if not, relocate to initialRoute
      if (!(Get.rootController.rootDelegate)
          .registeredRoutes
          .any((element) => element.name == '/')) {
        location = initialRoute;
      }
    } else if (location.isEmpty) {
      location = initialRoute;
    }

    Get.log('GetInformationParser: route location: $location');

    return SynchronousFuture(RouteDecoder.fromRoute(location));
  }

  @override
  RouteInformation restoreRouteInformation(RouteDecoder configuration) {
    return RouteInformation(
      uri: Uri.tryParse(configuration.pageSettings?.name ?? ''),
      state: null,
    );
  }
}


--- File: lib/get_navigation/src/routes/parse_route.dart ---
import 'package:flutter/foundation.dart';

import '../../../get.dart';

@immutable
class RouteDecoder {
  const RouteDecoder(
    this.currentTreeBranch,
    this.pageSettings,
  );
  final List<GetPage> currentTreeBranch;
  final PageSettings? pageSettings;

  factory RouteDecoder.fromRoute(String location) {
    var uri = Uri.parse(location);
    final args = PageSettings(uri);
    final decoder =
        (Get.rootController.rootDelegate).matchRoute(location, arguments: args);
    decoder.route = decoder.route?.copyWith(
      completer: null,
      arguments: args,
      parameters: args.params,
    );
    return decoder;
  }

  GetPage? get route =>
      currentTreeBranch.isEmpty ? null : currentTreeBranch.last;

  GetPage routeOrUnknown(GetPage onUnknow) =>
      currentTreeBranch.isEmpty ? onUnknow : currentTreeBranch.last;

  set route(GetPage? getPage) {
    if (getPage == null) return;
    if (currentTreeBranch.isEmpty) {
      currentTreeBranch.add(getPage);
    } else {
      currentTreeBranch[currentTreeBranch.length - 1] = getPage;
    }
  }

  List<GetPage>? get currentChildren => route?.children;

  Map<String, String> get parameters => pageSettings?.params ?? {};

  dynamic get args {
    return pageSettings?.arguments;
  }

  T? arguments<T>() {
    final args = pageSettings?.arguments;
    if (args is T) {
      return pageSettings?.arguments as T;
    } else {
      return null;
    }
  }

  // void replaceArguments(Object? arguments) {
  //   final newRoute = route;
  //   if (newRoute != null) {
  //     final index = currentTreeBranch.indexOf(newRoute);
  //     currentTreeBranch[index] = newRoute.copyWith(arguments: arguments);
  //   }
  // }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;

    return other is RouteDecoder &&
        listEquals(other.currentTreeBranch, currentTreeBranch) &&
        other.pageSettings == pageSettings;
  }

  @override
  int get hashCode => currentTreeBranch.hashCode ^ pageSettings.hashCode;

  @override
  String toString() =>
      'RouteDecoder(currentTreeBranch: $currentTreeBranch, pageSettings: $pageSettings)';
}

class ParseRouteTree {
  ParseRouteTree({
    required this.routes,
  });

  final List<GetPage> routes;

  RouteDecoder matchRoute(String name, {PageSettings? arguments}) {
    final uri = Uri.parse(name);
    final split = uri.path.split('/').where((element) => element.isNotEmpty);
    var curPath = '/';
    final cumulativePaths = <String>[
      '/',
    ];
    for (var item in split) {
      if (curPath.endsWith('/')) {
        curPath += item;
      } else {
        curPath += '/$item';
      }
      cumulativePaths.add(curPath);
    }

    final treeBranch = cumulativePaths
        .map((e) => MapEntry(e, _findRoute(e)))
        .where((element) => element.value != null)

        ///Prevent page be disposed
        .map((e) => MapEntry(e.key, e.value!.copyWith(key: ValueKey(e.key))))
        .toList();

    final params = Map<String, String>.from(uri.queryParameters);
    if (treeBranch.isNotEmpty) {
      //route is found, do further parsing to get nested query params
      final lastRoute = treeBranch.last;
      final parsedParams = _parseParams(name, lastRoute.value.path);
      if (parsedParams.isNotEmpty) {
        params.addAll(parsedParams);
      }
      //copy parameters to all pages.
      final mappedTreeBranch = treeBranch
          .map(
            (e) => e.value.copyWith(
              parameters: {
                if (e.value.parameters != null) ...e.value.parameters!,
                ...params,
              },
              name: e.key,
            ),
          )
          .toList();
      arguments?.params.clear();
      arguments?.params.addAll(params);
      return RouteDecoder(
        mappedTreeBranch,
        arguments,
      );
    }

    arguments?.params.clear();
    arguments?.params.addAll(params);

    //route not found
    return RouteDecoder(
      treeBranch.map((e) => e.value).toList(),
      arguments,
    );
  }

  void addRoutes<T>(List<GetPage<T>> getPages) {
    for (final route in getPages) {
      addRoute(route);
    }
  }

  void removeRoutes<T>(List<GetPage<T>> getPages) {
    for (final route in getPages) {
      removeRoute(route);
    }
  }

  void removeRoute<T>(GetPage<T> route) {
    routes.remove(route);
    for (var page in _flattenPage(route)) {
      removeRoute(page);
    }
  }

  void addRoute<T>(GetPage<T> route) {
    routes.add(route);

    // Add Page children.
    for (var page in _flattenPage(route)) {
      addRoute(page);
    }
  }

  List<GetPage> _flattenPage(GetPage route) {
    final result = <GetPage>[];
    if (route.children.isEmpty) {
      return result;
    }

    final parentPath = route.name;
    for (var page in route.children) {
      // Add Parent middlewares to children
      final parentMiddlewares = [
        if (page.middlewares.isNotEmpty) ...page.middlewares,
        if (route.middlewares.isNotEmpty) ...route.middlewares
      ];

      final parentBindings = [
        if (page.binding != null) page.binding!,
        if (page.bindings.isNotEmpty) ...page.bindings,
        if (route.bindings.isNotEmpty) ...route.bindings
      ];

      final parentBinds = [
        if (page.binds.isNotEmpty) ...page.binds,
        if (route.binds.isNotEmpty) ...route.binds
      ];

      result.add(
        _addChild(
          page,
          parentPath,
          parentMiddlewares,
          parentBindings,
          parentBinds,
        ),
      );

      final children = _flattenPage(page);
      for (var child in children) {
        result.add(_addChild(
          child,
          parentPath,
          [
            ...parentMiddlewares,
            if (child.middlewares.isNotEmpty) ...child.middlewares,
          ],
          [
            ...parentBindings,
            if (child.binding != null) child.binding!,
            if (child.bindings.isNotEmpty) ...child.bindings,
          ],
          [
            ...parentBinds,
            if (child.binds.isNotEmpty) ...child.binds,
          ],
        ));
      }
    }
    return result;
  }

  /// Change the Path for a [GetPage]
  GetPage _addChild(
    GetPage origin,
    String parentPath,
    List<GetMiddleware> middlewares,
    List<BindingsInterface> bindings,
    List<Bind> binds,
  ) {
    return origin.copyWith(
      middlewares: middlewares,
      name: origin.inheritParentPath
          ? (parentPath + origin.name).replaceAll(r'//', '/')
          : origin.name,
      bindings: bindings,
      binds: binds,
      // key:
    );
  }

  GetPage? _findRoute(String name) {
    final value = routes.firstWhereOrNull(
      (route) => route.path.regex.hasMatch(name),
    );

    return value;
  }

  Map<String, String> _parseParams(String path, PathDecoded routePath) {
    final params = <String, String>{};
    var idx = path.indexOf('?');
    final uri = Uri.tryParse(path);
    if (uri == null) return params;
    if (idx > -1) {
      params.addAll(uri.queryParameters);
    }
    var paramsMatch = routePath.regex.firstMatch(uri.path);
    if (paramsMatch == null) {
      return params;
    }
    for (var i = 0; i < routePath.keys.length; i++) {
      var param = Uri.decodeQueryComponent(paramsMatch[i + 1]!);
      params[routePath.keys[i]!] = param;
    }
    return params;
  }
}

extension FirstWhereOrNullExt<T> on List<T> {
  /// The first element satisfying [test], or `null` if there are none.
  T? firstWhereOrNull(bool Function(T element) test) {
    for (var element in this) {
      if (test(element)) return element;
    }
    return null;
  }
}


--- File: lib/get_navigation/src/routes/get_route.dart ---
// ignore_for_file: overridden_fields

import 'dart:async';

import 'package:flutter/cupertino.dart';
import 'package:flutter/foundation.dart';
import 'package:flutter/material.dart';

import '../../../get_instance/src/bindings_interface.dart';
import '../../../get_state_manager/src/simple/get_state.dart';
import '../../get_navigation.dart';

class GetPage<T> extends Page<T> {
  final GetPageBuilder page;
  final bool? popGesture;
  final Map<String, String>? parameters;
  final String? title;
  final Transition? transition;
  final Curve curve;
  final bool? participatesInRootNavigator;
  final Alignment? alignment;
  final bool maintainState;
  final bool opaque;
  final double Function(BuildContext context)? gestureWidth;
  final BindingsInterface? binding;
  final List<BindingsInterface> bindings;
  final List<Bind> binds;
  final CustomTransition? customTransition;
  final Duration? transitionDuration;
  final Duration? reverseTransitionDuration;
  final bool fullscreenDialog;
  final bool preventDuplicates;
  final Completer<T?>? completer;
  // @override
  // final LocalKey? key;

  // @override
  // RouteSettings get settings => this;

  @override
  final Object? arguments;

  @override
  final String name;

  final bool inheritParentPath;

  final List<GetPage> children;
  final List<GetMiddleware> middlewares;
  final PathDecoded path;
  final GetPage? unknownRoute;
  final bool showCupertinoParallax;

  final PreventDuplicateHandlingMode preventDuplicateHandlingMode;

  static void _defaultPopInvokedHandler(bool didPop, Object? result) {}

  GetPage({
    required this.name,
    required this.page,
    this.title,
    this.participatesInRootNavigator,
    this.gestureWidth,
    // RouteSettings settings,
    this.maintainState = true,
    this.curve = Curves.linear,
    this.alignment,
    this.parameters,
    this.opaque = true,
    this.transitionDuration,
    this.reverseTransitionDuration,
    this.popGesture,
    this.binding,
    this.bindings = const [],
    this.binds = const [],
    this.transition,
    this.customTransition,
    this.fullscreenDialog = false,
    this.children = const <GetPage>[],
    this.middlewares = const [],
    this.unknownRoute,
    this.arguments,
    this.showCupertinoParallax = true,
    this.preventDuplicates = true,
    this.preventDuplicateHandlingMode =
        PreventDuplicateHandlingMode.reorderRoutes,
    this.completer,
    this.inheritParentPath = true,
    LocalKey? key,
    super.canPop,
    super.onPopInvoked = _defaultPopInvokedHandler,
    super.restorationId,
  })  : path = _nameToRegex(name),
        assert(name.startsWith('/'),
            'It is necessary to start route name [$name] with a slash: /$name'),
        super(
          key: key ?? ValueKey(name),
          name: name,
          // arguments: Get.arguments,
        );
  // settings = RouteSettings(name: name, arguments: Get.arguments);

  GetPage<T> copyWith({
    LocalKey? key,
    String? name,
    GetPageBuilder? page,
    bool? popGesture,
    Map<String, String>? parameters,
    String? title,
    Transition? transition,
    Curve? curve,
    Alignment? alignment,
    bool? maintainState,
    bool? opaque,
    List<BindingsInterface>? bindings,
    BindingsInterface? binding,
    List<Bind>? binds,
    CustomTransition? customTransition,
    Duration? transitionDuration,
    Duration? reverseTransitionDuration,
    bool? fullscreenDialog,
    RouteSettings? settings,
    List<GetPage<T>>? children,
    GetPage? unknownRoute,
    List<GetMiddleware>? middlewares,
    bool? preventDuplicates,
    final double Function(BuildContext context)? gestureWidth,
    bool? participatesInRootNavigator,
    Object? arguments,
    bool? showCupertinoParallax,
    Completer<T?>? completer,
    bool? inheritParentPath,
    bool? canPop,
    PopInvokedWithResultCallback<T>? onPopInvoked,
    String? restorationId,
  }) {
    return GetPage(
      key: key ?? this.key,
      participatesInRootNavigator:
          participatesInRootNavigator ?? this.participatesInRootNavigator,
      preventDuplicates: preventDuplicates ?? this.preventDuplicates,
      name: name ?? this.name,
      page: page ?? this.page,
      popGesture: popGesture ?? this.popGesture,
      parameters: parameters ?? this.parameters,
      title: title ?? this.title,
      transition: transition ?? this.transition,
      curve: curve ?? this.curve,
      alignment: alignment ?? this.alignment,
      maintainState: maintainState ?? this.maintainState,
      opaque: opaque ?? this.opaque,
      bindings: bindings ?? this.bindings,
      binds: binds ?? this.binds,
      binding: binding ?? this.binding,
      customTransition: customTransition ?? this.customTransition,
      transitionDuration: transitionDuration ?? this.transitionDuration,
      reverseTransitionDuration:
          reverseTransitionDuration ?? this.reverseTransitionDuration,
      fullscreenDialog: fullscreenDialog ?? this.fullscreenDialog,
      children: children ?? this.children,
      unknownRoute: unknownRoute ?? this.unknownRoute,
      middlewares: middlewares ?? this.middlewares,
      gestureWidth: gestureWidth ?? this.gestureWidth,
      arguments: arguments ?? this.arguments,
      showCupertinoParallax:
          showCupertinoParallax ?? this.showCupertinoParallax,
      completer: completer ?? this.completer,
      inheritParentPath: inheritParentPath ?? this.inheritParentPath,
      canPop: canPop ?? this.canPop,
      onPopInvoked: onPopInvoked ?? this.onPopInvoked,
      restorationId: restorationId ?? restorationId,
    );
  }

  @override
  Route<T> createRoute(BuildContext context) {
    // return GetPageRoute<T>(settings: this, page: page);
    final page = PageRedirect(
      route: this,
      settings: this,
      unknownRoute: unknownRoute,
    ).getPageToRoute<T>(this, unknownRoute, context);

    return page;
  }

  static PathDecoded _nameToRegex(String path) {
    var keys = <String?>[];

    String recursiveReplace(Match pattern) {
      var buffer = StringBuffer('(?:');

      if (pattern[1] != null) buffer.write('.');
      buffer.write('([\\w%+-._~!\$&\'()*,;=:@]+))');
      if (pattern[3] != null) buffer.write('?');

      keys.add(pattern[2]);
      return "$buffer";
    }

    var stringPath = '$path/?'
        .replaceAllMapped(RegExp(r'(\.)?:(\w+)(\?)?'), recursiveReplace)
        .replaceAll('//', '/');

    return PathDecoded(RegExp('^$stringPath\$'), keys);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    return other is GetPage<T> && other.key == key;
  }

  @override
  String toString() =>
      '${objectRuntimeType(this, 'Page')}("$name", $key, $arguments)';

  @override
  int get hashCode {
    return key.hashCode;
  }
}

@immutable
class PathDecoded {
  final RegExp regex;
  final List<String?> keys;
  const PathDecoded(this.regex, this.keys);

  @override
  int get hashCode => regex.hashCode;

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;

    return other is PathDecoded &&
        other.regex == regex; // && listEquals(other.keys, keys);
  }
}


Instructions for the chapter (Generate content in English unless specified otherwise):
- Start with a clear heading (e.g., `# Chapter 3: GetPage & GetRouterDelegate
`). Use the provided concept name.

- If this is not the first chapter, begin with a brief transition from the previous chapter, referencing it with a proper Markdown link using its name.

- Begin with a high-level motivation explaining what problem this abstraction solves. Start with a central use case as a concrete example. The whole chapter should guide the reader to understand how to solve this use case. Make it very minimal and friendly to beginners.

- If the abstraction is complex, break it down into key concepts. Explain each concept one-by-one in a very beginner-friendly way.

- Explain how to use this abstraction to solve the use case. Give example inputs and outputs for code snippets (if the output isn't values, describe at a high level what will happen).

- Each code block should be BELOW 10 lines! If longer code blocks are needed, break them down into smaller pieces and walk through them one-by-one. Aggresively simplify the code to make it minimal. Use comments to skip non-important implementation details. Each code block should have a beginner friendly explanation right after it.

- Describe the internal implementation to help understand what's under the hood. First provide a non-code or code-light walkthrough on what happens step-by-step when the abstraction is called. It's recommended to use a simple sequenceDiagram with a dummy example - keep it minimal with at most 5 participants to ensure clarity. If participant name has space, use: `participant QP as Query Processing`. .

- Then dive deeper into code for the internal implementation with references to files. Provide example code blocks, but make them similarly simple and beginner-friendly. Explain.

- IMPORTANT: When you need to refer to other core abstractions covered in other chapters, ALWAYS use proper Markdown links like this: [Chapter Title](filename.md). Use the Complete Tutorial Structure above to find the correct filename and the chapter title. Translate the surrounding text.

- Use mermaid diagrams to illustrate complex concepts (```mermaid``` format). .

- Heavily use analogies and examples throughout to help beginners understand.

- End the chapter with a brief conclusion that summarizes what was learned and provides a transition to the next chapter. If there is a next chapter, use a proper Markdown link: [Next Chapter Title](next_chapter_filename).

- Ensure the tone is welcoming and easy for a newcomer to understand.

- Output *only* the Markdown content for this chapter.

Now, directly provide a super beginner-friendly Markdown output (DON'T need ```markdown``` tags):

2025-05-16 11:08:05,790 - INFO - RESPONSE: # Chapter 3: GetPage & GetRouterDelegate

In [Chapter 2: GetNavigation Extensions (e.g., Get.toNamed, Get.snackbar)](02_getnavigation_extensions__e_g___get_tonamed__get_snackbar__.md), we saw how easy GetX makes navigating between screens using methods like `Get.to()` and `Get.toNamed()`. We even had a sneak peek at defining named routes. Now, let's dive deeper into how GetX manages these routes in a more structured and powerful way using `GetPage` and `GetRouterDelegate`. These are the tools that make GetX's navigation so robust, especially for larger apps!

## The Need for Structure: Why Bother?

Imagine you're designing a website with many pages: a homepage, an about page, a contact page, a profile page, and so on. If you just linked them haphazardly, it would quickly become a mess. You'd want a clear sitemap and well-defined URLs for each page.

Similarly, in a Flutter app, as it grows, just calling `Get.to(() => MyScreen())` everywhere can become hard to manage. What if you want to change the transition animation for a specific screen? Or pass data to it in a standardized way? Or manage deep linking (opening specific app screens from a web link)?

This is where `GetPage` and `GetRouterDelegate` come in. They help you:
1.  **Define all your app's screens (routes) in one central place.**
2.  **Give each screen a unique name (like a URL).**
3.  **Configure special behaviors for each screen (like transitions or data bindings).**
4.  **Power Flutter's modern Navigator 2.0 system within GetX, allowing for more complex navigation scenarios.**

Let's meet the stars!

## Meet the Blueprint: `GetPage`

Think of `GetPage` as a **blueprint for a screen** in your app. It's not the screen itself, but rather a detailed description of it. Each `GetPage` tells GetX:
*   `name`: The unique "URL" or path for this screen (e.g., `/home`, `/profile`, `/settings/notifications`). This is what you use with `Get.toNamed()`.
*   `page`: A function that tells GetX *how to build* the actual widget for this screen when it's needed.
*   `binding` (optional): A way to set up controllers or other dependencies specifically for this screen. (We'll explore bindings more in GetX state management).
*   `transition` (optional): How the screen animates in and out. (More on this in [Transition System (GetPageRouteTransitionMixin, CustomTransition, Transitions)](07_transition_system__getpageroutetransitionmixin__customtransition__transitions__.md)).
*   `middlewares` (optional): Special functions that can run before a page is shown, perhaps to check if a user is logged in. (Covered in [GetMiddleware](06_getmiddleware_.md)).

Let's define a couple of simple `GetPage` blueprints:

```dart
// main.dart (or a separate routes file)
import 'package:flutter/material.dart';
import 'package:get/get.dart'; // Import GetX

// Assume HomeScreen and ProfileScreen widgets are defined elsewhere
// For example:
// class HomeScreen extends StatelessWidget { /* ... */ }
// class ProfileScreen extends StatelessWidget { /* ... */ }

final List<GetPage> appPages = [
  GetPage(
    name: '/home', // The unique name for the home screen
    page: () => HomeScreen(), // How to build the HomeScreen
  ),
  GetPage(
    name: '/profile', // The unique name for the profile screen
    page: () => ProfileScreen(), // How to build the ProfileScreen
    // transition: Transition.rightToLeft, // Optional: a nice slide animation
  ),
];
```
In this snippet, `appPages` is a list holding the blueprints for our `HomeScreen` and `ProfileScreen`. We've given each a unique `name` and a `page` function.

## Meet the Captain: `GetRouterDelegate`

If `GetPage` is the blueprint, then `GetRouterDelegate` is the **captain of your app's navigation ship**. It's the core engine that powers Flutter's modern Navigator 2.0 system within GetX.

You usually won't interact with `GetRouterDelegate` directly in simple apps. When you provide your list of `GetPage` blueprints to `GetMaterialApp` (as we'll see next), GetX sets up a `GetRouterDelegate` for you behind the scenes.

This "captain" is responsible for:
*   Taking your `GetPage` blueprints.
*   Managing the actual stack of screens (what's visible, what's underneath).
*   Deciding which page is currently visible based on the URL or navigation actions.
*   Handling how to go to new pages (`Get.toNamed()`).
*   Handling how to go back (`Get.back()`).

Think of it like an air traffic controller for your app's screens. It knows all the available "runways" (`GetPage`s) and directs the "planes" (your users' navigation actions) to the correct one smoothly.

## Putting It Together: Defining Routes in `GetMaterialApp`

Now, how do we tell our GetX app about these `GetPage` blueprints so the `GetRouterDelegate` can use them? We pass our list of `GetPage`s to the `getPages` property of `GetMaterialApp` (or `GetCupertinoApp`).

Let's update our `main.dart` from Chapter 2:

```dart
// main.dart
import 'package:flutter/material.dart';
import 'package:get/get.dart';

// Let's define our screens quickly for this example
class HomeScreen extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(title: Text('Home')),
      body: Center(
        child: ElevatedButton(
          onPressed: () => Get.toNamed('/profile'), // Navigate to profile
          child: Text('Go to Profile'),
        ),
      ),
    );
  }
}

class ProfileScreen extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(title: Text('Profile')),
      body: Center(child: Text('This is your Profile!')),
    );
  }
}

// Our GetPage blueprints
final List<GetPage> appPages = [
  GetPage(name: '/home', page: () => HomeScreen()),
  GetPage(name: '/profile', page: () => ProfileScreen()),
];

void main() {
  runApp(MyApp());
}

class MyApp extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return GetMaterialApp(
      title: 'GetX Named Routes',
      initialRoute: '/home', // Start at the home screen
      getPages: appPages,   // <-- Here's where we provide our blueprints!
    );
  }
}
```
By providing `appPages` to `GetMaterialApp`, we've done two things:
1.  Registered our `/home` and `/profile` routes.
2.  Enabled `GetMaterialApp` to use its internal `GetRouterDelegate` to manage navigation based on these named routes.

Now, `Get.toNamed('/profile')` from `HomeScreen` will correctly navigate to `ProfileScreen` because the `GetRouterDelegate` (set up by `GetMaterialApp`) knows about the `/profile` blueprint.

## How Does It Work Under the Hood?

When you use `getPages` with `GetMaterialApp`, GetX sets up a more sophisticated navigation system. Here's a simplified step-by-step:

1.  **Setup**: When `GetMaterialApp` starts, it sees you've provided `getPages`. It then creates and configures a `GetRouterDelegate` (specifically, an instance of `GetDelegate` from `lib/get_navigation/src/routes/get_router_delegate.dart`). This delegate is given your list of `GetPage` blueprints.
2.  **Navigation Trigger**: You call `Get.toNamed('/profile')`.
3.  **Delegate at Work**: The `Get.toNamed` call, in this Navigator 2.0 setup, ultimately informs the `GetRouterDelegate`.
4.  **Route Matching**: The `GetRouterDelegate` consults its list of `GetPage`s. It uses a helper, often `ParseRouteTree` (from `lib/get_navigation/src/routes/parse_route.dart`), to find the `GetPage` whose `name` matches `/profile`. We'll explore `ParseRouteTree` more in [Route Parsing & Configuration (RouteDecoder, PageSettings, ParseRouteTree)](05_route_parsing___configuration__routedecoder__pagesettings__parseroutetree__.md).
5.  **Screen Creation**: Once the matching `GetPage` blueprint is found, the `GetRouterDelegate` uses its `page: () => ProfileScreen()` function to create an instance of `ProfileScreen`.
6.  **Stack Update**: The `GetRouterDelegate` then updates Flutter's navigation stack to display this new `ProfileScreen`.

Here's a visual:

```mermaid
sequenceDiagram
    participant UserAction as User Taps Button
    participant GetToNamed as Get.toNamed("/profile")
    participant GMA as GetMaterialApp (internally)
    participant GRD as GetRouterDelegate
    participant FlutterNav as Flutter Navigator

    UserAction->>GetToNamed: Invokes navigation for "/profile"
    GetToNamed->>GMA: Signals intent (simplified)
    GMA->>GRD: Relays "/profile" to its delegate
    GRD->>GRD: Finds GetPage(name: "/profile") in its list (getPages)
    GRD->>GRD: Calls page() function from GetPage
    GRD->>FlutterNav: "Push this new screen (ProfileScreen)"
    FlutterNav->>UserAction: ProfileScreen is displayed
```

Inside `GetMaterialApp` (or more accurately, `GetMaterialApp.router` which is used when `getPages` is provided), it sets up like this:

```dart
// Simplified concept from GetMaterialApp when getPages is used
// return GetMaterialApp.router(
//   routeInformationParser: GetInformationParser(...), // Handles URL parsing
//   routerDelegate: GetDelegate(pages: getPages, ...), // Our captain!
// );
```
The `GetDelegate` (our `GetRouterDelegate` implementation) receives your `pages` (your `GetPage` list).

Then, `GetDelegate`'s `build` method uses these pages to construct the `Navigator`:

```dart
// Simplified from lib/get_navigation/src/routes/get_router_delegate.dart
// Inside GetDelegate's build method:

// final currentHistory = currentConfiguration;
// final pages = /* ... logic to get current visible GetPage(s) based on URL ... */
//    getVisualPages(currentHistory).toList();

// return GetNavigator(
//   key: navigatorKey,
//   onPopPage: _onPopVisualRoute, // Handles back button for these pages
//   pages: pages, // The actual Flutter Page objects derived from your GetPages
//   // ... other navigator configurations
// );
```
The `pages` list here are Flutter `Page` objects, which `GetDelegate` creates based on your `GetPage` definitions and the current navigation state.

So, by using `GetPage` and `getPages`, you're tapping into this powerful, Navigator 2.0-based routing managed by `GetRouterDelegate`.

## Why This Approach?

*   **Centralized Route Definitions**: All your main navigation paths are clearly defined in one place.
*   **Named Navigation Power**: Makes `Get.toNamed()` very robust.
*   **Decoupling**: Your UI code just says "go to `/profile`"; it doesn't need to know *how* `ProfileScreen` is built or what its specific dependencies are.
*   **Advanced Scenarios**: This structure is the foundation for more complex features like:
    *   Nested navigation (routes within routes).
    *   Guards/Middlewares (e.g., checking login status before accessing a route, covered in [GetMiddleware](06_getmiddleware_.md)).
    *   Custom transitions per route (see [Transition System (GetPageRouteTransitionMixin, CustomTransition, Transitions)](07_transition_system__getpageroutetransitionmixin__customtransition__transitions__.md)).
    *   Better web URL handling.

## Conclusion

You've now learned about `GetPage`, the blueprint for your screens, and `GetRouterDelegate`, the captain that manages navigation using these blueprints. By defining your routes using `GetPage` and providing them to `GetMaterialApp` via the `getPages` property, you unlock a more structured, powerful, and maintainable way to handle navigation in your GetX applications. This setup is what allows GetX to seamlessly integrate with Flutter's Navigator 2.0 system, giving you fine-grained control while keeping things simple.

While `GetRouterDelegate` works largely behind the scenes for many common use cases, understanding its role helps you appreciate the robustness of GetX navigation.

Next up, we'll explore how GetX makes it incredibly easy to show common UI overlays like Snackbars, Dialogs, and BottomSheets, often without needing `BuildContext` at all! Let's head to [Overlay Management (Snackbar, Dialog, BottomSheet)](04_overlay_management__snackbar__dialog__bottomsheet__.md).
2025-05-16 11:08:05,874 - INFO - PROMPT: 
Write a very beginner-friendly tutorial chapter (in Markdown format) for the project `getx` about the concept: "Overlay Management (Snackbar, Dialog, BottomSheet)
". This is Chapter 4.

Concept Details:
- Name: Overlay Management (Snackbar, Dialog, BottomSheet)

- Description:
This refers to the system for displaying temporary, non-page UI elements like snackbars, dialogs, and bottom sheets. `SnackbarController` specifically manages the lifecycle and queue of snackbars. Dialogs and BottomSheets are presented using custom `PopupRoute` implementations (`GetDialogRoute`, `GetModalBottomSheetRoute`).
Imagine a concierge service in a hotel. You can ask them to deliver a quick note (snackbar), arrange a meeting in a private room (dialog), or pull up a special information panel from below (bottom sheet), all without changing your main location (current page).


Complete Tutorial Structure:
1. [GetMaterialApp / GetCupertinoApp & GetRoot
](01_getmaterialapp___getcupertinoapp___getroot_.md)
2. [GetNavigation Extensions (e.g., Get.toNamed, Get.snackbar)
](02_getnavigation_extensions__e_g___get_tonamed__get_snackbar__.md)
3. [GetPage & GetRouterDelegate
](03_getpage___getrouterdelegate_.md)
4. [Overlay Management (Snackbar, Dialog, BottomSheet)
](04_overlay_management__snackbar__dialog__bottomsheet__.md)
5. [Route Parsing & Configuration (RouteDecoder, PageSettings, ParseRouteTree)
](05_route_parsing___configuration__routedecoder__pagesettings__parseroutetree__.md)
6. [GetMiddleware
](06_getmiddleware_.md)
7. [Transition System (GetPageRouteTransitionMixin, CustomTransition, Transitions)
](07_transition_system__getpageroutetransitionmixin__customtransition__transitions__.md)
8. [RouterReportManager
](08_routerreportmanager_.md)

Context from previous chapters:
# Chapter 1: GetMaterialApp / GetCupertinoApp & GetRoot

Welcome to your GetX journey! This is the very first step into a powerful and easy-to-use Flutter framework. In this chapter, we'll explore the foundational building blocks of any GetX application: `GetMaterialApp`, `GetCupertinoApp`, and the unsung hero, `GetRoot`.

## What's the Big Deal? Setting Up Your GetX App

Imagine you're building a house. Before you can add rooms, furniture, or even think about painting the walls, you need a solid foundation and the main structure, right? In a Flutter app using GetX, `GetMaterialApp` or `GetCupertinoApp` are like choosing the architectural style of your house (Material Design for Android-style or Cupertino for iOS-style), and they lay this essential groundwork.

Flutter apps usually start with `MaterialApp` (for Material Design) or `CupertinoApp` (for iOS-style design). GetX provides its own versions:

*   `GetMaterialApp`
*   `GetCupertinoApp`

Why use these instead of the standard Flutter ones? Because they do something crucial: **they initialize the GetX framework**. This "initialization" means they set up all the cool things GetX offers, like super-easy navigation, smart state management, and simple internationalization (showing your app in different languages).

Think of it like this: standard `MaterialApp` gives you a basic house blueprint. `GetMaterialApp` gives you that same blueprint but also installs the main electrical panel, plumbing system, and a smart home hub, all ready for you to use GetX features without extra setup.

## Meet the Stars of the Show

Let's break down these key components:

### 1. `GetMaterialApp` (for Material Design lovers)

If you're building an app that follows Google's Material Design guidelines (common for Android apps, but also widely used for cross-platform apps), you'll use `GetMaterialApp`. It's a direct replacement for Flutter's `MaterialApp`. By using it, you're telling your app, "Hey, I want to use GetX features!"

```dart
// main.dart
import 'package:flutter/material.dart';
import 'package:get/get.dart'; // Don't forget to import GetX!

void main() {
  runApp(MyApp());
}

class MyApp extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return GetMaterialApp( // <-- See? We use GetMaterialApp here!
      title: 'My First GetX App',
      home: MyHomePage(),
    );
  }
}

class MyHomePage extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(title: Text('GetX is Awesome!')),
      body: Center(child: Text('Hello, GetX World!')),
    );
  }
}
```
In this very simple app, just by changing `MaterialApp` to `GetMaterialApp`, we've unlocked the potential to use all of GetX's powerful features throughout our `MyApp`.

### 2. `GetCupertinoApp` (for iOS aficionados)

If you're aiming for an app that looks and feels like a native iOS application, you'll use `GetCupertinoApp`. It's the GetX equivalent of Flutter's `CupertinoApp`.

```dart
// main.dart
import 'package:flutter/cupertino.dart';
import 'package:get/get.dart'; // Import GetX

void main() {
  runApp(MyApp());
}

class MyApp extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return GetCupertinoApp( // <-- Using GetCupertinoApp for iOS style
      title: 'My First GetX iOS App',
      home: MyHomePage(),
    );
  }
}

class MyHomePage extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return CupertinoPageScaffold(
      navigationBar: CupertinoNavigationBar(
        middle: Text('Hello, GetX (iOS Style)!'),
      ),
      child: Center(child: Text('GetX on Cupertino!')),
    );
  }
}
```
Similar to `GetMaterialApp`, using `GetCupertinoApp` sets up your app for GetX functionalities but with an iOS-style foundation.

### 3. `GetRoot`: The Engine Under the Hood

You might not ever type `GetRoot` directly in your code, but it's super important to know it exists. `GetRoot` is the core widget that both `GetMaterialApp` and `GetCupertinoApp` use internally.

Think of `GetRoot` as the main power supply and central control panel for the GetX system in your app. It's responsible for:
*   Managing global configurations.
*   Setting up the routing system that GetX uses for navigation.
*   Initializing dependency management.
*   Handling internationalization settings (like current language).

So, when you use `GetMaterialApp` or `GetCupertinoApp`, they are essentially putting a `GetRoot` widget at the very top of your application's widget tree. This makes all the GetX features available to every part of your app.

## How Does It Work? A Peek Inside

You don't need to know the intricate details to use GetX effectively, but a little insight can be helpful!

1.  **You start your app:** You use `GetMaterialApp` (or `GetCupertinoApp`) as the root widget in your `main.dart` file.
2.  **`GetMaterialApp` takes charge:** When `GetMaterialApp` is built, its main job is to create and configure a `GetRoot` widget. It passes along all your app's configurations (like themes, initial routes, translations, etc.) to `GetRoot`.
3.  **`GetRoot` powers up:** `GetRoot` receives these configurations and initializes the entire GetX ecosystem. It sets up internal controllers, listeners for things like language changes, and provides the necessary context for GetX features to work.
4.  **Your app is ready!** With `GetRoot` in place, all other GetX functionalities (like `Get.to()` for navigation, `Get.put()` for dependency injection, `Get.snackbar()` for messages) can now find the necessary GetX infrastructure and work their magic.

Let's visualize this flow:

```mermaid
sequenceDiagram
    participant UserApp as main.dart
    participant GMA as GetMaterialApp
    participant GR as GetRoot
    participant GetXCore as GetX Core System

    UserApp->>GMA: Uses GetMaterialApp/GetCupertinoApp
    GMA->>GR: Wraps its child with GetRoot, passing configurations
    GR->>GetXCore: Initializes GetX services (routing, DI, locale)
    GMA->>UserApp: Renders app with GetX features enabled
```

**A Tiny Glimpse into the Code:**

You won't usually need to touch this code, but it helps to see it.

Here's a simplified look at what `GetMaterialApp` does in its `build` method (from `lib/get_navigation/src/root/get_material_app.dart`):

```dart
// Inside GetMaterialApp's build method
@override
Widget build(BuildContext context) {
  return GetRoot( // Notice! It returns a GetRoot widget.
    config: ConfigData( // Bundles up all configurations
      // ... like home, getPages, locale, theme ...
      home: home,
      getPages: getPages,
      locale: locale,
      theme: theme,
      // ... and many other settings you provide ...
    ),
    child: Builder(builder: (context) {
      // This inner part builds the actual MaterialApp,
      // now empowered by GetRoot and its configurations.
      final controller = GetRoot.of(context);
      return MaterialApp.router( /* ... uses controller.config ... */ );
    }),
  );
}
```
This code shows that `GetMaterialApp` essentially sets up `GetRoot` with all your app's settings. `GetRoot` then takes care of the nitty-gritty GetX initialization.

And here's a very simplified idea of what `GetRoot` does when it starts (from `lib/get_navigation/src/root/get_root.dart`):

```dart
// Inside GetRootState's initState method
@override
void initState() {
  config = widget.config; // Receives config from GetMaterialApp/GetCupertinoApp
  // ... other setup ...
  onInit(); // Calls a special GetX initialization method
  super.initState();
}

void onInit() {
  // Example: Sets up the current language (locale) for your app
  if (config.locale != null) Get.locale = config.locale;

  // Example: Initializes translations if you provide them
  if (config.translations != null) {
    Get.addTranslations(config.translations!.keys);
  }
  // ... and much more initialization for routing, logging, etc. ...
}
```
This `onInit()` method within `GetRoot` is where a lot of the GetX magic gets set up based on the properties you pass to `GetMaterialApp` or `GetCupertinoApp`.

## Why Bother? The Benefits

*   **Simplicity:** You just swap `MaterialApp` with `GetMaterialApp` (or `CupertinoApp` with `GetCupertinoApp`), and you're ready to use GetX. No complex setup rituals!
*   **Power:** This simple change unlocks a vast array of features:
    *   Effortless route management (covered in [GetNavigation Extensions (e.g., Get.toNamed, Get.snackbar)](02_getnavigation_extensions__e_g___get_tonamed__get_snackbar__.md) and [GetPage & GetRouterDelegate](03_getpage___getrouterdelegate__.md)).
    *   Simple state management.
    *   Easy dependency injection.
    *   Built-in internationalization.
    *   Dialogs, Snackbars, and BottomSheets without `context` (see [Overlay Management (Snackbar, Dialog, BottomSheet)](04_overlay_management__snackbar__dialog__bottomsheet__.md)).
*   **Performance:** GetX is designed to be lightweight and performant.

## Conclusion

You've just learned about the most fundamental step in building a GetX application: using `GetMaterialApp` or `GetCupertinoApp`. These widgets, powered by the underlying `GetRoot`, are your gateway to the GetX ecosystem. They seamlessly initialize everything you need, allowing you to focus on building amazing features rather than wrestling with boilerplate setup.

With this foundation laid, you're now ready to explore one of the most beloved features of GetX: its incredibly simple and powerful navigation system.

Ready to learn how to move between screens with ease? Let's dive into the [GetNavigation Extensions (e.g., Get.toNamed, Get.snackbar)](02_getnavigation_extensions__e_g___get_tonamed__get_snackbar__.md)!
---
# Chapter 2: GetNavigation Extensions (e.g., Get.toNamed, Get.snackbar)

Welcome back! In [Chapter 1: GetMaterialApp / GetCupertinoApp & GetRoot](01_getmaterialapp___getcupertinoapp___getroot_.md), we learned how to set up the foundation of our GetX app using `GetMaterialApp` or `GetCupertinoApp`. This simple step unlocked a world of powerful GetX features. Now, let's explore one of the most loved features: making navigation and showing pop-ups incredibly easy!

## The Old Way vs. The GetX Way

Imagine you're in your app, perhaps inside a settings page, and you want to navigate to a user profile page after a button tap. In standard Flutter, you'd typically need `BuildContext` to do this:

```dart
// Standard Flutter (needs context)
Navigator.push(context, MaterialPageRoute(builder: (context) => ProfileScreen()));
```

What if your button's logic is inside a separate class, like a ViewModel or a Controller, that doesn't have direct access to `BuildContext`? Passing `BuildContext` around can make your code a bit messy.

This is where GetX shines! GetX provides **GetNavigation Extensions**. These are convenient shortcut methods attached to the `Get` interface (think of `Get` as your GetX toolkit). They allow you to navigate or show UI elements like dialogs, snackbars, and bottom sheets from *anywhere* in your code without needing a `BuildContext`.

Think of it as a **universal remote control** for your app's navigation and common UI pop-ups. Instead of finding the specific local remote (`BuildContext`) for the TV in a room, you use one master remote (`Get`) to control any TV (navigation, dialog) in the house.

## Your Universal Remote: Meet `Get`

The `Get` object is your central access point for many GetX features. When you see `Get.something()`, you're using one of these handy extensions.

Let's see how this "universal remote" works for common tasks.

### 1. Navigating to a New Screen: `Get.to()`

Want to go to a new screen? Just use `Get.to()` and tell it which screen (widget) to build.

**Use Case:** Let's say we have a `HomeScreen` and we want to navigate to a `DetailScreen`.

First, your `main.dart` should be set up with `GetMaterialApp` (as learned in Chapter 1):

```dart
// main.dart
import 'package:flutter/material.dart';
import 'package:get/get.dart';
import 'home_screen.dart'; // We'll create this next

void main() {
  runApp(MyApp());
}

class MyApp extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return GetMaterialApp( // Using GetMaterialApp
      title: 'GetX Navigation',
      home: HomeScreen(),
    );
  }
}
```
This setup is crucial because `GetMaterialApp` prepares GetX for context-less navigation.

Now, let's create `HomeScreen` and `DetailScreen`:

```dart
// home_screen.dart
import 'package:flutter/material.dart';
import 'package:get/get.dart';
import 'detail_screen.dart'; // We'll create this

class HomeScreen extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(title: Text('Home')),
      body: Center(
        child: ElevatedButton(
          onPressed: () {
            // Look, no context needed!
            Get.to(() => DetailScreen());
          },
          child: Text('Go to Details'),
        ),
      ),
    );
  }
}
```
In `HomeScreen`, when the button is pressed, `Get.to(() => DetailScreen())` is called. This tells GetX to push `DetailScreen` onto the navigation stack.

```dart
// detail_screen.dart
import 'package:flutter/material.dart';

class DetailScreen extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(title: Text('Details')),
      body: Center(child: Text('This is the Detail Screen!')),
    );
  }
}
```
`DetailScreen` is just a simple page. When you tap the button on `HomeScreen`, you'll navigate to `DetailScreen`.

**What happened?**
`Get.to(() => DetailScreen())` pushed a new route displaying `DetailScreen` onto the navigation stack. The `() => DetailScreen()` part is a function that creates your new screen.

### 2. Navigating with Named Routes: `Get.toNamed()`

Sometimes, you prefer to navigate using names instead of creating widget instances directly. This is great for clean code and is essential for web routing. GetX makes this super easy with `Get.toNamed()`.

First, you need to define your named routes in `GetMaterialApp` using the `getPages` property. We'll dive deeper into `getPages` in [GetPage & GetRouterDelegate](03_getpage___getrouterdelegate__.md), but here's a sneak peek:

```dart
// main.dart (updated)
import 'package:flutter/material.dart';
import 'package:get/get.dart';
import 'home_screen.dart';
import 'detail_screen.dart'; // Import DetailScreen

void main() {
  runApp(MyApp());
}

class MyApp extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return GetMaterialApp(
      title: 'GetX Named Navigation',
      initialRoute: '/home', // Optional: set an initial route
      getPages: [
        GetPage(name: '/home', page: () => HomeScreen()),
        GetPage(name: '/detail', page: () => DetailScreen()),
      ],
    );
  }
}
```
We've defined two routes: `/home` pointing to `HomeScreen` and `/detail` pointing to `DetailScreen`.

Now, in your `HomeScreen`, you can navigate using the name:

```dart
// home_screen.dart (updated for named route)
// ... (imports remain the same)
class HomeScreen extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(title: Text('Home')),
      body: Center(
        child: ElevatedButton(
          onPressed: () {
            Get.toNamed('/detail'); // Navigate by name!
          },
          child: Text('Go to Details (Named)'),
        ),
      ),
    );
  }
}
```
When you tap the button, `Get.toNamed('/detail')` looks up the '/detail' route you defined in `getPages` and navigates to `DetailScreen`.

### 3. Going Back: `Get.back()`

To go back to the previous screen, it's as simple as:

```dart
// Inside DetailScreen, for example
ElevatedButton(
  onPressed: () {
    Get.back(); // Go back to HomeScreen
  },
  child: Text('Go Back'),
)
```
`Get.back()` pops the current screen from the navigation stack, just like Flutter's `Navigator.pop(context)`.

### 4. Showing a Quick Message: `Get.snackbar()`

Need to show a quick notification or message (a "snackbar")? GetX has you covered, again, without needing `BuildContext`.

```dart
// In any button's onPressed, or anywhere else:
ElevatedButton(
  onPressed: () {
    Get.snackbar(
      "Success!", // Title
      "Your action was completed.", // Message
      snackPosition: SnackPosition.BOTTOM, // Optional: position
    );
  },
  child: Text('Show Snackbar'),
)
```
This will display a sleek snackbar at the bottom (or top, depending on `snackPosition`) of your screen. It's that easy! We'll explore snackbars in more detail in [Overlay Management (Snackbar, Dialog, BottomSheet)](04_overlay_management__snackbar__dialog__bottomsheet__.md).

### 5. A Peek at Dialogs and Bottom Sheets

GetX also simplifies showing dialogs and bottom sheets without `BuildContext`.

*   **Dialogs with `Get.dialog()`**:
    ```dart
    // Example: Show a simple dialog
    Get.dialog(
      AlertDialog(
        title: Text('Alert!'),
        content: Text('This is a GetX dialog.'),
        actions: [TextButton(onPressed: () => Get.back(), child: Text('OK'))],
      )
    );
    ```

*   **Bottom Sheets with `Get.bottomSheet()`**:
    ```dart
    // Example: Show a simple bottom sheet
    Get.bottomSheet(
      Container(
        height: 200,
        color: Colors.white,
        child: Center(child: Text('This is a GetX bottom sheet!')),
      )
    );
    ```
These are very powerful, and you'll learn all about customizing them in [Overlay Management (Snackbar, Dialog, BottomSheet)](04_overlay_management__snackbar__dialog__bottomsheet__.md). For now, just know they exist and are super easy to call!

## How Does This Magic Work? Under the Hood

You might be wondering: "If I'm not giving it `BuildContext`, how does `Get.toNamed()` or `Get.snackbar()` know where to navigate or show the message?"

It's thanks to the setup we did in [Chapter 1: GetMaterialApp / GetCupertinoApp & GetRoot](01_getmaterialapp___getcupertinoapp___getroot_.md)!

1.  **The Foundation**: When you use `GetMaterialApp` (or `GetCupertinoApp`), it internally creates and configures a `GetRoot` widget. This `GetRoot` widget holds a global `NavigatorKey`. Think of this key as a direct phone line to Flutter's navigation system. It also manages an `OverlayKey` for things like snackbars and dialogs.

2.  **The Call**: When you call something like `Get.toNamed('/detail')`, the static `Get` interface uses this globally available `NavigatorKey` (managed by `GetRootController`) to access the current `NavigatorState`.

3.  **The Action**: Once it has the `NavigatorState`, it can then call the standard Flutter methods like `navigatorState.pushNamed('/detail')` or `navigatorState.push(MaterialPageRoute(...))`.

For snackbars, dialogs, and bottom sheets, `Get` uses a similar mechanism to access the `OverlayState` (via `Get.overlayContext`) to display these UI elements on top of your current screen.

Here's a simplified flow:

```mermaid
sequenceDiagram
    participant YourWidget as Your Widget (e.g., Button)
    participant GetStatic as Get (Static Interface)
    participant GetRootCtrl as GetRoot Controller (from GetMaterialApp)
    participant FlutterNavigator as Flutter Navigator/Overlay

    YourWidget->>GetStatic: Calls Get.toNamed("/details") or Get.snackbar(...)
    GetStatic->>GetRootCtrl: Accesses root NavigatorKey or OverlayContext
    GetRootCt<ctrl63>
---
# Chapter 3: GetPage & GetRouterDelegate

In [Chapter 2: GetNavigation Extensions (e.g., Get.toNamed, Get.snackbar)](02_getnavigation_extensions__e_g___get_tonamed__get_snackbar__.md), we saw how easy GetX makes navigating between screens using methods like `Get.to()` and `Get.toNamed()`. We even had a sneak peek at defining named routes. Now, let's dive deeper into how GetX manages these routes in a more structured and powerful way using `GetPage` and `GetRouterDelegate`. These are the tools that make GetX's navigation so robust, especially for larger apps!

## The Need for Structure: Why Bother?

Imagine you're designing a website with many pages: a homepage, an about page, a contact page, a profile page, and so on. If you just linked them haphazardly, it would quickly become a mess. You'd want a clear sitemap and well-defined URLs for each page.

Similarly, in a Flutter app, as it grows, just calling `Get.to(() => MyScreen())` everywhere can become hard to manage. What if you want to change the transition animation for a specific screen? Or pass data to it in a standardized way? Or manage deep linking (opening specific app screens from a web link)?

This is where `GetPage` and `GetRouterDelegate` come in. They help you:
1.  **Define all your app's screens (routes) in one central place.**
2.  **Give each screen a unique name (like a URL).**
3.  **Configure special behaviors for each screen (like transitions or data bindings).**
4.  **Power Flutter's modern Navigator 2.0 system within GetX, allowing for more complex navigation scenarios.**

Let's meet the stars!

## Meet the Blueprint: `GetPage`

Think of `GetPage` as a **blueprint for a screen** in your app. It's not the screen itself, but rather a detailed description of it. Each `GetPage` tells GetX:
*   `name`: The unique "URL" or path for this screen (e.g., `/home`, `/profile`, `/settings/notifications`). This is what you use with `Get.toNamed()`.
*   `page`: A function that tells GetX *how to build* the actual widget for this screen when it's needed.
*   `binding` (optional): A way to set up controllers or other dependencies specifically for this screen. (We'll explore bindings more in GetX state management).
*   `transition` (optional): How the screen animates in and out. (More on this in [Transition System (GetPageRouteTransitionMixin, CustomTransition, Transitions)](07_transition_system__getpageroutetransitionmixin__customtransition__transitions__.md)).
*   `middlewares` (optional): Special functions that can run before a page is shown, perhaps to check if a user is logged in. (Covered in [GetMiddleware](06_getmiddleware_.md)).

Let's define a couple of simple `GetPage` blueprints:

```dart
// main.dart (or a separate routes file)
import 'package:flutter/material.dart';
import 'package:get/get.dart'; // Import GetX

// Assume HomeScreen and ProfileScreen widgets are defined elsewhere
// For example:
// class HomeScreen extends StatelessWidget { /* ... */ }
// class ProfileScreen extends StatelessWidget { /* ... */ }

final List<GetPage> appPages = [
  GetPage(
    name: '/home', // The unique name for the home screen
    page: () => HomeScreen(), // How to build the HomeScreen
  ),
  GetPage(
    name: '/profile', // The unique name for the profile screen
    page: () => ProfileScreen(), // How to build the ProfileScreen
    // transition: Transition.rightToLeft, // Optional: a nice slide animation
  ),
];
```
In this snippet, `appPages` is a list holding the blueprints for our `HomeScreen` and `ProfileScreen`. We've given each a unique `name` and a `page` function.

## Meet the Captain: `GetRouterDelegate`

If `GetPage` is the blueprint, then `GetRouterDelegate` is the **captain of your app's navigation ship**. It's the core engine that powers Flutter's modern Navigator 2.0 system within GetX.

You usually won't interact with `GetRouterDelegate` directly in simple apps. When you provide your list of `GetPage` blueprints to `GetMaterialApp` (as we'll see next), GetX sets up a `GetRouterDelegate` for you behind the scenes.

This "captain" is responsible for:
*   Taking your `GetPage` blueprints.
*   Managing the actual stack of screens (what's visible, what's underneath).
*   Deciding which page is currently visible based on the URL or navigation actions.
*   Handling how to go to new pages (`Get.toNamed()`).
*   Handling how to go back (`Get.back()`).

Think of it like an air traffic controller for your app's screens. It knows all the available "runways" (`GetPage`s) and directs the "planes" (your users' navigation actions) to the correct one smoothly.

## Putting It Together: Defining Routes in `GetMaterialApp`

Now, how do we tell our GetX app about these `GetPage` blueprints so the `GetRouterDelegate` can use them? We pass our list of `GetPage`s to the `getPages` property of `GetMaterialApp` (or `GetCupertinoApp`).

Let's update our `main.dart` from Chapter 2:

```dart
// main.dart
import 'package:flutter/material.dart';
import 'package:get/get.dart';

// Let's define our screens quickly for this example
class HomeScreen extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(title: Text('Home')),
      body: Center(
        child: ElevatedButton(
          onPressed: () => Get.toNamed('/profile'), // Navigate to profile
          child: Text('Go to Profile'),
        ),
      ),
    );
  }
}

class ProfileScreen extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(title: Text('Profile')),
      body: Center(child: Text('This is your Profile!')),
    );
  }
}

// Our GetPage blueprints
final List<GetPage> appPages = [
  GetPage(name: '/home', page: () => HomeScreen()),
  GetPage(name: '/profile', page: () => ProfileScreen()),
];

void main() {
  runApp(MyApp());
}

class MyApp extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return GetMaterialApp(
      title: 'GetX Named Routes',
      initialRoute: '/home', // Start at the home screen
      getPages: appPages,   // <-- Here's where we provide our blueprints!
    );
  }
}
```
By providing `appPages` to `GetMaterialApp`, we've done two things:
1.  Registered our `/home` and `/profile` routes.
2.  Enabled `GetMaterialApp` to use its internal `GetRouterDelegate` to manage navigation based on these named routes.

Now, `Get.toNamed('/profile')` from `HomeScreen` will correctly navigate to `ProfileScreen` because the `GetRouterDelegate` (set up by `GetMaterialApp`) knows about the `/profile` blueprint.

## How Does It Work Under the Hood?

When you use `getPages` with `GetMaterialApp`, GetX sets up a more sophisticated navigation system. Here's a simplified step-by-step:

1.  **Setup**: When `GetMaterialApp` starts, it sees you've provided `getPages`. It then creates and configures a `GetRouterDelegate` (specifically, an instance of `GetDelegate` from `lib/get_navigation/src/routes/get_router_delegate.dart`). This delegate is given your list of `GetPage` blueprints.
2.  **Navigation Trigger**: You call `Get.toNamed('/profile')`.
3.  **Delegate at Work**: The `Get.toNamed` call, in this Navigator 2.0 setup, ultimately informs the `GetRouterDelegate`.
4.  **Route Matching**: The `GetRouterDelegate` consults its list of `GetPage`s. It uses a helper, often `ParseRouteTree` (from `lib/get_navigation/src/routes/parse_route.dart`), to find the `GetPage` whose `name` matches `/profile`. We'll explore `ParseRouteTree` more in [Route Parsing & Configuration (RouteDecoder, PageSettings, ParseRouteTree)](05_route_parsing___configuration__routedecoder__pagesettings__parseroutetree__.md).
5.  **Screen Creation**: Once the matching `GetPage` blueprint is found, the `GetRouterDelegate` uses its `page: () => ProfileScreen()` function to create an instance of `ProfileScreen`.
6.  **Stack Update**: The `GetRouterDelegate` then updates Flutter's navigation stack to display this new `ProfileScreen`.

Here's a visual:

```mermaid
sequenceDiagram
    participant UserAction as User Taps Button
    participant GetToNamed as Get.toNamed("/profile")
    participant GMA as GetMaterialApp (internally)
    participant GRD as GetRouterDelegate
    participant FlutterNav as Flutter Navigator

    UserAction->>GetToNamed: Invokes navigation for "/profile"
    GetToNamed->>GMA: Signals intent (simplified)
    GMA->>GRD: Relays "/profile" to its delegate
    GRD->>GRD: Finds GetPage(name: "/profile") in its list (getPages)
    GRD->>GRD: Calls page() function from GetPage
    GRD->>FlutterNav: "Push this new screen (ProfileScreen)"
    FlutterNav->>UserAction: ProfileScreen is displayed
```

Inside `GetMaterialApp` (or more accurately, `GetMaterialApp.router` which is used when `getPages` is provided), it sets up like this:

```dart
// Simplified concept from GetMaterialApp when getPages is used
// return GetMaterialApp.router(
//   routeInformationParser: GetInformationParser(...), // Handles URL parsing
//   routerDelegate: GetDelegate(pages: getPages, ...), // Our captain!
// );
```
The `GetDelegate` (our `GetRouterDelegate` implementation) receives your `pages` (your `GetPage` list).

Then, `GetDelegate`'s `build` method uses these pages to construct the `Navigator`:

```dart
// Simplified from lib/get_navigation/src/routes/get_router_delegate.dart
// Inside GetDelegate's build method:

// final currentHistory = currentConfiguration;
// final pages = /* ... logic to get current visible GetPage(s) based on URL ... */
//    getVisualPages(currentHistory).toList();

// return GetNavigator(
//   key: navigatorKey,
//   onPopPage: _onPopVisualRoute, // Handles back button for these pages
//   pages: pages, // The actual Flutter Page objects derived from your GetPages
//   // ... other navigator configurations
// );
```
The `pages` list here are Flutter `Page` objects, which `GetDelegate` creates based on your `GetPage` definitions and the current navigation state.

So, by using `GetPage` and `getPages`, you're tapping into this powerful, Navigator 2.0-based routing managed by `GetRouterDelegate`.

## Why This Approach?

*   **Centralized Route Definitions**: All your main navigation paths are clearly defined in one place.
*   **Named Navigation Power**: Makes `Get.toNamed()` very robust.
*   **Decoupling**: Your UI code just says "go to `/profile`"; it doesn't need to know *how* `ProfileScreen` is built or what its specific dependencies are.
*   **Advanced Scenarios**: This structure is the foundation for more complex features like:
    *   Nested navigation (routes within routes).
    *   Guards/Middlewares (e.g., checking login status before accessing a route, covered in [GetMiddleware](06_getmiddleware_.md)).
    *   Custom transitions per route (see [Transition System (GetPageRouteTransitionMixin, CustomTransition, Transitions)](07_transition_system__getpageroutetransitionmixin__customtransition__transitions__.md)).
    *   Better web URL handling.

## Conclusion

You've now learned about `GetPage`, the blueprint for your screens, and `GetRouterDelegate`, the captain that manages navigation using these blueprints. By defining your routes using `GetPage` and providing them to `GetMaterialApp` via the `getPages` property, you unlock a more structured, powerful, and maintainable way to handle navigation in your GetX applications. This setup is what allows GetX to seamlessly integrate with Flutter's Navigator 2.0 system, giving you fine-grained control while keeping things simple.

While `GetRouterDelegate` works largely behind the scenes for many common use cases, understanding its role helps you appreciate the robustness of GetX navigation.

Next up, we'll explore how GetX makes it incredibly easy to show common UI overlays like Snackbars, Dialogs, and BottomSheets, often without needing `BuildContext` at all! Let's head to [Overlay Management (Snackbar, Dialog, BottomSheet)](04_overlay_management__snackbar__dialog__bottomsheet__.md).

Relevant Code Snippets (Code itself remains unchanged):
--- File: lib/get_navigation/src/extension_navigation.dart ---
import 'dart:ui' as ui;

import 'package:flutter/material.dart';
import 'package:get/get_navigation/src/routes/test_kit.dart';

import '../../get.dart';
import 'dialog/dialog_route.dart';
import 'root/get_root.dart';

/// It replaces the Flutter Navigator, but needs no context.
/// You can to use navigator.push(YourRoute()) rather
/// Navigator.push(context, YourRoute());
NavigatorState? get navigator => GetNavigationExt(Get).key.currentState;

extension ExtensionBottomSheet on GetInterface {
  Future<T?> bottomSheet<T>(
    Widget bottomsheet, {
    Color? backgroundColor,
    double? elevation,
    bool persistent = true,
    ShapeBorder? shape,
    Clip? clipBehavior,
    Color? barrierColor,
    bool? ignoreSafeArea,
    bool isScrollControlled = false,
    bool useRootNavigator = false,
    bool isDismissible = true,
    bool enableDrag = true,
    RouteSettings? settings,
    Duration? enterBottomSheetDuration,
    Duration? exitBottomSheetDuration,
    Curve? curve,
  }) {
    return Navigator.of(overlayContext!, rootNavigator: useRootNavigator)
        .push(GetModalBottomSheetRoute<T>(
      builder: (_) => bottomsheet,
      isPersistent: persistent,
      // theme: Theme.of(key.currentContext, shadowThemeOnly: true),
      theme: Theme.of(key.currentContext!),
      isScrollControlled: isScrollControlled,

      barrierLabel: MaterialLocalizations.of(key.currentContext!)
          .modalBarrierDismissLabel,

      backgroundColor: backgroundColor ?? Colors.transparent,
      elevation: elevation,
      shape: shape,
      removeTop: ignoreSafeArea ?? true,
      clipBehavior: clipBehavior,
      isDismissible: isDismissible,
      modalBarrierColor: barrierColor,
      settings: settings,
      enableDrag: enableDrag,
      enterBottomSheetDuration:
          enterBottomSheetDuration ?? const Duration(milliseconds: 250),
      exitBottomSheetDuration:
          exitBottomSheetDuration ?? const Duration(milliseconds: 200),
      curve: curve,
    ));
  }
}

extension ExtensionDialog on GetInterface {
  /// Show a dialog.
  /// You can pass a [transitionDuration] and/or [transitionCurve],
  /// overriding the defaults when the dialog shows up and closes.
  /// When the dialog closes, uses those animations in reverse.
  Future<T?> dialog<T>(
    Widget widget, {
    bool barrierDismissible = true,
    Color? barrierColor,
    bool useSafeArea = true,
    GlobalKey<NavigatorState>? navigatorKey,
    Object? arguments,
    Duration? transitionDuration,
    Curve? transitionCurve,
    String? name,
    RouteSettings? routeSettings,
    String? id,
  }) {
    assert(debugCheckHasMaterialLocalizations(context!));

    //  final theme = Theme.of(context, shadowThemeOnly: true);
    final theme = Theme.of(context!);
    return generalDialog<T>(
      pageBuilder: (buildContext, animation, secondaryAnimation) {
        final pageChild = widget;
        Widget dialog = Builder(builder: (context) {
          return Theme(data: theme, child: pageChild);
        });
        if (useSafeArea) {
          dialog = SafeArea(child: dialog);
        }
        return dialog;
      },
      barrierDismissible: barrierDismissible,
      barrierLabel: MaterialLocalizations.of(context!).modalBarrierDismissLabel,
      barrierColor: barrierColor ?? Colors.black54,
      transitionDuration: transitionDuration ?? defaultDialogTransitionDuration,
      transitionBuilder: (context, animation, secondaryAnimation, child) {
        return FadeTransition(
          opacity: CurvedAnimation(
            parent: animation,
            curve: transitionCurve ?? defaultDialogTransitionCurve,
          ),
          child: child,
        );
      },
      navigatorKey: navigatorKey,
      routeSettings:
          routeSettings ?? RouteSettings(arguments: arguments, name: name),
      id: id,
    );
  }

  /// Api from showGeneralDialog with no context
  Future<T?> generalDialog<T>(
      {required RoutePageBuilder pageBuilder,
      bool barrierDismissible = false,
      String? barrierLabel,
      Color barrierColor = const Color(0x80000000),
      Duration transitionDuration = const Duration(milliseconds: 200),
      RouteTransitionsBuilder? transitionBuilder,
      GlobalKey<NavigatorState>? navigatorKey,
      RouteSettings? routeSettings,
      String? id}) {
    assert(!barrierDismissible || barrierLabel != null);
    final key = navigatorKey ?? Get.nestedKey(id)?.navigatorKey;
    final nav = key?.currentState ??
        Navigator.of(overlayContext!,
            rootNavigator:
                true); //overlay context will always return the root navigator
    return nav.push<T>(
      GetDialogRoute<T>(
        pageBuilder: pageBuilder,
        barrierDismissible: barrierDismissible,
        barrierLabel: barrierLabel,
        barrierColor: barrierColor,
        transitionDuration: transitionDuration,
        transitionBuilder: transitionBuilder,
        settings: routeSettings,
      ),
    );
  }

  /// Custom UI Dialog.
  Future<T?> defaultDialog<T>({
    String title = "Alert",
    EdgeInsetsGeometry? titlePadding,
    TextStyle? titleStyle,
    Widget? content,
    String? id,
    EdgeInsetsGeometry? contentPadding,
    VoidCallback? onConfirm,
    VoidCallback? onCancel,
    VoidCallback? onCustom,
    Color? cancelTextColor,
    Color? confirmTextColor,
    String? textConfirm,
    String? textCancel,
    String? textCustom,
    Widget? confirm,
    Widget? cancel,
    Widget? custom,
    Color? backgroundColor,
    bool barrierDismissible = true,
    Color? buttonColor,
    String middleText = "\n",
    TextStyle? middleTextStyle,
    double radius = 20.0,
    //   ThemeData themeData,
    List<Widget>? actions,

    // onWillPop Scope
    PopInvokedWithResultCallback<T>? onWillPop,

    // the navigator used to push the dialog
    GlobalKey<NavigatorState>? navigatorKey,
  }) {
    var leanCancel = onCancel != null || textCancel != null;
    var leanConfirm = onConfirm != null || textConfirm != null;
    actions ??= [];

    if (cancel != null) {
      actions.add(cancel);
    } else {
      if (leanCancel) {
        actions.add(TextButton(
          style: TextButton.styleFrom(
            tapTargetSize: MaterialTapTargetSize.shrinkWrap,
            padding: const EdgeInsets.symmetric(horizontal: 10, vertical: 8),
            shape: RoundedRectangleBorder(
                side: BorderSide(
                    color: buttonColor ?? theme.colorScheme.secondary,
                    width: 2,
                    style: BorderStyle.solid),
                borderRadius: BorderRadius.circular(radius)),
          ),
          onPressed: () {
            if (onCancel == null) {
              //TODO: Close current dialog after api change
              closeAllDialogs();
            } else {
              onCancel.call();
            }
          },
          child: Text(
            textCancel ?? "Cancel",
            style: TextStyle(
                color: cancelTextColor ?? theme.colorScheme.secondary),
          ),
        ));
      }
    }
    if (confirm != null) {
      actions.add(confirm);
    } else {
      if (leanConfirm) {
        actions.add(TextButton(
            style: TextButton.styleFrom(
              tapTargetSize: MaterialTapTargetSize.shrinkWrap,
              backgroundColor: buttonColor ?? theme.colorScheme.secondary,
              shape: RoundedRectangleBorder(
                  borderRadius: BorderRadius.circular(radius)),
            ),
            child: Text(
              textConfirm ?? "Ok",
              style: TextStyle(
                  color: confirmTextColor ?? theme.colorScheme.surface),
            ),
            onPressed: () {
              onConfirm?.call();
            }));
      }
    }

    Widget baseAlertDialog = Builder(builder: (context) {
      return AlertDialog(
        titlePadding: titlePadding ?? const EdgeInsets.all(8),
        contentPadding: contentPadding ?? const EdgeInsets.all(8),

        backgroundColor:
            backgroundColor ?? DialogTheme.of(context).backgroundColor,
        shape: RoundedRectangleBorder(
            borderRadius: BorderRadius.all(Radius.circular(radius))),
        title: Text(title, textAlign: TextAlign.center, style: titleStyle),
        content: Column(
          crossAxisAlignment: CrossAxisAlignment.center,
          mainAxisSize: MainAxisSize.min,
          children: [
            content ??
                Text(middleText,
                    textAlign: TextAlign.center, style: middleTextStyle),
            const SizedBox(height: 16),
            ButtonTheme(
              minWidth: 78.0,
              height: 34.0,
              child: Wrap(
                alignment: WrapAlignment.center,
                spacing: 8,
                runSpacing: 8,
                children: actions!,
              ),
            )
          ],
        ),
        // actions: actions, // ?? <Widget>[cancelButton, confirmButton],
        buttonPadding: EdgeInsets.zero,
      );
    });

    return dialog<T>(
      onWillPop != null
          ? PopScope<T>(
              onPopInvokedWithResult: (didPop, result) =>
                  onWillPop(didPop, result),
              // onPopInvoked: onWillPop,
              child: baseAlertDialog,
            )
          : baseAlertDialog,
      barrierDismissible: barrierDismissible,
      navigatorKey: navigatorKey,
      id: id,
    );
  }
}

extension ExtensionSnackbar on GetInterface {
  SnackbarController rawSnackbar({
    String? title,
    String? message,
    Widget? titleText,
    Widget? messageText,
    Widget? icon,
    bool instantInit = true,
    bool shouldIconPulse = true,
    double? maxWidth,
    EdgeInsets margin = const EdgeInsets.all(0.0),
    EdgeInsets padding = const EdgeInsets.all(16),
    double borderRadius = 0.0,
    Color? borderColor,
    double borderWidth = 1.0,
    Color backgroundColor = const Color(0xFF303030),
    Color? leftBarIndicatorColor,
    List<BoxShadow>? boxShadows,
    Gradient? backgroundGradient,
    Widget? mainButton,
    OnTap? onTap,
    Duration? duration = const Duration(seconds: 3),
    bool isDismissible = true,
    DismissDirection? dismissDirection,
    bool showProgressIndicator = false,
    AnimationController? progressIndicatorController,
    Color? progressIndicatorBackgroundColor,
    Animation<Color>? progressIndicatorValueColor,
    SnackPosition snackPosition = SnackPosition.bottom,
    SnackStyle snackStyle = SnackStyle.floating,
    Curve forwardAnimationCurve = Curves.easeOutCirc,
    Curve reverseAnimationCurve = Curves.easeOutCirc,
    Duration animationDuration = const Duration(seconds: 1),
    SnackbarStatusCallback? snackbarStatus,
    double barBlur = 0.0,
    double overlayBlur = 0.0,
    Color? overlayColor,
    Form? userInputForm,
  }) {
    final getSnackBar = GetSnackBar(
      snackbarStatus: snackbarStatus,
      title: title,
      message: message,
      titleText: titleText,
      messageText: messageText,
      snackPosition: snackPosition,
      borderRadius: borderRadius,
      margin: margin,
      duration: duration,
      barBlur: barBlur,
      backgroundColor: backgroundColor,
      icon: icon,
      shouldIconPulse: shouldIconPulse,
      maxWidth: maxWidth,
      padding: padding,
      borderColor: borderColor,
      borderWidth: borderWidth,
      leftBarIndicatorColor: leftBarIndicatorColor,
      boxShadows: boxShadows,
      backgroundGradient: backgroundGradient,
      mainButton: mainButton,
      onTap: onTap,
      isDismissible: isDismissible,
      dismissDirection: dismissDirection,
      showProgressIndicator: showProgressIndicator,
      progressIndicatorController: progressIndicatorController,
      progressIndicatorBackgroundColor: progressIndicatorBackgroundColor,
      progressIndicatorValueColor: progressIndicatorValueColor,
      snackStyle: snackStyle,
      forwardAnimationCurve: forwardAnimationCurve,
      reverseAnimationCurve: reverseAnimationCurve,
      animationDuration: animationDuration,
      overlayBlur: overlayBlur,
      overlayColor: overlayColor,
      userInputForm: userInputForm,
    );

    final controller = SnackbarController(getSnackBar);

    if (instantInit) {
      controller.show();
    } else {
      Engine.instance.addPostFrameCallback((_) {
        controller.show();
      });
    }
    return controller;
  }

  SnackbarController showSnackbar(GetSnackBar snackbar) {
    final controller = SnackbarController(snackbar);
    controller.show();
    return controller;
  }

  SnackbarController snackbar(
    String title,
    String message, {
    Color? colorText,
    Duration? duration = const Duration(seconds: 3),

    /// with instantInit = false you can put snackbar on initState
    bool instantInit = true,
    SnackPosition? snackPosition,
    Widget? titleText,
    Widget? messageText,
    Widget? icon,
    bool? shouldIconPulse,
    double? maxWidth,
    EdgeInsets? margin,
    EdgeInsets? padding,
    double? borderRadius,
    Color? borderColor,
    double? borderWidth,
    Color? backgroundColor,
    Color? leftBarIndicatorColor,
    List<BoxShadow>? boxShadows,
    Gradient? backgroundGradient,
    TextButton? mainButton,
    OnTap? onTap,
    OnHover? onHover,
    bool? isDismissible,
    bool? showProgressIndicator,
    DismissDirection? dismissDirection,
    AnimationController? progressIndicatorController,
    Color? progressIndicatorBackgroundColor,
    Animation<Color>? progressIndicatorValueColor,
    SnackStyle? snackStyle,
    Curve? forwardAnimationCurve,
    Curve? reverseAnimationCurve,
    Duration? animationDuration,
    double? barBlur,
    double? overlayBlur,
    SnackbarStatusCallback? snackbarStatus,
    Color? overlayColor,
    Form? userInputForm,
  }) {
    final getSnackBar = GetSnackBar(
        snackbarStatus: snackbarStatus,
        titleText: titleText ??
            Text(
              title,
              style: TextStyle(
                color: colorText ?? iconColor ?? Colors.black,
                fontWeight: FontWeight.w800,
                fontSize: 16,
              ),
            ),
        messageText: messageText ??
            Text(
              message,
              style: TextStyle(
                color: colorText ?? iconColor ?? Colors.black,
                fontWeight: FontWeight.w300,
                fontSize: 14,
              ),
            ),
        snackPosition: snackPosition ?? SnackPosition.top,
        borderRadius: borderRadius ?? 15,
        margin: margin ?? const EdgeInsets.symmetric(horizontal: 10),
        duration: duration,
        barBlur: barBlur ?? 7.0,
        backgroundColor: backgroundColor ?? Colors.grey.withValues(alpha: 0.2),
        icon: icon,
        shouldIconPulse: shouldIconPulse ?? true,
        maxWidth: maxWidth,
        padding: padding ?? const EdgeInsets.all(16),
        borderColor: borderColor,
        borderWidth: borderWidth,
        leftBarIndicatorColor: leftBarIndicatorColor,
        boxShadows: boxShadows,
        backgroundGradient: backgroundGradient,
        mainButton: mainButton,
        onTap: onTap,
        onHover: onHover,
        isDismissible: isDismissible ?? true,
        dismissDirection: dismissDirection,
        showProgressIndicator: showProgressIndicator ?? false,
        progressIndicatorController: progressIndicatorController,
        progressIndicatorBackgroundColor: progressIndicatorBackgroundColor,
        progressIndicatorValueColor: progressIndicatorValueColor,
        snackStyle: snackStyle ?? SnackStyle.floating,
        forwardAnimationCurve: forwardAnimationCurve ?? Curves.easeOutCirc,
        reverseAnimationCurve: reverseAnimationCurve ?? Curves.easeOutCirc,
        animationDuration: animationDuration ?? const Duration(seconds: 1),
        overlayBlur: overlayBlur ?? 0.0,
        overlayColor: overlayColor ?? Colors.transparent,
        userInputForm: userInputForm);

    final controller = SnackbarController(getSnackBar);

    if (instantInit) {
      controller.show();
    } else {
      //routing.isSnackbar = true;
      Engine.instance.addPostFrameCallback((_) {
        controller.show();
      });
    }
    return controller;
  }
}

extension GetNavigationExt on GetInterface {
  /// **Navigation.push()** shortcut.<br><br>
  ///
  /// Pushes a new `page` to the stack
  ///
  /// It has the advantage of not needing context,
  /// so you can call from your business logic
  ///
  /// You can set a custom [transition], and a transition [duration].
  ///
  /// You can send any type of value to the other route in the [arguments].
  ///
  /// Just like native routing in Flutter, you can push a route
  /// as a [fullscreenDialog],
  ///
  /// [id] is for when you are using nested navigation,
  /// as explained in documentation
  ///
  /// If you want the same behavior of ios that pops a route when the user drag,
  /// you can set [popGesture] to true
  ///
  /// If you're using the [BindingsInterface] api, you must define it here
  ///
  /// By default, GetX will prevent you from push a route that you already in,
  /// if you want to push anyway, set [preventDuplicates] to false
  Future<T?>? to<T extends Object?>(Widget Function() page,
      {bool? opaque,
      Transition? transition,
      Curve? curve,
      Duration? duration,
      String? id,
      String? routeName,
      bool fullscreenDialog = false,
      dynamic arguments,
      List<BindingsInterface> bindings = const [],
      bool preventDuplicates = true,
      bool? popGesture,
      bool showCupertinoParallax = true,
      double Function(BuildContext context)? gestureWidth,
      bool rebuildStack = true,
      PreventDuplicateHandlingMode preventDuplicateHandlingMode =
          PreventDuplicateHandlingMode.reorderRoutes}) {
    return searchDelegate(id).to(
      page,
      opaque: opaque,
      transition: transition,
      curve: curve,
      duration: duration,
      id: id,
      routeName: routeName,
      fullscreenDialog: fullscreenDialog,
      arguments: arguments,
      bindings: bindings,
      preventDuplicates: preventDuplicates,
      popGesture: popGesture,
      showCupertinoParallax: showCupertinoParallax,
      gestureWidth: gestureWidth,
      rebuildStack: rebuildStack,
      preventDuplicateHandlingMode: preventDuplicateHandlingMode,
    );
  }

//   GetPageBuilder _resolvePage(dynamic page, String method) {
//     if (page is GetPageBuilder) {
//       return page;
//     } else if (page is Widget) {
//       Get.log(
//           '''WARNING, consider using: "Get.$method(() => Page())"
//instead of "Get.$method(Page())".
// Using a widget function instead of a widget fully guarantees that the widget
//and its controllers will be removed from memory when they are no longer used.
//       ''');
//       return () => page;
//     } else if (page is String) {
//       throw '''Unexpected String,
// use toNamed() instead''';
//     } else {
//       throw '''Unexpected format,
// you can only use widgets and widget functions here''';
//     }
//   }

  /// **Navigation.pushNamed()** shortcut.<br><br>
  ///
  /// Pushes a new named `page` to the stack.
  ///
  /// It has the advantage of not needing context, so you can call
  /// from your business logic.
  ///
  /// You can send any type of value to the other route in the [arguments].
  ///
  /// [id] is for when you are using nested navigation,
  /// as explained in documentation
  ///
  /// By default, GetX will prevent you from push a route that you already in,
  /// if you want to push anyway, set [preventDuplicates] to false
  ///
  /// Note: Always put a slash on the route ('/page1'), to avoid unexpected errors
  Future<T?>? toNamed<T>(
    String page, {
    dynamic arguments,
    dynamic id,
    bool preventDuplicates = true,
    Map<String, String>? parameters,
  }) {
    // if (preventDuplicates && page == currentRoute) {
    //   return null;
    // }

    if (parameters != null) {
      final uri = Uri(path: page, queryParameters: parameters);
      page = uri.toString();
    }

    return searchDelegate(id).toNamed(
      page,
      arguments: arguments,
      id: id,
      preventDuplicates: preventDuplicates,
      parameters: parameters,
    );
  }

  /// **Navigation.pushReplacementNamed()** shortcut.<br><br>
  ///
  /// Pop the current named `page` in the stack and push a new one in its place
  ///
  /// It has the advantage of not needing context, so you can call
  /// from your business logic.
  ///
  /// You can send any type of value to the other route in the [arguments].
  ///
  /// [id] is for when you are using nested navigation,
  /// as explained in documentation
  ///
  /// By default, GetX will prevent you from push a route that you already in,
  /// if you want to push anyway, set [preventDuplicates] to false
  ///
  /// Note: Always put a slash on the route ('/page1'), to avoid unexpected errors
  Future<T?>? offNamed<T>(
    String page, {
    dynamic arguments,
    String? id,
    Map<String, String>? parameters,
  }) {
    // if (preventDuplicates && page == currentRoute) {
    //   return null;
    // }

    if (parameters != null) {
      final uri = Uri(path: page, queryParameters: parameters);
      page = uri.toString();
    }
    return searchDelegate(id).offNamed(
      page,
      arguments: arguments,
      id: id,
      // preventDuplicates: preventDuplicates,
      parameters: parameters,
    );
  }

  /// **Navigation.popUntil()** shortcut.<br><br>
  ///
  /// Calls pop several times in the stack until [predicate] returns true
  ///
  /// [id] is for when you are using nested navigation,
  /// as explained in documentation
  ///
  /// [predicate] can be used like this:
  /// `Get.until((route) => Get.currentRoute == '/home')`so when you get to home page,
  ///
  /// or also like this:
  /// `Get.until((route) => !Get.isDialogOpen())`, to make sure the
  /// dialog is closed
  void until(bool Function(GetPage<dynamic>) predicate, {String? id}) {
    // if (key.currentState.mounted) // add this if appear problems on future with route navigate
    // when widget don't mounted
    return searchDelegate(id).backUntil(predicate);
  }

  /// **Navigation.pushNamedAndRemoveUntil()** shortcut.<br><br>
  ///
  /// Push the given named `page`, and then pop several pages in the stack
  /// until [predicate] returns true
  ///
  /// You can send any type of value to the other route in the [arguments].
  ///
  /// [id] is for when you are using nested navigation,
  /// as explained in documentation
  ///
  /// [predicate] can be used like this:
  /// `Get.offNamedUntil(page, ModalRoute.withName('/home'))`
  /// to pop routes in stack until home,
  /// or like this:
  /// `Get.offNamedUntil((route) => !Get.isDialogOpen())`,
  /// to make sure the dialog is closed
  ///
  /// Note: Always put a slash on the route name ('/page1'), to avoid unexpected errors
  Future<T?>? offNamedUntil<T>(
    String page,
    bool Function(GetPage<dynamic>)? predicate, {
    String? id,
    dynamic arguments,
    Map<String, String>? parameters,
  }) {
    if (parameters != null) {
      final uri = Uri(path: page, queryParameters: parameters);
      page = uri.toString();
    }

    return searchDelegate(id).offNamedUntil<T>(
      page,
      predicate: predicate,
      id: id,
      arguments: arguments,
      parameters: parameters,
    );
  }

  /// **Navigation.popAndPushNamed()** shortcut.<br><br>
  ///
  /// Pop the current named page and pushes a new `page` to the stack
  /// in its place
  ///
  /// You can send any type of value to the other route in the [arguments].
  /// It is very similar to `offNamed()` but use a different approach
  ///
  /// The `offNamed()` pop a page, and goes to the next. The
  /// `offAndToNamed()` goes to the next page, and removes the previous one.
  /// The route transition animation is different.
  Future<T?>? offAndToNamed<T>(
    String page, {
    dynamic arguments,
    String? id,
    dynamic result,
    Map<String, String>? parameters,
  }) {
    if (parameters != null) {
      final uri = Uri(path: page, queryParameters: parameters);
      page = uri.toString();
    }
    return searchDelegate(id).backAndtoNamed(
      page,
      arguments: arguments,
      result: result,
    );
  }

  /// **Navigation.removeRoute()** shortcut.<br><br>
  ///
  /// Remove a specific [route] from the stack
  ///
  /// [id] is for when you are using nested navigation,
  /// as explained in documentation
  void removeRoute(String name, {String? id}) {
    return searchDelegate(id).removeRoute(name);
  }

  /// **Navigation.pushNamedAndRemoveUntil()** shortcut.<br><br>
  ///
  /// Push a named `page` and pop several pages in the stack
  /// until [predicate] returns true. [predicate] is optional
  ///
  /// It has the advantage of not needing context, so you can
  /// call from your business logic.
  ///
  /// You can send any type of value to the other route in the [arguments].
  ///
  /// [predicate] can be used like this:
  /// `Get.until((route) => Get.currentRoute == '/home')`so when you get to home page,
  /// or also like
  /// `Get.until((route) => !Get.isDialogOpen())`, to make sure the dialog
  /// is closed
  ///
  /// [id] is for when you are using nested navigation,
  /// as explained in documentation
  ///
  /// Note: Always put a slash on the route ('/page1'), to avoid unexpected errors
  Future<T?>? offAllNamed<T>(
    String newRouteName, {
    // bool Function(GetPage<dynamic>)? predicate,
    dynamic arguments,
    String? id,
    Map<String, String>? parameters,
  }) {
    if (parameters != null) {
      final uri = Uri(path: newRouteName, queryParameters: parameters);
      newRouteName = uri.toString();
    }

    return searchDelegate(id).offAllNamed<T>(
      newRouteName,
      //predicate: predicate ?? (_) => false,
      arguments: arguments,
      id: id,
      parameters: parameters,
    );
  }

  /// Returns true if a Snackbar, Dialog or BottomSheet is currently OPEN
  bool get isOverlaysOpen =>
      (isSnackbarOpen || isDialogOpen! || isBottomSheetOpen!);

  /// Returns true if there is no Snackbar, Dialog or BottomSheet open
  bool get isOverlaysClosed =>
      (!isSnackbarOpen && !isDialogOpen! && !isBottomSheetOpen!);

  /// **Navigation.popUntil()** shortcut.<br><br>
  ///
  /// Pop the current page, snackbar, dialog or bottomsheet in the stack
  ///
  /// if your set [closeOverlays] to true, Get.back() will close the
  /// currently open snackbar/dialog/bottomsheet AND the current page
  ///
  /// [id] is for when you are using nested navigation,
  /// as explained in documentation
  ///
  /// It has the advantage of not needing context, so you can call
  /// from your business logic.
  void back<T>({
    T? result,
    bool canPop = true,
    int times = 1,
    String? id,
  }) {
    if (times < 1) {
      times = 1;
    }

    if (times > 1) {
      var count = 0;
      return searchDelegate(id).backUntil((route) => count++ == times);
    } else {
      if (canPop) {
        if (searchDelegate(id).canBack == true) {
          return searchDelegate(id).back<T>(result);
        }
      } else {
        return searchDelegate(id).back<T>(result);
      }
    }
  }

  /// Pop the current page, snackbar, dialog or bottomsheet in the stack
  ///
  /// if your set [closeOverlays] to true, Get.back() will close the
  /// currently open snackbar/dialog/bottomsheet AND the current page
  ///
  /// [id] is for when you are using nested navigation,
  /// as explained in documentation
  ///
  /// It has the advantage of not needing context, so you can call
  /// from your business logic.
  void backLegacy<T>({
    T? result,
    bool closeOverlays = false,
    bool canPop = true,
    int times = 1,
    String? id,
  }) {
    if (closeOverlays) {
      closeAllOverlays();
    }

    if (times < 1) {
      times = 1;
    }

    if (times > 1) {
      var count = 0;
      return searchDelegate(id).navigatorKey.currentState?.popUntil((route) {
        return count++ == times;
      });
    } else {
      if (canPop) {
        if (searchDelegate(id).navigatorKey.currentState?.canPop() == true) {
          return searchDelegate(id).navigatorKey.currentState?.pop<T>(result);
        }
      } else {
        return searchDelegate(id).navigatorKey.currentState?.pop<T>(result);
      }
    }
  }

  void closeAllDialogsAndBottomSheets(
    String? id,
  ) {
    // It can not be divided, because dialogs and bottomsheets can not be consecutive
    while ((isDialogOpen! && isBottomSheetOpen!)) {
      closeOverlay(id: id);
    }
  }

  void closeAllDialogs({
    String? id,
  }) {
    while ((isDialogOpen!)) {
      closeOverlay(id: id);
    }
  }

  /// Close the currently open dialog, returning a [result], if provided
  void closeDialog<T>({String? id, T? result}) {
    // Stop if there is no dialog open
    if (isDialogOpen == null || !isDialogOpen!) return;

    closeOverlay(id: id, result: result);
  }

  void closeBottomSheet<T>({String? id, T? result}) {
    // Stop if there is no bottomsheet open
    if (isBottomSheetOpen == null || !isBottomSheetOpen!) return;

    closeOverlay(id: id, result: result);
  }

  /// Close the current overlay returning the [result], if provided
  void closeOverlay<T>({
    String? id,
    T? result,
  }) {
    searchDelegate(id).navigatorKey.currentState?.pop(result);
  }

  void closeAllBottomSheets({
    String? id,
  }) {
    while ((isBottomSheetOpen!)) {
      searchDelegate(id).navigatorKey.currentState?.pop();
    }
  }

  void closeAllOverlays() {
    closeAllDialogsAndBottomSheets(null);
    closeAllSnackbars();
  }

  /// **Navigation.popUntil()** (with predicate) shortcut .<br><br>
  ///
  /// Close as many routes as defined by [times]
  ///
  /// [id] is for when you are using nested navigation,
  /// as explained in documentation
  void close<T extends Object>({
    bool closeAll = true,
    bool closeSnackbar = true,
    bool closeDialog = true,
    bool closeBottomSheet = true,
    String? id,
    T? result,
  }) {
    void handleClose(bool closeCondition, Function closeAllFunction,
        Function closeSingleFunction,
        [bool? isOpenCondition]) {
      if (closeCondition) {
        if (closeAll) {
          closeAllFunction();
        } else if (isOpenCondition == true) {
          closeSingleFunction();
        }
      }
    }

    handleClose(closeSnackbar, closeAllSnackbars, closeCurrentSnackbar);
    handleClose(closeDialog, closeAllDialogs, closeOverlay, isDialogOpen);
    handleClose(closeBottomSheet, closeAllBottomSheets, closeOverlay,
        isBottomSheetOpen);
  }

  /// **Navigation.pushReplacement()** shortcut .<br><br>
  ///
  /// Pop the current page and pushes a new `page` to the stack
  ///
  /// It has the advantage of not needing context,
  /// so you can call from your business logic
  ///
  /// You can set a custom [transition], define a Tween [curve],
  /// and a transition [duration].
  ///
  /// You can send any type of value to the other route in the [arguments].
  ///
  /// Just like native routing in Flutter, you can push a route
  /// as a [fullscreenDialog],
  ///
  /// [id] is for when you are using nested navigation,
  /// as explained in documentation
  ///
  /// If you want the same behavior of ios that pops a route when the user drag,
  /// you can set [popGesture] to true
  ///
  /// If you're using the [BindingsInterface] api, you must define it here
  ///
  /// By default, GetX will prevent you from push a route that you already in,
  /// if you want to push anyway, set [preventDuplicates] to false
  Future<T?>? off<T>(
    Widget Function() page, {
    bool? opaque,
    Transition? transition,
    Curve? curve,
    bool? popGesture,
    String? id,
    String? routeName,
    dynamic arguments,
    List<BindingsInterface> bindings = const [],
    bool fullscreenDialog = false,
    bool preventDuplicates = true,
    Duration? duration,
    double Function(BuildContext context)? gestureWidth,
  }) {
    routeName ??= "/${page.runtimeType.toString()}";
    routeName = _cleanRouteName(routeName);
    if (preventDuplicates && routeName == currentRoute) {
      return null;
    }
    return searchDelegate(id).off(
      page,
      opaque: opaque ?? true,
      transition: transition,
      curve: curve,
      popGesture: popGesture,
      id: id,
      routeName: routeName,
      arguments: arguments,
      bindings: bindings,
      fullscreenDialog: fullscreenDialog,
      preventDuplicates: preventDuplicates,
      duration: duration,
      gestureWidth: gestureWidth,
    );
  }

  Future<T?> offUntil<T>(
    Widget Function() page,
    bool Function(GetPage) predicate, [
    Object? arguments,
    String? id,
  ]) {
    return searchDelegate(id).offUntil(
      page,
      predicate,
      arguments,
    );
  }

  ///
  /// Push a `page` and pop several pages in the stack
  /// until [predicate] returns true. [predicate] is optional
  ///
  /// It has the advantage of not needing context,
  /// so you can call from your business logic
  ///
  /// You can set a custom [transition], a [curve] and a transition [duration].
  ///
  /// You can send any type of value to the other route in the [arguments].
  ///
  /// Just like native routing in Flutter, you can push a route
  /// as a [fullscreenDialog],
  ///
  /// [predicate] can be used like this:
  /// `Get.until((route) => Get.currentRoute == '/home')`so when you get to home page,
  /// or also like
  /// `Get.until((route) => !Get.isDialogOpen())`, to make sure the dialog
  /// is closed
  ///
  /// [id] is for when you are using nested navigation,
  /// as explained in documentation
  ///
  /// If you want the same behavior of ios that pops a route when the user drag,
  /// you can set [popGesture] to true
  ///
  /// If you're using the [BindingsInterface] api, you must define it here
  ///
  /// By default, GetX will prevent you from push a route that you already in,
  /// if you want to push anyway, set [preventDuplicates] to false
  Future<T?>? offAll<T>(
    Widget Function() page, {
    bool Function(GetPage<dynamic>)? predicate,
    bool? opaque,
    bool? popGesture,
    String? id,
    String? routeName,
    dynamic arguments,
    List<BindingsInterface> bindings = const [],
    bool fullscreenDialog = false,
    Transition? transition,
    Curve? curve,
    Duration? duration,
    double Function(BuildContext context)? gestureWidth,
  }) {
    routeName ??= "/${page.runtimeType.toString()}";
    routeName = _cleanRouteName(routeName);
    return searchDelegate(id).offAll<T>(
      page,
      predicate: predicate,
      opaque: opaque ?? true,
      popGesture: popGesture,
      id: id,
      //  routeName routeName,
      arguments: arguments,
      bindings: bindings,
      fullscreenDialog: fullscreenDialog,
      transition: transition,
      curve: curve,
      duration: duration,
      gestureWidth: gestureWidth,
    );
  }

  /// Takes a route [name] String generated by [to], [off], [offAll]
  /// (and similar context navigation methods), cleans the extra chars and
  /// accommodates the format.
  /// TODO: check for a more "appealing" URL naming convention.
  /// `() => MyHomeScreenView` becomes `/my-home-screen-view`.
  String _cleanRouteName(String name) {
    name = name.replaceAll('() => ', '');

    /// uncomment for URL styling.
    // name = name.paramCase!;
    if (!name.startsWith('/')) {
      name = '/$name';
    }
    return Uri.tryParse(name)?.toString() ?? name;
  }
  //TODO: Deprecated
  // /// change default config of Get
  // void config(
  //     {bool? enableLog,
  //     LogWriterCallback? logWriterCallback,
  //     bool? defaultPopGesture,
  //     bool? defaultOpaqueRoute,
  //     Duration? defaultDurationTransition,
  //     bool? defaultGlobalState,
  //     Transition? defaultTransition}) {
  //   if (enableLog != null) {
  //     Get.isLogEnable = enableLog;
  //   }
  //   if (logWriterCallback != null) {
  //     Get.log = logWriterCallback;
  //   }
  //   if (defaultPopGesture != null) {
  //     _getxController.defaultPopGesture = defaultPopGesture;
  //   }
  //   if (defaultOpaqueRoute != null) {
  //     _getxController.defaultOpaqueRoute = defaultOpaqueRoute;
  //   }
  //   if (defaultTransition != null) {
  //     _getxController.defaultTransition = defaultTransition;
  //   }

  //   if (defaultDurationTransition != null) {
  //     _getxController.defaultTransitionDuration = defaultDurationTransition;
  //   }
  // }

  Future<void> updateLocale(Locale l) async {
    Get.locale = l;
    await forceAppUpdate();
  }

  /// As a rule, Flutter knows which widget to update,
  /// so this command is rarely needed. We can mention situations
  /// where you use const so that widgets are not updated with setState,
  /// but you want it to be forcefully updated when an event like
  /// language change happens. using context to make the widget dirty
  /// for performRebuild() is a viable solution.
  /// However, in situations where this is not possible, or at least,
  /// is not desired by the developer, the only solution for updating
  /// widgets that Flutter does not want to update is to use reassemble
  /// to forcibly rebuild all widgets. Attention: calling this function will
  /// reconstruct the application from the sketch, use this with caution.
  /// Your entire application will be rebuilt, and touch events will not
  /// work until the end of rendering.
  Future<void> forceAppUpdate() async {
    await engine.performReassemble();
  }

  void appUpdate() => rootController.update();

  void changeTheme(ThemeData theme) {
    rootController.setTheme(theme);
  }

  void changeThemeMode(ThemeMode themeMode) {
    rootController.setThemeMode(themeMode);
  }

  GlobalKey<NavigatorState>? addKey(GlobalKey<NavigatorState> newKey) {
    return rootController.addKey(newKey);
  }

  GetDelegate? nestedKey(String? key) {
    return rootController.nestedKey(key);
  }

  GetDelegate searchDelegate(String? k) {
    GetDelegate key;
    if (k == null) {
      key = Get.rootController.rootDelegate;
    } else {
      if (!keys.containsKey(k)) {
        throw 'Route id ($k) not found';
      }
      key = keys[k]!;
    }

    // if (_key.listenersLength == 0 && !testMode) {
    //   throw """You are trying to use contextless navigation without
    //   a GetMaterialApp or Get.key.
    //   If you are testing your app, you can use:
    //   [Get.testMode = true], or if you are running your app on
    //   a physical device or emulator, you must exchange your [MaterialApp]
    //   for a [GetMaterialApp].
    //   """;
    // }

    return key;
  }

  /// give name from current route
  String get currentRoute => routing.current;

  /// give name from previous route
  String get previousRoute => routing.previous;

  /// check if snackbar is open
  bool get isSnackbarOpen =>
      SnackbarController.isSnackbarBeingShown; //routing.isSnackbar;

  void closeAllSnackbars() {
    SnackbarController.cancelAllSnackbars();
  }

  Future<void> closeCurrentSnackbar() async {
    await SnackbarController.closeCurrentSnackbar();
  }

  /// check if dialog is open
  bool? get isDialogOpen => routing.isDialog;

  /// check if bottomsheet is open
  bool? get isBottomSheetOpen => routing.isBottomSheet;

  /// check a raw current route
  Route<dynamic>? get rawRoute => routing.route;

  /// check if default opaque route is enable
  bool get isOpaqueRouteDefault => defaultOpaqueRoute;

  /// give access to currentContext
  BuildContext? get context => key.currentContext;

  /// give access to current Overlay Context
  BuildContext? get overlayContext {
    BuildContext? overlay;
    key.currentState?.overlay?.context.visitChildElements((element) {
      overlay = element;
    });
    return overlay;
  }

  /// give access to Theme.of(context)
  ThemeData get theme {
    var theme = ThemeData.fallback();
    if (context != null) {
      theme = Theme.of(context!);
    }
    return theme;
  }

  /// The current null safe [WidgetsBinding]
  WidgetsBinding get engine {
    return WidgetsFlutterBinding.ensureInitialized();
  }

  /// The window to which this binding is bound.
  ui.PlatformDispatcher get window => engine.platformDispatcher;

  Locale? get deviceLocale => window.locale;

  ///The number of device pixels for each logical pixel.
  double get pixelRatio => window.implicitView!.devicePixelRatio;

  Size get size => window.implicitView!.physicalSize / pixelRatio;

  ///The horizontal extent of this size.
  double get width => size.width;

  ///The vertical extent of this size
  double get height => size.height;

  ///The distance from the top edge to the first unpadded pixel,
  ///in physical pixels.
  double get statusBarHeight => window.implicitView!.padding.top;

  ///The distance from the bottom edge to the first unpadded pixel,
  ///in physical pixels.
  double get bottomBarHeight => window.implicitView!.padding.bottom;

  ///The system-reported text scale.
  double get textScaleFactor => window.textScaleFactor;

  /// give access to TextTheme.of(context)
  TextTheme get textTheme => theme.textTheme;

  /// give access to Mediaquery.of(context)
  MediaQueryData get mediaQuery => MediaQuery.of(context!);

  /// Check if dark mode theme is enable
  bool get isDarkMode => (theme.brightness == Brightness.dark);

  /// Check if dark mode theme is enable on platform on android Q+
  bool get isPlatformDarkMode =>
      (ui.PlatformDispatcher.instance.platformBrightness == Brightness.dark);

  /// give access to Theme.of(context).iconTheme.color
  Color? get iconColor => theme.iconTheme.color;

  /// give access to FocusScope.of(context)
  FocusNode? get focusScope => FocusManager.instance.primaryFocus;

  // /// give access to Immutable MediaQuery.of(context).size.height
  // double get height => MediaQuery.of(context).size.height;

  // /// give access to Immutable MediaQuery.of(context).size.width
  // double get width => MediaQuery.of(context).size.width;

  GlobalKey<NavigatorState> get key => rootController.key;

  Map<String, GetDelegate> get keys => rootController.keys;

  GetRootState get rootController => GetRootState.controller;

  ConfigData get _getxController => GetRootState.controller.config;

  bool? get defaultPopGesture => _getxController.defaultPopGesture;
  bool get defaultOpaqueRoute => _getxController.defaultOpaqueRoute;

  Transition? get defaultTransition => _getxController.defaultTransition;

  Duration get defaultTransitionDuration {
    return _getxController.defaultTransitionDuration;
  }

  Curve get defaultTransitionCurve => _getxController.defaultTransitionCurve;

  Curve get defaultDialogTransitionCurve {
    return _getxController.defaultDialogTransitionCurve;
  }

  Duration get defaultDialogTransitionDuration {
    return _getxController.defaultDialogTransitionDuration;
  }

  Routing get routing => _getxController.routing;

  bool get _shouldUseMock => GetTestMode.active && !GetRoot.treeInitialized;

  /// give current arguments
  dynamic get arguments {
    return args();
  }

  T args<T>() {
    if (_shouldUseMock) {
      return GetTestMode.arguments as T;
    }
    return rootController.rootDelegate.arguments<T>();
  }

  // set parameters(Map<String, String?> newParameters) {
  //   rootController.parameters = newParameters;
  // }

  // @Deprecated('Use GetTestMode.active=true instead')
  set testMode(bool isTest) => GetTestMode.active = isTest;

  // @Deprecated('Use GetTestMode.active instead')
  bool get testMode => GetTestMode.active;

  Map<String, String?> get parameters {
    if (_shouldUseMock) {
      return GetTestMode.parameters;
    }

    return rootController.rootDelegate.parameters;
  }

  /// Casts the stored router delegate to a desired type
  TDelegate? delegate<TDelegate extends RouterDelegate<TPage>, TPage>() =>
      _getxController.routerDelegate as TDelegate?;
}

extension OverlayExt on GetInterface {
  Future<T> showOverlay<T>({
    required Future<T> Function() asyncFunction,
    Color opacityColor = Colors.black,
    Widget? loadingWidget,
    double opacity = .5,
  }) async {
    final navigatorState =
        Navigator.of(Get.overlayContext!, rootNavigator: false);
    final overlayState = navigatorState.overlay!;

    final overlayEntryOpacity = OverlayEntry(builder: (context) {
      return Opacity(
          opacity: opacity,
          child: Container(
            color: opacityColor,
          ));
    });
    final overlayEntryLoader = OverlayEntry(builder: (context) {
      return loadingWidget ??
          const Center(
              child: SizedBox(
            height: 90,
            width: 90,
            child: Text('Loading...'),
          ));
    });
    overlayState.insert(overlayEntryOpacity);
    overlayState.insert(overlayEntryLoader);

    T data;

    try {
      data = await asyncFunction();
    } on Exception catch (_) {
      overlayEntryLoader.remove();
      overlayEntryOpacity.remove();
      rethrow;
    }

    overlayEntryLoader.remove();
    overlayEntryOpacity.remove();
    return data;
  }
}


--- File: lib/get_navigation/src/snackbar/snackbar_controller.dart ---
import 'dart:async';
import 'dart:math';
import 'dart:ui';

import 'package:flutter/material.dart';

import '../../../get.dart';
import '../root/get_root.dart';

class SnackbarController {
  final key = GlobalKey<GetSnackBarState>();

  static bool get isSnackbarBeingShown =>
      GetRootState.controller.config.snackBarQueue.isJobInProgress;

  late Animation<double> _filterBlurAnimation;
  late Animation<Color?> _filterColorAnimation;

  final GetSnackBar snackbar;
  final _transitionCompleter = Completer();

  late SnackbarStatusCallback? _snackbarStatus;
  late final Alignment? _initialAlignment;
  late final Alignment? _endAlignment;

  bool _wasDismissedBySwipe = false;

  bool _onTappedDismiss = false;

  Timer? _timer;

  /// The animation that drives the route's transition and the previous route's
  /// forward transition.
  late final Animation<Alignment> _animation;

  /// The animation controller that the route uses to drive the transitions.
  ///
  /// The animation itself is exposed by the [animation] property.
  late final AnimationController _controller;

  SnackbarStatus? _currentStatus;

  final _overlayEntries = <OverlayEntry>[];

  OverlayState? _overlayState;

  SnackbarController(this.snackbar);

  Future<void> get future => _transitionCompleter.future;

  /// Close the snackbar with animation
  Future<void> close({bool withAnimations = true}) async {
    if (!withAnimations) {
      _removeOverlay();
      return;
    }
    _removeEntry();
    await future;
  }

  /// Adds GetSnackbar to a view queue.
  /// Only one GetSnackbar will be displayed at a time, and this method returns
  /// a future to when the snackbar disappears.
  Future<void> show() {
    return GetRootState.controller.config.snackBarQueue.addJob(this);
  }

  void _cancelTimer() {
    if (_timer != null && _timer!.isActive) {
      _timer!.cancel();
    }
  }

  // ignore: avoid_returning_this
  void _configureAlignment(SnackPosition snackPosition) {
    switch (snackbar.snackPosition) {
      case SnackPosition.top:
        {
          _initialAlignment = const Alignment(-1.0, -2.0);
          _endAlignment = const Alignment(-1.0, -1.0);
          break;
        }
      case SnackPosition.bottom:
        {
          _initialAlignment = const Alignment(-1.0, 2.0);
          _endAlignment = const Alignment(-1.0, 1.0);
          break;
        }
    }
  }

  bool _isTesting = false;

  void _configureOverlay() {
    final overlayContext = Get.overlayContext;
    _isTesting = overlayContext == null;
    _overlayState =
        _isTesting ? OverlayState() : Overlay.of(Get.overlayContext!);
    _overlayEntries.clear();
    _overlayEntries.addAll(_createOverlayEntries(_getBodyWidget()));
    if (!_isTesting) {
      _overlayState!.insertAll(_overlayEntries);
    }

    _configureSnackBarDisplay();
  }

  void _configureSnackBarDisplay() {
    assert(!_transitionCompleter.isCompleted,
        'Cannot configure a snackbar after disposing it.');
    _controller = _createAnimationController();
    _configureAlignment(snackbar.snackPosition);
    _snackbarStatus = snackbar.snackbarStatus;
    _filterBlurAnimation = _createBlurFilterAnimation();
    _filterColorAnimation = _createColorOverlayColor();
    _animation = _createAnimation();
    _animation.addStatusListener(_handleStatusChanged);
    _configureTimer();
    _controller.forward();
  }

  void _configureTimer() {
    if (snackbar.duration != null) {
      if (_timer != null && _timer!.isActive) {
        _timer!.cancel();
      }
      _timer = Timer(snackbar.duration!, _removeEntry);
    } else {
      if (_timer != null) {
        _timer!.cancel();
      }
    }
  }

  /// Called to create the animation that exposes the current progress of
  /// the transition controlled by the animation controller created by
  /// `createAnimationController()`.
  Animation<Alignment> _createAnimation() {
    assert(!_transitionCompleter.isCompleted,
        'Cannot create a animation from a disposed snackbar');
    return AlignmentTween(begin: _initialAlignment, end: _endAlignment).animate(
      CurvedAnimation(
        parent: _controller,
        curve: snackbar.forwardAnimationCurve,
        reverseCurve: snackbar.reverseAnimationCurve,
      ),
    );
  }

  /// Called to create the animation controller that will drive the transitions
  /// to this route from the previous one, and back to the previous route
  /// from this one.
  AnimationController _createAnimationController() {
    assert(!_transitionCompleter.isCompleted,
        'Cannot create a animationController from a disposed snackbar');
    assert(snackbar.animationDuration >= Duration.zero);
    return AnimationController(
      duration: snackbar.animationDuration,
      debugLabel: '$runtimeType',
      vsync: _overlayState!,
    );
  }

  Animation<double> _createBlurFilterAnimation() {
    return Tween(begin: 0.0, end: snackbar.overlayBlur).animate(
      CurvedAnimation(
        parent: _controller,
        curve: const Interval(
          0.0,
          0.35,
          curve: Curves.easeInOutCirc,
        ),
      ),
    );
  }

  Animation<Color?> _createColorOverlayColor() {
    return ColorTween(
            begin: const Color(0x00000000), end: snackbar.overlayColor)
        .animate(
      CurvedAnimation(
        parent: _controller,
        curve: const Interval(
          0.0,
          0.35,
          curve: Curves.easeInOutCirc,
        ),
      ),
    );
  }

  Iterable<OverlayEntry> _createOverlayEntries(Widget child) {
    return <OverlayEntry>[
      if (snackbar.overlayBlur > 0.0) ...[
        OverlayEntry(
          builder: (context) => GestureDetector(
            onTap: () {
              if (snackbar.isDismissible && !_onTappedDismiss) {
                _onTappedDismiss = true;
                close();
              }
            },
            child: AnimatedBuilder(
              animation: _filterBlurAnimation,
              builder: (context, child) {
                return BackdropFilter(
                  filter: ImageFilter.blur(
                    sigmaX: max(0.001, _filterBlurAnimation.value),
                    sigmaY: max(0.001, _filterBlurAnimation.value),
                  ),
                  child: Container(
                    constraints: const BoxConstraints.expand(),
                    color: _filterColorAnimation.value,
                  ),
                );
              },
            ),
          ),
          maintainState: false,
          opaque: false,
        ),
      ],
      OverlayEntry(
        builder: (context) => Semantics(
          focused: false,
          container: true,
          explicitChildNodes: true,
          child: AlignTransition(
            alignment: _animation,
            child: snackbar.isDismissible
                ? _getDismissibleSnack(child)
                : _getSnackbarContainer(child),
          ),
        ),
        maintainState: false,
        opaque: false,
      ),
    ];
  }

  Widget _getBodyWidget() {
    return Builder(builder: (_) {
      return MouseRegion(
        onEnter: (_) =>
            snackbar.onHover?.call(snackbar, SnackHoverState.entered),
        onExit: (_) => snackbar.onHover?.call(snackbar, SnackHoverState.exited),
        child: GestureDetector(
          behavior: snackbar.hitTestBehavior ?? HitTestBehavior.deferToChild,
          onTap: snackbar.onTap != null
              ? () => snackbar.onTap?.call(snackbar)
              : null,
          child: snackbar,
        ),
      );
    });
  }

  DismissDirection _getDefaultDismissDirection() {
    if (snackbar.snackPosition == SnackPosition.top) {
      return DismissDirection.up;
    }
    return DismissDirection.down;
  }

  Widget _getDismissibleSnack(Widget child) {
    return Dismissible(
      behavior: snackbar.hitTestBehavior ?? HitTestBehavior.opaque,
      direction: snackbar.dismissDirection ?? _getDefaultDismissDirection(),
      resizeDuration: null,
      confirmDismiss: (_) {
        if (_currentStatus == SnackbarStatus.opening ||
            _currentStatus == SnackbarStatus.closing) {
          return Future.value(false);
        }
        return Future.value(true);
      },
      key: const Key('dismissible'),
      onDismissed: (_) {
        _wasDismissedBySwipe = true;
        _removeEntry();
      },
      child: _getSnackbarContainer(child),
    );
  }

  Widget _getSnackbarContainer(Widget child) {
    return Container(
      margin: snackbar.margin,
      child: child,
    );
  }

  void _handleStatusChanged(AnimationStatus status) {
    switch (status) {
      case AnimationStatus.completed:
        _currentStatus = SnackbarStatus.open;
        _snackbarStatus?.call(_currentStatus);
        if (_overlayEntries.isNotEmpty) _overlayEntries.first.opaque = false;

        break;
      case AnimationStatus.forward:
        _currentStatus = SnackbarStatus.opening;
        _snackbarStatus?.call(_currentStatus);
        break;
      case AnimationStatus.reverse:
        _currentStatus = SnackbarStatus.closing;
        _snackbarStatus?.call(_currentStatus);
        if (_overlayEntries.isNotEmpty) _overlayEntries.first.opaque = false;
        break;
      case AnimationStatus.dismissed:
        assert(!_overlayEntries.first.opaque);
        _currentStatus = SnackbarStatus.closed;
        _snackbarStatus?.call(_currentStatus);
        _removeOverlay();
        break;
    }
  }

  void _removeEntry() {
    assert(
      !_transitionCompleter.isCompleted,
      'Cannot remove entry from a disposed snackbar',
    );

    _cancelTimer();

    if (_wasDismissedBySwipe) {
      Timer(const Duration(milliseconds: 200), _controller.reset);
      _wasDismissedBySwipe = false;
    } else {
      _controller.reverse();
    }
  }

  void _removeOverlay() {
    if (!_isTesting) {
      for (var element in _overlayEntries) {
        element.remove();
      }
    }

    assert(!_transitionCompleter.isCompleted,
        'Cannot remove overlay from a disposed snackbar');
    _controller.dispose();
    _overlayEntries.clear();
    _transitionCompleter.complete();
  }

  Future<void> _show() {
    _configureOverlay();
    return future;
  }

  static Future<void> cancelAllSnackbars() async {
    await GetRootState.controller.config.snackBarQueue.cancelAllJobs();
  }

  static Future<void> closeCurrentSnackbar() async {
    await GetRootState.controller.config.snackBarQueue.closeCurrentJob();
  }
}

class SnackBarQueue {
  final _queue = GetQueue();
  final _snackbarList = <SnackbarController>[];

  SnackbarController? get _currentSnackbar {
    if (_snackbarList.isEmpty) return null;
    return _snackbarList.first;
  }

  bool get isJobInProgress => _snackbarList.isNotEmpty;

  Future<void> addJob(SnackbarController job) async {
    _snackbarList.add(job);
    final data = await _queue.add(job._show);
    _snackbarList.remove(job);
    return data;
  }

  Future<void> cancelAllJobs() async {
    await _currentSnackbar?.close();
    _queue.cancelAllJobs();
    _snackbarList.clear();
  }

  void disposeControllers() {
    if (_currentSnackbar != null) {
      _currentSnackbar?._removeOverlay();
      _currentSnackbar?._controller.dispose();
      _snackbarList.remove(_currentSnackbar);
    }

    _queue.cancelAllJobs();

    for (var element in _snackbarList) {
      element._controller.dispose();
    }
    _snackbarList.clear();
  }

  Future<void> closeCurrentJob() async {
    if (_currentSnackbar == null) return;
    await _currentSnackbar!.close();
  }
}


--- File: lib/get_navigation/src/snackbar/snackbar.dart ---
import 'dart:async';
import 'dart:ui';

import 'package:flutter/material.dart';

import '../../../get_core/get_core.dart';
import '../../get_navigation.dart';

typedef OnTap = void Function(GetSnackBar snack);
typedef OnHover = void Function(
    GetSnackBar snack, SnackHoverState snackHoverState);

typedef SnackbarStatusCallback = void Function(SnackbarStatus? status);

class GetSnackBar extends StatefulWidget {
  /// A callback for you to listen to the different Snack status
  final SnackbarStatusCallback? snackbarStatus;

  /// The title displayed to the user
  final String? title;

  /// Defines how the snack bar area, including margin, will behave during hit testing.
  ///
  /// If this property is null and [margin] is not null, then [HitTestBehavior.deferToChild] is used by default.
  ///
  /// Please refer to [HitTestBehavior] for a detailed explanation of every behavior.
  final HitTestBehavior? hitTestBehavior;

  /// The direction in which the SnackBar can be dismissed.
  ///
  /// Default is [DismissDirection.down] when
  /// [snackPosition] == [SnackPosition.BOTTOM] and [DismissDirection.up]
  /// when [snackPosition] == [SnackPosition.TOP]
  final DismissDirection? dismissDirection;

  /// The message displayed to the user.
  final String? message;

  /// Replaces [title]. Although this accepts a [Widget], it is meant
  /// to receive [Text] or [RichText]
  final Widget? titleText;

  /// Replaces [message]. Although this accepts a [Widget], it is meant
  /// to receive [Text] or  [RichText]
  final Widget? messageText;

  /// Will be ignored if [backgroundGradient] is not null
  final Color backgroundColor;

  /// If not null, shows a left vertical colored bar on notification.
  /// It is not possible to use it with a [Form] and I do not recommend
  /// using it with [LinearProgressIndicator]
  final Color? leftBarIndicatorColor;

  /// [boxShadows] The shadows generated by Snack. Leave it null
  /// if you don't want a shadow.
  /// You can use more than one if you feel the need.
  /// Check (this example)[https://github.com/flutter/flutter/blob/master/packages/flutter/lib/src/material/shadows.dart]
  final List<BoxShadow>? boxShadows;

  /// Give to GetSnackbar a gradient background.
  /// It Makes [backgroundColor] be ignored.
  final Gradient? backgroundGradient;

  /// You can use any widget here, but I recommend [Icon] or [Image] as
  /// indication of what kind
  /// of message you are displaying. Other widgets may break the layout
  final Widget? icon;

  /// An option to animate the icon (if present). Defaults to true.
  final bool shouldIconPulse;

  /// (optional) An action that the user can take based on the snack bar.
  ///
  /// For example, the snack bar might let the user undo the operation that
  /// prompted the snackbar.
  final Widget? mainButton;

  /// A callback that registers the user's click anywhere.
  /// An alternative to [mainButton]
  final OnTap? onTap;

  /// A callback that registers the user's hover anywhere over the Snackbar.
  final OnHover? onHover;

  /// How long until Snack will hide itself (be dismissed).
  /// To make it indefinite, leave it null.
  final Duration? duration;

  /// True if you want to show a [LinearProgressIndicator].
  final bool showProgressIndicator;

  /// An optional [AnimationController] when you want to control the
  /// progress of your [LinearProgressIndicator].
  final AnimationController? progressIndicatorController;

  /// A [LinearProgressIndicator] configuration parameter.
  final Color? progressIndicatorBackgroundColor;

  /// A [LinearProgressIndicator] configuration parameter.
  final Animation<Color>? progressIndicatorValueColor;

  /// Determines if the user can swipe or click the overlay
  /// (if [overlayBlur] > 0) to dismiss.
  /// It is recommended that you set [duration] != null if this is false.
  /// If the user swipes to dismiss or clicks the overlay, no value
  /// will be returned.
  final bool isDismissible;

  /// Used to limit Snack width (usually on large screens)
  final double? maxWidth;

  /// Adds a custom margin to Snack
  final EdgeInsets margin;

  /// Adds a custom padding to Snack
  /// The default follows material design guide line
  final EdgeInsets padding;

  /// Adds a radius to all corners of Snack. Best combined with [margin].
  /// I do not recommend using it with [showProgressIndicator]
  /// or [leftBarIndicatorColor].
  final double borderRadius;

  /// Adds a border to every side of Snack
  /// I do not recommend using it with [showProgressIndicator]
  /// or [leftBarIndicatorColor].
  final Color? borderColor;

  /// Changes the width of the border if [borderColor] is specified
  final double? borderWidth;

  /// Snack can be based on [SnackPosition.TOP] or on [SnackPosition.BOTTOM]
  /// of your screen.
  /// [SnackPosition.BOTTOM] is the default.
  final SnackPosition snackPosition;

  /// Snack can be floating or be grounded to the edge of the screen.
  /// If grounded, I do not recommend using [margin] or [borderRadius].
  /// [SnackStyle.FLOATING] is the default
  /// If grounded, I do not recommend using a [backgroundColor] with
  /// transparency or [barBlur]
  final SnackStyle snackStyle;

  /// The [Curve] animation used when show() is called.
  /// [Curves.easeOut] is default
  final Curve forwardAnimationCurve;

  /// The [Curve] animation used when dismiss() is called.
  /// [Curves.fastOutSlowIn] is default
  final Curve reverseAnimationCurve;

  /// Use it to speed up or slow down the animation duration
  final Duration animationDuration;

  /// Default is 0.0. If different than 0.0, blurs only Snack's background.
  /// To take effect, make sure your [backgroundColor] has some opacity.
  /// The greater the value, the greater the blur.
  final double barBlur;

  /// Default is 0.0. If different than 0.0, creates a blurred
  /// overlay that prevents the user from interacting with the screen.
  /// The greater the value, the greater the blur.
  final double overlayBlur;

  /// Default is [Colors.transparent]. Only takes effect if [overlayBlur] > 0.0.
  /// Make sure you use a color with transparency here e.g.
  /// Colors.grey[600].withValues(alpha:0.2).
  final Color? overlayColor;

  /// A [TextFormField] in case you want a simple user input.
  /// Every other widget is ignored if this is not null.
  final Form? userInputForm;

  const GetSnackBar({
    super.key,
    this.title,
    this.message,
    this.titleText,
    this.messageText,
    this.icon,
    this.shouldIconPulse = true,
    this.maxWidth,
    this.margin = const EdgeInsets.all(0.0),
    this.padding = const EdgeInsets.all(16),
    this.borderRadius = 0.0,
    this.borderColor,
    this.borderWidth = 1.0,
    this.backgroundColor = const Color(0xFF303030),
    this.leftBarIndicatorColor,
    this.boxShadows,
    this.backgroundGradient,
    this.mainButton,
    this.onTap,
    this.onHover,
    this.duration,
    this.isDismissible = true,
    this.dismissDirection,
    this.showProgressIndicator = false,
    this.progressIndicatorController,
    this.progressIndicatorBackgroundColor,
    this.progressIndicatorValueColor,
    this.snackPosition = SnackPosition.bottom,
    this.snackStyle = SnackStyle.floating,
    this.forwardAnimationCurve = Curves.easeOutCirc,
    this.reverseAnimationCurve = Curves.easeOutCirc,
    this.animationDuration = const Duration(seconds: 1),
    this.barBlur = 0.0,
    this.overlayBlur = 0.0,
    this.overlayColor = Colors.transparent,
    this.userInputForm,
    this.snackbarStatus,
    this.hitTestBehavior,
  });

  @override
  State createState() => GetSnackBarState();

  /// Show the snack. It's call [SnackbarStatus.OPENING] state
  /// followed by [SnackbarStatus.OPEN]
  SnackbarController show() {
    return Get.showSnackbar(this);
  }
}

class GetSnackBarState extends State<GetSnackBar>
    with TickerProviderStateMixin {
  AnimationController? _fadeController;
  late Animation<double> _fadeAnimation;

  final Widget _emptyWidget = const SizedBox(width: 0.0, height: 0.0);
  final double _initialOpacity = 1.0;
  final double _finalOpacity = 0.4;

  final Duration _pulseAnimationDuration = const Duration(seconds: 1);

  late bool _isTitlePresent;
  late double _messageTopMargin;

  FocusScopeNode? _focusNode;
  late FocusAttachment _focusAttachment;

  final Completer<Size> _boxHeightCompleter = Completer<Size>();

  late CurvedAnimation _progressAnimation;

  final _backgroundBoxKey = GlobalKey();

  double get buttonPadding {
    if (widget.padding.right - 12 < 0) {
      return 4;
    } else {
      return widget.padding.right - 12;
    }
  }

  RowStyle get _rowStyle {
    if (widget.mainButton != null && widget.icon == null) {
      return RowStyle.action;
    } else if (widget.mainButton == null && widget.icon != null) {
      return RowStyle.icon;
    } else if (widget.mainButton != null && widget.icon != null) {
      return RowStyle.all;
    } else {
      return RowStyle.none;
    }
  }

  @override
  Widget build(BuildContext context) {
    return Align(
      heightFactor: 1.0,
      child: Material(
        color: widget.snackStyle == SnackStyle.floating
            ? Colors.transparent
            : widget.backgroundColor,
        child: SafeArea(
          minimum: widget.snackPosition == SnackPosition.bottom
              ? EdgeInsets.only(
                  bottom: MediaQuery.of(context).viewInsets.bottom)
              : EdgeInsets.only(top: MediaQuery.of(context).padding.top),
          bottom: widget.snackPosition == SnackPosition.bottom,
          top: widget.snackPosition == SnackPosition.top,
          left: false,
          right: false,
          child: Stack(
            children: [
              FutureBuilder<Size>(
                future: _boxHeightCompleter.future,
                builder: (context, snapshot) {
                  if (snapshot.hasData) {
                    if (widget.barBlur == 0) {
                      return _emptyWidget;
                    }
                    return ClipRRect(
                      borderRadius: BorderRadius.circular(widget.borderRadius),
                      child: BackdropFilter(
                        filter: ImageFilter.blur(
                            sigmaX: widget.barBlur, sigmaY: widget.barBlur),
                        child: Container(
                          height: snapshot.data!.height,
                          width: snapshot.data!.width,
                          decoration: BoxDecoration(
                            color: Colors.transparent,
                            borderRadius:
                                BorderRadius.circular(widget.borderRadius),
                          ),
                        ),
                      ),
                    );
                  } else {
                    return _emptyWidget;
                  }
                },
              ),
              if (widget.userInputForm != null)
                _containerWithForm()
              else
                _containerWithoutForm()
            ],
          ),
        ),
      ),
    );
  }

  @override
  void dispose() {
    _fadeController?.dispose();
    widget.progressIndicatorController?.removeListener(_updateProgress);
    widget.progressIndicatorController?.dispose();

    _focusAttachment.detach();
    _focusNode!.dispose();
    super.dispose();
  }

  @override
  void initState() {
    super.initState();

    assert(
        widget.userInputForm != null ||
            ((widget.message != null && widget.message!.isNotEmpty) ||
                widget.messageText != null),
        '''
You need to either use message[String], or messageText[Widget] or define a userInputForm[Form] in GetSnackbar''');

    _isTitlePresent = (widget.title != null || widget.titleText != null);
    _messageTopMargin = _isTitlePresent ? 6.0 : widget.padding.top;

    _configureLeftBarFuture();
    _configureProgressIndicatorAnimation();

    if (widget.icon != null && widget.shouldIconPulse) {
      _configurePulseAnimation();
      _fadeController?.forward();
    }

    _focusNode = FocusScopeNode();
    _focusAttachment = _focusNode!.attach(context);
  }

  Widget _buildLeftBarIndicator() {
    if (widget.leftBarIndicatorColor != null) {
      return FutureBuilder<Size>(
        future: _boxHeightCompleter.future,
        builder: (buildContext, snapshot) {
          if (snapshot.hasData) {
            return Container(
              color: widget.leftBarIndicatorColor,
              width: 5.0,
              height: snapshot.data!.height,
            );
          } else {
            return _emptyWidget;
          }
        },
      );
    } else {
      return _emptyWidget;
    }
  }

  void _configureLeftBarFuture() {
    Engine.instance.addPostFrameCallback(
      (_) {
        final keyContext = _backgroundBoxKey.currentContext;
        if (keyContext != null) {
          final box = keyContext.findRenderObject() as RenderBox;
          _boxHeightCompleter.complete(box.size);
        }
      },
    );
  }

  void _configureProgressIndicatorAnimation() {
    if (widget.showProgressIndicator &&
        widget.progressIndicatorController != null) {
      widget.progressIndicatorController!.addListener(_updateProgress);

      _progressAnimation = CurvedAnimation(
          curve: Curves.linear, parent: widget.progressIndicatorController!);
    }
  }

  void _configurePulseAnimation() {
    _fadeController =
        AnimationController(vsync: this, duration: _pulseAnimationDuration);
    _fadeAnimation = Tween(begin: _initialOpacity, end: _finalOpacity).animate(
      CurvedAnimation(
        parent: _fadeController!,
        curve: Curves.linear,
      ),
    );

    _fadeController!.addStatusListener((status) {
      if (status == AnimationStatus.completed) {
        _fadeController!.reverse();
      }
      if (status == AnimationStatus.dismissed) {
        _fadeController!.forward();
      }
    });

    _fadeController!.forward();
  }

  Widget _containerWithForm() {
    return Container(
      key: _backgroundBoxKey,
      constraints: widget.maxWidth != null
          ? BoxConstraints(maxWidth: widget.maxWidth!)
          : null,
      decoration: BoxDecoration(
        color: widget.backgroundColor,
        gradient: widget.backgroundGradient,
        boxShadow: widget.boxShadows,
        borderRadius: BorderRadius.circular(widget.borderRadius),
        border: widget.borderColor != null
            ? Border.all(
                color: widget.borderColor!,
                width: widget.borderWidth!,
              )
            : null,
      ),
      child: Padding(
        padding: const EdgeInsets.only(
            left: 8.0, right: 8.0, bottom: 8.0, top: 16.0),
        child: FocusScope(
          node: _focusNode,
          autofocus: true,
          child: widget.userInputForm!,
        ),
      ),
    );
  }

  Widget _containerWithoutForm() {
    final iconPadding = widget.padding.left > 16.0 ? widget.padding.left : 0.0;
    final left = _rowStyle == RowStyle.icon || _rowStyle == RowStyle.all
        ? 4.0
        : widget.padding.left;
    final right = _rowStyle == RowStyle.action || _rowStyle == RowStyle.all
        ? 8.0
        : widget.padding.right;
    return Container(
      key: _backgroundBoxKey,
      constraints: widget.maxWidth != null
          ? BoxConstraints(maxWidth: widget.maxWidth!)
          : null,
      decoration: BoxDecoration(
        color: widget.backgroundColor,
        gradient: widget.backgroundGradient,
        boxShadow: widget.boxShadows,
        borderRadius: BorderRadius.circular(widget.borderRadius),
        border: widget.borderColor != null
            ? Border.all(color: widget.borderColor!, width: widget.borderWidth!)
            : null,
      ),
      child: Column(
        mainAxisSize: MainAxisSize.min,
        children: [
          widget.showProgressIndicator
              ? LinearProgressIndicator(
                  value: widget.progressIndicatorController != null
                      ? _progressAnimation.value
                      : null,
                  backgroundColor: widget.progressIndicatorBackgroundColor,
                  valueColor: widget.progressIndicatorValueColor,
                )
              : _emptyWidget,
          Row(
            mainAxisSize: MainAxisSize.max,
            children: [
              _buildLeftBarIndicator(),
              if (_rowStyle == RowStyle.icon || _rowStyle == RowStyle.all)
                ConstrainedBox(
                  constraints:
                      BoxConstraints.tightFor(width: 42.0 + iconPadding),
                  child: _getIcon(),
                ),
              Expanded(
                flex: 1,
                child: Column(
                  crossAxisAlignment: CrossAxisAlignment.stretch,
                  mainAxisSize: MainAxisSize.min,
                  children: <Widget>[
                    if (_isTitlePresent)
                      Padding(
                        padding: EdgeInsets.only(
                          top: widget.padding.top,
                          left: left,
                          right: right,
                        ),
                        child: widget.titleText ??
                            Text(
                              widget.title ?? "",
                              style: const TextStyle(
                                fontSize: 16.0,
                                color: Colors.white,
                                fontWeight: FontWeight.bold,
                              ),
                            ),
                      )
                    else
                      _emptyWidget,
                    Padding(
                      padding: EdgeInsets.only(
                        top: _messageTopMargin,
                        left: left,
                        right: right,
                        bottom: widget.padding.bottom,
                      ),
                      child: widget.messageText ??
                          Text(
                            widget.message ?? "",
                            style: const TextStyle(
                                fontSize: 14.0, color: Colors.white),
                          ),
                    ),
                  ],
                ),
              ),
              if (_rowStyle == RowStyle.action || _rowStyle == RowStyle.all)
                Padding(
                  padding: EdgeInsets.only(right: buttonPadding),
                  child: widget.mainButton,
                ),
            ],
          ),
        ],
      ),
    );
  }

  Widget? _getIcon() {
    if (widget.icon != null && widget.icon is Icon && widget.shouldIconPulse) {
      return FadeTransition(
        opacity: _fadeAnimation,
        child: widget.icon,
      );
    } else if (widget.icon != null) {
      return widget.icon;
    } else {
      return _emptyWidget;
    }
  }

  void _updateProgress() => setState(() {});
}

enum RowStyle {
  icon,
  action,
  all,
  none,
}

/// Indicates Status of snackbar
/// [SnackbarStatus.OPEN] Snack is fully open, [SnackbarStatus.CLOSED] Snackbar
/// has closed,
/// [SnackbarStatus.OPENING] Starts with the opening animation and ends
/// with the full
/// snackbar display, [SnackbarStatus.CLOSING] Starts with the closing animation
/// and ends
/// with the full snackbar dispose
enum SnackbarStatus { open, closed, opening, closing }

/// Indicates if snack is going to start at the [TOP] or at the [BOTTOM]
enum SnackPosition { top, bottom }

/// Indicates if snack will be attached to the edge of the screen or not
enum SnackStyle { floating, grounded }

/// Indicates if the mouse entered or exited
enum SnackHoverState { entered, exited }


--- File: lib/get_navigation/src/dialog/dialog_route.dart ---
import 'package:flutter/widgets.dart';

import '../router_report.dart';

class GetDialogRoute<T> extends PopupRoute<T> {
  GetDialogRoute({
    required RoutePageBuilder pageBuilder,
    bool barrierDismissible = true,
    String? barrierLabel,
    Color barrierColor = const Color(0x80000000),
    Duration transitionDuration = const Duration(milliseconds: 200),
    RouteTransitionsBuilder? transitionBuilder,
    super.settings,
  })  : widget = pageBuilder,
        _barrierDismissible = barrierDismissible,
        _barrierLabel = barrierLabel,
        _barrierColor = barrierColor,
        _transitionDuration = transitionDuration,
        _transitionBuilder = transitionBuilder {
    RouterReportManager.instance.reportCurrentRoute(this);
  }

  final RoutePageBuilder widget;

  @override
  bool get barrierDismissible => _barrierDismissible;
  final bool _barrierDismissible;

  @override
  void dispose() {
    RouterReportManager.instance.reportRouteDispose(this);
    super.dispose();
  }

  @override
  String? get barrierLabel => _barrierLabel;
  final String? _barrierLabel;

  @override
  Color get barrierColor => _barrierColor;
  final Color _barrierColor;

  @override
  Duration get transitionDuration => _transitionDuration;
  final Duration _transitionDuration;

  final RouteTransitionsBuilder? _transitionBuilder;

  @override
  Widget buildPage(BuildContext context, Animation<double> animation,
      Animation<double> secondaryAnimation) {
    return Semantics(
      scopesRoute: true,
      explicitChildNodes: true,
      child: widget(context, animation, secondaryAnimation),
    );
  }

  @override
  Widget buildTransitions(BuildContext context, Animation<double> animation,
      Animation<double> secondaryAnimation, Widget child) {
    if (_transitionBuilder == null) {
      return FadeTransition(
          opacity: CurvedAnimation(
            parent: animation,
            curve: Curves.linear,
          ),
          child: child);
    } // Some default transition
    return _transitionBuilder(context, animation, secondaryAnimation, child);
  }
}


--- File: lib/get_navigation/src/bottomsheet/bottomsheet.dart ---
import 'package:flutter/material.dart';

import '../../../get.dart';
import '../router_report.dart';

class GetModalBottomSheetRoute<T> extends PopupRoute<T> {
  GetModalBottomSheetRoute({
    this.builder,
    this.theme,
    this.barrierLabel,
    this.backgroundColor,
    this.isPersistent,
    this.elevation,
    this.shape,
    this.removeTop = true,
    this.clipBehavior,
    this.modalBarrierColor,
    this.isDismissible = true,
    this.enableDrag = true,
    required this.isScrollControlled,
    super.settings,
    this.enterBottomSheetDuration = const Duration(milliseconds: 250),
    this.exitBottomSheetDuration = const Duration(milliseconds: 200),
    this.curve,
  }) {
    RouterReportManager.instance.reportCurrentRoute(this);
  }
  final bool? isPersistent;
  final WidgetBuilder? builder;
  final ThemeData? theme;
  final bool isScrollControlled;
  final Color? backgroundColor;
  final double? elevation;
  final ShapeBorder? shape;
  final Clip? clipBehavior;
  final Color? modalBarrierColor;
  final bool isDismissible;
  final bool enableDrag;
  // final String name;
  final Duration enterBottomSheetDuration;
  final Duration exitBottomSheetDuration;
  final Curve? curve;
  // remove safearea from top
  final bool removeTop;

  @override
  Duration get transitionDuration => const Duration(milliseconds: 700);

  @override
  bool get barrierDismissible => isDismissible;

  @override
  final String? barrierLabel;

  @override
  Color get barrierColor => modalBarrierColor ?? Colors.black54;

  AnimationController? _animationController;

  @override
  void dispose() {
    RouterReportManager.instance.reportRouteDispose(this);
    super.dispose();
  }

  @override
  Animation<double> createAnimation() {
    if (curve != null) {
      return CurvedAnimation(curve: curve!, parent: _animationController!.view);
    }
    return _animationController!.view;
  }

  @override
  AnimationController createAnimationController() {
    assert(_animationController == null);
    _animationController =
        BottomSheet.createAnimationController(navigator!.overlay!);
    _animationController!.duration = enterBottomSheetDuration;
    _animationController!.reverseDuration = exitBottomSheetDuration;
    return _animationController!;
  }

  @override
  Widget buildPage(BuildContext context, Animation<double> animation,
      Animation<double> secondaryAnimation) {
    final sheetTheme =
        theme?.bottomSheetTheme ?? Theme.of(context).bottomSheetTheme;
    // By definition, the bottom sheet is aligned to the bottom of the page
    // and isn't exposed to the top padding of the MediaQuery.
    Widget bottomSheet = MediaQuery.removePadding(
      context: context,
      removeTop: removeTop,
      child: Padding(
        padding:
            EdgeInsets.only(bottom: MediaQuery.of(context).viewInsets.bottom),
        child: _GetModalBottomSheet<T>(
          route: this,
          backgroundColor: backgroundColor ??
              sheetTheme.modalBackgroundColor ??
              sheetTheme.backgroundColor,
          elevation:
              elevation ?? sheetTheme.modalElevation ?? sheetTheme.elevation,
          shape: shape,
          clipBehavior: clipBehavior,
          isScrollControlled: isScrollControlled,
          enableDrag: enableDrag,
        ),
      ),
    );
    if (theme != null) bottomSheet = Theme(data: theme!, child: bottomSheet);
    return bottomSheet;
  }
}

class _GetModalBottomSheet<T> extends StatefulWidget {
  const _GetModalBottomSheet({
    super.key,
    this.route,
    this.backgroundColor,
    this.elevation,
    this.shape,
    this.clipBehavior,
    this.isScrollControlled = false,
    this.enableDrag = true,
    this.isPersistent = false,
  });
  final bool isPersistent;
  final GetModalBottomSheetRoute<T>? route;
  final bool isScrollControlled;
  final Color? backgroundColor;
  final double? elevation;
  final ShapeBorder? shape;
  final Clip? clipBehavior;
  final bool enableDrag;

  @override
  _GetModalBottomSheetState<T> createState() => _GetModalBottomSheetState<T>();
}

class _GetModalBottomSheetState<T> extends State<_GetModalBottomSheet<T>> {
  String _getRouteLabel(MaterialLocalizations localizations) {
    if ((Theme.of(context).platform == TargetPlatform.android) ||
        (Theme.of(context).platform == TargetPlatform.fuchsia)) {
      return localizations.dialogLabel;
    } else {
      return '';
    }
  }

  @override
  Widget build(BuildContext context) {
    assert(debugCheckHasMediaQuery(context));
    assert(debugCheckHasMaterialLocalizations(context));
    final mediaQuery = MediaQuery.of(context);
    final localizations = MaterialLocalizations.of(context);
    final routeLabel = _getRouteLabel(localizations);

    return AnimatedBuilder(
      animation: widget.route!.animation!,
      builder: (context, child) {
        // Disable the initial animation when accessible navigation is on so
        // that the semantics are added to the tree at the correct time.
        final animationValue = mediaQuery.accessibleNavigation
            ? 1.0
            : widget.route!.animation!.value;
        return Semantics(
          scopesRoute: true,
          namesRoute: true,
          label: routeLabel,
          explicitChildNodes: true,
          child: ClipRect(
            child: CustomSingleChildLayout(
                delegate: _GetModalBottomSheetLayout(
                    animationValue, widget.isScrollControlled),
                child: widget.isPersistent == false
                    ? BottomSheet(
                        animationController: widget.route!._animationController,
                        onClosing: () {
                          if (widget.route!.isCurrent) {
                            Navigator.pop(context);
                          }
                        },
                        builder: widget.route!.builder!,
                        backgroundColor: widget.backgroundColor,
                        elevation: widget.elevation,
                        shape: widget.shape,
                        clipBehavior: widget.clipBehavior,
                        enableDrag: widget.enableDrag,
                      )
                    : Scaffold(
                        bottomSheet: BottomSheet(
                          animationController:
                              widget.route!._animationController,
                          onClosing: () {
                            // if (widget.route.isCurrent) {
                            //   Navigator.pop(context);
                            // }
                          },
                          builder: widget.route!.builder!,
                          backgroundColor: widget.backgroundColor,
                          elevation: widget.elevation,
                          shape: widget.shape,
                          clipBehavior: widget.clipBehavior,
                          enableDrag: widget.enableDrag,
                        ),
                      )),
          ),
        );
      },
    );
  }
}

class _GetPerModalBottomSheet<T> extends StatefulWidget {
  const _GetPerModalBottomSheet({
    super.key,
    this.route,
    this.isPersistent,
    this.backgroundColor,
    this.elevation,
    this.shape,
    this.clipBehavior,
    this.isScrollControlled = false,
    this.enableDrag = true,
  });
  final bool? isPersistent;
  final GetModalBottomSheetRoute<T>? route;
  final bool isScrollControlled;
  final Color? backgroundColor;
  final double? elevation;
  final ShapeBorder? shape;
  final Clip? clipBehavior;
  final bool enableDrag;

  @override
  // ignore: lines_longer_than_80_chars
  _GetPerModalBottomSheetState<T> createState() =>
      _GetPerModalBottomSheetState<T>();
}

// ignore: lines_longer_than_80_chars
class _GetPerModalBottomSheetState<T>
    extends State<_GetPerModalBottomSheet<T>> {
  String _getRouteLabel(MaterialLocalizations localizations) {
    if ((Theme.of(context).platform == TargetPlatform.android) ||
        (Theme.of(context).platform == TargetPlatform.fuchsia)) {
      return localizations.dialogLabel;
    } else {
      return '';
    }
  }

  @override
  Widget build(BuildContext context) {
    assert(debugCheckHasMediaQuery(context));
    assert(debugCheckHasMaterialLocalizations(context));
    final mediaQuery = MediaQuery.of(context);
    final localizations = MaterialLocalizations.of(context);
    final routeLabel = _getRouteLabel(localizations);

    return AnimatedBuilder(
      animation: widget.route!.animation!,
      builder: (context, child) {
        // Disable the initial animation when accessible navigation is on so
        // that the semantics are added to the tree at the correct time.
        final animationValue = mediaQuery.accessibleNavigation
            ? 1.0
            : widget.route!.animation!.value;
        return Semantics(
          scopesRoute: true,
          namesRoute: true,
          label: routeLabel,
          explicitChildNodes: true,
          child: ClipRect(
            child: CustomSingleChildLayout(
                delegate: _GetModalBottomSheetLayout(
                    animationValue, widget.isScrollControlled),
                child: widget.isPersistent == false
                    ? BottomSheet(
                        animationController: widget.route!._animationController,
                        onClosing: () {
                          if (widget.route!.isCurrent) {
                            Navigator.pop(context);
                          }
                        },
                        builder: widget.route!.builder!,
                        backgroundColor: widget.backgroundColor,
                        elevation: widget.elevation,
                        shape: widget.shape,
                        clipBehavior: widget.clipBehavior,
                        enableDrag: widget.enableDrag,
                      )
                    : Scaffold(
                        bottomSheet: BottomSheet(
                          animationController:
                              widget.route!._animationController,
                          onClosing: () {
                            // if (widget.route.isCurrent) {
                            //   Navigator.pop(context);
                            // }
                          },
                          builder: widget.route!.builder!,
                          backgroundColor: widget.backgroundColor,
                          elevation: widget.elevation,
                          shape: widget.shape,
                          clipBehavior: widget.clipBehavior,
                          enableDrag: widget.enableDrag,
                        ),
                      )),
          ),
        );
      },
    );
  }
}

class _GetModalBottomSheetLayout extends SingleChildLayoutDelegate {
  _GetModalBottomSheetLayout(this.progress, this.isScrollControlled);

  final double progress;
  final bool isScrollControlled;

  @override
  BoxConstraints getConstraintsForChild(BoxConstraints constraints) {
    return BoxConstraints(
      minWidth: constraints.maxWidth,
      maxWidth: constraints.maxWidth,
      minHeight: 0.0,
      maxHeight: isScrollControlled
          ? constraints.maxHeight
          : constraints.maxHeight * 9.0 / 16.0,
    );
  }

  @override
  Offset getPositionForChild(Size size, Size childSize) {
    return Offset(0.0, size.height - childSize.height * progress);
  }

  @override
  bool shouldRelayout(_GetModalBottomSheetLayout oldDelegate) {
    return progress != oldDelegate.progress;
  }
}


Instructions for the chapter (Generate content in English unless specified otherwise):
- Start with a clear heading (e.g., `# Chapter 4: Overlay Management (Snackbar, Dialog, BottomSheet)
`). Use the provided concept name.

- If this is not the first chapter, begin with a brief transition from the previous chapter, referencing it with a proper Markdown link using its name.

- Begin with a high-level motivation explaining what problem this abstraction solves. Start with a central use case as a concrete example. The whole chapter should guide the reader to understand how to solve this use case. Make it very minimal and friendly to beginners.

- If the abstraction is complex, break it down into key concepts. Explain each concept one-by-one in a very beginner-friendly way.

- Explain how to use this abstraction to solve the use case. Give example inputs and outputs for code snippets (if the output isn't values, describe at a high level what will happen).

- Each code block should be BELOW 10 lines! If longer code blocks are needed, break them down into smaller pieces and walk through them one-by-one. Aggresively simplify the code to make it minimal. Use comments to skip non-important implementation details. Each code block should have a beginner friendly explanation right after it.

- Describe the internal implementation to help understand what's under the hood. First provide a non-code or code-light walkthrough on what happens step-by-step when the abstraction is called. It's recommended to use a simple sequenceDiagram with a dummy example - keep it minimal with at most 5 participants to ensure clarity. If participant name has space, use: `participant QP as Query Processing`. .

- Then dive deeper into code for the internal implementation with references to files. Provide example code blocks, but make them similarly simple and beginner-friendly. Explain.

- IMPORTANT: When you need to refer to other core abstractions covered in other chapters, ALWAYS use proper Markdown links like this: [Chapter Title](filename.md). Use the Complete Tutorial Structure above to find the correct filename and the chapter title. Translate the surrounding text.

- Use mermaid diagrams to illustrate complex concepts (```mermaid``` format). .

- Heavily use analogies and examples throughout to help beginners understand.

- End the chapter with a brief conclusion that summarizes what was learned and provides a transition to the next chapter. If there is a next chapter, use a proper Markdown link: [Next Chapter Title](next_chapter_filename).

- Ensure the tone is welcoming and easy for a newcomer to understand.

- Output *only* the Markdown content for this chapter.

Now, directly provide a super beginner-friendly Markdown output (DON'T need ```markdown``` tags):

2025-05-16 11:09:03,025 - INFO - RESPONSE: # Chapter 4: Overlay Management (Snackbar, Dialog, BottomSheet)

Welcome back! In [Chapter 3: GetPage & GetRouterDelegate](03_getpage___getrouterdelegate__.md), we learned how to structure our app's navigation with named routes using `GetPage`. Now, let's explore another incredibly handy feature of GetX: managing temporary UI elements like snackbars, dialogs, and bottom sheets, all without needing to pass `BuildContext` around!

## What are Overlays? The Hotel Concierge Analogy

Imagine you're staying in a fancy hotel (your app). You're comfortably in your room (your current screen). Sometimes, you need quick services or information without having to leave your room or go to a completely new part of the hotel. This is where the hotel concierge comes in handy!

In GetX, overlay management is like having a super-efficient concierge service for your app. You can request:
*   A **quick note delivered to you** (a **Snackbar**): A brief message that appears temporarily, usually at the top or bottom of the screen, to give you a quick update (e.g., "Message sent!").
*   To **arrange a private meeting in a temporary room** (a **Dialog**): A pop-up window that requires your attention before you can continue interacting with your current screen. Useful for alerts, confirmations, or quick forms.
*   To **pull up a special information panel from below** (a **BottomSheet**): A panel that slides up from the bottom of the screen, offering more detailed options or information related to the current context.

These are all "overlays"—UI elements that appear *on top* of your current page without completely replacing it. GetX makes showing these incredibly simple.

## GetX's Superpower: Context-less Overlays

As we saw in [Chapter 2: GetNavigation Extensions (e.g., Get.toNamed, Get.snackbar)](02_getnavigation_extensions__e_g___get_tonamed__get_snackbar__.md), one of GetX's main advantages is allowing you to trigger navigation and UI elements from anywhere in your code, often without needing `BuildContext`. This is especially true for overlays!

Thanks to the setup with `GetMaterialApp` (covered in [Chapter 1: GetMaterialApp / GetCupertinoApp & GetRoot](01_getmaterialapp___getcupertinoapp___getroot_.md)), GetX has access to the necessary "hooks" to display these overlays globally.

Let's see how to use our "concierge" (`Get`) to request these services.

### 1. Quick Notes: `Get.snackbar()`

Need to show a user a quick, non-intrusive message? `Get.snackbar()` is your friend. It's like asking the concierge to slip a small note under your door.

```dart
// In any button's onPressed, or anywhere in your logic:
ElevatedButton(
  onPressed: () {
    Get.snackbar(
      "Notification", // Title of the snackbar
      "Your profile was updated successfully!", // Message
      snackPosition: SnackPosition.BOTTOM, // Where it appears
      backgroundColor: Colors.green,
      colorText: Colors.white,
    );
  },
  child: Text('Update Profile & Show Snackbar'),
)
```
**What happens?**
Tapping this button will display a green snackbar at the bottom of the screen with the title "Notification" and your message. It will automatically dismiss after a few seconds.

**Behind the Scenes (Briefly):**
GetX uses a `SnackbarController` to manage these requests. If you call `Get.snackbar()` multiple times quickly, `SnackbarController` acts like the concierge's assistant, queuing up the notes and delivering them one by one, so they don't all appear at once and clutter the screen.

### 2. Private Meetings: `Get.dialog()`

Sometimes you need to grab the user's full attention for an important choice or piece of information. This is like asking the concierge to book a small, private meeting room (a Dialog). The user must interact with the dialog (e.g., press "OK" or "Cancel") before returning to their main room (screen).

```dart
// In any button's onPressed:
ElevatedButton(
  onPressed: () {
    Get.dialog(
      AlertDialog(
        title: Text('Confirm Action'),
        content: Text('Are you sure you want to delete this item?'),
        actions: [
          TextButton(onPressed: () => Get.back(), child: Text('Cancel')),
          TextButton(onPressed: () { /* delete logic */ Get.back(); }, child: Text('Delete')),
        ],
      ),
    );
  },
  child: Text('Delete Item (Show Dialog)'),
)
```
**What happens?**
Tapping this button will display a standard Material Design alert dialog in the middle of the screen. The background will be dimmed, and the user must tap "Cancel" or "Delete" to close the dialog. `Get.back()` is used here to close the dialog.

### 3. Special Info Panels: `Get.bottomSheet()`

For presenting a list of options or a bit more information without being as intrusive as a full dialog, a bottom sheet is perfect. It's like the concierge pulling up a neat information panel from a compartment below your desk.

```dart
// In any button's onPressed:
ElevatedButton(
  onPressed: () {
    Get.bottomSheet(
      Container(
        height: 200,
        color: Colors.blueGrey,
        child: Column(
          mainAxisAlignment: MainAxisAlignment.center,
          children: [
            ListTile(leading: Icon(Icons.share, color: Colors.white), title: Text('Share', style: TextStyle(color: Colors.white)), onTap: () => Get.back()),
            ListTile(leading: Icon(Icons.copy, color: Colors.white), title: Text('Copy Link', style: TextStyle(color: Colors.white)), onTap: () => Get.back()),
          ],
        ),
      ),
      // Optional: make it non-dismissible by dragging
      // isDismissible: false, 
    );
  },
  child: Text('Show Options (BottomSheet)'),
)
```
**What happens?**
Tapping this button will cause a panel to slide up from the bottom of the screen. This panel contains our "Share" and "Copy Link" options. Tapping an option (or outside the sheet, if dismissible) will close it. `Get.back()` closes the bottom sheet here.

## How Does GetX Handle These Requests? (Under the Hood)

You might wonder how `Get.snackbar()`, `Get.dialog()`, and `Get.bottomSheet()` can work without you explicitly giving them a `BuildContext`.

**The Magic of `GetMaterialApp` and `Get.overlayContext`**
As we learned in [Chapter 1: GetMaterialApp / GetCupertinoApp & GetRoot](01_getmaterialapp___getcupertinoapp___getroot_.md), using `GetMaterialApp` sets up the GetX framework. Crucially, `GetMaterialApp` (via `GetRoot`) holds a global key for Flutter's `Overlay`. The `Overlay` is like a special layer in your app where you can draw things on top of everything else. GetX exposes access to this overlay's context via `Get.overlayContext`.

```dart
// lib/get_navigation/src/extension_navigation.dart (simplified concept)
BuildContext? get overlayContext {
  // ... logic to get the context of the root overlay ...
  // This 'key' is managed by GetRootState (from GetMaterialApp)
  key.currentState?.overlay?.context.visitChildElements((element) {
    // ... find the overlay context ...
  });
  return /* the found overlay context */;
}
```
This `Get.overlayContext` is the "magic wand" GetX uses to show snackbars, dialogs, and bottom sheets from anywhere.

### Snackbars: The `SnackbarController` at Your Service

When you call `Get.snackbar(...)`, it's more than just displaying a widget.
1.  `Get.snackbar()` (in `extension_navigation.dart`) creates a `GetSnackBar` widget configured with your title, message, colors, etc.
2.  It then hands this `GetSnackBar` widget to a `SnackbarController` (from `lib/get_navigation/src/snackbar/snackbar_controller.dart`).
3.  The `SnackbarController` is responsible for:
    *   Managing a queue (`SnackBarQueue`). If multiple snackbars are requested, they are shown one after another.
    *   Creating `OverlayEntry` objects (Flutter's way of putting something on the `Overlay`).
    *   Handling animations (showing and hiding the snackbar).
    *   Managing the duration and dismissal of the snackbar.

```mermaid
sequenceDiagram
    participant YourCode as Your Widget/Logic
    participant GetSnackbarCall as Get.snackbar()
    participant SnackbarCtrl as SnackbarController
    participant Overlay as Flutter OverlayState

    YourCode->>GetSnackbarCall: Calls Get.snackbar("Title", "Message")
    GetSnackbarCall->>SnackbarCtrl: Creates GetSnackBar widget & passes to new SnackbarController
    SnackbarCtrl->>SnackbarCtrl: Adds itself to SnackBarQueue
    SnackbarCtrl->>Overlay: When its turn, creates OverlayEntry & inserts into Overlay
    Overlay->>YourCode: Snackbar is displayed
    SnackbarCtrl->>Overlay: Later, removes OverlayEntry (on dismiss/timeout)
```

Here's a highly simplified glimpse of `Get.snackbar()` in `lib/get_navigation/src/extension_navigation.dart`:
```dart
// Simplified from extension_navigation.dart
SnackbarController snackbar(String title, String message, {/*...other params...*/}) {
  final getSnackBar = GetSnackBar( // Creates the snackbar widget
    title: title,
    message: message,
    // ... many other properties ...
  );

  // Creates a controller for this specific snackbar instance
  final controller = SnackbarController(getSnackBar); 
  
  // Shows it (adds to queue, handles display via Overlay)
  if (instantInit) { 
    controller.show();
  } else {
    // ... schedule to show after current frame ...
  }
  return controller;
}
```
And `SnackbarController` (in `lib/get_navigation/src/snackbar/snackbar_controller.dart`) uses the `Get.overlayContext` to interact with Flutter's `Overlay`:
```dart
// Simplified concept from SnackbarController.dart
class SnackbarController {
  final GetSnackBar snackbar; // The widget to display
  // ... animation controllers, etc. ...

  Future<void> show() {
    // Adds this snackbar job to a queue
    return GetRootState.controller.config.snackBarQueue.addJob(this);
  }

  Future<void> _show() { // Called by the queue
    // Gets Flutter's OverlayState using Get.overlayContext
    _overlayState = Overlay.of(Get.overlayContext!); 
    // Creates OverlayEntry(s) to display the snackbar
    _overlayEntries.addAll(_createOverlayEntries(snackbar));
    _overlayState!.insertAll(_overlayEntries); // Shows it!
    // ... handles animations and timers ...
    return _transitionCompleter.future;
  }
  // ... methods to close, manage status ...
}
```
The `SnackbarController` is quite sophisticated, managing animations, dismissals, and even a queue. This ensures your snackbars behave politely.

### Dialogs and BottomSheets: Custom Popup Routes

Dialogs and BottomSheets are a bit different. They are typically "modal," meaning they block interaction with the underlying screen content. In Flutter, these are often implemented using `PopupRoute`. GetX provides its own custom `PopupRoute` implementations:
*   `GetDialogRoute` (from `lib/get_navigation/src/dialog/dialog_route.dart`)
*   `GetModalBottomSheetRoute` (from `lib/get_navigation/src/bottomsheet/bottomsheet.dart`)

When you call `Get.dialog()` or `Get.bottomSheet()`:
1.  The `Get` extension method (in `extension_navigation.dart`) takes your widget and parameters.
2.  It then uses `Navigator.of(Get.overlayContext!).push(...)` to push either a `GetDialogRoute` (for dialogs) or a `GetModalBottomSheetRoute` (for bottom sheets) onto the navigator's stack.

Here's a glimpse into `Get.dialog()` from `lib/get_navigation/src/extension_navigation.dart`:
```dart
// Simplified from extension_navigation.dart
Future<T?> dialog<T>(Widget widget, {/* ... params ... */}) {
  // ... theme setup ...
  return generalDialog<T>( // Calls a more generic dialog method
    pageBuilder: (buildContext, animation, secondaryAnimation) {
      // ... wraps widget with Theme, SafeArea etc. ...
      return widget; 
    },
    // ... other parameters like barrierDismissible, barrierColor ...
  );
}

Future<T?> generalDialog<T>({ required RoutePageBuilder pageBuilder, /*...*/}) {
  // Accesses the navigator via Get.overlayContext (or a specific key)
  final nav = /* ... Navigator.of(overlayContext!, rootNavigator: true) ... */;
  
  // Pushes GetX's custom dialog route
  return nav.push<T>( 
    GetDialogRoute<T>(
      pageBuilder: pageBuilder,
      // ... passes other parameters ...
    ),
  );
}
```
And for `Get.bottomSheet()`:
```dart
// Simplified from extension_navigation.dart
Future<T?> bottomSheet<T>(Widget bottomsheet, {/* ... params ... */}) {
  // Uses the Navigator from Get.overlayContext
  return Navigator.of(overlayContext!, rootNavigator: useRootNavigator)
      .push(GetModalBottomSheetRoute<T>( // Pushes GetX's custom bottom sheet route
          builder: (_) => bottomsheet,
          // ... passes many other parameters for customization ...
      ));
}
```
`GetDialogRoute` and `GetModalBottomSheetRoute` are subclasses of Flutter's `PopupRoute`. They handle the specifics of how the dialog or bottom sheet appears, animates, and interacts with the modal barrier (the dimming effect behind them).

So, for dialogs and bottom sheets, GetX leverages Flutter's standard navigation mechanism for `PopupRoute`s but makes them accessible via the simple `Get.dialog()` and `Get.bottomSheet()` calls, using `Get.overlayContext` to find the correct `Navigator`.

## Conclusion

You've just learned how GetX simplifies showing common temporary UI elements—Snackbars, Dialogs, and BottomSheets—much like a hotel concierge assisting with quick notes, private meetings, or information panels.

The key takeaways are:
*   GetX provides easy, context-less APIs like `Get.snackbar()`, `Get.dialog()`, and `Get.bottomSheet()`.
*   `SnackbarController` manages the lifecycle and queue of snackbars efficiently.
*   Dialogs and BottomSheets are presented using custom `PopupRoute` implementations (`GetDialogRoute`, `GetModalBottomSheetRoute`) that GetX makes easy to invoke.
*   All this is possible because `GetMaterialApp` (via `GetRoot`) sets up the necessary global access to Flutter's `Overlay` and `Navigator`.

With these tools, you can create a more interactive and communicative user experience with minimal boilerplate code.

In the next chapter, we'll delve into how GetX understands the named routes you define with `GetPage` and how it handles parameters in those routes. Get ready for [Route Parsing & Configuration (RouteDecoder, PageSettings, ParseRouteTree)](05_route_parsing___configuration__routedecoder__pagesettings__parseroutetree__.md)!
2025-05-16 11:09:03,094 - INFO - PROMPT: 
Write a very beginner-friendly tutorial chapter (in Markdown format) for the project `getx` about the concept: "Route Parsing & Configuration (RouteDecoder, PageSettings, ParseRouteTree)
". This is Chapter 5.

Concept Details:
- Name: Route Parsing & Configuration (RouteDecoder, PageSettings, ParseRouteTree)

- Description:
This system is responsible for understanding and interpreting route paths (like URLs). `PageSettings` holds information for a specific route instance, like arguments and parameters. `ParseRouteTree` builds a structured representation of all defined routes and their children. `RouteDecoder` then uses this tree to find the correct `GetPage` and its hierarchy based on a given string path.
It's like your app's address book and postal service. `ParseRouteTree` is the complete address book. When you want to "go to" `/users/123?mode=edit`, `RouteDecoder` looks up this address, figures out it's for `UserScreen` with ID `123` and mode `edit`, and prepares the `PageSettings`.


Complete Tutorial Structure:
1. [GetMaterialApp / GetCupertinoApp & GetRoot
](01_getmaterialapp___getcupertinoapp___getroot_.md)
2. [GetNavigation Extensions (e.g., Get.toNamed, Get.snackbar)
](02_getnavigation_extensions__e_g___get_tonamed__get_snackbar__.md)
3. [GetPage & GetRouterDelegate
](03_getpage___getrouterdelegate_.md)
4. [Overlay Management (Snackbar, Dialog, BottomSheet)
](04_overlay_management__snackbar__dialog__bottomsheet__.md)
5. [Route Parsing & Configuration (RouteDecoder, PageSettings, ParseRouteTree)
](05_route_parsing___configuration__routedecoder__pagesettings__parseroutetree__.md)
6. [GetMiddleware
](06_getmiddleware_.md)
7. [Transition System (GetPageRouteTransitionMixin, CustomTransition, Transitions)
](07_transition_system__getpageroutetransitionmixin__customtransition__transitions__.md)
8. [RouterReportManager
](08_routerreportmanager_.md)

Context from previous chapters:
# Chapter 1: GetMaterialApp / GetCupertinoApp & GetRoot

Welcome to your GetX journey! This is the very first step into a powerful and easy-to-use Flutter framework. In this chapter, we'll explore the foundational building blocks of any GetX application: `GetMaterialApp`, `GetCupertinoApp`, and the unsung hero, `GetRoot`.

## What's the Big Deal? Setting Up Your GetX App

Imagine you're building a house. Before you can add rooms, furniture, or even think about painting the walls, you need a solid foundation and the main structure, right? In a Flutter app using GetX, `GetMaterialApp` or `GetCupertinoApp` are like choosing the architectural style of your house (Material Design for Android-style or Cupertino for iOS-style), and they lay this essential groundwork.

Flutter apps usually start with `MaterialApp` (for Material Design) or `CupertinoApp` (for iOS-style design). GetX provides its own versions:

*   `GetMaterialApp`
*   `GetCupertinoApp`

Why use these instead of the standard Flutter ones? Because they do something crucial: **they initialize the GetX framework**. This "initialization" means they set up all the cool things GetX offers, like super-easy navigation, smart state management, and simple internationalization (showing your app in different languages).

Think of it like this: standard `MaterialApp` gives you a basic house blueprint. `GetMaterialApp` gives you that same blueprint but also installs the main electrical panel, plumbing system, and a smart home hub, all ready for you to use GetX features without extra setup.

## Meet the Stars of the Show

Let's break down these key components:

### 1. `GetMaterialApp` (for Material Design lovers)

If you're building an app that follows Google's Material Design guidelines (common for Android apps, but also widely used for cross-platform apps), you'll use `GetMaterialApp`. It's a direct replacement for Flutter's `MaterialApp`. By using it, you're telling your app, "Hey, I want to use GetX features!"

```dart
// main.dart
import 'package:flutter/material.dart';
import 'package:get/get.dart'; // Don't forget to import GetX!

void main() {
  runApp(MyApp());
}

class MyApp extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return GetMaterialApp( // <-- See? We use GetMaterialApp here!
      title: 'My First GetX App',
      home: MyHomePage(),
    );
  }
}

class MyHomePage extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(title: Text('GetX is Awesome!')),
      body: Center(child: Text('Hello, GetX World!')),
    );
  }
}
```
In this very simple app, just by changing `MaterialApp` to `GetMaterialApp`, we've unlocked the potential to use all of GetX's powerful features throughout our `MyApp`.

### 2. `GetCupertinoApp` (for iOS aficionados)

If you're aiming for an app that looks and feels like a native iOS application, you'll use `GetCupertinoApp`. It's the GetX equivalent of Flutter's `CupertinoApp`.

```dart
// main.dart
import 'package:flutter/cupertino.dart';
import 'package:get/get.dart'; // Import GetX

void main() {
  runApp(MyApp());
}

class MyApp extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return GetCupertinoApp( // <-- Using GetCupertinoApp for iOS style
      title: 'My First GetX iOS App',
      home: MyHomePage(),
    );
  }
}

class MyHomePage extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return CupertinoPageScaffold(
      navigationBar: CupertinoNavigationBar(
        middle: Text('Hello, GetX (iOS Style)!'),
      ),
      child: Center(child: Text('GetX on Cupertino!')),
    );
  }
}
```
Similar to `GetMaterialApp`, using `GetCupertinoApp` sets up your app for GetX functionalities but with an iOS-style foundation.

### 3. `GetRoot`: The Engine Under the Hood

You might not ever type `GetRoot` directly in your code, but it's super important to know it exists. `GetRoot` is the core widget that both `GetMaterialApp` and `GetCupertinoApp` use internally.

Think of `GetRoot` as the main power supply and central control panel for the GetX system in your app. It's responsible for:
*   Managing global configurations.
*   Setting up the routing system that GetX uses for navigation.
*   Initializing dependency management.
*   Handling internationalization settings (like current language).

So, when you use `GetMaterialApp` or `GetCupertinoApp`, they are essentially putting a `GetRoot` widget at the very top of your application's widget tree. This makes all the GetX features available to every part of your app.

## How Does It Work? A Peek Inside

You don't need to know the intricate details to use GetX effectively, but a little insight can be helpful!

1.  **You start your app:** You use `GetMaterialApp` (or `GetCupertinoApp`) as the root widget in your `main.dart` file.
2.  **`GetMaterialApp` takes charge:** When `GetMaterialApp` is built, its main job is to create and configure a `GetRoot` widget. It passes along all your app's configurations (like themes, initial routes, translations, etc.) to `GetRoot`.
3.  **`GetRoot` powers up:** `GetRoot` receives these configurations and initializes the entire GetX ecosystem. It sets up internal controllers, listeners for things like language changes, and provides the necessary context for GetX features to work.
4.  **Your app is ready!** With `GetRoot` in place, all other GetX functionalities (like `Get.to()` for navigation, `Get.put()` for dependency injection, `Get.snackbar()` for messages) can now find the necessary GetX infrastructure and work their magic.

Let's visualize this flow:

```mermaid
sequenceDiagram
    participant UserApp as main.dart
    participant GMA as GetMaterialApp
    participant GR as GetRoot
    participant GetXCore as GetX Core System

    UserApp->>GMA: Uses GetMaterialApp/GetCupertinoApp
    GMA->>GR: Wraps its child with GetRoot, passing configurations
    GR->>GetXCore: Initializes GetX services (routing, DI, locale)
    GMA->>UserApp: Renders app with GetX features enabled
```

**A Tiny Glimpse into the Code:**

You won't usually need to touch this code, but it helps to see it.

Here's a simplified look at what `GetMaterialApp` does in its `build` method (from `lib/get_navigation/src/root/get_material_app.dart`):

```dart
// Inside GetMaterialApp's build method
@override
Widget build(BuildContext context) {
  return GetRoot( // Notice! It returns a GetRoot widget.
    config: ConfigData( // Bundles up all configurations
      // ... like home, getPages, locale, theme ...
      home: home,
      getPages: getPages,
      locale: locale,
      theme: theme,
      // ... and many other settings you provide ...
    ),
    child: Builder(builder: (context) {
      // This inner part builds the actual MaterialApp,
      // now empowered by GetRoot and its configurations.
      final controller = GetRoot.of(context);
      return MaterialApp.router( /* ... uses controller.config ... */ );
    }),
  );
}
```
This code shows that `GetMaterialApp` essentially sets up `GetRoot` with all your app's settings. `GetRoot` then takes care of the nitty-gritty GetX initialization.

And here's a very simplified idea of what `GetRoot` does when it starts (from `lib/get_navigation/src/root/get_root.dart`):

```dart
// Inside GetRootState's initState method
@override
void initState() {
  config = widget.config; // Receives config from GetMaterialApp/GetCupertinoApp
  // ... other setup ...
  onInit(); // Calls a special GetX initialization method
  super.initState();
}

void onInit() {
  // Example: Sets up the current language (locale) for your app
  if (config.locale != null) Get.locale = config.locale;

  // Example: Initializes translations if you provide them
  if (config.translations != null) {
    Get.addTranslations(config.translations!.keys);
  }
  // ... and much more initialization for routing, logging, etc. ...
}
```
This `onInit()` method within `GetRoot` is where a lot of the GetX magic gets set up based on the properties you pass to `GetMaterialApp` or `GetCupertinoApp`.

## Why Bother? The Benefits

*   **Simplicity:** You just swap `MaterialApp` with `GetMaterialApp` (or `CupertinoApp` with `GetCupertinoApp`), and you're ready to use GetX. No complex setup rituals!
*   **Power:** This simple change unlocks a vast array of features:
    *   Effortless route management (covered in [GetNavigation Extensions (e.g., Get.toNamed, Get.snackbar)](02_getnavigation_extensions__e_g___get_tonamed__get_snackbar__.md) and [GetPage & GetRouterDelegate](03_getpage___getrouterdelegate__.md)).
    *   Simple state management.
    *   Easy dependency injection.
    *   Built-in internationalization.
    *   Dialogs, Snackbars, and BottomSheets without `context` (see [Overlay Management (Snackbar, Dialog, BottomSheet)](04_overlay_management__snackbar__dialog__bottomsheet__.md)).
*   **Performance:** GetX is designed to be lightweight and performant.

## Conclusion

You've just learned about the most fundamental step in building a GetX application: using `GetMaterialApp` or `GetCupertinoApp`. These widgets, powered by the underlying `GetRoot`, are your gateway to the GetX ecosystem. They seamlessly initialize everything you need, allowing you to focus on building amazing features rather than wrestling with boilerplate setup.

With this foundation laid, you're now ready to explore one of the most beloved features of GetX: its incredibly simple and powerful navigation system.

Ready to learn how to move between screens with ease? Let's dive into the [GetNavigation Extensions (e.g., Get.toNamed, Get.snackbar)](02_getnavigation_extensions__e_g___get_tonamed__get_snackbar__.md)!
---
# Chapter 2: GetNavigation Extensions (e.g., Get.toNamed, Get.snackbar)

Welcome back! In [Chapter 1: GetMaterialApp / GetCupertinoApp & GetRoot](01_getmaterialapp___getcupertinoapp___getroot_.md), we learned how to set up the foundation of our GetX app using `GetMaterialApp` or `GetCupertinoApp`. This simple step unlocked a world of powerful GetX features. Now, let's explore one of the most loved features: making navigation and showing pop-ups incredibly easy!

## The Old Way vs. The GetX Way

Imagine you're in your app, perhaps inside a settings page, and you want to navigate to a user profile page after a button tap. In standard Flutter, you'd typically need `BuildContext` to do this:

```dart
// Standard Flutter (needs context)
Navigator.push(context, MaterialPageRoute(builder: (context) => ProfileScreen()));
```

What if your button's logic is inside a separate class, like a ViewModel or a Controller, that doesn't have direct access to `BuildContext`? Passing `BuildContext` around can make your code a bit messy.

This is where GetX shines! GetX provides **GetNavigation Extensions**. These are convenient shortcut methods attached to the `Get` interface (think of `Get` as your GetX toolkit). They allow you to navigate or show UI elements like dialogs, snackbars, and bottom sheets from *anywhere* in your code without needing a `BuildContext`.

Think of it as a **universal remote control** for your app's navigation and common UI pop-ups. Instead of finding the specific local remote (`BuildContext`) for the TV in a room, you use one master remote (`Get`) to control any TV (navigation, dialog) in the house.

## Your Universal Remote: Meet `Get`

The `Get` object is your central access point for many GetX features. When you see `Get.something()`, you're using one of these handy extensions.

Let's see how this "universal remote" works for common tasks.

### 1. Navigating to a New Screen: `Get.to()`

Want to go to a new screen? Just use `Get.to()` and tell it which screen (widget) to build.

**Use Case:** Let's say we have a `HomeScreen` and we want to navigate to a `DetailScreen`.

First, your `main.dart` should be set up with `GetMaterialApp` (as learned in Chapter 1):

```dart
// main.dart
import 'package:flutter/material.dart';
import 'package:get/get.dart';
import 'home_screen.dart'; // We'll create this next

void main() {
  runApp(MyApp());
}

class MyApp extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return GetMaterialApp( // Using GetMaterialApp
      title: 'GetX Navigation',
      home: HomeScreen(),
    );
  }
}
```
This setup is crucial because `GetMaterialApp` prepares GetX for context-less navigation.

Now, let's create `HomeScreen` and `DetailScreen`:

```dart
// home_screen.dart
import 'package:flutter/material.dart';
import 'package:get/get.dart';
import 'detail_screen.dart'; // We'll create this

class HomeScreen extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(title: Text('Home')),
      body: Center(
        child: ElevatedButton(
          onPressed: () {
            // Look, no context needed!
            Get.to(() => DetailScreen());
          },
          child: Text('Go to Details'),
        ),
      ),
    );
  }
}
```
In `HomeScreen`, when the button is pressed, `Get.to(() => DetailScreen())` is called. This tells GetX to push `DetailScreen` onto the navigation stack.

```dart
// detail_screen.dart
import 'package:flutter/material.dart';

class DetailScreen extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(title: Text('Details')),
      body: Center(child: Text('This is the Detail Screen!')),
    );
  }
}
```
`DetailScreen` is just a simple page. When you tap the button on `HomeScreen`, you'll navigate to `DetailScreen`.

**What happened?**
`Get.to(() => DetailScreen())` pushed a new route displaying `DetailScreen` onto the navigation stack. The `() => DetailScreen()` part is a function that creates your new screen.

### 2. Navigating with Named Routes: `Get.toNamed()`

Sometimes, you prefer to navigate using names instead of creating widget instances directly. This is great for clean code and is essential for web routing. GetX makes this super easy with `Get.toNamed()`.

First, you need to define your named routes in `GetMaterialApp` using the `getPages` property. We'll dive deeper into `getPages` in [GetPage & GetRouterDelegate](03_getpage___getrouterdelegate__.md), but here's a sneak peek:

```dart
// main.dart (updated)
import 'package:flutter/material.dart';
import 'package:get/get.dart';
import 'home_screen.dart';
import 'detail_screen.dart'; // Import DetailScreen

void main() {
  runApp(MyApp());
}

class MyApp extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return GetMaterialApp(
      title: 'GetX Named Navigation',
      initialRoute: '/home', // Optional: set an initial route
      getPages: [
        GetPage(name: '/home', page: () => HomeScreen()),
        GetPage(name: '/detail', page: () => DetailScreen()),
      ],
    );
  }
}
```
We've defined two routes: `/home` pointing to `HomeScreen` and `/detail` pointing to `DetailScreen`.

Now, in your `HomeScreen`, you can navigate using the name:

```dart
// home_screen.dart (updated for named route)
// ... (imports remain the same)
class HomeScreen extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(title: Text('Home')),
      body: Center(
        child: ElevatedButton(
          onPressed: () {
            Get.toNamed('/detail'); // Navigate by name!
          },
          child: Text('Go to Details (Named)'),
        ),
      ),
    );
  }
}
```
When you tap the button, `Get.toNamed('/detail')` looks up the '/detail' route you defined in `getPages` and navigates to `DetailScreen`.

### 3. Going Back: `Get.back()`

To go back to the previous screen, it's as simple as:

```dart
// Inside DetailScreen, for example
ElevatedButton(
  onPressed: () {
    Get.back(); // Go back to HomeScreen
  },
  child: Text('Go Back'),
)
```
`Get.back()` pops the current screen from the navigation stack, just like Flutter's `Navigator.pop(context)`.

### 4. Showing a Quick Message: `Get.snackbar()`

Need to show a quick notification or message (a "snackbar")? GetX has you covered, again, without needing `BuildContext`.

```dart
// In any button's onPressed, or anywhere else:
ElevatedButton(
  onPressed: () {
    Get.snackbar(
      "Success!", // Title
      "Your action was completed.", // Message
      snackPosition: SnackPosition.BOTTOM, // Optional: position
    );
  },
  child: Text('Show Snackbar'),
)
```
This will display a sleek snackbar at the bottom (or top, depending on `snackPosition`) of your screen. It's that easy! We'll explore snackbars in more detail in [Overlay Management (Snackbar, Dialog, BottomSheet)](04_overlay_management__snackbar__dialog__bottomsheet__.md).

### 5. A Peek at Dialogs and Bottom Sheets

GetX also simplifies showing dialogs and bottom sheets without `BuildContext`.

*   **Dialogs with `Get.dialog()`**:
    ```dart
    // Example: Show a simple dialog
    Get.dialog(
      AlertDialog(
        title: Text('Alert!'),
        content: Text('This is a GetX dialog.'),
        actions: [TextButton(onPressed: () => Get.back(), child: Text('OK'))],
      )
    );
    ```

*   **Bottom Sheets with `Get.bottomSheet()`**:
    ```dart
    // Example: Show a simple bottom sheet
    Get.bottomSheet(
      Container(
        height: 200,
        color: Colors.white,
        child: Center(child: Text('This is a GetX bottom sheet!')),
      )
    );
    ```
These are very powerful, and you'll learn all about customizing them in [Overlay Management (Snackbar, Dialog, BottomSheet)](04_overlay_management__snackbar__dialog__bottomsheet__.md). For now, just know they exist and are super easy to call!

## How Does This Magic Work? Under the Hood

You might be wondering: "If I'm not giving it `BuildContext`, how does `Get.toNamed()` or `Get.snackbar()` know where to navigate or show the message?"

It's thanks to the setup we did in [Chapter 1: GetMaterialApp / GetCupertinoApp & GetRoot](01_getmaterialapp___getcupertinoapp___getroot_.md)!

1.  **The Foundation**: When you use `GetMaterialApp` (or `GetCupertinoApp`), it internally creates and configures a `GetRoot` widget. This `GetRoot` widget holds a global `NavigatorKey`. Think of this key as a direct phone line to Flutter's navigation system. It also manages an `OverlayKey` for things like snackbars and dialogs.

2.  **The Call**: When you call something like `Get.toNamed('/detail')`, the static `Get` interface uses this globally available `NavigatorKey` (managed by `GetRootController`) to access the current `NavigatorState`.

3.  **The Action**: Once it has the `NavigatorState`, it can then call the standard Flutter methods like `navigatorState.pushNamed('/detail')` or `navigatorState.push(MaterialPageRoute(...))`.

For snackbars, dialogs, and bottom sheets, `Get` uses a similar mechanism to access the `OverlayState` (via `Get.overlayContext`) to display these UI elements on top of your current screen.

Here's a simplified flow:

```mermaid
sequenceDiagram
    participant YourWidget as Your Widget (e.g., Button)
    participant GetStatic as Get (Static Interface)
    participant GetRootCtrl as GetRoot Controller (from GetMaterialApp)
    participant FlutterNavigator as Flutter Navigator/Overlay

    YourWidget->>GetStatic: Calls Get.toNamed("/details") or Get.snackbar(...)
    GetStatic->>GetRootCtrl: Accesses root NavigatorKey or OverlayContext
    GetRootCt<ctrl63>
---
# Chapter 3: GetPage & GetRouterDelegate

In [Chapter 2: GetNavigation Extensions (e.g., Get.toNamed, Get.snackbar)](02_getnavigation_extensions__e_g___get_tonamed__get_snackbar__.md), we saw how easy GetX makes navigating between screens using methods like `Get.to()` and `Get.toNamed()`. We even had a sneak peek at defining named routes. Now, let's dive deeper into how GetX manages these routes in a more structured and powerful way using `GetPage` and `GetRouterDelegate`. These are the tools that make GetX's navigation so robust, especially for larger apps!

## The Need for Structure: Why Bother?

Imagine you're designing a website with many pages: a homepage, an about page, a contact page, a profile page, and so on. If you just linked them haphazardly, it would quickly become a mess. You'd want a clear sitemap and well-defined URLs for each page.

Similarly, in a Flutter app, as it grows, just calling `Get.to(() => MyScreen())` everywhere can become hard to manage. What if you want to change the transition animation for a specific screen? Or pass data to it in a standardized way? Or manage deep linking (opening specific app screens from a web link)?

This is where `GetPage` and `GetRouterDelegate` come in. They help you:
1.  **Define all your app's screens (routes) in one central place.**
2.  **Give each screen a unique name (like a URL).**
3.  **Configure special behaviors for each screen (like transitions or data bindings).**
4.  **Power Flutter's modern Navigator 2.0 system within GetX, allowing for more complex navigation scenarios.**

Let's meet the stars!

## Meet the Blueprint: `GetPage`

Think of `GetPage` as a **blueprint for a screen** in your app. It's not the screen itself, but rather a detailed description of it. Each `GetPage` tells GetX:
*   `name`: The unique "URL" or path for this screen (e.g., `/home`, `/profile`, `/settings/notifications`). This is what you use with `Get.toNamed()`.
*   `page`: A function that tells GetX *how to build* the actual widget for this screen when it's needed.
*   `binding` (optional): A way to set up controllers or other dependencies specifically for this screen. (We'll explore bindings more in GetX state management).
*   `transition` (optional): How the screen animates in and out. (More on this in [Transition System (GetPageRouteTransitionMixin, CustomTransition, Transitions)](07_transition_system__getpageroutetransitionmixin__customtransition__transitions__.md)).
*   `middlewares` (optional): Special functions that can run before a page is shown, perhaps to check if a user is logged in. (Covered in [GetMiddleware](06_getmiddleware_.md)).

Let's define a couple of simple `GetPage` blueprints:

```dart
// main.dart (or a separate routes file)
import 'package:flutter/material.dart';
import 'package:get/get.dart'; // Import GetX

// Assume HomeScreen and ProfileScreen widgets are defined elsewhere
// For example:
// class HomeScreen extends StatelessWidget { /* ... */ }
// class ProfileScreen extends StatelessWidget { /* ... */ }

final List<GetPage> appPages = [
  GetPage(
    name: '/home', // The unique name for the home screen
    page: () => HomeScreen(), // How to build the HomeScreen
  ),
  GetPage(
    name: '/profile', // The unique name for the profile screen
    page: () => ProfileScreen(), // How to build the ProfileScreen
    // transition: Transition.rightToLeft, // Optional: a nice slide animation
  ),
];
```
In this snippet, `appPages` is a list holding the blueprints for our `HomeScreen` and `ProfileScreen`. We've given each a unique `name` and a `page` function.

## Meet the Captain: `GetRouterDelegate`

If `GetPage` is the blueprint, then `GetRouterDelegate` is the **captain of your app's navigation ship**. It's the core engine that powers Flutter's modern Navigator 2.0 system within GetX.

You usually won't interact with `GetRouterDelegate` directly in simple apps. When you provide your list of `GetPage` blueprints to `GetMaterialApp` (as we'll see next), GetX sets up a `GetRouterDelegate` for you behind the scenes.

This "captain" is responsible for:
*   Taking your `GetPage` blueprints.
*   Managing the actual stack of screens (what's visible, what's underneath).
*   Deciding which page is currently visible based on the URL or navigation actions.
*   Handling how to go to new pages (`Get.toNamed()`).
*   Handling how to go back (`Get.back()`).

Think of it like an air traffic controller for your app's screens. It knows all the available "runways" (`GetPage`s) and directs the "planes" (your users' navigation actions) to the correct one smoothly.

## Putting It Together: Defining Routes in `GetMaterialApp`

Now, how do we tell our GetX app about these `GetPage` blueprints so the `GetRouterDelegate` can use them? We pass our list of `GetPage`s to the `getPages` property of `GetMaterialApp` (or `GetCupertinoApp`).

Let's update our `main.dart` from Chapter 2:

```dart
// main.dart
import 'package:flutter/material.dart';
import 'package:get/get.dart';

// Let's define our screens quickly for this example
class HomeScreen extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(title: Text('Home')),
      body: Center(
        child: ElevatedButton(
          onPressed: () => Get.toNamed('/profile'), // Navigate to profile
          child: Text('Go to Profile'),
        ),
      ),
    );
  }
}

class ProfileScreen extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(title: Text('Profile')),
      body: Center(child: Text('This is your Profile!')),
    );
  }
}

// Our GetPage blueprints
final List<GetPage> appPages = [
  GetPage(name: '/home', page: () => HomeScreen()),
  GetPage(name: '/profile', page: () => ProfileScreen()),
];

void main() {
  runApp(MyApp());
}

class MyApp extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return GetMaterialApp(
      title: 'GetX Named Routes',
      initialRoute: '/home', // Start at the home screen
      getPages: appPages,   // <-- Here's where we provide our blueprints!
    );
  }
}
```
By providing `appPages` to `GetMaterialApp`, we've done two things:
1.  Registered our `/home` and `/profile` routes.
2.  Enabled `GetMaterialApp` to use its internal `GetRouterDelegate` to manage navigation based on these named routes.

Now, `Get.toNamed('/profile')` from `HomeScreen` will correctly navigate to `ProfileScreen` because the `GetRouterDelegate` (set up by `GetMaterialApp`) knows about the `/profile` blueprint.

## How Does It Work Under the Hood?

When you use `getPages` with `GetMaterialApp`, GetX sets up a more sophisticated navigation system. Here's a simplified step-by-step:

1.  **Setup**: When `GetMaterialApp` starts, it sees you've provided `getPages`. It then creates and configures a `GetRouterDelegate` (specifically, an instance of `GetDelegate` from `lib/get_navigation/src/routes/get_router_delegate.dart`). This delegate is given your list of `GetPage` blueprints.
2.  **Navigation Trigger**: You call `Get.toNamed('/profile')`.
3.  **Delegate at Work**: The `Get.toNamed` call, in this Navigator 2.0 setup, ultimately informs the `GetRouterDelegate`.
4.  **Route Matching**: The `GetRouterDelegate` consults its list of `GetPage`s. It uses a helper, often `ParseRouteTree` (from `lib/get_navigation/src/routes/parse_route.dart`), to find the `GetPage` whose `name` matches `/profile`. We'll explore `ParseRouteTree` more in [Route Parsing & Configuration (RouteDecoder, PageSettings, ParseRouteTree)](05_route_parsing___configuration__routedecoder__pagesettings__parseroutetree__.md).
5.  **Screen Creation**: Once the matching `GetPage` blueprint is found, the `GetRouterDelegate` uses its `page: () => ProfileScreen()` function to create an instance of `ProfileScreen`.
6.  **Stack Update**: The `GetRouterDelegate` then updates Flutter's navigation stack to display this new `ProfileScreen`.

Here's a visual:

```mermaid
sequenceDiagram
    participant UserAction as User Taps Button
    participant GetToNamed as Get.toNamed("/profile")
    participant GMA as GetMaterialApp (internally)
    participant GRD as GetRouterDelegate
    participant FlutterNav as Flutter Navigator

    UserAction->>GetToNamed: Invokes navigation for "/profile"
    GetToNamed->>GMA: Signals intent (simplified)
    GMA->>GRD: Relays "/profile" to its delegate
    GRD->>GRD: Finds GetPage(name: "/profile") in its list (getPages)
    GRD->>GRD: Calls page() function from GetPage
    GRD->>FlutterNav: "Push this new screen (ProfileScreen)"
    FlutterNav->>UserAction: ProfileScreen is displayed
```

Inside `GetMaterialApp` (or more accurately, `GetMaterialApp.router` which is used when `getPages` is provided), it sets up like this:

```dart
// Simplified concept from GetMaterialApp when getPages is used
// return GetMaterialApp.router(
//   routeInformationParser: GetInformationParser(...), // Handles URL parsing
//   routerDelegate: GetDelegate(pages: getPages, ...), // Our captain!
// );
```
The `GetDelegate` (our `GetRouterDelegate` implementation) receives your `pages` (your `GetPage` list).

Then, `GetDelegate`'s `build` method uses these pages to construct the `Navigator`:

```dart
// Simplified from lib/get_navigation/src/routes/get_router_delegate.dart
// Inside GetDelegate's build method:

// final currentHistory = currentConfiguration;
// final pages = /* ... logic to get current visible GetPage(s) based on URL ... */
//    getVisualPages(currentHistory).toList();

// return GetNavigator(
//   key: navigatorKey,
//   onPopPage: _onPopVisualRoute, // Handles back button for these pages
//   pages: pages, // The actual Flutter Page objects derived from your GetPages
//   // ... other navigator configurations
// );
```
The `pages` list here are Flutter `Page` objects, which `GetDelegate` creates based on your `GetPage` definitions and the current navigation state.

So, by using `GetPage` and `getPages`, you're tapping into this powerful, Navigator 2.0-based routing managed by `GetRouterDelegate`.

## Why This Approach?

*   **Centralized Route Definitions**: All your main navigation paths are clearly defined in one place.
*   **Named Navigation Power**: Makes `Get.toNamed()` very robust.
*   **Decoupling**: Your UI code just says "go to `/profile`"; it doesn't need to know *how* `ProfileScreen` is built or what its specific dependencies are.
*   **Advanced Scenarios**: This structure is the foundation for more complex features like:
    *   Nested navigation (routes within routes).
    *   Guards/Middlewares (e.g., checking login status before accessing a route, covered in [GetMiddleware](06_getmiddleware_.md)).
    *   Custom transitions per route (see [Transition System (GetPageRouteTransitionMixin, CustomTransition, Transitions)](07_transition_system__getpageroutetransitionmixin__customtransition__transitions__.md)).
    *   Better web URL handling.

## Conclusion

You've now learned about `GetPage`, the blueprint for your screens, and `GetRouterDelegate`, the captain that manages navigation using these blueprints. By defining your routes using `GetPage` and providing them to `GetMaterialApp` via the `getPages` property, you unlock a more structured, powerful, and maintainable way to handle navigation in your GetX applications. This setup is what allows GetX to seamlessly integrate with Flutter's Navigator 2.0 system, giving you fine-grained control while keeping things simple.

While `GetRouterDelegate` works largely behind the scenes for many common use cases, understanding its role helps you appreciate the robustness of GetX navigation.

Next up, we'll explore how GetX makes it incredibly easy to show common UI overlays like Snackbars, Dialogs, and BottomSheets, often without needing `BuildContext` at all! Let's head to [Overlay Management (Snackbar, Dialog, BottomSheet)](04_overlay_management__snackbar__dialog__bottomsheet__.md).
---
# Chapter 4: Overlay Management (Snackbar, Dialog, BottomSheet)

Welcome back! In [Chapter 3: GetPage & GetRouterDelegate](03_getpage___getrouterdelegate__.md), we learned how to structure our app's navigation with named routes using `GetPage`. Now, let's explore another incredibly handy feature of GetX: managing temporary UI elements like snackbars, dialogs, and bottom sheets, all without needing to pass `BuildContext` around!

## What are Overlays? The Hotel Concierge Analogy

Imagine you're staying in a fancy hotel (your app). You're comfortably in your room (your current screen). Sometimes, you need quick services or information without having to leave your room or go to a completely new part of the hotel. This is where the hotel concierge comes in handy!

In GetX, overlay management is like having a super-efficient concierge service for your app. You can request:
*   A **quick note delivered to you** (a **Snackbar**): A brief message that appears temporarily, usually at the top or bottom of the screen, to give you a quick update (e.g., "Message sent!").
*   To **arrange a private meeting in a temporary room** (a **Dialog**): A pop-up window that requires your attention before you can continue interacting with your current screen. Useful for alerts, confirmations, or quick forms.
*   To **pull up a special information panel from below** (a **BottomSheet**): A panel that slides up from the bottom of the screen, offering more detailed options or information related to the current context.

These are all "overlays"—UI elements that appear *on top* of your current page without completely replacing it. GetX makes showing these incredibly simple.

## GetX's Superpower: Context-less Overlays

As we saw in [Chapter 2: GetNavigation Extensions (e.g., Get.toNamed, Get.snackbar)](02_getnavigation_extensions__e_g___get_tonamed__get_snackbar__.md), one of GetX's main advantages is allowing you to trigger navigation and UI elements from anywhere in your code, often without needing `BuildContext`. This is especially true for overlays!

Thanks to the setup with `GetMaterialApp` (covered in [Chapter 1: GetMaterialApp / GetCupertinoApp & GetRoot](01_getmaterialapp___getcupertinoapp___getroot_.md)), GetX has access to the necessary "hooks" to display these overlays globally.

Let's see how to use our "concierge" (`Get`) to request these services.

### 1. Quick Notes: `Get.snackbar()`

Need to show a user a quick, non-intrusive message? `Get.snackbar()` is your friend. It's like asking the concierge to slip a small note under your door.

```dart
// In any button's onPressed, or anywhere in your logic:
ElevatedButton(
  onPressed: () {
    Get.snackbar(
      "Notification", // Title of the snackbar
      "Your profile was updated successfully!", // Message
      snackPosition: SnackPosition.BOTTOM, // Where it appears
      backgroundColor: Colors.green,
      colorText: Colors.white,
    );
  },
  child: Text('Update Profile & Show Snackbar'),
)
```
**What happens?**
Tapping this button will display a green snackbar at the bottom of the screen with the title "Notification" and your message. It will automatically dismiss after a few seconds.

**Behind the Scenes (Briefly):**
GetX uses a `SnackbarController` to manage these requests. If you call `Get.snackbar()` multiple times quickly, `SnackbarController` acts like the concierge's assistant, queuing up the notes and delivering them one by one, so they don't all appear at once and clutter the screen.

### 2. Private Meetings: `Get.dialog()`

Sometimes you need to grab the user's full attention for an important choice or piece of information. This is like asking the concierge to book a small, private meeting room (a Dialog). The user must interact with the dialog (e.g., press "OK" or "Cancel") before returning to their main room (screen).

```dart
// In any button's onPressed:
ElevatedButton(
  onPressed: () {
    Get.dialog(
      AlertDialog(
        title: Text('Confirm Action'),
        content: Text('Are you sure you want to delete this item?'),
        actions: [
          TextButton(onPressed: () => Get.back(), child: Text('Cancel')),
          TextButton(onPressed: () { /* delete logic */ Get.back(); }, child: Text('Delete')),
        ],
      ),
    );
  },
  child: Text('Delete Item (Show Dialog)'),
)
```
**What happens?**
Tapping this button will display a standard Material Design alert dialog in the middle of the screen. The background will be dimmed, and the user must tap "Cancel" or "Delete" to close the dialog. `Get.back()` is used here to close the dialog.

### 3. Special Info Panels: `Get.bottomSheet()`

For presenting a list of options or a bit more information without being as intrusive as a full dialog, a bottom sheet is perfect. It's like the concierge pulling up a neat information panel from a compartment below your desk.

```dart
// In any button's onPressed:
ElevatedButton(
  onPressed: () {
    Get.bottomSheet(
      Container(
        height: 200,
        color: Colors.blueGrey,
        child: Column(
          mainAxisAlignment: MainAxisAlignment.center,
          children: [
            ListTile(leading: Icon(Icons.share, color: Colors.white), title: Text('Share', style: TextStyle(color: Colors.white)), onTap: () => Get.back()),
            ListTile(leading: Icon(Icons.copy, color: Colors.white), title: Text('Copy Link', style: TextStyle(color: Colors.white)), onTap: () => Get.back()),
          ],
        ),
      ),
      // Optional: make it non-dismissible by dragging
      // isDismissible: false, 
    );
  },
  child: Text('Show Options (BottomSheet)'),
)
```
**What happens?**
Tapping this button will cause a panel to slide up from the bottom of the screen. This panel contains our "Share" and "Copy Link" options. Tapping an option (or outside the sheet, if dismissible) will close it. `Get.back()` closes the bottom sheet here.

## How Does GetX Handle These Requests? (Under the Hood)

You might wonder how `Get.snackbar()`, `Get.dialog()`, and `Get.bottomSheet()` can work without you explicitly giving them a `BuildContext`.

**The Magic of `GetMaterialApp` and `Get.overlayContext`**
As we learned in [Chapter 1: GetMaterialApp / GetCupertinoApp & GetRoot](01_getmaterialapp___getcupertinoapp___getroot_.md), using `GetMaterialApp` sets up the GetX framework. Crucially, `GetMaterialApp` (via `GetRoot`) holds a global key for Flutter's `Overlay`. The `Overlay` is like a special layer in your app where you can draw things on top of everything else. GetX exposes access to this overlay's context via `Get.overlayContext`.

```dart
// lib/get_navigation/src/extension_navigation.dart (simplified concept)
BuildContext? get overlayContext {
  // ... logic to get the context of the root overlay ...
  // This 'key' is managed by GetRootState (from GetMaterialApp)
  key.currentState?.overlay?.context.visitChildElements((element) {
    // ... find the overlay context ...
  });
  return /* the found overlay context */;
}
```
This `Get.overlayContext` is the "magic wand" GetX uses to show snackbars, dialogs, and bottom sheets from anywhere.

### Snackbars: The `SnackbarController` at Your Service

When you call `Get.snackbar(...)`, it's more than just displaying a widget.
1.  `Get.snackbar()` (in `extension_navigation.dart`) creates a `GetSnackBar` widget configured with your title, message, colors, etc.
2.  It then hands this `GetSnackBar` widget to a `SnackbarController` (from `lib/get_navigation/src/snackbar/snackbar_controller.dart`).
3.  The `SnackbarController` is responsible for:
    *   Managing a queue (`SnackBarQueue`). If multiple snackbars are requested, they are shown one after another.
    *   Creating `OverlayEntry` objects (Flutter's way of putting something on the `Overlay`).
    *   Handling animations (showing and hiding the snackbar).
    *   Managing the duration and dismissal of the snackbar.

```mermaid
sequenceDiagram
    participant YourCode as Your Widget/Logic
    participant GetSnackbarCall as Get.snackbar()
    participant SnackbarCtrl as SnackbarController
    participant Overlay as Flutter OverlayState

    YourCode->>GetSnackbarCall: Calls Get.snackbar("Title", "Message")
    GetSnackbarCall->>SnackbarCtrl: Creates GetSnackBar widget & passes to new SnackbarController
    SnackbarCtrl->>SnackbarCtrl: Adds itself to SnackBarQueue
    SnackbarCtrl->>Overlay: When its turn, creates OverlayEntry & inserts into Overlay
    Overlay->>YourCode: Snackbar is displayed
    SnackbarCtrl->>Overlay: Later, removes OverlayEntry (on dismiss/timeout)
```

Here's a highly simplified glimpse of `Get.snackbar()` in `lib/get_navigation/src/extension_navigation.dart`:
```dart
// Simplified from extension_navigation.dart
SnackbarController snackbar(String title, String message, {/*...other params...*/}) {
  final getSnackBar = GetSnackBar( // Creates the snackbar widget
    title: title,
    message: message,
    // ... many other properties ...
  );

  // Creates a controller for this specific snackbar instance
  final controller = SnackbarController(getSnackBar); 
  
  // Shows it (adds to queue, handles display via Overlay)
  if (instantInit) { 
    controller.show();
  } else {
    // ... schedule to show after current frame ...
  }
  return controller;
}
```
And `SnackbarController` (in `lib/get_navigation/src/snackbar/snackbar_controller.dart`) uses the `Get.overlayContext` to interact with Flutter's `Overlay`:
```dart
// Simplified concept from SnackbarController.dart
class SnackbarController {
  final GetSnackBar snackbar; // The widget to display
  // ... animation controllers, etc. ...

  Future<void> show() {
    // Adds this snackbar job to a queue
    return GetRootState.controller.config.snackBarQueue.addJob(this);
  }

  Future<void> _show() { // Called by the queue
    // Gets Flutter's OverlayState using Get.overlayContext
    _overlayState = Overlay.of(Get.overlayContext!); 
    // Creates OverlayEntry(s) to display the snackbar
    _overlayEntries.addAll(_createOverlayEntries(snackbar));
    _overlayState!.insertAll(_overlayEntries); // Shows it!
    // ... handles animations and timers ...
    return _transitionCompleter.future;
  }
  // ... methods to close, manage status ...
}
```
The `SnackbarController` is quite sophisticated, managing animations, dismissals, and even a queue. This ensures your snackbars behave politely.

### Dialogs and BottomSheets: Custom Popup Routes

Dialogs and BottomSheets are a bit different. They are typically "modal," meaning they block interaction with the underlying screen content. In Flutter, these are often implemented using `PopupRoute`. GetX provides its own custom `PopupRoute` implementations:
*   `GetDialogRoute` (from `lib/get_navigation/src/dialog/dialog_route.dart`)
*   `GetModalBottomSheetRoute` (from `lib/get_navigation/src/bottomsheet/bottomsheet.dart`)

When you call `Get.dialog()` or `Get.bottomSheet()`:
1.  The `Get` extension method (in `extension_navigation.dart`) takes your widget and parameters.
2.  It then uses `Navigator.of(Get.overlayContext!).push(...)` to push either a `GetDialogRoute` (for dialogs) or a `GetModalBottomSheetRoute` (for bottom sheets) onto the navigator's stack.

Here's a glimpse into `Get.dialog()` from `lib/get_navigation/src/extension_navigation.dart`:
```dart
// Simplified from extension_navigation.dart
Future<T?> dialog<T>(Widget widget, {/* ... params ... */}) {
  // ... theme setup ...
  return generalDialog<T>( // Calls a more generic dialog method
    pageBuilder: (buildContext, animation, secondaryAnimation) {
      // ... wraps widget with Theme, SafeArea etc. ...
      return widget; 
    },
    // ... other parameters like barrierDismissible, barrierColor ...
  );
}

Future<T?> generalDialog<T>({ required RoutePageBuilder pageBuilder, /*...*/}) {
  // Accesses the navigator via Get.overlayContext (or a specific key)
  final nav = /* ... Navigator.of(overlayContext!, rootNavigator: true) ... */;
  
  // Pushes GetX's custom dialog route
  return nav.push<T>( 
    GetDialogRoute<T>(
      pageBuilder: pageBuilder,
      // ... passes other parameters ...
    ),
  );
}
```
And for `Get.bottomSheet()`:
```dart
// Simplified from extension_navigation.dart
Future<T?> bottomSheet<T>(Widget bottomsheet, {/* ... params ... */}) {
  // Uses the Navigator from Get.overlayContext
  return Navigator.of(overlayContext!, rootNavigator: useRootNavigator)
      .push(GetModalBottomSheetRoute<T>( // Pushes GetX's custom bottom sheet route
          builder: (_) => bottomsheet,
          // ... passes many other parameters for customization ...
      ));
}
```
`GetDialogRoute` and `GetModalBottomSheetRoute` are subclasses of Flutter's `PopupRoute`. They handle the specifics of how the dialog or bottom sheet appears, animates, and interacts with the modal barrier (the dimming effect behind them).

So, for dialogs and bottom sheets, GetX leverages Flutter's standard navigation mechanism for `PopupRoute`s but makes them accessible via the simple `Get.dialog()` and `Get.bottomSheet()` calls, using `Get.overlayContext` to find the correct `Navigator`.

## Conclusion

You've just learned how GetX simplifies showing common temporary UI elements—Snackbars, Dialogs, and BottomSheets—much like a hotel concierge assisting with quick notes, private meetings, or information panels.

The key takeaways are:
*   GetX provides easy, context-less APIs like `Get.snackbar()`, `Get.dialog()`, and `Get.bottomSheet()`.
*   `SnackbarController` manages the lifecycle and queue of snackbars efficiently.
*   Dialogs and BottomSheets are presented using custom `PopupRoute` implementations (`GetDialogRoute`, `GetModalBottomSheetRoute`) that GetX makes easy to invoke.
*   All this is possible because `GetMaterialApp` (via `GetRoot`) sets up the necessary global access to Flutter's `Overlay` and `Navigator`.

With these tools, you can create a more interactive and communicative user experience with minimal boilerplate code.

In the next chapter, we'll delve into how GetX understands the named routes you define with `GetPage` and how it handles parameters in those routes. Get ready for [Route Parsing & Configuration (RouteDecoder, PageSettings, ParseRouteTree)](05_route_parsing___configuration__routedecoder__pagesettings__parseroutetree__.md)!

Relevant Code Snippets (Code itself remains unchanged):
--- File: lib/get_navigation/src/routes/get_router_delegate.dart ---
import 'dart:async';

import 'package:flutter/foundation.dart';
import 'package:flutter/material.dart';

import '../../../get_instance/src/bindings_interface.dart';
import '../../../get_utils/src/platform/platform.dart';
import '../../../route_manager.dart';

class GetDelegate extends RouterDelegate<RouteDecoder>
    with
        ChangeNotifier,
        PopNavigatorRouterDelegateMixin<RouteDecoder>,
        IGetNavigation {
  factory GetDelegate.createDelegate({
    GetPage<dynamic>? notFoundRoute,
    List<GetPage> pages = const [],
    List<NavigatorObserver>? navigatorObservers,
    TransitionDelegate<dynamic>? transitionDelegate,
    PopMode backButtonPopMode = PopMode.history,
    PreventDuplicateHandlingMode preventDuplicateHandlingMode =
        PreventDuplicateHandlingMode.reorderRoutes,
    GlobalKey<NavigatorState>? navigatorKey,
  }) {
    return GetDelegate(
      notFoundRoute: notFoundRoute,
      navigatorObservers: navigatorObservers,
      transitionDelegate: transitionDelegate,
      backButtonPopMode: backButtonPopMode,
      preventDuplicateHandlingMode: preventDuplicateHandlingMode,
      pages: pages,
      navigatorKey: navigatorKey,
    );
  }

  final List<RouteDecoder> _activePages = <RouteDecoder>[];
  final PopMode backButtonPopMode;
  final PreventDuplicateHandlingMode preventDuplicateHandlingMode;

  final GetPage notFoundRoute;

  final List<NavigatorObserver>? navigatorObservers;
  final TransitionDelegate<dynamic>? transitionDelegate;

  final Iterable<GetPage> Function(RouteDecoder currentNavStack)?
      pickPagesForRootNavigator;

  List<RouteDecoder> get activePages => _activePages;

  final _routeTree = ParseRouteTree(routes: []);

  List<GetPage> get registeredRoutes => _routeTree.routes;

  void addPages(List<GetPage> getPages) {
    _routeTree.addRoutes(getPages);
  }

  void clearRouteTree() {
    _routeTree.routes.clear();
  }

  void addPage(GetPage getPage) {
    _routeTree.addRoute(getPage);
  }

  void removePage(GetPage getPage) {
    _routeTree.removeRoute(getPage);
  }

  RouteDecoder matchRoute(String name, {PageSettings? arguments}) {
    return _routeTree.matchRoute(name, arguments: arguments);
  }

  // GlobalKey<NavigatorState> get navigatorKey => Get.key;

  @override
  GlobalKey<NavigatorState> navigatorKey;

  final String? restorationScopeId;

  GetDelegate({
    GetPage? notFoundRoute,
    this.navigatorObservers,
    this.transitionDelegate,
    this.backButtonPopMode = PopMode.history,
    this.preventDuplicateHandlingMode =
        PreventDuplicateHandlingMode.reorderRoutes,
    this.pickPagesForRootNavigator,
    this.restorationScopeId,
    bool showHashOnUrl = false,
    GlobalKey<NavigatorState>? navigatorKey,
    required List<GetPage> pages,
  })  : navigatorKey = navigatorKey ?? GlobalKey<NavigatorState>(),
        notFoundRoute = notFoundRoute ??= GetPage(
          name: '/404',
          page: () => const Scaffold(
            body: Center(child: Text('Route not found')),
          ),
        ) {
    if (!showHashOnUrl && GetPlatform.isWeb) setUrlStrategy();
    addPages(pages);
    addPage(notFoundRoute);
    Get.log('GetDelegate is created !');
  }

  Future<RouteDecoder?> runMiddleware(RouteDecoder config) async {
    final middlewares = config.currentTreeBranch.last.middlewares;
    if (middlewares.isEmpty) {
      return config;
    }
    var iterator = config;
    for (var item in middlewares) {
      var redirectRes = await item.redirectDelegate(iterator);

      if (redirectRes == null) {
        config.route?.completer?.complete();
        return null;
      }
      if (config != redirectRes) {
        config.route?.completer?.complete();
        Get.log('Redirect to ${redirectRes.pageSettings?.name}');
      }

      iterator = redirectRes;
      // Stop the iteration over the middleware if we changed page
      // and that redirectRes is not the same as the current config.
      if (config != redirectRes) {
        break;
      }
    }
    // If the target is not the same as the source, we need
    // to run the middlewares for the new route.
    if (iterator != config) {
      return await runMiddleware(iterator);
    }
    return iterator;
  }

  Future<void> _unsafeHistoryAdd(RouteDecoder config) async {
    final res = await runMiddleware(config);
    if (res == null) return;
    _activePages.add(res);
  }

  // Future<T?> _unsafeHistoryRemove<T>(RouteDecoder config, T result) async {
  //   var index = _activePages.indexOf(config);
  //   if (index >= 0) return _unsafeHistoryRemoveAt(index, result);
  //   return null;
  // }

  Future<T?> _unsafeHistoryRemoveAt<T>(int index, T result) async {
    if (index == _activePages.length - 1 && _activePages.length > 1) {
      //removing WILL update the current route
      final toCheck = _activePages[_activePages.length - 2];
      final resMiddleware = await runMiddleware(toCheck);
      if (resMiddleware == null) return null;
      _activePages[_activePages.length - 2] = resMiddleware;
    }

    final completer = _activePages.removeAt(index).route?.completer;
    if (completer?.isCompleted == false) completer!.complete(result);

    return completer?.future as T?;
  }

  T arguments<T>() {
    return currentConfiguration?.pageSettings?.arguments as T;
  }

  Map<String, String> get parameters {
    return currentConfiguration?.pageSettings?.params ?? {};
  }

  PageSettings? get pageSettings {
    return currentConfiguration?.pageSettings;
  }

  Future<void> _pushHistory(RouteDecoder config) async {
    if (config.route!.preventDuplicates) {
      final originalEntryIndex = _activePages.indexWhere(
          (element) => element.pageSettings?.name == config.pageSettings?.name);
      if (originalEntryIndex >= 0) {
        switch (preventDuplicateHandlingMode) {
          case PreventDuplicateHandlingMode.popUntilOriginalRoute:
            popModeUntil(config.pageSettings!.name, popMode: PopMode.page);
            break;
          case PreventDuplicateHandlingMode.reorderRoutes:
            await _unsafeHistoryRemoveAt(originalEntryIndex, null);
            await _unsafeHistoryAdd(config);
            break;
          case PreventDuplicateHandlingMode.doNothing:
          default:
            break;
        }
        return;
      }
    }
    await _unsafeHistoryAdd(config);
  }

  Future<T?> _popHistory<T>(T result) async {
    if (!_canPopHistory()) return null;
    return await _doPopHistory(result);
  }

  Future<T?> _doPopHistory<T>(T result) async {
    return _unsafeHistoryRemoveAt<T>(_activePages.length - 1, result);
  }

  Future<T?> _popPage<T>(T result) async {
    if (!_canPopPage()) return null;
    return await _doPopPage(result);
  }

  // returns the popped page
  Future<T?> _doPopPage<T>(T result) async {
    final currentBranch = currentConfiguration?.currentTreeBranch;
    if (currentBranch != null && currentBranch.length > 1) {
      //remove last part only
      final remaining = currentBranch.take(currentBranch.length - 1);
      final prevHistoryEntry = _activePages.length > 1
          ? _activePages[_activePages.length - 2]
          : null;

      //check if current route is the same as the previous route
      if (prevHistoryEntry != null) {
        //if so, pop the entire _activePages entry
        final newLocation = remaining.last.name;
        final prevLocation = prevHistoryEntry.pageSettings?.name;
        if (newLocation == prevLocation) {
          //pop the entire _activePages entry
          return await _popHistory(result);
        }
      }

      //create a new route with the remaining tree branch
      final res = await _popHistory<T>(result);
      await _pushHistory(
        RouteDecoder(
          remaining.toList(),
          null,
          //TOOD: persist state??
        ),
      );
      return res;
    } else {
      //remove entire entry
      return await _popHistory(result);
    }
  }

  Future<T?> _pop<T>(PopMode mode, T result) async {
    switch (mode) {
      case PopMode.history:
        return await _popHistory<T>(result);
      case PopMode.page:
        return await _popPage<T>(result);
    }
  }

  Future<T?> popHistory<T>(T result) async {
    return await _popHistory<T>(result);
  }

  bool _canPopHistory() {
    return _activePages.length > 1;
  }

  Future<bool> canPopHistory() {
    return SynchronousFuture(_canPopHistory());
  }

  bool _canPopPage() {
    final currentTreeBranch = currentConfiguration?.currentTreeBranch;
    if (currentTreeBranch == null) return false;
    return currentTreeBranch.length > 1 ? true : _canPopHistory();
  }

  Future<bool> canPopPage() {
    return SynchronousFuture(_canPopPage());
  }

  bool _canPop(mode) {
    switch (mode) {
      case PopMode.history:
        return _canPopHistory();
      case PopMode.page:
      default:
        return _canPopPage();
    }
  }

  /// gets the visual pages from the current _activePages entry
  ///
  /// visual pages must have [GetPage.participatesInRootNavigator] set to true
  Iterable<GetPage> getVisualPages(RouteDecoder? currentHistory) {
    final res = currentHistory!.currentTreeBranch
        .where((r) => r.participatesInRootNavigator != null);
    if (res.isEmpty) {
      //default behavior, all routes participate in root navigator
      return _activePages.map((e) => e.route!);
    } else {
      //user specified at least one participatesInRootNavigator
      return res
          .where((element) => element.participatesInRootNavigator == true);
    }
  }

  @override
  Widget build(BuildContext context) {
    final currentHistory = currentConfiguration;
    final pages = currentHistory == null
        ? <GetPage>[]
        : pickPagesForRootNavigator?.call(currentHistory).toList() ??
            getVisualPages(currentHistory).toList();
    if (pages.isEmpty) {
      return ColoredBox(
        color: Theme.of(context).scaffoldBackgroundColor,
      );
    }
    return GetNavigator(
      key: navigatorKey,
      onPopPage: _onPopVisualRoute,
      pages: pages,
      observers: navigatorObservers,
      transitionDelegate:
          transitionDelegate ?? const DefaultTransitionDelegate<dynamic>(),
    );
  }

  @override
  Future<void> goToUnknownPage([bool clearPages = false]) async {
    if (clearPages) _activePages.clear();

    final pageSettings = _buildPageSettings(notFoundRoute.name);
    final routeDecoder = _getRouteDecoder(pageSettings);

    _push(routeDecoder!);
  }

  @protected
  void _popWithResult<T>([T? result]) {
    final completer = _activePages.removeLast().route?.completer;
    if (completer?.isCompleted == false) completer!.complete(result);
  }

  @override
  Future<T?> toNamed<T>(
    String page, {
    dynamic arguments,
    dynamic id,
    bool preventDuplicates = true,
    Map<String, String>? parameters,
  }) async {
    final args = _buildPageSettings(page, arguments);
    final route = _getRouteDecoder<T>(args);
    if (route != null) {
      return _push<T>(route);
    } else {
      goToUnknownPage();
    }
    return null;
  }

  @override
  Future<T?> to<T>(
    Widget Function() page, {
    bool? opaque,
    Transition? transition,
    Curve? curve,
    Duration? duration,
    String? id,
    String? routeName,
    bool fullscreenDialog = false,
    dynamic arguments,
    List<BindingsInterface> bindings = const [],
    bool preventDuplicates = true,
    bool? popGesture,
    bool showCupertinoParallax = true,
    double Function(BuildContext context)? gestureWidth,
    bool rebuildStack = true,
    PreventDuplicateHandlingMode preventDuplicateHandlingMode =
        PreventDuplicateHandlingMode.reorderRoutes,
  }) async {
    routeName ??= _cleanRouteName("/${page.runtimeType}");
    // if (preventDuplicateHandlingMode ==
    //PreventDuplicateHandlingMode.Recreate) {
    //   routeName = routeName + page.hashCode.toString();
    // }

    final getPage = GetPage<T>(
      name: routeName,
      opaque: opaque ?? true,
      page: page,
      gestureWidth: gestureWidth,
      showCupertinoParallax: showCupertinoParallax,
      popGesture: popGesture ?? Get.defaultPopGesture,
      transition: transition ?? Get.defaultTransition,
      curve: curve ?? Get.defaultTransitionCurve,
      fullscreenDialog: fullscreenDialog,
      bindings: bindings,
      transitionDuration: duration ?? Get.defaultTransitionDuration,
      preventDuplicateHandlingMode: preventDuplicateHandlingMode,
    );

    _routeTree.addRoute(getPage);
    final args = _buildPageSettings(routeName, arguments);
    final route = _getRouteDecoder<T>(args);
    final result = await _push<T>(
      route!,
      rebuildStack: rebuildStack,
    );
    _routeTree.removeRoute(getPage);
    return result;
  }

  @override
  Future<T?> off<T>(
    Widget Function() page, {
    bool? opaque,
    Transition? transition,
    Curve? curve,
    Duration? duration,
    String? id,
    String? routeName,
    bool fullscreenDialog = false,
    dynamic arguments,
    List<BindingsInterface> bindings = const [],
    bool preventDuplicates = true,
    bool? popGesture,
    bool showCupertinoParallax = true,
    double Function(BuildContext context)? gestureWidth,
  }) async {
    routeName ??= _cleanRouteName("/${page.runtimeType}");
    final route = GetPage<T>(
      name: routeName,
      opaque: opaque ?? true,
      page: page,
      gestureWidth: gestureWidth,
      showCupertinoParallax: showCupertinoParallax,
      popGesture: popGesture ?? Get.defaultPopGesture,
      transition: transition ?? Get.defaultTransition,
      curve: curve ?? Get.defaultTransitionCurve,
      fullscreenDialog: fullscreenDialog,
      bindings: bindings,
      transitionDuration: duration ?? Get.defaultTransitionDuration,
    );

    final args = _buildPageSettings(routeName, arguments);
    return _replace(args, route);
  }

  @override
  Future<T?>? offAll<T>(
    Widget Function() page, {
    bool Function(GetPage route)? predicate,
    bool opaque = true,
    bool? popGesture,
    String? id,
    String? routeName,
    dynamic arguments,
    List<BindingsInterface> bindings = const [],
    bool fullscreenDialog = false,
    Transition? transition,
    Curve? curve,
    Duration? duration,
    bool showCupertinoParallax = true,
    double Function(BuildContext context)? gestureWidth,
  }) async {
    routeName ??= _cleanRouteName("/${page.runtimeType}");
    final route = GetPage<T>(
      name: routeName,
      opaque: opaque,
      page: page,
      gestureWidth: gestureWidth,
      showCupertinoParallax: showCupertinoParallax,
      popGesture: popGesture ?? Get.defaultPopGesture,
      transition: transition ?? Get.defaultTransition,
      curve: curve ?? Get.defaultTransitionCurve,
      fullscreenDialog: fullscreenDialog,
      bindings: bindings,
      transitionDuration: duration ?? Get.defaultTransitionDuration,
    );

    final args = _buildPageSettings(routeName, arguments);

    final newPredicate = predicate ?? (route) => false;

    while (_activePages.length > 1 && !newPredicate(_activePages.last.route!)) {
      _popWithResult();
    }

    return _replace(args, route);
  }

  @override
  Future<T?>? offAllNamed<T>(
    String newRouteName, {
    // bool Function(GetPage route)? predicate,
    dynamic arguments,
    String? id,
    Map<String, String>? parameters,
  }) async {
    final args = _buildPageSettings(newRouteName, arguments);
    final route = _getRouteDecoder<T>(args);
    if (route == null) return null;

    while (_activePages.length > 1) {
      _activePages.removeLast();
    }

    return _replaceNamed(route);
  }

  @override
  Future<T?>? offNamedUntil<T>(
    String page, {
    bool Function(GetPage route)? predicate,
    dynamic arguments,
    String? id,
    Map<String, String>? parameters,
  }) async {
    final args = _buildPageSettings(page, arguments);
    final route = _getRouteDecoder<T>(args);
    if (route == null) return null;

    final newPredicate = predicate ?? (route) => false;

    while (_activePages.length > 1 && !newPredicate(_activePages.last.route!)) {
      _activePages.removeLast();
    }

    return _push(route);
  }

  @override
  Future<T?> offNamed<T>(
    String page, {
    dynamic arguments,
    String? id,
    Map<String, String>? parameters,
  }) async {
    final args = _buildPageSettings(page, arguments);
    final route = _getRouteDecoder<T>(args);
    if (route == null) return null;
    _popWithResult();
    return _push<T>(route);
  }

  @override
  Future<T?> toNamedAndOffUntil<T>(
    String page,
    bool Function(GetPage) predicate, [
    Object? data,
  ]) async {
    final arguments = _buildPageSettings(page, data);

    final route = _getRouteDecoder<T>(arguments);

    if (route == null) return null;

    while (_activePages.isNotEmpty && !predicate(_activePages.last.route!)) {
      _popWithResult();
    }

    return _push<T>(route);
  }

  @override
  Future<T?> offUntil<T>(
    Widget Function() page,
    bool Function(GetPage) predicate, [
    Object? arguments,
  ]) async {
    while (_activePages.isNotEmpty && !predicate(_activePages.last.route!)) {
      _popWithResult();
    }

    return to<T>(page, arguments: arguments);
  }

  @override
  void removeRoute<T>(String name) {
    _activePages.remove(RouteDecoder.fromRoute(name));
  }

  bool get canBack {
    return _activePages.length > 1;
  }

  void _checkIfCanBack() {
    assert(() {
      if (!canBack) {
        final last = _activePages.last;
        final name = last.route?.name;
        throw 'The page $name cannot be popped';
      }
      return true;
    }());
  }

  @override
  Future<R?> backAndtoNamed<T, R>(String page,
      {T? result, Object? arguments}) async {
    final args = _buildPageSettings(page, arguments);
    final route = _getRouteDecoder<R>(args);
    if (route == null) return null;
    _popWithResult<T>(result);
    return _push<R>(route);
  }

  /// Removes routes according to [PopMode]
  /// until it reaches the specific [fullRoute],
  /// DOES NOT remove the [fullRoute]
  @override
  Future<void> popModeUntil(
    String fullRoute, {
    PopMode popMode = PopMode.history,
  }) async {
    // remove history or page entries until you meet route
    var iterator = currentConfiguration;
    while (_canPop(popMode) && iterator != null) {
      //the next line causes wasm compile error if included in the while loop
      //https://github.com/flutter/flutter/issues/140110
      if (iterator.pageSettings?.name == fullRoute) {
        break;
      }
      await _pop(popMode, null);
      // replace iterator
      iterator = currentConfiguration;
    }
    notifyListeners();
  }

  @override
  void backUntil(bool Function(GetPage) predicate) {
    while (_activePages.length > 1 && !predicate(_activePages.last.route!)) {
      _popWithResult();
    }

    notifyListeners();
  }

  Future<T?> _replace<T>(PageSettings arguments, GetPage<T> page) async {
    final index = _activePages.length > 1 ? _activePages.length - 1 : 0;
    _routeTree.addRoute(page);

    final activePage = _getRouteDecoder(arguments);

    // final activePage = _configureRouterDecoder<T>(route!, arguments);

    _activePages[index] = activePage!;

    notifyListeners();
    final result = await activePage.route?.completer?.future as Future<T?>?;
    _routeTree.removeRoute(page);

    return result;
  }

  Future<T?> _replaceNamed<T>(RouteDecoder activePage) async {
    final index = _activePages.length > 1 ? _activePages.length - 1 : 0;
    // final activePage = _configureRouterDecoder<T>(page, arguments);
    _activePages[index] = activePage;

    notifyListeners();
    final result = await activePage.route?.completer?.future as Future<T?>?;
    return result;
  }

  /// Takes a route [name] String generated by [to], [off], [offAll]
  /// (and similar context navigation methods), cleans the extra chars and
  /// accommodates the format.
  /// TODO: check for a more "appealing" URL naming convention.
  /// `() => MyHomeScreenView` becomes `/my-home-screen-view`.
  String _cleanRouteName(String name) {
    name = name.replaceAll('() => ', '');

    /// uncomment for URL styling.
    // name = name.paramCase!;
    if (!name.startsWith('/')) {
      name = '/$name';
    }
    return Uri.tryParse(name)?.toString() ?? name;
  }

  PageSettings _buildPageSettings(String page, [Object? data]) {
    var uri = Uri.parse(page);
    return PageSettings(uri, data);
  }

  @protected
  RouteDecoder? _getRouteDecoder<T>(PageSettings arguments) {
    var page = arguments.uri.path;
    final parameters = arguments.params;
    if (parameters.isNotEmpty) {
      final uri = Uri(path: page, queryParameters: parameters);
      page = uri.toString();
    }

    final decoder = _routeTree.matchRoute(page, arguments: arguments);
    final route = decoder.route;
    if (route == null) return null;

    return _configureRouterDecoder<T>(decoder, arguments);
  }

  @protected
  RouteDecoder _configureRouterDecoder<T>(
      RouteDecoder decoder, PageSettings arguments) {
    final parameters =
        arguments.params.isEmpty ? arguments.query : arguments.params;
    arguments.params.addAll(arguments.query);
    if (decoder.parameters.isEmpty) {
      decoder.parameters.addAll(parameters);
    }

    decoder.route = decoder.route?.copyWith(
      completer: _activePages.isEmpty ? null : Completer<T?>(),
      arguments: arguments,
      parameters: parameters,
      key: ValueKey(arguments.name),
    );

    return decoder;
  }

  Future<T?> _push<T>(RouteDecoder decoder, {bool rebuildStack = true}) async {
    var res = await runMiddleware(decoder);
    if (res == null) return null;
    // final res = mid ?? decoder;
    // if (res == null) res = decoder;

    final preventDuplicateHandlingMode =
        res.route?.preventDuplicateHandlingMode ??
            PreventDuplicateHandlingMode.reorderRoutes;

    final onStackPage = _activePages
        .firstWhereOrNull((element) => element.route?.key == res.route?.key);

    /// There are no duplicate routes in the stack
    if (onStackPage == null) {
      _activePages.add(res);
    } else {
      /// There are duplicate routes, reorder
      switch (preventDuplicateHandlingMode) {
        case PreventDuplicateHandlingMode.doNothing:
          break;
        case PreventDuplicateHandlingMode.reorderRoutes:
          _activePages.remove(onStackPage);
          _activePages.add(res);
          break;
        case PreventDuplicateHandlingMode.popUntilOriginalRoute:
          while (_activePages.last == onStackPage) {
            _popWithResult();
          }
          break;
        case PreventDuplicateHandlingMode.recreate:
          _activePages.remove(onStackPage);
          _activePages.add(res);
      }
    }
    if (rebuildStack) {
      notifyListeners();
    }

    return decoder.route?.completer?.future as Future<T?>?;
  }

  @override
  Future<void> setNewRoutePath(RouteDecoder configuration) async {
    final page = configuration.route;
    if (page == null) {
      goToUnknownPage();
      return;
    } else {
      _push(configuration);
    }
  }

  @override
  RouteDecoder? get currentConfiguration {
    if (_activePages.isEmpty) return null;
    final route = _activePages.last;
    return route;
  }

  Future<bool> handlePopupRoutes({
    Object? result,
  }) async {
    Route? currentRoute;
    navigatorKey.currentState!.popUntil((route) {
      currentRoute = route;
      return true;
    });
    if (currentRoute is PopupRoute) {
      return await navigatorKey.currentState!.maybePop(result);
    }
    return false;
  }

  @override
  Future<bool> popRoute({
    Object? result,
    PopMode? popMode,
  }) async {
    //Returning false will cause the entire app to be popped.
    final wasPopup = await handlePopupRoutes(result: result);
    if (wasPopup) return true;

    if (_canPop(popMode ?? backButtonPopMode)) {
      await _pop(popMode ?? backButtonPopMode, result);
      notifyListeners();
      return true;
    }

    return super.popRoute();
  }

  @override
  void back<T>([T? result]) {
    _checkIfCanBack();
    _popWithResult<T>(result);
    notifyListeners();
  }

  bool _onPopVisualRoute(Route<dynamic> route, dynamic result) {
    final didPop = route.didPop(result);
    if (!didPop) {
      return false;
    }
    _popWithResult(result);
    // final settings = route.settings;
    // if (settings is GetPage) {
    //   final config = _activePages.cast<RouteDecoder?>().firstWhere(
    //         (element) => element?.route == settings,
    //         orElse: () => null,
    //       );
    //   if (config != null) {
    //     _removeHistoryEntry(config, result);
    //   }
    // }
    notifyListeners();
    //return !route.navigator!.userGestureInProgress;
    return true;
  }
}


--- File: lib/get_navigation/src/routes/get_information_parser.dart ---
import 'package:flutter/foundation.dart';
import 'package:flutter/widgets.dart';

import '../../../get.dart';

class GetInformationParser extends RouteInformationParser<RouteDecoder> {
  factory GetInformationParser.createInformationParser(
      {String initialRoute = '/'}) {
    return GetInformationParser(initialRoute: initialRoute);
  }

  final String initialRoute;

  GetInformationParser({
    required this.initialRoute,
  }) {
    Get.log('GetInformationParser is created !');
  }
  @override
  SynchronousFuture<RouteDecoder> parseRouteInformation(
    RouteInformation routeInformation,
  ) {
    final uri = routeInformation.uri;
    var location = uri.toString();
    if (location == '/') {
      //check if there is a corresponding page
      //if not, relocate to initialRoute
      if (!(Get.rootController.rootDelegate)
          .registeredRoutes
          .any((element) => element.name == '/')) {
        location = initialRoute;
      }
    } else if (location.isEmpty) {
      location = initialRoute;
    }

    Get.log('GetInformationParser: route location: $location');

    return SynchronousFuture(RouteDecoder.fromRoute(location));
  }

  @override
  RouteInformation restoreRouteInformation(RouteDecoder configuration) {
    return RouteInformation(
      uri: Uri.tryParse(configuration.pageSettings?.name ?? ''),
      state: null,
    );
  }
}


--- File: lib/get_navigation/src/routes/parse_route.dart ---
import 'package:flutter/foundation.dart';

import '../../../get.dart';

@immutable
class RouteDecoder {
  const RouteDecoder(
    this.currentTreeBranch,
    this.pageSettings,
  );
  final List<GetPage> currentTreeBranch;
  final PageSettings? pageSettings;

  factory RouteDecoder.fromRoute(String location) {
    var uri = Uri.parse(location);
    final args = PageSettings(uri);
    final decoder =
        (Get.rootController.rootDelegate).matchRoute(location, arguments: args);
    decoder.route = decoder.route?.copyWith(
      completer: null,
      arguments: args,
      parameters: args.params,
    );
    return decoder;
  }

  GetPage? get route =>
      currentTreeBranch.isEmpty ? null : currentTreeBranch.last;

  GetPage routeOrUnknown(GetPage onUnknow) =>
      currentTreeBranch.isEmpty ? onUnknow : currentTreeBranch.last;

  set route(GetPage? getPage) {
    if (getPage == null) return;
    if (currentTreeBranch.isEmpty) {
      currentTreeBranch.add(getPage);
    } else {
      currentTreeBranch[currentTreeBranch.length - 1] = getPage;
    }
  }

  List<GetPage>? get currentChildren => route?.children;

  Map<String, String> get parameters => pageSettings?.params ?? {};

  dynamic get args {
    return pageSettings?.arguments;
  }

  T? arguments<T>() {
    final args = pageSettings?.arguments;
    if (args is T) {
      return pageSettings?.arguments as T;
    } else {
      return null;
    }
  }

  // void replaceArguments(Object? arguments) {
  //   final newRoute = route;
  //   if (newRoute != null) {
  //     final index = currentTreeBranch.indexOf(newRoute);
  //     currentTreeBranch[index] = newRoute.copyWith(arguments: arguments);
  //   }
  // }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;

    return other is RouteDecoder &&
        listEquals(other.currentTreeBranch, currentTreeBranch) &&
        other.pageSettings == pageSettings;
  }

  @override
  int get hashCode => currentTreeBranch.hashCode ^ pageSettings.hashCode;

  @override
  String toString() =>
      'RouteDecoder(currentTreeBranch: $currentTreeBranch, pageSettings: $pageSettings)';
}

class ParseRouteTree {
  ParseRouteTree({
    required this.routes,
  });

  final List<GetPage> routes;

  RouteDecoder matchRoute(String name, {PageSettings? arguments}) {
    final uri = Uri.parse(name);
    final split = uri.path.split('/').where((element) => element.isNotEmpty);
    var curPath = '/';
    final cumulativePaths = <String>[
      '/',
    ];
    for (var item in split) {
      if (curPath.endsWith('/')) {
        curPath += item;
      } else {
        curPath += '/$item';
      }
      cumulativePaths.add(curPath);
    }

    final treeBranch = cumulativePaths
        .map((e) => MapEntry(e, _findRoute(e)))
        .where((element) => element.value != null)

        ///Prevent page be disposed
        .map((e) => MapEntry(e.key, e.value!.copyWith(key: ValueKey(e.key))))
        .toList();

    final params = Map<String, String>.from(uri.queryParameters);
    if (treeBranch.isNotEmpty) {
      //route is found, do further parsing to get nested query params
      final lastRoute = treeBranch.last;
      final parsedParams = _parseParams(name, lastRoute.value.path);
      if (parsedParams.isNotEmpty) {
        params.addAll(parsedParams);
      }
      //copy parameters to all pages.
      final mappedTreeBranch = treeBranch
          .map(
            (e) => e.value.copyWith(
              parameters: {
                if (e.value.parameters != null) ...e.value.parameters!,
                ...params,
              },
              name: e.key,
            ),
          )
          .toList();
      arguments?.params.clear();
      arguments?.params.addAll(params);
      return RouteDecoder(
        mappedTreeBranch,
        arguments,
      );
    }

    arguments?.params.clear();
    arguments?.params.addAll(params);

    //route not found
    return RouteDecoder(
      treeBranch.map((e) => e.value).toList(),
      arguments,
    );
  }

  void addRoutes<T>(List<GetPage<T>> getPages) {
    for (final route in getPages) {
      addRoute(route);
    }
  }

  void removeRoutes<T>(List<GetPage<T>> getPages) {
    for (final route in getPages) {
      removeRoute(route);
    }
  }

  void removeRoute<T>(GetPage<T> route) {
    routes.remove(route);
    for (var page in _flattenPage(route)) {
      removeRoute(page);
    }
  }

  void addRoute<T>(GetPage<T> route) {
    routes.add(route);

    // Add Page children.
    for (var page in _flattenPage(route)) {
      addRoute(page);
    }
  }

  List<GetPage> _flattenPage(GetPage route) {
    final result = <GetPage>[];
    if (route.children.isEmpty) {
      return result;
    }

    final parentPath = route.name;
    for (var page in route.children) {
      // Add Parent middlewares to children
      final parentMiddlewares = [
        if (page.middlewares.isNotEmpty) ...page.middlewares,
        if (route.middlewares.isNotEmpty) ...route.middlewares
      ];

      final parentBindings = [
        if (page.binding != null) page.binding!,
        if (page.bindings.isNotEmpty) ...page.bindings,
        if (route.bindings.isNotEmpty) ...route.bindings
      ];

      final parentBinds = [
        if (page.binds.isNotEmpty) ...page.binds,
        if (route.binds.isNotEmpty) ...route.binds
      ];

      result.add(
        _addChild(
          page,
          parentPath,
          parentMiddlewares,
          parentBindings,
          parentBinds,
        ),
      );

      final children = _flattenPage(page);
      for (var child in children) {
        result.add(_addChild(
          child,
          parentPath,
          [
            ...parentMiddlewares,
            if (child.middlewares.isNotEmpty) ...child.middlewares,
          ],
          [
            ...parentBindings,
            if (child.binding != null) child.binding!,
            if (child.bindings.isNotEmpty) ...child.bindings,
          ],
          [
            ...parentBinds,
            if (child.binds.isNotEmpty) ...child.binds,
          ],
        ));
      }
    }
    return result;
  }

  /// Change the Path for a [GetPage]
  GetPage _addChild(
    GetPage origin,
    String parentPath,
    List<GetMiddleware> middlewares,
    List<BindingsInterface> bindings,
    List<Bind> binds,
  ) {
    return origin.copyWith(
      middlewares: middlewares,
      name: origin.inheritParentPath
          ? (parentPath + origin.name).replaceAll(r'//', '/')
          : origin.name,
      bindings: bindings,
      binds: binds,
      // key:
    );
  }

  GetPage? _findRoute(String name) {
    final value = routes.firstWhereOrNull(
      (route) => route.path.regex.hasMatch(name),
    );

    return value;
  }

  Map<String, String> _parseParams(String path, PathDecoded routePath) {
    final params = <String, String>{};
    var idx = path.indexOf('?');
    final uri = Uri.tryParse(path);
    if (uri == null) return params;
    if (idx > -1) {
      params.addAll(uri.queryParameters);
    }
    var paramsMatch = routePath.regex.firstMatch(uri.path);
    if (paramsMatch == null) {
      return params;
    }
    for (var i = 0; i < routePath.keys.length; i++) {
      var param = Uri.decodeQueryComponent(paramsMatch[i + 1]!);
      params[routePath.keys[i]!] = param;
    }
    return params;
  }
}

extension FirstWhereOrNullExt<T> on List<T> {
  /// The first element satisfying [test], or `null` if there are none.
  T? firstWhereOrNull(bool Function(T element) test) {
    for (var element in this) {
      if (test(element)) return element;
    }
    return null;
  }
}


--- File: lib/get_navigation/src/routes/page_settings.dart ---
import 'package:flutter/widgets.dart';

import '../../../route_manager.dart';

extension PageArgExt on BuildContext {
  RouteSettings? get settings {
    return ModalRoute.of(this)!.settings;
  }

  PageSettings? get pageSettings {
    final args = ModalRoute.of(this)?.settings.arguments;
    if (args is PageSettings) {
      return args;
    }
    return null;
  }

  dynamic get arguments {
    final args = settings?.arguments;
    if (args is PageSettings) {
      return args.arguments;
    } else {
      return args;
    }
  }

  Map<String, String> get params {
    final args = settings?.arguments;
    if (args is PageSettings) {
      return args.params;
    } else {
      return {};
    }
  }

  Router get router {
    return Router.of(this);
  }

  String get location {
    final parser = router.routeInformationParser;
    final config = delegate.currentConfiguration;
    return parser?.restoreRouteInformation(config)?.uri.toString() ?? '/';
  }

  GetDelegate get delegate {
    return router.routerDelegate as GetDelegate;
  }
}

class PageSettings extends RouteSettings {
  PageSettings(
    this.uri, [
    Object? arguments,
  ]) : super(arguments: arguments);

  @override
  String get name => '$uri';

  final Uri uri;

  final params = <String, String>{};

  String get path => uri.path;

  List<String> get paths => uri.pathSegments;

  Map<String, String> get query => uri.queryParameters;

  Map<String, List<String>> get queries => uri.queryParametersAll;

  @override
  String toString() => name;

  PageSettings copy({
    Uri? uri,
    Object? arguments,
  }) {
    return PageSettings(
      uri ?? this.uri,
      arguments ?? this.arguments,
    );
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;

    return other is PageSettings &&
        other.uri == uri &&
        other.arguments == arguments;
  }

  @override
  int get hashCode => uri.hashCode ^ arguments.hashCode;
}


Instructions for the chapter (Generate content in English unless specified otherwise):
- Start with a clear heading (e.g., `# Chapter 5: Route Parsing & Configuration (RouteDecoder, PageSettings, ParseRouteTree)
`). Use the provided concept name.

- If this is not the first chapter, begin with a brief transition from the previous chapter, referencing it with a proper Markdown link using its name.

- Begin with a high-level motivation explaining what problem this abstraction solves. Start with a central use case as a concrete example. The whole chapter should guide the reader to understand how to solve this use case. Make it very minimal and friendly to beginners.

- If the abstraction is complex, break it down into key concepts. Explain each concept one-by-one in a very beginner-friendly way.

- Explain how to use this abstraction to solve the use case. Give example inputs and outputs for code snippets (if the output isn't values, describe at a high level what will happen).

- Each code block should be BELOW 10 lines! If longer code blocks are needed, break them down into smaller pieces and walk through them one-by-one. Aggresively simplify the code to make it minimal. Use comments to skip non-important implementation details. Each code block should have a beginner friendly explanation right after it.

- Describe the internal implementation to help understand what's under the hood. First provide a non-code or code-light walkthrough on what happens step-by-step when the abstraction is called. It's recommended to use a simple sequenceDiagram with a dummy example - keep it minimal with at most 5 participants to ensure clarity. If participant name has space, use: `participant QP as Query Processing`. .

- Then dive deeper into code for the internal implementation with references to files. Provide example code blocks, but make them similarly simple and beginner-friendly. Explain.

- IMPORTANT: When you need to refer to other core abstractions covered in other chapters, ALWAYS use proper Markdown links like this: [Chapter Title](filename.md). Use the Complete Tutorial Structure above to find the correct filename and the chapter title. Translate the surrounding text.

- Use mermaid diagrams to illustrate complex concepts (```mermaid``` format). .

- Heavily use analogies and examples throughout to help beginners understand.

- End the chapter with a brief conclusion that summarizes what was learned and provides a transition to the next chapter. If there is a next chapter, use a proper Markdown link: [Next Chapter Title](next_chapter_filename).

- Ensure the tone is welcoming and easy for a newcomer to understand.

- Output *only* the Markdown content for this chapter.

Now, directly provide a super beginner-friendly Markdown output (DON'T need ```markdown``` tags):

2025-05-16 11:10:00,206 - INFO - RESPONSE: # Chapter 5: Route Parsing & Configuration (RouteDecoder, PageSettings, ParseRouteTree)

Welcome back! In [Chapter 4: Overlay Management (Snackbar, Dialog, BottomSheet)](04_overlay_management__snackbar__dialog__bottomsheet__.md), we explored how GetX simplifies showing UI overlays. Now, let's uncover the magic behind how GetX understands the addresses (routes) you navigate to, especially when they include dynamic parts like user IDs or query parameters.

## The App's Address System: Why Do We Need This?

Imagine your app is like a big city, and each screen is a building with a specific address. Sometimes, these addresses are simple, like `/home`. But often, they're more complex, like `/users/123` (showing user with ID 123) or `/products?category=electronics&sort=price` (showing electronic products sorted by price).

How does your app:
1.  Know which screen corresponds to `/users/123`?
2.  Extract the ID `123` so the screen can fetch the correct user data?
3.  Understand that `category=electronics` and `sort=price` are special instructions for the products screen?

This is where GetX's route parsing and configuration system comes in. It's like your app's combined **address book and highly intelligent postal service**.

*   **`ParseRouteTree`**: Think of this as the **master address book**. It holds a structured list of all possible "addresses" (routes) your app knows, including how they might be nested.
*   **`PageSettings`**: This is like an **individual envelope** for a specific navigation request. It contains the destination address, and importantly, any special data like user IDs (path parameters) or filtering options (query parameters).
*   **`RouteDecoder`**: This is the clever **postal worker**. When you say "go to `/users/123?mode=edit`", the `RouteDecoder` looks up this address in the `ParseRouteTree`, figures out it's for a user screen, extracts the ID `123` and the `mode=edit` instruction, and prepares the `PageSettings` "envelope" so the correct screen can be delivered with the right information.

Let's see how these components work together.

## Defining Routes with Parameters

In [Chapter 3: GetPage & GetRouterDelegate](03_getpage___getrouterdelegate__.md), we learned about `GetPage` for defining named routes. We can make these routes dynamic.

Suppose we want a screen to display user profiles. The route might look like `/users/:id`, where `:id` is a placeholder for the user's actual ID.

First, let's define this in our `GetMaterialApp`'s `getPages`:

```dart
// main.dart (or your routes file)
List<GetPage> appPages = [
  GetPage(name: '/', page: () => HomeScreen()),
  GetPage(
    name: '/users/:id', // The :id part is a path parameter
    page: () => UserProfileScreen(),
  ),
  // ... other pages
];
```
Here, `/users/:id` tells GetX that any route starting with `/users/` followed by some value should be handled by `UserProfileScreen`. That value will be available as the `id` parameter.

## Accessing Parameters in Your Screen

Now, when we navigate to, say, `/users/123`, how does `UserProfileScreen` get this `123`? GetX makes it easy with `Get.parameters`.

```dart
// user_profile_screen.dart
import 'package:flutter/material.dart';
import 'package:get/get.dart';

class UserProfileScreen extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    // Accessing the 'id' path parameter
    final String? userId = Get.parameters['id'];

    // Accessing a query parameter, e.g., if URL was /users/123?mode=view
    final String? mode = Get.parameters['mode'];

    return Scaffold(
      appBar: AppBar(title: Text('User Profile: $userId')),
      body: Center(
        child: Text('Displaying profile for user ID: $userId. Mode: $mode'),
      ),
    );
  }
}
```
If we navigate using `Get.toNamed('/users/456?mode=edit')`:
*   `Get.parameters['id']` would give you `"456"`.
*   `Get.parameters['mode']` would give you `"edit"`.

Simple, right? `Get.parameters` is a map containing all parsed path and query parameters.

## How It Works: The Journey of a Route

Let's trace what happens when you call `Get.toNamed('/users/123?mode=edit')`.

1.  **The Request**: Your code calls `Get.toNamed('/users/123?mode=edit')`.
2.  **Delegate Receives**: This request goes to the `GetRouterDelegate` (our app's navigation captain, from [Chapter 3: GetPage & GetRouterDelegate](03_getpage___getrouterdelegate__.md)).
3.  **Consulting the Address Book (`ParseRouteTree`)**:
    *   The `GetRouterDelegate` has an instance of `ParseRouteTree`. This tree was built when your app started, using the `getPages` list you provided to `GetMaterialApp`.
    *   The delegate asks `ParseRouteTree` to `matchRoute('/users/123?mode=edit')`.
4.  **Finding the Match & Preparing the Envelope (`PageSettings`)**:
    *   `ParseRouteTree` searches through its known `GetPage` definitions. It finds that `/users/:id` matches the path `/users/123`.
    *   It an instance of `PageSettings`. This object holds the original URI and is used to store parsed parameters.
    *   `ParseRouteTree` extracts `123` as the value for the path parameter `id`.
    *   It also parses the query part `?mode=edit` and extracts `mode` with the value `edit`.
    *   These parameters (`id: '123'`, `mode: 'edit'`) are stored within the `PageSettings` object.
5.  **The Postal Worker (`RouteDecoder`)**:
    *   `ParseRouteTree` then creates a `RouteDecoder` object. This `RouteDecoder` bundles:
        *   The matched `GetPage` (the blueprint for `UserProfileScreen`).
        *   The `PageSettings` object containing all the extracted parameters and arguments.
6.  **Delivery**:
    *   The `GetRouterDelegate` receives this `RouteDecoder`. It now knows exactly which screen to show (`UserProfileScreen` via its `GetPage`) and what data (`PageSettings` with `id` and `mode`) to make available to that screen.
    *   The `UserProfileScreen` is built. When it accesses `Get.parameters`, it's actually reading from the `PageSettings` associated with its current route instance (managed by `RouteDecoder`).

Here's a simplified visual of this lookup:

```mermaid
sequenceDiagram
    participant UserAction as User calls Get.toNamed
    participant GRD as GetRouterDelegate
    participant PRT as ParseRouteTree (The Address Book)
    participant PS as PageSettings (The Envelope)
    participant RD as RouteDecoder (The Postal Worker)

    UserAction->>GRD: Get.toNamed("/users/123?mode=edit")
    GRD->>PRT:  matchRoute("/users/123?mode=edit")
    PRT->>PRT: Finds GetPage(name: "/users/:id")
    PRT->>PS: Creates PageSettings, populates with id='123', mode='edit'
    PRT->>RD: Creates RouteDecoder(matched GetPage, PageSettings instance)
    RD-->>GRD: Returns populated RouteDecoder
    GRD->>UserAction: UserProfileScreen is displayed (can access params via Get.parameters)
```

## A Peek Inside the Code

Let's look at simplified versions of these key classes. You don't usually interact with them directly, but understanding their roles is insightful.

### `PageSettings` - The Envelope
(Found in `lib/get_navigation/src/routes/page_settings.dart`)

This class holds information about a specific instance of a route.

```dart
// Simplified concept of PageSettings
class PageSettings extends RouteSettings {
  PageSettings(this.uri, [Object? arguments])
      : super(name: '$uri', arguments: arguments);

  final Uri uri; // The full URI, e.g., /users/123?mode=edit
  final params = <String, String>{}; // Parsed path & query params

  // Helper to get just the path part, e.g., /users/123
  String get path => uri.path;
  // Helper for query params, e.g., {mode: edit}
  Map<String, String> get query => uri.queryParameters;
}
```
When a route is parsed, an instance of `PageSettings` is created, and its `params` map is filled with both path parameters (like `:id`) and query parameters (like `mode=edit`). The full `Uri` and any passed `arguments` are also stored.

### `ParseRouteTree` - The Address Book Builder
(Found in `lib/get_navigation/src/routes/parse_route.dart`)

This class takes all your `GetPage` definitions and builds an efficient way to look them up.

```dart
// Simplified concept of ParseRouteTree
class ParseRouteTree {
  final List<GetPage> routes; // All GetPages from GetMaterialApp.getPages

  ParseRouteTree({required this.routes});

  RouteDecoder matchRoute(String name, {PageSettings? arguments}) {
    final Uri uri = Uri.parse(name); // e.g., /users/123?mode=edit
    GetPage? matchedPage;
    Map<String, String> extractedParams = {};

    // 1. Find matching GetPage
    for (final GetPage routeDefinition in routes) {
      // routeDefinition.path.regex is a pre-compiled regex for the route's path
      // e.g., for '/users/:id', regex matches '/users/ANYTHING'
      final match = routeDefinition.path.regex.firstMatch(uri.path);
      if (match != null) {
        matchedPage = routeDefinition;
        // 2. Extract path parameters (e.g., :id)
        // routeDefinition.path.keys would be ['id']
        for (var i = 0; i < routeDefinition.path.keys.length; i++) {
          extractedParams[routeDefinition.path.keys[i]!] = match[i + 1]!;
        }
        break;
      }
    }

    // 3. Add query parameters
    extractedParams.addAll(uri.queryParameters);

    // 4. Populate PageSettings
    final settings = arguments ?? PageSettings(uri);
    settings.params.clear();
    settings.params.addAll(extractedParams);

    // 5. Create RouteDecoder
    return RouteDecoder(
      matchedPage != null ? [matchedPage] : [], // List of GetPages in hierarchy
      settings,
    );
  }
  // ... other methods to add/remove routes ...
}
```
When `matchRoute` is called:
1.  It iterates through your list of `GetPage`s.
2.  For each `GetPage`, it uses a pre-compiled regular expression (`route.path.regex`) from the `GetPage`'s `name` to see if the current URL path matches. The `PathDecoded` object (part of `GetPage`) handles the conversion of `name` like `/users/:id` into a regex and identifies parameter keys like `id`.
3.  If a match is found, it extracts path parameters.
4.  It then adds any query parameters from the URL.
5.  This information is used to populate a `PageSettings` object.
6.  Finally, it returns a `RouteDecoder` containing the matched `GetPage`(s) and the populated `PageSettings`.

### `RouteDecoder` - The Postal Worker with the Decoded Address
(Found in `lib/get_navigation/src/routes/parse_route.dart`)

This class holds the result of parsing a route: the `GetPage`(s) that should be displayed and their `PageSettings`.

```dart
// Simplified concept of RouteDecoder
class RouteDecoder {
  // currentTreeBranch can hold multiple GetPages for nested routes.
  // For a simple route, it's usually just one GetPage.
  final List<GetPage> currentTreeBranch;
  final PageSettings? pageSettings; // The "envelope" with params & args

  RouteDecoder(this.currentTreeBranch, this.pageSettings);

  // The actual GetPage to be displayed (often the last in the branch)
  GetPage? get route =>
      currentTreeBranch.isEmpty ? null : currentTreeBranch.last;

  // Parameters are conveniently accessible from PageSettings
  Map<String, String> get parameters => pageSettings?.params ?? {};
}
```
The `GetRouterDelegate` uses the `route` (the `GetPage`) from `RouteDecoder` to know which widget to build, and the `pageSettings` to make arguments and parameters available to that widget, typically via `Get.arguments` and `Get.parameters`.

When you use `Get.parameters` in your widget, GetX is essentially looking up the current `RouteDecoder` for your active route and accessing `routeDecoder.pageSettings.params`.

## The Big Picture with `GetRouterDelegate`

The `GetRouterDelegate` (specifically `GetDelegate` in GetX's code, see `lib/get_navigation/src/routes/get_router_delegate.dart`) orchestrates this. It holds the `ParseRouteTree`:

```dart
// Inside GetDelegate (simplified)
class GetDelegate extends RouterDelegate<RouteDecoder> {
  final _routeTree = ParseRouteTree(routes: []); // Initialized with your GetPages

  // ... when navigation occurs ...
  RouteDecoder? _getRouteDecoder<T>(PageSettings arguments) {
    // ...
    final decoder = _routeTree.matchRoute(pageUriString, arguments: arguments);
    // ... further configure decoder (like setting arguments) ...
    return decoder;
  }

  @override
  Future<void> setNewRoutePath(RouteDecoder configuration) async {
    // This is called by Flutter's navigation system when the URL changes
    // or when we programmatically navigate.
    // 'configuration' here is often the result of `_getRouteDecoder`.
    _push(configuration); // _push adds to active pages stack and rebuilds UI
    notifyListeners();
  }
  // ... more logic for building the Navigator widget stack ...
}
```
The `GetDelegate` uses its `_routeTree.matchRoute()` method (which internally uses `ParseRouteTree`) to get a `RouteDecoder`. This `RouteDecoder` then informs the delegate which `GetPage`(s) to render and what `PageSettings` (arguments and parameters) are associated with it.

## Conclusion

You've now seen how GetX acts like a sophisticated address book and postal service for your app's routes!
*   `ParseRouteTree` builds and maintains the "address book" from your `GetPage` definitions.
*   `PageSettings` acts as the "envelope," carrying specific details for a navigation request, including parsed path and query parameters.
*   `RouteDecoder` is the "postal worker" that uses the address book to understand an incoming route string, prepare the envelope, and identify the correct screen blueprint.

This system allows GetX to robustly handle complex URLs, extract parameters, and deliver them to your screens effortlessly, all while you primarily just define your `GetPage`s and use `Get.toNamed()` and `Get.parameters`.

Next up, we'll explore a powerful feature that lets you intercept navigation: [GetMiddleware](06_getmiddleware_.md). Imagine them as security checkpoints or toll booths before you can access certain routes!
2025-05-16 11:10:00,285 - INFO - PROMPT: 
Write a very beginner-friendly tutorial chapter (in Markdown format) for the project `getx` about the concept: "GetMiddleware
". This is Chapter 6.

Concept Details:
- Name: GetMiddleware

- Description:
Middlewares are like checkpoints or gatekeepers for your routes. Before a page is displayed, or its dependencies are set up, middlewares can intercept the navigation request. They can redirect to a different page (e.g., a login screen if not authenticated), modify the page's properties, or set up specific bindings.
Think of them as security guards or receptionists at different points in a building. They might check your ID, give you a visitor's pass, or direct you to a different office based on their rules.


Complete Tutorial Structure:
1. [GetMaterialApp / GetCupertinoApp & GetRoot
](01_getmaterialapp___getcupertinoapp___getroot_.md)
2. [GetNavigation Extensions (e.g., Get.toNamed, Get.snackbar)
](02_getnavigation_extensions__e_g___get_tonamed__get_snackbar__.md)
3. [GetPage & GetRouterDelegate
](03_getpage___getrouterdelegate_.md)
4. [Overlay Management (Snackbar, Dialog, BottomSheet)
](04_overlay_management__snackbar__dialog__bottomsheet__.md)
5. [Route Parsing & Configuration (RouteDecoder, PageSettings, ParseRouteTree)
](05_route_parsing___configuration__routedecoder__pagesettings__parseroutetree__.md)
6. [GetMiddleware
](06_getmiddleware_.md)
7. [Transition System (GetPageRouteTransitionMixin, CustomTransition, Transitions)
](07_transition_system__getpageroutetransitionmixin__customtransition__transitions__.md)
8. [RouterReportManager
](08_routerreportmanager_.md)

Context from previous chapters:
# Chapter 1: GetMaterialApp / GetCupertinoApp & GetRoot

Welcome to your GetX journey! This is the very first step into a powerful and easy-to-use Flutter framework. In this chapter, we'll explore the foundational building blocks of any GetX application: `GetMaterialApp`, `GetCupertinoApp`, and the unsung hero, `GetRoot`.

## What's the Big Deal? Setting Up Your GetX App

Imagine you're building a house. Before you can add rooms, furniture, or even think about painting the walls, you need a solid foundation and the main structure, right? In a Flutter app using GetX, `GetMaterialApp` or `GetCupertinoApp` are like choosing the architectural style of your house (Material Design for Android-style or Cupertino for iOS-style), and they lay this essential groundwork.

Flutter apps usually start with `MaterialApp` (for Material Design) or `CupertinoApp` (for iOS-style design). GetX provides its own versions:

*   `GetMaterialApp`
*   `GetCupertinoApp`

Why use these instead of the standard Flutter ones? Because they do something crucial: **they initialize the GetX framework**. This "initialization" means they set up all the cool things GetX offers, like super-easy navigation, smart state management, and simple internationalization (showing your app in different languages).

Think of it like this: standard `MaterialApp` gives you a basic house blueprint. `GetMaterialApp` gives you that same blueprint but also installs the main electrical panel, plumbing system, and a smart home hub, all ready for you to use GetX features without extra setup.

## Meet the Stars of the Show

Let's break down these key components:

### 1. `GetMaterialApp` (for Material Design lovers)

If you're building an app that follows Google's Material Design guidelines (common for Android apps, but also widely used for cross-platform apps), you'll use `GetMaterialApp`. It's a direct replacement for Flutter's `MaterialApp`. By using it, you're telling your app, "Hey, I want to use GetX features!"

```dart
// main.dart
import 'package:flutter/material.dart';
import 'package:get/get.dart'; // Don't forget to import GetX!

void main() {
  runApp(MyApp());
}

class MyApp extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return GetMaterialApp( // <-- See? We use GetMaterialApp here!
      title: 'My First GetX App',
      home: MyHomePage(),
    );
  }
}

class MyHomePage extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(title: Text('GetX is Awesome!')),
      body: Center(child: Text('Hello, GetX World!')),
    );
  }
}
```
In this very simple app, just by changing `MaterialApp` to `GetMaterialApp`, we've unlocked the potential to use all of GetX's powerful features throughout our `MyApp`.

### 2. `GetCupertinoApp` (for iOS aficionados)

If you're aiming for an app that looks and feels like a native iOS application, you'll use `GetCupertinoApp`. It's the GetX equivalent of Flutter's `CupertinoApp`.

```dart
// main.dart
import 'package:flutter/cupertino.dart';
import 'package:get/get.dart'; // Import GetX

void main() {
  runApp(MyApp());
}

class MyApp extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return GetCupertinoApp( // <-- Using GetCupertinoApp for iOS style
      title: 'My First GetX iOS App',
      home: MyHomePage(),
    );
  }
}

class MyHomePage extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return CupertinoPageScaffold(
      navigationBar: CupertinoNavigationBar(
        middle: Text('Hello, GetX (iOS Style)!'),
      ),
      child: Center(child: Text('GetX on Cupertino!')),
    );
  }
}
```
Similar to `GetMaterialApp`, using `GetCupertinoApp` sets up your app for GetX functionalities but with an iOS-style foundation.

### 3. `GetRoot`: The Engine Under the Hood

You might not ever type `GetRoot` directly in your code, but it's super important to know it exists. `GetRoot` is the core widget that both `GetMaterialApp` and `GetCupertinoApp` use internally.

Think of `GetRoot` as the main power supply and central control panel for the GetX system in your app. It's responsible for:
*   Managing global configurations.
*   Setting up the routing system that GetX uses for navigation.
*   Initializing dependency management.
*   Handling internationalization settings (like current language).

So, when you use `GetMaterialApp` or `GetCupertinoApp`, they are essentially putting a `GetRoot` widget at the very top of your application's widget tree. This makes all the GetX features available to every part of your app.

## How Does It Work? A Peek Inside

You don't need to know the intricate details to use GetX effectively, but a little insight can be helpful!

1.  **You start your app:** You use `GetMaterialApp` (or `GetCupertinoApp`) as the root widget in your `main.dart` file.
2.  **`GetMaterialApp` takes charge:** When `GetMaterialApp` is built, its main job is to create and configure a `GetRoot` widget. It passes along all your app's configurations (like themes, initial routes, translations, etc.) to `GetRoot`.
3.  **`GetRoot` powers up:** `GetRoot` receives these configurations and initializes the entire GetX ecosystem. It sets up internal controllers, listeners for things like language changes, and provides the necessary context for GetX features to work.
4.  **Your app is ready!** With `GetRoot` in place, all other GetX functionalities (like `Get.to()` for navigation, `Get.put()` for dependency injection, `Get.snackbar()` for messages) can now find the necessary GetX infrastructure and work their magic.

Let's visualize this flow:

```mermaid
sequenceDiagram
    participant UserApp as main.dart
    participant GMA as GetMaterialApp
    participant GR as GetRoot
    participant GetXCore as GetX Core System

    UserApp->>GMA: Uses GetMaterialApp/GetCupertinoApp
    GMA->>GR: Wraps its child with GetRoot, passing configurations
    GR->>GetXCore: Initializes GetX services (routing, DI, locale)
    GMA->>UserApp: Renders app with GetX features enabled
```

**A Tiny Glimpse into the Code:**

You won't usually need to touch this code, but it helps to see it.

Here's a simplified look at what `GetMaterialApp` does in its `build` method (from `lib/get_navigation/src/root/get_material_app.dart`):

```dart
// Inside GetMaterialApp's build method
@override
Widget build(BuildContext context) {
  return GetRoot( // Notice! It returns a GetRoot widget.
    config: ConfigData( // Bundles up all configurations
      // ... like home, getPages, locale, theme ...
      home: home,
      getPages: getPages,
      locale: locale,
      theme: theme,
      // ... and many other settings you provide ...
    ),
    child: Builder(builder: (context) {
      // This inner part builds the actual MaterialApp,
      // now empowered by GetRoot and its configurations.
      final controller = GetRoot.of(context);
      return MaterialApp.router( /* ... uses controller.config ... */ );
    }),
  );
}
```
This code shows that `GetMaterialApp` essentially sets up `GetRoot` with all your app's settings. `GetRoot` then takes care of the nitty-gritty GetX initialization.

And here's a very simplified idea of what `GetRoot` does when it starts (from `lib/get_navigation/src/root/get_root.dart`):

```dart
// Inside GetRootState's initState method
@override
void initState() {
  config = widget.config; // Receives config from GetMaterialApp/GetCupertinoApp
  // ... other setup ...
  onInit(); // Calls a special GetX initialization method
  super.initState();
}

void onInit() {
  // Example: Sets up the current language (locale) for your app
  if (config.locale != null) Get.locale = config.locale;

  // Example: Initializes translations if you provide them
  if (config.translations != null) {
    Get.addTranslations(config.translations!.keys);
  }
  // ... and much more initialization for routing, logging, etc. ...
}
```
This `onInit()` method within `GetRoot` is where a lot of the GetX magic gets set up based on the properties you pass to `GetMaterialApp` or `GetCupertinoApp`.

## Why Bother? The Benefits

*   **Simplicity:** You just swap `MaterialApp` with `GetMaterialApp` (or `CupertinoApp` with `GetCupertinoApp`), and you're ready to use GetX. No complex setup rituals!
*   **Power:** This simple change unlocks a vast array of features:
    *   Effortless route management (covered in [GetNavigation Extensions (e.g., Get.toNamed, Get.snackbar)](02_getnavigation_extensions__e_g___get_tonamed__get_snackbar__.md) and [GetPage & GetRouterDelegate](03_getpage___getrouterdelegate__.md)).
    *   Simple state management.
    *   Easy dependency injection.
    *   Built-in internationalization.
    *   Dialogs, Snackbars, and BottomSheets without `context` (see [Overlay Management (Snackbar, Dialog, BottomSheet)](04_overlay_management__snackbar__dialog__bottomsheet__.md)).
*   **Performance:** GetX is designed to be lightweight and performant.

## Conclusion

You've just learned about the most fundamental step in building a GetX application: using `GetMaterialApp` or `GetCupertinoApp`. These widgets, powered by the underlying `GetRoot`, are your gateway to the GetX ecosystem. They seamlessly initialize everything you need, allowing you to focus on building amazing features rather than wrestling with boilerplate setup.

With this foundation laid, you're now ready to explore one of the most beloved features of GetX: its incredibly simple and powerful navigation system.

Ready to learn how to move between screens with ease? Let's dive into the [GetNavigation Extensions (e.g., Get.toNamed, Get.snackbar)](02_getnavigation_extensions__e_g___get_tonamed__get_snackbar__.md)!
---
# Chapter 2: GetNavigation Extensions (e.g., Get.toNamed, Get.snackbar)

Welcome back! In [Chapter 1: GetMaterialApp / GetCupertinoApp & GetRoot](01_getmaterialapp___getcupertinoapp___getroot_.md), we learned how to set up the foundation of our GetX app using `GetMaterialApp` or `GetCupertinoApp`. This simple step unlocked a world of powerful GetX features. Now, let's explore one of the most loved features: making navigation and showing pop-ups incredibly easy!

## The Old Way vs. The GetX Way

Imagine you're in your app, perhaps inside a settings page, and you want to navigate to a user profile page after a button tap. In standard Flutter, you'd typically need `BuildContext` to do this:

```dart
// Standard Flutter (needs context)
Navigator.push(context, MaterialPageRoute(builder: (context) => ProfileScreen()));
```

What if your button's logic is inside a separate class, like a ViewModel or a Controller, that doesn't have direct access to `BuildContext`? Passing `BuildContext` around can make your code a bit messy.

This is where GetX shines! GetX provides **GetNavigation Extensions**. These are convenient shortcut methods attached to the `Get` interface (think of `Get` as your GetX toolkit). They allow you to navigate or show UI elements like dialogs, snackbars, and bottom sheets from *anywhere* in your code without needing a `BuildContext`.

Think of it as a **universal remote control** for your app's navigation and common UI pop-ups. Instead of finding the specific local remote (`BuildContext`) for the TV in a room, you use one master remote (`Get`) to control any TV (navigation, dialog) in the house.

## Your Universal Remote: Meet `Get`

The `Get` object is your central access point for many GetX features. When you see `Get.something()`, you're using one of these handy extensions.

Let's see how this "universal remote" works for common tasks.

### 1. Navigating to a New Screen: `Get.to()`

Want to go to a new screen? Just use `Get.to()` and tell it which screen (widget) to build.

**Use Case:** Let's say we have a `HomeScreen` and we want to navigate to a `DetailScreen`.

First, your `main.dart` should be set up with `GetMaterialApp` (as learned in Chapter 1):

```dart
// main.dart
import 'package:flutter/material.dart';
import 'package:get/get.dart';
import 'home_screen.dart'; // We'll create this next

void main() {
  runApp(MyApp());
}

class MyApp extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return GetMaterialApp( // Using GetMaterialApp
      title: 'GetX Navigation',
      home: HomeScreen(),
    );
  }
}
```
This setup is crucial because `GetMaterialApp` prepares GetX for context-less navigation.

Now, let's create `HomeScreen` and `DetailScreen`:

```dart
// home_screen.dart
import 'package:flutter/material.dart';
import 'package:get/get.dart';
import 'detail_screen.dart'; // We'll create this

class HomeScreen extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(title: Text('Home')),
      body: Center(
        child: ElevatedButton(
          onPressed: () {
            // Look, no context needed!
            Get.to(() => DetailScreen());
          },
          child: Text('Go to Details'),
        ),
      ),
    );
  }
}
```
In `HomeScreen`, when the button is pressed, `Get.to(() => DetailScreen())` is called. This tells GetX to push `DetailScreen` onto the navigation stack.

```dart
// detail_screen.dart
import 'package:flutter/material.dart';

class DetailScreen extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(title: Text('Details')),
      body: Center(child: Text('This is the Detail Screen!')),
    );
  }
}
```
`DetailScreen` is just a simple page. When you tap the button on `HomeScreen`, you'll navigate to `DetailScreen`.

**What happened?**
`Get.to(() => DetailScreen())` pushed a new route displaying `DetailScreen` onto the navigation stack. The `() => DetailScreen()` part is a function that creates your new screen.

### 2. Navigating with Named Routes: `Get.toNamed()`

Sometimes, you prefer to navigate using names instead of creating widget instances directly. This is great for clean code and is essential for web routing. GetX makes this super easy with `Get.toNamed()`.

First, you need to define your named routes in `GetMaterialApp` using the `getPages` property. We'll dive deeper into `getPages` in [GetPage & GetRouterDelegate](03_getpage___getrouterdelegate__.md), but here's a sneak peek:

```dart
// main.dart (updated)
import 'package:flutter/material.dart';
import 'package:get/get.dart';
import 'home_screen.dart';
import 'detail_screen.dart'; // Import DetailScreen

void main() {
  runApp(MyApp());
}

class MyApp extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return GetMaterialApp(
      title: 'GetX Named Navigation',
      initialRoute: '/home', // Optional: set an initial route
      getPages: [
        GetPage(name: '/home', page: () => HomeScreen()),
        GetPage(name: '/detail', page: () => DetailScreen()),
      ],
    );
  }
}
```
We've defined two routes: `/home` pointing to `HomeScreen` and `/detail` pointing to `DetailScreen`.

Now, in your `HomeScreen`, you can navigate using the name:

```dart
// home_screen.dart (updated for named route)
// ... (imports remain the same)
class HomeScreen extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(title: Text('Home')),
      body: Center(
        child: ElevatedButton(
          onPressed: () {
            Get.toNamed('/detail'); // Navigate by name!
          },
          child: Text('Go to Details (Named)'),
        ),
      ),
    );
  }
}
```
When you tap the button, `Get.toNamed('/detail')` looks up the '/detail' route you defined in `getPages` and navigates to `DetailScreen`.

### 3. Going Back: `Get.back()`

To go back to the previous screen, it's as simple as:

```dart
// Inside DetailScreen, for example
ElevatedButton(
  onPressed: () {
    Get.back(); // Go back to HomeScreen
  },
  child: Text('Go Back'),
)
```
`Get.back()` pops the current screen from the navigation stack, just like Flutter's `Navigator.pop(context)`.

### 4. Showing a Quick Message: `Get.snackbar()`

Need to show a quick notification or message (a "snackbar")? GetX has you covered, again, without needing `BuildContext`.

```dart
// In any button's onPressed, or anywhere else:
ElevatedButton(
  onPressed: () {
    Get.snackbar(
      "Success!", // Title
      "Your action was completed.", // Message
      snackPosition: SnackPosition.BOTTOM, // Optional: position
    );
  },
  child: Text('Show Snackbar'),
)
```
This will display a sleek snackbar at the bottom (or top, depending on `snackPosition`) of your screen. It's that easy! We'll explore snackbars in more detail in [Overlay Management (Snackbar, Dialog, BottomSheet)](04_overlay_management__snackbar__dialog__bottomsheet__.md).

### 5. A Peek at Dialogs and Bottom Sheets

GetX also simplifies showing dialogs and bottom sheets without `BuildContext`.

*   **Dialogs with `Get.dialog()`**:
    ```dart
    // Example: Show a simple dialog
    Get.dialog(
      AlertDialog(
        title: Text('Alert!'),
        content: Text('This is a GetX dialog.'),
        actions: [TextButton(onPressed: () => Get.back(), child: Text('OK'))],
      )
    );
    ```

*   **Bottom Sheets with `Get.bottomSheet()`**:
    ```dart
    // Example: Show a simple bottom sheet
    Get.bottomSheet(
      Container(
        height: 200,
        color: Colors.white,
        child: Center(child: Text('This is a GetX bottom sheet!')),
      )
    );
    ```
These are very powerful, and you'll learn all about customizing them in [Overlay Management (Snackbar, Dialog, BottomSheet)](04_overlay_management__snackbar__dialog__bottomsheet__.md). For now, just know they exist and are super easy to call!

## How Does This Magic Work? Under the Hood

You might be wondering: "If I'm not giving it `BuildContext`, how does `Get.toNamed()` or `Get.snackbar()` know where to navigate or show the message?"

It's thanks to the setup we did in [Chapter 1: GetMaterialApp / GetCupertinoApp & GetRoot](01_getmaterialapp___getcupertinoapp___getroot_.md)!

1.  **The Foundation**: When you use `GetMaterialApp` (or `GetCupertinoApp`), it internally creates and configures a `GetRoot` widget. This `GetRoot` widget holds a global `NavigatorKey`. Think of this key as a direct phone line to Flutter's navigation system. It also manages an `OverlayKey` for things like snackbars and dialogs.

2.  **The Call**: When you call something like `Get.toNamed('/detail')`, the static `Get` interface uses this globally available `NavigatorKey` (managed by `GetRootController`) to access the current `NavigatorState`.

3.  **The Action**: Once it has the `NavigatorState`, it can then call the standard Flutter methods like `navigatorState.pushNamed('/detail')` or `navigatorState.push(MaterialPageRoute(...))`.

For snackbars, dialogs, and bottom sheets, `Get` uses a similar mechanism to access the `OverlayState` (via `Get.overlayContext`) to display these UI elements on top of your current screen.

Here's a simplified flow:

```mermaid
sequenceDiagram
    participant YourWidget as Your Widget (e.g., Button)
    participant GetStatic as Get (Static Interface)
    participant GetRootCtrl as GetRoot Controller (from GetMaterialApp)
    participant FlutterNavigator as Flutter Navigator/Overlay

    YourWidget->>GetStatic: Calls Get.toNamed("/details") or Get.snackbar(...)
    GetStatic->>GetRootCtrl: Accesses root NavigatorKey or OverlayContext
    GetRootCt<ctrl63>
---
# Chapter 3: GetPage & GetRouterDelegate

In [Chapter 2: GetNavigation Extensions (e.g., Get.toNamed, Get.snackbar)](02_getnavigation_extensions__e_g___get_tonamed__get_snackbar__.md), we saw how easy GetX makes navigating between screens using methods like `Get.to()` and `Get.toNamed()`. We even had a sneak peek at defining named routes. Now, let's dive deeper into how GetX manages these routes in a more structured and powerful way using `GetPage` and `GetRouterDelegate`. These are the tools that make GetX's navigation so robust, especially for larger apps!

## The Need for Structure: Why Bother?

Imagine you're designing a website with many pages: a homepage, an about page, a contact page, a profile page, and so on. If you just linked them haphazardly, it would quickly become a mess. You'd want a clear sitemap and well-defined URLs for each page.

Similarly, in a Flutter app, as it grows, just calling `Get.to(() => MyScreen())` everywhere can become hard to manage. What if you want to change the transition animation for a specific screen? Or pass data to it in a standardized way? Or manage deep linking (opening specific app screens from a web link)?

This is where `GetPage` and `GetRouterDelegate` come in. They help you:
1.  **Define all your app's screens (routes) in one central place.**
2.  **Give each screen a unique name (like a URL).**
3.  **Configure special behaviors for each screen (like transitions or data bindings).**
4.  **Power Flutter's modern Navigator 2.0 system within GetX, allowing for more complex navigation scenarios.**

Let's meet the stars!

## Meet the Blueprint: `GetPage`

Think of `GetPage` as a **blueprint for a screen** in your app. It's not the screen itself, but rather a detailed description of it. Each `GetPage` tells GetX:
*   `name`: The unique "URL" or path for this screen (e.g., `/home`, `/profile`, `/settings/notifications`). This is what you use with `Get.toNamed()`.
*   `page`: A function that tells GetX *how to build* the actual widget for this screen when it's needed.
*   `binding` (optional): A way to set up controllers or other dependencies specifically for this screen. (We'll explore bindings more in GetX state management).
*   `transition` (optional): How the screen animates in and out. (More on this in [Transition System (GetPageRouteTransitionMixin, CustomTransition, Transitions)](07_transition_system__getpageroutetransitionmixin__customtransition__transitions__.md)).
*   `middlewares` (optional): Special functions that can run before a page is shown, perhaps to check if a user is logged in. (Covered in [GetMiddleware](06_getmiddleware_.md)).

Let's define a couple of simple `GetPage` blueprints:

```dart
// main.dart (or a separate routes file)
import 'package:flutter/material.dart';
import 'package:get/get.dart'; // Import GetX

// Assume HomeScreen and ProfileScreen widgets are defined elsewhere
// For example:
// class HomeScreen extends StatelessWidget { /* ... */ }
// class ProfileScreen extends StatelessWidget { /* ... */ }

final List<GetPage> appPages = [
  GetPage(
    name: '/home', // The unique name for the home screen
    page: () => HomeScreen(), // How to build the HomeScreen
  ),
  GetPage(
    name: '/profile', // The unique name for the profile screen
    page: () => ProfileScreen(), // How to build the ProfileScreen
    // transition: Transition.rightToLeft, // Optional: a nice slide animation
  ),
];
```
In this snippet, `appPages` is a list holding the blueprints for our `HomeScreen` and `ProfileScreen`. We've given each a unique `name` and a `page` function.

## Meet the Captain: `GetRouterDelegate`

If `GetPage` is the blueprint, then `GetRouterDelegate` is the **captain of your app's navigation ship**. It's the core engine that powers Flutter's modern Navigator 2.0 system within GetX.

You usually won't interact with `GetRouterDelegate` directly in simple apps. When you provide your list of `GetPage` blueprints to `GetMaterialApp` (as we'll see next), GetX sets up a `GetRouterDelegate` for you behind the scenes.

This "captain" is responsible for:
*   Taking your `GetPage` blueprints.
*   Managing the actual stack of screens (what's visible, what's underneath).
*   Deciding which page is currently visible based on the URL or navigation actions.
*   Handling how to go to new pages (`Get.toNamed()`).
*   Handling how to go back (`Get.back()`).

Think of it like an air traffic controller for your app's screens. It knows all the available "runways" (`GetPage`s) and directs the "planes" (your users' navigation actions) to the correct one smoothly.

## Putting It Together: Defining Routes in `GetMaterialApp`

Now, how do we tell our GetX app about these `GetPage` blueprints so the `GetRouterDelegate` can use them? We pass our list of `GetPage`s to the `getPages` property of `GetMaterialApp` (or `GetCupertinoApp`).

Let's update our `main.dart` from Chapter 2:

```dart
// main.dart
import 'package:flutter/material.dart';
import 'package:get/get.dart';

// Let's define our screens quickly for this example
class HomeScreen extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(title: Text('Home')),
      body: Center(
        child: ElevatedButton(
          onPressed: () => Get.toNamed('/profile'), // Navigate to profile
          child: Text('Go to Profile'),
        ),
      ),
    );
  }
}

class ProfileScreen extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(title: Text('Profile')),
      body: Center(child: Text('This is your Profile!')),
    );
  }
}

// Our GetPage blueprints
final List<GetPage> appPages = [
  GetPage(name: '/home', page: () => HomeScreen()),
  GetPage(name: '/profile', page: () => ProfileScreen()),
];

void main() {
  runApp(MyApp());
}

class MyApp extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return GetMaterialApp(
      title: 'GetX Named Routes',
      initialRoute: '/home', // Start at the home screen
      getPages: appPages,   // <-- Here's where we provide our blueprints!
    );
  }
}
```
By providing `appPages` to `GetMaterialApp`, we've done two things:
1.  Registered our `/home` and `/profile` routes.
2.  Enabled `GetMaterialApp` to use its internal `GetRouterDelegate` to manage navigation based on these named routes.

Now, `Get.toNamed('/profile')` from `HomeScreen` will correctly navigate to `ProfileScreen` because the `GetRouterDelegate` (set up by `GetMaterialApp`) knows about the `/profile` blueprint.

## How Does It Work Under the Hood?

When you use `getPages` with `GetMaterialApp`, GetX sets up a more sophisticated navigation system. Here's a simplified step-by-step:

1.  **Setup**: When `GetMaterialApp` starts, it sees you've provided `getPages`. It then creates and configures a `GetRouterDelegate` (specifically, an instance of `GetDelegate` from `lib/get_navigation/src/routes/get_router_delegate.dart`). This delegate is given your list of `GetPage` blueprints.
2.  **Navigation Trigger**: You call `Get.toNamed('/profile')`.
3.  **Delegate at Work**: The `Get.toNamed` call, in this Navigator 2.0 setup, ultimately informs the `GetRouterDelegate`.
4.  **Route Matching**: The `GetRouterDelegate` consults its list of `GetPage`s. It uses a helper, often `ParseRouteTree` (from `lib/get_navigation/src/routes/parse_route.dart`), to find the `GetPage` whose `name` matches `/profile`. We'll explore `ParseRouteTree` more in [Route Parsing & Configuration (RouteDecoder, PageSettings, ParseRouteTree)](05_route_parsing___configuration__routedecoder__pagesettings__parseroutetree__.md).
5.  **Screen Creation**: Once the matching `GetPage` blueprint is found, the `GetRouterDelegate` uses its `page: () => ProfileScreen()` function to create an instance of `ProfileScreen`.
6.  **Stack Update**: The `GetRouterDelegate` then updates Flutter's navigation stack to display this new `ProfileScreen`.

Here's a visual:

```mermaid
sequenceDiagram
    participant UserAction as User Taps Button
    participant GetToNamed as Get.toNamed("/profile")
    participant GMA as GetMaterialApp (internally)
    participant GRD as GetRouterDelegate
    participant FlutterNav as Flutter Navigator

    UserAction->>GetToNamed: Invokes navigation for "/profile"
    GetToNamed->>GMA: Signals intent (simplified)
    GMA->>GRD: Relays "/profile" to its delegate
    GRD->>GRD: Finds GetPage(name: "/profile") in its list (getPages)
    GRD->>GRD: Calls page() function from GetPage
    GRD->>FlutterNav: "Push this new screen (ProfileScreen)"
    FlutterNav->>UserAction: ProfileScreen is displayed
```

Inside `GetMaterialApp` (or more accurately, `GetMaterialApp.router` which is used when `getPages` is provided), it sets up like this:

```dart
// Simplified concept from GetMaterialApp when getPages is used
// return GetMaterialApp.router(
//   routeInformationParser: GetInformationParser(...), // Handles URL parsing
//   routerDelegate: GetDelegate(pages: getPages, ...), // Our captain!
// );
```
The `GetDelegate` (our `GetRouterDelegate` implementation) receives your `pages` (your `GetPage` list).

Then, `GetDelegate`'s `build` method uses these pages to construct the `Navigator`:

```dart
// Simplified from lib/get_navigation/src/routes/get_router_delegate.dart
// Inside GetDelegate's build method:

// final currentHistory = currentConfiguration;
// final pages = /* ... logic to get current visible GetPage(s) based on URL ... */
//    getVisualPages(currentHistory).toList();

// return GetNavigator(
//   key: navigatorKey,
//   onPopPage: _onPopVisualRoute, // Handles back button for these pages
//   pages: pages, // The actual Flutter Page objects derived from your GetPages
//   // ... other navigator configurations
// );
```
The `pages` list here are Flutter `Page` objects, which `GetDelegate` creates based on your `GetPage` definitions and the current navigation state.

So, by using `GetPage` and `getPages`, you're tapping into this powerful, Navigator 2.0-based routing managed by `GetRouterDelegate`.

## Why This Approach?

*   **Centralized Route Definitions**: All your main navigation paths are clearly defined in one place.
*   **Named Navigation Power**: Makes `Get.toNamed()` very robust.
*   **Decoupling**: Your UI code just says "go to `/profile`"; it doesn't need to know *how* `ProfileScreen` is built or what its specific dependencies are.
*   **Advanced Scenarios**: This structure is the foundation for more complex features like:
    *   Nested navigation (routes within routes).
    *   Guards/Middlewares (e.g., checking login status before accessing a route, covered in [GetMiddleware](06_getmiddleware_.md)).
    *   Custom transitions per route (see [Transition System (GetPageRouteTransitionMixin, CustomTransition, Transitions)](07_transition_system__getpageroutetransitionmixin__customtransition__transitions__.md)).
    *   Better web URL handling.

## Conclusion

You've now learned about `GetPage`, the blueprint for your screens, and `GetRouterDelegate`, the captain that manages navigation using these blueprints. By defining your routes using `GetPage` and providing them to `GetMaterialApp` via the `getPages` property, you unlock a more structured, powerful, and maintainable way to handle navigation in your GetX applications. This setup is what allows GetX to seamlessly integrate with Flutter's Navigator 2.0 system, giving you fine-grained control while keeping things simple.

While `GetRouterDelegate` works largely behind the scenes for many common use cases, understanding its role helps you appreciate the robustness of GetX navigation.

Next up, we'll explore how GetX makes it incredibly easy to show common UI overlays like Snackbars, Dialogs, and BottomSheets, often without needing `BuildContext` at all! Let's head to [Overlay Management (Snackbar, Dialog, BottomSheet)](04_overlay_management__snackbar__dialog__bottomsheet__.md).
---
# Chapter 4: Overlay Management (Snackbar, Dialog, BottomSheet)

Welcome back! In [Chapter 3: GetPage & GetRouterDelegate](03_getpage___getrouterdelegate__.md), we learned how to structure our app's navigation with named routes using `GetPage`. Now, let's explore another incredibly handy feature of GetX: managing temporary UI elements like snackbars, dialogs, and bottom sheets, all without needing to pass `BuildContext` around!

## What are Overlays? The Hotel Concierge Analogy

Imagine you're staying in a fancy hotel (your app). You're comfortably in your room (your current screen). Sometimes, you need quick services or information without having to leave your room or go to a completely new part of the hotel. This is where the hotel concierge comes in handy!

In GetX, overlay management is like having a super-efficient concierge service for your app. You can request:
*   A **quick note delivered to you** (a **Snackbar**): A brief message that appears temporarily, usually at the top or bottom of the screen, to give you a quick update (e.g., "Message sent!").
*   To **arrange a private meeting in a temporary room** (a **Dialog**): A pop-up window that requires your attention before you can continue interacting with your current screen. Useful for alerts, confirmations, or quick forms.
*   To **pull up a special information panel from below** (a **BottomSheet**): A panel that slides up from the bottom of the screen, offering more detailed options or information related to the current context.

These are all "overlays"—UI elements that appear *on top* of your current page without completely replacing it. GetX makes showing these incredibly simple.

## GetX's Superpower: Context-less Overlays

As we saw in [Chapter 2: GetNavigation Extensions (e.g., Get.toNamed, Get.snackbar)](02_getnavigation_extensions__e_g___get_tonamed__get_snackbar__.md), one of GetX's main advantages is allowing you to trigger navigation and UI elements from anywhere in your code, often without needing `BuildContext`. This is especially true for overlays!

Thanks to the setup with `GetMaterialApp` (covered in [Chapter 1: GetMaterialApp / GetCupertinoApp & GetRoot](01_getmaterialapp___getcupertinoapp___getroot_.md)), GetX has access to the necessary "hooks" to display these overlays globally.

Let's see how to use our "concierge" (`Get`) to request these services.

### 1. Quick Notes: `Get.snackbar()`

Need to show a user a quick, non-intrusive message? `Get.snackbar()` is your friend. It's like asking the concierge to slip a small note under your door.

```dart
// In any button's onPressed, or anywhere in your logic:
ElevatedButton(
  onPressed: () {
    Get.snackbar(
      "Notification", // Title of the snackbar
      "Your profile was updated successfully!", // Message
      snackPosition: SnackPosition.BOTTOM, // Where it appears
      backgroundColor: Colors.green,
      colorText: Colors.white,
    );
  },
  child: Text('Update Profile & Show Snackbar'),
)
```
**What happens?**
Tapping this button will display a green snackbar at the bottom of the screen with the title "Notification" and your message. It will automatically dismiss after a few seconds.

**Behind the Scenes (Briefly):**
GetX uses a `SnackbarController` to manage these requests. If you call `Get.snackbar()` multiple times quickly, `SnackbarController` acts like the concierge's assistant, queuing up the notes and delivering them one by one, so they don't all appear at once and clutter the screen.

### 2. Private Meetings: `Get.dialog()`

Sometimes you need to grab the user's full attention for an important choice or piece of information. This is like asking the concierge to book a small, private meeting room (a Dialog). The user must interact with the dialog (e.g., press "OK" or "Cancel") before returning to their main room (screen).

```dart
// In any button's onPressed:
ElevatedButton(
  onPressed: () {
    Get.dialog(
      AlertDialog(
        title: Text('Confirm Action'),
        content: Text('Are you sure you want to delete this item?'),
        actions: [
          TextButton(onPressed: () => Get.back(), child: Text('Cancel')),
          TextButton(onPressed: () { /* delete logic */ Get.back(); }, child: Text('Delete')),
        ],
      ),
    );
  },
  child: Text('Delete Item (Show Dialog)'),
)
```
**What happens?**
Tapping this button will display a standard Material Design alert dialog in the middle of the screen. The background will be dimmed, and the user must tap "Cancel" or "Delete" to close the dialog. `Get.back()` is used here to close the dialog.

### 3. Special Info Panels: `Get.bottomSheet()`

For presenting a list of options or a bit more information without being as intrusive as a full dialog, a bottom sheet is perfect. It's like the concierge pulling up a neat information panel from a compartment below your desk.

```dart
// In any button's onPressed:
ElevatedButton(
  onPressed: () {
    Get.bottomSheet(
      Container(
        height: 200,
        color: Colors.blueGrey,
        child: Column(
          mainAxisAlignment: MainAxisAlignment.center,
          children: [
            ListTile(leading: Icon(Icons.share, color: Colors.white), title: Text('Share', style: TextStyle(color: Colors.white)), onTap: () => Get.back()),
            ListTile(leading: Icon(Icons.copy, color: Colors.white), title: Text('Copy Link', style: TextStyle(color: Colors.white)), onTap: () => Get.back()),
          ],
        ),
      ),
      // Optional: make it non-dismissible by dragging
      // isDismissible: false, 
    );
  },
  child: Text('Show Options (BottomSheet)'),
)
```
**What happens?**
Tapping this button will cause a panel to slide up from the bottom of the screen. This panel contains our "Share" and "Copy Link" options. Tapping an option (or outside the sheet, if dismissible) will close it. `Get.back()` closes the bottom sheet here.

## How Does GetX Handle These Requests? (Under the Hood)

You might wonder how `Get.snackbar()`, `Get.dialog()`, and `Get.bottomSheet()` can work without you explicitly giving them a `BuildContext`.

**The Magic of `GetMaterialApp` and `Get.overlayContext`**
As we learned in [Chapter 1: GetMaterialApp / GetCupertinoApp & GetRoot](01_getmaterialapp___getcupertinoapp___getroot_.md), using `GetMaterialApp` sets up the GetX framework. Crucially, `GetMaterialApp` (via `GetRoot`) holds a global key for Flutter's `Overlay`. The `Overlay` is like a special layer in your app where you can draw things on top of everything else. GetX exposes access to this overlay's context via `Get.overlayContext`.

```dart
// lib/get_navigation/src/extension_navigation.dart (simplified concept)
BuildContext? get overlayContext {
  // ... logic to get the context of the root overlay ...
  // This 'key' is managed by GetRootState (from GetMaterialApp)
  key.currentState?.overlay?.context.visitChildElements((element) {
    // ... find the overlay context ...
  });
  return /* the found overlay context */;
}
```
This `Get.overlayContext` is the "magic wand" GetX uses to show snackbars, dialogs, and bottom sheets from anywhere.

### Snackbars: The `SnackbarController` at Your Service

When you call `Get.snackbar(...)`, it's more than just displaying a widget.
1.  `Get.snackbar()` (in `extension_navigation.dart`) creates a `GetSnackBar` widget configured with your title, message, colors, etc.
2.  It then hands this `GetSnackBar` widget to a `SnackbarController` (from `lib/get_navigation/src/snackbar/snackbar_controller.dart`).
3.  The `SnackbarController` is responsible for:
    *   Managing a queue (`SnackBarQueue`). If multiple snackbars are requested, they are shown one after another.
    *   Creating `OverlayEntry` objects (Flutter's way of putting something on the `Overlay`).
    *   Handling animations (showing and hiding the snackbar).
    *   Managing the duration and dismissal of the snackbar.

```mermaid
sequenceDiagram
    participant YourCode as Your Widget/Logic
    participant GetSnackbarCall as Get.snackbar()
    participant SnackbarCtrl as SnackbarController
    participant Overlay as Flutter OverlayState

    YourCode->>GetSnackbarCall: Calls Get.snackbar("Title", "Message")
    GetSnackbarCall->>SnackbarCtrl: Creates GetSnackBar widget & passes to new SnackbarController
    SnackbarCtrl->>SnackbarCtrl: Adds itself to SnackBarQueue
    SnackbarCtrl->>Overlay: When its turn, creates OverlayEntry & inserts into Overlay
    Overlay->>YourCode: Snackbar is displayed
    SnackbarCtrl->>Overlay: Later, removes OverlayEntry (on dismiss/timeout)
```

Here's a highly simplified glimpse of `Get.snackbar()` in `lib/get_navigation/src/extension_navigation.dart`:
```dart
// Simplified from extension_navigation.dart
SnackbarController snackbar(String title, String message, {/*...other params...*/}) {
  final getSnackBar = GetSnackBar( // Creates the snackbar widget
    title: title,
    message: message,
    // ... many other properties ...
  );

  // Creates a controller for this specific snackbar instance
  final controller = SnackbarController(getSnackBar); 
  
  // Shows it (adds to queue, handles display via Overlay)
  if (instantInit) { 
    controller.show();
  } else {
    // ... schedule to show after current frame ...
  }
  return controller;
}
```
And `SnackbarController` (in `lib/get_navigation/src/snackbar/snackbar_controller.dart`) uses the `Get.overlayContext` to interact with Flutter's `Overlay`:
```dart
// Simplified concept from SnackbarController.dart
class SnackbarController {
  final GetSnackBar snackbar; // The widget to display
  // ... animation controllers, etc. ...

  Future<void> show() {
    // Adds this snackbar job to a queue
    return GetRootState.controller.config.snackBarQueue.addJob(this);
  }

  Future<void> _show() { // Called by the queue
    // Gets Flutter's OverlayState using Get.overlayContext
    _overlayState = Overlay.of(Get.overlayContext!); 
    // Creates OverlayEntry(s) to display the snackbar
    _overlayEntries.addAll(_createOverlayEntries(snackbar));
    _overlayState!.insertAll(_overlayEntries); // Shows it!
    // ... handles animations and timers ...
    return _transitionCompleter.future;
  }
  // ... methods to close, manage status ...
}
```
The `SnackbarController` is quite sophisticated, managing animations, dismissals, and even a queue. This ensures your snackbars behave politely.

### Dialogs and BottomSheets: Custom Popup Routes

Dialogs and BottomSheets are a bit different. They are typically "modal," meaning they block interaction with the underlying screen content. In Flutter, these are often implemented using `PopupRoute`. GetX provides its own custom `PopupRoute` implementations:
*   `GetDialogRoute` (from `lib/get_navigation/src/dialog/dialog_route.dart`)
*   `GetModalBottomSheetRoute` (from `lib/get_navigation/src/bottomsheet/bottomsheet.dart`)

When you call `Get.dialog()` or `Get.bottomSheet()`:
1.  The `Get` extension method (in `extension_navigation.dart`) takes your widget and parameters.
2.  It then uses `Navigator.of(Get.overlayContext!).push(...)` to push either a `GetDialogRoute` (for dialogs) or a `GetModalBottomSheetRoute` (for bottom sheets) onto the navigator's stack.

Here's a glimpse into `Get.dialog()` from `lib/get_navigation/src/extension_navigation.dart`:
```dart
// Simplified from extension_navigation.dart
Future<T?> dialog<T>(Widget widget, {/* ... params ... */}) {
  // ... theme setup ...
  return generalDialog<T>( // Calls a more generic dialog method
    pageBuilder: (buildContext, animation, secondaryAnimation) {
      // ... wraps widget with Theme, SafeArea etc. ...
      return widget; 
    },
    // ... other parameters like barrierDismissible, barrierColor ...
  );
}

Future<T?> generalDialog<T>({ required RoutePageBuilder pageBuilder, /*...*/}) {
  // Accesses the navigator via Get.overlayContext (or a specific key)
  final nav = /* ... Navigator.of(overlayContext!, rootNavigator: true) ... */;
  
  // Pushes GetX's custom dialog route
  return nav.push<T>( 
    GetDialogRoute<T>(
      pageBuilder: pageBuilder,
      // ... passes other parameters ...
    ),
  );
}
```
And for `Get.bottomSheet()`:
```dart
// Simplified from extension_navigation.dart
Future<T?> bottomSheet<T>(Widget bottomsheet, {/* ... params ... */}) {
  // Uses the Navigator from Get.overlayContext
  return Navigator.of(overlayContext!, rootNavigator: useRootNavigator)
      .push(GetModalBottomSheetRoute<T>( // Pushes GetX's custom bottom sheet route
          builder: (_) => bottomsheet,
          // ... passes many other parameters for customization ...
      ));
}
```
`GetDialogRoute` and `GetModalBottomSheetRoute` are subclasses of Flutter's `PopupRoute`. They handle the specifics of how the dialog or bottom sheet appears, animates, and interacts with the modal barrier (the dimming effect behind them).

So, for dialogs and bottom sheets, GetX leverages Flutter's standard navigation mechanism for `PopupRoute`s but makes them accessible via the simple `Get.dialog()` and `Get.bottomSheet()` calls, using `Get.overlayContext` to find the correct `Navigator`.

## Conclusion

You've just learned how GetX simplifies showing common temporary UI elements—Snackbars, Dialogs, and BottomSheets—much like a hotel concierge assisting with quick notes, private meetings, or information panels.

The key takeaways are:
*   GetX provides easy, context-less APIs like `Get.snackbar()`, `Get.dialog()`, and `Get.bottomSheet()`.
*   `SnackbarController` manages the lifecycle and queue of snackbars efficiently.
*   Dialogs and BottomSheets are presented using custom `PopupRoute` implementations (`GetDialogRoute`, `GetModalBottomSheetRoute`) that GetX makes easy to invoke.
*   All this is possible because `GetMaterialApp` (via `GetRoot`) sets up the necessary global access to Flutter's `Overlay` and `Navigator`.

With these tools, you can create a more interactive and communicative user experience with minimal boilerplate code.

In the next chapter, we'll delve into how GetX understands the named routes you define with `GetPage` and how it handles parameters in those routes. Get ready for [Route Parsing & Configuration (RouteDecoder, PageSettings, ParseRouteTree)](05_route_parsing___configuration__routedecoder__pagesettings__parseroutetree__.md)!
---
# Chapter 5: Route Parsing & Configuration (RouteDecoder, PageSettings, ParseRouteTree)

Welcome back! In [Chapter 4: Overlay Management (Snackbar, Dialog, BottomSheet)](04_overlay_management__snackbar__dialog__bottomsheet__.md), we explored how GetX simplifies showing UI overlays. Now, let's uncover the magic behind how GetX understands the addresses (routes) you navigate to, especially when they include dynamic parts like user IDs or query parameters.

## The App's Address System: Why Do We Need This?

Imagine your app is like a big city, and each screen is a building with a specific address. Sometimes, these addresses are simple, like `/home`. But often, they're more complex, like `/users/123` (showing user with ID 123) or `/products?category=electronics&sort=price` (showing electronic products sorted by price).

How does your app:
1.  Know which screen corresponds to `/users/123`?
2.  Extract the ID `123` so the screen can fetch the correct user data?
3.  Understand that `category=electronics` and `sort=price` are special instructions for the products screen?

This is where GetX's route parsing and configuration system comes in. It's like your app's combined **address book and highly intelligent postal service**.

*   **`ParseRouteTree`**: Think of this as the **master address book**. It holds a structured list of all possible "addresses" (routes) your app knows, including how they might be nested.
*   **`PageSettings`**: This is like an **individual envelope** for a specific navigation request. It contains the destination address, and importantly, any special data like user IDs (path parameters) or filtering options (query parameters).
*   **`RouteDecoder`**: This is the clever **postal worker**. When you say "go to `/users/123?mode=edit`", the `RouteDecoder` looks up this address in the `ParseRouteTree`, figures out it's for a user screen, extracts the ID `123` and the `mode=edit` instruction, and prepares the `PageSettings` "envelope" so the correct screen can be delivered with the right information.

Let's see how these components work together.

## Defining Routes with Parameters

In [Chapter 3: GetPage & GetRouterDelegate](03_getpage___getrouterdelegate__.md), we learned about `GetPage` for defining named routes. We can make these routes dynamic.

Suppose we want a screen to display user profiles. The route might look like `/users/:id`, where `:id` is a placeholder for the user's actual ID.

First, let's define this in our `GetMaterialApp`'s `getPages`:

```dart
// main.dart (or your routes file)
List<GetPage> appPages = [
  GetPage(name: '/', page: () => HomeScreen()),
  GetPage(
    name: '/users/:id', // The :id part is a path parameter
    page: () => UserProfileScreen(),
  ),
  // ... other pages
];
```
Here, `/users/:id` tells GetX that any route starting with `/users/` followed by some value should be handled by `UserProfileScreen`. That value will be available as the `id` parameter.

## Accessing Parameters in Your Screen

Now, when we navigate to, say, `/users/123`, how does `UserProfileScreen` get this `123`? GetX makes it easy with `Get.parameters`.

```dart
// user_profile_screen.dart
import 'package:flutter/material.dart';
import 'package:get/get.dart';

class UserProfileScreen extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    // Accessing the 'id' path parameter
    final String? userId = Get.parameters['id'];

    // Accessing a query parameter, e.g., if URL was /users/123?mode=view
    final String? mode = Get.parameters['mode'];

    return Scaffold(
      appBar: AppBar(title: Text('User Profile: $userId')),
      body: Center(
        child: Text('Displaying profile for user ID: $userId. Mode: $mode'),
      ),
    );
  }
}
```
If we navigate using `Get.toNamed('/users/456?mode=edit')`:
*   `Get.parameters['id']` would give you `"456"`.
*   `Get.parameters['mode']` would give you `"edit"`.

Simple, right? `Get.parameters` is a map containing all parsed path and query parameters.

## How It Works: The Journey of a Route

Let's trace what happens when you call `Get.toNamed('/users/123?mode=edit')`.

1.  **The Request**: Your code calls `Get.toNamed('/users/123?mode=edit')`.
2.  **Delegate Receives**: This request goes to the `GetRouterDelegate` (our app's navigation captain, from [Chapter 3: GetPage & GetRouterDelegate](03_getpage___getrouterdelegate__.md)).
3.  **Consulting the Address Book (`ParseRouteTree`)**:
    *   The `GetRouterDelegate` has an instance of `ParseRouteTree`. This tree was built when your app started, using the `getPages` list you provided to `GetMaterialApp`.
    *   The delegate asks `ParseRouteTree` to `matchRoute('/users/123?mode=edit')`.
4.  **Finding the Match & Preparing the Envelope (`PageSettings`)**:
    *   `ParseRouteTree` searches through its known `GetPage` definitions. It finds that `/users/:id` matches the path `/users/123`.
    *   It an instance of `PageSettings`. This object holds the original URI and is used to store parsed parameters.
    *   `ParseRouteTree` extracts `123` as the value for the path parameter `id`.
    *   It also parses the query part `?mode=edit` and extracts `mode` with the value `edit`.
    *   These parameters (`id: '123'`, `mode: 'edit'`) are stored within the `PageSettings` object.
5.  **The Postal Worker (`RouteDecoder`)**:
    *   `ParseRouteTree` then creates a `RouteDecoder` object. This `RouteDecoder` bundles:
        *   The matched `GetPage` (the blueprint for `UserProfileScreen`).
        *   The `PageSettings` object containing all the extracted parameters and arguments.
6.  **Delivery**:
    *   The `GetRouterDelegate` receives this `RouteDecoder`. It now knows exactly which screen to show (`UserProfileScreen` via its `GetPage`) and what data (`PageSettings` with `id` and `mode`) to make available to that screen.
    *   The `UserProfileScreen` is built. When it accesses `Get.parameters`, it's actually reading from the `PageSettings` associated with its current route instance (managed by `RouteDecoder`).

Here's a simplified visual of this lookup:

```mermaid
sequenceDiagram
    participant UserAction as User calls Get.toNamed
    participant GRD as GetRouterDelegate
    participant PRT as ParseRouteTree (The Address Book)
    participant PS as PageSettings (The Envelope)
    participant RD as RouteDecoder (The Postal Worker)

    UserAction->>GRD: Get.toNamed("/users/123?mode=edit")
    GRD->>PRT:  matchRoute("/users/123?mode=edit")
    PRT->>PRT: Finds GetPage(name: "/users/:id")
    PRT->>PS: Creates PageSettings, populates with id='123', mode='edit'
    PRT->>RD: Creates RouteDecoder(matched GetPage, PageSettings instance)
    RD-->>GRD: Returns populated RouteDecoder
    GRD->>UserAction: UserProfileScreen is displayed (can access params via Get.parameters)
```

## A Peek Inside the Code

Let's look at simplified versions of these key classes. You don't usually interact with them directly, but understanding their roles is insightful.

### `PageSettings` - The Envelope
(Found in `lib/get_navigation/src/routes/page_settings.dart`)

This class holds information about a specific instance of a route.

```dart
// Simplified concept of PageSettings
class PageSettings extends RouteSettings {
  PageSettings(this.uri, [Object? arguments])
      : super(name: '$uri', arguments: arguments);

  final Uri uri; // The full URI, e.g., /users/123?mode=edit
  final params = <String, String>{}; // Parsed path & query params

  // Helper to get just the path part, e.g., /users/123
  String get path => uri.path;
  // Helper for query params, e.g., {mode: edit}
  Map<String, String> get query => uri.queryParameters;
}
```
When a route is parsed, an instance of `PageSettings` is created, and its `params` map is filled with both path parameters (like `:id`) and query parameters (like `mode=edit`). The full `Uri` and any passed `arguments` are also stored.

### `ParseRouteTree` - The Address Book Builder
(Found in `lib/get_navigation/src/routes/parse_route.dart`)

This class takes all your `GetPage` definitions and builds an efficient way to look them up.

```dart
// Simplified concept of ParseRouteTree
class ParseRouteTree {
  final List<GetPage> routes; // All GetPages from GetMaterialApp.getPages

  ParseRouteTree({required this.routes});

  RouteDecoder matchRoute(String name, {PageSettings? arguments}) {
    final Uri uri = Uri.parse(name); // e.g., /users/123?mode=edit
    GetPage? matchedPage;
    Map<String, String> extractedParams = {};

    // 1. Find matching GetPage
    for (final GetPage routeDefinition in routes) {
      // routeDefinition.path.regex is a pre-compiled regex for the route's path
      // e.g., for '/users/:id', regex matches '/users/ANYTHING'
      final match = routeDefinition.path.regex.firstMatch(uri.path);
      if (match != null) {
        matchedPage = routeDefinition;
        // 2. Extract path parameters (e.g., :id)
        // routeDefinition.path.keys would be ['id']
        for (var i = 0; i < routeDefinition.path.keys.length; i++) {
          extractedParams[routeDefinition.path.keys[i]!] = match[i + 1]!;
        }
        break;
      }
    }

    // 3. Add query parameters
    extractedParams.addAll(uri.queryParameters);

    // 4. Populate PageSettings
    final settings = arguments ?? PageSettings(uri);
    settings.params.clear();
    settings.params.addAll(extractedParams);

    // 5. Create RouteDecoder
    return RouteDecoder(
      matchedPage != null ? [matchedPage] : [], // List of GetPages in hierarchy
      settings,
    );
  }
  // ... other methods to add/remove routes ...
}
```
When `matchRoute` is called:
1.  It iterates through your list of `GetPage`s.
2.  For each `GetPage`, it uses a pre-compiled regular expression (`route.path.regex`) from the `GetPage`'s `name` to see if the current URL path matches. The `PathDecoded` object (part of `GetPage`) handles the conversion of `name` like `/users/:id` into a regex and identifies parameter keys like `id`.
3.  If a match is found, it extracts path parameters.
4.  It then adds any query parameters from the URL.
5.  This information is used to populate a `PageSettings` object.
6.  Finally, it returns a `RouteDecoder` containing the matched `GetPage`(s) and the populated `PageSettings`.

### `RouteDecoder` - The Postal Worker with the Decoded Address
(Found in `lib/get_navigation/src/routes/parse_route.dart`)

This class holds the result of parsing a route: the `GetPage`(s) that should be displayed and their `PageSettings`.

```dart
// Simplified concept of RouteDecoder
class RouteDecoder {
  // currentTreeBranch can hold multiple GetPages for nested routes.
  // For a simple route, it's usually just one GetPage.
  final List<GetPage> currentTreeBranch;
  final PageSettings? pageSettings; // The "envelope" with params & args

  RouteDecoder(this.currentTreeBranch, this.pageSettings);

  // The actual GetPage to be displayed (often the last in the branch)
  GetPage? get route =>
      currentTreeBranch.isEmpty ? null : currentTreeBranch.last;

  // Parameters are conveniently accessible from PageSettings
  Map<String, String> get parameters => pageSettings?.params ?? {};
}
```
The `GetRouterDelegate` uses the `route` (the `GetPage`) from `RouteDecoder` to know which widget to build, and the `pageSettings` to make arguments and parameters available to that widget, typically via `Get.arguments` and `Get.parameters`.

When you use `Get.parameters` in your widget, GetX is essentially looking up the current `RouteDecoder` for your active route and accessing `routeDecoder.pageSettings.params`.

## The Big Picture with `GetRouterDelegate`

The `GetRouterDelegate` (specifically `GetDelegate` in GetX's code, see `lib/get_navigation/src/routes/get_router_delegate.dart`) orchestrates this. It holds the `ParseRouteTree`:

```dart
// Inside GetDelegate (simplified)
class GetDelegate extends RouterDelegate<RouteDecoder> {
  final _routeTree = ParseRouteTree(routes: []); // Initialized with your GetPages

  // ... when navigation occurs ...
  RouteDecoder? _getRouteDecoder<T>(PageSettings arguments) {
    // ...
    final decoder = _routeTree.matchRoute(pageUriString, arguments: arguments);
    // ... further configure decoder (like setting arguments) ...
    return decoder;
  }

  @override
  Future<void> setNewRoutePath(RouteDecoder configuration) async {
    // This is called by Flutter's navigation system when the URL changes
    // or when we programmatically navigate.
    // 'configuration' here is often the result of `_getRouteDecoder`.
    _push(configuration); // _push adds to active pages stack and rebuilds UI
    notifyListeners();
  }
  // ... more logic for building the Navigator widget stack ...
}
```
The `GetDelegate` uses its `_routeTree.matchRoute()` method (which internally uses `ParseRouteTree`) to get a `RouteDecoder`. This `RouteDecoder` then informs the delegate which `GetPage`(s) to render and what `PageSettings` (arguments and parameters) are associated with it.

## Conclusion

You've now seen how GetX acts like a sophisticated address book and postal service for your app's routes!
*   `ParseRouteTree` builds and maintains the "address book" from your `GetPage` definitions.
*   `PageSettings` acts as the "envelope," carrying specific details for a navigation request, including parsed path and query parameters.
*   `RouteDecoder` is the "postal worker" that uses the address book to understand an incoming route string, prepare the envelope, and identify the correct screen blueprint.

This system allows GetX to robustly handle complex URLs, extract parameters, and deliver them to your screens effortlessly, all while you primarily just define your `GetPage`s and use `Get.toNamed()` and `Get.parameters`.

Next up, we'll explore a powerful feature that lets you intercept navigation: [GetMiddleware](06_getmiddleware_.md). Imagine them as security checkpoints or toll booths before you can access certain routes!

Relevant Code Snippets (Code itself remains unchanged):
--- File: lib/get_navigation/src/routes/get_router_delegate.dart ---
import 'dart:async';

import 'package:flutter/foundation.dart';
import 'package:flutter/material.dart';

import '../../../get_instance/src/bindings_interface.dart';
import '../../../get_utils/src/platform/platform.dart';
import '../../../route_manager.dart';

class GetDelegate extends RouterDelegate<RouteDecoder>
    with
        ChangeNotifier,
        PopNavigatorRouterDelegateMixin<RouteDecoder>,
        IGetNavigation {
  factory GetDelegate.createDelegate({
    GetPage<dynamic>? notFoundRoute,
    List<GetPage> pages = const [],
    List<NavigatorObserver>? navigatorObservers,
    TransitionDelegate<dynamic>? transitionDelegate,
    PopMode backButtonPopMode = PopMode.history,
    PreventDuplicateHandlingMode preventDuplicateHandlingMode =
        PreventDuplicateHandlingMode.reorderRoutes,
    GlobalKey<NavigatorState>? navigatorKey,
  }) {
    return GetDelegate(
      notFoundRoute: notFoundRoute,
      navigatorObservers: navigatorObservers,
      transitionDelegate: transitionDelegate,
      backButtonPopMode: backButtonPopMode,
      preventDuplicateHandlingMode: preventDuplicateHandlingMode,
      pages: pages,
      navigatorKey: navigatorKey,
    );
  }

  final List<RouteDecoder> _activePages = <RouteDecoder>[];
  final PopMode backButtonPopMode;
  final PreventDuplicateHandlingMode preventDuplicateHandlingMode;

  final GetPage notFoundRoute;

  final List<NavigatorObserver>? navigatorObservers;
  final TransitionDelegate<dynamic>? transitionDelegate;

  final Iterable<GetPage> Function(RouteDecoder currentNavStack)?
      pickPagesForRootNavigator;

  List<RouteDecoder> get activePages => _activePages;

  final _routeTree = ParseRouteTree(routes: []);

  List<GetPage> get registeredRoutes => _routeTree.routes;

  void addPages(List<GetPage> getPages) {
    _routeTree.addRoutes(getPages);
  }

  void clearRouteTree() {
    _routeTree.routes.clear();
  }

  void addPage(GetPage getPage) {
    _routeTree.addRoute(getPage);
  }

  void removePage(GetPage getPage) {
    _routeTree.removeRoute(getPage);
  }

  RouteDecoder matchRoute(String name, {PageSettings? arguments}) {
    return _routeTree.matchRoute(name, arguments: arguments);
  }

  // GlobalKey<NavigatorState> get navigatorKey => Get.key;

  @override
  GlobalKey<NavigatorState> navigatorKey;

  final String? restorationScopeId;

  GetDelegate({
    GetPage? notFoundRoute,
    this.navigatorObservers,
    this.transitionDelegate,
    this.backButtonPopMode = PopMode.history,
    this.preventDuplicateHandlingMode =
        PreventDuplicateHandlingMode.reorderRoutes,
    this.pickPagesForRootNavigator,
    this.restorationScopeId,
    bool showHashOnUrl = false,
    GlobalKey<NavigatorState>? navigatorKey,
    required List<GetPage> pages,
  })  : navigatorKey = navigatorKey ?? GlobalKey<NavigatorState>(),
        notFoundRoute = notFoundRoute ??= GetPage(
          name: '/404',
          page: () => const Scaffold(
            body: Center(child: Text('Route not found')),
          ),
        ) {
    if (!showHashOnUrl && GetPlatform.isWeb) setUrlStrategy();
    addPages(pages);
    addPage(notFoundRoute);
    Get.log('GetDelegate is created !');
  }

  Future<RouteDecoder?> runMiddleware(RouteDecoder config) async {
    final middlewares = config.currentTreeBranch.last.middlewares;
    if (middlewares.isEmpty) {
      return config;
    }
    var iterator = config;
    for (var item in middlewares) {
      var redirectRes = await item.redirectDelegate(iterator);

      if (redirectRes == null) {
        config.route?.completer?.complete();
        return null;
      }
      if (config != redirectRes) {
        config.route?.completer?.complete();
        Get.log('Redirect to ${redirectRes.pageSettings?.name}');
      }

      iterator = redirectRes;
      // Stop the iteration over the middleware if we changed page
      // and that redirectRes is not the same as the current config.
      if (config != redirectRes) {
        break;
      }
    }
    // If the target is not the same as the source, we need
    // to run the middlewares for the new route.
    if (iterator != config) {
      return await runMiddleware(iterator);
    }
    return iterator;
  }

  Future<void> _unsafeHistoryAdd(RouteDecoder config) async {
    final res = await runMiddleware(config);
    if (res == null) return;
    _activePages.add(res);
  }

  // Future<T?> _unsafeHistoryRemove<T>(RouteDecoder config, T result) async {
  //   var index = _activePages.indexOf(config);
  //   if (index >= 0) return _unsafeHistoryRemoveAt(index, result);
  //   return null;
  // }

  Future<T?> _unsafeHistoryRemoveAt<T>(int index, T result) async {
    if (index == _activePages.length - 1 && _activePages.length > 1) {
      //removing WILL update the current route
      final toCheck = _activePages[_activePages.length - 2];
      final resMiddleware = await runMiddleware(toCheck);
      if (resMiddleware == null) return null;
      _activePages[_activePages.length - 2] = resMiddleware;
    }

    final completer = _activePages.removeAt(index).route?.completer;
    if (completer?.isCompleted == false) completer!.complete(result);

    return completer?.future as T?;
  }

  T arguments<T>() {
    return currentConfiguration?.pageSettings?.arguments as T;
  }

  Map<String, String> get parameters {
    return currentConfiguration?.pageSettings?.params ?? {};
  }

  PageSettings? get pageSettings {
    return currentConfiguration?.pageSettings;
  }

  Future<void> _pushHistory(RouteDecoder config) async {
    if (config.route!.preventDuplicates) {
      final originalEntryIndex = _activePages.indexWhere(
          (element) => element.pageSettings?.name == config.pageSettings?.name);
      if (originalEntryIndex >= 0) {
        switch (preventDuplicateHandlingMode) {
          case PreventDuplicateHandlingMode.popUntilOriginalRoute:
            popModeUntil(config.pageSettings!.name, popMode: PopMode.page);
            break;
          case PreventDuplicateHandlingMode.reorderRoutes:
            await _unsafeHistoryRemoveAt(originalEntryIndex, null);
            await _unsafeHistoryAdd(config);
            break;
          case PreventDuplicateHandlingMode.doNothing:
          default:
            break;
        }
        return;
      }
    }
    await _unsafeHistoryAdd(config);
  }

  Future<T?> _popHistory<T>(T result) async {
    if (!_canPopHistory()) return null;
    return await _doPopHistory(result);
  }

  Future<T?> _doPopHistory<T>(T result) async {
    return _unsafeHistoryRemoveAt<T>(_activePages.length - 1, result);
  }

  Future<T?> _popPage<T>(T result) async {
    if (!_canPopPage()) return null;
    return await _doPopPage(result);
  }

  // returns the popped page
  Future<T?> _doPopPage<T>(T result) async {
    final currentBranch = currentConfiguration?.currentTreeBranch;
    if (currentBranch != null && currentBranch.length > 1) {
      //remove last part only
      final remaining = currentBranch.take(currentBranch.length - 1);
      final prevHistoryEntry = _activePages.length > 1
          ? _activePages[_activePages.length - 2]
          : null;

      //check if current route is the same as the previous route
      if (prevHistoryEntry != null) {
        //if so, pop the entire _activePages entry
        final newLocation = remaining.last.name;
        final prevLocation = prevHistoryEntry.pageSettings?.name;
        if (newLocation == prevLocation) {
          //pop the entire _activePages entry
          return await _popHistory(result);
        }
      }

      //create a new route with the remaining tree branch
      final res = await _popHistory<T>(result);
      await _pushHistory(
        RouteDecoder(
          remaining.toList(),
          null,
          //TOOD: persist state??
        ),
      );
      return res;
    } else {
      //remove entire entry
      return await _popHistory(result);
    }
  }

  Future<T?> _pop<T>(PopMode mode, T result) async {
    switch (mode) {
      case PopMode.history:
        return await _popHistory<T>(result);
      case PopMode.page:
        return await _popPage<T>(result);
    }
  }

  Future<T?> popHistory<T>(T result) async {
    return await _popHistory<T>(result);
  }

  bool _canPopHistory() {
    return _activePages.length > 1;
  }

  Future<bool> canPopHistory() {
    return SynchronousFuture(_canPopHistory());
  }

  bool _canPopPage() {
    final currentTreeBranch = currentConfiguration?.currentTreeBranch;
    if (currentTreeBranch == null) return false;
    return currentTreeBranch.length > 1 ? true : _canPopHistory();
  }

  Future<bool> canPopPage() {
    return SynchronousFuture(_canPopPage());
  }

  bool _canPop(mode) {
    switch (mode) {
      case PopMode.history:
        return _canPopHistory();
      case PopMode.page:
      default:
        return _canPopPage();
    }
  }

  /// gets the visual pages from the current _activePages entry
  ///
  /// visual pages must have [GetPage.participatesInRootNavigator] set to true
  Iterable<GetPage> getVisualPages(RouteDecoder? currentHistory) {
    final res = currentHistory!.currentTreeBranch
        .where((r) => r.participatesInRootNavigator != null);
    if (res.isEmpty) {
      //default behavior, all routes participate in root navigator
      return _activePages.map((e) => e.route!);
    } else {
      //user specified at least one participatesInRootNavigator
      return res
          .where((element) => element.participatesInRootNavigator == true);
    }
  }

  @override
  Widget build(BuildContext context) {
    final currentHistory = currentConfiguration;
    final pages = currentHistory == null
        ? <GetPage>[]
        : pickPagesForRootNavigator?.call(currentHistory).toList() ??
            getVisualPages(currentHistory).toList();
    if (pages.isEmpty) {
      return ColoredBox(
        color: Theme.of(context).scaffoldBackgroundColor,
      );
    }
    return GetNavigator(
      key: navigatorKey,
      onPopPage: _onPopVisualRoute,
      pages: pages,
      observers: navigatorObservers,
      transitionDelegate:
          transitionDelegate ?? const DefaultTransitionDelegate<dynamic>(),
    );
  }

  @override
  Future<void> goToUnknownPage([bool clearPages = false]) async {
    if (clearPages) _activePages.clear();

    final pageSettings = _buildPageSettings(notFoundRoute.name);
    final routeDecoder = _getRouteDecoder(pageSettings);

    _push(routeDecoder!);
  }

  @protected
  void _popWithResult<T>([T? result]) {
    final completer = _activePages.removeLast().route?.completer;
    if (completer?.isCompleted == false) completer!.complete(result);
  }

  @override
  Future<T?> toNamed<T>(
    String page, {
    dynamic arguments,
    dynamic id,
    bool preventDuplicates = true,
    Map<String, String>? parameters,
  }) async {
    final args = _buildPageSettings(page, arguments);
    final route = _getRouteDecoder<T>(args);
    if (route != null) {
      return _push<T>(route);
    } else {
      goToUnknownPage();
    }
    return null;
  }

  @override
  Future<T?> to<T>(
    Widget Function() page, {
    bool? opaque,
    Transition? transition,
    Curve? curve,
    Duration? duration,
    String? id,
    String? routeName,
    bool fullscreenDialog = false,
    dynamic arguments,
    List<BindingsInterface> bindings = const [],
    bool preventDuplicates = true,
    bool? popGesture,
    bool showCupertinoParallax = true,
    double Function(BuildContext context)? gestureWidth,
    bool rebuildStack = true,
    PreventDuplicateHandlingMode preventDuplicateHandlingMode =
        PreventDuplicateHandlingMode.reorderRoutes,
  }) async {
    routeName ??= _cleanRouteName("/${page.runtimeType}");
    // if (preventDuplicateHandlingMode ==
    //PreventDuplicateHandlingMode.Recreate) {
    //   routeName = routeName + page.hashCode.toString();
    // }

    final getPage = GetPage<T>(
      name: routeName,
      opaque: opaque ?? true,
      page: page,
      gestureWidth: gestureWidth,
      showCupertinoParallax: showCupertinoParallax,
      popGesture: popGesture ?? Get.defaultPopGesture,
      transition: transition ?? Get.defaultTransition,
      curve: curve ?? Get.defaultTransitionCurve,
      fullscreenDialog: fullscreenDialog,
      bindings: bindings,
      transitionDuration: duration ?? Get.defaultTransitionDuration,
      preventDuplicateHandlingMode: preventDuplicateHandlingMode,
    );

    _routeTree.addRoute(getPage);
    final args = _buildPageSettings(routeName, arguments);
    final route = _getRouteDecoder<T>(args);
    final result = await _push<T>(
      route!,
      rebuildStack: rebuildStack,
    );
    _routeTree.removeRoute(getPage);
    return result;
  }

  @override
  Future<T?> off<T>(
    Widget Function() page, {
    bool? opaque,
    Transition? transition,
    Curve? curve,
    Duration? duration,
    String? id,
    String? routeName,
    bool fullscreenDialog = false,
    dynamic arguments,
    List<BindingsInterface> bindings = const [],
    bool preventDuplicates = true,
    bool? popGesture,
    bool showCupertinoParallax = true,
    double Function(BuildContext context)? gestureWidth,
  }) async {
    routeName ??= _cleanRouteName("/${page.runtimeType}");
    final route = GetPage<T>(
      name: routeName,
      opaque: opaque ?? true,
      page: page,
      gestureWidth: gestureWidth,
      showCupertinoParallax: showCupertinoParallax,
      popGesture: popGesture ?? Get.defaultPopGesture,
      transition: transition ?? Get.defaultTransition,
      curve: curve ?? Get.defaultTransitionCurve,
      fullscreenDialog: fullscreenDialog,
      bindings: bindings,
      transitionDuration: duration ?? Get.defaultTransitionDuration,
    );

    final args = _buildPageSettings(routeName, arguments);
    return _replace(args, route);
  }

  @override
  Future<T?>? offAll<T>(
    Widget Function() page, {
    bool Function(GetPage route)? predicate,
    bool opaque = true,
    bool? popGesture,
    String? id,
    String? routeName,
    dynamic arguments,
    List<BindingsInterface> bindings = const [],
    bool fullscreenDialog = false,
    Transition? transition,
    Curve? curve,
    Duration? duration,
    bool showCupertinoParallax = true,
    double Function(BuildContext context)? gestureWidth,
  }) async {
    routeName ??= _cleanRouteName("/${page.runtimeType}");
    final route = GetPage<T>(
      name: routeName,
      opaque: opaque,
      page: page,
      gestureWidth: gestureWidth,
      showCupertinoParallax: showCupertinoParallax,
      popGesture: popGesture ?? Get.defaultPopGesture,
      transition: transition ?? Get.defaultTransition,
      curve: curve ?? Get.defaultTransitionCurve,
      fullscreenDialog: fullscreenDialog,
      bindings: bindings,
      transitionDuration: duration ?? Get.defaultTransitionDuration,
    );

    final args = _buildPageSettings(routeName, arguments);

    final newPredicate = predicate ?? (route) => false;

    while (_activePages.length > 1 && !newPredicate(_activePages.last.route!)) {
      _popWithResult();
    }

    return _replace(args, route);
  }

  @override
  Future<T?>? offAllNamed<T>(
    String newRouteName, {
    // bool Function(GetPage route)? predicate,
    dynamic arguments,
    String? id,
    Map<String, String>? parameters,
  }) async {
    final args = _buildPageSettings(newRouteName, arguments);
    final route = _getRouteDecoder<T>(args);
    if (route == null) return null;

    while (_activePages.length > 1) {
      _activePages.removeLast();
    }

    return _replaceNamed(route);
  }

  @override
  Future<T?>? offNamedUntil<T>(
    String page, {
    bool Function(GetPage route)? predicate,
    dynamic arguments,
    String? id,
    Map<String, String>? parameters,
  }) async {
    final args = _buildPageSettings(page, arguments);
    final route = _getRouteDecoder<T>(args);
    if (route == null) return null;

    final newPredicate = predicate ?? (route) => false;

    while (_activePages.length > 1 && !newPredicate(_activePages.last.route!)) {
      _activePages.removeLast();
    }

    return _push(route);
  }

  @override
  Future<T?> offNamed<T>(
    String page, {
    dynamic arguments,
    String? id,
    Map<String, String>? parameters,
  }) async {
    final args = _buildPageSettings(page, arguments);
    final route = _getRouteDecoder<T>(args);
    if (route == null) return null;
    _popWithResult();
    return _push<T>(route);
  }

  @override
  Future<T?> toNamedAndOffUntil<T>(
    String page,
    bool Function(GetPage) predicate, [
    Object? data,
  ]) async {
    final arguments = _buildPageSettings(page, data);

    final route = _getRouteDecoder<T>(arguments);

    if (route == null) return null;

    while (_activePages.isNotEmpty && !predicate(_activePages.last.route!)) {
      _popWithResult();
    }

    return _push<T>(route);
  }

  @override
  Future<T?> offUntil<T>(
    Widget Function() page,
    bool Function(GetPage) predicate, [
    Object? arguments,
  ]) async {
    while (_activePages.isNotEmpty && !predicate(_activePages.last.route!)) {
      _popWithResult();
    }

    return to<T>(page, arguments: arguments);
  }

  @override
  void removeRoute<T>(String name) {
    _activePages.remove(RouteDecoder.fromRoute(name));
  }

  bool get canBack {
    return _activePages.length > 1;
  }

  void _checkIfCanBack() {
    assert(() {
      if (!canBack) {
        final last = _activePages.last;
        final name = last.route?.name;
        throw 'The page $name cannot be popped';
      }
      return true;
    }());
  }

  @override
  Future<R?> backAndtoNamed<T, R>(String page,
      {T? result, Object? arguments}) async {
    final args = _buildPageSettings(page, arguments);
    final route = _getRouteDecoder<R>(args);
    if (route == null) return null;
    _popWithResult<T>(result);
    return _push<R>(route);
  }

  /// Removes routes according to [PopMode]
  /// until it reaches the specific [fullRoute],
  /// DOES NOT remove the [fullRoute]
  @override
  Future<void> popModeUntil(
    String fullRoute, {
    PopMode popMode = PopMode.history,
  }) async {
    // remove history or page entries until you meet route
    var iterator = currentConfiguration;
    while (_canPop(popMode) && iterator != null) {
      //the next line causes wasm compile error if included in the while loop
      //https://github.com/flutter/flutter/issues/140110
      if (iterator.pageSettings?.name == fullRoute) {
        break;
      }
      await _pop(popMode, null);
      // replace iterator
      iterator = currentConfiguration;
    }
    notifyListeners();
  }

  @override
  void backUntil(bool Function(GetPage) predicate) {
    while (_activePages.length > 1 && !predicate(_activePages.last.route!)) {
      _popWithResult();
    }

    notifyListeners();
  }

  Future<T?> _replace<T>(PageSettings arguments, GetPage<T> page) async {
    final index = _activePages.length > 1 ? _activePages.length - 1 : 0;
    _routeTree.addRoute(page);

    final activePage = _getRouteDecoder(arguments);

    // final activePage = _configureRouterDecoder<T>(route!, arguments);

    _activePages[index] = activePage!;

    notifyListeners();
    final result = await activePage.route?.completer?.future as Future<T?>?;
    _routeTree.removeRoute(page);

    return result;
  }

  Future<T?> _replaceNamed<T>(RouteDecoder activePage) async {
    final index = _activePages.length > 1 ? _activePages.length - 1 : 0;
    // final activePage = _configureRouterDecoder<T>(page, arguments);
    _activePages[index] = activePage;

    notifyListeners();
    final result = await activePage.route?.completer?.future as Future<T?>?;
    return result;
  }

  /// Takes a route [name] String generated by [to], [off], [offAll]
  /// (and similar context navigation methods), cleans the extra chars and
  /// accommodates the format.
  /// TODO: check for a more "appealing" URL naming convention.
  /// `() => MyHomeScreenView` becomes `/my-home-screen-view`.
  String _cleanRouteName(String name) {
    name = name.replaceAll('() => ', '');

    /// uncomment for URL styling.
    // name = name.paramCase!;
    if (!name.startsWith('/')) {
      name = '/$name';
    }
    return Uri.tryParse(name)?.toString() ?? name;
  }

  PageSettings _buildPageSettings(String page, [Object? data]) {
    var uri = Uri.parse(page);
    return PageSettings(uri, data);
  }

  @protected
  RouteDecoder? _getRouteDecoder<T>(PageSettings arguments) {
    var page = arguments.uri.path;
    final parameters = arguments.params;
    if (parameters.isNotEmpty) {
      final uri = Uri(path: page, queryParameters: parameters);
      page = uri.toString();
    }

    final decoder = _routeTree.matchRoute(page, arguments: arguments);
    final route = decoder.route;
    if (route == null) return null;

    return _configureRouterDecoder<T>(decoder, arguments);
  }

  @protected
  RouteDecoder _configureRouterDecoder<T>(
      RouteDecoder decoder, PageSettings arguments) {
    final parameters =
        arguments.params.isEmpty ? arguments.query : arguments.params;
    arguments.params.addAll(arguments.query);
    if (decoder.parameters.isEmpty) {
      decoder.parameters.addAll(parameters);
    }

    decoder.route = decoder.route?.copyWith(
      completer: _activePages.isEmpty ? null : Completer<T?>(),
      arguments: arguments,
      parameters: parameters,
      key: ValueKey(arguments.name),
    );

    return decoder;
  }

  Future<T?> _push<T>(RouteDecoder decoder, {bool rebuildStack = true}) async {
    var res = await runMiddleware(decoder);
    if (res == null) return null;
    // final res = mid ?? decoder;
    // if (res == null) res = decoder;

    final preventDuplicateHandlingMode =
        res.route?.preventDuplicateHandlingMode ??
            PreventDuplicateHandlingMode.reorderRoutes;

    final onStackPage = _activePages
        .firstWhereOrNull((element) => element.route?.key == res.route?.key);

    /// There are no duplicate routes in the stack
    if (onStackPage == null) {
      _activePages.add(res);
    } else {
      /// There are duplicate routes, reorder
      switch (preventDuplicateHandlingMode) {
        case PreventDuplicateHandlingMode.doNothing:
          break;
        case PreventDuplicateHandlingMode.reorderRoutes:
          _activePages.remove(onStackPage);
          _activePages.add(res);
          break;
        case PreventDuplicateHandlingMode.popUntilOriginalRoute:
          while (_activePages.last == onStackPage) {
            _popWithResult();
          }
          break;
        case PreventDuplicateHandlingMode.recreate:
          _activePages.remove(onStackPage);
          _activePages.add(res);
      }
    }
    if (rebuildStack) {
      notifyListeners();
    }

    return decoder.route?.completer?.future as Future<T?>?;
  }

  @override
  Future<void> setNewRoutePath(RouteDecoder configuration) async {
    final page = configuration.route;
    if (page == null) {
      goToUnknownPage();
      return;
    } else {
      _push(configuration);
    }
  }

  @override
  RouteDecoder? get currentConfiguration {
    if (_activePages.isEmpty) return null;
    final route = _activePages.last;
    return route;
  }

  Future<bool> handlePopupRoutes({
    Object? result,
  }) async {
    Route? currentRoute;
    navigatorKey.currentState!.popUntil((route) {
      currentRoute = route;
      return true;
    });
    if (currentRoute is PopupRoute) {
      return await navigatorKey.currentState!.maybePop(result);
    }
    return false;
  }

  @override
  Future<bool> popRoute({
    Object? result,
    PopMode? popMode,
  }) async {
    //Returning false will cause the entire app to be popped.
    final wasPopup = await handlePopupRoutes(result: result);
    if (wasPopup) return true;

    if (_canPop(popMode ?? backButtonPopMode)) {
      await _pop(popMode ?? backButtonPopMode, result);
      notifyListeners();
      return true;
    }

    return super.popRoute();
  }

  @override
  void back<T>([T? result]) {
    _checkIfCanBack();
    _popWithResult<T>(result);
    notifyListeners();
  }

  bool _onPopVisualRoute(Route<dynamic> route, dynamic result) {
    final didPop = route.didPop(result);
    if (!didPop) {
      return false;
    }
    _popWithResult(result);
    // final settings = route.settings;
    // if (settings is GetPage) {
    //   final config = _activePages.cast<RouteDecoder?>().firstWhere(
    //         (element) => element?.route == settings,
    //         orElse: () => null,
    //       );
    //   if (config != null) {
    //     _removeHistoryEntry(config, result);
    //   }
    // }
    notifyListeners();
    //return !route.navigator!.userGestureInProgress;
    return true;
  }
}


--- File: lib/get_navigation/src/routes/route_middleware.dart ---
import 'dart:async';

import 'package:flutter/cupertino.dart';

import '../../../get.dart';

/// The Page Middlewares.
/// The Functions will be called in this order
/// (( [redirect] -> [onPageCalled] -> [onBindingsStart] ->
/// [onPageBuildStart] -> [onPageBuilt] -> [onPageDispose] ))
abstract class GetMiddleware {
  GetMiddleware({this.priority = 0});

  /// The Order of the Middlewares to run.
  ///
  /// {@tool snippet}
  /// This Middewares will be called in this order.
  /// ```dart
  /// final middlewares = [
  ///   GetMiddleware(priority: 2),
  ///   GetMiddleware(priority: 5),
  ///   GetMiddleware(priority: 4),
  ///   GetMiddleware(priority: -8),
  /// ];
  /// ```
  ///  -8 => 2 => 4 => 5
  /// {@end-tool}
  final int priority;

  /// This function will be called when the page of
  /// the called route is being searched for.
  /// It take RouteSettings as a result an redirect to the new settings or
  /// give it null and there will be no redirecting.
  /// {@tool snippet}
  /// ```dart
  /// GetPage redirect(String route) {
  ///   final authService = Get.find<AuthService>();
  ///   return authService.authed.value ? null : RouteSettings(name: '/login');
  /// }
  /// ```
  /// {@end-tool}
  RouteSettings? redirect(String? route) => null;

  /// Similar to [redirect],
  /// This function will be called when the router delegate changes the
  /// current route.
  ///
  /// The default implmentation is to navigate to
  /// the input route, with no redirection.
  ///
  /// if this returns null, the navigation is stopped,
  /// and no new routes are pushed.
  /// {@tool snippet}
  /// ```dart
  /// GetNavConfig? redirect(GetNavConfig route) {
  ///   final authService = Get.find<AuthService>();
  ///   return authService.authed.value ? null : RouteSettings(name: '/login');
  /// }
  /// ```
  /// {@end-tool}
  FutureOr<RouteDecoder?> redirectDelegate(RouteDecoder route) => (route);

  /// This function will be called when this Page is called
  /// you can use it to change something about the page or give it new page
  /// {@tool snippet}
  /// ```dart
  /// GetPage onPageCalled(GetPage page) {
  ///   final authService = Get.find<AuthService>();
  ///   return page.copyWith(title: 'Welcome ${authService.UserName}');
  /// }
  /// ```
  /// {@end-tool}
  GetPage? onPageCalled(GetPage? page) => page;

  /// This function will be called right before the [BindingsInterface] are initialize.
  /// Here you can change [BindingsInterface] for this page
  /// {@tool snippet}
  /// ```dart
  /// List<Bindings> onBindingsStart(List<Bindings> bindings) {
  ///   final authService = Get.find<AuthService>();
  ///   if (authService.isAdmin) {
  ///     bindings.add(AdminBinding());
  ///   }
  ///   return bindings;
  /// }
  /// ```
  /// {@end-tool}
  List<R>? onBindingsStart<R>(List<R>? bindings) => bindings;

  /// This function will be called right after the [BindingsInterface] are initialize.
  GetPageBuilder? onPageBuildStart(GetPageBuilder? page) => page;

  /// This function will be called right after the
  /// GetPage.page function is called and will give you the result
  /// of the function. and take the widget that will be showed.
  Widget onPageBuilt(Widget page) => page;

  void onPageDispose() {}
}

class MiddlewareRunner {
  MiddlewareRunner(List<GetMiddleware>? middlewares)
      : _middlewares = middlewares != null
            ? (List.of(middlewares)..sort(_compareMiddleware))
            : const [];

  final List<GetMiddleware> _middlewares;

  static int _compareMiddleware(GetMiddleware a, GetMiddleware b) =>
      a.priority.compareTo(b.priority);

  GetPage? runOnPageCalled(GetPage? page) {
    for (final middleware in _middlewares) {
      page = middleware.onPageCalled(page);
    }
    return page;
  }

  RouteSettings? runRedirect(String? route) {
    for (final middleware in _middlewares) {
      final redirectTo = middleware.redirect(route);
      if (redirectTo != null) {
        return redirectTo;
      }
    }
    return null;
  }

  List<R>? runOnBindingsStart<R>(List<R>? bindings) {
    for (final middleware in _middlewares) {
      bindings = middleware.onBindingsStart(bindings);
    }
    return bindings;
  }

  GetPageBuilder? runOnPageBuildStart(GetPageBuilder? page) {
    for (final middleware in _middlewares) {
      page = middleware.onPageBuildStart(page);
    }
    return page;
  }

  Widget runOnPageBuilt(Widget page) {
    for (final middleware in _middlewares) {
      page = middleware.onPageBuilt(page);
    }
    return page;
  }

  void runOnPageDispose() {
    for (final middleware in _middlewares) {
      middleware.onPageDispose();
    }
  }
}

class PageRedirect {
  GetPage? route;
  GetPage? unknownRoute;
  RouteSettings? settings;
  bool isUnknown;

  PageRedirect({
    this.route,
    this.unknownRoute,
    this.isUnknown = false,
    this.settings,
  });

  // redirect all pages that needes redirecting
  GetPageRoute<T> getPageToRoute<T>(
      GetPage rou, GetPage? unk, BuildContext context) {
    while (needRecheck(context)) {}
    final r = (isUnknown ? unk : rou)!;

    return GetPageRoute<T>(
      page: r.page,
      parameter: r.parameters,
      alignment: r.alignment,
      title: r.title,
      maintainState: r.maintainState,
      routeName: r.name,
      settings: r,
      curve: r.curve,
      showCupertinoParallax: r.showCupertinoParallax,
      gestureWidth: r.gestureWidth,
      opaque: r.opaque,
      customTransition: r.customTransition,
      bindings: r.bindings,
      binding: r.binding,
      binds: r.binds,
      transitionDuration: r.transitionDuration ?? Get.defaultTransitionDuration,
      reverseTransitionDuration:
          r.reverseTransitionDuration ?? Get.defaultTransitionDuration,
      // performIncomeAnimation: _r.performIncomeAnimation,
      // performOutGoingAnimation: _r.performOutGoingAnimation,
      transition: r.transition,
      popGesture: r.popGesture,
      fullscreenDialog: r.fullscreenDialog,
      middlewares: r.middlewares,
    );
  }

  /// check if redirect is needed
  bool needRecheck(BuildContext context) {
    if (settings == null && route != null) {
      settings = route;
    }
    final match = context.delegate.matchRoute(settings!.name!);

    // No Match found
    if (match.route == null) {
      isUnknown = true;
      return false;
    }

    // No middlewares found return match.
    if (match.route!.middlewares.isEmpty) {
      return false;
    }

    final runner = MiddlewareRunner(match.route!.middlewares);
    route = runner.runOnPageCalled(match.route);
    addPageParameter(route!);

    final newSettings = runner.runRedirect(settings!.name);
    if (newSettings == null) {
      return false;
    }
    settings = newSettings;
    return true;
  }

  void addPageParameter(GetPage route) {
    if (route.parameters == null) return;

    final parameters = Map<String, String?>.from(Get.parameters);
    parameters.addEntries(route.parameters!.entries);
    // Get.parameters = parameters;
  }
}


--- File: lib/get_navigation/src/routes/get_route.dart ---
// ignore_for_file: overridden_fields

import 'dart:async';

import 'package:flutter/cupertino.dart';
import 'package:flutter/foundation.dart';
import 'package:flutter/material.dart';

import '../../../get_instance/src/bindings_interface.dart';
import '../../../get_state_manager/src/simple/get_state.dart';
import '../../get_navigation.dart';

class GetPage<T> extends Page<T> {
  final GetPageBuilder page;
  final bool? popGesture;
  final Map<String, String>? parameters;
  final String? title;
  final Transition? transition;
  final Curve curve;
  final bool? participatesInRootNavigator;
  final Alignment? alignment;
  final bool maintainState;
  final bool opaque;
  final double Function(BuildContext context)? gestureWidth;
  final BindingsInterface? binding;
  final List<BindingsInterface> bindings;
  final List<Bind> binds;
  final CustomTransition? customTransition;
  final Duration? transitionDuration;
  final Duration? reverseTransitionDuration;
  final bool fullscreenDialog;
  final bool preventDuplicates;
  final Completer<T?>? completer;
  // @override
  // final LocalKey? key;

  // @override
  // RouteSettings get settings => this;

  @override
  final Object? arguments;

  @override
  final String name;

  final bool inheritParentPath;

  final List<GetPage> children;
  final List<GetMiddleware> middlewares;
  final PathDecoded path;
  final GetPage? unknownRoute;
  final bool showCupertinoParallax;

  final PreventDuplicateHandlingMode preventDuplicateHandlingMode;

  static void _defaultPopInvokedHandler(bool didPop, Object? result) {}

  GetPage({
    required this.name,
    required this.page,
    this.title,
    this.participatesInRootNavigator,
    this.gestureWidth,
    // RouteSettings settings,
    this.maintainState = true,
    this.curve = Curves.linear,
    this.alignment,
    this.parameters,
    this.opaque = true,
    this.transitionDuration,
    this.reverseTransitionDuration,
    this.popGesture,
    this.binding,
    this.bindings = const [],
    this.binds = const [],
    this.transition,
    this.customTransition,
    this.fullscreenDialog = false,
    this.children = const <GetPage>[],
    this.middlewares = const [],
    this.unknownRoute,
    this.arguments,
    this.showCupertinoParallax = true,
    this.preventDuplicates = true,
    this.preventDuplicateHandlingMode =
        PreventDuplicateHandlingMode.reorderRoutes,
    this.completer,
    this.inheritParentPath = true,
    LocalKey? key,
    super.canPop,
    super.onPopInvoked = _defaultPopInvokedHandler,
    super.restorationId,
  })  : path = _nameToRegex(name),
        assert(name.startsWith('/'),
            'It is necessary to start route name [$name] with a slash: /$name'),
        super(
          key: key ?? ValueKey(name),
          name: name,
          // arguments: Get.arguments,
        );
  // settings = RouteSettings(name: name, arguments: Get.arguments);

  GetPage<T> copyWith({
    LocalKey? key,
    String? name,
    GetPageBuilder? page,
    bool? popGesture,
    Map<String, String>? parameters,
    String? title,
    Transition? transition,
    Curve? curve,
    Alignment? alignment,
    bool? maintainState,
    bool? opaque,
    List<BindingsInterface>? bindings,
    BindingsInterface? binding,
    List<Bind>? binds,
    CustomTransition? customTransition,
    Duration? transitionDuration,
    Duration? reverseTransitionDuration,
    bool? fullscreenDialog,
    RouteSettings? settings,
    List<GetPage<T>>? children,
    GetPage? unknownRoute,
    List<GetMiddleware>? middlewares,
    bool? preventDuplicates,
    final double Function(BuildContext context)? gestureWidth,
    bool? participatesInRootNavigator,
    Object? arguments,
    bool? showCupertinoParallax,
    Completer<T?>? completer,
    bool? inheritParentPath,
    bool? canPop,
    PopInvokedWithResultCallback<T>? onPopInvoked,
    String? restorationId,
  }) {
    return GetPage(
      key: key ?? this.key,
      participatesInRootNavigator:
          participatesInRootNavigator ?? this.participatesInRootNavigator,
      preventDuplicates: preventDuplicates ?? this.preventDuplicates,
      name: name ?? this.name,
      page: page ?? this.page,
      popGesture: popGesture ?? this.popGesture,
      parameters: parameters ?? this.parameters,
      title: title ?? this.title,
      transition: transition ?? this.transition,
      curve: curve ?? this.curve,
      alignment: alignment ?? this.alignment,
      maintainState: maintainState ?? this.maintainState,
      opaque: opaque ?? this.opaque,
      bindings: bindings ?? this.bindings,
      binds: binds ?? this.binds,
      binding: binding ?? this.binding,
      customTransition: customTransition ?? this.customTransition,
      transitionDuration: transitionDuration ?? this.transitionDuration,
      reverseTransitionDuration:
          reverseTransitionDuration ?? this.reverseTransitionDuration,
      fullscreenDialog: fullscreenDialog ?? this.fullscreenDialog,
      children: children ?? this.children,
      unknownRoute: unknownRoute ?? this.unknownRoute,
      middlewares: middlewares ?? this.middlewares,
      gestureWidth: gestureWidth ?? this.gestureWidth,
      arguments: arguments ?? this.arguments,
      showCupertinoParallax:
          showCupertinoParallax ?? this.showCupertinoParallax,
      completer: completer ?? this.completer,
      inheritParentPath: inheritParentPath ?? this.inheritParentPath,
      canPop: canPop ?? this.canPop,
      onPopInvoked: onPopInvoked ?? this.onPopInvoked,
      restorationId: restorationId ?? restorationId,
    );
  }

  @override
  Route<T> createRoute(BuildContext context) {
    // return GetPageRoute<T>(settings: this, page: page);
    final page = PageRedirect(
      route: this,
      settings: this,
      unknownRoute: unknownRoute,
    ).getPageToRoute<T>(this, unknownRoute, context);

    return page;
  }

  static PathDecoded _nameToRegex(String path) {
    var keys = <String?>[];

    String recursiveReplace(Match pattern) {
      var buffer = StringBuffer('(?:');

      if (pattern[1] != null) buffer.write('.');
      buffer.write('([\\w%+-._~!\$&\'()*,;=:@]+))');
      if (pattern[3] != null) buffer.write('?');

      keys.add(pattern[2]);
      return "$buffer";
    }

    var stringPath = '$path/?'
        .replaceAllMapped(RegExp(r'(\.)?:(\w+)(\?)?'), recursiveReplace)
        .replaceAll('//', '/');

    return PathDecoded(RegExp('^$stringPath\$'), keys);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    return other is GetPage<T> && other.key == key;
  }

  @override
  String toString() =>
      '${objectRuntimeType(this, 'Page')}("$name", $key, $arguments)';

  @override
  int get hashCode {
    return key.hashCode;
  }
}

@immutable
class PathDecoded {
  final RegExp regex;
  final List<String?> keys;
  const PathDecoded(this.regex, this.keys);

  @override
  int get hashCode => regex.hashCode;

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;

    return other is PathDecoded &&
        other.regex == regex; // && listEquals(other.keys, keys);
  }
}


Instructions for the chapter (Generate content in English unless specified otherwise):
- Start with a clear heading (e.g., `# Chapter 6: GetMiddleware
`). Use the provided concept name.

- If this is not the first chapter, begin with a brief transition from the previous chapter, referencing it with a proper Markdown link using its name.

- Begin with a high-level motivation explaining what problem this abstraction solves. Start with a central use case as a concrete example. The whole chapter should guide the reader to understand how to solve this use case. Make it very minimal and friendly to beginners.

- If the abstraction is complex, break it down into key concepts. Explain each concept one-by-one in a very beginner-friendly way.

- Explain how to use this abstraction to solve the use case. Give example inputs and outputs for code snippets (if the output isn't values, describe at a high level what will happen).

- Each code block should be BELOW 10 lines! If longer code blocks are needed, break them down into smaller pieces and walk through them one-by-one. Aggresively simplify the code to make it minimal. Use comments to skip non-important implementation details. Each code block should have a beginner friendly explanation right after it.

- Describe the internal implementation to help understand what's under the hood. First provide a non-code or code-light walkthrough on what happens step-by-step when the abstraction is called. It's recommended to use a simple sequenceDiagram with a dummy example - keep it minimal with at most 5 participants to ensure clarity. If participant name has space, use: `participant QP as Query Processing`. .

- Then dive deeper into code for the internal implementation with references to files. Provide example code blocks, but make them similarly simple and beginner-friendly. Explain.

- IMPORTANT: When you need to refer to other core abstractions covered in other chapters, ALWAYS use proper Markdown links like this: [Chapter Title](filename.md). Use the Complete Tutorial Structure above to find the correct filename and the chapter title. Translate the surrounding text.

- Use mermaid diagrams to illustrate complex concepts (```mermaid``` format). .

- Heavily use analogies and examples throughout to help beginners understand.

- End the chapter with a brief conclusion that summarizes what was learned and provides a transition to the next chapter. If there is a next chapter, use a proper Markdown link: [Next Chapter Title](next_chapter_filename).

- Ensure the tone is welcoming and easy for a newcomer to understand.

- Output *only* the Markdown content for this chapter.

Now, directly provide a super beginner-friendly Markdown output (DON'T need ```markdown``` tags):

2025-05-16 11:11:21,192 - INFO - RESPONSE: # Chapter 6: GetMiddleware

Welcome back! In [Chapter 5: Route Parsing & Configuration (RouteDecoder, PageSettings, ParseRouteTree)](05_route_parsing___configuration__routedecoder__pagesettings__parseroutetree__.md), we learned how GetX deciphers route names and handles parameters. Now, let's introduce a powerful concept: **GetMiddleware**. These are like checkpoints or gatekeepers for your routes, allowing you to run logic *before* a page is even shown.

## The Problem: Guarding Your Routes

Imagine you have a user profile page `/profile` in your app. You only want authenticated (logged-in) users to access this page. If a guest tries to navigate to `/profile`, they should be redirected to the `/login` page instead. How do you enforce this rule cleanly?

This is where `GetMiddleware` comes in! It lets you intercept navigation requests and decide what happens next.

## What is GetMiddleware? Your Route's Receptionist!

A `GetMiddleware` is a class you create that intercepts navigation to specific routes. Think of them as a security guard or a receptionist at the entrance of different offices (your pages) in a building (your app).

*   **Security Guard:** They might check if you have an ID (are you logged in?). If not, they might send you to the main reception (login page).
*   **Receptionist:** They might ask for your appointment details and, based on them, give you a specific visitor pass (modify page properties) or set up a meeting room for you (initialize bindings for the page).

A `GetMiddleware` can:
1.  **Redirect:** Send the user to a different page (e.g., redirect to `/login` if not authenticated).
2.  **Modify Page Properties:** Change aspects of the page that's about to be loaded (more advanced).
3.  **Setup Bindings:** Initialize specific controllers or services for the upcoming page (more advanced).

For this beginner-friendly chapter, we'll focus on the most common use case: **redirecting users.**

## Creating Your First Middleware: The AuthGuard

Let's create a middleware, `AuthMiddleware`, to protect our `/profile` route.

1.  Create a new Dart file, say `auth_middleware.dart`.
2.  Define your class extending `GetMiddleware`:

```dart
// auth_middleware.dart
import 'package:get/get.dart';

class AuthMiddleware extends GetMiddleware {
  // A simple flag to simulate login state.
  // In a real app, you'd get this from a service, e.g., Get.find<AuthService>().isLoggedIn.
  final bool isLoggedIn = false; // Let's assume the user is NOT logged in for this example.
}
```
Our `AuthMiddleware` currently just has a flag `isLoggedIn`. Now, we need to tell it what to do.

### The `redirectDelegate` Method

The most important method for our use case is `redirectDelegate`. GetX calls this method when a route associated with this middleware is about to be accessed. It receives the current `RouteDecoder` (the details of the route being navigated to) and can decide what `RouteDecoder` (if any) should be processed next.

Let's implement it:

```dart
// auth_middleware.dart (continued)
import 'package:get/get.dart';

class AuthMiddleware extends GetMiddleware {
  final bool isLoggedIn = false; // Assume user is NOT logged in.

  @override
  FutureOr<RouteDecoder?> redirectDelegate(RouteDecoder route) {
    // Check if the user is NOT logged in
    // AND they are NOT trying to go to the login page already
    if (!isLoggedIn && route.pageSettings?.name != '/login') {
      print("AuthMiddleware: User not logged in. Redirecting to /login.");
      // If not logged in, redirect to the '/login' page.
      // We get the RouteDecoder for '/login' from GetX's delegate.
      return Get.delegate.matchRoute('/login');
    }
    // If logged in, or already going to /login, proceed as normal.
    return super.redirectDelegate(route); // This passes the original route through.
  }
}
```
**Explanation:**
*   `redirectDelegate(RouteDecoder route)`: This function is given the `route` that the user is trying to access.
*   `if (!isLoggedIn && route.pageSettings?.name != '/login')`: We check two things:
    *   Is the user `isLoggedIn`? (Here, it's `false`).
    *   Is the route they're trying to access (`route.pageSettings?.name`) something *other* than `/login`? We don't want to redirect them away from `/login` if they're already trying to get there!
*   `return Get.delegate.matchRoute('/login');`: If both conditions are true (not logged in and not going to login), we tell GetX to redirect. We use `Get.delegate.matchRoute('/login')` to create a `RouteDecoder` that points to our `/login` route. This is the new destination.
*   `return super.redirectDelegate(route);`: If the user *is* logged in, or if they are already navigating to `/login`, we let them proceed to their original destination by returning the original `route` (the `super` call effectively does this).

> **Note:** `super.redirectDelegate(route)` simply returns the `route` it was given. You could also just `return route;`. If you return `null`, the navigation will be stopped entirely.

## Applying the Middleware to a `GetPage`

Now that we have our `AuthMiddleware`, we need to tell GetX to use it for specific routes. We do this in the `getPages` list within our `GetMaterialApp`.

Let's assume you have `GetPage` definitions for `/home`, `/login`, and `/profile`:

```dart
// main.dart
import 'package:flutter/material.dart';
import 'package:get/get.dart';
import 'auth_middleware.dart'; // Import your middleware

// Simple placeholder screens
class HomeScreen extends StatelessWidget {
  @override Widget build(BuildContext context) => Scaffold(appBar: AppBar(title: Text('Home')), body: Center(child: ElevatedButton(onPressed: () => Get.toNamed('/profile'), child: Text('Go to Profile'))));
}
class LoginScreen extends StatelessWidget {
  @override Widget build(BuildContext context) => Scaffold(appBar: AppBar(title: Text('Login')), body: Center(child: Text('Please Log In')));
}
class ProfileScreen extends StatelessWidget {
  @override Widget build(BuildContext context) => Scaffold(appBar: AppBar(title: Text('Profile')), body: Center(child: Text('Welcome to your Profile!')));
}

void main() {
  runApp(MyApp());
}

class MyApp extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return GetMaterialApp(
      initialRoute: '/home',
      getPages: [
        GetPage(name: '/home', page: () => HomeScreen()),
        GetPage(name: '/login', page: () => LoginScreen()),
        GetPage(
          name: '/profile',
          page: () => ProfileScreen(),
          middlewares: [ // <-- Apply our AuthMiddleware here!
            AuthMiddleware(),
          ],
        ),
      ],
    );
  }
}
```
In the `GetPage` for `/profile`, we added a `middlewares` list and put an instance of our `AuthMiddleware()` in it.

## Seeing it in Action!

Now, let's trace what happens:

1.  **App Starts:** You land on `/home`.
2.  **Navigate to Profile:** You click the "Go to Profile" button, which calls `Get.toNamed('/profile')`.
3.  **Middleware Intercepts:**
    *   GetX sees that the `/profile` route has `AuthMiddleware` attached.
    *   It calls `AuthMiddleware.redirectDelegate()` with the `RouteDecoder` for `/profile`.
    *   Inside our middleware:
        *   `isLoggedIn` is `false`.
        *   `route.pageSettings?.name` is `/profile` (which is not `/login`).
        *   The condition `!isLoggedIn && route.pageSettings?.name != '/login'` is TRUE.
        *   The middleware returns `Get.delegate.matchRoute('/login')`.
4.  **Redirection Occurs:** GetX now discards the original navigation to `/profile` and instead navigates to `/login`.
5.  **Result:** You see the `LoginScreen`!

If you were to change `isLoggedIn = true;` in your `AuthMiddleware` and rerun:
1.  Navigate to `/profile`.
2.  Middleware runs: `isLoggedIn` is `true`.
3.  The condition `!isLoggedIn && ...` is FALSE.
4.  The middleware returns `super.redirectDelegate(route)` (meaning, "proceed to `/profile`").
5.  **Result:** You see the `ProfileScreen`!

## How It Works Under the Hood

Let's briefly look at what GetX is doing.

1.  **Navigation Request:** You call `Get.toNamed('/profile')`.
2.  **Delegate Processing:** This request reaches the `GetRouterDelegate` (as seen in [Chapter 3: GetPage & GetRouterDelegate](03_getpage___getrouterdelegate__.md)).
3.  **Route Matching:** The delegate uses `ParseRouteTree` to find the `GetPage` associated with `/profile`.
4.  **Middleware Check:** The delegate sees that this `GetPage` has a list of `middlewares`.
5.  **Executing Middlewares:** The `GetRouterDelegate` (specifically in its `runMiddleware` method) iterates through these middlewares (sorted by priority, which we'll discuss soon). For each middleware, it calls its `redirectDelegate` method, passing the current `RouteDecoder`.

```mermaid
sequenceDiagram
    participant User as User Action
    participant GetToNamed as Get.toNamed("/profile")
    participant GRD as GetRouterDelegate
    participant AuthMW as AuthMiddleware
    participant TargetPage as ProfileScreen / LoginScreen

    User->>GetToNamed: Tries to go to /profile
    GetToNamed->>GRD: Informs delegate of intent
    GRD->>GRD: Finds GetPage for /profile, sees AuthMiddleware
    GRD->>AuthMW: Calls authMiddleware.redirectDelegate(profileRouteDecoder)
    alt User NOT Logged In
        AuthMW->>GRD: Returns loginRouteDecoder
        GRD->>TargetPage: Navigates to LoginScreen
    else User Logged In
        AuthMW->>GRD: Returns profileRouteDecoder (original)
        GRD->>TargetPage: Navigates to ProfileScreen
    end
```

Here's a peek at the relevant parts (simplified):

**`GetPage` (from `lib/get_navigation/src/routes/get_route.dart`):**
It has a property to hold middlewares.
```dart
class GetPage<T> extends Page<T> {
  // ... other properties ...
  final List<GetMiddleware> middlewares;

  GetPage({
    // ...
    this.middlewares = const [],
    // ...
  });
}
```

**`GetMiddleware` (from `lib/get_navigation/src/routes/route_middleware.dart`):**
This is the base class you extend.
```dart
abstract class GetMiddleware {
  // ... priority and other methods ...

  FutureOr<RouteDecoder?> redirectDelegate(RouteDecoder route) => (route);
  // Default implementation passes the original route through.
  // Returning null stops navigation.
  // Returning a different RouteDecoder redirects.
}
```

**`GetDelegate.runMiddleware()` (conceptual, from `lib/get_navigation/src/routes/get_router_delegate.dart`):**
This method in `GetDelegate` is responsible for executing the middlewares.
```dart
// Simplified concept from GetDelegate
Future<RouteDecoder?> runMiddleware(RouteDecoder currentRouteDecoder) async {
  final middlewares = currentRouteDecoder.route!.middlewares; // Get middlewares from GetPage
  if (middlewares.isEmpty) return currentRouteDecoder;

  var nextRouteDecoder = currentRouteDecoder;
  for (final middleware in middlewares) { // Loop (respecting priority)
    final resultFromMiddleware = await middleware.redirectDelegate(nextRouteDecoder);

    if (resultFromMiddleware == null) { // Middleware says stop
      return null;
    }
    nextRouteDecoder = resultFromMiddleware; // Update to what middleware returned
    // If middleware redirected (nextRouteDecoder != original input to it),
    // GetX might break and re-run middlewares FOR THE NEW ROUTE.
    if (/* current 'nextRouteDecoder' is actually a new different route */) {
       // Potentially re-run middleware chain for the *new* nextRouteDecoder
       return await runMiddleware(nextRouteDecoder);
    }
  }
  return nextRouteDecoder; // Final decision after all middlewares
}
```
This shows that `GetDelegate` actively calls your middleware's `redirectDelegate` and acts upon its result.

## Other Middleware Capabilities (A Quick Look)

While `redirectDelegate` is key for routing logic, `GetMiddleware` offers more:

*   `priority` (int): If you have multiple middlewares on a single `GetPage`, `priority` determines their execution order. Lower numbers run first. Default is `0`.
    ```dart
    class LoggerMiddleware extends GetMiddleware {
      @override
      int get priority => -1; // Run this before AuthMiddleware if both are on same route

      @override
      FutureOr<RouteDecoder?> redirectDelegate(RouteDecoder route) {
        print("Logger: Navigating to ${route.pageSettings?.name}");
        return route; // Just log and proceed
      }
    }

    // In GetPage: middlewares: [AuthMiddleware(), LoggerMiddleware()]
    // LoggerMiddleware (priority -1) runs before AuthMiddleware (priority 0).
    ```

*   `onPageCalled(GetPage? page)`: Called after redirection logic but before bindings. You can modify the `GetPage` instance here (e.g., change its title).
*   `onBindingsStart(List<BindingsInterface>? bindings)`: Called before bindings are initialized. You could add or remove bindings.
*   `onPageBuildStart(GetPageBuilder? page)`: Called before the `page()` builder of `GetPage` is executed.
*   `onPageBuilt(Widget page)`: Called after the page widget is built.
*   `onPageDispose()`: Called when the page and its bindings are disposed.

For most common scenarios like authentication, `redirectDelegate` and `priority` are what you'll use most often.

## Conclusion

You've learned about `GetMiddleware`, your powerful tool for guarding routes and executing logic before pages are displayed. By implementing the `redirectDelegate` method, you can easily control navigation flow, such as redirecting unauthenticated users to a login screen. Adding these middlewares to your `GetPage` definitions integrates them seamlessly into GetX's routing system.

This opens up possibilities for creating more secure and dynamic applications.

Next, we'll explore how GetX handles the visual flair of navigation: the [Transition System (GetPageRouteTransitionMixin, CustomTransition, Transitions)](07_transition_system__getpageroutetransitionmixin__customtransition__transitions__.md)!
2025-05-16 11:11:21,269 - INFO - PROMPT: 
Write a very beginner-friendly tutorial chapter (in Markdown format) for the project `getx` about the concept: "Transition System (GetPageRouteTransitionMixin, CustomTransition, Transitions)
". This is Chapter 7.

Concept Details:
- Name: Transition System (GetPageRouteTransitionMixin, CustomTransition, Transitions)

- Description:
This system defines how screens animate when navigating from one to another. `GetPageRouteTransitionMixin` provides the core logic for page transitions, including standard Material/Cupertino transitions and back-swipe gestures. `Transitions` enum lists pre-defined animation types (fade, slide, etc.). `CustomTransition` allows developers to implement entirely unique animations.
Think of it as the special effects director for your app's scene changes. It dictates whether a new scene slides in, fades in, zooms, or uses a custom choreographed entrance.


Complete Tutorial Structure:
1. [GetMaterialApp / GetCupertinoApp & GetRoot
](01_getmaterialapp___getcupertinoapp___getroot_.md)
2. [GetNavigation Extensions (e.g., Get.toNamed, Get.snackbar)
](02_getnavigation_extensions__e_g___get_tonamed__get_snackbar__.md)
3. [GetPage & GetRouterDelegate
](03_getpage___getrouterdelegate_.md)
4. [Overlay Management (Snackbar, Dialog, BottomSheet)
](04_overlay_management__snackbar__dialog__bottomsheet__.md)
5. [Route Parsing & Configuration (RouteDecoder, PageSettings, ParseRouteTree)
](05_route_parsing___configuration__routedecoder__pagesettings__parseroutetree__.md)
6. [GetMiddleware
](06_getmiddleware_.md)
7. [Transition System (GetPageRouteTransitionMixin, CustomTransition, Transitions)
](07_transition_system__getpageroutetransitionmixin__customtransition__transitions__.md)
8. [RouterReportManager
](08_routerreportmanager_.md)

Context from previous chapters:
# Chapter 1: GetMaterialApp / GetCupertinoApp & GetRoot

Welcome to your GetX journey! This is the very first step into a powerful and easy-to-use Flutter framework. In this chapter, we'll explore the foundational building blocks of any GetX application: `GetMaterialApp`, `GetCupertinoApp`, and the unsung hero, `GetRoot`.

## What's the Big Deal? Setting Up Your GetX App

Imagine you're building a house. Before you can add rooms, furniture, or even think about painting the walls, you need a solid foundation and the main structure, right? In a Flutter app using GetX, `GetMaterialApp` or `GetCupertinoApp` are like choosing the architectural style of your house (Material Design for Android-style or Cupertino for iOS-style), and they lay this essential groundwork.

Flutter apps usually start with `MaterialApp` (for Material Design) or `CupertinoApp` (for iOS-style design). GetX provides its own versions:

*   `GetMaterialApp`
*   `GetCupertinoApp`

Why use these instead of the standard Flutter ones? Because they do something crucial: **they initialize the GetX framework**. This "initialization" means they set up all the cool things GetX offers, like super-easy navigation, smart state management, and simple internationalization (showing your app in different languages).

Think of it like this: standard `MaterialApp` gives you a basic house blueprint. `GetMaterialApp` gives you that same blueprint but also installs the main electrical panel, plumbing system, and a smart home hub, all ready for you to use GetX features without extra setup.

## Meet the Stars of the Show

Let's break down these key components:

### 1. `GetMaterialApp` (for Material Design lovers)

If you're building an app that follows Google's Material Design guidelines (common for Android apps, but also widely used for cross-platform apps), you'll use `GetMaterialApp`. It's a direct replacement for Flutter's `MaterialApp`. By using it, you're telling your app, "Hey, I want to use GetX features!"

```dart
// main.dart
import 'package:flutter/material.dart';
import 'package:get/get.dart'; // Don't forget to import GetX!

void main() {
  runApp(MyApp());
}

class MyApp extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return GetMaterialApp( // <-- See? We use GetMaterialApp here!
      title: 'My First GetX App',
      home: MyHomePage(),
    );
  }
}

class MyHomePage extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(title: Text('GetX is Awesome!')),
      body: Center(child: Text('Hello, GetX World!')),
    );
  }
}
```
In this very simple app, just by changing `MaterialApp` to `GetMaterialApp`, we've unlocked the potential to use all of GetX's powerful features throughout our `MyApp`.

### 2. `GetCupertinoApp` (for iOS aficionados)

If you're aiming for an app that looks and feels like a native iOS application, you'll use `GetCupertinoApp`. It's the GetX equivalent of Flutter's `CupertinoApp`.

```dart
// main.dart
import 'package:flutter/cupertino.dart';
import 'package:get/get.dart'; // Import GetX

void main() {
  runApp(MyApp());
}

class MyApp extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return GetCupertinoApp( // <-- Using GetCupertinoApp for iOS style
      title: 'My First GetX iOS App',
      home: MyHomePage(),
    );
  }
}

class MyHomePage extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return CupertinoPageScaffold(
      navigationBar: CupertinoNavigationBar(
        middle: Text('Hello, GetX (iOS Style)!'),
      ),
      child: Center(child: Text('GetX on Cupertino!')),
    );
  }
}
```
Similar to `GetMaterialApp`, using `GetCupertinoApp` sets up your app for GetX functionalities but with an iOS-style foundation.

### 3. `GetRoot`: The Engine Under the Hood

You might not ever type `GetRoot` directly in your code, but it's super important to know it exists. `GetRoot` is the core widget that both `GetMaterialApp` and `GetCupertinoApp` use internally.

Think of `GetRoot` as the main power supply and central control panel for the GetX system in your app. It's responsible for:
*   Managing global configurations.
*   Setting up the routing system that GetX uses for navigation.
*   Initializing dependency management.
*   Handling internationalization settings (like current language).

So, when you use `GetMaterialApp` or `GetCupertinoApp`, they are essentially putting a `GetRoot` widget at the very top of your application's widget tree. This makes all the GetX features available to every part of your app.

## How Does It Work? A Peek Inside

You don't need to know the intricate details to use GetX effectively, but a little insight can be helpful!

1.  **You start your app:** You use `GetMaterialApp` (or `GetCupertinoApp`) as the root widget in your `main.dart` file.
2.  **`GetMaterialApp` takes charge:** When `GetMaterialApp` is built, its main job is to create and configure a `GetRoot` widget. It passes along all your app's configurations (like themes, initial routes, translations, etc.) to `GetRoot`.
3.  **`GetRoot` powers up:** `GetRoot` receives these configurations and initializes the entire GetX ecosystem. It sets up internal controllers, listeners for things like language changes, and provides the necessary context for GetX features to work.
4.  **Your app is ready!** With `GetRoot` in place, all other GetX functionalities (like `Get.to()` for navigation, `Get.put()` for dependency injection, `Get.snackbar()` for messages) can now find the necessary GetX infrastructure and work their magic.

Let's visualize this flow:

```mermaid
sequenceDiagram
    participant UserApp as main.dart
    participant GMA as GetMaterialApp
    participant GR as GetRoot
    participant GetXCore as GetX Core System

    UserApp->>GMA: Uses GetMaterialApp/GetCupertinoApp
    GMA->>GR: Wraps its child with GetRoot, passing configurations
    GR->>GetXCore: Initializes GetX services (routing, DI, locale)
    GMA->>UserApp: Renders app with GetX features enabled
```

**A Tiny Glimpse into the Code:**

You won't usually need to touch this code, but it helps to see it.

Here's a simplified look at what `GetMaterialApp` does in its `build` method (from `lib/get_navigation/src/root/get_material_app.dart`):

```dart
// Inside GetMaterialApp's build method
@override
Widget build(BuildContext context) {
  return GetRoot( // Notice! It returns a GetRoot widget.
    config: ConfigData( // Bundles up all configurations
      // ... like home, getPages, locale, theme ...
      home: home,
      getPages: getPages,
      locale: locale,
      theme: theme,
      // ... and many other settings you provide ...
    ),
    child: Builder(builder: (context) {
      // This inner part builds the actual MaterialApp,
      // now empowered by GetRoot and its configurations.
      final controller = GetRoot.of(context);
      return MaterialApp.router( /* ... uses controller.config ... */ );
    }),
  );
}
```
This code shows that `GetMaterialApp` essentially sets up `GetRoot` with all your app's settings. `GetRoot` then takes care of the nitty-gritty GetX initialization.

And here's a very simplified idea of what `GetRoot` does when it starts (from `lib/get_navigation/src/root/get_root.dart`):

```dart
// Inside GetRootState's initState method
@override
void initState() {
  config = widget.config; // Receives config from GetMaterialApp/GetCupertinoApp
  // ... other setup ...
  onInit(); // Calls a special GetX initialization method
  super.initState();
}

void onInit() {
  // Example: Sets up the current language (locale) for your app
  if (config.locale != null) Get.locale = config.locale;

  // Example: Initializes translations if you provide them
  if (config.translations != null) {
    Get.addTranslations(config.translations!.keys);
  }
  // ... and much more initialization for routing, logging, etc. ...
}
```
This `onInit()` method within `GetRoot` is where a lot of the GetX magic gets set up based on the properties you pass to `GetMaterialApp` or `GetCupertinoApp`.

## Why Bother? The Benefits

*   **Simplicity:** You just swap `MaterialApp` with `GetMaterialApp` (or `CupertinoApp` with `GetCupertinoApp`), and you're ready to use GetX. No complex setup rituals!
*   **Power:** This simple change unlocks a vast array of features:
    *   Effortless route management (covered in [GetNavigation Extensions (e.g., Get.toNamed, Get.snackbar)](02_getnavigation_extensions__e_g___get_tonamed__get_snackbar__.md) and [GetPage & GetRouterDelegate](03_getpage___getrouterdelegate__.md)).
    *   Simple state management.
    *   Easy dependency injection.
    *   Built-in internationalization.
    *   Dialogs, Snackbars, and BottomSheets without `context` (see [Overlay Management (Snackbar, Dialog, BottomSheet)](04_overlay_management__snackbar__dialog__bottomsheet__.md)).
*   **Performance:** GetX is designed to be lightweight and performant.

## Conclusion

You've just learned about the most fundamental step in building a GetX application: using `GetMaterialApp` or `GetCupertinoApp`. These widgets, powered by the underlying `GetRoot`, are your gateway to the GetX ecosystem. They seamlessly initialize everything you need, allowing you to focus on building amazing features rather than wrestling with boilerplate setup.

With this foundation laid, you're now ready to explore one of the most beloved features of GetX: its incredibly simple and powerful navigation system.

Ready to learn how to move between screens with ease? Let's dive into the [GetNavigation Extensions (e.g., Get.toNamed, Get.snackbar)](02_getnavigation_extensions__e_g___get_tonamed__get_snackbar__.md)!
---
# Chapter 2: GetNavigation Extensions (e.g., Get.toNamed, Get.snackbar)

Welcome back! In [Chapter 1: GetMaterialApp / GetCupertinoApp & GetRoot](01_getmaterialapp___getcupertinoapp___getroot_.md), we learned how to set up the foundation of our GetX app using `GetMaterialApp` or `GetCupertinoApp`. This simple step unlocked a world of powerful GetX features. Now, let's explore one of the most loved features: making navigation and showing pop-ups incredibly easy!

## The Old Way vs. The GetX Way

Imagine you're in your app, perhaps inside a settings page, and you want to navigate to a user profile page after a button tap. In standard Flutter, you'd typically need `BuildContext` to do this:

```dart
// Standard Flutter (needs context)
Navigator.push(context, MaterialPageRoute(builder: (context) => ProfileScreen()));
```

What if your button's logic is inside a separate class, like a ViewModel or a Controller, that doesn't have direct access to `BuildContext`? Passing `BuildContext` around can make your code a bit messy.

This is where GetX shines! GetX provides **GetNavigation Extensions**. These are convenient shortcut methods attached to the `Get` interface (think of `Get` as your GetX toolkit). They allow you to navigate or show UI elements like dialogs, snackbars, and bottom sheets from *anywhere* in your code without needing a `BuildContext`.

Think of it as a **universal remote control** for your app's navigation and common UI pop-ups. Instead of finding the specific local remote (`BuildContext`) for the TV in a room, you use one master remote (`Get`) to control any TV (navigation, dialog) in the house.

## Your Universal Remote: Meet `Get`

The `Get` object is your central access point for many GetX features. When you see `Get.something()`, you're using one of these handy extensions.

Let's see how this "universal remote" works for common tasks.

### 1. Navigating to a New Screen: `Get.to()`

Want to go to a new screen? Just use `Get.to()` and tell it which screen (widget) to build.

**Use Case:** Let's say we have a `HomeScreen` and we want to navigate to a `DetailScreen`.

First, your `main.dart` should be set up with `GetMaterialApp` (as learned in Chapter 1):

```dart
// main.dart
import 'package:flutter/material.dart';
import 'package:get/get.dart';
import 'home_screen.dart'; // We'll create this next

void main() {
  runApp(MyApp());
}

class MyApp extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return GetMaterialApp( // Using GetMaterialApp
      title: 'GetX Navigation',
      home: HomeScreen(),
    );
  }
}
```
This setup is crucial because `GetMaterialApp` prepares GetX for context-less navigation.

Now, let's create `HomeScreen` and `DetailScreen`:

```dart
// home_screen.dart
import 'package:flutter/material.dart';
import 'package:get/get.dart';
import 'detail_screen.dart'; // We'll create this

class HomeScreen extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(title: Text('Home')),
      body: Center(
        child: ElevatedButton(
          onPressed: () {
            // Look, no context needed!
            Get.to(() => DetailScreen());
          },
          child: Text('Go to Details'),
        ),
      ),
    );
  }
}
```
In `HomeScreen`, when the button is pressed, `Get.to(() => DetailScreen())` is called. This tells GetX to push `DetailScreen` onto the navigation stack.

```dart
// detail_screen.dart
import 'package:flutter/material.dart';

class DetailScreen extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(title: Text('Details')),
      body: Center(child: Text('This is the Detail Screen!')),
    );
  }
}
```
`DetailScreen` is just a simple page. When you tap the button on `HomeScreen`, you'll navigate to `DetailScreen`.

**What happened?**
`Get.to(() => DetailScreen())` pushed a new route displaying `DetailScreen` onto the navigation stack. The `() => DetailScreen()` part is a function that creates your new screen.

### 2. Navigating with Named Routes: `Get.toNamed()`

Sometimes, you prefer to navigate using names instead of creating widget instances directly. This is great for clean code and is essential for web routing. GetX makes this super easy with `Get.toNamed()`.

First, you need to define your named routes in `GetMaterialApp` using the `getPages` property. We'll dive deeper into `getPages` in [GetPage & GetRouterDelegate](03_getpage___getrouterdelegate__.md), but here's a sneak peek:

```dart
// main.dart (updated)
import 'package:flutter/material.dart';
import 'package:get/get.dart';
import 'home_screen.dart';
import 'detail_screen.dart'; // Import DetailScreen

void main() {
  runApp(MyApp());
}

class MyApp extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return GetMaterialApp(
      title: 'GetX Named Navigation',
      initialRoute: '/home', // Optional: set an initial route
      getPages: [
        GetPage(name: '/home', page: () => HomeScreen()),
        GetPage(name: '/detail', page: () => DetailScreen()),
      ],
    );
  }
}
```
We've defined two routes: `/home` pointing to `HomeScreen` and `/detail` pointing to `DetailScreen`.

Now, in your `HomeScreen`, you can navigate using the name:

```dart
// home_screen.dart (updated for named route)
// ... (imports remain the same)
class HomeScreen extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(title: Text('Home')),
      body: Center(
        child: ElevatedButton(
          onPressed: () {
            Get.toNamed('/detail'); // Navigate by name!
          },
          child: Text('Go to Details (Named)'),
        ),
      ),
    );
  }
}
```
When you tap the button, `Get.toNamed('/detail')` looks up the '/detail' route you defined in `getPages` and navigates to `DetailScreen`.

### 3. Going Back: `Get.back()`

To go back to the previous screen, it's as simple as:

```dart
// Inside DetailScreen, for example
ElevatedButton(
  onPressed: () {
    Get.back(); // Go back to HomeScreen
  },
  child: Text('Go Back'),
)
```
`Get.back()` pops the current screen from the navigation stack, just like Flutter's `Navigator.pop(context)`.

### 4. Showing a Quick Message: `Get.snackbar()`

Need to show a quick notification or message (a "snackbar")? GetX has you covered, again, without needing `BuildContext`.

```dart
// In any button's onPressed, or anywhere else:
ElevatedButton(
  onPressed: () {
    Get.snackbar(
      "Success!", // Title
      "Your action was completed.", // Message
      snackPosition: SnackPosition.BOTTOM, // Optional: position
    );
  },
  child: Text('Show Snackbar'),
)
```
This will display a sleek snackbar at the bottom (or top, depending on `snackPosition`) of your screen. It's that easy! We'll explore snackbars in more detail in [Overlay Management (Snackbar, Dialog, BottomSheet)](04_overlay_management__snackbar__dialog__bottomsheet__.md).

### 5. A Peek at Dialogs and Bottom Sheets

GetX also simplifies showing dialogs and bottom sheets without `BuildContext`.

*   **Dialogs with `Get.dialog()`**:
    ```dart
    // Example: Show a simple dialog
    Get.dialog(
      AlertDialog(
        title: Text('Alert!'),
        content: Text('This is a GetX dialog.'),
        actions: [TextButton(onPressed: () => Get.back(), child: Text('OK'))],
      )
    );
    ```

*   **Bottom Sheets with `Get.bottomSheet()`**:
    ```dart
    // Example: Show a simple bottom sheet
    Get.bottomSheet(
      Container(
        height: 200,
        color: Colors.white,
        child: Center(child: Text('This is a GetX bottom sheet!')),
      )
    );
    ```
These are very powerful, and you'll learn all about customizing them in [Overlay Management (Snackbar, Dialog, BottomSheet)](04_overlay_management__snackbar__dialog__bottomsheet__.md). For now, just know they exist and are super easy to call!

## How Does This Magic Work? Under the Hood

You might be wondering: "If I'm not giving it `BuildContext`, how does `Get.toNamed()` or `Get.snackbar()` know where to navigate or show the message?"

It's thanks to the setup we did in [Chapter 1: GetMaterialApp / GetCupertinoApp & GetRoot](01_getmaterialapp___getcupertinoapp___getroot_.md)!

1.  **The Foundation**: When you use `GetMaterialApp` (or `GetCupertinoApp`), it internally creates and configures a `GetRoot` widget. This `GetRoot` widget holds a global `NavigatorKey`. Think of this key as a direct phone line to Flutter's navigation system. It also manages an `OverlayKey` for things like snackbars and dialogs.

2.  **The Call**: When you call something like `Get.toNamed('/detail')`, the static `Get` interface uses this globally available `NavigatorKey` (managed by `GetRootController`) to access the current `NavigatorState`.

3.  **The Action**: Once it has the `NavigatorState`, it can then call the standard Flutter methods like `navigatorState.pushNamed('/detail')` or `navigatorState.push(MaterialPageRoute(...))`.

For snackbars, dialogs, and bottom sheets, `Get` uses a similar mechanism to access the `OverlayState` (via `Get.overlayContext`) to display these UI elements on top of your current screen.

Here's a simplified flow:

```mermaid
sequenceDiagram
    participant YourWidget as Your Widget (e.g., Button)
    participant GetStatic as Get (Static Interface)
    participant GetRootCtrl as GetRoot Controller (from GetMaterialApp)
    participant FlutterNavigator as Flutter Navigator/Overlay

    YourWidget->>GetStatic: Calls Get.toNamed("/details") or Get.snackbar(...)
    GetStatic->>GetRootCtrl: Accesses root NavigatorKey or OverlayContext
    GetRootCt<ctrl63>
---
# Chapter 3: GetPage & GetRouterDelegate

In [Chapter 2: GetNavigation Extensions (e.g., Get.toNamed, Get.snackbar)](02_getnavigation_extensions__e_g___get_tonamed__get_snackbar__.md), we saw how easy GetX makes navigating between screens using methods like `Get.to()` and `Get.toNamed()`. We even had a sneak peek at defining named routes. Now, let's dive deeper into how GetX manages these routes in a more structured and powerful way using `GetPage` and `GetRouterDelegate`. These are the tools that make GetX's navigation so robust, especially for larger apps!

## The Need for Structure: Why Bother?

Imagine you're designing a website with many pages: a homepage, an about page, a contact page, a profile page, and so on. If you just linked them haphazardly, it would quickly become a mess. You'd want a clear sitemap and well-defined URLs for each page.

Similarly, in a Flutter app, as it grows, just calling `Get.to(() => MyScreen())` everywhere can become hard to manage. What if you want to change the transition animation for a specific screen? Or pass data to it in a standardized way? Or manage deep linking (opening specific app screens from a web link)?

This is where `GetPage` and `GetRouterDelegate` come in. They help you:
1.  **Define all your app's screens (routes) in one central place.**
2.  **Give each screen a unique name (like a URL).**
3.  **Configure special behaviors for each screen (like transitions or data bindings).**
4.  **Power Flutter's modern Navigator 2.0 system within GetX, allowing for more complex navigation scenarios.**

Let's meet the stars!

## Meet the Blueprint: `GetPage`

Think of `GetPage` as a **blueprint for a screen** in your app. It's not the screen itself, but rather a detailed description of it. Each `GetPage` tells GetX:
*   `name`: The unique "URL" or path for this screen (e.g., `/home`, `/profile`, `/settings/notifications`). This is what you use with `Get.toNamed()`.
*   `page`: A function that tells GetX *how to build* the actual widget for this screen when it's needed.
*   `binding` (optional): A way to set up controllers or other dependencies specifically for this screen. (We'll explore bindings more in GetX state management).
*   `transition` (optional): How the screen animates in and out. (More on this in [Transition System (GetPageRouteTransitionMixin, CustomTransition, Transitions)](07_transition_system__getpageroutetransitionmixin__customtransition__transitions__.md)).
*   `middlewares` (optional): Special functions that can run before a page is shown, perhaps to check if a user is logged in. (Covered in [GetMiddleware](06_getmiddleware_.md)).

Let's define a couple of simple `GetPage` blueprints:

```dart
// main.dart (or a separate routes file)
import 'package:flutter/material.dart';
import 'package:get/get.dart'; // Import GetX

// Assume HomeScreen and ProfileScreen widgets are defined elsewhere
// For example:
// class HomeScreen extends StatelessWidget { /* ... */ }
// class ProfileScreen extends StatelessWidget { /* ... */ }

final List<GetPage> appPages = [
  GetPage(
    name: '/home', // The unique name for the home screen
    page: () => HomeScreen(), // How to build the HomeScreen
  ),
  GetPage(
    name: '/profile', // The unique name for the profile screen
    page: () => ProfileScreen(), // How to build the ProfileScreen
    // transition: Transition.rightToLeft, // Optional: a nice slide animation
  ),
];
```
In this snippet, `appPages` is a list holding the blueprints for our `HomeScreen` and `ProfileScreen`. We've given each a unique `name` and a `page` function.

## Meet the Captain: `GetRouterDelegate`

If `GetPage` is the blueprint, then `GetRouterDelegate` is the **captain of your app's navigation ship**. It's the core engine that powers Flutter's modern Navigator 2.0 system within GetX.

You usually won't interact with `GetRouterDelegate` directly in simple apps. When you provide your list of `GetPage` blueprints to `GetMaterialApp` (as we'll see next), GetX sets up a `GetRouterDelegate` for you behind the scenes.

This "captain" is responsible for:
*   Taking your `GetPage` blueprints.
*   Managing the actual stack of screens (what's visible, what's underneath).
*   Deciding which page is currently visible based on the URL or navigation actions.
*   Handling how to go to new pages (`Get.toNamed()`).
*   Handling how to go back (`Get.back()`).

Think of it like an air traffic controller for your app's screens. It knows all the available "runways" (`GetPage`s) and directs the "planes" (your users' navigation actions) to the correct one smoothly.

## Putting It Together: Defining Routes in `GetMaterialApp`

Now, how do we tell our GetX app about these `GetPage` blueprints so the `GetRouterDelegate` can use them? We pass our list of `GetPage`s to the `getPages` property of `GetMaterialApp` (or `GetCupertinoApp`).

Let's update our `main.dart` from Chapter 2:

```dart
// main.dart
import 'package:flutter/material.dart';
import 'package:get/get.dart';

// Let's define our screens quickly for this example
class HomeScreen extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(title: Text('Home')),
      body: Center(
        child: ElevatedButton(
          onPressed: () => Get.toNamed('/profile'), // Navigate to profile
          child: Text('Go to Profile'),
        ),
      ),
    );
  }
}

class ProfileScreen extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(title: Text('Profile')),
      body: Center(child: Text('This is your Profile!')),
    );
  }
}

// Our GetPage blueprints
final List<GetPage> appPages = [
  GetPage(name: '/home', page: () => HomeScreen()),
  GetPage(name: '/profile', page: () => ProfileScreen()),
];

void main() {
  runApp(MyApp());
}

class MyApp extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return GetMaterialApp(
      title: 'GetX Named Routes',
      initialRoute: '/home', // Start at the home screen
      getPages: appPages,   // <-- Here's where we provide our blueprints!
    );
  }
}
```
By providing `appPages` to `GetMaterialApp`, we've done two things:
1.  Registered our `/home` and `/profile` routes.
2.  Enabled `GetMaterialApp` to use its internal `GetRouterDelegate` to manage navigation based on these named routes.

Now, `Get.toNamed('/profile')` from `HomeScreen` will correctly navigate to `ProfileScreen` because the `GetRouterDelegate` (set up by `GetMaterialApp`) knows about the `/profile` blueprint.

## How Does It Work Under the Hood?

When you use `getPages` with `GetMaterialApp`, GetX sets up a more sophisticated navigation system. Here's a simplified step-by-step:

1.  **Setup**: When `GetMaterialApp` starts, it sees you've provided `getPages`. It then creates and configures a `GetRouterDelegate` (specifically, an instance of `GetDelegate` from `lib/get_navigation/src/routes/get_router_delegate.dart`). This delegate is given your list of `GetPage` blueprints.
2.  **Navigation Trigger**: You call `Get.toNamed('/profile')`.
3.  **Delegate at Work**: The `Get.toNamed` call, in this Navigator 2.0 setup, ultimately informs the `GetRouterDelegate`.
4.  **Route Matching**: The `GetRouterDelegate` consults its list of `GetPage`s. It uses a helper, often `ParseRouteTree` (from `lib/get_navigation/src/routes/parse_route.dart`), to find the `GetPage` whose `name` matches `/profile`. We'll explore `ParseRouteTree` more in [Route Parsing & Configuration (RouteDecoder, PageSettings, ParseRouteTree)](05_route_parsing___configuration__routedecoder__pagesettings__parseroutetree__.md).
5.  **Screen Creation**: Once the matching `GetPage` blueprint is found, the `GetRouterDelegate` uses its `page: () => ProfileScreen()` function to create an instance of `ProfileScreen`.
6.  **Stack Update**: The `GetRouterDelegate` then updates Flutter's navigation stack to display this new `ProfileScreen`.

Here's a visual:

```mermaid
sequenceDiagram
    participant UserAction as User Taps Button
    participant GetToNamed as Get.toNamed("/profile")
    participant GMA as GetMaterialApp (internally)
    participant GRD as GetRouterDelegate
    participant FlutterNav as Flutter Navigator

    UserAction->>GetToNamed: Invokes navigation for "/profile"
    GetToNamed->>GMA: Signals intent (simplified)
    GMA->>GRD: Relays "/profile" to its delegate
    GRD->>GRD: Finds GetPage(name: "/profile") in its list (getPages)
    GRD->>GRD: Calls page() function from GetPage
    GRD->>FlutterNav: "Push this new screen (ProfileScreen)"
    FlutterNav->>UserAction: ProfileScreen is displayed
```

Inside `GetMaterialApp` (or more accurately, `GetMaterialApp.router` which is used when `getPages` is provided), it sets up like this:

```dart
// Simplified concept from GetMaterialApp when getPages is used
// return GetMaterialApp.router(
//   routeInformationParser: GetInformationParser(...), // Handles URL parsing
//   routerDelegate: GetDelegate(pages: getPages, ...), // Our captain!
// );
```
The `GetDelegate` (our `GetRouterDelegate` implementation) receives your `pages` (your `GetPage` list).

Then, `GetDelegate`'s `build` method uses these pages to construct the `Navigator`:

```dart
// Simplified from lib/get_navigation/src/routes/get_router_delegate.dart
// Inside GetDelegate's build method:

// final currentHistory = currentConfiguration;
// final pages = /* ... logic to get current visible GetPage(s) based on URL ... */
//    getVisualPages(currentHistory).toList();

// return GetNavigator(
//   key: navigatorKey,
//   onPopPage: _onPopVisualRoute, // Handles back button for these pages
//   pages: pages, // The actual Flutter Page objects derived from your GetPages
//   // ... other navigator configurations
// );
```
The `pages` list here are Flutter `Page` objects, which `GetDelegate` creates based on your `GetPage` definitions and the current navigation state.

So, by using `GetPage` and `getPages`, you're tapping into this powerful, Navigator 2.0-based routing managed by `GetRouterDelegate`.

## Why This Approach?

*   **Centralized Route Definitions**: All your main navigation paths are clearly defined in one place.
*   **Named Navigation Power**: Makes `Get.toNamed()` very robust.
*   **Decoupling**: Your UI code just says "go to `/profile`"; it doesn't need to know *how* `ProfileScreen` is built or what its specific dependencies are.
*   **Advanced Scenarios**: This structure is the foundation for more complex features like:
    *   Nested navigation (routes within routes).
    *   Guards/Middlewares (e.g., checking login status before accessing a route, covered in [GetMiddleware](06_getmiddleware_.md)).
    *   Custom transitions per route (see [Transition System (GetPageRouteTransitionMixin, CustomTransition, Transitions)](07_transition_system__getpageroutetransitionmixin__customtransition__transitions__.md)).
    *   Better web URL handling.

## Conclusion

You've now learned about `GetPage`, the blueprint for your screens, and `GetRouterDelegate`, the captain that manages navigation using these blueprints. By defining your routes using `GetPage` and providing them to `GetMaterialApp` via the `getPages` property, you unlock a more structured, powerful, and maintainable way to handle navigation in your GetX applications. This setup is what allows GetX to seamlessly integrate with Flutter's Navigator 2.0 system, giving you fine-grained control while keeping things simple.

While `GetRouterDelegate` works largely behind the scenes for many common use cases, understanding its role helps you appreciate the robustness of GetX navigation.

Next up, we'll explore how GetX makes it incredibly easy to show common UI overlays like Snackbars, Dialogs, and BottomSheets, often without needing `BuildContext` at all! Let's head to [Overlay Management (Snackbar, Dialog, BottomSheet)](04_overlay_management__snackbar__dialog__bottomsheet__.md).
---
# Chapter 4: Overlay Management (Snackbar, Dialog, BottomSheet)

Welcome back! In [Chapter 3: GetPage & GetRouterDelegate](03_getpage___getrouterdelegate__.md), we learned how to structure our app's navigation with named routes using `GetPage`. Now, let's explore another incredibly handy feature of GetX: managing temporary UI elements like snackbars, dialogs, and bottom sheets, all without needing to pass `BuildContext` around!

## What are Overlays? The Hotel Concierge Analogy

Imagine you're staying in a fancy hotel (your app). You're comfortably in your room (your current screen). Sometimes, you need quick services or information without having to leave your room or go to a completely new part of the hotel. This is where the hotel concierge comes in handy!

In GetX, overlay management is like having a super-efficient concierge service for your app. You can request:
*   A **quick note delivered to you** (a **Snackbar**): A brief message that appears temporarily, usually at the top or bottom of the screen, to give you a quick update (e.g., "Message sent!").
*   To **arrange a private meeting in a temporary room** (a **Dialog**): A pop-up window that requires your attention before you can continue interacting with your current screen. Useful for alerts, confirmations, or quick forms.
*   To **pull up a special information panel from below** (a **BottomSheet**): A panel that slides up from the bottom of the screen, offering more detailed options or information related to the current context.

These are all "overlays"—UI elements that appear *on top* of your current page without completely replacing it. GetX makes showing these incredibly simple.

## GetX's Superpower: Context-less Overlays

As we saw in [Chapter 2: GetNavigation Extensions (e.g., Get.toNamed, Get.snackbar)](02_getnavigation_extensions__e_g___get_tonamed__get_snackbar__.md), one of GetX's main advantages is allowing you to trigger navigation and UI elements from anywhere in your code, often without needing `BuildContext`. This is especially true for overlays!

Thanks to the setup with `GetMaterialApp` (covered in [Chapter 1: GetMaterialApp / GetCupertinoApp & GetRoot](01_getmaterialapp___getcupertinoapp___getroot_.md)), GetX has access to the necessary "hooks" to display these overlays globally.

Let's see how to use our "concierge" (`Get`) to request these services.

### 1. Quick Notes: `Get.snackbar()`

Need to show a user a quick, non-intrusive message? `Get.snackbar()` is your friend. It's like asking the concierge to slip a small note under your door.

```dart
// In any button's onPressed, or anywhere in your logic:
ElevatedButton(
  onPressed: () {
    Get.snackbar(
      "Notification", // Title of the snackbar
      "Your profile was updated successfully!", // Message
      snackPosition: SnackPosition.BOTTOM, // Where it appears
      backgroundColor: Colors.green,
      colorText: Colors.white,
    );
  },
  child: Text('Update Profile & Show Snackbar'),
)
```
**What happens?**
Tapping this button will display a green snackbar at the bottom of the screen with the title "Notification" and your message. It will automatically dismiss after a few seconds.

**Behind the Scenes (Briefly):**
GetX uses a `SnackbarController` to manage these requests. If you call `Get.snackbar()` multiple times quickly, `SnackbarController` acts like the concierge's assistant, queuing up the notes and delivering them one by one, so they don't all appear at once and clutter the screen.

### 2. Private Meetings: `Get.dialog()`

Sometimes you need to grab the user's full attention for an important choice or piece of information. This is like asking the concierge to book a small, private meeting room (a Dialog). The user must interact with the dialog (e.g., press "OK" or "Cancel") before returning to their main room (screen).

```dart
// In any button's onPressed:
ElevatedButton(
  onPressed: () {
    Get.dialog(
      AlertDialog(
        title: Text('Confirm Action'),
        content: Text('Are you sure you want to delete this item?'),
        actions: [
          TextButton(onPressed: () => Get.back(), child: Text('Cancel')),
          TextButton(onPressed: () { /* delete logic */ Get.back(); }, child: Text('Delete')),
        ],
      ),
    );
  },
  child: Text('Delete Item (Show Dialog)'),
)
```
**What happens?**
Tapping this button will display a standard Material Design alert dialog in the middle of the screen. The background will be dimmed, and the user must tap "Cancel" or "Delete" to close the dialog. `Get.back()` is used here to close the dialog.

### 3. Special Info Panels: `Get.bottomSheet()`

For presenting a list of options or a bit more information without being as intrusive as a full dialog, a bottom sheet is perfect. It's like the concierge pulling up a neat information panel from a compartment below your desk.

```dart
// In any button's onPressed:
ElevatedButton(
  onPressed: () {
    Get.bottomSheet(
      Container(
        height: 200,
        color: Colors.blueGrey,
        child: Column(
          mainAxisAlignment: MainAxisAlignment.center,
          children: [
            ListTile(leading: Icon(Icons.share, color: Colors.white), title: Text('Share', style: TextStyle(color: Colors.white)), onTap: () => Get.back()),
            ListTile(leading: Icon(Icons.copy, color: Colors.white), title: Text('Copy Link', style: TextStyle(color: Colors.white)), onTap: () => Get.back()),
          ],
        ),
      ),
      // Optional: make it non-dismissible by dragging
      // isDismissible: false, 
    );
  },
  child: Text('Show Options (BottomSheet)'),
)
```
**What happens?**
Tapping this button will cause a panel to slide up from the bottom of the screen. This panel contains our "Share" and "Copy Link" options. Tapping an option (or outside the sheet, if dismissible) will close it. `Get.back()` closes the bottom sheet here.

## How Does GetX Handle These Requests? (Under the Hood)

You might wonder how `Get.snackbar()`, `Get.dialog()`, and `Get.bottomSheet()` can work without you explicitly giving them a `BuildContext`.

**The Magic of `GetMaterialApp` and `Get.overlayContext`**
As we learned in [Chapter 1: GetMaterialApp / GetCupertinoApp & GetRoot](01_getmaterialapp___getcupertinoapp___getroot_.md), using `GetMaterialApp` sets up the GetX framework. Crucially, `GetMaterialApp` (via `GetRoot`) holds a global key for Flutter's `Overlay`. The `Overlay` is like a special layer in your app where you can draw things on top of everything else. GetX exposes access to this overlay's context via `Get.overlayContext`.

```dart
// lib/get_navigation/src/extension_navigation.dart (simplified concept)
BuildContext? get overlayContext {
  // ... logic to get the context of the root overlay ...
  // This 'key' is managed by GetRootState (from GetMaterialApp)
  key.currentState?.overlay?.context.visitChildElements((element) {
    // ... find the overlay context ...
  });
  return /* the found overlay context */;
}
```
This `Get.overlayContext` is the "magic wand" GetX uses to show snackbars, dialogs, and bottom sheets from anywhere.

### Snackbars: The `SnackbarController` at Your Service

When you call `Get.snackbar(...)`, it's more than just displaying a widget.
1.  `Get.snackbar()` (in `extension_navigation.dart`) creates a `GetSnackBar` widget configured with your title, message, colors, etc.
2.  It then hands this `GetSnackBar` widget to a `SnackbarController` (from `lib/get_navigation/src/snackbar/snackbar_controller.dart`).
3.  The `SnackbarController` is responsible for:
    *   Managing a queue (`SnackBarQueue`). If multiple snackbars are requested, they are shown one after another.
    *   Creating `OverlayEntry` objects (Flutter's way of putting something on the `Overlay`).
    *   Handling animations (showing and hiding the snackbar).
    *   Managing the duration and dismissal of the snackbar.

```mermaid
sequenceDiagram
    participant YourCode as Your Widget/Logic
    participant GetSnackbarCall as Get.snackbar()
    participant SnackbarCtrl as SnackbarController
    participant Overlay as Flutter OverlayState

    YourCode->>GetSnackbarCall: Calls Get.snackbar("Title", "Message")
    GetSnackbarCall->>SnackbarCtrl: Creates GetSnackBar widget & passes to new SnackbarController
    SnackbarCtrl->>SnackbarCtrl: Adds itself to SnackBarQueue
    SnackbarCtrl->>Overlay: When its turn, creates OverlayEntry & inserts into Overlay
    Overlay->>YourCode: Snackbar is displayed
    SnackbarCtrl->>Overlay: Later, removes OverlayEntry (on dismiss/timeout)
```

Here's a highly simplified glimpse of `Get.snackbar()` in `lib/get_navigation/src/extension_navigation.dart`:
```dart
// Simplified from extension_navigation.dart
SnackbarController snackbar(String title, String message, {/*...other params...*/}) {
  final getSnackBar = GetSnackBar( // Creates the snackbar widget
    title: title,
    message: message,
    // ... many other properties ...
  );

  // Creates a controller for this specific snackbar instance
  final controller = SnackbarController(getSnackBar); 
  
  // Shows it (adds to queue, handles display via Overlay)
  if (instantInit) { 
    controller.show();
  } else {
    // ... schedule to show after current frame ...
  }
  return controller;
}
```
And `SnackbarController` (in `lib/get_navigation/src/snackbar/snackbar_controller.dart`) uses the `Get.overlayContext` to interact with Flutter's `Overlay`:
```dart
// Simplified concept from SnackbarController.dart
class SnackbarController {
  final GetSnackBar snackbar; // The widget to display
  // ... animation controllers, etc. ...

  Future<void> show() {
    // Adds this snackbar job to a queue
    return GetRootState.controller.config.snackBarQueue.addJob(this);
  }

  Future<void> _show() { // Called by the queue
    // Gets Flutter's OverlayState using Get.overlayContext
    _overlayState = Overlay.of(Get.overlayContext!); 
    // Creates OverlayEntry(s) to display the snackbar
    _overlayEntries.addAll(_createOverlayEntries(snackbar));
    _overlayState!.insertAll(_overlayEntries); // Shows it!
    // ... handles animations and timers ...
    return _transitionCompleter.future;
  }
  // ... methods to close, manage status ...
}
```
The `SnackbarController` is quite sophisticated, managing animations, dismissals, and even a queue. This ensures your snackbars behave politely.

### Dialogs and BottomSheets: Custom Popup Routes

Dialogs and BottomSheets are a bit different. They are typically "modal," meaning they block interaction with the underlying screen content. In Flutter, these are often implemented using `PopupRoute`. GetX provides its own custom `PopupRoute` implementations:
*   `GetDialogRoute` (from `lib/get_navigation/src/dialog/dialog_route.dart`)
*   `GetModalBottomSheetRoute` (from `lib/get_navigation/src/bottomsheet/bottomsheet.dart`)

When you call `Get.dialog()` or `Get.bottomSheet()`:
1.  The `Get` extension method (in `extension_navigation.dart`) takes your widget and parameters.
2.  It then uses `Navigator.of(Get.overlayContext!).push(...)` to push either a `GetDialogRoute` (for dialogs) or a `GetModalBottomSheetRoute` (for bottom sheets) onto the navigator's stack.

Here's a glimpse into `Get.dialog()` from `lib/get_navigation/src/extension_navigation.dart`:
```dart
// Simplified from extension_navigation.dart
Future<T?> dialog<T>(Widget widget, {/* ... params ... */}) {
  // ... theme setup ...
  return generalDialog<T>( // Calls a more generic dialog method
    pageBuilder: (buildContext, animation, secondaryAnimation) {
      // ... wraps widget with Theme, SafeArea etc. ...
      return widget; 
    },
    // ... other parameters like barrierDismissible, barrierColor ...
  );
}

Future<T?> generalDialog<T>({ required RoutePageBuilder pageBuilder, /*...*/}) {
  // Accesses the navigator via Get.overlayContext (or a specific key)
  final nav = /* ... Navigator.of(overlayContext!, rootNavigator: true) ... */;
  
  // Pushes GetX's custom dialog route
  return nav.push<T>( 
    GetDialogRoute<T>(
      pageBuilder: pageBuilder,
      // ... passes other parameters ...
    ),
  );
}
```
And for `Get.bottomSheet()`:
```dart
// Simplified from extension_navigation.dart
Future<T?> bottomSheet<T>(Widget bottomsheet, {/* ... params ... */}) {
  // Uses the Navigator from Get.overlayContext
  return Navigator.of(overlayContext!, rootNavigator: useRootNavigator)
      .push(GetModalBottomSheetRoute<T>( // Pushes GetX's custom bottom sheet route
          builder: (_) => bottomsheet,
          // ... passes many other parameters for customization ...
      ));
}
```
`GetDialogRoute` and `GetModalBottomSheetRoute` are subclasses of Flutter's `PopupRoute`. They handle the specifics of how the dialog or bottom sheet appears, animates, and interacts with the modal barrier (the dimming effect behind them).

So, for dialogs and bottom sheets, GetX leverages Flutter's standard navigation mechanism for `PopupRoute`s but makes them accessible via the simple `Get.dialog()` and `Get.bottomSheet()` calls, using `Get.overlayContext` to find the correct `Navigator`.

## Conclusion

You've just learned how GetX simplifies showing common temporary UI elements—Snackbars, Dialogs, and BottomSheets—much like a hotel concierge assisting with quick notes, private meetings, or information panels.

The key takeaways are:
*   GetX provides easy, context-less APIs like `Get.snackbar()`, `Get.dialog()`, and `Get.bottomSheet()`.
*   `SnackbarController` manages the lifecycle and queue of snackbars efficiently.
*   Dialogs and BottomSheets are presented using custom `PopupRoute` implementations (`GetDialogRoute`, `GetModalBottomSheetRoute`) that GetX makes easy to invoke.
*   All this is possible because `GetMaterialApp` (via `GetRoot`) sets up the necessary global access to Flutter's `Overlay` and `Navigator`.

With these tools, you can create a more interactive and communicative user experience with minimal boilerplate code.

In the next chapter, we'll delve into how GetX understands the named routes you define with `GetPage` and how it handles parameters in those routes. Get ready for [Route Parsing & Configuration (RouteDecoder, PageSettings, ParseRouteTree)](05_route_parsing___configuration__routedecoder__pagesettings__parseroutetree__.md)!
---
# Chapter 5: Route Parsing & Configuration (RouteDecoder, PageSettings, ParseRouteTree)

Welcome back! In [Chapter 4: Overlay Management (Snackbar, Dialog, BottomSheet)](04_overlay_management__snackbar__dialog__bottomsheet__.md), we explored how GetX simplifies showing UI overlays. Now, let's uncover the magic behind how GetX understands the addresses (routes) you navigate to, especially when they include dynamic parts like user IDs or query parameters.

## The App's Address System: Why Do We Need This?

Imagine your app is like a big city, and each screen is a building with a specific address. Sometimes, these addresses are simple, like `/home`. But often, they're more complex, like `/users/123` (showing user with ID 123) or `/products?category=electronics&sort=price` (showing electronic products sorted by price).

How does your app:
1.  Know which screen corresponds to `/users/123`?
2.  Extract the ID `123` so the screen can fetch the correct user data?
3.  Understand that `category=electronics` and `sort=price` are special instructions for the products screen?

This is where GetX's route parsing and configuration system comes in. It's like your app's combined **address book and highly intelligent postal service**.

*   **`ParseRouteTree`**: Think of this as the **master address book**. It holds a structured list of all possible "addresses" (routes) your app knows, including how they might be nested.
*   **`PageSettings`**: This is like an **individual envelope** for a specific navigation request. It contains the destination address, and importantly, any special data like user IDs (path parameters) or filtering options (query parameters).
*   **`RouteDecoder`**: This is the clever **postal worker**. When you say "go to `/users/123?mode=edit`", the `RouteDecoder` looks up this address in the `ParseRouteTree`, figures out it's for a user screen, extracts the ID `123` and the `mode=edit` instruction, and prepares the `PageSettings` "envelope" so the correct screen can be delivered with the right information.

Let's see how these components work together.

## Defining Routes with Parameters

In [Chapter 3: GetPage & GetRouterDelegate](03_getpage___getrouterdelegate__.md), we learned about `GetPage` for defining named routes. We can make these routes dynamic.

Suppose we want a screen to display user profiles. The route might look like `/users/:id`, where `:id` is a placeholder for the user's actual ID.

First, let's define this in our `GetMaterialApp`'s `getPages`:

```dart
// main.dart (or your routes file)
List<GetPage> appPages = [
  GetPage(name: '/', page: () => HomeScreen()),
  GetPage(
    name: '/users/:id', // The :id part is a path parameter
    page: () => UserProfileScreen(),
  ),
  // ... other pages
];
```
Here, `/users/:id` tells GetX that any route starting with `/users/` followed by some value should be handled by `UserProfileScreen`. That value will be available as the `id` parameter.

## Accessing Parameters in Your Screen

Now, when we navigate to, say, `/users/123`, how does `UserProfileScreen` get this `123`? GetX makes it easy with `Get.parameters`.

```dart
// user_profile_screen.dart
import 'package:flutter/material.dart';
import 'package:get/get.dart';

class UserProfileScreen extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    // Accessing the 'id' path parameter
    final String? userId = Get.parameters['id'];

    // Accessing a query parameter, e.g., if URL was /users/123?mode=view
    final String? mode = Get.parameters['mode'];

    return Scaffold(
      appBar: AppBar(title: Text('User Profile: $userId')),
      body: Center(
        child: Text('Displaying profile for user ID: $userId. Mode: $mode'),
      ),
    );
  }
}
```
If we navigate using `Get.toNamed('/users/456?mode=edit')`:
*   `Get.parameters['id']` would give you `"456"`.
*   `Get.parameters['mode']` would give you `"edit"`.

Simple, right? `Get.parameters` is a map containing all parsed path and query parameters.

## How It Works: The Journey of a Route

Let's trace what happens when you call `Get.toNamed('/users/123?mode=edit')`.

1.  **The Request**: Your code calls `Get.toNamed('/users/123?mode=edit')`.
2.  **Delegate Receives**: This request goes to the `GetRouterDelegate` (our app's navigation captain, from [Chapter 3: GetPage & GetRouterDelegate](03_getpage___getrouterdelegate__.md)).
3.  **Consulting the Address Book (`ParseRouteTree`)**:
    *   The `GetRouterDelegate` has an instance of `ParseRouteTree`. This tree was built when your app started, using the `getPages` list you provided to `GetMaterialApp`.
    *   The delegate asks `ParseRouteTree` to `matchRoute('/users/123?mode=edit')`.
4.  **Finding the Match & Preparing the Envelope (`PageSettings`)**:
    *   `ParseRouteTree` searches through its known `GetPage` definitions. It finds that `/users/:id` matches the path `/users/123`.
    *   It an instance of `PageSettings`. This object holds the original URI and is used to store parsed parameters.
    *   `ParseRouteTree` extracts `123` as the value for the path parameter `id`.
    *   It also parses the query part `?mode=edit` and extracts `mode` with the value `edit`.
    *   These parameters (`id: '123'`, `mode: 'edit'`) are stored within the `PageSettings` object.
5.  **The Postal Worker (`RouteDecoder`)**:
    *   `ParseRouteTree` then creates a `RouteDecoder` object. This `RouteDecoder` bundles:
        *   The matched `GetPage` (the blueprint for `UserProfileScreen`).
        *   The `PageSettings` object containing all the extracted parameters and arguments.
6.  **Delivery**:
    *   The `GetRouterDelegate` receives this `RouteDecoder`. It now knows exactly which screen to show (`UserProfileScreen` via its `GetPage`) and what data (`PageSettings` with `id` and `mode`) to make available to that screen.
    *   The `UserProfileScreen` is built. When it accesses `Get.parameters`, it's actually reading from the `PageSettings` associated with its current route instance (managed by `RouteDecoder`).

Here's a simplified visual of this lookup:

```mermaid
sequenceDiagram
    participant UserAction as User calls Get.toNamed
    participant GRD as GetRouterDelegate
    participant PRT as ParseRouteTree (The Address Book)
    participant PS as PageSettings (The Envelope)
    participant RD as RouteDecoder (The Postal Worker)

    UserAction->>GRD: Get.toNamed("/users/123?mode=edit")
    GRD->>PRT:  matchRoute("/users/123?mode=edit")
    PRT->>PRT: Finds GetPage(name: "/users/:id")
    PRT->>PS: Creates PageSettings, populates with id='123', mode='edit'
    PRT->>RD: Creates RouteDecoder(matched GetPage, PageSettings instance)
    RD-->>GRD: Returns populated RouteDecoder
    GRD->>UserAction: UserProfileScreen is displayed (can access params via Get.parameters)
```

## A Peek Inside the Code

Let's look at simplified versions of these key classes. You don't usually interact with them directly, but understanding their roles is insightful.

### `PageSettings` - The Envelope
(Found in `lib/get_navigation/src/routes/page_settings.dart`)

This class holds information about a specific instance of a route.

```dart
// Simplified concept of PageSettings
class PageSettings extends RouteSettings {
  PageSettings(this.uri, [Object? arguments])
      : super(name: '$uri', arguments: arguments);

  final Uri uri; // The full URI, e.g., /users/123?mode=edit
  final params = <String, String>{}; // Parsed path & query params

  // Helper to get just the path part, e.g., /users/123
  String get path => uri.path;
  // Helper for query params, e.g., {mode: edit}
  Map<String, String> get query => uri.queryParameters;
}
```
When a route is parsed, an instance of `PageSettings` is created, and its `params` map is filled with both path parameters (like `:id`) and query parameters (like `mode=edit`). The full `Uri` and any passed `arguments` are also stored.

### `ParseRouteTree` - The Address Book Builder
(Found in `lib/get_navigation/src/routes/parse_route.dart`)

This class takes all your `GetPage` definitions and builds an efficient way to look them up.

```dart
// Simplified concept of ParseRouteTree
class ParseRouteTree {
  final List<GetPage> routes; // All GetPages from GetMaterialApp.getPages

  ParseRouteTree({required this.routes});

  RouteDecoder matchRoute(String name, {PageSettings? arguments}) {
    final Uri uri = Uri.parse(name); // e.g., /users/123?mode=edit
    GetPage? matchedPage;
    Map<String, String> extractedParams = {};

    // 1. Find matching GetPage
    for (final GetPage routeDefinition in routes) {
      // routeDefinition.path.regex is a pre-compiled regex for the route's path
      // e.g., for '/users/:id', regex matches '/users/ANYTHING'
      final match = routeDefinition.path.regex.firstMatch(uri.path);
      if (match != null) {
        matchedPage = routeDefinition;
        // 2. Extract path parameters (e.g., :id)
        // routeDefinition.path.keys would be ['id']
        for (var i = 0; i < routeDefinition.path.keys.length; i++) {
          extractedParams[routeDefinition.path.keys[i]!] = match[i + 1]!;
        }
        break;
      }
    }

    // 3. Add query parameters
    extractedParams.addAll(uri.queryParameters);

    // 4. Populate PageSettings
    final settings = arguments ?? PageSettings(uri);
    settings.params.clear();
    settings.params.addAll(extractedParams);

    // 5. Create RouteDecoder
    return RouteDecoder(
      matchedPage != null ? [matchedPage] : [], // List of GetPages in hierarchy
      settings,
    );
  }
  // ... other methods to add/remove routes ...
}
```
When `matchRoute` is called:
1.  It iterates through your list of `GetPage`s.
2.  For each `GetPage`, it uses a pre-compiled regular expression (`route.path.regex`) from the `GetPage`'s `name` to see if the current URL path matches. The `PathDecoded` object (part of `GetPage`) handles the conversion of `name` like `/users/:id` into a regex and identifies parameter keys like `id`.
3.  If a match is found, it extracts path parameters.
4.  It then adds any query parameters from the URL.
5.  This information is used to populate a `PageSettings` object.
6.  Finally, it returns a `RouteDecoder` containing the matched `GetPage`(s) and the populated `PageSettings`.

### `RouteDecoder` - The Postal Worker with the Decoded Address
(Found in `lib/get_navigation/src/routes/parse_route.dart`)

This class holds the result of parsing a route: the `GetPage`(s) that should be displayed and their `PageSettings`.

```dart
// Simplified concept of RouteDecoder
class RouteDecoder {
  // currentTreeBranch can hold multiple GetPages for nested routes.
  // For a simple route, it's usually just one GetPage.
  final List<GetPage> currentTreeBranch;
  final PageSettings? pageSettings; // The "envelope" with params & args

  RouteDecoder(this.currentTreeBranch, this.pageSettings);

  // The actual GetPage to be displayed (often the last in the branch)
  GetPage? get route =>
      currentTreeBranch.isEmpty ? null : currentTreeBranch.last;

  // Parameters are conveniently accessible from PageSettings
  Map<String, String> get parameters => pageSettings?.params ?? {};
}
```
The `GetRouterDelegate` uses the `route` (the `GetPage`) from `RouteDecoder` to know which widget to build, and the `pageSettings` to make arguments and parameters available to that widget, typically via `Get.arguments` and `Get.parameters`.

When you use `Get.parameters` in your widget, GetX is essentially looking up the current `RouteDecoder` for your active route and accessing `routeDecoder.pageSettings.params`.

## The Big Picture with `GetRouterDelegate`

The `GetRouterDelegate` (specifically `GetDelegate` in GetX's code, see `lib/get_navigation/src/routes/get_router_delegate.dart`) orchestrates this. It holds the `ParseRouteTree`:

```dart
// Inside GetDelegate (simplified)
class GetDelegate extends RouterDelegate<RouteDecoder> {
  final _routeTree = ParseRouteTree(routes: []); // Initialized with your GetPages

  // ... when navigation occurs ...
  RouteDecoder? _getRouteDecoder<T>(PageSettings arguments) {
    // ...
    final decoder = _routeTree.matchRoute(pageUriString, arguments: arguments);
    // ... further configure decoder (like setting arguments) ...
    return decoder;
  }

  @override
  Future<void> setNewRoutePath(RouteDecoder configuration) async {
    // This is called by Flutter's navigation system when the URL changes
    // or when we programmatically navigate.
    // 'configuration' here is often the result of `_getRouteDecoder`.
    _push(configuration); // _push adds to active pages stack and rebuilds UI
    notifyListeners();
  }
  // ... more logic for building the Navigator widget stack ...
}
```
The `GetDelegate` uses its `_routeTree.matchRoute()` method (which internally uses `ParseRouteTree`) to get a `RouteDecoder`. This `RouteDecoder` then informs the delegate which `GetPage`(s) to render and what `PageSettings` (arguments and parameters) are associated with it.

## Conclusion

You've now seen how GetX acts like a sophisticated address book and postal service for your app's routes!
*   `ParseRouteTree` builds and maintains the "address book" from your `GetPage` definitions.
*   `PageSettings` acts as the "envelope," carrying specific details for a navigation request, including parsed path and query parameters.
*   `RouteDecoder` is the "postal worker" that uses the address book to understand an incoming route string, prepare the envelope, and identify the correct screen blueprint.

This system allows GetX to robustly handle complex URLs, extract parameters, and deliver them to your screens effortlessly, all while you primarily just define your `GetPage`s and use `Get.toNamed()` and `Get.parameters`.

Next up, we'll explore a powerful feature that lets you intercept navigation: [GetMiddleware](06_getmiddleware_.md). Imagine them as security checkpoints or toll booths before you can access certain routes!
---
# Chapter 6: GetMiddleware

Welcome back! In [Chapter 5: Route Parsing & Configuration (RouteDecoder, PageSettings, ParseRouteTree)](05_route_parsing___configuration__routedecoder__pagesettings__parseroutetree__.md), we learned how GetX deciphers route names and handles parameters. Now, let's introduce a powerful concept: **GetMiddleware**. These are like checkpoints or gatekeepers for your routes, allowing you to run logic *before* a page is even shown.

## The Problem: Guarding Your Routes

Imagine you have a user profile page `/profile` in your app. You only want authenticated (logged-in) users to access this page. If a guest tries to navigate to `/profile`, they should be redirected to the `/login` page instead. How do you enforce this rule cleanly?

This is where `GetMiddleware` comes in! It lets you intercept navigation requests and decide what happens next.

## What is GetMiddleware? Your Route's Receptionist!

A `GetMiddleware` is a class you create that intercepts navigation to specific routes. Think of them as a security guard or a receptionist at the entrance of different offices (your pages) in a building (your app).

*   **Security Guard:** They might check if you have an ID (are you logged in?). If not, they might send you to the main reception (login page).
*   **Receptionist:** They might ask for your appointment details and, based on them, give you a specific visitor pass (modify page properties) or set up a meeting room for you (initialize bindings for the page).

A `GetMiddleware` can:
1.  **Redirect:** Send the user to a different page (e.g., redirect to `/login` if not authenticated).
2.  **Modify Page Properties:** Change aspects of the page that's about to be loaded (more advanced).
3.  **Setup Bindings:** Initialize specific controllers or services for the upcoming page (more advanced).

For this beginner-friendly chapter, we'll focus on the most common use case: **redirecting users.**

## Creating Your First Middleware: The AuthGuard

Let's create a middleware, `AuthMiddleware`, to protect our `/profile` route.

1.  Create a new Dart file, say `auth_middleware.dart`.
2.  Define your class extending `GetMiddleware`:

```dart
// auth_middleware.dart
import 'package:get/get.dart';

class AuthMiddleware extends GetMiddleware {
  // A simple flag to simulate login state.
  // In a real app, you'd get this from a service, e.g., Get.find<AuthService>().isLoggedIn.
  final bool isLoggedIn = false; // Let's assume the user is NOT logged in for this example.
}
```
Our `AuthMiddleware` currently just has a flag `isLoggedIn`. Now, we need to tell it what to do.

### The `redirectDelegate` Method

The most important method for our use case is `redirectDelegate`. GetX calls this method when a route associated with this middleware is about to be accessed. It receives the current `RouteDecoder` (the details of the route being navigated to) and can decide what `RouteDecoder` (if any) should be processed next.

Let's implement it:

```dart
// auth_middleware.dart (continued)
import 'package:get/get.dart';

class AuthMiddleware extends GetMiddleware {
  final bool isLoggedIn = false; // Assume user is NOT logged in.

  @override
  FutureOr<RouteDecoder?> redirectDelegate(RouteDecoder route) {
    // Check if the user is NOT logged in
    // AND they are NOT trying to go to the login page already
    if (!isLoggedIn && route.pageSettings?.name != '/login') {
      print("AuthMiddleware: User not logged in. Redirecting to /login.");
      // If not logged in, redirect to the '/login' page.
      // We get the RouteDecoder for '/login' from GetX's delegate.
      return Get.delegate.matchRoute('/login');
    }
    // If logged in, or already going to /login, proceed as normal.
    return super.redirectDelegate(route); // This passes the original route through.
  }
}
```
**Explanation:**
*   `redirectDelegate(RouteDecoder route)`: This function is given the `route` that the user is trying to access.
*   `if (!isLoggedIn && route.pageSettings?.name != '/login')`: We check two things:
    *   Is the user `isLoggedIn`? (Here, it's `false`).
    *   Is the route they're trying to access (`route.pageSettings?.name`) something *other* than `/login`? We don't want to redirect them away from `/login` if they're already trying to get there!
*   `return Get.delegate.matchRoute('/login');`: If both conditions are true (not logged in and not going to login), we tell GetX to redirect. We use `Get.delegate.matchRoute('/login')` to create a `RouteDecoder` that points to our `/login` route. This is the new destination.
*   `return super.redirectDelegate(route);`: If the user *is* logged in, or if they are already navigating to `/login`, we let them proceed to their original destination by returning the original `route` (the `super` call effectively does this).

> **Note:** `super.redirectDelegate(route)` simply returns the `route` it was given. You could also just `return route;`. If you return `null`, the navigation will be stopped entirely.

## Applying the Middleware to a `GetPage`

Now that we have our `AuthMiddleware`, we need to tell GetX to use it for specific routes. We do this in the `getPages` list within our `GetMaterialApp`.

Let's assume you have `GetPage` definitions for `/home`, `/login`, and `/profile`:

```dart
// main.dart
import 'package:flutter/material.dart';
import 'package:get/get.dart';
import 'auth_middleware.dart'; // Import your middleware

// Simple placeholder screens
class HomeScreen extends StatelessWidget {
  @override Widget build(BuildContext context) => Scaffold(appBar: AppBar(title: Text('Home')), body: Center(child: ElevatedButton(onPressed: () => Get.toNamed('/profile'), child: Text('Go to Profile'))));
}
class LoginScreen extends StatelessWidget {
  @override Widget build(BuildContext context) => Scaffold(appBar: AppBar(title: Text('Login')), body: Center(child: Text('Please Log In')));
}
class ProfileScreen extends StatelessWidget {
  @override Widget build(BuildContext context) => Scaffold(appBar: AppBar(title: Text('Profile')), body: Center(child: Text('Welcome to your Profile!')));
}

void main() {
  runApp(MyApp());
}

class MyApp extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return GetMaterialApp(
      initialRoute: '/home',
      getPages: [
        GetPage(name: '/home', page: () => HomeScreen()),
        GetPage(name: '/login', page: () => LoginScreen()),
        GetPage(
          name: '/profile',
          page: () => ProfileScreen(),
          middlewares: [ // <-- Apply our AuthMiddleware here!
            AuthMiddleware(),
          ],
        ),
      ],
    );
  }
}
```
In the `GetPage` for `/profile`, we added a `middlewares` list and put an instance of our `AuthMiddleware()` in it.

## Seeing it in Action!

Now, let's trace what happens:

1.  **App Starts:** You land on `/home`.
2.  **Navigate to Profile:** You click the "Go to Profile" button, which calls `Get.toNamed('/profile')`.
3.  **Middleware Intercepts:**
    *   GetX sees that the `/profile` route has `AuthMiddleware` attached.
    *   It calls `AuthMiddleware.redirectDelegate()` with the `RouteDecoder` for `/profile`.
    *   Inside our middleware:
        *   `isLoggedIn` is `false`.
        *   `route.pageSettings?.name` is `/profile` (which is not `/login`).
        *   The condition `!isLoggedIn && route.pageSettings?.name != '/login'` is TRUE.
        *   The middleware returns `Get.delegate.matchRoute('/login')`.
4.  **Redirection Occurs:** GetX now discards the original navigation to `/profile` and instead navigates to `/login`.
5.  **Result:** You see the `LoginScreen`!

If you were to change `isLoggedIn = true;` in your `AuthMiddleware` and rerun:
1.  Navigate to `/profile`.
2.  Middleware runs: `isLoggedIn` is `true`.
3.  The condition `!isLoggedIn && ...` is FALSE.
4.  The middleware returns `super.redirectDelegate(route)` (meaning, "proceed to `/profile`").
5.  **Result:** You see the `ProfileScreen`!

## How It Works Under the Hood

Let's briefly look at what GetX is doing.

1.  **Navigation Request:** You call `Get.toNamed('/profile')`.
2.  **Delegate Processing:** This request reaches the `GetRouterDelegate` (as seen in [Chapter 3: GetPage & GetRouterDelegate](03_getpage___getrouterdelegate__.md)).
3.  **Route Matching:** The delegate uses `ParseRouteTree` to find the `GetPage` associated with `/profile`.
4.  **Middleware Check:** The delegate sees that this `GetPage` has a list of `middlewares`.
5.  **Executing Middlewares:** The `GetRouterDelegate` (specifically in its `runMiddleware` method) iterates through these middlewares (sorted by priority, which we'll discuss soon). For each middleware, it calls its `redirectDelegate` method, passing the current `RouteDecoder`.

```mermaid
sequenceDiagram
    participant User as User Action
    participant GetToNamed as Get.toNamed("/profile")
    participant GRD as GetRouterDelegate
    participant AuthMW as AuthMiddleware
    participant TargetPage as ProfileScreen / LoginScreen

    User->>GetToNamed: Tries to go to /profile
    GetToNamed->>GRD: Informs delegate of intent
    GRD->>GRD: Finds GetPage for /profile, sees AuthMiddleware
    GRD->>AuthMW: Calls authMiddleware.redirectDelegate(profileRouteDecoder)
    alt User NOT Logged In
        AuthMW->>GRD: Returns loginRouteDecoder
        GRD->>TargetPage: Navigates to LoginScreen
    else User Logged In
        AuthMW->>GRD: Returns profileRouteDecoder (original)
        GRD->>TargetPage: Navigates to ProfileScreen
    end
```

Here's a peek at the relevant parts (simplified):

**`GetPage` (from `lib/get_navigation/src/routes/get_route.dart`):**
It has a property to hold middlewares.
```dart
class GetPage<T> extends Page<T> {
  // ... other properties ...
  final List<GetMiddleware> middlewares;

  GetPage({
    // ...
    this.middlewares = const [],
    // ...
  });
}
```

**`GetMiddleware` (from `lib/get_navigation/src/routes/route_middleware.dart`):**
This is the base class you extend.
```dart
abstract class GetMiddleware {
  // ... priority and other methods ...

  FutureOr<RouteDecoder?> redirectDelegate(RouteDecoder route) => (route);
  // Default implementation passes the original route through.
  // Returning null stops navigation.
  // Returning a different RouteDecoder redirects.
}
```

**`GetDelegate.runMiddleware()` (conceptual, from `lib/get_navigation/src/routes/get_router_delegate.dart`):**
This method in `GetDelegate` is responsible for executing the middlewares.
```dart
// Simplified concept from GetDelegate
Future<RouteDecoder?> runMiddleware(RouteDecoder currentRouteDecoder) async {
  final middlewares = currentRouteDecoder.route!.middlewares; // Get middlewares from GetPage
  if (middlewares.isEmpty) return currentRouteDecoder;

  var nextRouteDecoder = currentRouteDecoder;
  for (final middleware in middlewares) { // Loop (respecting priority)
    final resultFromMiddleware = await middleware.redirectDelegate(nextRouteDecoder);

    if (resultFromMiddleware == null) { // Middleware says stop
      return null;
    }
    nextRouteDecoder = resultFromMiddleware; // Update to what middleware returned
    // If middleware redirected (nextRouteDecoder != original input to it),
    // GetX might break and re-run middlewares FOR THE NEW ROUTE.
    if (/* current 'nextRouteDecoder' is actually a new different route */) {
       // Potentially re-run middleware chain for the *new* nextRouteDecoder
       return await runMiddleware(nextRouteDecoder);
    }
  }
  return nextRouteDecoder; // Final decision after all middlewares
}
```
This shows that `GetDelegate` actively calls your middleware's `redirectDelegate` and acts upon its result.

## Other Middleware Capabilities (A Quick Look)

While `redirectDelegate` is key for routing logic, `GetMiddleware` offers more:

*   `priority` (int): If you have multiple middlewares on a single `GetPage`, `priority` determines their execution order. Lower numbers run first. Default is `0`.
    ```dart
    class LoggerMiddleware extends GetMiddleware {
      @override
      int get priority => -1; // Run this before AuthMiddleware if both are on same route

      @override
      FutureOr<RouteDecoder?> redirectDelegate(RouteDecoder route) {
        print("Logger: Navigating to ${route.pageSettings?.name}");
        return route; // Just log and proceed
      }
    }

    // In GetPage: middlewares: [AuthMiddleware(), LoggerMiddleware()]
    // LoggerMiddleware (priority -1) runs before AuthMiddleware (priority 0).
    ```

*   `onPageCalled(GetPage? page)`: Called after redirection logic but before bindings. You can modify the `GetPage` instance here (e.g., change its title).
*   `onBindingsStart(List<BindingsInterface>? bindings)`: Called before bindings are initialized. You could add or remove bindings.
*   `onPageBuildStart(GetPageBuilder? page)`: Called before the `page()` builder of `GetPage` is executed.
*   `onPageBuilt(Widget page)`: Called after the page widget is built.
*   `onPageDispose()`: Called when the page and its bindings are disposed.

For most common scenarios like authentication, `redirectDelegate` and `priority` are what you'll use most often.

## Conclusion

You've learned about `GetMiddleware`, your powerful tool for guarding routes and executing logic before pages are displayed. By implementing the `redirectDelegate` method, you can easily control navigation flow, such as redirecting unauthenticated users to a login screen. Adding these middlewares to your `GetPage` definitions integrates them seamlessly into GetX's routing system.

This opens up possibilities for creating more secure and dynamic applications.

Next, we'll explore how GetX handles the visual flair of navigation: the [Transition System (GetPageRouteTransitionMixin, CustomTransition, Transitions)](07_transition_system__getpageroutetransitionmixin__customtransition__transitions__.md)!

Relevant Code Snippets (Code itself remains unchanged):
--- File: lib/get_navigation/src/routes/default_transitions.dart ---
import 'package:flutter/cupertino.dart';
import 'package:flutter/material.dart';

import 'circular_reveal_clipper.dart';

class LeftToRightFadeTransition {
  Widget buildTransitions(
      BuildContext context,
      Curve? curve,
      Alignment? alignment,
      Animation<double> animation,
      Animation<double> secondaryAnimation,
      Widget child) {
    return SlideTransition(
      position: Tween<Offset>(
        begin: const Offset(-1.0, 0.0),
        end: Offset.zero,
      ).animate(animation),
      child: FadeTransition(
        opacity: animation,
        child: SlideTransition(
            position: Tween<Offset>(
              begin: Offset.zero,
              end: const Offset(1.0, 0.0),
            ).animate(secondaryAnimation),
            child: child),
      ),
    );
  }
}

class RightToLeftFadeTransition {
  Widget buildTransitions(
      BuildContext context,
      Curve? curve,
      Alignment? alignment,
      Animation<double> animation,
      Animation<double> secondaryAnimation,
      Widget child) {
    return SlideTransition(
      position: Tween<Offset>(
        begin: const Offset(1.0, 0.0),
        end: Offset.zero,
      ).animate(animation),
      child: FadeTransition(
        opacity: animation,
        child: SlideTransition(
            position: Tween<Offset>(
              begin: Offset.zero,
              end: const Offset(-1.0, 0.0),
            ).animate(secondaryAnimation),
            child: child),
      ),
    );
  }
}

class NoTransition {
  Widget buildTransitions(
      BuildContext context,
      Curve curve,
      Alignment alignment,
      Animation<double> animation,
      Animation<double> secondaryAnimation,
      Widget child) {
    return child;
  }
}

class FadeInTransition {
  Widget buildTransitions(
      BuildContext context,
      Curve? curve,
      Alignment? alignment,
      Animation<double> animation,
      Animation<double> secondaryAnimation,
      Widget child) {
    return FadeTransition(opacity: animation, child: child);
  }
}

class SlideDownTransition {
  Widget buildTransitions(
      BuildContext context,
      Curve? curve,
      Alignment? alignment,
      Animation<double> animation,
      Animation<double> secondaryAnimation,
      Widget child) {
    return SlideTransition(
      position: Tween<Offset>(
        begin: const Offset(0.0, 1.0),
        end: Offset.zero,
      ).animate(animation),
      child: child,
    );
  }
}

class SlideLeftTransition {
  Widget buildTransitions(
      BuildContext context,
      Curve? curve,
      Alignment? alignment,
      Animation<double> animation,
      Animation<double> secondaryAnimation,
      Widget child) {
    return SlideTransition(
      position: Tween<Offset>(
        begin: const Offset(-1.0, 0.0),
        end: Offset.zero,
      ).animate(animation),
      child: child,
    );
  }
}

class SlideRightTransition {
  Widget buildTransitions(
      BuildContext context,
      Curve? curve,
      Alignment? alignment,
      Animation<double> animation,
      Animation<double> secondaryAnimation,
      Widget child) {
    return SlideTransition(
      position: Tween<Offset>(
        begin: const Offset(1.0, 0.0),
        end: Offset.zero,
      ).animate(animation),
      child: child,
    );
  }
}

class SlideTopTransition {
  Widget buildTransitions(
      BuildContext context,
      Curve? curve,
      Alignment? alignment,
      Animation<double> animation,
      Animation<double> secondaryAnimation,
      Widget child) {
    return SlideTransition(
      position: Tween<Offset>(
        begin: const Offset(0.0, -1.0),
        end: Offset.zero,
      ).animate(animation),
      child: child,
    );
  }
}

class ZoomInTransition {
  Widget buildTransitions(
      BuildContext context,
      Curve? curve,
      Alignment? alignment,
      Animation<double> animation,
      Animation<double> secondaryAnimation,
      Widget child) {
    return ScaleTransition(
      scale: animation,
      child: child,
    );
  }
}

class SizeTransitions {
  Widget buildTransitions(
      BuildContext context,
      Curve curve,
      Alignment? alignment,
      Animation<double> animation,
      Animation<double> secondaryAnimation,
      Widget child) {
    return Align(
      alignment: Alignment.center,
      child: SizeTransition(
        sizeFactor: CurvedAnimation(
          parent: animation,
          curve: curve,
        ),
        child: child,
      ),
    );
  }
}

class CircularRevealTransition {
  Widget buildTransitions(
      BuildContext context,
      Curve? curve,
      Alignment? alignment,
      Animation<double> animation,
      Animation<double> secondaryAnimation,
      Widget child) {
    return ClipPath(
      clipper: CircularRevealClipper(
        fraction: animation.value,
        centerAlignment: Alignment.center,
        centerOffset: Offset.zero,
        minRadius: 0,
        maxRadius: 800,
      ),
      child: child,
    );
  }
}


--- File: lib/get_navigation/src/routes/get_transition_mixin.dart ---
import 'dart:math';
import 'dart:ui';

import 'package:flutter/cupertino.dart';
import 'package:flutter/foundation.dart';
import 'package:flutter/gestures.dart';
import 'package:flutter/material.dart';

import '../../../get.dart';
import '../root/get_root.dart';

const double _kBackGestureWidth = 20.0;

const double _kMinFlingVelocity = 1; // Screen widths per second.

// An eyeballed value for the maximum time it takes for a page to animate
// forward if the user releases a page mid swipe.
const int _kMaxMidSwipePageForwardAnimationTime = 800; // Milliseconds.

// The maximum time for a page to get reset to it's original position if the
// user releases a page mid swipe.
const int _kMaxPageBackAnimationTime = 300; // Milliseconds.

class GetBackGestureDetector<T> extends StatefulWidget {
  const GetBackGestureDetector({
    super.key,
    required this.limitedSwipe,
    required this.gestureWidth,
    required this.initialOffset,
    required this.popGestureEnable,
    required this.onStartPopGesture,
    required this.child,
  });

  final bool limitedSwipe;
  final double gestureWidth;
  final double initialOffset;

  final Widget child;
  final ValueGetter<bool> popGestureEnable;
  final ValueGetter<GetBackGestureController<T>> onStartPopGesture;

  @override
  GetBackGestureDetectorState<T> createState() =>
      GetBackGestureDetectorState<T>();
}

class GetBackGestureDetectorState<T> extends State<GetBackGestureDetector<T>> {
  GetBackGestureController<T>? _backGestureController;

  void _handleDragStart(DragStartDetails details) {
    assert(mounted);
    assert(_backGestureController == null);
    _backGestureController = widget.onStartPopGesture();
  }

  void _handleDragUpdate(DragUpdateDetails details) {
    assert(mounted);
    assert(_backGestureController != null);
    _backGestureController!.dragUpdate(
      _convertToLogical(details.primaryDelta! / context.size!.width),
    );
  }

  void _handleDragEnd(DragEndDetails details) {
    assert(mounted);
    assert(_backGestureController != null);
    _backGestureController!.dragEnd(_convertToLogical(
      details.velocity.pixelsPerSecond.dx / context.size!.width,
    ));
    _backGestureController = null;
  }

  void _handleDragCancel() {
    assert(mounted);
    // This can be called even if start is not called, paired with the "down"
    // event that we don't consider here.
    _backGestureController?.dragEnd(0);
    _backGestureController = null;
  }

  double _convertToLogical(double value) {
    switch (Directionality.of(context)) {
      case TextDirection.rtl:
        return -value;
      case TextDirection.ltr:
        return value;
    }
  }

  @override
  Widget build(BuildContext context) {
    assert(debugCheckHasDirectionality(context));

    final gestureDetector = RawGestureDetector(
      behavior: HitTestBehavior.translucent,
      gestures: {
        _DirectionalityDragGestureRecognizer:
            GestureRecognizerFactoryWithHandlers<
                _DirectionalityDragGestureRecognizer>(
          () {
            final directionality = Directionality.of(context);
            return _DirectionalityDragGestureRecognizer(
              debugOwner: this,
              isRTL: directionality == TextDirection.rtl,
              isLTR: directionality == TextDirection.ltr,
              hasbackGestureController: () => _backGestureController != null,
              popGestureEnable: widget.popGestureEnable,
            );
          },
          (directionalityDragGesture) => directionalityDragGesture
            ..onStart = _handleDragStart
            ..onUpdate = _handleDragUpdate
            ..onEnd = _handleDragEnd
            ..onCancel = _handleDragCancel,
        )
      },
    );

    return Stack(
      fit: StackFit.passthrough,
      children: [
        widget.child,
        if (widget.limitedSwipe)
          PositionedDirectional(
            start: widget.initialOffset,
            width: _dragAreaWidth(context),
            top: 0,
            bottom: 0,
            child: gestureDetector,
          )
        else
          Positioned.fill(child: gestureDetector),
      ],
    );
  }

  double _dragAreaWidth(BuildContext context) {
    // For devices with notches, the drag area needs to be larger on the side
    // that has the notch.
    final dragAreaWidth = Directionality.of(context) == TextDirection.ltr
        ? context.mediaQuery.padding.left
        : context.mediaQuery.padding.right;
    return max(dragAreaWidth, widget.gestureWidth);
  }
}

class GetBackGestureController<T> {
  GetBackGestureController({
    required this.navigator,
    required this.controller,
  }) {
    navigator.didStartUserGesture();
  }

  final AnimationController controller;
  final NavigatorState navigator;

  /// The drag gesture has changed by [delta]. The total range of the
  /// drag should be 0.0 to 1.0.
  void dragUpdate(double delta) {
    controller.value -= delta;
  }

  /// The drag gesture has ended with a horizontal motion of [velocity] as a
  /// fraction of screen width per second.
  void dragEnd(double velocity) {
    // Fling in the appropriate direction.
    // AnimationController.fling is guaranteed to
    // take at least one frame.
    //
    // This curve has been determined through rigorously eyeballing native iOS
    // animations.
    const Curve animationCurve = Curves.fastLinearToSlowEaseIn;
    final bool animateForward;

    // If the user releases the page before mid screen with sufficient velocity,
    // or after mid screen, we should animate the page out. Otherwise, the page
    // should be animated back in.
    if (velocity.abs() >= _kMinFlingVelocity) {
      animateForward = velocity <= 0;
    } else {
      animateForward = controller.value > 0.5;
    }

    if (animateForward) {
      // The closer the panel is to dismissing, the shorter the animation is.
      // We want to cap the animation time, but we want to use a linear curve
      // to determine it.
      final droppedPageForwardAnimationTime = min(
        lerpDouble(_kMaxMidSwipePageForwardAnimationTime, 0, controller.value)!
            .floor(),
        _kMaxPageBackAnimationTime,
      );
      controller.animateTo(1.0,
          duration: Duration(milliseconds: droppedPageForwardAnimationTime),
          curve: animationCurve);
    } else {
      // This route is destined to pop at this point. Reuse navigator's pop.
      Get.back();

      // The popping may have finished inline if already at the
      // target destination.
      if (controller.isAnimating) {
        // Otherwise, use a custom popping animation duration and curve.
        final droppedPageBackAnimationTime = lerpDouble(
                0, _kMaxMidSwipePageForwardAnimationTime, controller.value)!
            .floor();
        controller.animateBack(0.0,
            duration: Duration(milliseconds: droppedPageBackAnimationTime),
            curve: animationCurve);
      }
    }

    if (controller.isAnimating) {
      // Keep the userGestureInProgress in true state so we don't change the
      // curve of the page transition mid-flight since CupertinoPageTransition
      // depends on userGestureInProgress.
      late AnimationStatusListener animationStatusCallback;
      animationStatusCallback = (status) {
        navigator.didStopUserGesture();
        controller.removeStatusListener(animationStatusCallback);
      };
      controller.addStatusListener(animationStatusCallback);
    } else {
      navigator.didStopUserGesture();
    }
  }
}

mixin GetPageRouteTransitionMixin<T> on PageRoute<T> {
  ValueNotifier<String?>? _previousTitle;

  @override
  Color? get barrierColor => null;

  @override
  String? get barrierLabel => null;

  double Function(BuildContext context)? get gestureWidth;

  /// True if an iOS-style back swipe pop gesture is currently
  /// underway for this route.
  ///
  /// See also:
  ///
  ///  * [isPopGestureInProgress], which returns true if a Cupertino pop gesture
  ///    is currently underway for specific route.
  ///  * [popGestureEnabled], which returns true if a user-triggered pop gesture
  ///    would be allowed.
  //bool get popGestureInProgress => isPopGestureInProgress(this);

  /// The title string of the previous [CupertinoPageRoute].
  ///
  /// The [ValueListenable]'s value is readable after the route is installed
  /// onto a [Navigator]. The [ValueListenable] will also notify its listeners
  /// if the value changes (such as by replacing the previous route).
  ///
  /// The [ValueListenable] itself will be null before the route is installed.
  /// Its content value will be null if the previous route has no title or
  /// is not a [CupertinoPageRoute].
  ///
  /// See also:
  ///
  ///  * [ValueListenableBuilder], which can be used to listen and rebuild
  ///    widgets based on a ValueListenable.
  ValueListenable<String?> get previousTitle {
    assert(
      _previousTitle != null,
      '''
Cannot read the previousTitle for a route that has not yet been installed''',
    );
    return _previousTitle!;
  }

  bool get showCupertinoParallax;

  /// {@template flutter.cupertino.CupertinoRouteTransitionMixin.title}
  /// A title string for this route.
  ///
  /// Used to auto-populate [CupertinoNavigationBar] and
  /// [CupertinoSliverNavigationBar]'s `middle`/`largeTitle` widgets when
  /// one is not manually supplied.
  /// {@endtemplate}
  String? get title;

  @override
  // A relatively rigorous eyeball estimation.
  Duration get transitionDuration;

  @override
  Duration get reverseTransitionDuration;

  /// Builds the primary contents of the route.
  @protected
  Widget buildContent(BuildContext context);

  @override
  Widget buildPage(BuildContext context, Animation<double> animation,
      Animation<double> secondaryAnimation) {
    final child = buildContent(context);
    final Widget result = Semantics(
      scopesRoute: true,
      explicitChildNodes: true,
      child: child,
    );
    return result;
  }

  @override
  Widget buildTransitions(BuildContext context, Animation<double> animation,
      Animation<double> secondaryAnimation, Widget child) {
    return buildPageTransitions<T>(
        this, context, animation, secondaryAnimation, child);
  }

  @override
  bool canTransitionTo(TransitionRoute<dynamic> nextRoute) {
    // Don't perform outgoing animation if the next route is a
    // fullscreen dialog.
    return (nextRoute is GetPageRouteTransitionMixin &&
            !nextRoute.fullscreenDialog &&
            nextRoute.showCupertinoParallax) ||
        (nextRoute is CupertinoRouteTransitionMixin &&
            !nextRoute.fullscreenDialog) ||
        (nextRoute is CupertinoSheetRoute &&
            !nextRoute.fullscreenDialog);
  }

  @override
  void didChangePrevious(Route<dynamic>? previousRoute) {
    final previousTitleString = previousRoute is CupertinoRouteTransitionMixin
        ? previousRoute.title
        : null;
    if (_previousTitle == null) {
      _previousTitle = ValueNotifier<String?>(previousTitleString);
    } else {
      _previousTitle!.value = previousTitleString;
    }
    super.didChangePrevious(previousRoute);
  }

  static bool canSwipe(GetPageRoute route) =>
      route.popGesture ?? Get.defaultPopGesture ?? GetPlatform.isIOS;

  /// Returns a [CupertinoFullscreenDialogTransition] if [route] is a full
  /// screen dialog, otherwise a [CupertinoPageTransition] is returned.
  ///
  /// Used by [CupertinoPageRoute.buildTransitions].
  ///
  /// This method can be applied to any [PageRoute], not just
  /// [CupertinoPageRoute]. It's typically used to provide a Cupertino style
  /// horizontal transition for material widgets when the target platform
  /// is [TargetPlatform.iOS].
  ///
  /// See also:
  ///
  ///  * [CupertinoPageTransitionsBuilder], which uses this method to define a
  ///    [PageTransitionsBuilder] for the [PageTransitionsTheme].
  static Widget buildPageTransitions<T>(
    PageRoute<T> rawRoute,
    BuildContext context,
    Animation<double> animation,
    Animation<double> secondaryAnimation,
    Widget child, {
    bool limitedSwipe = false,
    double initialOffset = 0,
  }) {
    // Check if the route has an animation that's currently participating
    // in a back swipe gesture.
    //
    // In the middle of a back gesture drag, let the transition be linear to
    // match finger motions.
    final route = rawRoute as GetPageRoute<T>;
    final linearTransition = route.popGestureInProgress;
    final finalCurve = route.curve ?? Get.defaultTransitionCurve;
    final hasCurve = route.curve != null;
    if (route.fullscreenDialog && route.transition == null) {
      return CupertinoFullscreenDialogTransition(
        primaryRouteAnimation: hasCurve
            ? CurvedAnimation(parent: animation, curve: finalCurve)
            : animation,
        secondaryRouteAnimation: secondaryAnimation,
        linearTransition: linearTransition,
        child: child,
      );
    } else {
      if (route.customTransition != null) {
        return route.customTransition!.buildTransition(
          context,
          finalCurve,
          route.alignment,
          animation,
          secondaryAnimation,
          GetBackGestureDetector<T>(
            popGestureEnable: () =>
                _isPopGestureEnabled(route, canSwipe(route), context),
            onStartPopGesture: () {
              assert(_isPopGestureEnabled(route, canSwipe(route), context));
              return _startPopGesture(route);
            },
            limitedSwipe: limitedSwipe,
            gestureWidth:
                route.gestureWidth?.call(context) ?? _kBackGestureWidth,
            initialOffset: initialOffset,
            child: child,
          ),
        );
      }

      /// Apply the curve by default...
      final iosAnimation = animation;
      animation = CurvedAnimation(parent: animation, curve: finalCurve);

      switch (route.transition ?? Get.defaultTransition) {
        case Transition.leftToRight:
          return SlideLeftTransition().buildTransitions(
              context,
              route.curve,
              route.alignment,
              animation,
              secondaryAnimation,
              GetBackGestureDetector<T>(
                popGestureEnable: () =>
                    _isPopGestureEnabled(route, canSwipe(route), context),
                onStartPopGesture: () {
                  assert(_isPopGestureEnabled(route, canSwipe(route), context));
                  return _startPopGesture(route);
                },
                limitedSwipe: limitedSwipe,
                gestureWidth:
                    route.gestureWidth?.call(context) ?? _kBackGestureWidth,
                initialOffset: initialOffset,
                child: child,
              ));

        case Transition.downToUp:
          return SlideDownTransition().buildTransitions(
              context,
              route.curve,
              route.alignment,
              animation,
              secondaryAnimation,
              GetBackGestureDetector<T>(
                popGestureEnable: () =>
                    _isPopGestureEnabled(route, canSwipe(route), context),
                onStartPopGesture: () {
                  assert(_isPopGestureEnabled(route, canSwipe(route), context));
                  return _startPopGesture(route);
                },
                limitedSwipe: limitedSwipe,
                gestureWidth:
                    route.gestureWidth?.call(context) ?? _kBackGestureWidth,
                initialOffset: initialOffset,
                child: child,
              ));

        case Transition.upToDown:
          return SlideTopTransition().buildTransitions(
              context,
              route.curve,
              route.alignment,
              animation,
              secondaryAnimation,
              GetBackGestureDetector<T>(
                popGestureEnable: () =>
                    _isPopGestureEnabled(route, canSwipe(route), context),
                onStartPopGesture: () {
                  assert(_isPopGestureEnabled(route, canSwipe(route), context));
                  return _startPopGesture(route);
                },
                limitedSwipe: limitedSwipe,
                gestureWidth:
                    route.gestureWidth?.call(context) ?? _kBackGestureWidth,
                initialOffset: initialOffset,
                child: child,
              ));

        case Transition.noTransition:
          return GetBackGestureDetector<T>(
            popGestureEnable: () =>
                _isPopGestureEnabled(route, canSwipe(route), context),
            onStartPopGesture: () {
              assert(_isPopGestureEnabled(route, canSwipe(route), context));
              return _startPopGesture(route);
            },
            limitedSwipe: limitedSwipe,
            gestureWidth:
                route.gestureWidth?.call(context) ?? _kBackGestureWidth,
            initialOffset: initialOffset,
            child: child,
          );

        case Transition.rightToLeft:
          return SlideRightTransition().buildTransitions(
              context,
              route.curve,
              route.alignment,
              animation,
              secondaryAnimation,
              GetBackGestureDetector<T>(
                popGestureEnable: () =>
                    _isPopGestureEnabled(route, canSwipe(route), context),
                onStartPopGesture: () {
                  assert(_isPopGestureEnabled(route, canSwipe(route), context));
                  return _startPopGesture(route);
                },
                limitedSwipe: limitedSwipe,
                gestureWidth:
                    route.gestureWidth?.call(context) ?? _kBackGestureWidth,
                initialOffset: initialOffset,
                child: child,
              ));

        case Transition.zoom:
          return ZoomInTransition().buildTransitions(
              context,
              route.curve,
              route.alignment,
              animation,
              secondaryAnimation,
              GetBackGestureDetector<T>(
                popGestureEnable: () =>
                    _isPopGestureEnabled(route, canSwipe(route), context),
                onStartPopGesture: () {
                  assert(_isPopGestureEnabled(route, canSwipe(route), context));
                  return _startPopGesture(route);
                },
                limitedSwipe: limitedSwipe,
                gestureWidth:
                    route.gestureWidth?.call(context) ?? _kBackGestureWidth,
                initialOffset: initialOffset,
                child: child,
              ));

        case Transition.fadeIn:
          return FadeInTransition().buildTransitions(
              context,
              route.curve,
              route.alignment,
              animation,
              secondaryAnimation,
              GetBackGestureDetector<T>(
                popGestureEnable: () =>
                    _isPopGestureEnabled(route, canSwipe(route), context),
                onStartPopGesture: () {
                  assert(_isPopGestureEnabled(route, canSwipe(route), context));
                  return _startPopGesture(route);
                },
                limitedSwipe: limitedSwipe,
                gestureWidth:
                    route.gestureWidth?.call(context) ?? _kBackGestureWidth,
                initialOffset: initialOffset,
                child: child,
              ));

        case Transition.rightToLeftWithFade:
          return RightToLeftFadeTransition().buildTransitions(
              context,
              route.curve,
              route.alignment,
              animation,
              secondaryAnimation,
              GetBackGestureDetector<T>(
                popGestureEnable: () =>
                    _isPopGestureEnabled(route, canSwipe(route), context),
                onStartPopGesture: () {
                  assert(_isPopGestureEnabled(route, canSwipe(route), context));
                  return _startPopGesture(route);
                },
                limitedSwipe: limitedSwipe,
                gestureWidth:
                    route.gestureWidth?.call(context) ?? _kBackGestureWidth,
                initialOffset: initialOffset,
                child: child,
              ));

        case Transition.leftToRightWithFade:
          return LeftToRightFadeTransition().buildTransitions(
              context,
              route.curve,
              route.alignment,
              animation,
              secondaryAnimation,
              GetBackGestureDetector<T>(
                popGestureEnable: () =>
                    _isPopGestureEnabled(route, canSwipe(route), context),
                onStartPopGesture: () {
                  assert(_isPopGestureEnabled(route, canSwipe(route), context));
                  return _startPopGesture(route);
                },
                limitedSwipe: limitedSwipe,
                gestureWidth:
                    route.gestureWidth?.call(context) ?? _kBackGestureWidth,
                initialOffset: initialOffset,
                child: child,
              ));

        case Transition.cupertino:
          return CupertinoPageTransition(
              primaryRouteAnimation: animation,
              secondaryRouteAnimation: secondaryAnimation,
              linearTransition: linearTransition,
              child: GetBackGestureDetector<T>(
                popGestureEnable: () =>
                    _isPopGestureEnabled(route, canSwipe(route), context),
                onStartPopGesture: () {
                  assert(_isPopGestureEnabled(route, canSwipe(route), context));
                  return _startPopGesture(route);
                },
                limitedSwipe: limitedSwipe,
                gestureWidth:
                    route.gestureWidth?.call(context) ?? _kBackGestureWidth,
                initialOffset: initialOffset,
                child: child,
              ));

        case Transition.size:
          return SizeTransitions().buildTransitions(
              context,
              route.curve!,
              route.alignment,
              animation,
              secondaryAnimation,
              GetBackGestureDetector<T>(
                popGestureEnable: () =>
                    _isPopGestureEnabled(route, canSwipe(route), context),
                onStartPopGesture: () {
                  assert(_isPopGestureEnabled(route, canSwipe(route), context));
                  return _startPopGesture(route);
                },
                limitedSwipe: limitedSwipe,
                gestureWidth:
                    route.gestureWidth?.call(context) ?? _kBackGestureWidth,
                initialOffset: initialOffset,
                child: child,
              ));

        case Transition.fade:
          return const FadeUpwardsPageTransitionsBuilder().buildTransitions(
              route,
              context,
              animation,
              secondaryAnimation,
              GetBackGestureDetector<T>(
                popGestureEnable: () =>
                    _isPopGestureEnabled(route, canSwipe(route), context),
                onStartPopGesture: () {
                  assert(_isPopGestureEnabled(route, canSwipe(route), context));
                  return _startPopGesture(route);
                },
                limitedSwipe: limitedSwipe,
                gestureWidth:
                    route.gestureWidth?.call(context) ?? _kBackGestureWidth,
                initialOffset: initialOffset,
                child: child,
              ));

        case Transition.topLevel:
          return const ZoomPageTransitionsBuilder().buildTransitions(
              route,
              context,
              animation,
              secondaryAnimation,
              GetBackGestureDetector<T>(
                popGestureEnable: () =>
                    _isPopGestureEnabled(route, canSwipe(route), context),
                onStartPopGesture: () {
                  assert(_isPopGestureEnabled(route, canSwipe(route), context));
                  return _startPopGesture(route);
                },
                limitedSwipe: limitedSwipe,
                gestureWidth:
                    route.gestureWidth?.call(context) ?? _kBackGestureWidth,
                initialOffset: initialOffset,
                child: child,
              ));

        case Transition.native:
          return const PageTransitionsTheme().buildTransitions(
              route,
              context,
              iosAnimation,
              secondaryAnimation,
              GetBackGestureDetector<T>(
                popGestureEnable: () =>
                    _isPopGestureEnabled(route, canSwipe(route), context),
                onStartPopGesture: () {
                  assert(_isPopGestureEnabled(route, canSwipe(route), context));
                  return _startPopGesture(route);
                },
                limitedSwipe: limitedSwipe,
                gestureWidth:
                    route.gestureWidth?.call(context) ?? _kBackGestureWidth,
                initialOffset: initialOffset,
                child: child,
              ));

        case Transition.circularReveal:
          return CircularRevealTransition().buildTransitions(
              context,
              route.curve,
              route.alignment,
              animation,
              secondaryAnimation,
              GetBackGestureDetector<T>(
                popGestureEnable: () =>
                    _isPopGestureEnabled(route, canSwipe(route), context),
                onStartPopGesture: () {
                  assert(_isPopGestureEnabled(route, canSwipe(route), context));
                  return _startPopGesture(route);
                },
                limitedSwipe: limitedSwipe,
                gestureWidth:
                    route.gestureWidth?.call(context) ?? _kBackGestureWidth,
                initialOffset: initialOffset,
                child: child,
              ));

        default:
          final customTransition = GetRoot.of(context).config.customTransition;

          if (customTransition != null) {
            return customTransition.buildTransition(context, route.curve,
                route.alignment, animation, secondaryAnimation, child);
          }

          PageTransitionsTheme pageTransitionsTheme =
              Theme.of(context).pageTransitionsTheme;

          return pageTransitionsTheme.buildTransitions(
              route,
              context,
              iosAnimation,
              secondaryAnimation,
              GetBackGestureDetector<T>(
                popGestureEnable: () =>
                    _isPopGestureEnabled(route, canSwipe(route), context),
                onStartPopGesture: () {
                  assert(
                    _isPopGestureEnabled(route, canSwipe(route), context),
                  );
                  return _startPopGesture(route);
                },
                limitedSwipe: limitedSwipe,
                gestureWidth:
                    route.gestureWidth?.call(context) ?? _kBackGestureWidth,
                initialOffset: initialOffset,
                child: child,
              ));
      }
    }
  }

  // Called by GetBackGestureDetector when a pop ("back") drag start
  // gesture is detected. The returned controller handles all of the subsequent
  // drag events.
  /// True if an iOS-style back swipe pop gesture is currently
  /// underway for [route].
  ///
  /// This just check the route's [NavigatorState.userGestureInProgress].
  ///
  /// See also:
  ///
  ///  * [popGestureEnabled], which returns true if a user-triggered pop gesture
  ///    would be allowed.
  static bool isPopGestureInProgress(BuildContext context) {
    final route = ModalRoute.of(context)!;
    return route.navigator!.userGestureInProgress;
  }

  static bool _isPopGestureEnabled<T>(
      PageRoute<T> route, bool canSwipe, BuildContext context) {
    // If there's nothing to go back to, then obviously we don't support
    // the back gesture.
    if (route.isFirst) return false;
    // If the route wouldn't actually pop if we popped it, then the gesture
    // would be really confusing (or would skip internal routes),
    // so disallow it.
    if (route.willHandlePopInternally) return false;
    // support [PopScope]
    if (route.popDisposition == RoutePopDisposition.doNotPop) return false;
    // Fullscreen dialogs aren't dismissible by back swipe.
    if (route.fullscreenDialog) return false;
    // If we're in an animation already, we cannot be manually swiped.
    if (route.animation!.status != AnimationStatus.completed) return false;
    // If we're being popped into, we also cannot be swiped until the pop above
    // it completes. This translates to our secondary animation being
    // dismissed.
    if (route.secondaryAnimation!.status != AnimationStatus.dismissed) {
      return false;
    }
    // If we're in a gesture already, we cannot start another.
    if (GetPageRouteTransitionMixin.isPopGestureInProgress(context)) {
      return false;
    }

    // Don't perfome swipe if canSwipe be false
    if (!canSwipe) return false;

    // Looks like a back gesture would be welcome!
    return true;
  }

  static GetBackGestureController<T> _startPopGesture<T>(
    PageRoute<T> route,
  ) {
    return GetBackGestureController<T>(
      navigator: route.navigator!,
      controller: route.controller!, // protected access
    );
  }
}

class _DirectionalityDragGestureRecognizer
    extends HorizontalDragGestureRecognizer {
  final ValueGetter<bool> popGestureEnable;
  final ValueGetter<bool> hasbackGestureController;
  final bool isRTL;
  final bool isLTR;

  _DirectionalityDragGestureRecognizer({
    required this.isRTL,
    required this.isLTR,
    required this.popGestureEnable,
    required this.hasbackGestureController,
    super.debugOwner,
  });

  @override
  void handleEvent(PointerEvent event) {
    final dx = event.delta.dx;
    if (hasbackGestureController() ||
        popGestureEnable() && (isRTL && dx < 0 || isLTR && dx > 0 || dx == 0)) {
      super.handleEvent(event);
    } else {
      stopTrackingPointer(event.pointer);
    }
  }
}


--- File: lib/get_navigation/src/routes/transitions_type.dart ---
import 'package:flutter/widgets.dart';

import 'default_route.dart';

enum Transition {
  fade,
  fadeIn,
  rightToLeft,
  leftToRight,
  upToDown,
  downToUp,
  rightToLeftWithFade,
  leftToRightWithFade,
  zoom,
  topLevel,
  noTransition,
  cupertino,
  cupertinoDialog,
  size,
  circularReveal,
  native,
}

typedef GetPageBuilder = Widget Function();
typedef GetRouteAwarePageBuilder<T> = Widget Function([GetPageRoute<T>? route]);


--- File: lib/get_navigation/src/routes/custom_transition.dart ---
import 'package:flutter/widgets.dart';

// ignore: one_member_abstracts
abstract class CustomTransition {
  Widget buildTransition(
    BuildContext context,
    Curve? curve,
    Alignment? alignment,
    Animation<double> animation,
    Animation<double> secondaryAnimation,
    Widget child,
  );
}


--- File: lib/get_navigation/src/routes/default_route.dart ---
import 'package:flutter/cupertino.dart';

import '../../../get.dart';
import '../router_report.dart';

@optionalTypeArgs
mixin RouteReportMixin<T extends StatefulWidget> on State<T> {
  @override
  void initState() {
    super.initState();
    RouterReportManager.instance.reportCurrentRoute(this);
  }

  @override
  void dispose() {
    super.dispose();
    RouterReportManager.instance.reportRouteDispose(this);
  }
}

mixin PageRouteReportMixin<T> on Route<T> {
  @override
  void install() {
    super.install();
    RouterReportManager.instance.reportCurrentRoute(this);
  }

  @override
  void dispose() {
    super.dispose();
    RouterReportManager.instance.reportRouteDispose(this);
  }
}

class GetPageRoute<T> extends PageRoute<T>
    with GetPageRouteTransitionMixin<T>, PageRouteReportMixin {
  /// Creates a page route for use in an iOS designed app.
  ///
  /// The [builder], [maintainState], and [fullscreenDialog] arguments must not
  /// be null.
  GetPageRoute({
    super.settings,
    this.transitionDuration = const Duration(milliseconds: 300),
    this.reverseTransitionDuration = const Duration(milliseconds: 300),
    this.opaque = true,
    this.parameter,
    this.gestureWidth,
    this.curve,
    this.alignment,
    this.transition,
    this.popGesture,
    this.customTransition,
    this.barrierDismissible = false,
    this.barrierColor,
    BindingsInterface? binding,
    List<BindingsInterface> bindings = const [],
    this.binds,
    this.routeName,
    this.page,
    this.title,
    this.showCupertinoParallax = true,
    this.barrierLabel,
    this.maintainState = true,
    super.fullscreenDialog,
    this.middlewares,
  })  : bindings = (binding == null) ? bindings : [...bindings, binding],
        _middlewareRunner = MiddlewareRunner(middlewares);

  @override
  final Duration transitionDuration;
  @override
  final Duration reverseTransitionDuration;

  final GetPageBuilder? page;
  final String? routeName;
  //final String reference;
  final CustomTransition? customTransition;
  final List<BindingsInterface> bindings;
  final Map<String, String>? parameter;
  final List<Bind>? binds;

  @override
  final bool showCupertinoParallax;

  @override
  final bool opaque;
  final bool? popGesture;

  @override
  final bool barrierDismissible;
  final Transition? transition;
  final Curve? curve;
  final Alignment? alignment;
  final List<GetMiddleware>? middlewares;

  @override
  final Color? barrierColor;

  @override
  final String? barrierLabel;

  @override
  final bool maintainState;

  final MiddlewareRunner _middlewareRunner;

  @override
  void dispose() {
    super.dispose();
    _middlewareRunner.runOnPageDispose();
    _child = null;
  }

  Widget? _child;

  Widget _getChild() {
    if (_child != null) return _child!;

    final localBinds = [if (binds != null) ...binds!];

    final bindingsToBind = _middlewareRunner
        .runOnBindingsStart(bindings.isNotEmpty ? bindings : localBinds);

    final pageToBuild = _middlewareRunner.runOnPageBuildStart(page)!;

    if (bindingsToBind != null && bindingsToBind.isNotEmpty) {
      if (bindingsToBind is List<BindingsInterface>) {
        for (final item in bindingsToBind) {
          final dep = item.dependencies();
          if (dep is List<Bind>) {
            _child = Binds(
              binds: dep,
              child: _middlewareRunner.runOnPageBuilt(pageToBuild()),
            );
          }
        }
      } else if (bindingsToBind is List<Bind>) {
        _child = Binds(
          binds: bindingsToBind,
          child: _middlewareRunner.runOnPageBuilt(pageToBuild()),
        );
      }
    }

    return _child ??= _middlewareRunner.runOnPageBuilt(pageToBuild());
  }

  @override
  Widget buildContent(BuildContext context) {
    return _getChild();
  }

  @override
  final String? title;

  @override
  String get debugLabel => '${super.debugLabel}(${settings.name})';

  @override
  final double Function(BuildContext context)? gestureWidth;
}


Instructions for the chapter (Generate content in English unless specified otherwise):
- Start with a clear heading (e.g., `# Chapter 7: Transition System (GetPageRouteTransitionMixin, CustomTransition, Transitions)
`). Use the provided concept name.

- If this is not the first chapter, begin with a brief transition from the previous chapter, referencing it with a proper Markdown link using its name.

- Begin with a high-level motivation explaining what problem this abstraction solves. Start with a central use case as a concrete example. The whole chapter should guide the reader to understand how to solve this use case. Make it very minimal and friendly to beginners.

- If the abstraction is complex, break it down into key concepts. Explain each concept one-by-one in a very beginner-friendly way.

- Explain how to use this abstraction to solve the use case. Give example inputs and outputs for code snippets (if the output isn't values, describe at a high level what will happen).

- Each code block should be BELOW 10 lines! If longer code blocks are needed, break them down into smaller pieces and walk through them one-by-one. Aggresively simplify the code to make it minimal. Use comments to skip non-important implementation details. Each code block should have a beginner friendly explanation right after it.

- Describe the internal implementation to help understand what's under the hood. First provide a non-code or code-light walkthrough on what happens step-by-step when the abstraction is called. It's recommended to use a simple sequenceDiagram with a dummy example - keep it minimal with at most 5 participants to ensure clarity. If participant name has space, use: `participant QP as Query Processing`. .

- Then dive deeper into code for the internal implementation with references to files. Provide example code blocks, but make them similarly simple and beginner-friendly. Explain.

- IMPORTANT: When you need to refer to other core abstractions covered in other chapters, ALWAYS use proper Markdown links like this: [Chapter Title](filename.md). Use the Complete Tutorial Structure above to find the correct filename and the chapter title. Translate the surrounding text.

- Use mermaid diagrams to illustrate complex concepts (```mermaid``` format). .

- Heavily use analogies and examples throughout to help beginners understand.

- End the chapter with a brief conclusion that summarizes what was learned and provides a transition to the next chapter. If there is a next chapter, use a proper Markdown link: [Next Chapter Title](next_chapter_filename).

- Ensure the tone is welcoming and easy for a newcomer to understand.

- Output *only* the Markdown content for this chapter.

Now, directly provide a super beginner-friendly Markdown output (DON'T need ```markdown``` tags):

2025-05-16 11:12:19,151 - INFO - RESPONSE: # Chapter 7: Transition System (GetPageRouteTransitionMixin, CustomTransition, Transitions)

Welcome back! In [Chapter 6: GetMiddleware](06_getmiddleware_.md), we learned how to guard our routes and perform actions before a page is displayed. Now, let's add some visual flair to our app's navigation. This chapter is all about controlling how screens animate when you move from one to another.

## Lights, Camera, Animate! Why Transitions Matter

Imagine you're watching a movie. The way one scene changes to the next can greatly affect the viewing experience. A quick cut builds tension, while a slow fade can indicate a passage of time. Similarly, in an app, the way a new screen appears or an old one disappears—the **transition**—can make your app feel slick, intuitive, or just plain fun.

Think of GetX's Transition System as the **special effects director** for your app's scene changes. It dictates whether a new screen:
*   Slides in from the right (like typical Android apps)
*   Slides in from the bottom (like a modal)
*   Fades in gently
*   Zooms into view
*   Or uses a completely custom, choreographed entrance you design!

This system makes it easy to define these "special effects" for your screen changes.

## The Main Actors in GetX's Transition System

There are three main components you'll get to know:

1.  **`Transitions` (enum)**: This is a list of pre-defined, commonly used animation types that GetX provides out-of-the-box (like fade, slide, zoom). Think of it as a catalog of ready-made special effects.
2.  **`GetPageRouteTransitionMixin`**: This is the engine room! It's a core piece of GetX code (a "mixin") that provides the actual logic for performing page transitions. It handles standard Material Design and Cupertino (iOS-style) transitions, and even includes support for the "swipe-to-go-back" gesture common on iOS. You usually don't use this directly, but it powers the transitions you choose.
3.  **`CustomTransition`**: If the pre-defined `Transitions` aren't enough, GetX lets you become the special effects designer. `CustomTransition` is a class you can extend to implement your very own unique screen animations.

Let's see how to use these to direct our app's scene changes!

## Using Pre-defined Animations with `Transitions`

The easiest way to add an animation is to pick one from the `Transitions` enum and apply it to a `GetPage`.

Remember how we define our routes with `GetPage` in [Chapter 3: GetPage & GetRouterDelegate](03_getpage___getrouterdelegate__.md)? We can simply add a `transition` property there.

**Use Case:** Let's say we have a `HomeScreen` and a `DetailScreen`. We want the `DetailScreen` to zoom in when we navigate to it.

First, make sure your screens are defined:
```dart
// home_screen.dart
import 'package:flutter/material.dart';
import 'package:get/get.dart';

class HomeScreen extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(title: Text('Home')),
      body: Center(
        child: ElevatedButton(
          onPressed: () => Get.toNamed('/detail'), // Navigate to detail
          child: Text('Go to Detail (with Zoom)'),
        ),
      ),
    );
  }
}

// detail_screen.dart
class DetailScreen extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(title: Text('Detail Screen')),
      body: Center(child: Text('I zoomed in!')),
    );
  }
}
```
These are just basic screens.

Now, let's define our routes in `main.dart` and specify the transition for `/detail`:
```dart
// main.dart
import 'package:flutter/material.dart';
import 'package:get/get.dart';
import 'home_screen.dart'; // Assuming you have these files
import 'detail_screen.dart';

void main() {
  runApp(MyApp());
}

class MyApp extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return GetMaterialApp(
      initialRoute: '/home',
      getPages: [
        GetPage(name: '/home', page: () => HomeScreen()),
        GetPage(
          name: '/detail',
          page: () => DetailScreen(),
          transition: Transition.zoom, // <-- Our special effect!
        ),
      ],
    );
  }
}
```
**What happens?**
When you tap the "Go to Detail (with Zoom)" button on the `HomeScreen`, the `DetailScreen` will animate in by zooming. When you navigate back, it will zoom out. It's that simple!

The `Transitions` enum (from `lib/get_navigation/src/routes/transitions_type.dart`) offers many options:
*   `Transition.fade`
*   `Transition.fadeIn`
*   `Transition.rightToLeft`, `Transition.leftToRight` (slide animations)
*   `Transition.upToDown`, `Transition.downToUp`
*   `Transition.size`
*   `Transition.cupertino` (iOS-style slide)
*   And many more!

You can also set a default transition for your entire app in `GetMaterialApp`:
```dart
GetMaterialApp(
  defaultTransition: Transition.native, // Uses platform-native transition by default
  // ... other properties
)
```
If a `GetPage` doesn't specify its own `transition`, it will use this `defaultTransition`. If neither is set, GetX often defaults to a platform-appropriate transition.

## Creating Your Own Magic: `CustomTransition`

What if none of the pre-defined transitions fit your vision? You can create your own! This is where `CustomTransition` comes in.

`CustomTransition` is an abstract class (from `lib/get_navigation/src/routes/custom_transition.dart`). You create your own class that extends it and implement the `buildTransition` method. This method gives you all you need to build your animation:

**Use Case:** Let's create a simple custom fade-in transition that's a bit slower than the default.

1.  **Create your custom transition class:**

```dart
// my_custom_transitions.dart
import 'package:flutter/widgets.dart';
import 'package:get/get.dart'; // For CustomTransition

class MySlowFade implements CustomTransition {
  @override
  Widget buildTransition(
    BuildContext context,
    Curve? curve, // Animation curve (e.g., Curves.easeIn)
    Alignment? alignment, // For some transitions like Scale
    Animation<double> animation, // The main animation (0.0 to 1.0)
    Animation<double> secondaryAnimation, // For when this screen is pushed OFF
    Widget child, // The screen (page) being transitioned
  ) {
    // Use Flutter's FadeTransition widget
    return FadeTransition(
      opacity: CurvedAnimation(
        parent: animation,
        curve: curve ?? Curves.easeInOut, // Use provided curve or a default
      ),
      child: child,
    );
  }
}
```
**Explanation:**
*   We created `MySlowFade` extending `CustomTransition`.
*   The `buildTransition` method is where the magic happens. It's given:
    *   `animation`: This is like a progress bar for your animation, going from 0.0 (start) to 1.0 (end).
    *   `child`: This is the actual page widget you want to animate.
*   We return a `FadeTransition` widget, linking its `opacity` to our main `animation`. We also apply a `Curve` to make the fade smoother.

2.  **Use your `CustomTransition` in a `GetPage`:**

Let's say we have a `SpecialScreen` that should use this slow fade:

```dart
// special_screen.dart
class SpecialScreen extends StatelessWidget { /* ... simple screen ... */ }

// main.dart (updated getPages)
import 'my_custom_transitions.dart'; // Import your custom transition

// ... (existing GetPage definitions) ...
GetPage(
  name: '/special',
  page: () => SpecialScreen(),
  customTransition: MySlowFade(), // <-- Use your custom transition here!
  transitionDuration: Duration(milliseconds: 800), // Optional: make it slower
),
```
Now, when navigating to `/special`, it will use `MySlowFade`. We also set `transitionDuration` on the `GetPage` to make the animation take 800 milliseconds. If you don't set `transitionDuration` on `GetPage`, it will use the default.

## Under the Hood: How GetX Makes Transitions Happen

You're probably wondering how adding `transition: Transition.zoom` or `customTransition: MySlowFade()` to a `GetPage` actually works.

The star here is `GetPageRouteTransitionMixin` (from `lib/get_navigation/src/routes/get_transition_mixin.dart`). This mixin is part of `GetPageRoute` (from `lib/get_navigation/src/routes/default_route.dart`), which is the actual `Route` object GetX creates when you define a `GetPage` and navigate to it.

Here's a simplified flow:

1.  **Navigation Triggered:** You call `Get.toNamed('/detail')`.
2.  **`GetPage `Info Used:** The `GetRouterDelegate` finds the `GetPage` for `/detail`. It sees you've specified `transition: Transition.zoom`.
3.  **`GetPageRoute` Created:** The delegate creates an instance of `GetPageRoute`. This `GetPageRoute` object is created with all the info from your `GetPage`, including the chosen `transition` (or `customTransition`), `transitionDuration`, `curve`, etc.
4.  **`GetPageRouteTransitionMixin` Steps In:** `GetPageRoute` uses `GetPageRouteTransitionMixin`. This mixin has a crucial method called `buildTransitions` (or more specifically, `buildPageTransitions` which it calls).
5.  **Animation Building Time!:** The `buildPageTransitions` method is responsible for wrapping your actual page widget (`child`) with the correct Flutter animation widgets.
    *   It checks if a `customTransition` was provided on the `GetPageRoute` (which came from your `GetPage`). If yes, it calls your `customTransition.buildTransition(...)` method.
    *   If no `customTransition`, it looks at the `transition` property (e.g., `Transition.zoom`). Based on this enum value, it picks one of the pre-defined animation setups (like `ZoomInTransition().buildTransitions(...)` from `lib/get_navigation/src/routes/default_transitions.dart`).
    *   It also applies any `curve` or `transitionDuration` you specified.
    *   **Swipe-to-go-back:** Importantly, this method also wraps your page with `GetBackGestureDetector`. This widget listens for horizontal swipe gestures (primarily on iOS, but configurable) to allow the user to swipe from the edge of the screen to navigate back.

Here’s a visual:
```mermaid
sequenceDiagram
    participant UserAction as User Taps Button
    participant GetToNamed as Get.toNamed("/detail")
    participant GRD as GetRouterDelegate
    participant GetPageInfo as GetPage (for /detail)
    participant GetPRoute as GetPageRoute (instance for /detail)
    participant Mixin as GetPageRouteTransitionMixin
    participant Output as Animated Screen

    UserAction->>GetToNamed: Navigates to "/detail"
    GetToNamed->>GRD: Signals intent
    GRD->>GetPageInfo: Reads transition: Transition.zoom
    GRD->>GetPRoute: Creates GetPageRoute with Zoom info
    GetPRoute->>Mixin: Mixin's buildPageTransitions() is called
    Mixin->>Mixin: Checks for customTransition (none here)
    Mixin->>Mixin: Selects ZoomInTransition based on Transition.zoom
    Mixin->>Output: Wraps DetailScreen with ZoomInTransition & GetBackGestureDetector
    Output->>UserAction: DetailScreen animates with zoom
```

**A Glimpse into `GetPageRouteTransitionMixin.buildPageTransitions`:**
This method (located in `lib/get_navigation/src/routes/get_transition_mixin.dart`) is quite long because it handles all transition types. Here's a very simplified idea of its logic:

```dart
// Simplified concept from GetPageRouteTransitionMixin.buildPageTransitions
static Widget buildPageTransitions<T>(
  PageRoute<T> rawRoute, // This is our GetPageRoute
  BuildContext context,
  Animation<double> animation, // Main animation controller
  Animation<double> secondaryAnimation,
  Widget child, // The page content
) {
  final route = rawRoute as GetPageRoute<T>; // Cast to GetPageRoute

  // 1. Handle Custom Transition first
  if (route.customTransition != null) {
    return route.customTransition!.buildTransition(
      context, route.curve, route.alignment,
      animation, secondaryAnimation,
      _wrapWithGestureDetector(route, child, context), // Add swipe gesture
    );
  }

  // 2. Apply curve to the animation
  final curvedAnimation = CurvedAnimation(
      parent: animation,
      curve: route.curve ?? Get.defaultTransitionCurve ?? Curves.linear);

  // 3. Handle pre-defined Transitions (big switch statement)
  Widget transitionWidget;
  switch (route.transition ?? Get.defaultTransition) {
    case Transition.fadeIn:
      transitionWidget = FadeInTransition().buildTransitions(
          context, route.curve, route.alignment,
          curvedAnimation, secondaryAnimation, child);
      break;
    case Transition.zoom:
      transitionWidget = ZoomInTransition().buildTransitions(
          context, route.curve, route.alignment,
          curvedAnimation, secondaryAnimation, child);
      break;
    // ... many other cases for other Transitions ...
    case Transition.rightToLeft:
      // ... uses SlideRightTransition ...
      break;
    default: // Default to platform theme if nothing matches
      PageTransitionsTheme theme = Theme.of(context).pageTransitionsTheme;
      transitionWidget = theme.buildTransitions(
          route, context, animation, secondaryAnimation, child);
  }

  // 4. Always wrap with GetBackGestureDetector for swipe-back
  return _wrapWithGestureDetector(route, transitionWidget, context);
}

// Helper to illustrate gesture detector wrapping (concept)
static Widget _wrapWithGestureDetector<T>(
    GetPageRoute<T> route, Widget childToWrap, BuildContext context) {
  return GetBackGestureDetector<T>(
    popGestureEnable: () => /* logic to see if swipe is enabled */ true,
    onStartPopGesture: () => /* setup controller for swipe */ GetBackGestureController(/*...*/),
    child: childToWrap,
    // ... other gesture detector params ...
  );
}
```
**Explanation:**
*   It first checks if `route.customTransition` (from your `GetPage`) is provided. If so, it uses that.
*   Otherwise, it uses a `switch` statement on `route.transition` (also from `GetPage`). Each case uses a helper class (like `FadeInTransition`, `ZoomInTransition` found in `lib/get_navigation/src/routes/default_transitions.dart`) to build the specific animation.
*   These helper classes essentially do what our `MySlowFade.buildTransition` did – they return configured Flutter animation widgets (like `SlideTransition`, `ScaleTransition`).
*   Crucially, the final child (either from custom or pre-defined transition) is wrapped in `GetBackGestureDetector`. This detector, part of the mixin, provides the logic for the swipe-to-go-back gesture. The `GetBackGestureController` handles the interaction logic during the swipe.

So, `GetPageRouteTransitionMixin` is the versatile director that knows how to stage many different types of scene changes, either from its catalog (`Transitions`) or by following your custom script (`CustomTransition`), and it also ensures the "swipe back" convenience is available.

## Conclusion

You've now learned how to add visual polish to your app's navigation using GetX's Transition System!
*   You can easily apply **pre-defined animations** using the `Transitions` enum in your `GetPage` definitions.
*   For unique effects, you can create your own animations by extending **`CustomTransition`**.
*   Under the hood, **`GetPageRouteTransitionMixin`** (used by `GetPageRoute`) does the heavy lifting, applying your chosen transition and enabling features like swipe-to-go-back via `GetBackGestureDetector`.

By thoughtfully choosing or creating transitions, you can significantly enhance the user experience of your GetX application, making it feel more fluid and engaging.

Next, we'll look at how GetX can help you understand what's happening with your routes, a useful feature for debugging and analytics: [RouterReportManager](08_routerreportmanager_.md).
2025-05-16 11:12:19,237 - INFO - PROMPT: 
Write a very beginner-friendly tutorial chapter (in Markdown format) for the project `getx` about the concept: "RouterReportManager
". This is Chapter 8.

Concept Details:
- Name: RouterReportManager

- Description:
This class acts as a central observer for route navigation events and dependency lifecycles within GetX. It tracks when routes are created, disposed, or when dependencies are linked to routes. This is crucial for GetX's smart memory management, ensuring that controllers and services are correctly initialized and cleaned up as users navigate through the app.
It's like an air traffic controller for your app's routes and their associated resources (dependencies). It logs arrivals, departures, and ensures resources are allocated and deallocated efficiently.


Complete Tutorial Structure:
1. [GetMaterialApp / GetCupertinoApp & GetRoot
](01_getmaterialapp___getcupertinoapp___getroot_.md)
2. [GetNavigation Extensions (e.g., Get.toNamed, Get.snackbar)
](02_getnavigation_extensions__e_g___get_tonamed__get_snackbar__.md)
3. [GetPage & GetRouterDelegate
](03_getpage___getrouterdelegate_.md)
4. [Overlay Management (Snackbar, Dialog, BottomSheet)
](04_overlay_management__snackbar__dialog__bottomsheet__.md)
5. [Route Parsing & Configuration (RouteDecoder, PageSettings, ParseRouteTree)
](05_route_parsing___configuration__routedecoder__pagesettings__parseroutetree__.md)
6. [GetMiddleware
](06_getmiddleware_.md)
7. [Transition System (GetPageRouteTransitionMixin, CustomTransition, Transitions)
](07_transition_system__getpageroutetransitionmixin__customtransition__transitions__.md)
8. [RouterReportManager
](08_routerreportmanager_.md)

Context from previous chapters:
# Chapter 1: GetMaterialApp / GetCupertinoApp & GetRoot

Welcome to your GetX journey! This is the very first step into a powerful and easy-to-use Flutter framework. In this chapter, we'll explore the foundational building blocks of any GetX application: `GetMaterialApp`, `GetCupertinoApp`, and the unsung hero, `GetRoot`.

## What's the Big Deal? Setting Up Your GetX App

Imagine you're building a house. Before you can add rooms, furniture, or even think about painting the walls, you need a solid foundation and the main structure, right? In a Flutter app using GetX, `GetMaterialApp` or `GetCupertinoApp` are like choosing the architectural style of your house (Material Design for Android-style or Cupertino for iOS-style), and they lay this essential groundwork.

Flutter apps usually start with `MaterialApp` (for Material Design) or `CupertinoApp` (for iOS-style design). GetX provides its own versions:

*   `GetMaterialApp`
*   `GetCupertinoApp`

Why use these instead of the standard Flutter ones? Because they do something crucial: **they initialize the GetX framework**. This "initialization" means they set up all the cool things GetX offers, like super-easy navigation, smart state management, and simple internationalization (showing your app in different languages).

Think of it like this: standard `MaterialApp` gives you a basic house blueprint. `GetMaterialApp` gives you that same blueprint but also installs the main electrical panel, plumbing system, and a smart home hub, all ready for you to use GetX features without extra setup.

## Meet the Stars of the Show

Let's break down these key components:

### 1. `GetMaterialApp` (for Material Design lovers)

If you're building an app that follows Google's Material Design guidelines (common for Android apps, but also widely used for cross-platform apps), you'll use `GetMaterialApp`. It's a direct replacement for Flutter's `MaterialApp`. By using it, you're telling your app, "Hey, I want to use GetX features!"

```dart
// main.dart
import 'package:flutter/material.dart';
import 'package:get/get.dart'; // Don't forget to import GetX!

void main() {
  runApp(MyApp());
}

class MyApp extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return GetMaterialApp( // <-- See? We use GetMaterialApp here!
      title: 'My First GetX App',
      home: MyHomePage(),
    );
  }
}

class MyHomePage extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(title: Text('GetX is Awesome!')),
      body: Center(child: Text('Hello, GetX World!')),
    );
  }
}
```
In this very simple app, just by changing `MaterialApp` to `GetMaterialApp`, we've unlocked the potential to use all of GetX's powerful features throughout our `MyApp`.

### 2. `GetCupertinoApp` (for iOS aficionados)

If you're aiming for an app that looks and feels like a native iOS application, you'll use `GetCupertinoApp`. It's the GetX equivalent of Flutter's `CupertinoApp`.

```dart
// main.dart
import 'package:flutter/cupertino.dart';
import 'package:get/get.dart'; // Import GetX

void main() {
  runApp(MyApp());
}

class MyApp extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return GetCupertinoApp( // <-- Using GetCupertinoApp for iOS style
      title: 'My First GetX iOS App',
      home: MyHomePage(),
    );
  }
}

class MyHomePage extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return CupertinoPageScaffold(
      navigationBar: CupertinoNavigationBar(
        middle: Text('Hello, GetX (iOS Style)!'),
      ),
      child: Center(child: Text('GetX on Cupertino!')),
    );
  }
}
```
Similar to `GetMaterialApp`, using `GetCupertinoApp` sets up your app for GetX functionalities but with an iOS-style foundation.

### 3. `GetRoot`: The Engine Under the Hood

You might not ever type `GetRoot` directly in your code, but it's super important to know it exists. `GetRoot` is the core widget that both `GetMaterialApp` and `GetCupertinoApp` use internally.

Think of `GetRoot` as the main power supply and central control panel for the GetX system in your app. It's responsible for:
*   Managing global configurations.
*   Setting up the routing system that GetX uses for navigation.
*   Initializing dependency management.
*   Handling internationalization settings (like current language).

So, when you use `GetMaterialApp` or `GetCupertinoApp`, they are essentially putting a `GetRoot` widget at the very top of your application's widget tree. This makes all the GetX features available to every part of your app.

## How Does It Work? A Peek Inside

You don't need to know the intricate details to use GetX effectively, but a little insight can be helpful!

1.  **You start your app:** You use `GetMaterialApp` (or `GetCupertinoApp`) as the root widget in your `main.dart` file.
2.  **`GetMaterialApp` takes charge:** When `GetMaterialApp` is built, its main job is to create and configure a `GetRoot` widget. It passes along all your app's configurations (like themes, initial routes, translations, etc.) to `GetRoot`.
3.  **`GetRoot` powers up:** `GetRoot` receives these configurations and initializes the entire GetX ecosystem. It sets up internal controllers, listeners for things like language changes, and provides the necessary context for GetX features to work.
4.  **Your app is ready!** With `GetRoot` in place, all other GetX functionalities (like `Get.to()` for navigation, `Get.put()` for dependency injection, `Get.snackbar()` for messages) can now find the necessary GetX infrastructure and work their magic.

Let's visualize this flow:

```mermaid
sequenceDiagram
    participant UserApp as main.dart
    participant GMA as GetMaterialApp
    participant GR as GetRoot
    participant GetXCore as GetX Core System

    UserApp->>GMA: Uses GetMaterialApp/GetCupertinoApp
    GMA->>GR: Wraps its child with GetRoot, passing configurations
    GR->>GetXCore: Initializes GetX services (routing, DI, locale)
    GMA->>UserApp: Renders app with GetX features enabled
```

**A Tiny Glimpse into the Code:**

You won't usually need to touch this code, but it helps to see it.

Here's a simplified look at what `GetMaterialApp` does in its `build` method (from `lib/get_navigation/src/root/get_material_app.dart`):

```dart
// Inside GetMaterialApp's build method
@override
Widget build(BuildContext context) {
  return GetRoot( // Notice! It returns a GetRoot widget.
    config: ConfigData( // Bundles up all configurations
      // ... like home, getPages, locale, theme ...
      home: home,
      getPages: getPages,
      locale: locale,
      theme: theme,
      // ... and many other settings you provide ...
    ),
    child: Builder(builder: (context) {
      // This inner part builds the actual MaterialApp,
      // now empowered by GetRoot and its configurations.
      final controller = GetRoot.of(context);
      return MaterialApp.router( /* ... uses controller.config ... */ );
    }),
  );
}
```
This code shows that `GetMaterialApp` essentially sets up `GetRoot` with all your app's settings. `GetRoot` then takes care of the nitty-gritty GetX initialization.

And here's a very simplified idea of what `GetRoot` does when it starts (from `lib/get_navigation/src/root/get_root.dart`):

```dart
// Inside GetRootState's initState method
@override
void initState() {
  config = widget.config; // Receives config from GetMaterialApp/GetCupertinoApp
  // ... other setup ...
  onInit(); // Calls a special GetX initialization method
  super.initState();
}

void onInit() {
  // Example: Sets up the current language (locale) for your app
  if (config.locale != null) Get.locale = config.locale;

  // Example: Initializes translations if you provide them
  if (config.translations != null) {
    Get.addTranslations(config.translations!.keys);
  }
  // ... and much more initialization for routing, logging, etc. ...
}
```
This `onInit()` method within `GetRoot` is where a lot of the GetX magic gets set up based on the properties you pass to `GetMaterialApp` or `GetCupertinoApp`.

## Why Bother? The Benefits

*   **Simplicity:** You just swap `MaterialApp` with `GetMaterialApp` (or `CupertinoApp` with `GetCupertinoApp`), and you're ready to use GetX. No complex setup rituals!
*   **Power:** This simple change unlocks a vast array of features:
    *   Effortless route management (covered in [GetNavigation Extensions (e.g., Get.toNamed, Get.snackbar)](02_getnavigation_extensions__e_g___get_tonamed__get_snackbar__.md) and [GetPage & GetRouterDelegate](03_getpage___getrouterdelegate__.md)).
    *   Simple state management.
    *   Easy dependency injection.
    *   Built-in internationalization.
    *   Dialogs, Snackbars, and BottomSheets without `context` (see [Overlay Management (Snackbar, Dialog, BottomSheet)](04_overlay_management__snackbar__dialog__bottomsheet__.md)).
*   **Performance:** GetX is designed to be lightweight and performant.

## Conclusion

You've just learned about the most fundamental step in building a GetX application: using `GetMaterialApp` or `GetCupertinoApp`. These widgets, powered by the underlying `GetRoot`, are your gateway to the GetX ecosystem. They seamlessly initialize everything you need, allowing you to focus on building amazing features rather than wrestling with boilerplate setup.

With this foundation laid, you're now ready to explore one of the most beloved features of GetX: its incredibly simple and powerful navigation system.

Ready to learn how to move between screens with ease? Let's dive into the [GetNavigation Extensions (e.g., Get.toNamed, Get.snackbar)](02_getnavigation_extensions__e_g___get_tonamed__get_snackbar__.md)!
---
# Chapter 2: GetNavigation Extensions (e.g., Get.toNamed, Get.snackbar)

Welcome back! In [Chapter 1: GetMaterialApp / GetCupertinoApp & GetRoot](01_getmaterialapp___getcupertinoapp___getroot_.md), we learned how to set up the foundation of our GetX app using `GetMaterialApp` or `GetCupertinoApp`. This simple step unlocked a world of powerful GetX features. Now, let's explore one of the most loved features: making navigation and showing pop-ups incredibly easy!

## The Old Way vs. The GetX Way

Imagine you're in your app, perhaps inside a settings page, and you want to navigate to a user profile page after a button tap. In standard Flutter, you'd typically need `BuildContext` to do this:

```dart
// Standard Flutter (needs context)
Navigator.push(context, MaterialPageRoute(builder: (context) => ProfileScreen()));
```

What if your button's logic is inside a separate class, like a ViewModel or a Controller, that doesn't have direct access to `BuildContext`? Passing `BuildContext` around can make your code a bit messy.

This is where GetX shines! GetX provides **GetNavigation Extensions**. These are convenient shortcut methods attached to the `Get` interface (think of `Get` as your GetX toolkit). They allow you to navigate or show UI elements like dialogs, snackbars, and bottom sheets from *anywhere* in your code without needing a `BuildContext`.

Think of it as a **universal remote control** for your app's navigation and common UI pop-ups. Instead of finding the specific local remote (`BuildContext`) for the TV in a room, you use one master remote (`Get`) to control any TV (navigation, dialog) in the house.

## Your Universal Remote: Meet `Get`

The `Get` object is your central access point for many GetX features. When you see `Get.something()`, you're using one of these handy extensions.

Let's see how this "universal remote" works for common tasks.

### 1. Navigating to a New Screen: `Get.to()`

Want to go to a new screen? Just use `Get.to()` and tell it which screen (widget) to build.

**Use Case:** Let's say we have a `HomeScreen` and we want to navigate to a `DetailScreen`.

First, your `main.dart` should be set up with `GetMaterialApp` (as learned in Chapter 1):

```dart
// main.dart
import 'package:flutter/material.dart';
import 'package:get/get.dart';
import 'home_screen.dart'; // We'll create this next

void main() {
  runApp(MyApp());
}

class MyApp extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return GetMaterialApp( // Using GetMaterialApp
      title: 'GetX Navigation',
      home: HomeScreen(),
    );
  }
}
```
This setup is crucial because `GetMaterialApp` prepares GetX for context-less navigation.

Now, let's create `HomeScreen` and `DetailScreen`:

```dart
// home_screen.dart
import 'package:flutter/material.dart';
import 'package:get/get.dart';
import 'detail_screen.dart'; // We'll create this

class HomeScreen extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(title: Text('Home')),
      body: Center(
        child: ElevatedButton(
          onPressed: () {
            // Look, no context needed!
            Get.to(() => DetailScreen());
          },
          child: Text('Go to Details'),
        ),
      ),
    );
  }
}
```
In `HomeScreen`, when the button is pressed, `Get.to(() => DetailScreen())` is called. This tells GetX to push `DetailScreen` onto the navigation stack.

```dart
// detail_screen.dart
import 'package:flutter/material.dart';

class DetailScreen extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(title: Text('Details')),
      body: Center(child: Text('This is the Detail Screen!')),
    );
  }
}
```
`DetailScreen` is just a simple page. When you tap the button on `HomeScreen`, you'll navigate to `DetailScreen`.

**What happened?**
`Get.to(() => DetailScreen())` pushed a new route displaying `DetailScreen` onto the navigation stack. The `() => DetailScreen()` part is a function that creates your new screen.

### 2. Navigating with Named Routes: `Get.toNamed()`

Sometimes, you prefer to navigate using names instead of creating widget instances directly. This is great for clean code and is essential for web routing. GetX makes this super easy with `Get.toNamed()`.

First, you need to define your named routes in `GetMaterialApp` using the `getPages` property. We'll dive deeper into `getPages` in [GetPage & GetRouterDelegate](03_getpage___getrouterdelegate__.md), but here's a sneak peek:

```dart
// main.dart (updated)
import 'package:flutter/material.dart';
import 'package:get/get.dart';
import 'home_screen.dart';
import 'detail_screen.dart'; // Import DetailScreen

void main() {
  runApp(MyApp());
}

class MyApp extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return GetMaterialApp(
      title: 'GetX Named Navigation',
      initialRoute: '/home', // Optional: set an initial route
      getPages: [
        GetPage(name: '/home', page: () => HomeScreen()),
        GetPage(name: '/detail', page: () => DetailScreen()),
      ],
    );
  }
}
```
We've defined two routes: `/home` pointing to `HomeScreen` and `/detail` pointing to `DetailScreen`.

Now, in your `HomeScreen`, you can navigate using the name:

```dart
// home_screen.dart (updated for named route)
// ... (imports remain the same)
class HomeScreen extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(title: Text('Home')),
      body: Center(
        child: ElevatedButton(
          onPressed: () {
            Get.toNamed('/detail'); // Navigate by name!
          },
          child: Text('Go to Details (Named)'),
        ),
      ),
    );
  }
}
```
When you tap the button, `Get.toNamed('/detail')` looks up the '/detail' route you defined in `getPages` and navigates to `DetailScreen`.

### 3. Going Back: `Get.back()`

To go back to the previous screen, it's as simple as:

```dart
// Inside DetailScreen, for example
ElevatedButton(
  onPressed: () {
    Get.back(); // Go back to HomeScreen
  },
  child: Text('Go Back'),
)
```
`Get.back()` pops the current screen from the navigation stack, just like Flutter's `Navigator.pop(context)`.

### 4. Showing a Quick Message: `Get.snackbar()`

Need to show a quick notification or message (a "snackbar")? GetX has you covered, again, without needing `BuildContext`.

```dart
// In any button's onPressed, or anywhere else:
ElevatedButton(
  onPressed: () {
    Get.snackbar(
      "Success!", // Title
      "Your action was completed.", // Message
      snackPosition: SnackPosition.BOTTOM, // Optional: position
    );
  },
  child: Text('Show Snackbar'),
)
```
This will display a sleek snackbar at the bottom (or top, depending on `snackPosition`) of your screen. It's that easy! We'll explore snackbars in more detail in [Overlay Management (Snackbar, Dialog, BottomSheet)](04_overlay_management__snackbar__dialog__bottomsheet__.md).

### 5. A Peek at Dialogs and Bottom Sheets

GetX also simplifies showing dialogs and bottom sheets without `BuildContext`.

*   **Dialogs with `Get.dialog()`**:
    ```dart
    // Example: Show a simple dialog
    Get.dialog(
      AlertDialog(
        title: Text('Alert!'),
        content: Text('This is a GetX dialog.'),
        actions: [TextButton(onPressed: () => Get.back(), child: Text('OK'))],
      )
    );
    ```

*   **Bottom Sheets with `Get.bottomSheet()`**:
    ```dart
    // Example: Show a simple bottom sheet
    Get.bottomSheet(
      Container(
        height: 200,
        color: Colors.white,
        child: Center(child: Text('This is a GetX bottom sheet!')),
      )
    );
    ```
These are very powerful, and you'll learn all about customizing them in [Overlay Management (Snackbar, Dialog, BottomSheet)](04_overlay_management__snackbar__dialog__bottomsheet__.md). For now, just know they exist and are super easy to call!

## How Does This Magic Work? Under the Hood

You might be wondering: "If I'm not giving it `BuildContext`, how does `Get.toNamed()` or `Get.snackbar()` know where to navigate or show the message?"

It's thanks to the setup we did in [Chapter 1: GetMaterialApp / GetCupertinoApp & GetRoot](01_getmaterialapp___getcupertinoapp___getroot_.md)!

1.  **The Foundation**: When you use `GetMaterialApp` (or `GetCupertinoApp`), it internally creates and configures a `GetRoot` widget. This `GetRoot` widget holds a global `NavigatorKey`. Think of this key as a direct phone line to Flutter's navigation system. It also manages an `OverlayKey` for things like snackbars and dialogs.

2.  **The Call**: When you call something like `Get.toNamed('/detail')`, the static `Get` interface uses this globally available `NavigatorKey` (managed by `GetRootController`) to access the current `NavigatorState`.

3.  **The Action**: Once it has the `NavigatorState`, it can then call the standard Flutter methods like `navigatorState.pushNamed('/detail')` or `navigatorState.push(MaterialPageRoute(...))`.

For snackbars, dialogs, and bottom sheets, `Get` uses a similar mechanism to access the `OverlayState` (via `Get.overlayContext`) to display these UI elements on top of your current screen.

Here's a simplified flow:

```mermaid
sequenceDiagram
    participant YourWidget as Your Widget (e.g., Button)
    participant GetStatic as Get (Static Interface)
    participant GetRootCtrl as GetRoot Controller (from GetMaterialApp)
    participant FlutterNavigator as Flutter Navigator/Overlay

    YourWidget->>GetStatic: Calls Get.toNamed("/details") or Get.snackbar(...)
    GetStatic->>GetRootCtrl: Accesses root NavigatorKey or OverlayContext
    GetRootCt<ctrl63>
---
# Chapter 3: GetPage & GetRouterDelegate

In [Chapter 2: GetNavigation Extensions (e.g., Get.toNamed, Get.snackbar)](02_getnavigation_extensions__e_g___get_tonamed__get_snackbar__.md), we saw how easy GetX makes navigating between screens using methods like `Get.to()` and `Get.toNamed()`. We even had a sneak peek at defining named routes. Now, let's dive deeper into how GetX manages these routes in a more structured and powerful way using `GetPage` and `GetRouterDelegate`. These are the tools that make GetX's navigation so robust, especially for larger apps!

## The Need for Structure: Why Bother?

Imagine you're designing a website with many pages: a homepage, an about page, a contact page, a profile page, and so on. If you just linked them haphazardly, it would quickly become a mess. You'd want a clear sitemap and well-defined URLs for each page.

Similarly, in a Flutter app, as it grows, just calling `Get.to(() => MyScreen())` everywhere can become hard to manage. What if you want to change the transition animation for a specific screen? Or pass data to it in a standardized way? Or manage deep linking (opening specific app screens from a web link)?

This is where `GetPage` and `GetRouterDelegate` come in. They help you:
1.  **Define all your app's screens (routes) in one central place.**
2.  **Give each screen a unique name (like a URL).**
3.  **Configure special behaviors for each screen (like transitions or data bindings).**
4.  **Power Flutter's modern Navigator 2.0 system within GetX, allowing for more complex navigation scenarios.**

Let's meet the stars!

## Meet the Blueprint: `GetPage`

Think of `GetPage` as a **blueprint for a screen** in your app. It's not the screen itself, but rather a detailed description of it. Each `GetPage` tells GetX:
*   `name`: The unique "URL" or path for this screen (e.g., `/home`, `/profile`, `/settings/notifications`). This is what you use with `Get.toNamed()`.
*   `page`: A function that tells GetX *how to build* the actual widget for this screen when it's needed.
*   `binding` (optional): A way to set up controllers or other dependencies specifically for this screen. (We'll explore bindings more in GetX state management).
*   `transition` (optional): How the screen animates in and out. (More on this in [Transition System (GetPageRouteTransitionMixin, CustomTransition, Transitions)](07_transition_system__getpageroutetransitionmixin__customtransition__transitions__.md)).
*   `middlewares` (optional): Special functions that can run before a page is shown, perhaps to check if a user is logged in. (Covered in [GetMiddleware](06_getmiddleware_.md)).

Let's define a couple of simple `GetPage` blueprints:

```dart
// main.dart (or a separate routes file)
import 'package:flutter/material.dart';
import 'package:get/get.dart'; // Import GetX

// Assume HomeScreen and ProfileScreen widgets are defined elsewhere
// For example:
// class HomeScreen extends StatelessWidget { /* ... */ }
// class ProfileScreen extends StatelessWidget { /* ... */ }

final List<GetPage> appPages = [
  GetPage(
    name: '/home', // The unique name for the home screen
    page: () => HomeScreen(), // How to build the HomeScreen
  ),
  GetPage(
    name: '/profile', // The unique name for the profile screen
    page: () => ProfileScreen(), // How to build the ProfileScreen
    // transition: Transition.rightToLeft, // Optional: a nice slide animation
  ),
];
```
In this snippet, `appPages` is a list holding the blueprints for our `HomeScreen` and `ProfileScreen`. We've given each a unique `name` and a `page` function.

## Meet the Captain: `GetRouterDelegate`

If `GetPage` is the blueprint, then `GetRouterDelegate` is the **captain of your app's navigation ship**. It's the core engine that powers Flutter's modern Navigator 2.0 system within GetX.

You usually won't interact with `GetRouterDelegate` directly in simple apps. When you provide your list of `GetPage` blueprints to `GetMaterialApp` (as we'll see next), GetX sets up a `GetRouterDelegate` for you behind the scenes.

This "captain" is responsible for:
*   Taking your `GetPage` blueprints.
*   Managing the actual stack of screens (what's visible, what's underneath).
*   Deciding which page is currently visible based on the URL or navigation actions.
*   Handling how to go to new pages (`Get.toNamed()`).
*   Handling how to go back (`Get.back()`).

Think of it like an air traffic controller for your app's screens. It knows all the available "runways" (`GetPage`s) and directs the "planes" (your users' navigation actions) to the correct one smoothly.

## Putting It Together: Defining Routes in `GetMaterialApp`

Now, how do we tell our GetX app about these `GetPage` blueprints so the `GetRouterDelegate` can use them? We pass our list of `GetPage`s to the `getPages` property of `GetMaterialApp` (or `GetCupertinoApp`).

Let's update our `main.dart` from Chapter 2:

```dart
// main.dart
import 'package:flutter/material.dart';
import 'package:get/get.dart';

// Let's define our screens quickly for this example
class HomeScreen extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(title: Text('Home')),
      body: Center(
        child: ElevatedButton(
          onPressed: () => Get.toNamed('/profile'), // Navigate to profile
          child: Text('Go to Profile'),
        ),
      ),
    );
  }
}

class ProfileScreen extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(title: Text('Profile')),
      body: Center(child: Text('This is your Profile!')),
    );
  }
}

// Our GetPage blueprints
final List<GetPage> appPages = [
  GetPage(name: '/home', page: () => HomeScreen()),
  GetPage(name: '/profile', page: () => ProfileScreen()),
];

void main() {
  runApp(MyApp());
}

class MyApp extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return GetMaterialApp(
      title: 'GetX Named Routes',
      initialRoute: '/home', // Start at the home screen
      getPages: appPages,   // <-- Here's where we provide our blueprints!
    );
  }
}
```
By providing `appPages` to `GetMaterialApp`, we've done two things:
1.  Registered our `/home` and `/profile` routes.
2.  Enabled `GetMaterialApp` to use its internal `GetRouterDelegate` to manage navigation based on these named routes.

Now, `Get.toNamed('/profile')` from `HomeScreen` will correctly navigate to `ProfileScreen` because the `GetRouterDelegate` (set up by `GetMaterialApp`) knows about the `/profile` blueprint.

## How Does It Work Under the Hood?

When you use `getPages` with `GetMaterialApp`, GetX sets up a more sophisticated navigation system. Here's a simplified step-by-step:

1.  **Setup**: When `GetMaterialApp` starts, it sees you've provided `getPages`. It then creates and configures a `GetRouterDelegate` (specifically, an instance of `GetDelegate` from `lib/get_navigation/src/routes/get_router_delegate.dart`). This delegate is given your list of `GetPage` blueprints.
2.  **Navigation Trigger**: You call `Get.toNamed('/profile')`.
3.  **Delegate at Work**: The `Get.toNamed` call, in this Navigator 2.0 setup, ultimately informs the `GetRouterDelegate`.
4.  **Route Matching**: The `GetRouterDelegate` consults its list of `GetPage`s. It uses a helper, often `ParseRouteTree` (from `lib/get_navigation/src/routes/parse_route.dart`), to find the `GetPage` whose `name` matches `/profile`. We'll explore `ParseRouteTree` more in [Route Parsing & Configuration (RouteDecoder, PageSettings, ParseRouteTree)](05_route_parsing___configuration__routedecoder__pagesettings__parseroutetree__.md).
5.  **Screen Creation**: Once the matching `GetPage` blueprint is found, the `GetRouterDelegate` uses its `page: () => ProfileScreen()` function to create an instance of `ProfileScreen`.
6.  **Stack Update**: The `GetRouterDelegate` then updates Flutter's navigation stack to display this new `ProfileScreen`.

Here's a visual:

```mermaid
sequenceDiagram
    participant UserAction as User Taps Button
    participant GetToNamed as Get.toNamed("/profile")
    participant GMA as GetMaterialApp (internally)
    participant GRD as GetRouterDelegate
    participant FlutterNav as Flutter Navigator

    UserAction->>GetToNamed: Invokes navigation for "/profile"
    GetToNamed->>GMA: Signals intent (simplified)
    GMA->>GRD: Relays "/profile" to its delegate
    GRD->>GRD: Finds GetPage(name: "/profile") in its list (getPages)
    GRD->>GRD: Calls page() function from GetPage
    GRD->>FlutterNav: "Push this new screen (ProfileScreen)"
    FlutterNav->>UserAction: ProfileScreen is displayed
```

Inside `GetMaterialApp` (or more accurately, `GetMaterialApp.router` which is used when `getPages` is provided), it sets up like this:

```dart
// Simplified concept from GetMaterialApp when getPages is used
// return GetMaterialApp.router(
//   routeInformationParser: GetInformationParser(...), // Handles URL parsing
//   routerDelegate: GetDelegate(pages: getPages, ...), // Our captain!
// );
```
The `GetDelegate` (our `GetRouterDelegate` implementation) receives your `pages` (your `GetPage` list).

Then, `GetDelegate`'s `build` method uses these pages to construct the `Navigator`:

```dart
// Simplified from lib/get_navigation/src/routes/get_router_delegate.dart
// Inside GetDelegate's build method:

// final currentHistory = currentConfiguration;
// final pages = /* ... logic to get current visible GetPage(s) based on URL ... */
//    getVisualPages(currentHistory).toList();

// return GetNavigator(
//   key: navigatorKey,
//   onPopPage: _onPopVisualRoute, // Handles back button for these pages
//   pages: pages, // The actual Flutter Page objects derived from your GetPages
//   // ... other navigator configurations
// );
```
The `pages` list here are Flutter `Page` objects, which `GetDelegate` creates based on your `GetPage` definitions and the current navigation state.

So, by using `GetPage` and `getPages`, you're tapping into this powerful, Navigator 2.0-based routing managed by `GetRouterDelegate`.

## Why This Approach?

*   **Centralized Route Definitions**: All your main navigation paths are clearly defined in one place.
*   **Named Navigation Power**: Makes `Get.toNamed()` very robust.
*   **Decoupling**: Your UI code just says "go to `/profile`"; it doesn't need to know *how* `ProfileScreen` is built or what its specific dependencies are.
*   **Advanced Scenarios**: This structure is the foundation for more complex features like:
    *   Nested navigation (routes within routes).
    *   Guards/Middlewares (e.g., checking login status before accessing a route, covered in [GetMiddleware](06_getmiddleware_.md)).
    *   Custom transitions per route (see [Transition System (GetPageRouteTransitionMixin, CustomTransition, Transitions)](07_transition_system__getpageroutetransitionmixin__customtransition__transitions__.md)).
    *   Better web URL handling.

## Conclusion

You've now learned about `GetPage`, the blueprint for your screens, and `GetRouterDelegate`, the captain that manages navigation using these blueprints. By defining your routes using `GetPage` and providing them to `GetMaterialApp` via the `getPages` property, you unlock a more structured, powerful, and maintainable way to handle navigation in your GetX applications. This setup is what allows GetX to seamlessly integrate with Flutter's Navigator 2.0 system, giving you fine-grained control while keeping things simple.

While `GetRouterDelegate` works largely behind the scenes for many common use cases, understanding its role helps you appreciate the robustness of GetX navigation.

Next up, we'll explore how GetX makes it incredibly easy to show common UI overlays like Snackbars, Dialogs, and BottomSheets, often without needing `BuildContext` at all! Let's head to [Overlay Management (Snackbar, Dialog, BottomSheet)](04_overlay_management__snackbar__dialog__bottomsheet__.md).
---
# Chapter 4: Overlay Management (Snackbar, Dialog, BottomSheet)

Welcome back! In [Chapter 3: GetPage & GetRouterDelegate](03_getpage___getrouterdelegate__.md), we learned how to structure our app's navigation with named routes using `GetPage`. Now, let's explore another incredibly handy feature of GetX: managing temporary UI elements like snackbars, dialogs, and bottom sheets, all without needing to pass `BuildContext` around!

## What are Overlays? The Hotel Concierge Analogy

Imagine you're staying in a fancy hotel (your app). You're comfortably in your room (your current screen). Sometimes, you need quick services or information without having to leave your room or go to a completely new part of the hotel. This is where the hotel concierge comes in handy!

In GetX, overlay management is like having a super-efficient concierge service for your app. You can request:
*   A **quick note delivered to you** (a **Snackbar**): A brief message that appears temporarily, usually at the top or bottom of the screen, to give you a quick update (e.g., "Message sent!").
*   To **arrange a private meeting in a temporary room** (a **Dialog**): A pop-up window that requires your attention before you can continue interacting with your current screen. Useful for alerts, confirmations, or quick forms.
*   To **pull up a special information panel from below** (a **BottomSheet**): A panel that slides up from the bottom of the screen, offering more detailed options or information related to the current context.

These are all "overlays"—UI elements that appear *on top* of your current page without completely replacing it. GetX makes showing these incredibly simple.

## GetX's Superpower: Context-less Overlays

As we saw in [Chapter 2: GetNavigation Extensions (e.g., Get.toNamed, Get.snackbar)](02_getnavigation_extensions__e_g___get_tonamed__get_snackbar__.md), one of GetX's main advantages is allowing you to trigger navigation and UI elements from anywhere in your code, often without needing `BuildContext`. This is especially true for overlays!

Thanks to the setup with `GetMaterialApp` (covered in [Chapter 1: GetMaterialApp / GetCupertinoApp & GetRoot](01_getmaterialapp___getcupertinoapp___getroot_.md)), GetX has access to the necessary "hooks" to display these overlays globally.

Let's see how to use our "concierge" (`Get`) to request these services.

### 1. Quick Notes: `Get.snackbar()`

Need to show a user a quick, non-intrusive message? `Get.snackbar()` is your friend. It's like asking the concierge to slip a small note under your door.

```dart
// In any button's onPressed, or anywhere in your logic:
ElevatedButton(
  onPressed: () {
    Get.snackbar(
      "Notification", // Title of the snackbar
      "Your profile was updated successfully!", // Message
      snackPosition: SnackPosition.BOTTOM, // Where it appears
      backgroundColor: Colors.green,
      colorText: Colors.white,
    );
  },
  child: Text('Update Profile & Show Snackbar'),
)
```
**What happens?**
Tapping this button will display a green snackbar at the bottom of the screen with the title "Notification" and your message. It will automatically dismiss after a few seconds.

**Behind the Scenes (Briefly):**
GetX uses a `SnackbarController` to manage these requests. If you call `Get.snackbar()` multiple times quickly, `SnackbarController` acts like the concierge's assistant, queuing up the notes and delivering them one by one, so they don't all appear at once and clutter the screen.

### 2. Private Meetings: `Get.dialog()`

Sometimes you need to grab the user's full attention for an important choice or piece of information. This is like asking the concierge to book a small, private meeting room (a Dialog). The user must interact with the dialog (e.g., press "OK" or "Cancel") before returning to their main room (screen).

```dart
// In any button's onPressed:
ElevatedButton(
  onPressed: () {
    Get.dialog(
      AlertDialog(
        title: Text('Confirm Action'),
        content: Text('Are you sure you want to delete this item?'),
        actions: [
          TextButton(onPressed: () => Get.back(), child: Text('Cancel')),
          TextButton(onPressed: () { /* delete logic */ Get.back(); }, child: Text('Delete')),
        ],
      ),
    );
  },
  child: Text('Delete Item (Show Dialog)'),
)
```
**What happens?**
Tapping this button will display a standard Material Design alert dialog in the middle of the screen. The background will be dimmed, and the user must tap "Cancel" or "Delete" to close the dialog. `Get.back()` is used here to close the dialog.

### 3. Special Info Panels: `Get.bottomSheet()`

For presenting a list of options or a bit more information without being as intrusive as a full dialog, a bottom sheet is perfect. It's like the concierge pulling up a neat information panel from a compartment below your desk.

```dart
// In any button's onPressed:
ElevatedButton(
  onPressed: () {
    Get.bottomSheet(
      Container(
        height: 200,
        color: Colors.blueGrey,
        child: Column(
          mainAxisAlignment: MainAxisAlignment.center,
          children: [
            ListTile(leading: Icon(Icons.share, color: Colors.white), title: Text('Share', style: TextStyle(color: Colors.white)), onTap: () => Get.back()),
            ListTile(leading: Icon(Icons.copy, color: Colors.white), title: Text('Copy Link', style: TextStyle(color: Colors.white)), onTap: () => Get.back()),
          ],
        ),
      ),
      // Optional: make it non-dismissible by dragging
      // isDismissible: false, 
    );
  },
  child: Text('Show Options (BottomSheet)'),
)
```
**What happens?**
Tapping this button will cause a panel to slide up from the bottom of the screen. This panel contains our "Share" and "Copy Link" options. Tapping an option (or outside the sheet, if dismissible) will close it. `Get.back()` closes the bottom sheet here.

## How Does GetX Handle These Requests? (Under the Hood)

You might wonder how `Get.snackbar()`, `Get.dialog()`, and `Get.bottomSheet()` can work without you explicitly giving them a `BuildContext`.

**The Magic of `GetMaterialApp` and `Get.overlayContext`**
As we learned in [Chapter 1: GetMaterialApp / GetCupertinoApp & GetRoot](01_getmaterialapp___getcupertinoapp___getroot_.md), using `GetMaterialApp` sets up the GetX framework. Crucially, `GetMaterialApp` (via `GetRoot`) holds a global key for Flutter's `Overlay`. The `Overlay` is like a special layer in your app where you can draw things on top of everything else. GetX exposes access to this overlay's context via `Get.overlayContext`.

```dart
// lib/get_navigation/src/extension_navigation.dart (simplified concept)
BuildContext? get overlayContext {
  // ... logic to get the context of the root overlay ...
  // This 'key' is managed by GetRootState (from GetMaterialApp)
  key.currentState?.overlay?.context.visitChildElements((element) {
    // ... find the overlay context ...
  });
  return /* the found overlay context */;
}
```
This `Get.overlayContext` is the "magic wand" GetX uses to show snackbars, dialogs, and bottom sheets from anywhere.

### Snackbars: The `SnackbarController` at Your Service

When you call `Get.snackbar(...)`, it's more than just displaying a widget.
1.  `Get.snackbar()` (in `extension_navigation.dart`) creates a `GetSnackBar` widget configured with your title, message, colors, etc.
2.  It then hands this `GetSnackBar` widget to a `SnackbarController` (from `lib/get_navigation/src/snackbar/snackbar_controller.dart`).
3.  The `SnackbarController` is responsible for:
    *   Managing a queue (`SnackBarQueue`). If multiple snackbars are requested, they are shown one after another.
    *   Creating `OverlayEntry` objects (Flutter's way of putting something on the `Overlay`).
    *   Handling animations (showing and hiding the snackbar).
    *   Managing the duration and dismissal of the snackbar.

```mermaid
sequenceDiagram
    participant YourCode as Your Widget/Logic
    participant GetSnackbarCall as Get.snackbar()
    participant SnackbarCtrl as SnackbarController
    participant Overlay as Flutter OverlayState

    YourCode->>GetSnackbarCall: Calls Get.snackbar("Title", "Message")
    GetSnackbarCall->>SnackbarCtrl: Creates GetSnackBar widget & passes to new SnackbarController
    SnackbarCtrl->>SnackbarCtrl: Adds itself to SnackBarQueue
    SnackbarCtrl->>Overlay: When its turn, creates OverlayEntry & inserts into Overlay
    Overlay->>YourCode: Snackbar is displayed
    SnackbarCtrl->>Overlay: Later, removes OverlayEntry (on dismiss/timeout)
```

Here's a highly simplified glimpse of `Get.snackbar()` in `lib/get_navigation/src/extension_navigation.dart`:
```dart
// Simplified from extension_navigation.dart
SnackbarController snackbar(String title, String message, {/*...other params...*/}) {
  final getSnackBar = GetSnackBar( // Creates the snackbar widget
    title: title,
    message: message,
    // ... many other properties ...
  );

  // Creates a controller for this specific snackbar instance
  final controller = SnackbarController(getSnackBar); 
  
  // Shows it (adds to queue, handles display via Overlay)
  if (instantInit) { 
    controller.show();
  } else {
    // ... schedule to show after current frame ...
  }
  return controller;
}
```
And `SnackbarController` (in `lib/get_navigation/src/snackbar/snackbar_controller.dart`) uses the `Get.overlayContext` to interact with Flutter's `Overlay`:
```dart
// Simplified concept from SnackbarController.dart
class SnackbarController {
  final GetSnackBar snackbar; // The widget to display
  // ... animation controllers, etc. ...

  Future<void> show() {
    // Adds this snackbar job to a queue
    return GetRootState.controller.config.snackBarQueue.addJob(this);
  }

  Future<void> _show() { // Called by the queue
    // Gets Flutter's OverlayState using Get.overlayContext
    _overlayState = Overlay.of(Get.overlayContext!); 
    // Creates OverlayEntry(s) to display the snackbar
    _overlayEntries.addAll(_createOverlayEntries(snackbar));
    _overlayState!.insertAll(_overlayEntries); // Shows it!
    // ... handles animations and timers ...
    return _transitionCompleter.future;
  }
  // ... methods to close, manage status ...
}
```
The `SnackbarController` is quite sophisticated, managing animations, dismissals, and even a queue. This ensures your snackbars behave politely.

### Dialogs and BottomSheets: Custom Popup Routes

Dialogs and BottomSheets are a bit different. They are typically "modal," meaning they block interaction with the underlying screen content. In Flutter, these are often implemented using `PopupRoute`. GetX provides its own custom `PopupRoute` implementations:
*   `GetDialogRoute` (from `lib/get_navigation/src/dialog/dialog_route.dart`)
*   `GetModalBottomSheetRoute` (from `lib/get_navigation/src/bottomsheet/bottomsheet.dart`)

When you call `Get.dialog()` or `Get.bottomSheet()`:
1.  The `Get` extension method (in `extension_navigation.dart`) takes your widget and parameters.
2.  It then uses `Navigator.of(Get.overlayContext!).push(...)` to push either a `GetDialogRoute` (for dialogs) or a `GetModalBottomSheetRoute` (for bottom sheets) onto the navigator's stack.

Here's a glimpse into `Get.dialog()` from `lib/get_navigation/src/extension_navigation.dart`:
```dart
// Simplified from extension_navigation.dart
Future<T?> dialog<T>(Widget widget, {/* ... params ... */}) {
  // ... theme setup ...
  return generalDialog<T>( // Calls a more generic dialog method
    pageBuilder: (buildContext, animation, secondaryAnimation) {
      // ... wraps widget with Theme, SafeArea etc. ...
      return widget; 
    },
    // ... other parameters like barrierDismissible, barrierColor ...
  );
}

Future<T?> generalDialog<T>({ required RoutePageBuilder pageBuilder, /*...*/}) {
  // Accesses the navigator via Get.overlayContext (or a specific key)
  final nav = /* ... Navigator.of(overlayContext!, rootNavigator: true) ... */;
  
  // Pushes GetX's custom dialog route
  return nav.push<T>( 
    GetDialogRoute<T>(
      pageBuilder: pageBuilder,
      // ... passes other parameters ...
    ),
  );
}
```
And for `Get.bottomSheet()`:
```dart
// Simplified from extension_navigation.dart
Future<T?> bottomSheet<T>(Widget bottomsheet, {/* ... params ... */}) {
  // Uses the Navigator from Get.overlayContext
  return Navigator.of(overlayContext!, rootNavigator: useRootNavigator)
      .push(GetModalBottomSheetRoute<T>( // Pushes GetX's custom bottom sheet route
          builder: (_) => bottomsheet,
          // ... passes many other parameters for customization ...
      ));
}
```
`GetDialogRoute` and `GetModalBottomSheetRoute` are subclasses of Flutter's `PopupRoute`. They handle the specifics of how the dialog or bottom sheet appears, animates, and interacts with the modal barrier (the dimming effect behind them).

So, for dialogs and bottom sheets, GetX leverages Flutter's standard navigation mechanism for `PopupRoute`s but makes them accessible via the simple `Get.dialog()` and `Get.bottomSheet()` calls, using `Get.overlayContext` to find the correct `Navigator`.

## Conclusion

You've just learned how GetX simplifies showing common temporary UI elements—Snackbars, Dialogs, and BottomSheets—much like a hotel concierge assisting with quick notes, private meetings, or information panels.

The key takeaways are:
*   GetX provides easy, context-less APIs like `Get.snackbar()`, `Get.dialog()`, and `Get.bottomSheet()`.
*   `SnackbarController` manages the lifecycle and queue of snackbars efficiently.
*   Dialogs and BottomSheets are presented using custom `PopupRoute` implementations (`GetDialogRoute`, `GetModalBottomSheetRoute`) that GetX makes easy to invoke.
*   All this is possible because `GetMaterialApp` (via `GetRoot`) sets up the necessary global access to Flutter's `Overlay` and `Navigator`.

With these tools, you can create a more interactive and communicative user experience with minimal boilerplate code.

In the next chapter, we'll delve into how GetX understands the named routes you define with `GetPage` and how it handles parameters in those routes. Get ready for [Route Parsing & Configuration (RouteDecoder, PageSettings, ParseRouteTree)](05_route_parsing___configuration__routedecoder__pagesettings__parseroutetree__.md)!
---
# Chapter 5: Route Parsing & Configuration (RouteDecoder, PageSettings, ParseRouteTree)

Welcome back! In [Chapter 4: Overlay Management (Snackbar, Dialog, BottomSheet)](04_overlay_management__snackbar__dialog__bottomsheet__.md), we explored how GetX simplifies showing UI overlays. Now, let's uncover the magic behind how GetX understands the addresses (routes) you navigate to, especially when they include dynamic parts like user IDs or query parameters.

## The App's Address System: Why Do We Need This?

Imagine your app is like a big city, and each screen is a building with a specific address. Sometimes, these addresses are simple, like `/home`. But often, they're more complex, like `/users/123` (showing user with ID 123) or `/products?category=electronics&sort=price` (showing electronic products sorted by price).

How does your app:
1.  Know which screen corresponds to `/users/123`?
2.  Extract the ID `123` so the screen can fetch the correct user data?
3.  Understand that `category=electronics` and `sort=price` are special instructions for the products screen?

This is where GetX's route parsing and configuration system comes in. It's like your app's combined **address book and highly intelligent postal service**.

*   **`ParseRouteTree`**: Think of this as the **master address book**. It holds a structured list of all possible "addresses" (routes) your app knows, including how they might be nested.
*   **`PageSettings`**: This is like an **individual envelope** for a specific navigation request. It contains the destination address, and importantly, any special data like user IDs (path parameters) or filtering options (query parameters).
*   **`RouteDecoder`**: This is the clever **postal worker**. When you say "go to `/users/123?mode=edit`", the `RouteDecoder` looks up this address in the `ParseRouteTree`, figures out it's for a user screen, extracts the ID `123` and the `mode=edit` instruction, and prepares the `PageSettings` "envelope" so the correct screen can be delivered with the right information.

Let's see how these components work together.

## Defining Routes with Parameters

In [Chapter 3: GetPage & GetRouterDelegate](03_getpage___getrouterdelegate__.md), we learned about `GetPage` for defining named routes. We can make these routes dynamic.

Suppose we want a screen to display user profiles. The route might look like `/users/:id`, where `:id` is a placeholder for the user's actual ID.

First, let's define this in our `GetMaterialApp`'s `getPages`:

```dart
// main.dart (or your routes file)
List<GetPage> appPages = [
  GetPage(name: '/', page: () => HomeScreen()),
  GetPage(
    name: '/users/:id', // The :id part is a path parameter
    page: () => UserProfileScreen(),
  ),
  // ... other pages
];
```
Here, `/users/:id` tells GetX that any route starting with `/users/` followed by some value should be handled by `UserProfileScreen`. That value will be available as the `id` parameter.

## Accessing Parameters in Your Screen

Now, when we navigate to, say, `/users/123`, how does `UserProfileScreen` get this `123`? GetX makes it easy with `Get.parameters`.

```dart
// user_profile_screen.dart
import 'package:flutter/material.dart';
import 'package:get/get.dart';

class UserProfileScreen extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    // Accessing the 'id' path parameter
    final String? userId = Get.parameters['id'];

    // Accessing a query parameter, e.g., if URL was /users/123?mode=view
    final String? mode = Get.parameters['mode'];

    return Scaffold(
      appBar: AppBar(title: Text('User Profile: $userId')),
      body: Center(
        child: Text('Displaying profile for user ID: $userId. Mode: $mode'),
      ),
    );
  }
}
```
If we navigate using `Get.toNamed('/users/456?mode=edit')`:
*   `Get.parameters['id']` would give you `"456"`.
*   `Get.parameters['mode']` would give you `"edit"`.

Simple, right? `Get.parameters` is a map containing all parsed path and query parameters.

## How It Works: The Journey of a Route

Let's trace what happens when you call `Get.toNamed('/users/123?mode=edit')`.

1.  **The Request**: Your code calls `Get.toNamed('/users/123?mode=edit')`.
2.  **Delegate Receives**: This request goes to the `GetRouterDelegate` (our app's navigation captain, from [Chapter 3: GetPage & GetRouterDelegate](03_getpage___getrouterdelegate__.md)).
3.  **Consulting the Address Book (`ParseRouteTree`)**:
    *   The `GetRouterDelegate` has an instance of `ParseRouteTree`. This tree was built when your app started, using the `getPages` list you provided to `GetMaterialApp`.
    *   The delegate asks `ParseRouteTree` to `matchRoute('/users/123?mode=edit')`.
4.  **Finding the Match & Preparing the Envelope (`PageSettings`)**:
    *   `ParseRouteTree` searches through its known `GetPage` definitions. It finds that `/users/:id` matches the path `/users/123`.
    *   It an instance of `PageSettings`. This object holds the original URI and is used to store parsed parameters.
    *   `ParseRouteTree` extracts `123` as the value for the path parameter `id`.
    *   It also parses the query part `?mode=edit` and extracts `mode` with the value `edit`.
    *   These parameters (`id: '123'`, `mode: 'edit'`) are stored within the `PageSettings` object.
5.  **The Postal Worker (`RouteDecoder`)**:
    *   `ParseRouteTree` then creates a `RouteDecoder` object. This `RouteDecoder` bundles:
        *   The matched `GetPage` (the blueprint for `UserProfileScreen`).
        *   The `PageSettings` object containing all the extracted parameters and arguments.
6.  **Delivery**:
    *   The `GetRouterDelegate` receives this `RouteDecoder`. It now knows exactly which screen to show (`UserProfileScreen` via its `GetPage`) and what data (`PageSettings` with `id` and `mode`) to make available to that screen.
    *   The `UserProfileScreen` is built. When it accesses `Get.parameters`, it's actually reading from the `PageSettings` associated with its current route instance (managed by `RouteDecoder`).

Here's a simplified visual of this lookup:

```mermaid
sequenceDiagram
    participant UserAction as User calls Get.toNamed
    participant GRD as GetRouterDelegate
    participant PRT as ParseRouteTree (The Address Book)
    participant PS as PageSettings (The Envelope)
    participant RD as RouteDecoder (The Postal Worker)

    UserAction->>GRD: Get.toNamed("/users/123?mode=edit")
    GRD->>PRT:  matchRoute("/users/123?mode=edit")
    PRT->>PRT: Finds GetPage(name: "/users/:id")
    PRT->>PS: Creates PageSettings, populates with id='123', mode='edit'
    PRT->>RD: Creates RouteDecoder(matched GetPage, PageSettings instance)
    RD-->>GRD: Returns populated RouteDecoder
    GRD->>UserAction: UserProfileScreen is displayed (can access params via Get.parameters)
```

## A Peek Inside the Code

Let's look at simplified versions of these key classes. You don't usually interact with them directly, but understanding their roles is insightful.

### `PageSettings` - The Envelope
(Found in `lib/get_navigation/src/routes/page_settings.dart`)

This class holds information about a specific instance of a route.

```dart
// Simplified concept of PageSettings
class PageSettings extends RouteSettings {
  PageSettings(this.uri, [Object? arguments])
      : super(name: '$uri', arguments: arguments);

  final Uri uri; // The full URI, e.g., /users/123?mode=edit
  final params = <String, String>{}; // Parsed path & query params

  // Helper to get just the path part, e.g., /users/123
  String get path => uri.path;
  // Helper for query params, e.g., {mode: edit}
  Map<String, String> get query => uri.queryParameters;
}
```
When a route is parsed, an instance of `PageSettings` is created, and its `params` map is filled with both path parameters (like `:id`) and query parameters (like `mode=edit`). The full `Uri` and any passed `arguments` are also stored.

### `ParseRouteTree` - The Address Book Builder
(Found in `lib/get_navigation/src/routes/parse_route.dart`)

This class takes all your `GetPage` definitions and builds an efficient way to look them up.

```dart
// Simplified concept of ParseRouteTree
class ParseRouteTree {
  final List<GetPage> routes; // All GetPages from GetMaterialApp.getPages

  ParseRouteTree({required this.routes});

  RouteDecoder matchRoute(String name, {PageSettings? arguments}) {
    final Uri uri = Uri.parse(name); // e.g., /users/123?mode=edit
    GetPage? matchedPage;
    Map<String, String> extractedParams = {};

    // 1. Find matching GetPage
    for (final GetPage routeDefinition in routes) {
      // routeDefinition.path.regex is a pre-compiled regex for the route's path
      // e.g., for '/users/:id', regex matches '/users/ANYTHING'
      final match = routeDefinition.path.regex.firstMatch(uri.path);
      if (match != null) {
        matchedPage = routeDefinition;
        // 2. Extract path parameters (e.g., :id)
        // routeDefinition.path.keys would be ['id']
        for (var i = 0; i < routeDefinition.path.keys.length; i++) {
          extractedParams[routeDefinition.path.keys[i]!] = match[i + 1]!;
        }
        break;
      }
    }

    // 3. Add query parameters
    extractedParams.addAll(uri.queryParameters);

    // 4. Populate PageSettings
    final settings = arguments ?? PageSettings(uri);
    settings.params.clear();
    settings.params.addAll(extractedParams);

    // 5. Create RouteDecoder
    return RouteDecoder(
      matchedPage != null ? [matchedPage] : [], // List of GetPages in hierarchy
      settings,
    );
  }
  // ... other methods to add/remove routes ...
}
```
When `matchRoute` is called:
1.  It iterates through your list of `GetPage`s.
2.  For each `GetPage`, it uses a pre-compiled regular expression (`route.path.regex`) from the `GetPage`'s `name` to see if the current URL path matches. The `PathDecoded` object (part of `GetPage`) handles the conversion of `name` like `/users/:id` into a regex and identifies parameter keys like `id`.
3.  If a match is found, it extracts path parameters.
4.  It then adds any query parameters from the URL.
5.  This information is used to populate a `PageSettings` object.
6.  Finally, it returns a `RouteDecoder` containing the matched `GetPage`(s) and the populated `PageSettings`.

### `RouteDecoder` - The Postal Worker with the Decoded Address
(Found in `lib/get_navigation/src/routes/parse_route.dart`)

This class holds the result of parsing a route: the `GetPage`(s) that should be displayed and their `PageSettings`.

```dart
// Simplified concept of RouteDecoder
class RouteDecoder {
  // currentTreeBranch can hold multiple GetPages for nested routes.
  // For a simple route, it's usually just one GetPage.
  final List<GetPage> currentTreeBranch;
  final PageSettings? pageSettings; // The "envelope" with params & args

  RouteDecoder(this.currentTreeBranch, this.pageSettings);

  // The actual GetPage to be displayed (often the last in the branch)
  GetPage? get route =>
      currentTreeBranch.isEmpty ? null : currentTreeBranch.last;

  // Parameters are conveniently accessible from PageSettings
  Map<String, String> get parameters => pageSettings?.params ?? {};
}
```
The `GetRouterDelegate` uses the `route` (the `GetPage`) from `RouteDecoder` to know which widget to build, and the `pageSettings` to make arguments and parameters available to that widget, typically via `Get.arguments` and `Get.parameters`.

When you use `Get.parameters` in your widget, GetX is essentially looking up the current `RouteDecoder` for your active route and accessing `routeDecoder.pageSettings.params`.

## The Big Picture with `GetRouterDelegate`

The `GetRouterDelegate` (specifically `GetDelegate` in GetX's code, see `lib/get_navigation/src/routes/get_router_delegate.dart`) orchestrates this. It holds the `ParseRouteTree`:

```dart
// Inside GetDelegate (simplified)
class GetDelegate extends RouterDelegate<RouteDecoder> {
  final _routeTree = ParseRouteTree(routes: []); // Initialized with your GetPages

  // ... when navigation occurs ...
  RouteDecoder? _getRouteDecoder<T>(PageSettings arguments) {
    // ...
    final decoder = _routeTree.matchRoute(pageUriString, arguments: arguments);
    // ... further configure decoder (like setting arguments) ...
    return decoder;
  }

  @override
  Future<void> setNewRoutePath(RouteDecoder configuration) async {
    // This is called by Flutter's navigation system when the URL changes
    // or when we programmatically navigate.
    // 'configuration' here is often the result of `_getRouteDecoder`.
    _push(configuration); // _push adds to active pages stack and rebuilds UI
    notifyListeners();
  }
  // ... more logic for building the Navigator widget stack ...
}
```
The `GetDelegate` uses its `_routeTree.matchRoute()` method (which internally uses `ParseRouteTree`) to get a `RouteDecoder`. This `RouteDecoder` then informs the delegate which `GetPage`(s) to render and what `PageSettings` (arguments and parameters) are associated with it.

## Conclusion

You've now seen how GetX acts like a sophisticated address book and postal service for your app's routes!
*   `ParseRouteTree` builds and maintains the "address book" from your `GetPage` definitions.
*   `PageSettings` acts as the "envelope," carrying specific details for a navigation request, including parsed path and query parameters.
*   `RouteDecoder` is the "postal worker" that uses the address book to understand an incoming route string, prepare the envelope, and identify the correct screen blueprint.

This system allows GetX to robustly handle complex URLs, extract parameters, and deliver them to your screens effortlessly, all while you primarily just define your `GetPage`s and use `Get.toNamed()` and `Get.parameters`.

Next up, we'll explore a powerful feature that lets you intercept navigation: [GetMiddleware](06_getmiddleware_.md). Imagine them as security checkpoints or toll booths before you can access certain routes!
---
# Chapter 6: GetMiddleware

Welcome back! In [Chapter 5: Route Parsing & Configuration (RouteDecoder, PageSettings, ParseRouteTree)](05_route_parsing___configuration__routedecoder__pagesettings__parseroutetree__.md), we learned how GetX deciphers route names and handles parameters. Now, let's introduce a powerful concept: **GetMiddleware**. These are like checkpoints or gatekeepers for your routes, allowing you to run logic *before* a page is even shown.

## The Problem: Guarding Your Routes

Imagine you have a user profile page `/profile` in your app. You only want authenticated (logged-in) users to access this page. If a guest tries to navigate to `/profile`, they should be redirected to the `/login` page instead. How do you enforce this rule cleanly?

This is where `GetMiddleware` comes in! It lets you intercept navigation requests and decide what happens next.

## What is GetMiddleware? Your Route's Receptionist!

A `GetMiddleware` is a class you create that intercepts navigation to specific routes. Think of them as a security guard or a receptionist at the entrance of different offices (your pages) in a building (your app).

*   **Security Guard:** They might check if you have an ID (are you logged in?). If not, they might send you to the main reception (login page).
*   **Receptionist:** They might ask for your appointment details and, based on them, give you a specific visitor pass (modify page properties) or set up a meeting room for you (initialize bindings for the page).

A `GetMiddleware` can:
1.  **Redirect:** Send the user to a different page (e.g., redirect to `/login` if not authenticated).
2.  **Modify Page Properties:** Change aspects of the page that's about to be loaded (more advanced).
3.  **Setup Bindings:** Initialize specific controllers or services for the upcoming page (more advanced).

For this beginner-friendly chapter, we'll focus on the most common use case: **redirecting users.**

## Creating Your First Middleware: The AuthGuard

Let's create a middleware, `AuthMiddleware`, to protect our `/profile` route.

1.  Create a new Dart file, say `auth_middleware.dart`.
2.  Define your class extending `GetMiddleware`:

```dart
// auth_middleware.dart
import 'package:get/get.dart';

class AuthMiddleware extends GetMiddleware {
  // A simple flag to simulate login state.
  // In a real app, you'd get this from a service, e.g., Get.find<AuthService>().isLoggedIn.
  final bool isLoggedIn = false; // Let's assume the user is NOT logged in for this example.
}
```
Our `AuthMiddleware` currently just has a flag `isLoggedIn`. Now, we need to tell it what to do.

### The `redirectDelegate` Method

The most important method for our use case is `redirectDelegate`. GetX calls this method when a route associated with this middleware is about to be accessed. It receives the current `RouteDecoder` (the details of the route being navigated to) and can decide what `RouteDecoder` (if any) should be processed next.

Let's implement it:

```dart
// auth_middleware.dart (continued)
import 'package:get/get.dart';

class AuthMiddleware extends GetMiddleware {
  final bool isLoggedIn = false; // Assume user is NOT logged in.

  @override
  FutureOr<RouteDecoder?> redirectDelegate(RouteDecoder route) {
    // Check if the user is NOT logged in
    // AND they are NOT trying to go to the login page already
    if (!isLoggedIn && route.pageSettings?.name != '/login') {
      print("AuthMiddleware: User not logged in. Redirecting to /login.");
      // If not logged in, redirect to the '/login' page.
      // We get the RouteDecoder for '/login' from GetX's delegate.
      return Get.delegate.matchRoute('/login');
    }
    // If logged in, or already going to /login, proceed as normal.
    return super.redirectDelegate(route); // This passes the original route through.
  }
}
```
**Explanation:**
*   `redirectDelegate(RouteDecoder route)`: This function is given the `route` that the user is trying to access.
*   `if (!isLoggedIn && route.pageSettings?.name != '/login')`: We check two things:
    *   Is the user `isLoggedIn`? (Here, it's `false`).
    *   Is the route they're trying to access (`route.pageSettings?.name`) something *other* than `/login`? We don't want to redirect them away from `/login` if they're already trying to get there!
*   `return Get.delegate.matchRoute('/login');`: If both conditions are true (not logged in and not going to login), we tell GetX to redirect. We use `Get.delegate.matchRoute('/login')` to create a `RouteDecoder` that points to our `/login` route. This is the new destination.
*   `return super.redirectDelegate(route);`: If the user *is* logged in, or if they are already navigating to `/login`, we let them proceed to their original destination by returning the original `route` (the `super` call effectively does this).

> **Note:** `super.redirectDelegate(route)` simply returns the `route` it was given. You could also just `return route;`. If you return `null`, the navigation will be stopped entirely.

## Applying the Middleware to a `GetPage`

Now that we have our `AuthMiddleware`, we need to tell GetX to use it for specific routes. We do this in the `getPages` list within our `GetMaterialApp`.

Let's assume you have `GetPage` definitions for `/home`, `/login`, and `/profile`:

```dart
// main.dart
import 'package:flutter/material.dart';
import 'package:get/get.dart';
import 'auth_middleware.dart'; // Import your middleware

// Simple placeholder screens
class HomeScreen extends StatelessWidget {
  @override Widget build(BuildContext context) => Scaffold(appBar: AppBar(title: Text('Home')), body: Center(child: ElevatedButton(onPressed: () => Get.toNamed('/profile'), child: Text('Go to Profile'))));
}
class LoginScreen extends StatelessWidget {
  @override Widget build(BuildContext context) => Scaffold(appBar: AppBar(title: Text('Login')), body: Center(child: Text('Please Log In')));
}
class ProfileScreen extends StatelessWidget {
  @override Widget build(BuildContext context) => Scaffold(appBar: AppBar(title: Text('Profile')), body: Center(child: Text('Welcome to your Profile!')));
}

void main() {
  runApp(MyApp());
}

class MyApp extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return GetMaterialApp(
      initialRoute: '/home',
      getPages: [
        GetPage(name: '/home', page: () => HomeScreen()),
        GetPage(name: '/login', page: () => LoginScreen()),
        GetPage(
          name: '/profile',
          page: () => ProfileScreen(),
          middlewares: [ // <-- Apply our AuthMiddleware here!
            AuthMiddleware(),
          ],
        ),
      ],
    );
  }
}
```
In the `GetPage` for `/profile`, we added a `middlewares` list and put an instance of our `AuthMiddleware()` in it.

## Seeing it in Action!

Now, let's trace what happens:

1.  **App Starts:** You land on `/home`.
2.  **Navigate to Profile:** You click the "Go to Profile" button, which calls `Get.toNamed('/profile')`.
3.  **Middleware Intercepts:**
    *   GetX sees that the `/profile` route has `AuthMiddleware` attached.
    *   It calls `AuthMiddleware.redirectDelegate()` with the `RouteDecoder` for `/profile`.
    *   Inside our middleware:
        *   `isLoggedIn` is `false`.
        *   `route.pageSettings?.name` is `/profile` (which is not `/login`).
        *   The condition `!isLoggedIn && route.pageSettings?.name != '/login'` is TRUE.
        *   The middleware returns `Get.delegate.matchRoute('/login')`.
4.  **Redirection Occurs:** GetX now discards the original navigation to `/profile` and instead navigates to `/login`.
5.  **Result:** You see the `LoginScreen`!

If you were to change `isLoggedIn = true;` in your `AuthMiddleware` and rerun:
1.  Navigate to `/profile`.
2.  Middleware runs: `isLoggedIn` is `true`.
3.  The condition `!isLoggedIn && ...` is FALSE.
4.  The middleware returns `super.redirectDelegate(route)` (meaning, "proceed to `/profile`").
5.  **Result:** You see the `ProfileScreen`!

## How It Works Under the Hood

Let's briefly look at what GetX is doing.

1.  **Navigation Request:** You call `Get.toNamed('/profile')`.
2.  **Delegate Processing:** This request reaches the `GetRouterDelegate` (as seen in [Chapter 3: GetPage & GetRouterDelegate](03_getpage___getrouterdelegate__.md)).
3.  **Route Matching:** The delegate uses `ParseRouteTree` to find the `GetPage` associated with `/profile`.
4.  **Middleware Check:** The delegate sees that this `GetPage` has a list of `middlewares`.
5.  **Executing Middlewares:** The `GetRouterDelegate` (specifically in its `runMiddleware` method) iterates through these middlewares (sorted by priority, which we'll discuss soon). For each middleware, it calls its `redirectDelegate` method, passing the current `RouteDecoder`.

```mermaid
sequenceDiagram
    participant User as User Action
    participant GetToNamed as Get.toNamed("/profile")
    participant GRD as GetRouterDelegate
    participant AuthMW as AuthMiddleware
    participant TargetPage as ProfileScreen / LoginScreen

    User->>GetToNamed: Tries to go to /profile
    GetToNamed->>GRD: Informs delegate of intent
    GRD->>GRD: Finds GetPage for /profile, sees AuthMiddleware
    GRD->>AuthMW: Calls authMiddleware.redirectDelegate(profileRouteDecoder)
    alt User NOT Logged In
        AuthMW->>GRD: Returns loginRouteDecoder
        GRD->>TargetPage: Navigates to LoginScreen
    else User Logged In
        AuthMW->>GRD: Returns profileRouteDecoder (original)
        GRD->>TargetPage: Navigates to ProfileScreen
    end
```

Here's a peek at the relevant parts (simplified):

**`GetPage` (from `lib/get_navigation/src/routes/get_route.dart`):**
It has a property to hold middlewares.
```dart
class GetPage<T> extends Page<T> {
  // ... other properties ...
  final List<GetMiddleware> middlewares;

  GetPage({
    // ...
    this.middlewares = const [],
    // ...
  });
}
```

**`GetMiddleware` (from `lib/get_navigation/src/routes/route_middleware.dart`):**
This is the base class you extend.
```dart
abstract class GetMiddleware {
  // ... priority and other methods ...

  FutureOr<RouteDecoder?> redirectDelegate(RouteDecoder route) => (route);
  // Default implementation passes the original route through.
  // Returning null stops navigation.
  // Returning a different RouteDecoder redirects.
}
```

**`GetDelegate.runMiddleware()` (conceptual, from `lib/get_navigation/src/routes/get_router_delegate.dart`):**
This method in `GetDelegate` is responsible for executing the middlewares.
```dart
// Simplified concept from GetDelegate
Future<RouteDecoder?> runMiddleware(RouteDecoder currentRouteDecoder) async {
  final middlewares = currentRouteDecoder.route!.middlewares; // Get middlewares from GetPage
  if (middlewares.isEmpty) return currentRouteDecoder;

  var nextRouteDecoder = currentRouteDecoder;
  for (final middleware in middlewares) { // Loop (respecting priority)
    final resultFromMiddleware = await middleware.redirectDelegate(nextRouteDecoder);

    if (resultFromMiddleware == null) { // Middleware says stop
      return null;
    }
    nextRouteDecoder = resultFromMiddleware; // Update to what middleware returned
    // If middleware redirected (nextRouteDecoder != original input to it),
    // GetX might break and re-run middlewares FOR THE NEW ROUTE.
    if (/* current 'nextRouteDecoder' is actually a new different route */) {
       // Potentially re-run middleware chain for the *new* nextRouteDecoder
       return await runMiddleware(nextRouteDecoder);
    }
  }
  return nextRouteDecoder; // Final decision after all middlewares
}
```
This shows that `GetDelegate` actively calls your middleware's `redirectDelegate` and acts upon its result.

## Other Middleware Capabilities (A Quick Look)

While `redirectDelegate` is key for routing logic, `GetMiddleware` offers more:

*   `priority` (int): If you have multiple middlewares on a single `GetPage`, `priority` determines their execution order. Lower numbers run first. Default is `0`.
    ```dart
    class LoggerMiddleware extends GetMiddleware {
      @override
      int get priority => -1; // Run this before AuthMiddleware if both are on same route

      @override
      FutureOr<RouteDecoder?> redirectDelegate(RouteDecoder route) {
        print("Logger: Navigating to ${route.pageSettings?.name}");
        return route; // Just log and proceed
      }
    }

    // In GetPage: middlewares: [AuthMiddleware(), LoggerMiddleware()]
    // LoggerMiddleware (priority -1) runs before AuthMiddleware (priority 0).
    ```

*   `onPageCalled(GetPage? page)`: Called after redirection logic but before bindings. You can modify the `GetPage` instance here (e.g., change its title).
*   `onBindingsStart(List<BindingsInterface>? bindings)`: Called before bindings are initialized. You could add or remove bindings.
*   `onPageBuildStart(GetPageBuilder? page)`: Called before the `page()` builder of `GetPage` is executed.
*   `onPageBuilt(Widget page)`: Called after the page widget is built.
*   `onPageDispose()`: Called when the page and its bindings are disposed.

For most common scenarios like authentication, `redirectDelegate` and `priority` are what you'll use most often.

## Conclusion

You've learned about `GetMiddleware`, your powerful tool for guarding routes and executing logic before pages are displayed. By implementing the `redirectDelegate` method, you can easily control navigation flow, such as redirecting unauthenticated users to a login screen. Adding these middlewares to your `GetPage` definitions integrates them seamlessly into GetX's routing system.

This opens up possibilities for creating more secure and dynamic applications.

Next, we'll explore how GetX handles the visual flair of navigation: the [Transition System (GetPageRouteTransitionMixin, CustomTransition, Transitions)](07_transition_system__getpageroutetransitionmixin__customtransition__transitions__.md)!
---
# Chapter 7: Transition System (GetPageRouteTransitionMixin, CustomTransition, Transitions)

Welcome back! In [Chapter 6: GetMiddleware](06_getmiddleware_.md), we learned how to guard our routes and perform actions before a page is displayed. Now, let's add some visual flair to our app's navigation. This chapter is all about controlling how screens animate when you move from one to another.

## Lights, Camera, Animate! Why Transitions Matter

Imagine you're watching a movie. The way one scene changes to the next can greatly affect the viewing experience. A quick cut builds tension, while a slow fade can indicate a passage of time. Similarly, in an app, the way a new screen appears or an old one disappears—the **transition**—can make your app feel slick, intuitive, or just plain fun.

Think of GetX's Transition System as the **special effects director** for your app's scene changes. It dictates whether a new screen:
*   Slides in from the right (like typical Android apps)
*   Slides in from the bottom (like a modal)
*   Fades in gently
*   Zooms into view
*   Or uses a completely custom, choreographed entrance you design!

This system makes it easy to define these "special effects" for your screen changes.

## The Main Actors in GetX's Transition System

There are three main components you'll get to know:

1.  **`Transitions` (enum)**: This is a list of pre-defined, commonly used animation types that GetX provides out-of-the-box (like fade, slide, zoom). Think of it as a catalog of ready-made special effects.
2.  **`GetPageRouteTransitionMixin`**: This is the engine room! It's a core piece of GetX code (a "mixin") that provides the actual logic for performing page transitions. It handles standard Material Design and Cupertino (iOS-style) transitions, and even includes support for the "swipe-to-go-back" gesture common on iOS. You usually don't use this directly, but it powers the transitions you choose.
3.  **`CustomTransition`**: If the pre-defined `Transitions` aren't enough, GetX lets you become the special effects designer. `CustomTransition` is a class you can extend to implement your very own unique screen animations.

Let's see how to use these to direct our app's scene changes!

## Using Pre-defined Animations with `Transitions`

The easiest way to add an animation is to pick one from the `Transitions` enum and apply it to a `GetPage`.

Remember how we define our routes with `GetPage` in [Chapter 3: GetPage & GetRouterDelegate](03_getpage___getrouterdelegate__.md)? We can simply add a `transition` property there.

**Use Case:** Let's say we have a `HomeScreen` and a `DetailScreen`. We want the `DetailScreen` to zoom in when we navigate to it.

First, make sure your screens are defined:
```dart
// home_screen.dart
import 'package:flutter/material.dart';
import 'package:get/get.dart';

class HomeScreen extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(title: Text('Home')),
      body: Center(
        child: ElevatedButton(
          onPressed: () => Get.toNamed('/detail'), // Navigate to detail
          child: Text('Go to Detail (with Zoom)'),
        ),
      ),
    );
  }
}

// detail_screen.dart
class DetailScreen extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(title: Text('Detail Screen')),
      body: Center(child: Text('I zoomed in!')),
    );
  }
}
```
These are just basic screens.

Now, let's define our routes in `main.dart` and specify the transition for `/detail`:
```dart
// main.dart
import 'package:flutter/material.dart';
import 'package:get/get.dart';
import 'home_screen.dart'; // Assuming you have these files
import 'detail_screen.dart';

void main() {
  runApp(MyApp());
}

class MyApp extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return GetMaterialApp(
      initialRoute: '/home',
      getPages: [
        GetPage(name: '/home', page: () => HomeScreen()),
        GetPage(
          name: '/detail',
          page: () => DetailScreen(),
          transition: Transition.zoom, // <-- Our special effect!
        ),
      ],
    );
  }
}
```
**What happens?**
When you tap the "Go to Detail (with Zoom)" button on the `HomeScreen`, the `DetailScreen` will animate in by zooming. When you navigate back, it will zoom out. It's that simple!

The `Transitions` enum (from `lib/get_navigation/src/routes/transitions_type.dart`) offers many options:
*   `Transition.fade`
*   `Transition.fadeIn`
*   `Transition.rightToLeft`, `Transition.leftToRight` (slide animations)
*   `Transition.upToDown`, `Transition.downToUp`
*   `Transition.size`
*   `Transition.cupertino` (iOS-style slide)
*   And many more!

You can also set a default transition for your entire app in `GetMaterialApp`:
```dart
GetMaterialApp(
  defaultTransition: Transition.native, // Uses platform-native transition by default
  // ... other properties
)
```
If a `GetPage` doesn't specify its own `transition`, it will use this `defaultTransition`. If neither is set, GetX often defaults to a platform-appropriate transition.

## Creating Your Own Magic: `CustomTransition`

What if none of the pre-defined transitions fit your vision? You can create your own! This is where `CustomTransition` comes in.

`CustomTransition` is an abstract class (from `lib/get_navigation/src/routes/custom_transition.dart`). You create your own class that extends it and implement the `buildTransition` method. This method gives you all you need to build your animation:

**Use Case:** Let's create a simple custom fade-in transition that's a bit slower than the default.

1.  **Create your custom transition class:**

```dart
// my_custom_transitions.dart
import 'package:flutter/widgets.dart';
import 'package:get/get.dart'; // For CustomTransition

class MySlowFade implements CustomTransition {
  @override
  Widget buildTransition(
    BuildContext context,
    Curve? curve, // Animation curve (e.g., Curves.easeIn)
    Alignment? alignment, // For some transitions like Scale
    Animation<double> animation, // The main animation (0.0 to 1.0)
    Animation<double> secondaryAnimation, // For when this screen is pushed OFF
    Widget child, // The screen (page) being transitioned
  ) {
    // Use Flutter's FadeTransition widget
    return FadeTransition(
      opacity: CurvedAnimation(
        parent: animation,
        curve: curve ?? Curves.easeInOut, // Use provided curve or a default
      ),
      child: child,
    );
  }
}
```
**Explanation:**
*   We created `MySlowFade` extending `CustomTransition`.
*   The `buildTransition` method is where the magic happens. It's given:
    *   `animation`: This is like a progress bar for your animation, going from 0.0 (start) to 1.0 (end).
    *   `child`: This is the actual page widget you want to animate.
*   We return a `FadeTransition` widget, linking its `opacity` to our main `animation`. We also apply a `Curve` to make the fade smoother.

2.  **Use your `CustomTransition` in a `GetPage`:**

Let's say we have a `SpecialScreen` that should use this slow fade:

```dart
// special_screen.dart
class SpecialScreen extends StatelessWidget { /* ... simple screen ... */ }

// main.dart (updated getPages)
import 'my_custom_transitions.dart'; // Import your custom transition

// ... (existing GetPage definitions) ...
GetPage(
  name: '/special',
  page: () => SpecialScreen(),
  customTransition: MySlowFade(), // <-- Use your custom transition here!
  transitionDuration: Duration(milliseconds: 800), // Optional: make it slower
),
```
Now, when navigating to `/special`, it will use `MySlowFade`. We also set `transitionDuration` on the `GetPage` to make the animation take 800 milliseconds. If you don't set `transitionDuration` on `GetPage`, it will use the default.

## Under the Hood: How GetX Makes Transitions Happen

You're probably wondering how adding `transition: Transition.zoom` or `customTransition: MySlowFade()` to a `GetPage` actually works.

The star here is `GetPageRouteTransitionMixin` (from `lib/get_navigation/src/routes/get_transition_mixin.dart`). This mixin is part of `GetPageRoute` (from `lib/get_navigation/src/routes/default_route.dart`), which is the actual `Route` object GetX creates when you define a `GetPage` and navigate to it.

Here's a simplified flow:

1.  **Navigation Triggered:** You call `Get.toNamed('/detail')`.
2.  **`GetPage `Info Used:** The `GetRouterDelegate` finds the `GetPage` for `/detail`. It sees you've specified `transition: Transition.zoom`.
3.  **`GetPageRoute` Created:** The delegate creates an instance of `GetPageRoute`. This `GetPageRoute` object is created with all the info from your `GetPage`, including the chosen `transition` (or `customTransition`), `transitionDuration`, `curve`, etc.
4.  **`GetPageRouteTransitionMixin` Steps In:** `GetPageRoute` uses `GetPageRouteTransitionMixin`. This mixin has a crucial method called `buildTransitions` (or more specifically, `buildPageTransitions` which it calls).
5.  **Animation Building Time!:** The `buildPageTransitions` method is responsible for wrapping your actual page widget (`child`) with the correct Flutter animation widgets.
    *   It checks if a `customTransition` was provided on the `GetPageRoute` (which came from your `GetPage`). If yes, it calls your `customTransition.buildTransition(...)` method.
    *   If no `customTransition`, it looks at the `transition` property (e.g., `Transition.zoom`). Based on this enum value, it picks one of the pre-defined animation setups (like `ZoomInTransition().buildTransitions(...)` from `lib/get_navigation/src/routes/default_transitions.dart`).
    *   It also applies any `curve` or `transitionDuration` you specified.
    *   **Swipe-to-go-back:** Importantly, this method also wraps your page with `GetBackGestureDetector`. This widget listens for horizontal swipe gestures (primarily on iOS, but configurable) to allow the user to swipe from the edge of the screen to navigate back.

Here’s a visual:
```mermaid
sequenceDiagram
    participant UserAction as User Taps Button
    participant GetToNamed as Get.toNamed("/detail")
    participant GRD as GetRouterDelegate
    participant GetPageInfo as GetPage (for /detail)
    participant GetPRoute as GetPageRoute (instance for /detail)
    participant Mixin as GetPageRouteTransitionMixin
    participant Output as Animated Screen

    UserAction->>GetToNamed: Navigates to "/detail"
    GetToNamed->>GRD: Signals intent
    GRD->>GetPageInfo: Reads transition: Transition.zoom
    GRD->>GetPRoute: Creates GetPageRoute with Zoom info
    GetPRoute->>Mixin: Mixin's buildPageTransitions() is called
    Mixin->>Mixin: Checks for customTransition (none here)
    Mixin->>Mixin: Selects ZoomInTransition based on Transition.zoom
    Mixin->>Output: Wraps DetailScreen with ZoomInTransition & GetBackGestureDetector
    Output->>UserAction: DetailScreen animates with zoom
```

**A Glimpse into `GetPageRouteTransitionMixin.buildPageTransitions`:**
This method (located in `lib/get_navigation/src/routes/get_transition_mixin.dart`) is quite long because it handles all transition types. Here's a very simplified idea of its logic:

```dart
// Simplified concept from GetPageRouteTransitionMixin.buildPageTransitions
static Widget buildPageTransitions<T>(
  PageRoute<T> rawRoute, // This is our GetPageRoute
  BuildContext context,
  Animation<double> animation, // Main animation controller
  Animation<double> secondaryAnimation,
  Widget child, // The page content
) {
  final route = rawRoute as GetPageRoute<T>; // Cast to GetPageRoute

  // 1. Handle Custom Transition first
  if (route.customTransition != null) {
    return route.customTransition!.buildTransition(
      context, route.curve, route.alignment,
      animation, secondaryAnimation,
      _wrapWithGestureDetector(route, child, context), // Add swipe gesture
    );
  }

  // 2. Apply curve to the animation
  final curvedAnimation = CurvedAnimation(
      parent: animation,
      curve: route.curve ?? Get.defaultTransitionCurve ?? Curves.linear);

  // 3. Handle pre-defined Transitions (big switch statement)
  Widget transitionWidget;
  switch (route.transition ?? Get.defaultTransition) {
    case Transition.fadeIn:
      transitionWidget = FadeInTransition().buildTransitions(
          context, route.curve, route.alignment,
          curvedAnimation, secondaryAnimation, child);
      break;
    case Transition.zoom:
      transitionWidget = ZoomInTransition().buildTransitions(
          context, route.curve, route.alignment,
          curvedAnimation, secondaryAnimation, child);
      break;
    // ... many other cases for other Transitions ...
    case Transition.rightToLeft:
      // ... uses SlideRightTransition ...
      break;
    default: // Default to platform theme if nothing matches
      PageTransitionsTheme theme = Theme.of(context).pageTransitionsTheme;
      transitionWidget = theme.buildTransitions(
          route, context, animation, secondaryAnimation, child);
  }

  // 4. Always wrap with GetBackGestureDetector for swipe-back
  return _wrapWithGestureDetector(route, transitionWidget, context);
}

// Helper to illustrate gesture detector wrapping (concept)
static Widget _wrapWithGestureDetector<T>(
    GetPageRoute<T> route, Widget childToWrap, BuildContext context) {
  return GetBackGestureDetector<T>(
    popGestureEnable: () => /* logic to see if swipe is enabled */ true,
    onStartPopGesture: () => /* setup controller for swipe */ GetBackGestureController(/*...*/),
    child: childToWrap,
    // ... other gesture detector params ...
  );
}
```
**Explanation:**
*   It first checks if `route.customTransition` (from your `GetPage`) is provided. If so, it uses that.
*   Otherwise, it uses a `switch` statement on `route.transition` (also from `GetPage`). Each case uses a helper class (like `FadeInTransition`, `ZoomInTransition` found in `lib/get_navigation/src/routes/default_transitions.dart`) to build the specific animation.
*   These helper classes essentially do what our `MySlowFade.buildTransition` did – they return configured Flutter animation widgets (like `SlideTransition`, `ScaleTransition`).
*   Crucially, the final child (either from custom or pre-defined transition) is wrapped in `GetBackGestureDetector`. This detector, part of the mixin, provides the logic for the swipe-to-go-back gesture. The `GetBackGestureController` handles the interaction logic during the swipe.

So, `GetPageRouteTransitionMixin` is the versatile director that knows how to stage many different types of scene changes, either from its catalog (`Transitions`) or by following your custom script (`CustomTransition`), and it also ensures the "swipe back" convenience is available.

## Conclusion

You've now learned how to add visual polish to your app's navigation using GetX's Transition System!
*   You can easily apply **pre-defined animations** using the `Transitions` enum in your `GetPage` definitions.
*   For unique effects, you can create your own animations by extending **`CustomTransition`**.
*   Under the hood, **`GetPageRouteTransitionMixin`** (used by `GetPageRoute`) does the heavy lifting, applying your chosen transition and enabling features like swipe-to-go-back via `GetBackGestureDetector`.

By thoughtfully choosing or creating transitions, you can significantly enhance the user experience of your GetX application, making it feel more fluid and engaging.

Next, we'll look at how GetX can help you understand what's happening with your routes, a useful feature for debugging and analytics: [RouterReportManager](08_routerreportmanager_.md).

Relevant Code Snippets (Code itself remains unchanged):
--- File: lib/get_navigation/src/router_report.dart ---
import 'dart:collection';

import '../../get.dart';

class RouterReportManager<T> {
  /// Holds a reference to `Get.reference` when the Instance was
  /// created to manage the memory.
  final Map<T?, List<String>> _routesKey = {};

  /// Stores the onClose() references of instances created with `Get.create()`
  /// using the `Get.reference`.
  /// Experimental feature to keep the lifecycle and memory management with
  /// non-singleton instances.
  final Map<T?, HashSet<Function>> _routesByCreate = {};

  static RouterReportManager? _instance;

  RouterReportManager._();

  static RouterReportManager get instance =>
      _instance ??= RouterReportManager._();

  static void dispose() {
    _instance = null;
  }

  void printInstanceStack() {
    Get.log(_routesKey.toString());
  }

  T? _current;

  // ignore: use_setters_to_change_properties
  void reportCurrentRoute(T newRoute) {
    _current = newRoute;
  }

  /// Links a Class instance [S] (or [tag]) to the current route.
  /// Requires usage of `GetMaterialApp`.
  void reportDependencyLinkedToRoute(String dependencyKey) {
    if (_current == null) return;
    if (_routesKey.containsKey(_current)) {
      _routesKey[_current!]!.add(dependencyKey);
    } else {
      _routesKey[_current] = <String>[dependencyKey];
    }
  }

  void clearRouteKeys() {
    _routesKey.clear();
    _routesByCreate.clear();
  }

  void appendRouteByCreate(GetLifeCycleMixin i) {
    _routesByCreate[_current] ??= HashSet<Function>();
    // _routesByCreate[Get.reference]!.add(i.onDelete as Function);
    _routesByCreate[_current]!.add(i.onDelete);
  }

  void reportRouteDispose(T disposed) {
    if (Get.smartManagement != SmartManagement.onlyBuilder) {
      // Engine.instance.addPostFrameCallback((_) {
      // Future.microtask(() {
      _removeDependencyByRoute(disposed);
      // });
    }
  }

  void reportRouteWillDispose(T disposed) {
    final keysToRemove = <String>[];

    _routesKey[disposed]?.forEach(keysToRemove.add);

    /// Removes `Get.create()` instances registered in `routeName`.
    if (_routesByCreate.containsKey(disposed)) {
      for (final onClose in _routesByCreate[disposed]!) {
        // assure the [DisposableInterface] instance holding a reference
        // to onClose() wasn't disposed.
        onClose();
      }
      _routesByCreate[disposed]!.clear();
      _routesByCreate.remove(disposed);
    }

    for (final element in keysToRemove) {
      Get.markAsDirty(key: element);

      //_routesKey.remove(element);
    }

    keysToRemove.clear();
  }

  /// Clears from memory registered Instances associated with [routeName] when
  /// using `Get.smartManagement` as [SmartManagement.full] or
  /// [SmartManagement.keepFactory]
  /// Meant for internal usage of `GetPageRoute` and `GetDialogRoute`
  void _removeDependencyByRoute(T routeName) {
    final keysToRemove = <String>[];

    _routesKey[routeName]?.forEach(keysToRemove.add);

    /// Removes `Get.create()` instances registered in `routeName`.
    if (_routesByCreate.containsKey(routeName)) {
      for (final onClose in _routesByCreate[routeName]!) {
        // assure the [DisposableInterface] instance holding a reference
        // to onClose() wasn't disposed.
        onClose();
      }
      _routesByCreate[routeName]!.clear();
      _routesByCreate.remove(routeName);
    }

    for (final element in keysToRemove) {
      final value = Get.delete(key: element);
      if (value) {
        _routesKey[routeName]?.remove(element);
      }
    }

    _routesKey.remove(routeName);

    keysToRemove.clear();
  }
}


--- File: lib/get_navigation/src/dialog/dialog_route.dart ---
import 'package:flutter/widgets.dart';

import '../router_report.dart';

class GetDialogRoute<T> extends PopupRoute<T> {
  GetDialogRoute({
    required RoutePageBuilder pageBuilder,
    bool barrierDismissible = true,
    String? barrierLabel,
    Color barrierColor = const Color(0x80000000),
    Duration transitionDuration = const Duration(milliseconds: 200),
    RouteTransitionsBuilder? transitionBuilder,
    super.settings,
  })  : widget = pageBuilder,
        _barrierDismissible = barrierDismissible,
        _barrierLabel = barrierLabel,
        _barrierColor = barrierColor,
        _transitionDuration = transitionDuration,
        _transitionBuilder = transitionBuilder {
    RouterReportManager.instance.reportCurrentRoute(this);
  }

  final RoutePageBuilder widget;

  @override
  bool get barrierDismissible => _barrierDismissible;
  final bool _barrierDismissible;

  @override
  void dispose() {
    RouterReportManager.instance.reportRouteDispose(this);
    super.dispose();
  }

  @override
  String? get barrierLabel => _barrierLabel;
  final String? _barrierLabel;

  @override
  Color get barrierColor => _barrierColor;
  final Color _barrierColor;

  @override
  Duration get transitionDuration => _transitionDuration;
  final Duration _transitionDuration;

  final RouteTransitionsBuilder? _transitionBuilder;

  @override
  Widget buildPage(BuildContext context, Animation<double> animation,
      Animation<double> secondaryAnimation) {
    return Semantics(
      scopesRoute: true,
      explicitChildNodes: true,
      child: widget(context, animation, secondaryAnimation),
    );
  }

  @override
  Widget buildTransitions(BuildContext context, Animation<double> animation,
      Animation<double> secondaryAnimation, Widget child) {
    if (_transitionBuilder == null) {
      return FadeTransition(
          opacity: CurvedAnimation(
            parent: animation,
            curve: Curves.linear,
          ),
          child: child);
    } // Some default transition
    return _transitionBuilder(context, animation, secondaryAnimation, child);
  }
}


--- File: lib/get_navigation/src/bottomsheet/bottomsheet.dart ---
import 'package:flutter/material.dart';

import '../../../get.dart';
import '../router_report.dart';

class GetModalBottomSheetRoute<T> extends PopupRoute<T> {
  GetModalBottomSheetRoute({
    this.builder,
    this.theme,
    this.barrierLabel,
    this.backgroundColor,
    this.isPersistent,
    this.elevation,
    this.shape,
    this.removeTop = true,
    this.clipBehavior,
    this.modalBarrierColor,
    this.isDismissible = true,
    this.enableDrag = true,
    required this.isScrollControlled,
    super.settings,
    this.enterBottomSheetDuration = const Duration(milliseconds: 250),
    this.exitBottomSheetDuration = const Duration(milliseconds: 200),
    this.curve,
  }) {
    RouterReportManager.instance.reportCurrentRoute(this);
  }
  final bool? isPersistent;
  final WidgetBuilder? builder;
  final ThemeData? theme;
  final bool isScrollControlled;
  final Color? backgroundColor;
  final double? elevation;
  final ShapeBorder? shape;
  final Clip? clipBehavior;
  final Color? modalBarrierColor;
  final bool isDismissible;
  final bool enableDrag;
  // final String name;
  final Duration enterBottomSheetDuration;
  final Duration exitBottomSheetDuration;
  final Curve? curve;
  // remove safearea from top
  final bool removeTop;

  @override
  Duration get transitionDuration => const Duration(milliseconds: 700);

  @override
  bool get barrierDismissible => isDismissible;

  @override
  final String? barrierLabel;

  @override
  Color get barrierColor => modalBarrierColor ?? Colors.black54;

  AnimationController? _animationController;

  @override
  void dispose() {
    RouterReportManager.instance.reportRouteDispose(this);
    super.dispose();
  }

  @override
  Animation<double> createAnimation() {
    if (curve != null) {
      return CurvedAnimation(curve: curve!, parent: _animationController!.view);
    }
    return _animationController!.view;
  }

  @override
  AnimationController createAnimationController() {
    assert(_animationController == null);
    _animationController =
        BottomSheet.createAnimationController(navigator!.overlay!);
    _animationController!.duration = enterBottomSheetDuration;
    _animationController!.reverseDuration = exitBottomSheetDuration;
    return _animationController!;
  }

  @override
  Widget buildPage(BuildContext context, Animation<double> animation,
      Animation<double> secondaryAnimation) {
    final sheetTheme =
        theme?.bottomSheetTheme ?? Theme.of(context).bottomSheetTheme;
    // By definition, the bottom sheet is aligned to the bottom of the page
    // and isn't exposed to the top padding of the MediaQuery.
    Widget bottomSheet = MediaQuery.removePadding(
      context: context,
      removeTop: removeTop,
      child: Padding(
        padding:
            EdgeInsets.only(bottom: MediaQuery.of(context).viewInsets.bottom),
        child: _GetModalBottomSheet<T>(
          route: this,
          backgroundColor: backgroundColor ??
              sheetTheme.modalBackgroundColor ??
              sheetTheme.backgroundColor,
          elevation:
              elevation ?? sheetTheme.modalElevation ?? sheetTheme.elevation,
          shape: shape,
          clipBehavior: clipBehavior,
          isScrollControlled: isScrollControlled,
          enableDrag: enableDrag,
        ),
      ),
    );
    if (theme != null) bottomSheet = Theme(data: theme!, child: bottomSheet);
    return bottomSheet;
  }
}

class _GetModalBottomSheet<T> extends StatefulWidget {
  const _GetModalBottomSheet({
    super.key,
    this.route,
    this.backgroundColor,
    this.elevation,
    this.shape,
    this.clipBehavior,
    this.isScrollControlled = false,
    this.enableDrag = true,
    this.isPersistent = false,
  });
  final bool isPersistent;
  final GetModalBottomSheetRoute<T>? route;
  final bool isScrollControlled;
  final Color? backgroundColor;
  final double? elevation;
  final ShapeBorder? shape;
  final Clip? clipBehavior;
  final bool enableDrag;

  @override
  _GetModalBottomSheetState<T> createState() => _GetModalBottomSheetState<T>();
}

class _GetModalBottomSheetState<T> extends State<_GetModalBottomSheet<T>> {
  String _getRouteLabel(MaterialLocalizations localizations) {
    if ((Theme.of(context).platform == TargetPlatform.android) ||
        (Theme.of(context).platform == TargetPlatform.fuchsia)) {
      return localizations.dialogLabel;
    } else {
      return '';
    }
  }

  @override
  Widget build(BuildContext context) {
    assert(debugCheckHasMediaQuery(context));
    assert(debugCheckHasMaterialLocalizations(context));
    final mediaQuery = MediaQuery.of(context);
    final localizations = MaterialLocalizations.of(context);
    final routeLabel = _getRouteLabel(localizations);

    return AnimatedBuilder(
      animation: widget.route!.animation!,
      builder: (context, child) {
        // Disable the initial animation when accessible navigation is on so
        // that the semantics are added to the tree at the correct time.
        final animationValue = mediaQuery.accessibleNavigation
            ? 1.0
            : widget.route!.animation!.value;
        return Semantics(
          scopesRoute: true,
          namesRoute: true,
          label: routeLabel,
          explicitChildNodes: true,
          child: ClipRect(
            child: CustomSingleChildLayout(
                delegate: _GetModalBottomSheetLayout(
                    animationValue, widget.isScrollControlled),
                child: widget.isPersistent == false
                    ? BottomSheet(
                        animationController: widget.route!._animationController,
                        onClosing: () {
                          if (widget.route!.isCurrent) {
                            Navigator.pop(context);
                          }
                        },
                        builder: widget.route!.builder!,
                        backgroundColor: widget.backgroundColor,
                        elevation: widget.elevation,
                        shape: widget.shape,
                        clipBehavior: widget.clipBehavior,
                        enableDrag: widget.enableDrag,
                      )
                    : Scaffold(
                        bottomSheet: BottomSheet(
                          animationController:
                              widget.route!._animationController,
                          onClosing: () {
                            // if (widget.route.isCurrent) {
                            //   Navigator.pop(context);
                            // }
                          },
                          builder: widget.route!.builder!,
                          backgroundColor: widget.backgroundColor,
                          elevation: widget.elevation,
                          shape: widget.shape,
                          clipBehavior: widget.clipBehavior,
                          enableDrag: widget.enableDrag,
                        ),
                      )),
          ),
        );
      },
    );
  }
}

class _GetPerModalBottomSheet<T> extends StatefulWidget {
  const _GetPerModalBottomSheet({
    super.key,
    this.route,
    this.isPersistent,
    this.backgroundColor,
    this.elevation,
    this.shape,
    this.clipBehavior,
    this.isScrollControlled = false,
    this.enableDrag = true,
  });
  final bool? isPersistent;
  final GetModalBottomSheetRoute<T>? route;
  final bool isScrollControlled;
  final Color? backgroundColor;
  final double? elevation;
  final ShapeBorder? shape;
  final Clip? clipBehavior;
  final bool enableDrag;

  @override
  // ignore: lines_longer_than_80_chars
  _GetPerModalBottomSheetState<T> createState() =>
      _GetPerModalBottomSheetState<T>();
}

// ignore: lines_longer_than_80_chars
class _GetPerModalBottomSheetState<T>
    extends State<_GetPerModalBottomSheet<T>> {
  String _getRouteLabel(MaterialLocalizations localizations) {
    if ((Theme.of(context).platform == TargetPlatform.android) ||
        (Theme.of(context).platform == TargetPlatform.fuchsia)) {
      return localizations.dialogLabel;
    } else {
      return '';
    }
  }

  @override
  Widget build(BuildContext context) {
    assert(debugCheckHasMediaQuery(context));
    assert(debugCheckHasMaterialLocalizations(context));
    final mediaQuery = MediaQuery.of(context);
    final localizations = MaterialLocalizations.of(context);
    final routeLabel = _getRouteLabel(localizations);

    return AnimatedBuilder(
      animation: widget.route!.animation!,
      builder: (context, child) {
        // Disable the initial animation when accessible navigation is on so
        // that the semantics are added to the tree at the correct time.
        final animationValue = mediaQuery.accessibleNavigation
            ? 1.0
            : widget.route!.animation!.value;
        return Semantics(
          scopesRoute: true,
          namesRoute: true,
          label: routeLabel,
          explicitChildNodes: true,
          child: ClipRect(
            child: CustomSingleChildLayout(
                delegate: _GetModalBottomSheetLayout(
                    animationValue, widget.isScrollControlled),
                child: widget.isPersistent == false
                    ? BottomSheet(
                        animationController: widget.route!._animationController,
                        onClosing: () {
                          if (widget.route!.isCurrent) {
                            Navigator.pop(context);
                          }
                        },
                        builder: widget.route!.builder!,
                        backgroundColor: widget.backgroundColor,
                        elevation: widget.elevation,
                        shape: widget.shape,
                        clipBehavior: widget.clipBehavior,
                        enableDrag: widget.enableDrag,
                      )
                    : Scaffold(
                        bottomSheet: BottomSheet(
                          animationController:
                              widget.route!._animationController,
                          onClosing: () {
                            // if (widget.route.isCurrent) {
                            //   Navigator.pop(context);
                            // }
                          },
                          builder: widget.route!.builder!,
                          backgroundColor: widget.backgroundColor,
                          elevation: widget.elevation,
                          shape: widget.shape,
                          clipBehavior: widget.clipBehavior,
                          enableDrag: widget.enableDrag,
                        ),
                      )),
          ),
        );
      },
    );
  }
}

class _GetModalBottomSheetLayout extends SingleChildLayoutDelegate {
  _GetModalBottomSheetLayout(this.progress, this.isScrollControlled);

  final double progress;
  final bool isScrollControlled;

  @override
  BoxConstraints getConstraintsForChild(BoxConstraints constraints) {
    return BoxConstraints(
      minWidth: constraints.maxWidth,
      maxWidth: constraints.maxWidth,
      minHeight: 0.0,
      maxHeight: isScrollControlled
          ? constraints.maxHeight
          : constraints.maxHeight * 9.0 / 16.0,
    );
  }

  @override
  Offset getPositionForChild(Size size, Size childSize) {
    return Offset(0.0, size.height - childSize.height * progress);
  }

  @override
  bool shouldRelayout(_GetModalBottomSheetLayout oldDelegate) {
    return progress != oldDelegate.progress;
  }
}


--- File: lib/get_navigation/src/routes/default_route.dart ---
import 'package:flutter/cupertino.dart';

import '../../../get.dart';
import '../router_report.dart';

@optionalTypeArgs
mixin RouteReportMixin<T extends StatefulWidget> on State<T> {
  @override
  void initState() {
    super.initState();
    RouterReportManager.instance.reportCurrentRoute(this);
  }

  @override
  void dispose() {
    super.dispose();
    RouterReportManager.instance.reportRouteDispose(this);
  }
}

mixin PageRouteReportMixin<T> on Route<T> {
  @override
  void install() {
    super.install();
    RouterReportManager.instance.reportCurrentRoute(this);
  }

  @override
  void dispose() {
    super.dispose();
    RouterReportManager.instance.reportRouteDispose(this);
  }
}

class GetPageRoute<T> extends PageRoute<T>
    with GetPageRouteTransitionMixin<T>, PageRouteReportMixin {
  /// Creates a page route for use in an iOS designed app.
  ///
  /// The [builder], [maintainState], and [fullscreenDialog] arguments must not
  /// be null.
  GetPageRoute({
    super.settings,
    this.transitionDuration = const Duration(milliseconds: 300),
    this.reverseTransitionDuration = const Duration(milliseconds: 300),
    this.opaque = true,
    this.parameter,
    this.gestureWidth,
    this.curve,
    this.alignment,
    this.transition,
    this.popGesture,
    this.customTransition,
    this.barrierDismissible = false,
    this.barrierColor,
    BindingsInterface? binding,
    List<BindingsInterface> bindings = const [],
    this.binds,
    this.routeName,
    this.page,
    this.title,
    this.showCupertinoParallax = true,
    this.barrierLabel,
    this.maintainState = true,
    super.fullscreenDialog,
    this.middlewares,
  })  : bindings = (binding == null) ? bindings : [...bindings, binding],
        _middlewareRunner = MiddlewareRunner(middlewares);

  @override
  final Duration transitionDuration;
  @override
  final Duration reverseTransitionDuration;

  final GetPageBuilder? page;
  final String? routeName;
  //final String reference;
  final CustomTransition? customTransition;
  final List<BindingsInterface> bindings;
  final Map<String, String>? parameter;
  final List<Bind>? binds;

  @override
  final bool showCupertinoParallax;

  @override
  final bool opaque;
  final bool? popGesture;

  @override
  final bool barrierDismissible;
  final Transition? transition;
  final Curve? curve;
  final Alignment? alignment;
  final List<GetMiddleware>? middlewares;

  @override
  final Color? barrierColor;

  @override
  final String? barrierLabel;

  @override
  final bool maintainState;

  final MiddlewareRunner _middlewareRunner;

  @override
  void dispose() {
    super.dispose();
    _middlewareRunner.runOnPageDispose();
    _child = null;
  }

  Widget? _child;

  Widget _getChild() {
    if (_child != null) return _child!;

    final localBinds = [if (binds != null) ...binds!];

    final bindingsToBind = _middlewareRunner
        .runOnBindingsStart(bindings.isNotEmpty ? bindings : localBinds);

    final pageToBuild = _middlewareRunner.runOnPageBuildStart(page)!;

    if (bindingsToBind != null && bindingsToBind.isNotEmpty) {
      if (bindingsToBind is List<BindingsInterface>) {
        for (final item in bindingsToBind) {
          final dep = item.dependencies();
          if (dep is List<Bind>) {
            _child = Binds(
              binds: dep,
              child: _middlewareRunner.runOnPageBuilt(pageToBuild()),
            );
          }
        }
      } else if (bindingsToBind is List<Bind>) {
        _child = Binds(
          binds: bindingsToBind,
          child: _middlewareRunner.runOnPageBuilt(pageToBuild()),
        );
      }
    }

    return _child ??= _middlewareRunner.runOnPageBuilt(pageToBuild());
  }

  @override
  Widget buildContent(BuildContext context) {
    return _getChild();
  }

  @override
  final String? title;

  @override
  String get debugLabel => '${super.debugLabel}(${settings.name})';

  @override
  final double Function(BuildContext context)? gestureWidth;
}


--- File: lib/get_navigation/src/routes/observers/route_observer.dart ---
import 'package:flutter/widgets.dart';

import '../../../../get_core/get_core.dart';
import '../../../../instance_manager.dart';
import '../../../get_navigation.dart';
import '../../dialog/dialog_route.dart';
import '../../router_report.dart';

/// Extracts the name of a route based on it's instance type
/// or null if not possible.
String? _extractRouteName(Route? route) {
  if (route?.settings.name != null) {
    return route!.settings.name;
  }

  if (route is GetPageRoute) {
    return route.routeName;
  }

  if (route is GetDialogRoute) {
    return 'DIALOG ${route.hashCode}';
  }

  if (route is GetModalBottomSheetRoute) {
    return 'BOTTOMSHEET ${route.hashCode}';
  }

  return null;
}

class GetObserver extends NavigatorObserver {
  final Function(Routing?)? routing;

  final Routing? _routeSend;

  GetObserver([this.routing, this._routeSend]);

  @override
  void didPop(Route route, Route? previousRoute) {
    super.didPop(route, previousRoute);
    final currentRoute = _RouteData.ofRoute(route);
    final newRoute = _RouteData.ofRoute(previousRoute);

    if (currentRoute.isBottomSheet || currentRoute.isDialog) {
      Get.log("CLOSE ${currentRoute.name}");
    } else if (currentRoute.isGetPageRoute) {
      Get.log("CLOSE TO ROUTE ${currentRoute.name}");
    }
    if (previousRoute != null) {
      RouterReportManager.instance.reportCurrentRoute(previousRoute);
    }

    // Here we use a 'inverse didPush set', meaning that we use
    // previous route instead of 'route' because this is
    // a 'inverse push'
    _routeSend?.update((value) {
      // Only PageRoute is allowed to change current value
      if (previousRoute is PageRoute) {
        value.current = _extractRouteName(previousRoute) ?? '';
        value.previous = newRoute.name ?? '';
      } else if (value.previous.isNotEmpty) {
        value.current = value.previous;
      }

      value.args = previousRoute?.settings.arguments;
      value.route = previousRoute;
      value.isBack = true;
      value.removed = '';
      value.isBottomSheet = newRoute.isBottomSheet;
      value.isDialog = newRoute.isDialog;
    });

    routing?.call(_routeSend);
  }

  @override
  void didPush(Route route, Route? previousRoute) {
    super.didPush(route, previousRoute);
    final newRoute = _RouteData.ofRoute(route);

    if (newRoute.isBottomSheet || newRoute.isDialog) {
      Get.log("OPEN ${newRoute.name}");
    } else if (newRoute.isGetPageRoute) {
      Get.log("GOING TO ROUTE ${newRoute.name}");
    }

    RouterReportManager.instance.reportCurrentRoute(route);
    _routeSend?.update((value) {
      if (route is PageRoute) {
        value.current = newRoute.name ?? '';
      }
      final previousRouteName = _extractRouteName(previousRoute);
      if (previousRouteName != null) {
        value.previous = previousRouteName;
      }

      value.args = route.settings.arguments;
      value.route = route;
      value.isBack = false;
      value.removed = '';
      value.isBottomSheet =
          newRoute.isBottomSheet ? true : value.isBottomSheet ?? false;
      value.isDialog = newRoute.isDialog ? true : value.isDialog ?? false;
    });

    if (routing != null) {
      routing!(_routeSend);
    }
  }

  @override
  void didRemove(Route route, Route? previousRoute) {
    super.didRemove(route, previousRoute);
    final routeName = _extractRouteName(route);
    final currentRoute = _RouteData.ofRoute(route);
    final previousRouteName = _extractRouteName(previousRoute);

    Get.log("REMOVING ROUTE $routeName");
    Get.log("PREVIOUS ROUTE $previousRouteName");

    _routeSend?.update((value) {
      value.route = previousRoute;
      value.isBack = false;
      value.removed = routeName ?? '';
      value.previous = previousRouteName ?? '';
      value.isBottomSheet =
          currentRoute.isBottomSheet ? false : value.isBottomSheet;
      value.isDialog = currentRoute.isDialog ? false : value.isDialog;
    });

    if (route is GetPageRoute) {
      RouterReportManager.instance.reportRouteWillDispose(route);
    }
    routing?.call(_routeSend);
  }

  @override
  void didReplace({Route? newRoute, Route? oldRoute}) {
    super.didReplace(newRoute: newRoute, oldRoute: oldRoute);
    final newName = _extractRouteName(newRoute);
    final oldName = _extractRouteName(oldRoute);
    final currentRoute = _RouteData.ofRoute(oldRoute);

    Get.log("REPLACE ROUTE $oldName");
    Get.log("NEW ROUTE $newName");

    if (newRoute != null) {
      RouterReportManager.instance.reportCurrentRoute(newRoute);
    }

    _routeSend?.update((value) {
      // Only PageRoute is allowed to change current value
      if (newRoute is PageRoute) {
        value.current = newName ?? '';
      }

      value.args = newRoute?.settings.arguments;
      value.route = newRoute;
      value.isBack = false;
      value.removed = '';
      value.previous = oldName ?? '';
      value.isBottomSheet =
          currentRoute.isBottomSheet ? false : value.isBottomSheet;
      value.isDialog = currentRoute.isDialog ? false : value.isDialog;
    });
    if (oldRoute is GetPageRoute) {
      RouterReportManager.instance.reportRouteWillDispose(oldRoute);
    }

    routing?.call(_routeSend);
  }
}

//TODO: Use copyWith, and remove mutate variables
class Routing {
  String current;
  String previous;
  dynamic args;
  String removed;
  Route<dynamic>? route;
  bool? isBack;
  bool? isBottomSheet;
  bool? isDialog;

  Routing({
    this.current = '',
    this.previous = '',
    this.args,
    this.removed = '',
    this.route,
    this.isBack,
    this.isBottomSheet,
    this.isDialog,
  });

  void update(void Function(Routing value) fn) {
    fn(this);
  }
}

/// This is basically a util for rules about 'what a route is'
class _RouteData {
  final bool isGetPageRoute;
  final bool isBottomSheet;
  final bool isDialog;
  final String? name;

  const _RouteData({
    required this.name,
    required this.isGetPageRoute,
    required this.isBottomSheet,
    required this.isDialog,
  });

  factory _RouteData.ofRoute(Route? route) {
    return _RouteData(
      name: _extractRouteName(route),
      isGetPageRoute: route is GetPageRoute,
      isDialog: route is GetDialogRoute,
      isBottomSheet: route is GetModalBottomSheetRoute,
    );
  }
}


Instructions for the chapter (Generate content in English unless specified otherwise):
- Start with a clear heading (e.g., `# Chapter 8: RouterReportManager
`). Use the provided concept name.

- If this is not the first chapter, begin with a brief transition from the previous chapter, referencing it with a proper Markdown link using its name.

- Begin with a high-level motivation explaining what problem this abstraction solves. Start with a central use case as a concrete example. The whole chapter should guide the reader to understand how to solve this use case. Make it very minimal and friendly to beginners.

- If the abstraction is complex, break it down into key concepts. Explain each concept one-by-one in a very beginner-friendly way.

- Explain how to use this abstraction to solve the use case. Give example inputs and outputs for code snippets (if the output isn't values, describe at a high level what will happen).

- Each code block should be BELOW 10 lines! If longer code blocks are needed, break them down into smaller pieces and walk through them one-by-one. Aggresively simplify the code to make it minimal. Use comments to skip non-important implementation details. Each code block should have a beginner friendly explanation right after it.

- Describe the internal implementation to help understand what's under the hood. First provide a non-code or code-light walkthrough on what happens step-by-step when the abstraction is called. It's recommended to use a simple sequenceDiagram with a dummy example - keep it minimal with at most 5 participants to ensure clarity. If participant name has space, use: `participant QP as Query Processing`. .

- Then dive deeper into code for the internal implementation with references to files. Provide example code blocks, but make them similarly simple and beginner-friendly. Explain.

- IMPORTANT: When you need to refer to other core abstractions covered in other chapters, ALWAYS use proper Markdown links like this: [Chapter Title](filename.md). Use the Complete Tutorial Structure above to find the correct filename and the chapter title. Translate the surrounding text.

- Use mermaid diagrams to illustrate complex concepts (```mermaid``` format). .

- Heavily use analogies and examples throughout to help beginners understand.

- End the chapter with a brief conclusion that summarizes what was learned and provides a transition to the next chapter. If there is a next chapter, use a proper Markdown link: [Next Chapter Title](next_chapter_filename).

- Ensure the tone is welcoming and easy for a newcomer to understand.

- Output *only* the Markdown content for this chapter.

Now, directly provide a super beginner-friendly Markdown output (DON'T need ```markdown``` tags):

2025-05-16 11:13:19,011 - INFO - RESPONSE: # Chapter 8: RouterReportManager

Welcome to the final chapter of this section! In [Chapter 7: Transition System (GetPageRouteTransitionMixin, CustomTransition, Transitions)](07_transition_system__getpageroutetransitionmixin__customtransition__transitions__.md), we explored how to add beautiful animations to your screen navigations. Now, let's dive into a crucial behind-the-scenes component that ensures GetX manages memory efficiently as you navigate: the `RouterReportManager`.

## The Unsung Hero: Automatic Memory Management

Have you ever put a controller on a page using `Get.put(MyController())` and wondered what happens to that controller when you navigate away from the page? Does it just stay in memory forever?

In many cases, if not handled carefully, this could lead to memory leaks – your app consuming more and more memory over time. GetX, however, has a "smart memory management" system, and `RouterReportManager` is its core engine.

Think of `RouterReportManager` as the **chief operations officer** for your app's routes and the resources (like controllers or services) associated with them. It doesn't make a grand appearance on stage, but it works diligently backstage to ensure everything runs smoothly and efficiently. Its main job is to know which resources belong to which route, and to clean them up when they're no longer needed.

## The Air Traffic Controller for Your Routes and Dependencies

Let's use an analogy: Imagine `RouterReportManager` as an **Air Traffic Controller (ATC)** at a busy airport. Each **route** (screen/page) in your app is like an airplane, and each **dependency** (like a controller you `Get.put()` for that page) is like a passenger or a piece of cargo specifically for that flight.

Here's how the "ATC" (`RouterReportManager`) operates:

1.  **Flight Arrival (Route Pushed): `reportCurrentRoute(newRoute)`**
    *   When a new screen pops up (e.g., you navigate to `UserPage`), GetX tells the ATC, "Flight `UserPage` has just arrived and is now the active flight."
    *   The ATC logs this arrival.

2.  **Boarding Passengers & Loading Cargo (Dependency Linked to Route): `reportDependencyLinkedToRoute(dependencyKey)`**
    *   When you use `Get.put(UserController())` on `UserPage`, GetX informs the ATC, "Passenger `UserController` (identified by its unique key) is boarding Flight `UserPage`."
    *   The ATC adds `UserController` to the manifest for Flight `UserPage`.

3.  **Flight Preparing for Departure (Route Will Be Disposed): `reportRouteWillDispose(disposedRoute)`**
    *   Just before a screen is about to be removed (e.g., you press "back" from `UserPage`), GetX gives a heads-up to the ATC: "Flight `UserPage` is preparing for departure and will soon be off the active list."
    *   The ATC can perform some pre-departure checks or cleanup for passengers created with `Get.create()` (a more advanced way GetX manages some dependencies).

4.  **Flight Departure & Deboarding (Route Disposed & Dependencies Removed): `reportRouteDispose(disposedRoute)` & `_removeDependencyByRoute(routeName)`**
    *   Once `UserPage` is actually removed from the screen, GetX informs the ATC, "Flight `UserPage` has departed."
    *   The ATC then consults its manifest for Flight `UserPage`. For every passenger (`UserController`) listed:
        *   It instructs the ground crew (`Get.delete(key: passengerKey)`) to deboard that passenger – meaning the `UserController` instance is removed from memory.
    *   This ensures that passengers (controllers) don't just linger around the airport (your app's memory) after their flight has left!

This process is key to GetX's acclaimed smart memory management. It ensures resources are allocated when needed and, crucially, deallocated when the route they belong to is no longer active.

## How GetX Components Interact with the "ATC"

You usually don't call `RouterReportManager.instance.someMethod()` directly. Instead, other parts of GetX that you *do* use (like `GetPageRoute` or even `Get.put()`) communicate with it.

When a route is navigated to or away from, GetX's route objects (like `GetPageRoute` for regular pages, `GetDialogRoute` for dialogs, and `GetModalBottomSheetRoute` for bottom sheets) automatically notify the `RouterReportManager`.

Let's look at how a typical page (`GetPageRoute`) talks to the ATC:

```dart
// Simplified from lib/get_navigation/src/routes/default_route.dart
// Inside GetPageRoute which uses PageRouteReportMixin

mixin PageRouteReportMixin<T> on Route<T> {
  @override
  void install() { // Called when the route is pushed and becomes active
    super.install();
    // "ATC, this route (me!) is now the current flight."
    RouterReportManager.instance.reportCurrentRoute(this);
  }

  @override
  void dispose() { // Called when the route is popped and removed
    super.dispose();
    // "ATC, this route (me!) has departed. Clean up my passengers."
    RouterReportManager.instance.reportRouteDispose(this);
    // (_child = null;) // Also internal cleanup for the page widget
  }
}
```
*   When a `GetPageRoute` is "installed" (meaning it's pushed onto the navigation stack and becomes visible), it calls `RouterReportManager.instance.reportCurrentRoute(this)`.
*   When it's "disposed" (popped from the stack), it calls `RouterReportManager.instance.reportRouteDispose(this)`.

Dialogs and BottomSheets do something similar:

```dart
// Simplified from lib/get_navigation/src/dialog/dialog_route.dart
class GetDialogRoute<T> extends PopupRoute<T> {
  GetDialogRoute({ /* ... */ }) {
    // When a dialog is created: "ATC, this dialog is now the current flight."
    RouterReportManager.instance.reportCurrentRoute(this);
  }

  @override
  void dispose() {
    // When a dialog is closed: "ATC, this dialog flight has departed."
    RouterReportManager.instance.reportRouteDispose(this);
    super.dispose();
  }
  // ...
}
```
So, as you navigate, open dialogs, or show bottom sheets, these components are constantly keeping `RouterReportManager` informed.

The `GetObserver` (from `lib/get_navigation/src/routes/observers/route_observer.dart`), which you can add to your `GetMaterialApp`'s `navigatorObservers` list for custom logging or analytics, also interacts with `RouterReportManager` to keep it updated on route changes.

## Inside the Control Tower: `RouterReportManager`'s Logic

The `RouterReportManager` (from `lib/get_navigation/src/router_report.dart`) itself uses a few key data structures:

*   `_routesKey`: A `Map<T?, List<String>>`. This is the **flight manifest**. `T` is the route object (like an instance of `GetPageRoute`), and `List<String>` is the list of dependency keys (names of controllers/services) associated with that route.
*   `_current`: Stores the reference to the route that is currently active.

Let's look at simplified versions of its core methods:

1.  **Reporting the Current Route:**
    ```dart
    // Simplified from lib/get_navigation/src/router_report.dart
    T? _current; // T is the type of the route (e.g., Route<dynamic>)

    void reportCurrentRoute(T newRoute) {
      _current = newRoute; // "Okay, noted. 'newRoute' is now the active flight."
    }
    ```

2.  **Linking a Dependency (Passenger) to the Current Route (Flight):**
    ```dart
    // Simplified from lib/get_navigation/src/router_report.dart
    final Map<T?, List<String>> _routesKey = {};

    void reportDependencyLinkedToRoute(String dependencyKey) {
      if (_current == null) return; // No active flight? Can't board.
      _routesKey.putIfAbsent(_current, () => <String>[]).add(dependencyKey);
      // "Passenger 'dependencyKey' added to manifest of flight '_current'."
    }
    ```
    When you use `Get.put(MyController())`, GetX (if `smartManagement` is active) eventually calls this method to link `MyController`'s internal key to the `_current` route.

3.  **Removing Dependencies for a Departed Route:**
    This is the crucial cleanup step.
    ```dart
    // Simplified from lib/get_navigation/src/router_report.dart
    void _removeDependencyByRoute(T routeName) { // 'routeName' is the departed flight
      final keysToRemove = <String>[];
      _routesKey[routeName]?.forEach(keysToRemove.add); // Get all passengers for this flight

      for (final dependencyKey in keysToRemove) {
        // "Ground crew, deboard passenger 'dependencyKey'!"
        final bool wasDeleted = Get.delete(key: dependencyKey);
        if (wasDeleted) {
          // If successfully deboarded, remove from this flight's manifest
          _routesKey[routeName]?.remove(dependencyKey);
        }
      }

      _routesKey.remove(routeName); // Remove the flight manifest itself
                                   // as the flight is gone.
    }
    ```
    When `reportRouteDispose(route)` is called, it will eventually trigger `_removeDependencyByRoute(route)`. This method iterates through all dependency keys linked to the disposed `route` and calls `Get.delete()` for each one. `Get.delete()` is GetX's way of removing a controller/service instance from its internal registry and calling its `onClose()` method if it's a `GetxController`.

    > **Smart Management:** This intelligent cleanup behavior is typically controlled by `GetMaterialApp`'s `smartManagement` property. Options like `SmartManagement.full` (default) ensure this comprehensive cleanup. `SmartManagement.onlyBuilder` would only clean up controllers in `GetBuilder`s, and `SmartManagement.keepFactory` keeps the factory that creates the controller but disposes of the instance.

## Visualizing the Process: A Navigation Scenario

Let's trace a simple scenario:
1.  You navigate from `PageA` to `PageB`.
2.  `PageB` uses `Get.put(PageBController())`.
3.  You then navigate back from `PageB` to `PageA`.

```mermaid
sequenceDiagram
    participant User as User Action
    participant Navigator as Flutter/GetX Navigator
    participant PageBRoute as PageB's GetPageRoute
    participant Get as Get (Static Interface)
    participant RRM as RouterReportManager
    participant PageBCtrl as PageBController

    User->>Navigator: Navigates to PageB
    Navigator->>PageBRoute: Creates & installs PageBRoute
    PageBRoute->>RRM: reportCurrentRoute(PageBRoute)
    RRM->>RRM: Sets PageBRoute as _current

    User->>Get: Calls Get.put(PageBController()) in PageB
    Get->>Get: Creates PageBController instance
    Get->>RRM: reportDependencyLinkedToRoute("PageBController_key")
    RRM->>RRM: Adds "PageBController_key" to _routesKey[PageBRoute]

    User->>Navigator: Navigates back (pops PageB)
    Navigator->>PageBRoute: Disposes PageBRoute
    PageBRoute->>RRM: reportRouteDispose(PageBRoute)
    RRM->>RRM: Calls _removeDependencyByRoute(PageBRoute)
    RRM->>Get: Get.delete(key: "PageBController_key")
    Get->>PageBCtrl: Calls PageBController.onClose() & removes instance
```

This diagram shows `RouterReportManager` orchestrating the link between `PageBController` and `PageBRoute`, and ensuring `PageBController` is cleaned up when `PageBRoute` is gone.

## Why Is This Important For You?

Even though you might not interact with `RouterReportManager` directly, understanding its role is beneficial:

*   **Automatic Cleanup:** You get automatic memory management for controllers and dependencies scoped to routes. This means less boilerplate for manual cleanup and fewer chances of memory leaks.
*   **Efficiency:** Your app uses resources more efficiently because unused controllers are removed from memory.
*   **Confidence:** You can trust GetX to handle the lifecycle of your route-specific dependencies correctly, letting you focus on building features.

`RouterReportManager` is a testament to GetX's philosophy of providing powerful features with a simple API, often by handling complexities internally.

## Conclusion

The `RouterReportManager` is a vital, albeit often invisible, part of GetX's navigation and dependency management system. Acting like an air traffic controller, it meticulously tracks which dependencies belong to which routes and ensures they are cleaned up when their routes are no longer active. This underpins GetX's smart memory management, contributing to more robust, efficient, and leak-free Flutter applications.

Understanding components like `RouterReportManager` helps you appreciate the depth and thoughtfulness of the GetX framework, even if your daily interactions are with higher-level APIs like `Get.toNamed()` and `Get.put()`.

This concludes our current journey through these GetX navigation and routing concepts. Happy coding with GetX!
