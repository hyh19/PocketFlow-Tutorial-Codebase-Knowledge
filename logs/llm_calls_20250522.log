2025-05-22 23:56:00,551 - INFO - PROMPT: Hello, how are you?
2025-05-22 23:56:02,359 - INFO - RESPONSE: I'm doing well, thank you for asking! I hope you are having a good day too. How can I help you today?
2025-05-22 23:56:26,355 - INFO - PROMPT: 
For the project `flutter (overlay.dart)`:

Codebase Context:
--- File Index 0: packages/flutter/lib/src/widgets/overlay.dart ---
// Copyright 2014 The Flutter Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

/// @docImport 'package:flutter/cupertino.dart';
/// @docImport 'package:flutter/material.dart';
///
/// @docImport 'app.dart';
/// @docImport 'drag_target.dart';
/// @docImport 'implicit_animations.dart';
/// @docImport 'media_query.dart';
/// @docImport 'navigator.dart';
/// @docImport 'routes.dart';
/// @docImport 'scroll_view.dart';
/// @docImport 'sliver.dart';
/// @docImport 'text.dart';
library;

import 'dart:collection';

import 'package:flutter/foundation.dart';
import 'package:flutter/rendering.dart';
import 'package:flutter/scheduler.dart';

import 'basic.dart';
import 'framework.dart';
import 'lookup_boundary.dart';
import 'ticker_provider.dart';

const String _flutterWidgetsLibrary = 'package:flutter/widgets.dart';

// Examples can assume:
// late BuildContext context;

// * OverlayEntry Implementation

/// A place in an [Overlay] that can contain a widget.
///
/// Overlay entries are inserted into an [Overlay] using the
/// [OverlayState.insert] or [OverlayState.insertAll] functions. To find the
/// closest enclosing overlay for a given [BuildContext], use the [Overlay.of]
/// function.
///
/// An overlay entry can be in at most one overlay at a time. To remove an entry
/// from its overlay, call the [remove] function on the overlay entry.
///
/// Because an [Overlay] uses a [Stack] layout, overlay entries can use
/// [Positioned] and [AnimatedPositioned] to position themselves within the
/// overlay.
///
/// For example, [Draggable] uses an [OverlayEntry] to show the drag avatar that
/// follows the user's finger across the screen after the drag begins. Using the
/// overlay to display the drag avatar lets the avatar float over the other
/// widgets in the app. As the user's finger moves, draggable calls
/// [markNeedsBuild] on the overlay entry to cause it to rebuild. In its build,
/// the entry includes a [Positioned] with its top and left property set to
/// position the drag avatar near the user's finger. When the drag is over,
/// [Draggable] removes the entry from the overlay to remove the drag avatar
/// from view.
///
/// By default, if there is an entirely [opaque] entry over this one, then this
/// one will not be included in the widget tree (in particular, stateful widgets
/// within the overlay entry will not be instantiated). To ensure that your
/// overlay entry is still built even if it is not visible, set [maintainState]
/// to true. This is more expensive, so should be done with care. In particular,
/// if widgets in an overlay entry with [maintainState] set to true repeatedly
/// call [State.setState], the user's battery will be drained unnecessarily.
///
/// [OverlayEntry] is a [Listenable] that notifies when the widget built by
/// [builder] is mounted or unmounted, whose exact state can be queried by
/// [mounted]. After the owner of the [OverlayEntry] calls [remove] and then
/// [dispose], the widget may not be immediately removed from the widget tree.
/// As a result listeners of the [OverlayEntry] can get notified for one last
/// time after the [dispose] call, when the widget is eventually unmounted.
///
/// {@macro flutter.widgets.overlayPortalVsOverlayEntry}
///
/// See also:
///
///  * [OverlayPortal], an alternative API for inserting widgets into an
///    [Overlay] using a builder callback.
///  * [Overlay], a stack of entries that can be managed independently.
///  * [OverlayState], the current state of an Overlay.
///  * [WidgetsApp], a convenience widget that wraps a number of widgets that
///    are commonly required for an application.
///  * [MaterialApp], a convenience widget that wraps a number of widgets that
///    are commonly required for Material Design applications.
class OverlayEntry implements Listenable {
  /// Creates an overlay entry.
  ///
  /// To insert the entry into an [Overlay], first find the overlay using
  /// [Overlay.of] and then call [OverlayState.insert]. To remove the entry,
  /// call [remove] on the overlay entry itself.
  OverlayEntry({
    required this.builder,
    bool opaque = false,
    bool maintainState = false,
    this.canSizeOverlay = false,
  }) : _opaque = opaque,
       _maintainState = maintainState {
    if (kFlutterMemoryAllocationsEnabled) {
      _maybeDispatchObjectCreation();
    }
  }

  /// This entry will include the widget built by this builder in the overlay at
  /// the entry's position.
  ///
  /// To cause this builder to be called again, call [markNeedsBuild] on this
  /// overlay entry.
  final WidgetBuilder builder;

  /// Whether this entry occludes the entire overlay.
  ///
  /// If an entry claims to be opaque, then, for efficiency, the overlay will
  /// skip building entries below that entry unless they have [maintainState]
  /// set.
  bool get opaque => _opaque;
  bool _opaque;
  set opaque(bool value) {
    assert(!_disposedByOwner);
    if (_opaque == value) {
      return;
    }
    _opaque = value;
    _overlay?._didChangeEntryOpacity();
  }

  /// Whether this entry must be included in the tree even if there is a fully
  /// [opaque] entry above it.
  ///
  /// By default, if there is an entirely [opaque] entry over this one, then this
  /// one will not be included in the widget tree (in particular, stateful widgets
  /// within the overlay entry will not be instantiated). To ensure that your
  /// overlay entry is still built even if it is not visible, set [maintainState]
  /// to true. This is more expensive, so should be done with care. In particular,
  /// if widgets in an overlay entry with [maintainState] set to true repeatedly
  /// call [State.setState], the user's battery will be drained unnecessarily.
  ///
  /// This is used by the [Navigator] and [Route] objects to ensure that routes
  /// are kept around even when in the background, so that [Future]s promised
  /// from subsequent routes will be handled properly when they complete.
  bool get maintainState => _maintainState;
  bool _maintainState;
  set maintainState(bool value) {
    assert(!_disposedByOwner);
    if (_maintainState == value) {
      return;
    }
    _maintainState = value;
    assert(_overlay != null);
    _overlay!._didChangeEntryOpacity();
  }

  /// Whether the content of this [OverlayEntry] can be used to size the
  /// [Overlay].
  ///
  /// In most situations the overlay sizes itself based on its incoming
  /// constraints to be as large as possible. However, if that would result in
  /// an infinite size, it has to rely on one of its children to size itself. In
  /// this situation, the overlay will consult the topmost non-[Positioned]
  /// overlay entry that has this property set to true, lay it out with the
  /// incoming [BoxConstraints] of the overlay, and force all other
  /// non-[Positioned] overlay entries to have the same size. The [Positioned]
  /// entries are laid out as usual based on the calculated size of the overlay.
  ///
  /// Overlay entries that set this to true must be able to handle unconstrained
  /// [BoxConstraints].
  ///
  /// Setting this to true has no effect if the overlay entry uses a [Positioned]
  /// widget to position itself in the overlay.
  final bool canSizeOverlay;

  /// Whether the [OverlayEntry] is currently mounted in the widget tree.
  ///
  /// The [OverlayEntry] notifies its listeners when this value changes.
  bool get mounted => _overlayEntryStateNotifier?.value != null;

  /// The currently mounted `_OverlayEntryWidgetState` built using this [OverlayEntry].
  ValueNotifier<_OverlayEntryWidgetState?>? _overlayEntryStateNotifier =
      ValueNotifier<_OverlayEntryWidgetState?>(null);

  // TODO(polina-c): stop duplicating code across disposables
  // https://github.com/flutter/flutter/issues/137435
  /// Dispatches event of object creation to [FlutterMemoryAllocations.instance].
  void _maybeDispatchObjectCreation() {
    if (kFlutterMemoryAllocationsEnabled) {
      FlutterMemoryAllocations.instance.dispatchObjectCreated(
        library: _flutterWidgetsLibrary,
        className: '$OverlayEntry',
        object: this,
      );
    }
  }

  @override
  void addListener(VoidCallback listener) {
    assert(!_disposedByOwner);
    _overlayEntryStateNotifier?.addListener(listener);
  }

  @override
  void removeListener(VoidCallback listener) {
    _overlayEntryStateNotifier?.removeListener(listener);
  }

  OverlayState? _overlay;
  final GlobalKey<_OverlayEntryWidgetState> _key = GlobalKey<_OverlayEntryWidgetState>();

  /// Remove this entry from the overlay.
  ///
  /// This should only be called once.
  ///
  /// This method removes this overlay entry from the overlay immediately. The
  /// UI will be updated in the same frame if this method is called before the
  /// overlay rebuild in this frame; otherwise, the UI will be updated in the
  /// next frame. This means that it is safe to call during builds, but also
  /// that if you do call this after the overlay rebuild, the UI will not update
  /// until the next frame (i.e. many milliseconds later).
  void remove() {
    assert(_overlay != null);
    assert(!_disposedByOwner);
    final OverlayState overlay = _overlay!;
    _overlay = null;
    if (!overlay.mounted) {
      return;
    }

    overlay._entries.remove(this);
    if (SchedulerBinding.instance.schedulerPhase == SchedulerPhase.persistentCallbacks) {
      SchedulerBinding.instance.addPostFrameCallback((Duration duration) {
        overlay._markDirty();
      }, debugLabel: 'OverlayEntry.markDirty');
    } else {
      overlay._markDirty();
    }
  }

  /// Cause this entry to rebuild during the next pipeline flush.
  ///
  /// You need to call this function if the output of [builder] has changed.
  void markNeedsBuild() {
    assert(!_disposedByOwner);
    _key.currentState?._markNeedsBuild();
  }

  void _didUnmount() {
    assert(!mounted);
    if (_disposedByOwner) {
      _overlayEntryStateNotifier?.dispose();
      _overlayEntryStateNotifier = null;
    }
  }

  bool _disposedByOwner = false;

  /// Discards any resources used by this [OverlayEntry].
  ///
  /// This method must be called after [remove] if the [OverlayEntry] is
  /// inserted into an [Overlay].
  ///
  /// After this is called, the object is not in a usable state and should be
  /// discarded (calls to [addListener] will throw after the object is disposed).
  /// However, the listeners registered may not be immediately released until
  /// the widget built using this [OverlayEntry] is unmounted from the widget
  /// tree.
  ///
  /// This method should only be called by the object's owner.
  void dispose() {
    assert(!_disposedByOwner);
    assert(
      _overlay == null,
      'An OverlayEntry must first be removed from the Overlay before dispose is called.',
    );
    if (kFlutterMemoryAllocationsEnabled) {
      FlutterMemoryAllocations.instance.dispatchObjectDisposed(object: this);
    }
    _disposedByOwner = true;
    if (!mounted) {
      // If we're still mounted when disposed, then this will be disposed in
      // _didUnmount, to allow notifications to occur until the entry is
      // unmounted.
      _overlayEntryStateNotifier?.dispose();
      _overlayEntryStateNotifier = null;
    }
  }

  @override
  String toString() =>
      '${describeIdentity(this)}(opaque: $opaque; maintainState: $maintainState)${_disposedByOwner ? "(DISPOSED)" : ""}';
}

class _OverlayEntryWidget extends StatefulWidget {
  const _OverlayEntryWidget({
    required Key super.key,
    required this.entry,
    required this.overlayState,
    this.tickerEnabled = true,
  });

  final OverlayEntry entry;
  final OverlayState overlayState;
  final bool tickerEnabled;

  @override
  _OverlayEntryWidgetState createState() => _OverlayEntryWidgetState();
}

class _OverlayEntryWidgetState extends State<_OverlayEntryWidget> {
  late _RenderTheater _theater;

  // Manages the stack of theater children whose paint order are sorted by their
  // _zOrderIndex. The children added by OverlayPortal are added to this linked
  // list, and they will be shown _above_ the OverlayEntry tied to this widget.
  // The children with larger zOrderIndex values (i.e. those called `show`
  // recently) will be painted last.
  //
  // This linked list is lazily created in `_add`, and the entries are added/removed
  // via `_add`/`_remove`, called by OverlayPortals lower in the tree. `_add` or
  // `_remove` does not cause this widget to rebuild, the linked list will be
  // read by _RenderTheater as part of its render child model. This would ideally
  // be in a RenderObject but there may not be RenderObjects between
  // _RenderTheater and the render subtree OverlayEntry builds.
  LinkedList<_OverlayEntryLocation>? _sortedTheaterSiblings;

  // Worst-case O(N), N being the number of children added to the top spot in
  // the same frame. This can be a bit expensive when there's a lot of global
  // key reparenting in the same frame but N is usually a small number.
  void _add(_OverlayEntryLocation child) {
    assert(mounted);
    final LinkedList<_OverlayEntryLocation> children =
        _sortedTheaterSiblings ??= LinkedList<_OverlayEntryLocation>();
    assert(!children.contains(child));
    _OverlayEntryLocation? insertPosition = children.isEmpty ? null : children.last;
    while (insertPosition != null && insertPosition._zOrderIndex > child._zOrderIndex) {
      insertPosition = insertPosition.previous;
    }
    if (insertPosition == null) {
      children.addFirst(child);
    } else {
      insertPosition.insertAfter(child);
    }
    assert(children.contains(child));
  }

  void _remove(_OverlayEntryLocation child) {
    assert(_sortedTheaterSiblings != null);
    final bool wasInCollection = _sortedTheaterSiblings?.remove(child) ?? false;
    assert(wasInCollection);
  }

  // Returns an Iterable that traverse the children in the child model in paint
  // order (from farthest to the user to the closest to the user).
  //
  // The iterator should be safe to use even when the child model is being
  // mutated. The reason for that is it's allowed to add/remove/move deferred
  // children to a _RenderTheater during performLayout, but the affected
  // children don't have to be laid out in the same performLayout call.
  late final Iterable<RenderBox> _paintOrderIterable = _createChildIterable(reversed: false);
  // An Iterable that traverse the children in the child model in
  // hit-test order (from closest to the user to the farthest to the user).
  late final Iterable<RenderBox> _hitTestOrderIterable = _createChildIterable(reversed: true);

  // The following uses sync* because hit-testing is lazy, and LinkedList as a
  // Iterable doesn't support concurrent modification.
  Iterable<RenderBox> _createChildIterable({required bool reversed}) sync* {
    final LinkedList<_OverlayEntryLocation>? children = _sortedTheaterSiblings;
    if (children == null || children.isEmpty) {
      return;
    }
    _OverlayEntryLocation? candidate = reversed ? children.last : children.first;
    while (candidate != null) {
      final RenderBox? renderBox = candidate._overlayChildRenderBox;
      candidate = reversed ? candidate.previous : candidate.next;
      if (renderBox != null) {
        yield renderBox;
      }
    }
  }

  @override
  void initState() {
    super.initState();
    widget.entry._overlayEntryStateNotifier!.value = this;
    _theater = context.findAncestorRenderObjectOfType<_RenderTheater>()!;
    assert(_sortedTheaterSiblings == null);
  }

  @override
  void didUpdateWidget(_OverlayEntryWidget oldWidget) {
    super.didUpdateWidget(oldWidget);
    // OverlayState's build method always returns a RenderObjectWidget _Theater,
    // so it's safe to assume that state equality implies render object equality.
    assert(oldWidget.entry == widget.entry);
    if (oldWidget.overlayState != widget.overlayState) {
      final _RenderTheater newTheater = context.findAncestorRenderObjectOfType<_RenderTheater>()!;
      assert(_theater != newTheater);
      _theater = newTheater;
    }
  }

  @override
  void dispose() {
    widget.entry._overlayEntryStateNotifier?.value = null;
    widget.entry._didUnmount();
    _sortedTheaterSiblings = null;
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    return TickerMode(
      enabled: widget.tickerEnabled,
      child: _RenderTheaterMarker(
        theater: _theater,
        overlayEntryWidgetState: this,
        child: widget.entry.builder(context),
      ),
    );
  }

  void _markNeedsBuild() {
    setState(() {
      /* the state that changed is in the builder */
    });
  }
}

/// A stack of entries that can be managed independently.
///
/// Overlays let independent child widgets "float" visual elements on top of
/// other widgets by inserting them into the overlay's stack. The overlay lets
/// each of these widgets manage their participation in the overlay using
/// [OverlayEntry] objects.
///
/// Although you can create an [Overlay] directly, it's most common to use the
/// overlay created by the [Navigator] in a [WidgetsApp], [CupertinoApp] or a
/// [MaterialApp]. The navigator uses its overlay to manage the visual
/// appearance of its routes.
///
/// The [Overlay] widget uses a custom stack implementation, which is very
/// similar to the [Stack] widget. The main use case of [Overlay] is related to
/// navigation and being able to insert widgets on top of the pages in an app.
/// For layout purposes unrelated to navigation, consider using [Stack] instead.
///
/// An [Overlay] widget requires a [Directionality] widget to be in scope, so
/// that it can resolve direction-sensitive coordinates of any
/// [Positioned.directional] children.
///
/// For widgets drawn in an [OverlayEntry], do not assume that the size of the
/// [Overlay] is the size returned by [MediaQuery.sizeOf]. Nested overlays can
/// have different sizes.
///
/// {@tool dartpad}
/// This example shows how to use the [Overlay] to highlight the [NavigationBar]
/// destination.
///
/// ** See code in examples/api/lib/widgets/overlay/overlay.0.dart **
/// {@end-tool}
///
/// See also:
///
///  * [OverlayEntry], the class that is used for describing the overlay entries.
///  * [OverlayState], which is used to insert the entries into the overlay.
///  * [WidgetsApp], which inserts an [Overlay] widget indirectly via its [Navigator].
///  * [MaterialApp], which inserts an [Overlay] widget indirectly via its [Navigator].
///  * [CupertinoApp], which inserts an [Overlay] widget indirectly via its [Navigator].
///  * [Stack], which allows directly displaying a stack of widgets.
class Overlay extends StatefulWidget {
  /// Creates an overlay.
  ///
  /// The initial entries will be inserted into the overlay when its associated
  /// [OverlayState] is initialized.
  ///
  /// Rather than creating an overlay, consider using the overlay that is
  /// created by the [Navigator] in a [WidgetsApp], [CupertinoApp], or a
  /// [MaterialApp] for the application.
  const Overlay({
    super.key,
    this.initialEntries = const <OverlayEntry>[],
    this.clipBehavior = Clip.hardEdge,
  });

  /// Wrap the provided `child` in an [Overlay] to allow other visual elements
  /// (packed in [OverlayEntry]s) to float on top of the child.
  ///
  /// This is a convenience method over the regular [Overlay] constructor: It
  /// creates an [Overlay] and puts the provided `child` in an [OverlayEntry]
  /// at the bottom of that newly created Overlay.
  static Widget wrap({Key? key, Clip clipBehavior = Clip.hardEdge, required Widget child}) {
    return _WrappingOverlay(key: key, clipBehavior: clipBehavior, child: child);
  }

  /// The entries to include in the overlay initially.
  ///
  /// These entries are only used when the [OverlayState] is initialized. If you
  /// are providing a new [Overlay] description for an overlay that's already in
  /// the tree, then the new entries are ignored.
  ///
  /// To add entries to an [Overlay] that is already in the tree, use
  /// [Overlay.of] to obtain the [OverlayState] (or assign a [GlobalKey] to the
  /// [Overlay] widget and obtain the [OverlayState] via
  /// [GlobalKey.currentState]), and then use [OverlayState.insert] or
  /// [OverlayState.insertAll].
  ///
  /// To remove an entry from an [Overlay], use [OverlayEntry.remove].
  final List<OverlayEntry> initialEntries;

  /// {@macro flutter.material.Material.clipBehavior}
  ///
  /// Defaults to [Clip.hardEdge].
  final Clip clipBehavior;

  /// The [OverlayState] from the closest instance of [Overlay] that encloses
  /// the given context within the closest [LookupBoundary], and, in debug mode,
  /// will throw if one is not found.
  ///
  /// In debug mode, if the `debugRequiredFor` argument is provided and an
  /// overlay isn't found, then this function will throw an exception containing
  /// the runtime type of the given widget in the error message. The exception
  /// attempts to explain that the calling [Widget] (the one given by the
  /// `debugRequiredFor` argument) needs an [Overlay] to be present to function.
  /// If `debugRequiredFor` is not supplied, then the error message is more
  /// generic.
  ///
  /// Typical usage is as follows:
  ///
  /// ```dart
  /// OverlayState overlay = Overlay.of(context);
  /// ```
  ///
  /// If `rootOverlay` is set to true, the state from the furthest instance of
  /// this class is given instead. Useful for installing overlay entries above
  /// all subsequent instances of [Overlay].
  ///
  /// This method can be expensive (it walks the element tree).
  ///
  /// See also:
  ///
  /// * [Overlay.maybeOf] for a similar function that returns null if an
  ///   [Overlay] is not found.
  static OverlayState of(
    BuildContext context, {
    bool rootOverlay = false,
    Widget? debugRequiredFor,
  }) {
    final OverlayState? result = maybeOf(context, rootOverlay: rootOverlay);
    assert(() {
      if (result == null) {
        final bool hiddenByBoundary = LookupBoundary.debugIsHidingAncestorStateOfType<OverlayState>(
          context,
        );
        final List<DiagnosticsNode> information = <DiagnosticsNode>[
          ErrorSummary(
            'No Overlay widget found${hiddenByBoundary ? ' within the closest LookupBoundary' : ''}.',
          ),
          if (hiddenByBoundary)
            ErrorDescription(
              'There is an ancestor Overlay widget, but it is hidden by a LookupBoundary.',
            ),
          ErrorDescription(
            '${debugRequiredFor?.runtimeType ?? 'Some'} widgets require an Overlay widget ancestor for correct operation.',
          ),
          ErrorHint(
            'The most common way to add an Overlay to an application is to include a MaterialApp, CupertinoApp or Navigator widget in the runApp() call.',
          ),
          if (debugRequiredFor != null)
            DiagnosticsProperty<Widget>(
              'The specific widget that failed to find an overlay was',
              debugRequiredFor,
              style: DiagnosticsTreeStyle.errorProperty,
            ),
          if (context.widget != debugRequiredFor)
            context.describeElement(
              'The context from which that widget was searching for an overlay was',
            ),
        ];

        throw FlutterError.fromParts(information);
      }
      return true;
    }());
    return result!;
  }

  /// The [OverlayState] from the closest instance of [Overlay] that encloses
  /// the given context within the closest [LookupBoundary], if any.
  ///
  /// Typical usage is as follows:
  ///
  /// ```dart
  /// OverlayState? overlay = Overlay.maybeOf(context);
  /// ```
  ///
  /// If `rootOverlay` is set to true, the state from the furthest instance of
  /// this class is given instead. Useful for installing overlay entries above
  /// all subsequent instances of [Overlay].
  ///
  /// This method can be expensive (it walks the element tree).
  ///
  /// See also:
  ///
  ///  * [Overlay.of] for a similar function that returns a non-nullable result
  ///    and throws if an [Overlay] is not found.

  static OverlayState? maybeOf(BuildContext context, {bool rootOverlay = false}) {
    return rootOverlay
        ? LookupBoundary.findRootAncestorStateOfType<OverlayState>(context)
        : LookupBoundary.findAncestorStateOfType<OverlayState>(context);
  }

  @override
  OverlayState createState() => OverlayState();
}

/// The current state of an [Overlay].
///
/// Used to insert [OverlayEntry]s into the overlay using the [insert] and
/// [insertAll] functions.
class OverlayState extends State<Overlay> with TickerProviderStateMixin {
  final List<OverlayEntry> _entries = <OverlayEntry>[];

  @protected
  @override
  void initState() {
    super.initState();
    insertAll(widget.initialEntries);
  }

  int _insertionIndex(OverlayEntry? below, OverlayEntry? above) {
    assert(above == null || below == null);
    if (below != null) {
      return _entries.indexOf(below);
    }
    if (above != null) {
      return _entries.indexOf(above) + 1;
    }
    return _entries.length;
  }

  bool _debugCanInsertEntry(OverlayEntry entry) {
    final List<DiagnosticsNode> operandsInformation = <DiagnosticsNode>[
      DiagnosticsProperty<OverlayEntry>(
        'The OverlayEntry was',
        entry,
        style: DiagnosticsTreeStyle.errorProperty,
      ),
      DiagnosticsProperty<OverlayState>(
        'The Overlay the OverlayEntry was trying to insert to was',
        this,
        style: DiagnosticsTreeStyle.errorProperty,
      ),
    ];

    if (!mounted) {
      throw FlutterError.fromParts(<DiagnosticsNode>[
        ErrorSummary('Attempted to insert an OverlayEntry to an already disposed Overlay.'),
        ...operandsInformation,
      ]);
    }

    final OverlayState? currentOverlay = entry._overlay;
    final bool alreadyContainsEntry = _entries.contains(entry);

    if (alreadyContainsEntry) {
      final bool inconsistentOverlayState = !identical(currentOverlay, this);
      throw FlutterError.fromParts(<DiagnosticsNode>[
        ErrorSummary('The specified entry is already present in the target Overlay.'),
        ...operandsInformation,
        if (inconsistentOverlayState)
          ErrorHint('This could be an error in the Flutter framework.')
        else
          ErrorHint(
            'Consider calling remove on the OverlayEntry before inserting it to a different Overlay, '
            'or switching to the OverlayPortal API to avoid manual OverlayEntry management.',
          ),
        if (inconsistentOverlayState)
          DiagnosticsProperty<OverlayState>(
            "The OverlayEntry's current Overlay was",
            currentOverlay,
            style: DiagnosticsTreeStyle.errorProperty,
          ),
      ]);
    }

    if (currentOverlay == null) {
      return true;
    }

    throw FlutterError.fromParts(<DiagnosticsNode>[
      ErrorSummary('The specified entry is already present in a different Overlay.'),
      ...operandsInformation,
      DiagnosticsProperty<OverlayState>(
        "The OverlayEntry's current Overlay was",
        currentOverlay,
        style: DiagnosticsTreeStyle.errorProperty,
      ),
      ErrorHint(
        'Consider calling remove on the OverlayEntry before inserting it to a different Overlay, '
        'or switching to the OverlayPortal API to avoid manual OverlayEntry management.',
      ),
    ]);
  }

  /// Insert the given entry into the overlay.
  ///
  /// If `below` is non-null, the entry is inserted just below `below`.
  /// If `above` is non-null, the entry is inserted just above `above`.
  /// Otherwise, the entry is inserted on top.
  ///
  /// It is an error to specify both `above` and `below`.
  void insert(OverlayEntry entry, {OverlayEntry? below, OverlayEntry? above}) {
    assert(_debugVerifyInsertPosition(above, below));
    assert(_debugCanInsertEntry(entry));
    entry._overlay = this;
    setState(() {
      _entries.insert(_insertionIndex(below, above), entry);
    });
  }

  /// Insert all the entries in the given iterable.
  ///
  /// If `below` is non-null, the entries are inserted just below `below`.
  /// If `above` is non-null, the entries are inserted just above `above`.
  /// Otherwise, the entries are inserted on top.
  ///
  /// It is an error to specify both `above` and `below`.
  void insertAll(Iterable<OverlayEntry> entries, {OverlayEntry? below, OverlayEntry? above}) {
    assert(_debugVerifyInsertPosition(above, below));
    assert(entries.every(_debugCanInsertEntry));
    if (entries.isEmpty) {
      return;
    }
    for (final OverlayEntry entry in entries) {
      assert(entry._overlay == null);
      entry._overlay = this;
    }
    setState(() {
      _entries.insertAll(_insertionIndex(below, above), entries);
    });
  }

  bool _debugVerifyInsertPosition(
    OverlayEntry? above,
    OverlayEntry? below, {
    Iterable<OverlayEntry>? newEntries,
  }) {
    assert(above == null || below == null, 'Only one of `above` and `below` may be specified.');
    assert(
      above == null ||
          (above._overlay == this &&
              _entries.contains(above) &&
              (newEntries?.contains(above) ?? true)),
      'The provided entry used for `above` must be present in the Overlay${newEntries != null ? ' and in the `newEntriesList`' : ''}.',
    );
    assert(
      below == null ||
          (below._overlay == this &&
              _entries.contains(below) &&
              (newEntries?.contains(below) ?? true)),
      'The provided entry used for `below` must be present in the Overlay${newEntries != null ? ' and in the `newEntriesList`' : ''}.',
    );
    return true;
  }

  /// Remove all the entries listed in the given iterable, then reinsert them
  /// into the overlay in the given order.
  ///
  /// Entries mention in `newEntries` but absent from the overlay are inserted
  /// as if with [insertAll].
  ///
  /// Entries not mentioned in `newEntries` but present in the overlay are
  /// positioned as a group in the resulting list relative to the entries that
  /// were moved, as specified by one of `below` or `above`, which, if
  /// specified, must be one of the entries in `newEntries`:
  ///
  /// If `below` is non-null, the group is positioned just below `below`.
  /// If `above` is non-null, the group is positioned just above `above`.
  /// Otherwise, the group is left on top, with all the rearranged entries
  /// below.
  ///
  /// It is an error to specify both `above` and `below`.
  void rearrange(Iterable<OverlayEntry> newEntries, {OverlayEntry? below, OverlayEntry? above}) {
    final List<OverlayEntry> newEntriesList =
        newEntries is List<OverlayEntry> ? newEntries : newEntries.toList(growable: false);
    assert(_debugVerifyInsertPosition(above, below, newEntries: newEntriesList));
    assert(
      newEntriesList.every(
        (OverlayEntry entry) => entry._overlay == null || entry._overlay == this,
      ),
      'One or more of the specified entries are already present in another Overlay.',
    );
    assert(
      newEntriesList.every(
        (OverlayEntry entry) => _entries.indexOf(entry) == _entries.lastIndexOf(entry),
      ),
      'One or more of the specified entries are specified multiple times.',
    );
    if (newEntriesList.isEmpty) {
      return;
    }
    if (listEquals(_entries, newEntriesList)) {
      return;
    }
    final LinkedHashSet<OverlayEntry> old = LinkedHashSet<OverlayEntry>.of(_entries);
    for (final OverlayEntry entry in newEntriesList) {
      entry._overlay ??= this;
    }
    setState(() {
      _entries.clear();
      _entries.addAll(newEntriesList);
      old.removeAll(newEntriesList);
      _entries.insertAll(_insertionIndex(below, above), old);
    });
  }

  void _markDirty() {
    if (mounted) {
      setState(() {});
    }
  }

  /// (DEBUG ONLY) Check whether a given entry is visible (i.e., not behind an
  /// opaque entry).
  ///
  /// This is an O(N) algorithm, and should not be necessary except for debug
  /// asserts. To avoid people depending on it, this function is implemented
  /// only in debug mode, and always returns false in release mode.
  bool debugIsVisible(OverlayEntry entry) {
    bool result = false;
    assert(_entries.contains(entry));
    assert(() {
      for (int i = _entries.length - 1; i > 0; i -= 1) {
        final OverlayEntry candidate = _entries[i];
        if (candidate == entry) {
          result = true;
          break;
        }
        if (candidate.opaque) {
          break;
        }
      }
      return true;
    }());
    return result;
  }

  void _didChangeEntryOpacity() {
    setState(() {
      // We use the opacity of the entry in our build function, which means we
      // our state has changed.
    });
  }

  @protected
  @override
  Widget build(BuildContext context) {
    // This list is filled backwards and then reversed below before
    // it is added to the tree.
    final List<_OverlayEntryWidget> children = <_OverlayEntryWidget>[];
    bool onstage = true;
    int onstageCount = 0;
    for (final OverlayEntry entry in _entries.reversed) {
      if (onstage) {
        onstageCount += 1;
        children.add(_OverlayEntryWidget(key: entry._key, overlayState: this, entry: entry));
        if (entry.opaque) {
          onstage = false;
        }
      } else if (entry.maintainState) {
        children.add(
          _OverlayEntryWidget(
            key: entry._key,
            overlayState: this,
            entry: entry,
            tickerEnabled: false,
          ),
        );
      }
    }
    return _Theater(
      skipCount: children.length - onstageCount,
      clipBehavior: widget.clipBehavior,
      children: children.reversed.toList(growable: false),
    );
  }

  @protected
  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    // TODO(jacobr): use IterableProperty instead as that would
    // provide a slightly more consistent string summary of the List.
    properties.add(DiagnosticsProperty<List<OverlayEntry>>('entries', _entries));
  }
}

class _WrappingOverlay extends StatefulWidget {
  const _WrappingOverlay({super.key, this.clipBehavior = Clip.hardEdge, required this.child});

  final Clip clipBehavior;
  final Widget child;

  @override
  State<_WrappingOverlay> createState() => _WrappingOverlayState();
}

class _WrappingOverlayState extends State<_WrappingOverlay> {
  late final OverlayEntry _entry = OverlayEntry(
    canSizeOverlay: true,
    opaque: true,
    builder: (BuildContext context) {
      return widget.child;
    },
  );

  @override
  void didUpdateWidget(_WrappingOverlay oldWidget) {
    super.didUpdateWidget(oldWidget);
    _entry.markNeedsBuild();
  }

  @override
  void dispose() {
    _entry
      ..remove()
      ..dispose();
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    return Overlay(clipBehavior: widget.clipBehavior, initialEntries: <OverlayEntry>[_entry]);
  }
}

/// Special version of a [Stack], that doesn't layout and render the first
/// [skipCount] children.
///
/// The first [skipCount] children are considered "offstage".
class _Theater extends MultiChildRenderObjectWidget {
  const _Theater({
    this.skipCount = 0,
    this.clipBehavior = Clip.hardEdge,
    required List<_OverlayEntryWidget> super.children,
  }) : assert(skipCount >= 0),
       assert(children.length >= skipCount);

  final int skipCount;

  final Clip clipBehavior;

  @override
  _TheaterElement createElement() => _TheaterElement(this);

  @override
  _RenderTheater createRenderObject(BuildContext context) {
    return _RenderTheater(
      skipCount: skipCount,
      textDirection: Directionality.of(context),
      clipBehavior: clipBehavior,
    );
  }

  @override
  void updateRenderObject(BuildContext context, _RenderTheater renderObject) {
    renderObject
      ..skipCount = skipCount
      ..textDirection = Directionality.of(context)
      ..clipBehavior = clipBehavior;
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties.add(IntProperty('skipCount', skipCount));
  }
}

class _TheaterElement extends MultiChildRenderObjectElement {
  _TheaterElement(_Theater super.widget);

  @override
  _RenderTheater get renderObject => super.renderObject as _RenderTheater;

  @override
  void insertRenderObjectChild(RenderBox child, IndexedSlot<Element?> slot) {
    super.insertRenderObjectChild(child, slot);
    final _TheaterParentData parentData = child.parentData! as _TheaterParentData;
    parentData.overlayEntry =
        ((widget as _Theater).children[slot.index] as _OverlayEntryWidget).entry;
    assert(parentData.overlayEntry != null);
  }

  @override
  void moveRenderObjectChild(
    RenderBox child,
    IndexedSlot<Element?> oldSlot,
    IndexedSlot<Element?> newSlot,
  ) {
    super.moveRenderObjectChild(child, oldSlot, newSlot);
    assert(() {
      final _TheaterParentData parentData = child.parentData! as _TheaterParentData;
      return parentData.overlayEntry ==
          ((widget as _Theater).children[newSlot.index] as _OverlayEntryWidget).entry;
    }());
  }

  @override
  void debugVisitOnstageChildren(ElementVisitor visitor) {
    final _Theater theater = widget as _Theater;
    assert(children.length >= theater.skipCount);
    children.skip(theater.skipCount).forEach(visitor);
  }
}

// A `RenderBox` that sizes itself to its parent's size, implements the stack
// layout algorithm and renders its children in the given `theater`.
mixin _RenderTheaterMixin on RenderBox {
  _RenderTheater get theater;

  Iterable<RenderBox> _childrenInPaintOrder();
  Iterable<RenderBox> _childrenInHitTestOrder();

  @override
  void setupParentData(RenderBox child) {
    if (child.parentData is! StackParentData) {
      child.parentData = StackParentData();
    }
  }

  @override
  double? computeDistanceToActualBaseline(TextBaseline baseline) {
    assert(!debugNeedsLayout);
    BaselineOffset baselineOffset = BaselineOffset.noBaseline;
    for (final RenderBox child in _childrenInPaintOrder()) {
      assert(!child.debugNeedsLayout);
      final StackParentData childParentData = child.parentData! as StackParentData;
      baselineOffset = baselineOffset.minOf(
        BaselineOffset(child.getDistanceToActualBaseline(baseline)) + childParentData.offset.dy,
      );
    }
    return baselineOffset.offset;
  }

  static double? baselineForChild(
    RenderBox child,
    Size theaterSize,
    BoxConstraints nonPositionedChildConstraints,
    Alignment alignment,
    TextBaseline baseline,
  ) {
    final StackParentData childParentData = child.parentData! as StackParentData;
    final BoxConstraints childConstraints =
        childParentData.isPositioned
            ? childParentData.positionedChildConstraints(theaterSize)
            : nonPositionedChildConstraints;
    final double? baselineOffset = child.getDryBaseline(childConstraints, baseline);
    if (baselineOffset == null) {
      return null;
    }
    final double y = switch (childParentData) {
      StackParentData(:final double top?) => top,
      StackParentData(:final double bottom?) =>
        theaterSize.height - bottom - child.getDryLayout(childConstraints).height,
      StackParentData() =>
        alignment.alongOffset(theaterSize - child.getDryLayout(childConstraints) as Offset).dy,
    };
    return baselineOffset + y;
  }

  void layoutChild(RenderBox child, BoxConstraints nonPositionedChildConstraints) {
    final StackParentData childParentData = child.parentData! as StackParentData;
    final Alignment alignment = theater._resolvedAlignment;
    if (!childParentData.isPositioned) {
      child.layout(nonPositionedChildConstraints, parentUsesSize: true);
      childParentData.offset = Offset.zero;
    } else {
      assert(
        child is! _RenderDeferredLayoutBox,
        'all _RenderDeferredLayoutBoxes must be non-positioned children.',
      );
      RenderStack.layoutPositionedChild(child, childParentData, size, alignment);
    }
    assert(child.parentData == childParentData);
  }

  @override
  bool hitTestChildren(BoxHitTestResult result, {required Offset position}) {
    final Iterator<RenderBox> iterator = _childrenInHitTestOrder().iterator;
    bool isHit = false;
    while (!isHit && iterator.moveNext()) {
      final RenderBox child = iterator.current;
      final StackParentData childParentData = child.parentData! as StackParentData;
      final RenderBox localChild = child;
      bool childHitTest(BoxHitTestResult result, Offset position) =>
          localChild.hitTest(result, position: position);
      isHit = result.addWithPaintOffset(
        offset: childParentData.offset,
        position: position,
        hitTest: childHitTest,
      );
    }
    return isHit;
  }

  @override
  void paint(PaintingContext context, Offset offset) {
    for (final RenderBox child in _childrenInPaintOrder()) {
      final StackParentData childParentData = child.parentData! as StackParentData;
      context.paintChild(child, childParentData.offset + offset);
    }
  }
}

class _TheaterParentData extends StackParentData {
  // The OverlayEntry that directly created this child. This field is null for
  // children that are created by an OverlayPortal.
  OverlayEntry? overlayEntry;

  /// A [OverlayPortal] makes its overlay child a render child of an ancestor
  /// [Overlay]. Currently, to make sure the overlay child is painted after its
  /// [OverlayPortal], and before the next [OverlayEntry] (which could be
  /// something that should obstruct the overlay child, such as a [ModalRoute])
  /// in the host [Overlay], the paint order of each overlay child is managed by
  /// the [OverlayEntry] that hosts its [OverlayPortal].
  ///
  /// The following methods are exposed to allow easy access to the overlay
  /// children's render objects whose order is managed by [overlayEntry], in the
  /// right order.

  // _overlayStateMounted is set to null in _OverlayEntryWidgetState's dispose
  // method. This property is only accessed during layout, paint and hit-test so
  // the `value!` should be safe.
  Iterator<RenderBox>? get paintOrderIterator =>
      overlayEntry?._overlayEntryStateNotifier?.value!._paintOrderIterable.iterator;
  Iterator<RenderBox>? get hitTestOrderIterator =>
      overlayEntry?._overlayEntryStateNotifier?.value!._hitTestOrderIterable.iterator;

  // A convenience method for traversing `paintOrderIterator` with a
  // [RenderObjectVisitor].
  void visitOverlayPortalChildrenOnOverlayEntry(RenderObjectVisitor visitor) =>
      overlayEntry?._overlayEntryStateNotifier?.value!._paintOrderIterable.forEach(visitor);
}

class _RenderTheater extends RenderBox
    with ContainerRenderObjectMixin<RenderBox, StackParentData>, _RenderTheaterMixin {
  _RenderTheater({
    List<RenderBox>? children,
    required TextDirection textDirection,
    int skipCount = 0,
    Clip clipBehavior = Clip.hardEdge,
  }) : assert(skipCount >= 0),
       _textDirection = textDirection,
       _skipCount = skipCount,
       _clipBehavior = clipBehavior {
    addAll(children);
  }

  @override
  _RenderTheater get theater => this;

  @override
  void setupParentData(RenderBox child) {
    if (child.parentData is! _TheaterParentData) {
      child.parentData = _TheaterParentData();
    }
  }

  @override
  void attach(PipelineOwner owner) {
    super.attach(owner);
    RenderBox? child = firstChild;
    while (child != null) {
      final _TheaterParentData childParentData = child.parentData! as _TheaterParentData;
      final Iterator<RenderBox>? iterator = childParentData.paintOrderIterator;
      if (iterator != null) {
        while (iterator.moveNext()) {
          iterator.current.attach(owner);
        }
      }
      child = childParentData.nextSibling;
    }
  }

  static void _detachChild(RenderObject child) => child.detach();

  @override
  void detach() {
    super.detach();
    RenderBox? child = firstChild;
    while (child != null) {
      final _TheaterParentData childParentData = child.parentData! as _TheaterParentData;
      childParentData.visitOverlayPortalChildrenOnOverlayEntry(_detachChild);
      child = childParentData.nextSibling;
    }
  }

  @override
  void redepthChildren() => visitChildren(redepthChild);

  Alignment? _alignmentCache;
  Alignment get _resolvedAlignment =>
      _alignmentCache ??= AlignmentDirectional.topStart.resolve(textDirection);

  void _markNeedResolution() {
    _alignmentCache = null;
    markNeedsLayout();
  }

  TextDirection get textDirection => _textDirection;
  TextDirection _textDirection;
  set textDirection(TextDirection value) {
    if (_textDirection == value) {
      return;
    }
    _textDirection = value;
    _markNeedResolution();
  }

  int get skipCount => _skipCount;
  int _skipCount;
  set skipCount(int value) {
    if (_skipCount != value) {
      _skipCount = value;
      markNeedsLayout();
    }
  }

  /// {@macro flutter.material.Material.clipBehavior}
  ///
  /// Defaults to [Clip.hardEdge].
  Clip get clipBehavior => _clipBehavior;
  Clip _clipBehavior = Clip.hardEdge;
  set clipBehavior(Clip value) {
    if (value != _clipBehavior) {
      _clipBehavior = value;
      markNeedsPaint();
      markNeedsSemanticsUpdate();
    }
  }

  // Adding/removing deferred child does not affect the layout of other children,
  // or that of the Overlay, so there's no need to invalidate the layout of the
  // Overlay.
  //
  // When _skipMarkNeedsLayout is true, markNeedsLayout does not do anything.
  bool _skipMarkNeedsLayout = false;
  void _addDeferredChild(_RenderDeferredLayoutBox child) {
    assert(!_skipMarkNeedsLayout);
    _skipMarkNeedsLayout = true;
    adoptChild(child);
    // The Overlay still needs repainting when a deferred child is added. Usually
    // `markNeedsLayout` implies `markNeedsPaint`, but here `markNeedsLayout` is
    // skipped when the `_skipMarkNeedsLayout` flag is set.
    markNeedsPaint();
    _skipMarkNeedsLayout = false;

    // After adding `child` to the render tree, we want to make sure it will be
    // laid out in the same frame. This is done by calling markNeedsLayout on the
    // layout surrogate. This ensures `child` is reachable via tree walk (see
    // _RenderLayoutSurrogateProxyBox.performLayout).
    child._layoutSurrogate.markNeedsLayout();
  }

  void _removeDeferredChild(_RenderDeferredLayoutBox child) {
    assert(!_skipMarkNeedsLayout);
    _skipMarkNeedsLayout = true;
    dropChild(child);
    // The Overlay still needs repainting when a deferred child is dropped. See
    // the comment in `_addDeferredChild`.
    markNeedsPaint();
    _skipMarkNeedsLayout = false;
  }

  @override
  void markNeedsLayout() {
    if (!_skipMarkNeedsLayout) {
      super.markNeedsLayout();
    }
  }

  RenderBox? get _firstOnstageChild {
    if (skipCount == super.childCount) {
      return null;
    }
    RenderBox? child = super.firstChild;
    for (int toSkip = skipCount; toSkip > 0; toSkip--) {
      final StackParentData childParentData = child!.parentData! as StackParentData;
      child = childParentData.nextSibling;
      assert(child != null);
    }
    return child;
  }

  RenderBox? get _lastOnstageChild => skipCount == super.childCount ? null : lastChild;

  @override
  double computeMinIntrinsicWidth(double height) {
    return RenderStack.getIntrinsicDimension(
      _firstOnstageChild,
      (RenderBox child) => child.getMinIntrinsicWidth(height),
    );
  }

  @override
  double computeMaxIntrinsicWidth(double height) {
    return RenderStack.getIntrinsicDimension(
      _firstOnstageChild,
      (RenderBox child) => child.getMaxIntrinsicWidth(height),
    );
  }

  @override
  double computeMinIntrinsicHeight(double width) {
    return RenderStack.getIntrinsicDimension(
      _firstOnstageChild,
      (RenderBox child) => child.getMinIntrinsicHeight(width),
    );
  }

  @override
  double computeMaxIntrinsicHeight(double width) {
    return RenderStack.getIntrinsicDimension(
      _firstOnstageChild,
      (RenderBox child) => child.getMaxIntrinsicHeight(width),
    );
  }

  @override
  double? computeDryBaseline(BoxConstraints constraints, TextBaseline baseline) {
    final Size size =
        constraints.biggest.isFinite
            ? constraints.biggest
            : _findSizeDeterminingChild().getDryLayout(constraints);
    final BoxConstraints nonPositionedChildConstraints = BoxConstraints.tight(size);
    final Alignment alignment = theater._resolvedAlignment;

    BaselineOffset baselineOffset = BaselineOffset.noBaseline;
    for (final RenderBox child in _childrenInPaintOrder()) {
      baselineOffset = baselineOffset.minOf(
        BaselineOffset(
          _RenderTheaterMixin.baselineForChild(
            child,
            size,
            nonPositionedChildConstraints,
            alignment,
            baseline,
          ),
        ),
      );
    }
    return baselineOffset.offset;
  }

  @override
  Size computeDryLayout(BoxConstraints constraints) {
    if (constraints.biggest.isFinite) {
      return constraints.biggest;
    }
    return _findSizeDeterminingChild().getDryLayout(constraints);
  }

  @override
  // The following uses sync* because concurrent modifications should be allowed
  // during layout.
  Iterable<RenderBox> _childrenInPaintOrder() sync* {
    RenderBox? child = _firstOnstageChild;
    while (child != null) {
      yield child;
      final _TheaterParentData childParentData = child.parentData! as _TheaterParentData;
      final Iterator<RenderBox>? innerIterator = childParentData.paintOrderIterator;
      if (innerIterator != null) {
        while (innerIterator.moveNext()) {
          yield innerIterator.current;
        }
      }
      child = childParentData.nextSibling;
    }
  }

  @override
  // The following uses sync* because hit testing should be lazy.
  Iterable<RenderBox> _childrenInHitTestOrder() sync* {
    RenderBox? child = _lastOnstageChild;
    int childLeft = childCount - skipCount;
    while (child != null) {
      final _TheaterParentData childParentData = child.parentData! as _TheaterParentData;
      final Iterator<RenderBox>? innerIterator = childParentData.hitTestOrderIterator;
      if (innerIterator != null) {
        while (innerIterator.moveNext()) {
          yield innerIterator.current;
        }
      }
      yield child;
      childLeft -= 1;
      child = childLeft <= 0 ? null : childParentData.previousSibling;
    }
  }

  @override
  bool get sizedByParent => false;

  bool _layingOutSizeDeterminingChild = false;
  @override
  void performLayout() {
    RenderBox? sizeDeterminingChild;
    if (constraints.biggest.isFinite) {
      size = constraints.biggest;
    } else {
      sizeDeterminingChild = _findSizeDeterminingChild();
      _layingOutSizeDeterminingChild = true;
      layoutChild(sizeDeterminingChild, constraints);
      _layingOutSizeDeterminingChild = false;
      size = sizeDeterminingChild.size;
    }

    // Equivalent to BoxConstraints used by RenderStack for StackFit.expand.
    final BoxConstraints nonPositionedChildConstraints = BoxConstraints.tight(size);
    for (final RenderBox child in _childrenInPaintOrder()) {
      if (child != sizeDeterminingChild) {
        layoutChild(child, nonPositionedChildConstraints);
      }
    }
  }

  RenderBox _findSizeDeterminingChild() {
    RenderBox? child = _lastOnstageChild;
    while (child != null) {
      final _TheaterParentData childParentData = child.parentData! as _TheaterParentData;
      if ((childParentData.overlayEntry?.canSizeOverlay ?? false) &&
          !childParentData.isPositioned) {
        return child;
      }
      child = childParentData.previousSibling;
    }
    throw FlutterError.fromParts(<DiagnosticsNode>[
      ErrorSummary(
        'Overlay was given infinite constraints and cannot be sized by a suitable child.',
      ),
      ErrorDescription(
        'The constraints given to the overlay ($constraints) would result in an illegal '
        'infinite size (${constraints.biggest}). To avoid that, the Overlay tried to size '
        'itself to one of its children, but no suitable non-positioned child that belongs to an '
        'OverlayEntry with canSizeOverlay set to true could be found.',
      ),
      ErrorHint(
        'Try wrapping the Overlay in a SizedBox to give it a finite size or '
        'use an OverlayEntry with canSizeOverlay set to true.',
      ),
    ]);
  }

  final LayerHandle<ClipRectLayer> _clipRectLayer = LayerHandle<ClipRectLayer>();

  @override
  void paint(PaintingContext context, Offset offset) {
    if (clipBehavior != Clip.none) {
      _clipRectLayer.layer = context.pushClipRect(
        needsCompositing,
        offset,
        Offset.zero & size,
        super.paint,
        clipBehavior: clipBehavior,
        oldLayer: _clipRectLayer.layer,
      );
    } else {
      _clipRectLayer.layer = null;
      super.paint(context, offset);
    }
  }

  @override
  void dispose() {
    _clipRectLayer.layer = null;
    super.dispose();
  }

  @override
  void visitChildren(RenderObjectVisitor visitor) {
    RenderBox? child = firstChild;
    while (child != null) {
      visitor(child);
      final _TheaterParentData childParentData = child.parentData! as _TheaterParentData;
      childParentData.visitOverlayPortalChildrenOnOverlayEntry(visitor);
      child = childParentData.nextSibling;
    }
  }

  @override
  void visitChildrenForSemantics(RenderObjectVisitor visitor) {
    RenderBox? child = _firstOnstageChild;
    while (child != null) {
      visitor(child);
      final _TheaterParentData childParentData = child.parentData! as _TheaterParentData;
      child = childParentData.nextSibling;
    }
  }

  @override
  Rect? describeApproximatePaintClip(RenderObject child) {
    switch (clipBehavior) {
      case Clip.none:
        return null;
      case Clip.hardEdge:
      case Clip.antiAlias:
      case Clip.antiAliasWithSaveLayer:
        return Offset.zero & size;
    }
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties.add(IntProperty('skipCount', skipCount));
    properties.add(EnumProperty<TextDirection>('textDirection', textDirection));
  }

  @override
  List<DiagnosticsNode> debugDescribeChildren() {
    final List<DiagnosticsNode> offstageChildren = <DiagnosticsNode>[];
    final List<DiagnosticsNode> onstageChildren = <DiagnosticsNode>[];

    int count = 1;
    bool onstage = false;
    RenderBox? child = firstChild;
    final RenderBox? firstOnstageChild = _firstOnstageChild;
    while (child != null) {
      final _TheaterParentData childParentData = child.parentData! as _TheaterParentData;
      if (child == firstOnstageChild) {
        onstage = true;
        count = 1;
      }

      if (onstage) {
        onstageChildren.add(child.toDiagnosticsNode(name: 'onstage $count'));
      } else {
        offstageChildren.add(
          child.toDiagnosticsNode(name: 'offstage $count', style: DiagnosticsTreeStyle.offstage),
        );
      }

      int subcount = 1;
      childParentData.visitOverlayPortalChildrenOnOverlayEntry((RenderObject renderObject) {
        final RenderBox child = renderObject as RenderBox;
        if (onstage) {
          onstageChildren.add(child.toDiagnosticsNode(name: 'onstage $count - $subcount'));
        } else {
          offstageChildren.add(
            child.toDiagnosticsNode(
              name: 'offstage $count - $subcount',
              style: DiagnosticsTreeStyle.offstage,
            ),
          );
        }
        subcount += 1;
      });

      child = childParentData.nextSibling;
      count += 1;
    }

    return <DiagnosticsNode>[
      ...onstageChildren,
      if (offstageChildren.isNotEmpty)
        ...offstageChildren
      else
        DiagnosticsNode.message('no offstage children', style: DiagnosticsTreeStyle.offstage),
    ];
  }
}

// * OverlayPortal Implementation
//  OverlayPortal is inspired by the
//  [flutter_portal](https://pub.dev/packages/flutter_portal) package.
//
// ** RenderObject hierarchy
// The widget works by inserting its overlay child's render subtree directly
// under [Overlay]'s render object (_RenderTheater).
// https://user-images.githubusercontent.com/31859944/171971838-62ed3975-4b5d-4733-a9c9-f79e263b8fcc.jpg
//
// To ensure the overlay child render subtree does not do layout twice, the
// subtree must only perform layout after both its _RenderTheater and the
// [OverlayPortal]'s render object (_RenderLayoutSurrogateProxyBox) have
// finished layout. This is handled by _RenderDeferredLayoutBox.
//
// ** Z-Index of an overlay child
// [_OverlayEntryLocation] is a (currently private) interface that allows an
// [OverlayPortal] to insert its overlay child into a specific [Overlay], as
// well as specifying the paint order between the overlay child and other
// children of the _RenderTheater.
//
// Since [OverlayPortal] is only allowed to target ancestor [Overlay]s
// (_RenderTheater must finish doing layout before _RenderDeferredLayoutBox),
// the _RenderTheater should typically be acquired using an [InheritedWidget]
// (currently, _RenderTheaterMarker) in case the [OverlayPortal] gets
// reparented.

/// A class to show, hide and bring to top an [OverlayPortal]'s overlay child
/// in the target [Overlay].
///
/// A [OverlayPortalController] can only be given to at most one [OverlayPortal]
/// at a time. When an [OverlayPortalController] is moved from one
/// [OverlayPortal] to another, its [isShowing] state does not carry over.
///
/// [OverlayPortalController.show] and [OverlayPortalController.hide] can be
/// called even before the controller is assigned to any [OverlayPortal], but
/// they typically should not be called while the widget tree is being rebuilt.
class OverlayPortalController {
  /// Creates an [OverlayPortalController], optionally with a String identifier
  /// `debugLabel`.
  OverlayPortalController({String? debugLabel}) : _debugLabel = debugLabel;

  _OverlayPortalState? _attachTarget;

  // A separate _zOrderIndex to allow `show()` or `hide()` to be called when the
  // controller is not yet attached. Once this controller is attached,
  // _attachTarget._zOrderIndex will be used as the source of truth, and this
  // variable will be set to null.
  int? _zOrderIndex;
  final String? _debugLabel;

  static int _wallTime =
      kIsWeb
          ? -9007199254740992 // -2^53
          : -1 << 63;

  // Returns a unique and monotonically increasing timestamp that represents
  // now.
  //
  // The value this method returns increments after each call.
  int _now() {
    final int now = _wallTime += 1;
    assert(_zOrderIndex == null || _zOrderIndex! < now);
    assert(_attachTarget?._zOrderIndex == null || _attachTarget!._zOrderIndex! < now);
    return now;
  }

  /// Show the overlay child of the [OverlayPortal] this controller is attached
  /// to, at the top of the target [Overlay].
  ///
  /// When there are more than one [OverlayPortal]s that target the same
  /// [Overlay], the overlay child of the last [OverlayPortal] to have called
  /// [show] appears at the top level, unobstructed.
  ///
  /// If [isShowing] is already true, calling this method brings the overlay
  /// child it controls to the top.
  ///
  /// This method should typically not be called while the widget tree is being
  /// rebuilt.
  void show() {
    final _OverlayPortalState? state = _attachTarget;
    if (state != null) {
      state.show(_now());
    } else {
      _zOrderIndex = _now();
    }
  }

  /// Hide the [OverlayPortal]'s overlay child.
  ///
  /// Once hidden, the overlay child will be removed from the widget tree the
  /// next time the widget tree rebuilds, and stateful widgets in the overlay
  /// child may lose states as a result.
  ///
  /// This method should typically not be called while the widget tree is being
  /// rebuilt.
  void hide() {
    final _OverlayPortalState? state = _attachTarget;
    if (state != null) {
      state.hide();
    } else {
      assert(_zOrderIndex != null);
      _zOrderIndex = null;
    }
  }

  /// Whether the associated [OverlayPortal] should build and show its overlay
  /// child, using its `overlayChildBuilder`.
  bool get isShowing {
    final _OverlayPortalState? state = _attachTarget;
    return state != null ? state._zOrderIndex != null : _zOrderIndex != null;
  }

  /// Convenience method for toggling the current [isShowing] status.
  ///
  /// This method should typically not be called while the widget tree is being
  /// rebuilt.
  void toggle() => isShowing ? hide() : show();

  @override
  String toString() {
    final String? debugLabel = _debugLabel;
    final String label = debugLabel == null ? '' : '($debugLabel)';
    final String isDetached = _attachTarget != null ? '' : ' DETACHED';
    return '${objectRuntimeType(this, 'OverlayPortalController')}$label$isDetached';
  }
}

/// A widget that renders its overlay child on an [Overlay].
///
/// The overlay child is initially hidden until [OverlayPortalController.show]
/// is called on the associated [controller]. The [OverlayPortal] uses
/// [overlayChildBuilder] to build its overlay child and renders it on the
/// specified [Overlay] as if it was inserted using an [OverlayEntry], while it
/// can depend on the same set of [InheritedWidget]s (such as [Theme]) that this
/// widget can depend on.
///
/// This widget requires an [Overlay] ancestor in the widget tree when its
/// overlay child is showing. The overlay child is rendered by the [Overlay]
/// ancestor, not by the widget itself. This allows the overlay child to float
/// above other widgets, independent of its position in the widget tree.
///
/// When [OverlayPortalController.hide] is called, the widget built using
/// [overlayChildBuilder] will be removed from the widget tree the next time the
/// widget rebuilds. Stateful descendants in the overlay child subtree may lose
/// states as a result.
///
/// {@tool dartpad}
/// This example uses an [OverlayPortal] to build a tooltip that becomes visible
/// when the user taps on the [child] widget. There's a [DefaultTextStyle] above
/// the [OverlayPortal] controlling the [TextStyle] of both the [child] widget
/// and the widget [overlayChildBuilder] builds, which isn't otherwise doable if
/// the tooltip was added as an [OverlayEntry].
///
/// ** See code in examples/api/lib/widgets/overlay/overlay_portal.0.dart **
/// {@end-tool}
///
/// ### Paint Order
///
/// In an [Overlay], an overlay child is painted after the [OverlayEntry]
/// associated with its [OverlayPortal] (that is, the [OverlayEntry] closest to
/// the [OverlayPortal] in the widget tree, which usually represents the
/// enclosing [Route]), and before the next [OverlayEntry].
///
/// When an [OverlayEntry] has multiple associated [OverlayPortal]s, the paint
/// order between their overlay children is the order in which
/// [OverlayPortalController.show] was called. The last [OverlayPortal] to have
/// called `show` gets to paint its overlay child in the foreground.
///
/// ### Semantics
///
/// The semantics subtree generated by the overlay child is considered attached
/// to [OverlayPortal] instead of the target [Overlay]. An [OverlayPortal]'s
/// semantics subtree can be dropped from the semantics tree due to invisibility
/// while the overlay child is still visible (for example, when the
/// [OverlayPortal] is completely invisible in a [ListView] but kept alive by
/// a [KeepAlive] widget). When this happens the semantics subtree generated by
/// the overlay child is also dropped, even if the overlay child is still visible
/// on screen.
///
/// {@template flutter.widgets.overlayPortalVsOverlayEntry}
/// ### Differences between [OverlayPortal] and [OverlayEntry]
///
/// The main difference between [OverlayEntry] and [OverlayPortal] is that
/// [OverlayEntry] builds its widget subtree as a child of the target [Overlay],
/// while [OverlayPortal] uses [OverlayPortal.overlayChildBuilder] to build a
/// child widget of itself. This allows [OverlayPortal]'s overlay child to depend
/// on the same set of [InheritedWidget]s as [OverlayPortal], and it's also
/// guaranteed that the overlay child will not outlive its [OverlayPortal].
///
/// On the other hand, [OverlayPortal]'s implementation is more complex. For
/// instance, it does a bit more work than a regular widget during global key
/// reparenting. If the content to be shown on the [Overlay] doesn't benefit
/// from being a part of [OverlayPortal]'s subtree, consider using an
/// [OverlayEntry] instead.
/// {@endtemplate}
///
/// See also:
///
///  * [OverlayEntry], an alternative API for inserting widgets into an
///    [Overlay].
///  * [Positioned], which can be used to size and position the overlay child in
///    relation to the target [Overlay]'s boundaries.
///  * [CompositedTransformFollower], which can be used to position the overlay
///    child in relation to the linked [CompositedTransformTarget] widget.
class OverlayPortal extends StatefulWidget {
  /// Creates an [OverlayPortal] that renders the widget [overlayChildBuilder]
  /// builds on the closest [Overlay] when [OverlayPortalController.show] is
  /// called.
  const OverlayPortal({
    super.key,
    required this.controller,
    required this.overlayChildBuilder,
    this.child,
  }) : _targetRootOverlay = false;

  /// Creates an [OverlayPortal] that renders the widget [overlayChildBuilder]
  /// builds on the root [Overlay] when [OverlayPortalController.show] is
  /// called.
  const OverlayPortal.targetsRootOverlay({
    super.key,
    required this.controller,
    required this.overlayChildBuilder,
    this.child,
  }) : _targetRootOverlay = true;

  /// The controller to show, hide and bring to top the overlay child.
  final OverlayPortalController controller;

  /// A [WidgetBuilder] used to build a widget below this widget in the tree,
  /// that renders on the closest [Overlay].
  ///
  /// The said widget will only be built and shown in the closest [Overlay] once
  /// [OverlayPortalController.show] is called on the associated [controller].
  /// It will be painted in front of the [OverlayEntry] closest to this widget
  /// in the widget tree (which is usually the enclosing [Route]).
  ///
  /// The built overlay child widget is inserted below this widget in the widget
  /// tree, allowing it to depend on [InheritedWidget]s above it, and be
  /// notified when the [InheritedWidget]s change.
  ///
  /// Unlike [child], the built overlay child can visually extend outside the
  /// bounds of this widget without being clipped, and receive hit-test events
  /// outside of this widget's bounds, as long as it does not extend outside of
  /// the [Overlay] on which it is rendered.
  final WidgetBuilder overlayChildBuilder;

  /// A widget below this widget in the tree.
  final Widget? child;

  final bool _targetRootOverlay;

  @override
  State<OverlayPortal> createState() => _OverlayPortalState();
}

class _OverlayPortalState extends State<OverlayPortal> {
  int? _zOrderIndex;
  // The location of the overlay child within the overlay. This object will be
  // used as the slot of the overlay child widget.
  //
  // The developer must call `show` to reveal the overlay so we can get a unique
  // timestamp of the user interaction for determining the z-index of the
  // overlay child in the overlay.
  //
  // Avoid invalidating the cache if possible, since the framework uses `==` to
  // compare slots, and _OverlayEntryLocation can't override that operator since
  // it's mutable. Changing slots can be relatively slow.
  bool _childModelMayHaveChanged = true;
  _OverlayEntryLocation? _locationCache;
  static bool _isTheSameLocation(_OverlayEntryLocation locationCache, _RenderTheaterMarker marker) {
    return locationCache._childModel == marker.overlayEntryWidgetState &&
        locationCache._theater == marker.theater;
  }

  _OverlayEntryLocation _getLocation(int zOrderIndex, bool targetRootOverlay) {
    final _OverlayEntryLocation? cachedLocation = _locationCache;
    late final _RenderTheaterMarker marker = _RenderTheaterMarker.of(
      context,
      targetRootOverlay: targetRootOverlay,
    );
    final bool isCacheValid =
        cachedLocation != null &&
        (!_childModelMayHaveChanged || _isTheSameLocation(cachedLocation, marker));
    _childModelMayHaveChanged = false;
    if (isCacheValid) {
      assert(cachedLocation._zOrderIndex == zOrderIndex);
      assert(cachedLocation._debugIsLocationValid());
      return cachedLocation;
    }
    // Otherwise invalidate the cache and create a new location.
    cachedLocation?._debugMarkLocationInvalid();
    final _OverlayEntryLocation newLocation = _OverlayEntryLocation(
      zOrderIndex,
      marker.overlayEntryWidgetState,
      marker.theater,
    );
    assert(newLocation._zOrderIndex == zOrderIndex);
    return _locationCache = newLocation;
  }

  @override
  void initState() {
    super.initState();
    _setupController(widget.controller);
  }

  void _setupController(OverlayPortalController controller) {
    assert(
      controller._attachTarget == null || controller._attachTarget == this,
      'Failed to attach $controller to $this. It is already attached to ${controller._attachTarget}.',
    );
    final int? controllerZOrderIndex = controller._zOrderIndex;
    final int? zOrderIndex = _zOrderIndex;
    if (zOrderIndex == null ||
        (controllerZOrderIndex != null && controllerZOrderIndex > zOrderIndex)) {
      _zOrderIndex = controllerZOrderIndex;
    }
    controller._zOrderIndex = null;
    controller._attachTarget = this;
  }

  @override
  void didChangeDependencies() {
    super.didChangeDependencies();
    _childModelMayHaveChanged = true;
  }

  @override
  void didUpdateWidget(OverlayPortal oldWidget) {
    super.didUpdateWidget(oldWidget);
    _childModelMayHaveChanged =
        _childModelMayHaveChanged || oldWidget._targetRootOverlay != widget._targetRootOverlay;
    if (oldWidget.controller != widget.controller) {
      oldWidget.controller._attachTarget = null;
      _setupController(widget.controller);
    }
  }

  @override
  void dispose() {
    assert(widget.controller._attachTarget == this);
    widget.controller._attachTarget = null;
    _locationCache?._debugMarkLocationInvalid();
    _locationCache = null;
    super.dispose();
  }

  void show(int zOrderIndex) {
    assert(
      SchedulerBinding.instance.schedulerPhase != SchedulerPhase.persistentCallbacks,
      '${widget.controller.runtimeType}.show() should not be called during build.',
    );
    setState(() {
      _zOrderIndex = zOrderIndex;
    });
    _locationCache?._debugMarkLocationInvalid();
    _locationCache = null;
  }

  void hide() {
    assert(SchedulerBinding.instance.schedulerPhase != SchedulerPhase.persistentCallbacks);
    setState(() {
      _zOrderIndex = null;
    });
    _locationCache?._debugMarkLocationInvalid();
    _locationCache = null;
  }

  @override
  Widget build(BuildContext context) {
    final int? zOrderIndex = _zOrderIndex;
    if (zOrderIndex == null) {
      return _OverlayPortal(overlayLocation: null, overlayChild: null, child: widget.child);
    }
    return _OverlayPortal(
      overlayLocation: _getLocation(zOrderIndex, widget._targetRootOverlay),
      overlayChild: _DeferredLayout(child: Builder(builder: widget.overlayChildBuilder)),
      child: widget.child,
    );
  }
}

/// A location in an [Overlay].
///
/// An [_OverlayEntryLocation] determines the [Overlay] the associated
/// [OverlayPortal] should put its overlay child onto, as well as the overlay
/// child's paint order in relation to other contents painted on the [Overlay].
//
// An _OverlayEntryLocation is a cursor pointing to a location in a particular
// Overlay's child model, and provides methods to insert/remove/move a
// _RenderDeferredLayoutBox to/from its target _theater.
//
// The occupant (a `RenderBox`) will be painted above the associated
// [OverlayEntry], but below the [OverlayEntry] above that [OverlayEntry].
//
// Additionally, `_activate` and `_deactivate` are called when the overlay
// child's `_OverlayPortalElement` activates/deactivates (for instance, during
// global key reparenting).
// `_OverlayPortalElement` removes its overlay child's render object from the
// target `_RenderTheater` when it deactivates and puts it back on `activated`.
// These 2 methods can be used to "hide" a child in the child model without
// removing it, when the child is expensive/difficult to re-insert at the
// correct location on `activated`.
//
// ### Equality
//
// An `_OverlayEntryLocation` will be used as an Element's slot. These 3 parts
// uniquely identify a place in an overlay's child model:
// - _theater
// - _childModel (the OverlayEntry)
// - _zOrderIndex
//
// Since it can't implement operator== (it's mutable), the same `_OverlayEntryLocation`
// instance must not be used to represent more than one locations.
final class _OverlayEntryLocation extends LinkedListEntry<_OverlayEntryLocation> {
  _OverlayEntryLocation(this._zOrderIndex, this._childModel, this._theater);

  final int _zOrderIndex;
  final _OverlayEntryWidgetState _childModel;
  final _RenderTheater _theater;

  _RenderDeferredLayoutBox? _overlayChildRenderBox;
  void _addToChildModel(_RenderDeferredLayoutBox child) {
    assert(
      _overlayChildRenderBox == null,
      'Failed to add $child. This location ($this) is already occupied by $_overlayChildRenderBox.',
    );
    _overlayChildRenderBox = child;
    _childModel._add(this);
    _theater.markNeedsPaint();
    _theater.markNeedsCompositingBitsUpdate();
    _theater.markNeedsSemanticsUpdate();
  }

  void _removeFromChildModel(_RenderDeferredLayoutBox child) {
    assert(child == _overlayChildRenderBox);
    _overlayChildRenderBox = null;
    assert(_childModel._sortedTheaterSiblings?.contains(this) ?? false);
    _childModel._remove(this);
    _theater.markNeedsPaint();
    _theater.markNeedsCompositingBitsUpdate();
    _theater.markNeedsSemanticsUpdate();
  }

  void _addChild(_RenderDeferredLayoutBox child) {
    assert(_debugIsLocationValid());
    _addToChildModel(child);
    _theater._addDeferredChild(child);
    assert(child.parent == _theater);
  }

  void _removeChild(_RenderDeferredLayoutBox child) {
    // This call is allowed even when this location is disposed.
    _removeFromChildModel(child);
    _theater._removeDeferredChild(child);
    assert(child.parent == null);
  }

  void _moveChild(_RenderDeferredLayoutBox child, _OverlayEntryLocation fromLocation) {
    assert(fromLocation != this);
    assert(_debugIsLocationValid());
    final _RenderTheater fromTheater = fromLocation._theater;
    final _OverlayEntryWidgetState fromModel = fromLocation._childModel;

    if (fromTheater != _theater) {
      fromTheater._removeDeferredChild(child);
      _theater._addDeferredChild(child);
    }

    if (fromModel != _childModel || fromLocation._zOrderIndex != _zOrderIndex) {
      fromLocation._removeFromChildModel(child);
      _addToChildModel(child);
    }
  }

  void _activate(_RenderDeferredLayoutBox child) {
    // This call is allowed even when this location is invalidated.
    // See _OverlayPortalElement.activate.
    assert(_overlayChildRenderBox == null, '$_overlayChildRenderBox');
    _theater._addDeferredChild(child);
    _overlayChildRenderBox = child;
  }

  void _deactivate(_RenderDeferredLayoutBox child) {
    // This call is allowed even when this location is invalidated.
    _theater._removeDeferredChild(child);
    _overlayChildRenderBox = null;
  }

  // Throws a StateError if this location is already invalidated and shouldn't
  // be used as an OverlayPortal slot. Must be used in asserts.
  //
  // Generally, `assert(_debugIsLocationValid())` should be used to prevent
  // invalid accesses to an invalid `_OverlayEntryLocation` object. Exceptions
  // to this rule are _removeChild, _deactivate, which will be called when the
  // OverlayPortal is being removed from the widget tree and may use the
  // location information to perform cleanup tasks.
  //
  // Another exception is the _activate method which is called by
  // _OverlayPortalElement.activate. See the comment in _OverlayPortalElement.activate.
  bool _debugIsLocationValid() {
    if (_debugMarkLocationInvalidStackTrace == null) {
      return true;
    }
    throw StateError(
      '$this is already disposed. Stack trace: $_debugMarkLocationInvalidStackTrace',
    );
  }

  // The StackTrace of the first _debugMarkLocationInvalid call. It's only for
  // debugging purposes and the StackTrace will only be captured in debug builds.
  //
  // The effect of this method is not reversible. Once marked invalid, this
  // object can't be marked as valid again.
  StackTrace? _debugMarkLocationInvalidStackTrace;
  @mustCallSuper
  void _debugMarkLocationInvalid() {
    assert(_debugIsLocationValid());
    assert(() {
      _debugMarkLocationInvalidStackTrace = StackTrace.current;
      return true;
    }());
  }

  @override
  String toString() =>
      '${objectRuntimeType(this, '_OverlayEntryLocation')}[${shortHash(this)}] ${_debugMarkLocationInvalidStackTrace != null ? "(INVALID)" : ""}';
}

class _RenderTheaterMarker extends InheritedWidget {
  const _RenderTheaterMarker({
    required this.theater,
    required this.overlayEntryWidgetState,
    required super.child,
  });

  final _RenderTheater theater;
  final _OverlayEntryWidgetState overlayEntryWidgetState;

  @override
  bool updateShouldNotify(_RenderTheaterMarker oldWidget) {
    return oldWidget.theater != theater ||
        oldWidget.overlayEntryWidgetState != overlayEntryWidgetState;
  }

  static _RenderTheaterMarker of(BuildContext context, {bool targetRootOverlay = false}) {
    final _RenderTheaterMarker? marker;
    if (targetRootOverlay) {
      final InheritedElement? ancestor = _rootRenderTheaterMarkerOf(
        context.getElementForInheritedWidgetOfExactType<_RenderTheaterMarker>(),
      );
      assert(ancestor == null || ancestor.widget is _RenderTheaterMarker);
      marker =
          ancestor != null
              ? context.dependOnInheritedElement(ancestor) as _RenderTheaterMarker?
              : null;
    } else {
      marker = context.dependOnInheritedWidgetOfExactType<_RenderTheaterMarker>();
    }
    if (marker != null) {
      return marker;
    }
    throw FlutterError.fromParts(<DiagnosticsNode>[
      ErrorSummary('No Overlay widget found.'),
      ErrorDescription(
        '${context.widget.runtimeType} widgets require an Overlay widget ancestor.\n'
        'An overlay lets widgets float on top of other widget children.',
      ),
      ErrorHint(
        'To introduce an Overlay widget, you can either directly '
        'include one, or use a widget that contains an Overlay itself, '
        'such as a Navigator, WidgetApp, MaterialApp, or CupertinoApp.',
      ),
      ...context.describeMissingAncestor(expectedAncestorType: Overlay),
    ]);
  }

  static InheritedElement? _rootRenderTheaterMarkerOf(InheritedElement? theaterMarkerElement) {
    assert(theaterMarkerElement == null || theaterMarkerElement.widget is _RenderTheaterMarker);
    if (theaterMarkerElement == null) {
      return null;
    }
    InheritedElement? ancestor;
    theaterMarkerElement.visitAncestorElements((Element element) {
      ancestor = element.getElementForInheritedWidgetOfExactType<_RenderTheaterMarker>();
      return false;
    });
    return ancestor == null ? theaterMarkerElement : _rootRenderTheaterMarkerOf(ancestor);
  }
}

class _OverlayPortal extends RenderObjectWidget {
  /// Creates a widget that renders the given [overlayChild] in the [Overlay]
  /// specified by `overlayLocation`.
  ///
  /// The `overlayLocation` parameter must not be null when [overlayChild] is not
  /// null.
  _OverlayPortal({required this.overlayLocation, required this.overlayChild, required this.child})
    : assert(overlayChild == null || overlayLocation != null),
      assert(overlayLocation == null || overlayLocation._debugIsLocationValid());

  final Widget? overlayChild;

  /// A widget below this widget in the tree.
  final Widget? child;

  final _OverlayEntryLocation? overlayLocation;

  @override
  RenderObjectElement createElement() => _OverlayPortalElement(this);

  @override
  RenderObject createRenderObject(BuildContext context) => _RenderLayoutSurrogateProxyBox();
}

class _OverlayPortalElement extends RenderObjectElement {
  _OverlayPortalElement(_OverlayPortal super.widget);

  @override
  _RenderLayoutSurrogateProxyBox get renderObject =>
      super.renderObject as _RenderLayoutSurrogateProxyBox;

  Element? _overlayChild;
  Element? _child;

  @override
  void mount(Element? parent, Object? newSlot) {
    super.mount(parent, newSlot);
    final _OverlayPortal widget = this.widget as _OverlayPortal;
    _child = updateChild(_child, widget.child, null);
    _overlayChild = updateChild(_overlayChild, widget.overlayChild, widget.overlayLocation);
  }

  @override
  void update(_OverlayPortal newWidget) {
    super.update(newWidget);
    _child = updateChild(_child, newWidget.child, null);
    _overlayChild = updateChild(_overlayChild, newWidget.overlayChild, newWidget.overlayLocation);
  }

  @override
  void forgetChild(Element child) {
    // The _overlayChild Element does not have a key because the _DeferredLayout
    // widget does not take a Key, so only the regular _child can be taken
    // during global key reparenting.
    assert(child == _child);
    _child = null;
    super.forgetChild(child);
  }

  @override
  void visitChildren(ElementVisitor visitor) {
    final Element? child = _child;
    final Element? overlayChild = _overlayChild;
    if (child != null) {
      visitor(child);
    }
    if (overlayChild != null) {
      visitor(overlayChild);
    }
  }

  @override
  void activate() {
    super.activate();
    final _RenderDeferredLayoutBox? box = _overlayChild?.renderObject as _RenderDeferredLayoutBox?;
    if (box != null) {
      assert(!box.attached);
      assert(renderObject._deferredLayoutChild == box);
      // updateChild has not been called at this point so the RenderTheater in
      // the overlay location could be detached. Adding children to a detached
      // RenderObject is still allowed however this isn't the most efficient.
      (_overlayChild!.slot! as _OverlayEntryLocation)._activate(box);
    }
  }

  @override
  void deactivate() {
    // Instead of just detaching the render objects, removing them from the
    // render subtree entirely. This is a workaround for the
    // !renderObject.attached assert in the `super.deactivate()` method.
    final _RenderDeferredLayoutBox? box = _overlayChild?.renderObject as _RenderDeferredLayoutBox?;
    if (box != null) {
      (_overlayChild!.slot! as _OverlayEntryLocation)._deactivate(box);
    }
    super.deactivate();
  }

  @override
  void insertRenderObjectChild(RenderBox child, _OverlayEntryLocation? slot) {
    assert(child.parent == null, "$child's parent is not null: ${child.parent}");
    if (slot != null) {
      renderObject._deferredLayoutChild = child as _RenderDeferredLayoutBox;
      slot._addChild(child);
      renderObject.markNeedsSemanticsUpdate();
    } else {
      renderObject.child = child;
    }
  }

  // The [_DeferredLayout] widget does not have a key so there will be no
  // reparenting between _overlayChild and _child, thus the non-null-typed slots.
  @override
  void moveRenderObjectChild(
    _RenderDeferredLayoutBox child,
    _OverlayEntryLocation oldSlot,
    _OverlayEntryLocation newSlot,
  ) {
    assert(newSlot._debugIsLocationValid());
    newSlot._moveChild(child, oldSlot);
    renderObject.markNeedsSemanticsUpdate();
  }

  @override
  void removeRenderObjectChild(RenderBox child, _OverlayEntryLocation? slot) {
    if (slot == null) {
      renderObject.child = null;
      return;
    }
    assert(renderObject._deferredLayoutChild == child);
    slot._removeChild(child as _RenderDeferredLayoutBox);
    renderObject._deferredLayoutChild = null;
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties.add(DiagnosticsProperty<Element>('child', _child, defaultValue: null));
    properties.add(DiagnosticsProperty<Element>('overlayChild', _overlayChild, defaultValue: null));
    properties.add(
      DiagnosticsProperty<Object>('overlayLocation', _overlayChild?.slot, defaultValue: null),
    );
  }
}

class _DeferredLayout extends SingleChildRenderObjectWidget {
  const _DeferredLayout({
    // This widget must not be given a key: we currently do not support
    // reparenting between the overlayChild and child.
    required Widget child,
  }) : super(child: child);

  _RenderLayoutSurrogateProxyBox getLayoutParent(BuildContext context) {
    return context.findAncestorRenderObjectOfType<_RenderLayoutSurrogateProxyBox>()!;
  }

  @override
  _RenderDeferredLayoutBox createRenderObject(BuildContext context) {
    final _RenderLayoutSurrogateProxyBox parent = getLayoutParent(context);
    final _RenderDeferredLayoutBox renderObject = _RenderDeferredLayoutBox(parent);
    parent._deferredLayoutChild = renderObject;
    return renderObject;
  }

  @override
  void updateRenderObject(BuildContext context, _RenderDeferredLayoutBox renderObject) {
    assert(renderObject._layoutSurrogate == getLayoutParent(context));
    assert(getLayoutParent(context)._deferredLayoutChild == renderObject);
  }
}

// A `RenderProxyBox` that defers its layout until its `_layoutSurrogate` (which
// is not necessarily an ancestor of this RenderBox, but shares at least one
// `_RenderTheater` ancestor with this RenderBox) is laid out.
//
// This `RenderObject` must be a child of a `_RenderTheater`. It guarantees that:
//
// 1. It's a relayout boundary, so calling `markNeedsLayout` on it never dirties
//    its `_RenderTheater`.
//
// 2. Its `layout` implementation is overridden such that `performLayout` does
//    not do anything when its called from `layout`, preventing the parent
//    `_RenderTheater` from laying out this subtree prematurely (but this
//    `RenderObject` may still be resized). Instead, `markNeedsLayout` will be
//    called from within `layout` to schedule a layout update for this relayout
//    boundary when needed.
//
// 3. When invoked from `PipelineOwner.flushLayout`, or
//    `_layoutSurrogate.performLayout`, this `RenderObject` behaves like an
//    `Overlay` that has only one entry.
final class _RenderDeferredLayoutBox extends RenderProxyBox
    with _RenderTheaterMixin, LinkedListEntry<_RenderDeferredLayoutBox> {
  _RenderDeferredLayoutBox(this._layoutSurrogate);

  StackParentData get stackParentData => parentData! as StackParentData;
  final _RenderLayoutSurrogateProxyBox _layoutSurrogate;

  @override
  Iterable<RenderBox> _childrenInPaintOrder() {
    final RenderBox? child = this.child;
    return child == null
        ? const Iterable<RenderBox>.empty()
        : Iterable<RenderBox>.generate(1, (int i) => child);
  }

  @override
  Iterable<RenderBox> _childrenInHitTestOrder() => _childrenInPaintOrder();

  @override
  _RenderTheater get theater {
    final RenderObject? parent = this.parent;
    return parent is _RenderTheater
        ? parent
        : throw FlutterError('$parent of $this is not a _RenderTheater');
  }

  @override
  void redepthChildren() {
    _layoutSurrogate.redepthChild(this);
    super.redepthChildren();
  }

  @override
  bool get sizedByParent => true;

  bool _needsLayout = true;
  @override
  void markNeedsLayout() {
    _needsLayout = true;
    super.markNeedsLayout();
  }

  @override
  RenderObject? get semanticsParent => _layoutSurrogate;

  @override
  double? computeDryBaseline(BoxConstraints constraints, TextBaseline baseline) {
    final RenderBox? child = this.child;
    if (child == null) {
      return null;
    }
    return _RenderTheaterMixin.baselineForChild(
      child,
      constraints.biggest,
      constraints,
      theater._resolvedAlignment,
      baseline,
    );
  }

  @override
  RenderObject? get debugLayoutParent => _layoutSurrogate;

  void layoutByLayoutSurrogate() {
    assert(!_theaterDoingThisLayout);
    final _RenderTheater? theater = parent as _RenderTheater?;
    if (theater == null || !attached) {
      assert(false, '$this is not attached to parent');
      return;
    }
    if (theater._layingOutSizeDeterminingChild) {
      theater.invokeLayoutCallback((BoxConstraints constraints) {
        markNeedsLayout();
      });
    } else {
      final BoxConstraints theaterConstraints = theater.constraints;
      final Size boxSize =
          theaterConstraints.biggest.isFinite
              ? theaterConstraints.biggest
              // Accessing the theater's size is only unsafe if it is laying out the
              // size-determining child.
              : theater.size;
      super.layout(BoxConstraints.tight(boxSize));
    }
  }

  bool _theaterDoingThisLayout = false;
  @override
  void layout(Constraints constraints, {bool parentUsesSize = false}) {
    assert(_needsLayout == debugNeedsLayout);
    // Only _RenderTheater calls this implementation.
    assert(parent != null);
    final bool scheduleDeferredLayout = _needsLayout || this.constraints != constraints;
    assert(!_theaterDoingThisLayout);
    _theaterDoingThisLayout = true;
    super.layout(constraints, parentUsesSize: parentUsesSize);
    assert(_theaterDoingThisLayout);
    _theaterDoingThisLayout = false;
    _needsLayout = false;
    assert(!debugNeedsLayout);
    if (scheduleDeferredLayout) {
      final _RenderTheater parent = this.parent! as _RenderTheater;
      // Invoking markNeedsLayout as a layout callback allows this node to be
      // merged back to the `PipelineOwner`'s dirty list in the right order, if
      // it's not already dirty. Otherwise this may cause some dirty descendants
      // to performLayout a second time.
      parent.invokeLayoutCallback((BoxConstraints constraints) {
        markNeedsLayout();
      });
    }
  }

  @override
  void performResize() {
    size = constraints.biggest;
  }

  bool _debugMutationsLocked = false;
  @override
  void performLayout() {
    assert(!_debugMutationsLocked);
    if (_theaterDoingThisLayout) {
      _needsLayout = false;
      return;
    }
    assert(() {
      _debugMutationsLocked = true;
      return true;
    }());
    // This method is directly being invoked from `PipelineOwner.flushLayout`,
    // or from `_layoutSurrogate`'s performLayout.
    assert(parent != null);
    final RenderBox? child = this.child;
    if (child == null) {
      _needsLayout = false;
      return;
    }
    assert(constraints.isTight);
    layoutChild(child, constraints);
    assert(() {
      _debugMutationsLocked = false;
      return true;
    }());
    _needsLayout = false;
  }

  @override
  void applyPaintTransform(RenderBox child, Matrix4 transform) {
    final BoxParentData childParentData = child.parentData! as BoxParentData;
    final Offset offset = childParentData.offset;
    transform.translate(offset.dx, offset.dy);
  }
}

// A RenderProxyBox that makes sure its `deferredLayoutChild` has a greater
// depth than itself.
class _RenderLayoutSurrogateProxyBox extends RenderProxyBox {
  _RenderDeferredLayoutBox? _deferredLayoutChild;

  @override
  void redepthChildren() {
    super.redepthChildren();
    final _RenderDeferredLayoutBox? child = _deferredLayoutChild;
    // If child is not attached, this method will be invoked by child's real
    // parent when it's attached.
    if (child != null && child.attached) {
      assert(child.attached);
      redepthChild(child);
    }
  }

  @override
  void performLayout() {
    super.performLayout();
    // Try to layout `_deferredLayoutChild` here now that its configuration
    // and constraints are up-to-date. Additionally, during the very first
    // layout, this makes sure that _deferredLayoutChild is reachable via tree
    // walk.
    _deferredLayoutChild?.layoutByLayoutSurrogate();
  }

  @override
  void visitChildrenForSemantics(RenderObjectVisitor visitor) {
    super.visitChildrenForSemantics(visitor);
    final _RenderDeferredLayoutBox? deferredChild = _deferredLayoutChild;
    if (deferredChild != null) {
      visitor(deferredChild);
    }
  }
}




Analyze the codebase context.
Identify the top 5-10 core most important abstractions to help those new to the codebase.

For each abstraction, provide:
1. A concise `name`.
2. A beginner-friendly `description` explaining what it is with a simple analogy, in around 100 words.
3. A list of relevant `file_indices` (integers) using the format `idx # path/comment`.

List of file indices and paths present in the context:
- 0 # packages/flutter/lib/src/widgets/overlay.dart

Format the output as a YAML list of dictionaries:

```yaml
- name: |
    Query Processing
  description: |
    Explains what the abstraction does.
    It's like a central dispatcher routing requests.
  file_indices:
    - 0 # path/to/file1.py
    - 3 # path/to/related.py
- name: |
    Query Optimization
  description: |
    Another core concept, similar to a blueprint for objects.
  file_indices:
    - 5 # path/to/another.js
# ... up to 10 abstractions
```
2025-05-22 23:56:36,467 - INFO - RESPONSE: ```yaml
- name: |
    Overlay
  description: |
    Think of an Overlay as a stack of transparent sheets (or "entries") placed on top of your regular UI content. Widgets in the Overlay float above everything else, like popups, dialogs, or tooltips. The Overlay helps manage which sheet is on top and visible.
  file_indices:
    - 0 # packages/flutter/lib/src/widgets/overlay.dart
- name: |
    OverlayEntry
  description: |
    An OverlayEntry is like one of the transparent sheets you can put into an Overlay. It holds a single widget that will be displayed on the Overlay. You can add or remove entries to control what pops up on top of your content. Each entry can decide if areas below it are visible (`opaque`) or if it should always be built even if hidden (`maintainState`).
  file_indices:
    - 0 # packages/flutter/lib/src/widgets/overlay.dart
- name: |
    OverlayState
  description: |
    This is the manager for an Overlay. It keeps track of all the OverlayEntry sheets currently in the stack. You use methods like `insert` and `remove` on the `OverlayState` to add or take out OverlayEntry sheets, changing what's visible on the Overlay.
  file_indices:
    - 0 # packages/flutter/lib/src/widgets/overlay.dart
- name: |
    OverlayPortal
  description: |
    An OverlayPortal is an alternative way to put a widget onto an Overlay. Instead of directly managing an OverlayEntry, you give the OverlayPortal a builder function that creates the widget you want to show. This widget then appears on the Overlay, but it acts like it's part of the OverlayPortal's original location in the widget tree for things like themes or other inherited widgets.
  file_indices:
    - 0 # packages/flutter/lib/src/widgets/overlay.dart
- name: |
    OverlayPortalController
  description: |
    This is like a remote control for an OverlayPortal. You use it to tell the linked OverlayPortal when to show or hide its special overlay widget. Calling `show()` makes the widget appear on the Overlay, and calling `hide()` makes it disappear. You can also use it to bring the widget to the front if multiple OverlayPortals are showing.
  file_indices:
    - 0 # packages/flutter/lib/src/widgets/overlay.dart
- name: |
    _Theater
  description: |
    _Theater is the internal rendering part of the Overlay. It's a special type of layout engine (similar to a Stack) that manages the visual arrangement of all the OverlayEntry widgets and the widgets from OverlayPortals. It handles which entries are visible and where they are positioned on the screen.
  file_indices:
    - 0 # packages/flutter/lib/src/widgets/overlay.dart
- name: |
    _OverlayEntryLocation
  description: |
    _OverlayEntryLocation is an internal concept used by OverlayPortal to track where its displayed widget should be placed within the Overlay's rendering structure (_Theater). It's like a ticket with a specific z-index that the OverlayPortal's widget uses to find its spot in the Overlay's visual stack, ensuring it's painted above the correct OverlayEntry.
  file_indices:
    - 0 # packages/flutter/lib/src/widgets/overlay.dart
- name: |
    _RenderDeferredLayoutBox
  description: |
    This is an internal behind-the-scenes helper for OverlayPortal. It receives the widget that should be shown on the Overlay but doesn't lay it out immediately. Instead, it waits for its layout "surrogate" (_RenderLayoutSurrogateProxyBox, the OverlayPortal's own render box) to be laid out first. This ensures the OverlayPortal's floating widget is laid out correctly relative to the Overlay itself, even though it's managed separately.
  file_indices:
    - 0 # packages/flutter/lib/src/widgets/overlay.dart
```
2025-05-22 23:56:36,479 - INFO - PROMPT: 
Based on the following abstractions and relevant code snippets from the project `flutter (overlay.dart)`:

List of Abstraction Indices and Names:
0 # Overlay

1 # OverlayEntry

2 # OverlayState

3 # OverlayPortal

4 # OverlayPortalController

5 # _Theater

6 # _OverlayEntryLocation

7 # _RenderDeferredLayoutBox


Context (Abstractions, Descriptions, Code):
Identified Abstractions:\n- Index 0: Overlay
 (Relevant file indices: [0])\n  Description: Think of an Overlay as a stack of transparent sheets (or "entries") placed on top of your regular UI content. Widgets in the Overlay float above everything else, like popups, dialogs, or tooltips. The Overlay helps manage which sheet is on top and visible.
\n- Index 1: OverlayEntry
 (Relevant file indices: [0])\n  Description: An OverlayEntry is like one of the transparent sheets you can put into an Overlay. It holds a single widget that will be displayed on the Overlay. You can add or remove entries to control what pops up on top of your content. Each entry can decide if areas below it are visible (`opaque`) or if it should always be built even if hidden (`maintainState`).
\n- Index 2: OverlayState
 (Relevant file indices: [0])\n  Description: This is the manager for an Overlay. It keeps track of all the OverlayEntry sheets currently in the stack. You use methods like `insert` and `remove` on the `OverlayState` to add or take out OverlayEntry sheets, changing what's visible on the Overlay.
\n- Index 3: OverlayPortal
 (Relevant file indices: [0])\n  Description: An OverlayPortal is an alternative way to put a widget onto an Overlay. Instead of directly managing an OverlayEntry, you give the OverlayPortal a builder function that creates the widget you want to show. This widget then appears on the Overlay, but it acts like it's part of the OverlayPortal's original location in the widget tree for things like themes or other inherited widgets.
\n- Index 4: OverlayPortalController
 (Relevant file indices: [0])\n  Description: This is like a remote control for an OverlayPortal. You use it to tell the linked OverlayPortal when to show or hide its special overlay widget. Calling `show()` makes the widget appear on the Overlay, and calling `hide()` makes it disappear. You can also use it to bring the widget to the front if multiple OverlayPortals are showing.
\n- Index 5: _Theater
 (Relevant file indices: [0])\n  Description: _Theater is the internal rendering part of the Overlay. It's a special type of layout engine (similar to a Stack) that manages the visual arrangement of all the OverlayEntry widgets and the widgets from OverlayPortals. It handles which entries are visible and where they are positioned on the screen.
\n- Index 6: _OverlayEntryLocation
 (Relevant file indices: [0])\n  Description: _OverlayEntryLocation is an internal concept used by OverlayPortal to track where its displayed widget should be placed within the Overlay's rendering structure (_Theater). It's like a ticket with a specific z-index that the OverlayPortal's widget uses to find its spot in the Overlay's visual stack, ensuring it's painted above the correct OverlayEntry.
\n- Index 7: _RenderDeferredLayoutBox
 (Relevant file indices: [0])\n  Description: This is an internal behind-the-scenes helper for OverlayPortal. It receives the widget that should be shown on the Overlay but doesn't lay it out immediately. Instead, it waits for its layout "surrogate" (_RenderLayoutSurrogateProxyBox, the OverlayPortal's own render box) to be laid out first. This ensures the OverlayPortal's floating widget is laid out correctly relative to the Overlay itself, even though it's managed separately.
\n\nRelevant File Snippets (Referenced by Index and Path):\n--- File: 0 # packages/flutter/lib/src/widgets/overlay.dart ---\n// Copyright 2014 The Flutter Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

/// @docImport 'package:flutter/cupertino.dart';
/// @docImport 'package:flutter/material.dart';
///
/// @docImport 'app.dart';
/// @docImport 'drag_target.dart';
/// @docImport 'implicit_animations.dart';
/// @docImport 'media_query.dart';
/// @docImport 'navigator.dart';
/// @docImport 'routes.dart';
/// @docImport 'scroll_view.dart';
/// @docImport 'sliver.dart';
/// @docImport 'text.dart';
library;

import 'dart:collection';

import 'package:flutter/foundation.dart';
import 'package:flutter/rendering.dart';
import 'package:flutter/scheduler.dart';

import 'basic.dart';
import 'framework.dart';
import 'lookup_boundary.dart';
import 'ticker_provider.dart';

const String _flutterWidgetsLibrary = 'package:flutter/widgets.dart';

// Examples can assume:
// late BuildContext context;

// * OverlayEntry Implementation

/// A place in an [Overlay] that can contain a widget.
///
/// Overlay entries are inserted into an [Overlay] using the
/// [OverlayState.insert] or [OverlayState.insertAll] functions. To find the
/// closest enclosing overlay for a given [BuildContext], use the [Overlay.of]
/// function.
///
/// An overlay entry can be in at most one overlay at a time. To remove an entry
/// from its overlay, call the [remove] function on the overlay entry.
///
/// Because an [Overlay] uses a [Stack] layout, overlay entries can use
/// [Positioned] and [AnimatedPositioned] to position themselves within the
/// overlay.
///
/// For example, [Draggable] uses an [OverlayEntry] to show the drag avatar that
/// follows the user's finger across the screen after the drag begins. Using the
/// overlay to display the drag avatar lets the avatar float over the other
/// widgets in the app. As the user's finger moves, draggable calls
/// [markNeedsBuild] on the overlay entry to cause it to rebuild. In its build,
/// the entry includes a [Positioned] with its top and left property set to
/// position the drag avatar near the user's finger. When the drag is over,
/// [Draggable] removes the entry from the overlay to remove the drag avatar
/// from view.
///
/// By default, if there is an entirely [opaque] entry over this one, then this
/// one will not be included in the widget tree (in particular, stateful widgets
/// within the overlay entry will not be instantiated). To ensure that your
/// overlay entry is still built even if it is not visible, set [maintainState]
/// to true. This is more expensive, so should be done with care. In particular,
/// if widgets in an overlay entry with [maintainState] set to true repeatedly
/// call [State.setState], the user's battery will be drained unnecessarily.
///
/// [OverlayEntry] is a [Listenable] that notifies when the widget built by
/// [builder] is mounted or unmounted, whose exact state can be queried by
/// [mounted]. After the owner of the [OverlayEntry] calls [remove] and then
/// [dispose], the widget may not be immediately removed from the widget tree.
/// As a result listeners of the [OverlayEntry] can get notified for one last
/// time after the [dispose] call, when the widget is eventually unmounted.
///
/// {@macro flutter.widgets.overlayPortalVsOverlayEntry}
///
/// See also:
///
///  * [OverlayPortal], an alternative API for inserting widgets into an
///    [Overlay] using a builder callback.
///  * [Overlay], a stack of entries that can be managed independently.
///  * [OverlayState], the current state of an Overlay.
///  * [WidgetsApp], a convenience widget that wraps a number of widgets that
///    are commonly required for an application.
///  * [MaterialApp], a convenience widget that wraps a number of widgets that
///    are commonly required for Material Design applications.
class OverlayEntry implements Listenable {
  /// Creates an overlay entry.
  ///
  /// To insert the entry into an [Overlay], first find the overlay using
  /// [Overlay.of] and then call [OverlayState.insert]. To remove the entry,
  /// call [remove] on the overlay entry itself.
  OverlayEntry({
    required this.builder,
    bool opaque = false,
    bool maintainState = false,
    this.canSizeOverlay = false,
  }) : _opaque = opaque,
       _maintainState = maintainState {
    if (kFlutterMemoryAllocationsEnabled) {
      _maybeDispatchObjectCreation();
    }
  }

  /// This entry will include the widget built by this builder in the overlay at
  /// the entry's position.
  ///
  /// To cause this builder to be called again, call [markNeedsBuild] on this
  /// overlay entry.
  final WidgetBuilder builder;

  /// Whether this entry occludes the entire overlay.
  ///
  /// If an entry claims to be opaque, then, for efficiency, the overlay will
  /// skip building entries below that entry unless they have [maintainState]
  /// set.
  bool get opaque => _opaque;
  bool _opaque;
  set opaque(bool value) {
    assert(!_disposedByOwner);
    if (_opaque == value) {
      return;
    }
    _opaque = value;
    _overlay?._didChangeEntryOpacity();
  }

  /// Whether this entry must be included in the tree even if there is a fully
  /// [opaque] entry above it.
  ///
  /// By default, if there is an entirely [opaque] entry over this one, then this
  /// one will not be included in the widget tree (in particular, stateful widgets
  /// within the overlay entry will not be instantiated). To ensure that your
  /// overlay entry is still built even if it is not visible, set [maintainState]
  /// to true. This is more expensive, so should be done with care. In particular,
  /// if widgets in an overlay entry with [maintainState] set to true repeatedly
  /// call [State.setState], the user's battery will be drained unnecessarily.
  ///
  /// This is used by the [Navigator] and [Route] objects to ensure that routes
  /// are kept around even when in the background, so that [Future]s promised
  /// from subsequent routes will be handled properly when they complete.
  bool get maintainState => _maintainState;
  bool _maintainState;
  set maintainState(bool value) {
    assert(!_disposedByOwner);
    if (_maintainState == value) {
      return;
    }
    _maintainState = value;
    assert(_overlay != null);
    _overlay!._didChangeEntryOpacity();
  }

  /// Whether the content of this [OverlayEntry] can be used to size the
  /// [Overlay].
  ///
  /// In most situations the overlay sizes itself based on its incoming
  /// constraints to be as large as possible. However, if that would result in
  /// an infinite size, it has to rely on one of its children to size itself. In
  /// this situation, the overlay will consult the topmost non-[Positioned]
  /// overlay entry that has this property set to true, lay it out with the
  /// incoming [BoxConstraints] of the overlay, and force all other
  /// non-[Positioned] overlay entries to have the same size. The [Positioned]
  /// entries are laid out as usual based on the calculated size of the overlay.
  ///
  /// Overlay entries that set this to true must be able to handle unconstrained
  /// [BoxConstraints].
  ///
  /// Setting this to true has no effect if the overlay entry uses a [Positioned]
  /// widget to position itself in the overlay.
  final bool canSizeOverlay;

  /// Whether the [OverlayEntry] is currently mounted in the widget tree.
  ///
  /// The [OverlayEntry] notifies its listeners when this value changes.
  bool get mounted => _overlayEntryStateNotifier?.value != null;

  /// The currently mounted `_OverlayEntryWidgetState` built using this [OverlayEntry].
  ValueNotifier<_OverlayEntryWidgetState?>? _overlayEntryStateNotifier =
      ValueNotifier<_OverlayEntryWidgetState?>(null);

  // TODO(polina-c): stop duplicating code across disposables
  // https://github.com/flutter/flutter/issues/137435
  /// Dispatches event of object creation to [FlutterMemoryAllocations.instance].
  void _maybeDispatchObjectCreation() {
    if (kFlutterMemoryAllocationsEnabled) {
      FlutterMemoryAllocations.instance.dispatchObjectCreated(
        library: _flutterWidgetsLibrary,
        className: '$OverlayEntry',
        object: this,
      );
    }
  }

  @override
  void addListener(VoidCallback listener) {
    assert(!_disposedByOwner);
    _overlayEntryStateNotifier?.addListener(listener);
  }

  @override
  void removeListener(VoidCallback listener) {
    _overlayEntryStateNotifier?.removeListener(listener);
  }

  OverlayState? _overlay;
  final GlobalKey<_OverlayEntryWidgetState> _key = GlobalKey<_OverlayEntryWidgetState>();

  /// Remove this entry from the overlay.
  ///
  /// This should only be called once.
  ///
  /// This method removes this overlay entry from the overlay immediately. The
  /// UI will be updated in the same frame if this method is called before the
  /// overlay rebuild in this frame; otherwise, the UI will be updated in the
  /// next frame. This means that it is safe to call during builds, but also
  /// that if you do call this after the overlay rebuild, the UI will not update
  /// until the next frame (i.e. many milliseconds later).
  void remove() {
    assert(_overlay != null);
    assert(!_disposedByOwner);
    final OverlayState overlay = _overlay!;
    _overlay = null;
    if (!overlay.mounted) {
      return;
    }

    overlay._entries.remove(this);
    if (SchedulerBinding.instance.schedulerPhase == SchedulerPhase.persistentCallbacks) {
      SchedulerBinding.instance.addPostFrameCallback((Duration duration) {
        overlay._markDirty();
      }, debugLabel: 'OverlayEntry.markDirty');
    } else {
      overlay._markDirty();
    }
  }

  /// Cause this entry to rebuild during the next pipeline flush.
  ///
  /// You need to call this function if the output of [builder] has changed.
  void markNeedsBuild() {
    assert(!_disposedByOwner);
    _key.currentState?._markNeedsBuild();
  }

  void _didUnmount() {
    assert(!mounted);
    if (_disposedByOwner) {
      _overlayEntryStateNotifier?.dispose();
      _overlayEntryStateNotifier = null;
    }
  }

  bool _disposedByOwner = false;

  /// Discards any resources used by this [OverlayEntry].
  ///
  /// This method must be called after [remove] if the [OverlayEntry] is
  /// inserted into an [Overlay].
  ///
  /// After this is called, the object is not in a usable state and should be
  /// discarded (calls to [addListener] will throw after the object is disposed).
  /// However, the listeners registered may not be immediately released until
  /// the widget built using this [OverlayEntry] is unmounted from the widget
  /// tree.
  ///
  /// This method should only be called by the object's owner.
  void dispose() {
    assert(!_disposedByOwner);
    assert(
      _overlay == null,
      'An OverlayEntry must first be removed from the Overlay before dispose is called.',
    );
    if (kFlutterMemoryAllocationsEnabled) {
      FlutterMemoryAllocations.instance.dispatchObjectDisposed(object: this);
    }
    _disposedByOwner = true;
    if (!mounted) {
      // If we're still mounted when disposed, then this will be disposed in
      // _didUnmount, to allow notifications to occur until the entry is
      // unmounted.
      _overlayEntryStateNotifier?.dispose();
      _overlayEntryStateNotifier = null;
    }
  }

  @override
  String toString() =>
      '${describeIdentity(this)}(opaque: $opaque; maintainState: $maintainState)${_disposedByOwner ? "(DISPOSED)" : ""}';
}

class _OverlayEntryWidget extends StatefulWidget {
  const _OverlayEntryWidget({
    required Key super.key,
    required this.entry,
    required this.overlayState,
    this.tickerEnabled = true,
  });

  final OverlayEntry entry;
  final OverlayState overlayState;
  final bool tickerEnabled;

  @override
  _OverlayEntryWidgetState createState() => _OverlayEntryWidgetState();
}

class _OverlayEntryWidgetState extends State<_OverlayEntryWidget> {
  late _RenderTheater _theater;

  // Manages the stack of theater children whose paint order are sorted by their
  // _zOrderIndex. The children added by OverlayPortal are added to this linked
  // list, and they will be shown _above_ the OverlayEntry tied to this widget.
  // The children with larger zOrderIndex values (i.e. those called `show`
  // recently) will be painted last.
  //
  // This linked list is lazily created in `_add`, and the entries are added/removed
  // via `_add`/`_remove`, called by OverlayPortals lower in the tree. `_add` or
  // `_remove` does not cause this widget to rebuild, the linked list will be
  // read by _RenderTheater as part of its render child model. This would ideally
  // be in a RenderObject but there may not be RenderObjects between
  // _RenderTheater and the render subtree OverlayEntry builds.
  LinkedList<_OverlayEntryLocation>? _sortedTheaterSiblings;

  // Worst-case O(N), N being the number of children added to the top spot in
  // the same frame. This can be a bit expensive when there's a lot of global
  // key reparenting in the same frame but N is usually a small number.
  void _add(_OverlayEntryLocation child) {
    assert(mounted);
    final LinkedList<_OverlayEntryLocation> children =
        _sortedTheaterSiblings ??= LinkedList<_OverlayEntryLocation>();
    assert(!children.contains(child));
    _OverlayEntryLocation? insertPosition = children.isEmpty ? null : children.last;
    while (insertPosition != null && insertPosition._zOrderIndex > child._zOrderIndex) {
      insertPosition = insertPosition.previous;
    }
    if (insertPosition == null) {
      children.addFirst(child);
    } else {
      insertPosition.insertAfter(child);
    }
    assert(children.contains(child));
  }

  void _remove(_OverlayEntryLocation child) {
    assert(_sortedTheaterSiblings != null);
    final bool wasInCollection = _sortedTheaterSiblings?.remove(child) ?? false;
    assert(wasInCollection);
  }

  // Returns an Iterable that traverse the children in the child model in paint
  // order (from farthest to the user to the closest to the user).
  //
  // The iterator should be safe to use even when the child model is being
  // mutated. The reason for that is it's allowed to add/remove/move deferred
  // children to a _RenderTheater during performLayout, but the affected
  // children don't have to be laid out in the same performLayout call.
  late final Iterable<RenderBox> _paintOrderIterable = _createChildIterable(reversed: false);
  // An Iterable that traverse the children in the child model in
  // hit-test order (from closest to the user to the farthest to the user).
  late final Iterable<RenderBox> _hitTestOrderIterable = _createChildIterable(reversed: true);

  // The following uses sync* because hit-testing is lazy, and LinkedList as a
  // Iterable doesn't support concurrent modification.
  Iterable<RenderBox> _createChildIterable({required bool reversed}) sync* {
    final LinkedList<_OverlayEntryLocation>? children = _sortedTheaterSiblings;
    if (children == null || children.isEmpty) {
      return;
    }
    _OverlayEntryLocation? candidate = reversed ? children.last : children.first;
    while (candidate != null) {
      final RenderBox? renderBox = candidate._overlayChildRenderBox;
      candidate = reversed ? candidate.previous : candidate.next;
      if (renderBox != null) {
        yield renderBox;
      }
    }
  }

  @override
  void initState() {
    super.initState();
    widget.entry._overlayEntryStateNotifier!.value = this;
    _theater = context.findAncestorRenderObjectOfType<_RenderTheater>()!;
    assert(_sortedTheaterSiblings == null);
  }

  @override
  void didUpdateWidget(_OverlayEntryWidget oldWidget) {
    super.didUpdateWidget(oldWidget);
    // OverlayState's build method always returns a RenderObjectWidget _Theater,
    // so it's safe to assume that state equality implies render object equality.
    assert(oldWidget.entry == widget.entry);
    if (oldWidget.overlayState != widget.overlayState) {
      final _RenderTheater newTheater = context.findAncestorRenderObjectOfType<_RenderTheater>()!;
      assert(_theater != newTheater);
      _theater = newTheater;
    }
  }

  @override
  void dispose() {
    widget.entry._overlayEntryStateNotifier?.value = null;
    widget.entry._didUnmount();
    _sortedTheaterSiblings = null;
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    return TickerMode(
      enabled: widget.tickerEnabled,
      child: _RenderTheaterMarker(
        theater: _theater,
        overlayEntryWidgetState: this,
        child: widget.entry.builder(context),
      ),
    );
  }

  void _markNeedsBuild() {
    setState(() {
      /* the state that changed is in the builder */
    });
  }
}

/// A stack of entries that can be managed independently.
///
/// Overlays let independent child widgets "float" visual elements on top of
/// other widgets by inserting them into the overlay's stack. The overlay lets
/// each of these widgets manage their participation in the overlay using
/// [OverlayEntry] objects.
///
/// Although you can create an [Overlay] directly, it's most common to use the
/// overlay created by the [Navigator] in a [WidgetsApp], [CupertinoApp] or a
/// [MaterialApp]. The navigator uses its overlay to manage the visual
/// appearance of its routes.
///
/// The [Overlay] widget uses a custom stack implementation, which is very
/// similar to the [Stack] widget. The main use case of [Overlay] is related to
/// navigation and being able to insert widgets on top of the pages in an app.
/// For layout purposes unrelated to navigation, consider using [Stack] instead.
///
/// An [Overlay] widget requires a [Directionality] widget to be in scope, so
/// that it can resolve direction-sensitive coordinates of any
/// [Positioned.directional] children.
///
/// For widgets drawn in an [OverlayEntry], do not assume that the size of the
/// [Overlay] is the size returned by [MediaQuery.sizeOf]. Nested overlays can
/// have different sizes.
///
/// {@tool dartpad}
/// This example shows how to use the [Overlay] to highlight the [NavigationBar]
/// destination.
///
/// ** See code in examples/api/lib/widgets/overlay/overlay.0.dart **
/// {@end-tool}
///
/// See also:
///
///  * [OverlayEntry], the class that is used for describing the overlay entries.
///  * [OverlayState], which is used to insert the entries into the overlay.
///  * [WidgetsApp], which inserts an [Overlay] widget indirectly via its [Navigator].
///  * [MaterialApp], which inserts an [Overlay] widget indirectly via its [Navigator].
///  * [CupertinoApp], which inserts an [Overlay] widget indirectly via its [Navigator].
///  * [Stack], which allows directly displaying a stack of widgets.
class Overlay extends StatefulWidget {
  /// Creates an overlay.
  ///
  /// The initial entries will be inserted into the overlay when its associated
  /// [OverlayState] is initialized.
  ///
  /// Rather than creating an overlay, consider using the overlay that is
  /// created by the [Navigator] in a [WidgetsApp], [CupertinoApp], or a
  /// [MaterialApp] for the application.
  const Overlay({
    super.key,
    this.initialEntries = const <OverlayEntry>[],
    this.clipBehavior = Clip.hardEdge,
  });

  /// Wrap the provided `child` in an [Overlay] to allow other visual elements
  /// (packed in [OverlayEntry]s) to float on top of the child.
  ///
  /// This is a convenience method over the regular [Overlay] constructor: It
  /// creates an [Overlay] and puts the provided `child` in an [OverlayEntry]
  /// at the bottom of that newly created Overlay.
  static Widget wrap({Key? key, Clip clipBehavior = Clip.hardEdge, required Widget child}) {
    return _WrappingOverlay(key: key, clipBehavior: clipBehavior, child: child);
  }

  /// The entries to include in the overlay initially.
  ///
  /// These entries are only used when the [OverlayState] is initialized. If you
  /// are providing a new [Overlay] description for an overlay that's already in
  /// the tree, then the new entries are ignored.
  ///
  /// To add entries to an [Overlay] that is already in the tree, use
  /// [Overlay.of] to obtain the [OverlayState] (or assign a [GlobalKey] to the
  /// [Overlay] widget and obtain the [OverlayState] via
  /// [GlobalKey.currentState]), and then use [OverlayState.insert] or
  /// [OverlayState.insertAll].
  ///
  /// To remove an entry from an [Overlay], use [OverlayEntry.remove].
  final List<OverlayEntry> initialEntries;

  /// {@macro flutter.material.Material.clipBehavior}
  ///
  /// Defaults to [Clip.hardEdge].
  final Clip clipBehavior;

  /// The [OverlayState] from the closest instance of [Overlay] that encloses
  /// the given context within the closest [LookupBoundary], and, in debug mode,
  /// will throw if one is not found.
  ///
  /// In debug mode, if the `debugRequiredFor` argument is provided and an
  /// overlay isn't found, then this function will throw an exception containing
  /// the runtime type of the given widget in the error message. The exception
  /// attempts to explain that the calling [Widget] (the one given by the
  /// `debugRequiredFor` argument) needs an [Overlay] to be present to function.
  /// If `debugRequiredFor` is not supplied, then the error message is more
  /// generic.
  ///
  /// Typical usage is as follows:
  ///
  /// ```dart
  /// OverlayState overlay = Overlay.of(context);
  /// ```
  ///
  /// If `rootOverlay` is set to true, the state from the furthest instance of
  /// this class is given instead. Useful for installing overlay entries above
  /// all subsequent instances of [Overlay].
  ///
  /// This method can be expensive (it walks the element tree).
  ///
  /// See also:
  ///
  /// * [Overlay.maybeOf] for a similar function that returns null if an
  ///   [Overlay] is not found.
  static OverlayState of(
    BuildContext context, {
    bool rootOverlay = false,
    Widget? debugRequiredFor,
  }) {
    final OverlayState? result = maybeOf(context, rootOverlay: rootOverlay);
    assert(() {
      if (result == null) {
        final bool hiddenByBoundary = LookupBoundary.debugIsHidingAncestorStateOfType<OverlayState>(
          context,
        );
        final List<DiagnosticsNode> information = <DiagnosticsNode>[
          ErrorSummary(
            'No Overlay widget found${hiddenByBoundary ? ' within the closest LookupBoundary' : ''}.',
          ),
          if (hiddenByBoundary)
            ErrorDescription(
              'There is an ancestor Overlay widget, but it is hidden by a LookupBoundary.',
            ),
          ErrorDescription(
            '${debugRequiredFor?.runtimeType ?? 'Some'} widgets require an Overlay widget ancestor for correct operation.',
          ),
          ErrorHint(
            'The most common way to add an Overlay to an application is to include a MaterialApp, CupertinoApp or Navigator widget in the runApp() call.',
          ),
          if (debugRequiredFor != null)
            DiagnosticsProperty<Widget>(
              'The specific widget that failed to find an overlay was',
              debugRequiredFor,
              style: DiagnosticsTreeStyle.errorProperty,
            ),
          if (context.widget != debugRequiredFor)
            context.describeElement(
              'The context from which that widget was searching for an overlay was',
            ),
        ];

        throw FlutterError.fromParts(information);
      }
      return true;
    }());
    return result!;
  }

  /// The [OverlayState] from the closest instance of [Overlay] that encloses
  /// the given context within the closest [LookupBoundary], if any.
  ///
  /// Typical usage is as follows:
  ///
  /// ```dart
  /// OverlayState? overlay = Overlay.maybeOf(context);
  /// ```
  ///
  /// If `rootOverlay` is set to true, the state from the furthest instance of
  /// this class is given instead. Useful for installing overlay entries above
  /// all subsequent instances of [Overlay].
  ///
  /// This method can be expensive (it walks the element tree).
  ///
  /// See also:
  ///
  ///  * [Overlay.of] for a similar function that returns a non-nullable result
  ///    and throws if an [Overlay] is not found.

  static OverlayState? maybeOf(BuildContext context, {bool rootOverlay = false}) {
    return rootOverlay
        ? LookupBoundary.findRootAncestorStateOfType<OverlayState>(context)
        : LookupBoundary.findAncestorStateOfType<OverlayState>(context);
  }

  @override
  OverlayState createState() => OverlayState();
}

/// The current state of an [Overlay].
///
/// Used to insert [OverlayEntry]s into the overlay using the [insert] and
/// [insertAll] functions.
class OverlayState extends State<Overlay> with TickerProviderStateMixin {
  final List<OverlayEntry> _entries = <OverlayEntry>[];

  @protected
  @override
  void initState() {
    super.initState();
    insertAll(widget.initialEntries);
  }

  int _insertionIndex(OverlayEntry? below, OverlayEntry? above) {
    assert(above == null || below == null);
    if (below != null) {
      return _entries.indexOf(below);
    }
    if (above != null) {
      return _entries.indexOf(above) + 1;
    }
    return _entries.length;
  }

  bool _debugCanInsertEntry(OverlayEntry entry) {
    final List<DiagnosticsNode> operandsInformation = <DiagnosticsNode>[
      DiagnosticsProperty<OverlayEntry>(
        'The OverlayEntry was',
        entry,
        style: DiagnosticsTreeStyle.errorProperty,
      ),
      DiagnosticsProperty<OverlayState>(
        'The Overlay the OverlayEntry was trying to insert to was',
        this,
        style: DiagnosticsTreeStyle.errorProperty,
      ),
    ];

    if (!mounted) {
      throw FlutterError.fromParts(<DiagnosticsNode>[
        ErrorSummary('Attempted to insert an OverlayEntry to an already disposed Overlay.'),
        ...operandsInformation,
      ]);
    }

    final OverlayState? currentOverlay = entry._overlay;
    final bool alreadyContainsEntry = _entries.contains(entry);

    if (alreadyContainsEntry) {
      final bool inconsistentOverlayState = !identical(currentOverlay, this);
      throw FlutterError.fromParts(<DiagnosticsNode>[
        ErrorSummary('The specified entry is already present in the target Overlay.'),
        ...operandsInformation,
        if (inconsistentOverlayState)
          ErrorHint('This could be an error in the Flutter framework.')
        else
          ErrorHint(
            'Consider calling remove on the OverlayEntry before inserting it to a different Overlay, '
            'or switching to the OverlayPortal API to avoid manual OverlayEntry management.',
          ),
        if (inconsistentOverlayState)
          DiagnosticsProperty<OverlayState>(
            "The OverlayEntry's current Overlay was",
            currentOverlay,
            style: DiagnosticsTreeStyle.errorProperty,
          ),
      ]);
    }

    if (currentOverlay == null) {
      return true;
    }

    throw FlutterError.fromParts(<DiagnosticsNode>[
      ErrorSummary('The specified entry is already present in a different Overlay.'),
      ...operandsInformation,
      DiagnosticsProperty<OverlayState>(
        "The OverlayEntry's current Overlay was",
        currentOverlay,
        style: DiagnosticsTreeStyle.errorProperty,
      ),
      ErrorHint(
        'Consider calling remove on the OverlayEntry before inserting it to a different Overlay, '
        'or switching to the OverlayPortal API to avoid manual OverlayEntry management.',
      ),
    ]);
  }

  /// Insert the given entry into the overlay.
  ///
  /// If `below` is non-null, the entry is inserted just below `below`.
  /// If `above` is non-null, the entry is inserted just above `above`.
  /// Otherwise, the entry is inserted on top.
  ///
  /// It is an error to specify both `above` and `below`.
  void insert(OverlayEntry entry, {OverlayEntry? below, OverlayEntry? above}) {
    assert(_debugVerifyInsertPosition(above, below));
    assert(_debugCanInsertEntry(entry));
    entry._overlay = this;
    setState(() {
      _entries.insert(_insertionIndex(below, above), entry);
    });
  }

  /// Insert all the entries in the given iterable.
  ///
  /// If `below` is non-null, the entries are inserted just below `below`.
  /// If `above` is non-null, the entries are inserted just above `above`.
  /// Otherwise, the entries are inserted on top.
  ///
  /// It is an error to specify both `above` and `below`.
  void insertAll(Iterable<OverlayEntry> entries, {OverlayEntry? below, OverlayEntry? above}) {
    assert(_debugVerifyInsertPosition(above, below));
    assert(entries.every(_debugCanInsertEntry));
    if (entries.isEmpty) {
      return;
    }
    for (final OverlayEntry entry in entries) {
      assert(entry._overlay == null);
      entry._overlay = this;
    }
    setState(() {
      _entries.insertAll(_insertionIndex(below, above), entries);
    });
  }

  bool _debugVerifyInsertPosition(
    OverlayEntry? above,
    OverlayEntry? below, {
    Iterable<OverlayEntry>? newEntries,
  }) {
    assert(above == null || below == null, 'Only one of `above` and `below` may be specified.');
    assert(
      above == null ||
          (above._overlay == this &&
              _entries.contains(above) &&
              (newEntries?.contains(above) ?? true)),
      'The provided entry used for `above` must be present in the Overlay${newEntries != null ? ' and in the `newEntriesList`' : ''}.',
    );
    assert(
      below == null ||
          (below._overlay == this &&
              _entries.contains(below) &&
              (newEntries?.contains(below) ?? true)),
      'The provided entry used for `below` must be present in the Overlay${newEntries != null ? ' and in the `newEntriesList`' : ''}.',
    );
    return true;
  }

  /// Remove all the entries listed in the given iterable, then reinsert them
  /// into the overlay in the given order.
  ///
  /// Entries mention in `newEntries` but absent from the overlay are inserted
  /// as if with [insertAll].
  ///
  /// Entries not mentioned in `newEntries` but present in the overlay are
  /// positioned as a group in the resulting list relative to the entries that
  /// were moved, as specified by one of `below` or `above`, which, if
  /// specified, must be one of the entries in `newEntries`:
  ///
  /// If `below` is non-null, the group is positioned just below `below`.
  /// If `above` is non-null, the group is positioned just above `above`.
  /// Otherwise, the group is left on top, with all the rearranged entries
  /// below.
  ///
  /// It is an error to specify both `above` and `below`.
  void rearrange(Iterable<OverlayEntry> newEntries, {OverlayEntry? below, OverlayEntry? above}) {
    final List<OverlayEntry> newEntriesList =
        newEntries is List<OverlayEntry> ? newEntries : newEntries.toList(growable: false);
    assert(_debugVerifyInsertPosition(above, below, newEntries: newEntriesList));
    assert(
      newEntriesList.every(
        (OverlayEntry entry) => entry._overlay == null || entry._overlay == this,
      ),
      'One or more of the specified entries are already present in another Overlay.',
    );
    assert(
      newEntriesList.every(
        (OverlayEntry entry) => _entries.indexOf(entry) == _entries.lastIndexOf(entry),
      ),
      'One or more of the specified entries are specified multiple times.',
    );
    if (newEntriesList.isEmpty) {
      return;
    }
    if (listEquals(_entries, newEntriesList)) {
      return;
    }
    final LinkedHashSet<OverlayEntry> old = LinkedHashSet<OverlayEntry>.of(_entries);
    for (final OverlayEntry entry in newEntriesList) {
      entry._overlay ??= this;
    }
    setState(() {
      _entries.clear();
      _entries.addAll(newEntriesList);
      old.removeAll(newEntriesList);
      _entries.insertAll(_insertionIndex(below, above), old);
    });
  }

  void _markDirty() {
    if (mounted) {
      setState(() {});
    }
  }

  /// (DEBUG ONLY) Check whether a given entry is visible (i.e., not behind an
  /// opaque entry).
  ///
  /// This is an O(N) algorithm, and should not be necessary except for debug
  /// asserts. To avoid people depending on it, this function is implemented
  /// only in debug mode, and always returns false in release mode.
  bool debugIsVisible(OverlayEntry entry) {
    bool result = false;
    assert(_entries.contains(entry));
    assert(() {
      for (int i = _entries.length - 1; i > 0; i -= 1) {
        final OverlayEntry candidate = _entries[i];
        if (candidate == entry) {
          result = true;
          break;
        }
        if (candidate.opaque) {
          break;
        }
      }
      return true;
    }());
    return result;
  }

  void _didChangeEntryOpacity() {
    setState(() {
      // We use the opacity of the entry in our build function, which means we
      // our state has changed.
    });
  }

  @protected
  @override
  Widget build(BuildContext context) {
    // This list is filled backwards and then reversed below before
    // it is added to the tree.
    final List<_OverlayEntryWidget> children = <_OverlayEntryWidget>[];
    bool onstage = true;
    int onstageCount = 0;
    for (final OverlayEntry entry in _entries.reversed) {
      if (onstage) {
        onstageCount += 1;
        children.add(_OverlayEntryWidget(key: entry._key, overlayState: this, entry: entry));
        if (entry.opaque) {
          onstage = false;
        }
      } else if (entry.maintainState) {
        children.add(
          _OverlayEntryWidget(
            key: entry._key,
            overlayState: this,
            entry: entry,
            tickerEnabled: false,
          ),
        );
      }
    }
    return _Theater(
      skipCount: children.length - onstageCount,
      clipBehavior: widget.clipBehavior,
      children: children.reversed.toList(growable: false),
    );
  }

  @protected
  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    // TODO(jacobr): use IterableProperty instead as that would
    // provide a slightly more consistent string summary of the List.
    properties.add(DiagnosticsProperty<List<OverlayEntry>>('entries', _entries));
  }
}

class _WrappingOverlay extends StatefulWidget {
  const _WrappingOverlay({super.key, this.clipBehavior = Clip.hardEdge, required this.child});

  final Clip clipBehavior;
  final Widget child;

  @override
  State<_WrappingOverlay> createState() => _WrappingOverlayState();
}

class _WrappingOverlayState extends State<_WrappingOverlay> {
  late final OverlayEntry _entry = OverlayEntry(
    canSizeOverlay: true,
    opaque: true,
    builder: (BuildContext context) {
      return widget.child;
    },
  );

  @override
  void didUpdateWidget(_WrappingOverlay oldWidget) {
    super.didUpdateWidget(oldWidget);
    _entry.markNeedsBuild();
  }

  @override
  void dispose() {
    _entry
      ..remove()
      ..dispose();
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    return Overlay(clipBehavior: widget.clipBehavior, initialEntries: <OverlayEntry>[_entry]);
  }
}

/// Special version of a [Stack], that doesn't layout and render the first
/// [skipCount] children.
///
/// The first [skipCount] children are considered "offstage".
class _Theater extends MultiChildRenderObjectWidget {
  const _Theater({
    this.skipCount = 0,
    this.clipBehavior = Clip.hardEdge,
    required List<_OverlayEntryWidget> super.children,
  }) : assert(skipCount >= 0),
       assert(children.length >= skipCount);

  final int skipCount;

  final Clip clipBehavior;

  @override
  _TheaterElement createElement() => _TheaterElement(this);

  @override
  _RenderTheater createRenderObject(BuildContext context) {
    return _RenderTheater(
      skipCount: skipCount,
      textDirection: Directionality.of(context),
      clipBehavior: clipBehavior,
    );
  }

  @override
  void updateRenderObject(BuildContext context, _RenderTheater renderObject) {
    renderObject
      ..skipCount = skipCount
      ..textDirection = Directionality.of(context)
      ..clipBehavior = clipBehavior;
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties.add(IntProperty('skipCount', skipCount));
  }
}

class _TheaterElement extends MultiChildRenderObjectElement {
  _TheaterElement(_Theater super.widget);

  @override
  _RenderTheater get renderObject => super.renderObject as _RenderTheater;

  @override
  void insertRenderObjectChild(RenderBox child, IndexedSlot<Element?> slot) {
    super.insertRenderObjectChild(child, slot);
    final _TheaterParentData parentData = child.parentData! as _TheaterParentData;
    parentData.overlayEntry =
        ((widget as _Theater).children[slot.index] as _OverlayEntryWidget).entry;
    assert(parentData.overlayEntry != null);
  }

  @override
  void moveRenderObjectChild(
    RenderBox child,
    IndexedSlot<Element?> oldSlot,
    IndexedSlot<Element?> newSlot,
  ) {
    super.moveRenderObjectChild(child, oldSlot, newSlot);
    assert(() {
      final _TheaterParentData parentData = child.parentData! as _TheaterParentData;
      return parentData.overlayEntry ==
          ((widget as _Theater).children[newSlot.index] as _OverlayEntryWidget).entry;
    }());
  }

  @override
  void debugVisitOnstageChildren(ElementVisitor visitor) {
    final _Theater theater = widget as _Theater;
    assert(children.length >= theater.skipCount);
    children.skip(theater.skipCount).forEach(visitor);
  }
}

// A `RenderBox` that sizes itself to its parent's size, implements the stack
// layout algorithm and renders its children in the given `theater`.
mixin _RenderTheaterMixin on RenderBox {
  _RenderTheater get theater;

  Iterable<RenderBox> _childrenInPaintOrder();
  Iterable<RenderBox> _childrenInHitTestOrder();

  @override
  void setupParentData(RenderBox child) {
    if (child.parentData is! StackParentData) {
      child.parentData = StackParentData();
    }
  }

  @override
  double? computeDistanceToActualBaseline(TextBaseline baseline) {
    assert(!debugNeedsLayout);
    BaselineOffset baselineOffset = BaselineOffset.noBaseline;
    for (final RenderBox child in _childrenInPaintOrder()) {
      assert(!child.debugNeedsLayout);
      final StackParentData childParentData = child.parentData! as StackParentData;
      baselineOffset = baselineOffset.minOf(
        BaselineOffset(child.getDistanceToActualBaseline(baseline)) + childParentData.offset.dy,
      );
    }
    return baselineOffset.offset;
  }

  static double? baselineForChild(
    RenderBox child,
    Size theaterSize,
    BoxConstraints nonPositionedChildConstraints,
    Alignment alignment,
    TextBaseline baseline,
  ) {
    final StackParentData childParentData = child.parentData! as StackParentData;
    final BoxConstraints childConstraints =
        childParentData.isPositioned
            ? childParentData.positionedChildConstraints(theaterSize)
            : nonPositionedChildConstraints;
    final double? baselineOffset = child.getDryBaseline(childConstraints, baseline);
    if (baselineOffset == null) {
      return null;
    }
    final double y = switch (childParentData) {
      StackParentData(:final double top?) => top,
      StackParentData(:final double bottom?) =>
        theaterSize.height - bottom - child.getDryLayout(childConstraints).height,
      StackParentData() =>
        alignment.alongOffset(theaterSize - child.getDryLayout(childConstraints) as Offset).dy,
    };
    return baselineOffset + y;
  }

  void layoutChild(RenderBox child, BoxConstraints nonPositionedChildConstraints) {
    final StackParentData childParentData = child.parentData! as StackParentData;
    final Alignment alignment = theater._resolvedAlignment;
    if (!childParentData.isPositioned) {
      child.layout(nonPositionedChildConstraints, parentUsesSize: true);
      childParentData.offset = Offset.zero;
    } else {
      assert(
        child is! _RenderDeferredLayoutBox,
        'all _RenderDeferredLayoutBoxes must be non-positioned children.',
      );
      RenderStack.layoutPositionedChild(child, childParentData, size, alignment);
    }
    assert(child.parentData == childParentData);
  }

  @override
  bool hitTestChildren(BoxHitTestResult result, {required Offset position}) {
    final Iterator<RenderBox> iterator = _childrenInHitTestOrder().iterator;
    bool isHit = false;
    while (!isHit && iterator.moveNext()) {
      final RenderBox child = iterator.current;
      final StackParentData childParentData = child.parentData! as StackParentData;
      final RenderBox localChild = child;
      bool childHitTest(BoxHitTestResult result, Offset position) =>
          localChild.hitTest(result, position: position);
      isHit = result.addWithPaintOffset(
        offset: childParentData.offset,
        position: position,
        hitTest: childHitTest,
      );
    }
    return isHit;
  }

  @override
  void paint(PaintingContext context, Offset offset) {
    for (final RenderBox child in _childrenInPaintOrder()) {
      final StackParentData childParentData = child.parentData! as StackParentData;
      context.paintChild(child, childParentData.offset + offset);
    }
  }
}

class _TheaterParentData extends StackParentData {
  // The OverlayEntry that directly created this child. This field is null for
  // children that are created by an OverlayPortal.
  OverlayEntry? overlayEntry;

  /// A [OverlayPortal] makes its overlay child a render child of an ancestor
  /// [Overlay]. Currently, to make sure the overlay child is painted after its
  /// [OverlayPortal], and before the next [OverlayEntry] (which could be
  /// something that should obstruct the overlay child, such as a [ModalRoute])
  /// in the host [Overlay], the paint order of each overlay child is managed by
  /// the [OverlayEntry] that hosts its [OverlayPortal].
  ///
  /// The following methods are exposed to allow easy access to the overlay
  /// children's render objects whose order is managed by [overlayEntry], in the
  /// right order.

  // _overlayStateMounted is set to null in _OverlayEntryWidgetState's dispose
  // method. This property is only accessed during layout, paint and hit-test so
  // the `value!` should be safe.
  Iterator<RenderBox>? get paintOrderIterator =>
      overlayEntry?._overlayEntryStateNotifier?.value!._paintOrderIterable.iterator;
  Iterator<RenderBox>? get hitTestOrderIterator =>
      overlayEntry?._overlayEntryStateNotifier?.value!._hitTestOrderIterable.iterator;

  // A convenience method for traversing `paintOrderIterator` with a
  // [RenderObjectVisitor].
  void visitOverlayPortalChildrenOnOverlayEntry(RenderObjectVisitor visitor) =>
      overlayEntry?._overlayEntryStateNotifier?.value!._paintOrderIterable.forEach(visitor);
}

class _RenderTheater extends RenderBox
    with ContainerRenderObjectMixin<RenderBox, StackParentData>, _RenderTheaterMixin {
  _RenderTheater({
    List<RenderBox>? children,
    required TextDirection textDirection,
    int skipCount = 0,
    Clip clipBehavior = Clip.hardEdge,
  }) : assert(skipCount >= 0),
       _textDirection = textDirection,
       _skipCount = skipCount,
       _clipBehavior = clipBehavior {
    addAll(children);
  }

  @override
  _RenderTheater get theater => this;

  @override
  void setupParentData(RenderBox child) {
    if (child.parentData is! _TheaterParentData) {
      child.parentData = _TheaterParentData();
    }
  }

  @override
  void attach(PipelineOwner owner) {
    super.attach(owner);
    RenderBox? child = firstChild;
    while (child != null) {
      final _TheaterParentData childParentData = child.parentData! as _TheaterParentData;
      final Iterator<RenderBox>? iterator = childParentData.paintOrderIterator;
      if (iterator != null) {
        while (iterator.moveNext()) {
          iterator.current.attach(owner);
        }
      }
      child = childParentData.nextSibling;
    }
  }

  static void _detachChild(RenderObject child) => child.detach();

  @override
  void detach() {
    super.detach();
    RenderBox? child = firstChild;
    while (child != null) {
      final _TheaterParentData childParentData = child.parentData! as _TheaterParentData;
      childParentData.visitOverlayPortalChildrenOnOverlayEntry(_detachChild);
      child = childParentData.nextSibling;
    }
  }

  @override
  void redepthChildren() => visitChildren(redepthChild);

  Alignment? _alignmentCache;
  Alignment get _resolvedAlignment =>
      _alignmentCache ??= AlignmentDirectional.topStart.resolve(textDirection);

  void _markNeedResolution() {
    _alignmentCache = null;
    markNeedsLayout();
  }

  TextDirection get textDirection => _textDirection;
  TextDirection _textDirection;
  set textDirection(TextDirection value) {
    if (_textDirection == value) {
      return;
    }
    _textDirection = value;
    _markNeedResolution();
  }

  int get skipCount => _skipCount;
  int _skipCount;
  set skipCount(int value) {
    if (_skipCount != value) {
      _skipCount = value;
      markNeedsLayout();
    }
  }

  /// {@macro flutter.material.Material.clipBehavior}
  ///
  /// Defaults to [Clip.hardEdge].
  Clip get clipBehavior => _clipBehavior;
  Clip _clipBehavior = Clip.hardEdge;
  set clipBehavior(Clip value) {
    if (value != _clipBehavior) {
      _clipBehavior = value;
      markNeedsPaint();
      markNeedsSemanticsUpdate();
    }
  }

  // Adding/removing deferred child does not affect the layout of other children,
  // or that of the Overlay, so there's no need to invalidate the layout of the
  // Overlay.
  //
  // When _skipMarkNeedsLayout is true, markNeedsLayout does not do anything.
  bool _skipMarkNeedsLayout = false;
  void _addDeferredChild(_RenderDeferredLayoutBox child) {
    assert(!_skipMarkNeedsLayout);
    _skipMarkNeedsLayout = true;
    adoptChild(child);
    // The Overlay still needs repainting when a deferred child is added. Usually
    // `markNeedsLayout` implies `markNeedsPaint`, but here `markNeedsLayout` is
    // skipped when the `_skipMarkNeedsLayout` flag is set.
    markNeedsPaint();
    _skipMarkNeedsLayout = false;

    // After adding `child` to the render tree, we want to make sure it will be
    // laid out in the same frame. This is done by calling markNeedsLayout on the
    // layout surrogate. This ensures `child` is reachable via tree walk (see
    // _RenderLayoutSurrogateProxyBox.performLayout).
    child._layoutSurrogate.markNeedsLayout();
  }

  void _removeDeferredChild(_RenderDeferredLayoutBox child) {
    assert(!_skipMarkNeedsLayout);
    _skipMarkNeedsLayout = true;
    dropChild(child);
    // The Overlay still needs repainting when a deferred child is dropped. See
    // the comment in `_addDeferredChild`.
    markNeedsPaint();
    _skipMarkNeedsLayout = false;
  }

  @override
  void markNeedsLayout() {
    if (!_skipMarkNeedsLayout) {
      super.markNeedsLayout();
    }
  }

  RenderBox? get _firstOnstageChild {
    if (skipCount == super.childCount) {
      return null;
    }
    RenderBox? child = super.firstChild;
    for (int toSkip = skipCount; toSkip > 0; toSkip--) {
      final StackParentData childParentData = child!.parentData! as StackParentData;
      child = childParentData.nextSibling;
      assert(child != null);
    }
    return child;
  }

  RenderBox? get _lastOnstageChild => skipCount == super.childCount ? null : lastChild;

  @override
  double computeMinIntrinsicWidth(double height) {
    return RenderStack.getIntrinsicDimension(
      _firstOnstageChild,
      (RenderBox child) => child.getMinIntrinsicWidth(height),
    );
  }

  @override
  double computeMaxIntrinsicWidth(double height) {
    return RenderStack.getIntrinsicDimension(
      _firstOnstageChild,
      (RenderBox child) => child.getMaxIntrinsicWidth(height),
    );
  }

  @override
  double computeMinIntrinsicHeight(double width) {
    return RenderStack.getIntrinsicDimension(
      _firstOnstageChild,
      (RenderBox child) => child.getMinIntrinsicHeight(width),
    );
  }

  @override
  double computeMaxIntrinsicHeight(double width) {
    return RenderStack.getIntrinsicDimension(
      _firstOnstageChild,
      (RenderBox child) => child.getMaxIntrinsicHeight(width),
    );
  }

  @override
  double? computeDryBaseline(BoxConstraints constraints, TextBaseline baseline) {
    final Size size =
        constraints.biggest.isFinite
            ? constraints.biggest
            : _findSizeDeterminingChild().getDryLayout(constraints);
    final BoxConstraints nonPositionedChildConstraints = BoxConstraints.tight(size);
    final Alignment alignment = theater._resolvedAlignment;

    BaselineOffset baselineOffset = BaselineOffset.noBaseline;
    for (final RenderBox child in _childrenInPaintOrder()) {
      baselineOffset = baselineOffset.minOf(
        BaselineOffset(
          _RenderTheaterMixin.baselineForChild(
            child,
            size,
            nonPositionedChildConstraints,
            alignment,
            baseline,
          ),
        ),
      );
    }
    return baselineOffset.offset;
  }

  @override
  Size computeDryLayout(BoxConstraints constraints) {
    if (constraints.biggest.isFinite) {
      return constraints.biggest;
    }
    return _findSizeDeterminingChild().getDryLayout(constraints);
  }

  @override
  // The following uses sync* because concurrent modifications should be allowed
  // during layout.
  Iterable<RenderBox> _childrenInPaintOrder() sync* {
    RenderBox? child = _firstOnstageChild;
    while (child != null) {
      yield child;
      final _TheaterParentData childParentData = child.parentData! as _TheaterParentData;
      final Iterator<RenderBox>? innerIterator = childParentData.paintOrderIterator;
      if (innerIterator != null) {
        while (innerIterator.moveNext()) {
          yield innerIterator.current;
        }
      }
      child = childParentData.nextSibling;
    }
  }

  @override
  // The following uses sync* because hit testing should be lazy.
  Iterable<RenderBox> _childrenInHitTestOrder() sync* {
    RenderBox? child = _lastOnstageChild;
    int childLeft = childCount - skipCount;
    while (child != null) {
      final _TheaterParentData childParentData = child.parentData! as _TheaterParentData;
      final Iterator<RenderBox>? innerIterator = childParentData.hitTestOrderIterator;
      if (innerIterator != null) {
        while (innerIterator.moveNext()) {
          yield innerIterator.current;
        }
      }
      yield child;
      childLeft -= 1;
      child = childLeft <= 0 ? null : childParentData.previousSibling;
    }
  }

  @override
  bool get sizedByParent => false;

  bool _layingOutSizeDeterminingChild = false;
  @override
  void performLayout() {
    RenderBox? sizeDeterminingChild;
    if (constraints.biggest.isFinite) {
      size = constraints.biggest;
    } else {
      sizeDeterminingChild = _findSizeDeterminingChild();
      _layingOutSizeDeterminingChild = true;
      layoutChild(sizeDeterminingChild, constraints);
      _layingOutSizeDeterminingChild = false;
      size = sizeDeterminingChild.size;
    }

    // Equivalent to BoxConstraints used by RenderStack for StackFit.expand.
    final BoxConstraints nonPositionedChildConstraints = BoxConstraints.tight(size);
    for (final RenderBox child in _childrenInPaintOrder()) {
      if (child != sizeDeterminingChild) {
        layoutChild(child, nonPositionedChildConstraints);
      }
    }
  }

  RenderBox _findSizeDeterminingChild() {
    RenderBox? child = _lastOnstageChild;
    while (child != null) {
      final _TheaterParentData childParentData = child.parentData! as _TheaterParentData;
      if ((childParentData.overlayEntry?.canSizeOverlay ?? false) &&
          !childParentData.isPositioned) {
        return child;
      }
      child = childParentData.previousSibling;
    }
    throw FlutterError.fromParts(<DiagnosticsNode>[
      ErrorSummary(
        'Overlay was given infinite constraints and cannot be sized by a suitable child.',
      ),
      ErrorDescription(
        'The constraints given to the overlay ($constraints) would result in an illegal '
        'infinite size (${constraints.biggest}). To avoid that, the Overlay tried to size '
        'itself to one of its children, but no suitable non-positioned child that belongs to an '
        'OverlayEntry with canSizeOverlay set to true could be found.',
      ),
      ErrorHint(
        'Try wrapping the Overlay in a SizedBox to give it a finite size or '
        'use an OverlayEntry with canSizeOverlay set to true.',
      ),
    ]);
  }

  final LayerHandle<ClipRectLayer> _clipRectLayer = LayerHandle<ClipRectLayer>();

  @override
  void paint(PaintingContext context, Offset offset) {
    if (clipBehavior != Clip.none) {
      _clipRectLayer.layer = context.pushClipRect(
        needsCompositing,
        offset,
        Offset.zero & size,
        super.paint,
        clipBehavior: clipBehavior,
        oldLayer: _clipRectLayer.layer,
      );
    } else {
      _clipRectLayer.layer = null;
      super.paint(context, offset);
    }
  }

  @override
  void dispose() {
    _clipRectLayer.layer = null;
    super.dispose();
  }

  @override
  void visitChildren(RenderObjectVisitor visitor) {
    RenderBox? child = firstChild;
    while (child != null) {
      visitor(child);
      final _TheaterParentData childParentData = child.parentData! as _TheaterParentData;
      childParentData.visitOverlayPortalChildrenOnOverlayEntry(visitor);
      child = childParentData.nextSibling;
    }
  }

  @override
  void visitChildrenForSemantics(RenderObjectVisitor visitor) {
    RenderBox? child = _firstOnstageChild;
    while (child != null) {
      visitor(child);
      final _TheaterParentData childParentData = child.parentData! as _TheaterParentData;
      child = childParentData.nextSibling;
    }
  }

  @override
  Rect? describeApproximatePaintClip(RenderObject child) {
    switch (clipBehavior) {
      case Clip.none:
        return null;
      case Clip.hardEdge:
      case Clip.antiAlias:
      case Clip.antiAliasWithSaveLayer:
        return Offset.zero & size;
    }
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties.add(IntProperty('skipCount', skipCount));
    properties.add(EnumProperty<TextDirection>('textDirection', textDirection));
  }

  @override
  List<DiagnosticsNode> debugDescribeChildren() {
    final List<DiagnosticsNode> offstageChildren = <DiagnosticsNode>[];
    final List<DiagnosticsNode> onstageChildren = <DiagnosticsNode>[];

    int count = 1;
    bool onstage = false;
    RenderBox? child = firstChild;
    final RenderBox? firstOnstageChild = _firstOnstageChild;
    while (child != null) {
      final _TheaterParentData childParentData = child.parentData! as _TheaterParentData;
      if (child == firstOnstageChild) {
        onstage = true;
        count = 1;
      }

      if (onstage) {
        onstageChildren.add(child.toDiagnosticsNode(name: 'onstage $count'));
      } else {
        offstageChildren.add(
          child.toDiagnosticsNode(name: 'offstage $count', style: DiagnosticsTreeStyle.offstage),
        );
      }

      int subcount = 1;
      childParentData.visitOverlayPortalChildrenOnOverlayEntry((RenderObject renderObject) {
        final RenderBox child = renderObject as RenderBox;
        if (onstage) {
          onstageChildren.add(child.toDiagnosticsNode(name: 'onstage $count - $subcount'));
        } else {
          offstageChildren.add(
            child.toDiagnosticsNode(
              name: 'offstage $count - $subcount',
              style: DiagnosticsTreeStyle.offstage,
            ),
          );
        }
        subcount += 1;
      });

      child = childParentData.nextSibling;
      count += 1;
    }

    return <DiagnosticsNode>[
      ...onstageChildren,
      if (offstageChildren.isNotEmpty)
        ...offstageChildren
      else
        DiagnosticsNode.message('no offstage children', style: DiagnosticsTreeStyle.offstage),
    ];
  }
}

// * OverlayPortal Implementation
//  OverlayPortal is inspired by the
//  [flutter_portal](https://pub.dev/packages/flutter_portal) package.
//
// ** RenderObject hierarchy
// The widget works by inserting its overlay child's render subtree directly
// under [Overlay]'s render object (_RenderTheater).
// https://user-images.githubusercontent.com/31859944/171971838-62ed3975-4b5d-4733-a9c9-f79e263b8fcc.jpg
//
// To ensure the overlay child render subtree does not do layout twice, the
// subtree must only perform layout after both its _RenderTheater and the
// [OverlayPortal]'s render object (_RenderLayoutSurrogateProxyBox) have
// finished layout. This is handled by _RenderDeferredLayoutBox.
//
// ** Z-Index of an overlay child
// [_OverlayEntryLocation] is a (currently private) interface that allows an
// [OverlayPortal] to insert its overlay child into a specific [Overlay], as
// well as specifying the paint order between the overlay child and other
// children of the _RenderTheater.
//
// Since [OverlayPortal] is only allowed to target ancestor [Overlay]s
// (_RenderTheater must finish doing layout before _RenderDeferredLayoutBox),
// the _RenderTheater should typically be acquired using an [InheritedWidget]
// (currently, _RenderTheaterMarker) in case the [OverlayPortal] gets
// reparented.

/// A class to show, hide and bring to top an [OverlayPortal]'s overlay child
/// in the target [Overlay].
///
/// A [OverlayPortalController] can only be given to at most one [OverlayPortal]
/// at a time. When an [OverlayPortalController] is moved from one
/// [OverlayPortal] to another, its [isShowing] state does not carry over.
///
/// [OverlayPortalController.show] and [OverlayPortalController.hide] can be
/// called even before the controller is assigned to any [OverlayPortal], but
/// they typically should not be called while the widget tree is being rebuilt.
class OverlayPortalController {
  /// Creates an [OverlayPortalController], optionally with a String identifier
  /// `debugLabel`.
  OverlayPortalController({String? debugLabel}) : _debugLabel = debugLabel;

  _OverlayPortalState? _attachTarget;

  // A separate _zOrderIndex to allow `show()` or `hide()` to be called when the
  // controller is not yet attached. Once this controller is attached,
  // _attachTarget._zOrderIndex will be used as the source of truth, and this
  // variable will be set to null.
  int? _zOrderIndex;
  final String? _debugLabel;

  static int _wallTime =
      kIsWeb
          ? -9007199254740992 // -2^53
          : -1 << 63;

  // Returns a unique and monotonically increasing timestamp that represents
  // now.
  //
  // The value this method returns increments after each call.
  int _now() {
    final int now = _wallTime += 1;
    assert(_zOrderIndex == null || _zOrderIndex! < now);
    assert(_attachTarget?._zOrderIndex == null || _attachTarget!._zOrderIndex! < now);
    return now;
  }

  /// Show the overlay child of the [OverlayPortal] this controller is attached
  /// to, at the top of the target [Overlay].
  ///
  /// When there are more than one [OverlayPortal]s that target the same
  /// [Overlay], the overlay child of the last [OverlayPortal] to have called
  /// [show] appears at the top level, unobstructed.
  ///
  /// If [isShowing] is already true, calling this method brings the overlay
  /// child it controls to the top.
  ///
  /// This method should typically not be called while the widget tree is being
  /// rebuilt.
  void show() {
    final _OverlayPortalState? state = _attachTarget;
    if (state != null) {
      state.show(_now());
    } else {
      _zOrderIndex = _now();
    }
  }

  /// Hide the [OverlayPortal]'s overlay child.
  ///
  /// Once hidden, the overlay child will be removed from the widget tree the
  /// next time the widget tree rebuilds, and stateful widgets in the overlay
  /// child may lose states as a result.
  ///
  /// This method should typically not be called while the widget tree is being
  /// rebuilt.
  void hide() {
    final _OverlayPortalState? state = _attachTarget;
    if (state != null) {
      state.hide();
    } else {
      assert(_zOrderIndex != null);
      _zOrderIndex = null;
    }
  }

  /// Whether the associated [OverlayPortal] should build and show its overlay
  /// child, using its `overlayChildBuilder`.
  bool get isShowing {
    final _OverlayPortalState? state = _attachTarget;
    return state != null ? state._zOrderIndex != null : _zOrderIndex != null;
  }

  /// Convenience method for toggling the current [isShowing] status.
  ///
  /// This method should typically not be called while the widget tree is being
  /// rebuilt.
  void toggle() => isShowing ? hide() : show();

  @override
  String toString() {
    final String? debugLabel = _debugLabel;
    final String label = debugLabel == null ? '' : '($debugLabel)';
    final String isDetached = _attachTarget != null ? '' : ' DETACHED';
    return '${objectRuntimeType(this, 'OverlayPortalController')}$label$isDetached';
  }
}

/// A widget that renders its overlay child on an [Overlay].
///
/// The overlay child is initially hidden until [OverlayPortalController.show]
/// is called on the associated [controller]. The [OverlayPortal] uses
/// [overlayChildBuilder] to build its overlay child and renders it on the
/// specified [Overlay] as if it was inserted using an [OverlayEntry], while it
/// can depend on the same set of [InheritedWidget]s (such as [Theme]) that this
/// widget can depend on.
///
/// This widget requires an [Overlay] ancestor in the widget tree when its
/// overlay child is showing. The overlay child is rendered by the [Overlay]
/// ancestor, not by the widget itself. This allows the overlay child to float
/// above other widgets, independent of its position in the widget tree.
///
/// When [OverlayPortalController.hide] is called, the widget built using
/// [overlayChildBuilder] will be removed from the widget tree the next time the
/// widget rebuilds. Stateful descendants in the overlay child subtree may lose
/// states as a result.
///
/// {@tool dartpad}
/// This example uses an [OverlayPortal] to build a tooltip that becomes visible
/// when the user taps on the [child] widget. There's a [DefaultTextStyle] above
/// the [OverlayPortal] controlling the [TextStyle] of both the [child] widget
/// and the widget [overlayChildBuilder] builds, which isn't otherwise doable if
/// the tooltip was added as an [OverlayEntry].
///
/// ** See code in examples/api/lib/widgets/overlay/overlay_portal.0.dart **
/// {@end-tool}
///
/// ### Paint Order
///
/// In an [Overlay], an overlay child is painted after the [OverlayEntry]
/// associated with its [OverlayPortal] (that is, the [OverlayEntry] closest to
/// the [OverlayPortal] in the widget tree, which usually represents the
/// enclosing [Route]), and before the next [OverlayEntry].
///
/// When an [OverlayEntry] has multiple associated [OverlayPortal]s, the paint
/// order between their overlay children is the order in which
/// [OverlayPortalController.show] was called. The last [OverlayPortal] to have
/// called `show` gets to paint its overlay child in the foreground.
///
/// ### Semantics
///
/// The semantics subtree generated by the overlay child is considered attached
/// to [OverlayPortal] instead of the target [Overlay]. An [OverlayPortal]'s
/// semantics subtree can be dropped from the semantics tree due to invisibility
/// while the overlay child is still visible (for example, when the
/// [OverlayPortal] is completely invisible in a [ListView] but kept alive by
/// a [KeepAlive] widget). When this happens the semantics subtree generated by
/// the overlay child is also dropped, even if the overlay child is still visible
/// on screen.
///
/// {@template flutter.widgets.overlayPortalVsOverlayEntry}
/// ### Differences between [OverlayPortal] and [OverlayEntry]
///
/// The main difference between [OverlayEntry] and [OverlayPortal] is that
/// [OverlayEntry] builds its widget subtree as a child of the target [Overlay],
/// while [OverlayPortal] uses [OverlayPortal.overlayChildBuilder] to build a
/// child widget of itself. This allows [OverlayPortal]'s overlay child to depend
/// on the same set of [InheritedWidget]s as [OverlayPortal], and it's also
/// guaranteed that the overlay child will not outlive its [OverlayPortal].
///
/// On the other hand, [OverlayPortal]'s implementation is more complex. For
/// instance, it does a bit more work than a regular widget during global key
/// reparenting. If the content to be shown on the [Overlay] doesn't benefit
/// from being a part of [OverlayPortal]'s subtree, consider using an
/// [OverlayEntry] instead.
/// {@endtemplate}
///
/// See also:
///
///  * [OverlayEntry], an alternative API for inserting widgets into an
///    [Overlay].
///  * [Positioned], which can be used to size and position the overlay child in
///    relation to the target [Overlay]'s boundaries.
///  * [CompositedTransformFollower], which can be used to position the overlay
///    child in relation to the linked [CompositedTransformTarget] widget.
class OverlayPortal extends StatefulWidget {
  /// Creates an [OverlayPortal] that renders the widget [overlayChildBuilder]
  /// builds on the closest [Overlay] when [OverlayPortalController.show] is
  /// called.
  const OverlayPortal({
    super.key,
    required this.controller,
    required this.overlayChildBuilder,
    this.child,
  }) : _targetRootOverlay = false;

  /// Creates an [OverlayPortal] that renders the widget [overlayChildBuilder]
  /// builds on the root [Overlay] when [OverlayPortalController.show] is
  /// called.
  const OverlayPortal.targetsRootOverlay({
    super.key,
    required this.controller,
    required this.overlayChildBuilder,
    this.child,
  }) : _targetRootOverlay = true;

  /// The controller to show, hide and bring to top the overlay child.
  final OverlayPortalController controller;

  /// A [WidgetBuilder] used to build a widget below this widget in the tree,
  /// that renders on the closest [Overlay].
  ///
  /// The said widget will only be built and shown in the closest [Overlay] once
  /// [OverlayPortalController.show] is called on the associated [controller].
  /// It will be painted in front of the [OverlayEntry] closest to this widget
  /// in the widget tree (which is usually the enclosing [Route]).
  ///
  /// The built overlay child widget is inserted below this widget in the widget
  /// tree, allowing it to depend on [InheritedWidget]s above it, and be
  /// notified when the [InheritedWidget]s change.
  ///
  /// Unlike [child], the built overlay child can visually extend outside the
  /// bounds of this widget without being clipped, and receive hit-test events
  /// outside of this widget's bounds, as long as it does not extend outside of
  /// the [Overlay] on which it is rendered.
  final WidgetBuilder overlayChildBuilder;

  /// A widget below this widget in the tree.
  final Widget? child;

  final bool _targetRootOverlay;

  @override
  State<OverlayPortal> createState() => _OverlayPortalState();
}

class _OverlayPortalState extends State<OverlayPortal> {
  int? _zOrderIndex;
  // The location of the overlay child within the overlay. This object will be
  // used as the slot of the overlay child widget.
  //
  // The developer must call `show` to reveal the overlay so we can get a unique
  // timestamp of the user interaction for determining the z-index of the
  // overlay child in the overlay.
  //
  // Avoid invalidating the cache if possible, since the framework uses `==` to
  // compare slots, and _OverlayEntryLocation can't override that operator since
  // it's mutable. Changing slots can be relatively slow.
  bool _childModelMayHaveChanged = true;
  _OverlayEntryLocation? _locationCache;
  static bool _isTheSameLocation(_OverlayEntryLocation locationCache, _RenderTheaterMarker marker) {
    return locationCache._childModel == marker.overlayEntryWidgetState &&
        locationCache._theater == marker.theater;
  }

  _OverlayEntryLocation _getLocation(int zOrderIndex, bool targetRootOverlay) {
    final _OverlayEntryLocation? cachedLocation = _locationCache;
    late final _RenderTheaterMarker marker = _RenderTheaterMarker.of(
      context,
      targetRootOverlay: targetRootOverlay,
    );
    final bool isCacheValid =
        cachedLocation != null &&
        (!_childModelMayHaveChanged || _isTheSameLocation(cachedLocation, marker));
    _childModelMayHaveChanged = false;
    if (isCacheValid) {
      assert(cachedLocation._zOrderIndex == zOrderIndex);
      assert(cachedLocation._debugIsLocationValid());
      return cachedLocation;
    }
    // Otherwise invalidate the cache and create a new location.
    cachedLocation?._debugMarkLocationInvalid();
    final _OverlayEntryLocation newLocation = _OverlayEntryLocation(
      zOrderIndex,
      marker.overlayEntryWidgetState,
      marker.theater,
    );
    assert(newLocation._zOrderIndex == zOrderIndex);
    return _locationCache = newLocation;
  }

  @override
  void initState() {
    super.initState();
    _setupController(widget.controller);
  }

  void _setupController(OverlayPortalController controller) {
    assert(
      controller._attachTarget == null || controller._attachTarget == this,
      'Failed to attach $controller to $this. It is already attached to ${controller._attachTarget}.',
    );
    final int? controllerZOrderIndex = controller._zOrderIndex;
    final int? zOrderIndex = _zOrderIndex;
    if (zOrderIndex == null ||
        (controllerZOrderIndex != null && controllerZOrderIndex > zOrderIndex)) {
      _zOrderIndex = controllerZOrderIndex;
    }
    controller._zOrderIndex = null;
    controller._attachTarget = this;
  }

  @override
  void didChangeDependencies() {
    super.didChangeDependencies();
    _childModelMayHaveChanged = true;
  }

  @override
  void didUpdateWidget(OverlayPortal oldWidget) {
    super.didUpdateWidget(oldWidget);
    _childModelMayHaveChanged =
        _childModelMayHaveChanged || oldWidget._targetRootOverlay != widget._targetRootOverlay;
    if (oldWidget.controller != widget.controller) {
      oldWidget.controller._attachTarget = null;
      _setupController(widget.controller);
    }
  }

  @override
  void dispose() {
    assert(widget.controller._attachTarget == this);
    widget.controller._attachTarget = null;
    _locationCache?._debugMarkLocationInvalid();
    _locationCache = null;
    super.dispose();
  }

  void show(int zOrderIndex) {
    assert(
      SchedulerBinding.instance.schedulerPhase != SchedulerPhase.persistentCallbacks,
      '${widget.controller.runtimeType}.show() should not be called during build.',
    );
    setState(() {
      _zOrderIndex = zOrderIndex;
    });
    _locationCache?._debugMarkLocationInvalid();
    _locationCache = null;
  }

  void hide() {
    assert(SchedulerBinding.instance.schedulerPhase != SchedulerPhase.persistentCallbacks);
    setState(() {
      _zOrderIndex = null;
    });
    _locationCache?._debugMarkLocationInvalid();
    _locationCache = null;
  }

  @override
  Widget build(BuildContext context) {
    final int? zOrderIndex = _zOrderIndex;
    if (zOrderIndex == null) {
      return _OverlayPortal(overlayLocation: null, overlayChild: null, child: widget.child);
    }
    return _OverlayPortal(
      overlayLocation: _getLocation(zOrderIndex, widget._targetRootOverlay),
      overlayChild: _DeferredLayout(child: Builder(builder: widget.overlayChildBuilder)),
      child: widget.child,
    );
  }
}

/// A location in an [Overlay].
///
/// An [_OverlayEntryLocation] determines the [Overlay] the associated
/// [OverlayPortal] should put its overlay child onto, as well as the overlay
/// child's paint order in relation to other contents painted on the [Overlay].
//
// An _OverlayEntryLocation is a cursor pointing to a location in a particular
// Overlay's child model, and provides methods to insert/remove/move a
// _RenderDeferredLayoutBox to/from its target _theater.
//
// The occupant (a `RenderBox`) will be painted above the associated
// [OverlayEntry], but below the [OverlayEntry] above that [OverlayEntry].
//
// Additionally, `_activate` and `_deactivate` are called when the overlay
// child's `_OverlayPortalElement` activates/deactivates (for instance, during
// global key reparenting).
// `_OverlayPortalElement` removes its overlay child's render object from the
// target `_RenderTheater` when it deactivates and puts it back on `activated`.
// These 2 methods can be used to "hide" a child in the child model without
// removing it, when the child is expensive/difficult to re-insert at the
// correct location on `activated`.
//
// ### Equality
//
// An `_OverlayEntryLocation` will be used as an Element's slot. These 3 parts
// uniquely identify a place in an overlay's child model:
// - _theater
// - _childModel (the OverlayEntry)
// - _zOrderIndex
//
// Since it can't implement operator== (it's mutable), the same `_OverlayEntryLocation`
// instance must not be used to represent more than one locations.
final class _OverlayEntryLocation extends LinkedListEntry<_OverlayEntryLocation> {
  _OverlayEntryLocation(this._zOrderIndex, this._childModel, this._theater);

  final int _zOrderIndex;
  final _OverlayEntryWidgetState _childModel;
  final _RenderTheater _theater;

  _RenderDeferredLayoutBox? _overlayChildRenderBox;
  void _addToChildModel(_RenderDeferredLayoutBox child) {
    assert(
      _overlayChildRenderBox == null,
      'Failed to add $child. This location ($this) is already occupied by $_overlayChildRenderBox.',
    );
    _overlayChildRenderBox = child;
    _childModel._add(this);
    _theater.markNeedsPaint();
    _theater.markNeedsCompositingBitsUpdate();
    _theater.markNeedsSemanticsUpdate();
  }

  void _removeFromChildModel(_RenderDeferredLayoutBox child) {
    assert(child == _overlayChildRenderBox);
    _overlayChildRenderBox = null;
    assert(_childModel._sortedTheaterSiblings?.contains(this) ?? false);
    _childModel._remove(this);
    _theater.markNeedsPaint();
    _theater.markNeedsCompositingBitsUpdate();
    _theater.markNeedsSemanticsUpdate();
  }

  void _addChild(_RenderDeferredLayoutBox child) {
    assert(_debugIsLocationValid());
    _addToChildModel(child);
    _theater._addDeferredChild(child);
    assert(child.parent == _theater);
  }

  void _removeChild(_RenderDeferredLayoutBox child) {
    // This call is allowed even when this location is disposed.
    _removeFromChildModel(child);
    _theater._removeDeferredChild(child);
    assert(child.parent == null);
  }

  void _moveChild(_RenderDeferredLayoutBox child, _OverlayEntryLocation fromLocation) {
    assert(fromLocation != this);
    assert(_debugIsLocationValid());
    final _RenderTheater fromTheater = fromLocation._theater;
    final _OverlayEntryWidgetState fromModel = fromLocation._childModel;

    if (fromTheater != _theater) {
      fromTheater._removeDeferredChild(child);
      _theater._addDeferredChild(child);
    }

    if (fromModel != _childModel || fromLocation._zOrderIndex != _zOrderIndex) {
      fromLocation._removeFromChildModel(child);
      _addToChildModel(child);
    }
  }

  void _activate(_RenderDeferredLayoutBox child) {
    // This call is allowed even when this location is invalidated.
    // See _OverlayPortalElement.activate.
    assert(_overlayChildRenderBox == null, '$_overlayChildRenderBox');
    _theater._addDeferredChild(child);
    _overlayChildRenderBox = child;
  }

  void _deactivate(_RenderDeferredLayoutBox child) {
    // This call is allowed even when this location is invalidated.
    _theater._removeDeferredChild(child);
    _overlayChildRenderBox = null;
  }

  // Throws a StateError if this location is already invalidated and shouldn't
  // be used as an OverlayPortal slot. Must be used in asserts.
  //
  // Generally, `assert(_debugIsLocationValid())` should be used to prevent
  // invalid accesses to an invalid `_OverlayEntryLocation` object. Exceptions
  // to this rule are _removeChild, _deactivate, which will be called when the
  // OverlayPortal is being removed from the widget tree and may use the
  // location information to perform cleanup tasks.
  //
  // Another exception is the _activate method which is called by
  // _OverlayPortalElement.activate. See the comment in _OverlayPortalElement.activate.
  bool _debugIsLocationValid() {
    if (_debugMarkLocationInvalidStackTrace == null) {
      return true;
    }
    throw StateError(
      '$this is already disposed. Stack trace: $_debugMarkLocationInvalidStackTrace',
    );
  }

  // The StackTrace of the first _debugMarkLocationInvalid call. It's only for
  // debugging purposes and the StackTrace will only be captured in debug builds.
  //
  // The effect of this method is not reversible. Once marked invalid, this
  // object can't be marked as valid again.
  StackTrace? _debugMarkLocationInvalidStackTrace;
  @mustCallSuper
  void _debugMarkLocationInvalid() {
    assert(_debugIsLocationValid());
    assert(() {
      _debugMarkLocationInvalidStackTrace = StackTrace.current;
      return true;
    }());
  }

  @override
  String toString() =>
      '${objectRuntimeType(this, '_OverlayEntryLocation')}[${shortHash(this)}] ${_debugMarkLocationInvalidStackTrace != null ? "(INVALID)" : ""}';
}

class _RenderTheaterMarker extends InheritedWidget {
  const _RenderTheaterMarker({
    required this.theater,
    required this.overlayEntryWidgetState,
    required super.child,
  });

  final _RenderTheater theater;
  final _OverlayEntryWidgetState overlayEntryWidgetState;

  @override
  bool updateShouldNotify(_RenderTheaterMarker oldWidget) {
    return oldWidget.theater != theater ||
        oldWidget.overlayEntryWidgetState != overlayEntryWidgetState;
  }

  static _RenderTheaterMarker of(BuildContext context, {bool targetRootOverlay = false}) {
    final _RenderTheaterMarker? marker;
    if (targetRootOverlay) {
      final InheritedElement? ancestor = _rootRenderTheaterMarkerOf(
        context.getElementForInheritedWidgetOfExactType<_RenderTheaterMarker>(),
      );
      assert(ancestor == null || ancestor.widget is _RenderTheaterMarker);
      marker =
          ancestor != null
              ? context.dependOnInheritedElement(ancestor) as _RenderTheaterMarker?
              : null;
    } else {
      marker = context.dependOnInheritedWidgetOfExactType<_RenderTheaterMarker>();
    }
    if (marker != null) {
      return marker;
    }
    throw FlutterError.fromParts(<DiagnosticsNode>[
      ErrorSummary('No Overlay widget found.'),
      ErrorDescription(
        '${context.widget.runtimeType} widgets require an Overlay widget ancestor.\n'
        'An overlay lets widgets float on top of other widget children.',
      ),
      ErrorHint(
        'To introduce an Overlay widget, you can either directly '
        'include one, or use a widget that contains an Overlay itself, '
        'such as a Navigator, WidgetApp, MaterialApp, or CupertinoApp.',
      ),
      ...context.describeMissingAncestor(expectedAncestorType: Overlay),
    ]);
  }

  static InheritedElement? _rootRenderTheaterMarkerOf(InheritedElement? theaterMarkerElement) {
    assert(theaterMarkerElement == null || theaterMarkerElement.widget is _RenderTheaterMarker);
    if (theaterMarkerElement == null) {
      return null;
    }
    InheritedElement? ancestor;
    theaterMarkerElement.visitAncestorElements((Element element) {
      ancestor = element.getElementForInheritedWidgetOfExactType<_RenderTheaterMarker>();
      return false;
    });
    return ancestor == null ? theaterMarkerElement : _rootRenderTheaterMarkerOf(ancestor);
  }
}

class _OverlayPortal extends RenderObjectWidget {
  /// Creates a widget that renders the given [overlayChild] in the [Overlay]
  /// specified by `overlayLocation`.
  ///
  /// The `overlayLocation` parameter must not be null when [overlayChild] is not
  /// null.
  _OverlayPortal({required this.overlayLocation, required this.overlayChild, required this.child})
    : assert(overlayChild == null || overlayLocation != null),
      assert(overlayLocation == null || overlayLocation._debugIsLocationValid());

  final Widget? overlayChild;

  /// A widget below this widget in the tree.
  final Widget? child;

  final _OverlayEntryLocation? overlayLocation;

  @override
  RenderObjectElement createElement() => _OverlayPortalElement(this);

  @override
  RenderObject createRenderObject(BuildContext context) => _RenderLayoutSurrogateProxyBox();
}

class _OverlayPortalElement extends RenderObjectElement {
  _OverlayPortalElement(_OverlayPortal super.widget);

  @override
  _RenderLayoutSurrogateProxyBox get renderObject =>
      super.renderObject as _RenderLayoutSurrogateProxyBox;

  Element? _overlayChild;
  Element? _child;

  @override
  void mount(Element? parent, Object? newSlot) {
    super.mount(parent, newSlot);
    final _OverlayPortal widget = this.widget as _OverlayPortal;
    _child = updateChild(_child, widget.child, null);
    _overlayChild = updateChild(_overlayChild, widget.overlayChild, widget.overlayLocation);
  }

  @override
  void update(_OverlayPortal newWidget) {
    super.update(newWidget);
    _child = updateChild(_child, newWidget.child, null);
    _overlayChild = updateChild(_overlayChild, newWidget.overlayChild, newWidget.overlayLocation);
  }

  @override
  void forgetChild(Element child) {
    // The _overlayChild Element does not have a key because the _DeferredLayout
    // widget does not take a Key, so only the regular _child can be taken
    // during global key reparenting.
    assert(child == _child);
    _child = null;
    super.forgetChild(child);
  }

  @override
  void visitChildren(ElementVisitor visitor) {
    final Element? child = _child;
    final Element? overlayChild = _overlayChild;
    if (child != null) {
      visitor(child);
    }
    if (overlayChild != null) {
      visitor(overlayChild);
    }
  }

  @override
  void activate() {
    super.activate();
    final _RenderDeferredLayoutBox? box = _overlayChild?.renderObject as _RenderDeferredLayoutBox?;
    if (box != null) {
      assert(!box.attached);
      assert(renderObject._deferredLayoutChild == box);
      // updateChild has not been called at this point so the RenderTheater in
      // the overlay location could be detached. Adding children to a detached
      // RenderObject is still allowed however this isn't the most efficient.
      (_overlayChild!.slot! as _OverlayEntryLocation)._activate(box);
    }
  }

  @override
  void deactivate() {
    // Instead of just detaching the render objects, removing them from the
    // render subtree entirely. This is a workaround for the
    // !renderObject.attached assert in the `super.deactivate()` method.
    final _RenderDeferredLayoutBox? box = _overlayChild?.renderObject as _RenderDeferredLayoutBox?;
    if (box != null) {
      (_overlayChild!.slot! as _OverlayEntryLocation)._deactivate(box);
    }
    super.deactivate();
  }

  @override
  void insertRenderObjectChild(RenderBox child, _OverlayEntryLocation? slot) {
    assert(child.parent == null, "$child's parent is not null: ${child.parent}");
    if (slot != null) {
      renderObject._deferredLayoutChild = child as _RenderDeferredLayoutBox;
      slot._addChild(child);
      renderObject.markNeedsSemanticsUpdate();
    } else {
      renderObject.child = child;
    }
  }

  // The [_DeferredLayout] widget does not have a key so there will be no
  // reparenting between _overlayChild and _child, thus the non-null-typed slots.
  @override
  void moveRenderObjectChild(
    _RenderDeferredLayoutBox child,
    _OverlayEntryLocation oldSlot,
    _OverlayEntryLocation newSlot,
  ) {
    assert(newSlot._debugIsLocationValid());
    newSlot._moveChild(child, oldSlot);
    renderObject.markNeedsSemanticsUpdate();
  }

  @override
  void removeRenderObjectChild(RenderBox child, _OverlayEntryLocation? slot) {
    if (slot == null) {
      renderObject.child = null;
      return;
    }
    assert(renderObject._deferredLayoutChild == child);
    slot._removeChild(child as _RenderDeferredLayoutBox);
    renderObject._deferredLayoutChild = null;
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties.add(DiagnosticsProperty<Element>('child', _child, defaultValue: null));
    properties.add(DiagnosticsProperty<Element>('overlayChild', _overlayChild, defaultValue: null));
    properties.add(
      DiagnosticsProperty<Object>('overlayLocation', _overlayChild?.slot, defaultValue: null),
    );
  }
}

class _DeferredLayout extends SingleChildRenderObjectWidget {
  const _DeferredLayout({
    // This widget must not be given a key: we currently do not support
    // reparenting between the overlayChild and child.
    required Widget child,
  }) : super(child: child);

  _RenderLayoutSurrogateProxyBox getLayoutParent(BuildContext context) {
    return context.findAncestorRenderObjectOfType<_RenderLayoutSurrogateProxyBox>()!;
  }

  @override
  _RenderDeferredLayoutBox createRenderObject(BuildContext context) {
    final _RenderLayoutSurrogateProxyBox parent = getLayoutParent(context);
    final _RenderDeferredLayoutBox renderObject = _RenderDeferredLayoutBox(parent);
    parent._deferredLayoutChild = renderObject;
    return renderObject;
  }

  @override
  void updateRenderObject(BuildContext context, _RenderDeferredLayoutBox renderObject) {
    assert(renderObject._layoutSurrogate == getLayoutParent(context));
    assert(getLayoutParent(context)._deferredLayoutChild == renderObject);
  }
}

// A `RenderProxyBox` that defers its layout until its `_layoutSurrogate` (which
// is not necessarily an ancestor of this RenderBox, but shares at least one
// `_RenderTheater` ancestor with this RenderBox) is laid out.
//
// This `RenderObject` must be a child of a `_RenderTheater`. It guarantees that:
//
// 1. It's a relayout boundary, so calling `markNeedsLayout` on it never dirties
//    its `_RenderTheater`.
//
// 2. Its `layout` implementation is overridden such that `performLayout` does
//    not do anything when its called from `layout`, preventing the parent
//    `_RenderTheater` from laying out this subtree prematurely (but this
//    `RenderObject` may still be resized). Instead, `markNeedsLayout` will be
//    called from within `layout` to schedule a layout update for this relayout
//    boundary when needed.
//
// 3. When invoked from `PipelineOwner.flushLayout`, or
//    `_layoutSurrogate.performLayout`, this `RenderObject` behaves like an
//    `Overlay` that has only one entry.
final class _RenderDeferredLayoutBox extends RenderProxyBox
    with _RenderTheaterMixin, LinkedListEntry<_RenderDeferredLayoutBox> {
  _RenderDeferredLayoutBox(this._layoutSurrogate);

  StackParentData get stackParentData => parentData! as StackParentData;
  final _RenderLayoutSurrogateProxyBox _layoutSurrogate;

  @override
  Iterable<RenderBox> _childrenInPaintOrder() {
    final RenderBox? child = this.child;
    return child == null
        ? const Iterable<RenderBox>.empty()
        : Iterable<RenderBox>.generate(1, (int i) => child);
  }

  @override
  Iterable<RenderBox> _childrenInHitTestOrder() => _childrenInPaintOrder();

  @override
  _RenderTheater get theater {
    final RenderObject? parent = this.parent;
    return parent is _RenderTheater
        ? parent
        : throw FlutterError('$parent of $this is not a _RenderTheater');
  }

  @override
  void redepthChildren() {
    _layoutSurrogate.redepthChild(this);
    super.redepthChildren();
  }

  @override
  bool get sizedByParent => true;

  bool _needsLayout = true;
  @override
  void markNeedsLayout() {
    _needsLayout = true;
    super.markNeedsLayout();
  }

  @override
  RenderObject? get semanticsParent => _layoutSurrogate;

  @override
  double? computeDryBaseline(BoxConstraints constraints, TextBaseline baseline) {
    final RenderBox? child = this.child;
    if (child == null) {
      return null;
    }
    return _RenderTheaterMixin.baselineForChild(
      child,
      constraints.biggest,
      constraints,
      theater._resolvedAlignment,
      baseline,
    );
  }

  @override
  RenderObject? get debugLayoutParent => _layoutSurrogate;

  void layoutByLayoutSurrogate() {
    assert(!_theaterDoingThisLayout);
    final _RenderTheater? theater = parent as _RenderTheater?;
    if (theater == null || !attached) {
      assert(false, '$this is not attached to parent');
      return;
    }
    if (theater._layingOutSizeDeterminingChild) {
      theater.invokeLayoutCallback((BoxConstraints constraints) {
        markNeedsLayout();
      });
    } else {
      final BoxConstraints theaterConstraints = theater.constraints;
      final Size boxSize =
          theaterConstraints.biggest.isFinite
              ? theaterConstraints.biggest
              // Accessing the theater's size is only unsafe if it is laying out the
              // size-determining child.
              : theater.size;
      super.layout(BoxConstraints.tight(boxSize));
    }
  }

  bool _theaterDoingThisLayout = false;
  @override
  void layout(Constraints constraints, {bool parentUsesSize = false}) {
    assert(_needsLayout == debugNeedsLayout);
    // Only _RenderTheater calls this implementation.
    assert(parent != null);
    final bool scheduleDeferredLayout = _needsLayout || this.constraints != constraints;
    assert(!_theaterDoingThisLayout);
    _theaterDoingThisLayout = true;
    super.layout(constraints, parentUsesSize: parentUsesSize);
    assert(_theaterDoingThisLayout);
    _theaterDoingThisLayout = false;
    _needsLayout = false;
    assert(!debugNeedsLayout);
    if (scheduleDeferredLayout) {
      final _RenderTheater parent = this.parent! as _RenderTheater;
      // Invoking markNeedsLayout as a layout callback allows this node to be
      // merged back to the `PipelineOwner`'s dirty list in the right order, if
      // it's not already dirty. Otherwise this may cause some dirty descendants
      // to performLayout a second time.
      parent.invokeLayoutCallback((BoxConstraints constraints) {
        markNeedsLayout();
      });
    }
  }

  @override
  void performResize() {
    size = constraints.biggest;
  }

  bool _debugMutationsLocked = false;
  @override
  void performLayout() {
    assert(!_debugMutationsLocked);
    if (_theaterDoingThisLayout) {
      _needsLayout = false;
      return;
    }
    assert(() {
      _debugMutationsLocked = true;
      return true;
    }());
    // This method is directly being invoked from `PipelineOwner.flushLayout`,
    // or from `_layoutSurrogate`'s performLayout.
    assert(parent != null);
    final RenderBox? child = this.child;
    if (child == null) {
      _needsLayout = false;
      return;
    }
    assert(constraints.isTight);
    layoutChild(child, constraints);
    assert(() {
      _debugMutationsLocked = false;
      return true;
    }());
    _needsLayout = false;
  }

  @override
  void applyPaintTransform(RenderBox child, Matrix4 transform) {
    final BoxParentData childParentData = child.parentData! as BoxParentData;
    final Offset offset = childParentData.offset;
    transform.translate(offset.dx, offset.dy);
  }
}

// A RenderProxyBox that makes sure its `deferredLayoutChild` has a greater
// depth than itself.
class _RenderLayoutSurrogateProxyBox extends RenderProxyBox {
  _RenderDeferredLayoutBox? _deferredLayoutChild;

  @override
  void redepthChildren() {
    super.redepthChildren();
    final _RenderDeferredLayoutBox? child = _deferredLayoutChild;
    // If child is not attached, this method will be invoked by child's real
    // parent when it's attached.
    if (child != null && child.attached) {
      assert(child.attached);
      redepthChild(child);
    }
  }

  @override
  void performLayout() {
    super.performLayout();
    // Try to layout `_deferredLayoutChild` here now that its configuration
    // and constraints are up-to-date. Additionally, during the very first
    // layout, this makes sure that _deferredLayoutChild is reachable via tree
    // walk.
    _deferredLayoutChild?.layoutByLayoutSurrogate();
  }

  @override
  void visitChildrenForSemantics(RenderObjectVisitor visitor) {
    super.visitChildrenForSemantics(visitor);
    final _RenderDeferredLayoutBox? deferredChild = _deferredLayoutChild;
    if (deferredChild != null) {
      visitor(deferredChild);
    }
  }
}


Please provide:
1. A high-level `summary` of the project's main purpose and functionality in a few beginner-friendly sentences. Use markdown formatting with **bold** and *italic* text to highlight important concepts.
2. A list (`relationships`) describing the key interactions between these abstractions. For each relationship, specify:
    - `from_abstraction`: Index of the source abstraction (e.g., `0 # AbstractionName1`)
    - `to_abstraction`: Index of the target abstraction (e.g., `1 # AbstractionName2`)
    - `label`: A brief label for the interaction **in just a few words** (e.g., "Manages", "Inherits", "Uses").
    Ideally the relationship should be backed by one abstraction calling or passing parameters to another.
    Simplify the relationship and exclude those non-important ones.

IMPORTANT: Make sure EVERY abstraction is involved in at least ONE relationship (either as source or target). Each abstraction index must appear at least once across all relationships.

Format the output as YAML:

```yaml
summary: |
  A brief, simple explanation of the project.
  Can span multiple lines with **bold** and *italic* for emphasis.
relationships:
  - from_abstraction: 0 # AbstractionName1
    to_abstraction: 1 # AbstractionName2
    label: "Manages"
  - from_abstraction: 2 # AbstractionName3
    to_abstraction: 0 # AbstractionName1
    label: "Provides config"
  # ... other relationships
```

Now, provide the YAML output:

2025-05-22 23:56:40,776 - INFO - RESPONSE: ```yaml
summary: |
  This Flutter project provides an **Overlay** system, allowing widgets to *float* above the standard UI content.
  **OverlayEntry** and **OverlayPortal** are used to add these floating widgets, which are managed by the **OverlayState** and rendered by the internal **_Theater**.
relationships:
  - from_abstraction: 0 # Overlay
    to_abstraction: 2 # OverlayState
    label: "Manages state"
  - from_abstraction: 2 # OverlayState
    to_abstraction: 1 # OverlayEntry
    label: "Inserts/Removes"
  - from_abstraction: 2 # OverlayState
    to_abstraction: 5 # _Theater
    label: "Builds render object"
  - from_abstraction: 1 # OverlayEntry
    to_abstraction: 0 # Overlay
    label: "Can be inserted into"
  - from_abstraction: 1 # OverlayEntry
    to_abstraction: 2 # OverlayState
    label: "Removes itself from"
  - from_abstraction: 3 # OverlayPortal
    to_abstraction: 4 # OverlayPortalController
    label: "Uses"
  - from_abstraction: 3 # OverlayPortal
    to_abstraction: 6 # _OverlayEntryLocation
    label: "Creates location"
  - from_abstraction: 4 # OverlayPortalController
    to_abstraction: 3 # OverlayPortal
    label: "Controls"
  - from_abstraction: 6 # _OverlayEntryLocation
    to_abstraction: 5 # _Theater
    label: "References theater"
  - from_abstraction: 6 # _OverlayEntryLocation
    to_abstraction: 7 # _RenderDeferredLayoutBox
    label: "Adds/Removes child"
  - from_abstraction: 7 # _RenderDeferredLayoutBox
    to_abstraction: 5 # _Theater
    label: "Is child of"
```
2025-05-22 23:56:40,783 - INFO - PROMPT: 
Given the following project abstractions and their relationships for the project ```` flutter (overlay.dart) ````:

Abstractions (Index # Name):
- 0 # Overlay

- 1 # OverlayEntry

- 2 # OverlayState

- 3 # OverlayPortal

- 4 # OverlayPortalController

- 5 # _Theater

- 6 # _OverlayEntryLocation

- 7 # _RenderDeferredLayoutBox


Context about relationships and project summary:
Project Summary:
This Flutter project provides an **Overlay** system, allowing widgets to *float* above the standard UI content.
**OverlayEntry** and **OverlayPortal** are used to add these floating widgets, which are managed by the **OverlayState** and rendered by the internal **_Theater**.


Relationships (Indices refer to abstractions above):
- From 0 (Overlay
) to 2 (OverlayState
): Manages state
- From 2 (OverlayState
) to 1 (OverlayEntry
): Inserts/Removes
- From 2 (OverlayState
) to 5 (_Theater
): Builds render object
- From 1 (OverlayEntry
) to 0 (Overlay
): Can be inserted into
- From 1 (OverlayEntry
) to 2 (OverlayState
): Removes itself from
- From 3 (OverlayPortal
) to 4 (OverlayPortalController
): Uses
- From 3 (OverlayPortal
) to 6 (_OverlayEntryLocation
): Creates location
- From 4 (OverlayPortalController
) to 3 (OverlayPortal
): Controls
- From 6 (_OverlayEntryLocation
) to 5 (_Theater
): References theater
- From 6 (_OverlayEntryLocation
) to 7 (_RenderDeferredLayoutBox
): Adds/Removes child
- From 7 (_RenderDeferredLayoutBox
) to 5 (_Theater
): Is child of


If you are going to make a tutorial for ```` flutter (overlay.dart) ````, what is the best order to explain these abstractions, from first to last?
Ideally, first explain those that are the most important or foundational, perhaps user-facing concepts or entry points. Then move to more detailed, lower-level implementation details or supporting concepts.

Output the ordered list of abstraction indices, including the name in a comment for clarity. Use the format `idx # AbstractionName`.

```yaml
- 2 # FoundationalConcept
- 0 # CoreClassA
- 1 # CoreClassB (uses CoreClassA)
- ...
```

Now, provide the YAML output:

2025-05-22 23:56:42,384 - INFO - RESPONSE: ```yaml
- 0 # Overlay
- 2 # OverlayState
- 1 # OverlayEntry
- 3 # OverlayPortal
- 4 # OverlayPortalController
- 5 # _Theater
- 7 # _RenderDeferredLayoutBox
- 6 # _OverlayEntryLocation
```
2025-05-22 23:56:42,391 - INFO - PROMPT: 
Write a very beginner-friendly tutorial chapter (in Markdown format) for the project `flutter (overlay.dart)` about the concept: "Overlay
". This is Chapter 1.

Concept Details:
- Name: Overlay

- Description:
Think of an Overlay as a stack of transparent sheets (or "entries") placed on top of your regular UI content. Widgets in the Overlay float above everything else, like popups, dialogs, or tooltips. The Overlay helps manage which sheet is on top and visible.


Complete Tutorial Structure:
1. [Overlay
](01_overlay_.md)
2. [OverlayState
](02_overlaystate_.md)
3. [OverlayEntry
](03_overlayentry_.md)
4. [OverlayPortal
](04_overlayportal_.md)
5. [OverlayPortalController
](05_overlayportalcontroller_.md)
6. [_Theater
](06__theater_.md)
7. [_RenderDeferredLayoutBox
](07__renderdeferredlayoutbox_.md)
8. [_OverlayEntryLocation
](08__overlayentrylocation_.md)

Context from previous chapters:
This is the first chapter.

Relevant Code Snippets (Code itself remains unchanged):
--- File: packages/flutter/lib/src/widgets/overlay.dart ---
// Copyright 2014 The Flutter Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

/// @docImport 'package:flutter/cupertino.dart';
/// @docImport 'package:flutter/material.dart';
///
/// @docImport 'app.dart';
/// @docImport 'drag_target.dart';
/// @docImport 'implicit_animations.dart';
/// @docImport 'media_query.dart';
/// @docImport 'navigator.dart';
/// @docImport 'routes.dart';
/// @docImport 'scroll_view.dart';
/// @docImport 'sliver.dart';
/// @docImport 'text.dart';
library;

import 'dart:collection';

import 'package:flutter/foundation.dart';
import 'package:flutter/rendering.dart';
import 'package:flutter/scheduler.dart';

import 'basic.dart';
import 'framework.dart';
import 'lookup_boundary.dart';
import 'ticker_provider.dart';

const String _flutterWidgetsLibrary = 'package:flutter/widgets.dart';

// Examples can assume:
// late BuildContext context;

// * OverlayEntry Implementation

/// A place in an [Overlay] that can contain a widget.
///
/// Overlay entries are inserted into an [Overlay] using the
/// [OverlayState.insert] or [OverlayState.insertAll] functions. To find the
/// closest enclosing overlay for a given [BuildContext], use the [Overlay.of]
/// function.
///
/// An overlay entry can be in at most one overlay at a time. To remove an entry
/// from its overlay, call the [remove] function on the overlay entry.
///
/// Because an [Overlay] uses a [Stack] layout, overlay entries can use
/// [Positioned] and [AnimatedPositioned] to position themselves within the
/// overlay.
///
/// For example, [Draggable] uses an [OverlayEntry] to show the drag avatar that
/// follows the user's finger across the screen after the drag begins. Using the
/// overlay to display the drag avatar lets the avatar float over the other
/// widgets in the app. As the user's finger moves, draggable calls
/// [markNeedsBuild] on the overlay entry to cause it to rebuild. In its build,
/// the entry includes a [Positioned] with its top and left property set to
/// position the drag avatar near the user's finger. When the drag is over,
/// [Draggable] removes the entry from the overlay to remove the drag avatar
/// from view.
///
/// By default, if there is an entirely [opaque] entry over this one, then this
/// one will not be included in the widget tree (in particular, stateful widgets
/// within the overlay entry will not be instantiated). To ensure that your
/// overlay entry is still built even if it is not visible, set [maintainState]
/// to true. This is more expensive, so should be done with care. In particular,
/// if widgets in an overlay entry with [maintainState] set to true repeatedly
/// call [State.setState], the user's battery will be drained unnecessarily.
///
/// [OverlayEntry] is a [Listenable] that notifies when the widget built by
/// [builder] is mounted or unmounted, whose exact state can be queried by
/// [mounted]. After the owner of the [OverlayEntry] calls [remove] and then
/// [dispose], the widget may not be immediately removed from the widget tree.
/// As a result listeners of the [OverlayEntry] can get notified for one last
/// time after the [dispose] call, when the widget is eventually unmounted.
///
/// {@macro flutter.widgets.overlayPortalVsOverlayEntry}
///
/// See also:
///
///  * [OverlayPortal], an alternative API for inserting widgets into an
///    [Overlay] using a builder callback.
///  * [Overlay], a stack of entries that can be managed independently.
///  * [OverlayState], the current state of an Overlay.
///  * [WidgetsApp], a convenience widget that wraps a number of widgets that
///    are commonly required for an application.
///  * [MaterialApp], a convenience widget that wraps a number of widgets that
///    are commonly required for Material Design applications.
class OverlayEntry implements Listenable {
  /// Creates an overlay entry.
  ///
  /// To insert the entry into an [Overlay], first find the overlay using
  /// [Overlay.of] and then call [OverlayState.insert]. To remove the entry,
  /// call [remove] on the overlay entry itself.
  OverlayEntry({
    required this.builder,
    bool opaque = false,
    bool maintainState = false,
    this.canSizeOverlay = false,
  }) : _opaque = opaque,
       _maintainState = maintainState {
    if (kFlutterMemoryAllocationsEnabled) {
      _maybeDispatchObjectCreation();
    }
  }

  /// This entry will include the widget built by this builder in the overlay at
  /// the entry's position.
  ///
  /// To cause this builder to be called again, call [markNeedsBuild] on this
  /// overlay entry.
  final WidgetBuilder builder;

  /// Whether this entry occludes the entire overlay.
  ///
  /// If an entry claims to be opaque, then, for efficiency, the overlay will
  /// skip building entries below that entry unless they have [maintainState]
  /// set.
  bool get opaque => _opaque;
  bool _opaque;
  set opaque(bool value) {
    assert(!_disposedByOwner);
    if (_opaque == value) {
      return;
    }
    _opaque = value;
    _overlay?._didChangeEntryOpacity();
  }

  /// Whether this entry must be included in the tree even if there is a fully
  /// [opaque] entry above it.
  ///
  /// By default, if there is an entirely [opaque] entry over this one, then this
  /// one will not be included in the widget tree (in particular, stateful widgets
  /// within the overlay entry will not be instantiated). To ensure that your
  /// overlay entry is still built even if it is not visible, set [maintainState]
  /// to true. This is more expensive, so should be done with care. In particular,
  /// if widgets in an overlay entry with [maintainState] set to true repeatedly
  /// call [State.setState], the user's battery will be drained unnecessarily.
  ///
  /// This is used by the [Navigator] and [Route] objects to ensure that routes
  /// are kept around even when in the background, so that [Future]s promised
  /// from subsequent routes will be handled properly when they complete.
  bool get maintainState => _maintainState;
  bool _maintainState;
  set maintainState(bool value) {
    assert(!_disposedByOwner);
    if (_maintainState == value) {
      return;
    }
    _maintainState = value;
    assert(_overlay != null);
    _overlay!._didChangeEntryOpacity();
  }

  /// Whether the content of this [OverlayEntry] can be used to size the
  /// [Overlay].
  ///
  /// In most situations the overlay sizes itself based on its incoming
  /// constraints to be as large as possible. However, if that would result in
  /// an infinite size, it has to rely on one of its children to size itself. In
  /// this situation, the overlay will consult the topmost non-[Positioned]
  /// overlay entry that has this property set to true, lay it out with the
  /// incoming [BoxConstraints] of the overlay, and force all other
  /// non-[Positioned] overlay entries to have the same size. The [Positioned]
  /// entries are laid out as usual based on the calculated size of the overlay.
  ///
  /// Overlay entries that set this to true must be able to handle unconstrained
  /// [BoxConstraints].
  ///
  /// Setting this to true has no effect if the overlay entry uses a [Positioned]
  /// widget to position itself in the overlay.
  final bool canSizeOverlay;

  /// Whether the [OverlayEntry] is currently mounted in the widget tree.
  ///
  /// The [OverlayEntry] notifies its listeners when this value changes.
  bool get mounted => _overlayEntryStateNotifier?.value != null;

  /// The currently mounted `_OverlayEntryWidgetState` built using this [OverlayEntry].
  ValueNotifier<_OverlayEntryWidgetState?>? _overlayEntryStateNotifier =
      ValueNotifier<_OverlayEntryWidgetState?>(null);

  // TODO(polina-c): stop duplicating code across disposables
  // https://github.com/flutter/flutter/issues/137435
  /// Dispatches event of object creation to [FlutterMemoryAllocations.instance].
  void _maybeDispatchObjectCreation() {
    if (kFlutterMemoryAllocationsEnabled) {
      FlutterMemoryAllocations.instance.dispatchObjectCreated(
        library: _flutterWidgetsLibrary,
        className: '$OverlayEntry',
        object: this,
      );
    }
  }

  @override
  void addListener(VoidCallback listener) {
    assert(!_disposedByOwner);
    _overlayEntryStateNotifier?.addListener(listener);
  }

  @override
  void removeListener(VoidCallback listener) {
    _overlayEntryStateNotifier?.removeListener(listener);
  }

  OverlayState? _overlay;
  final GlobalKey<_OverlayEntryWidgetState> _key = GlobalKey<_OverlayEntryWidgetState>();

  /// Remove this entry from the overlay.
  ///
  /// This should only be called once.
  ///
  /// This method removes this overlay entry from the overlay immediately. The
  /// UI will be updated in the same frame if this method is called before the
  /// overlay rebuild in this frame; otherwise, the UI will be updated in the
  /// next frame. This means that it is safe to call during builds, but also
  /// that if you do call this after the overlay rebuild, the UI will not update
  /// until the next frame (i.e. many milliseconds later).
  void remove() {
    assert(_overlay != null);
    assert(!_disposedByOwner);
    final OverlayState overlay = _overlay!;
    _overlay = null;
    if (!overlay.mounted) {
      return;
    }

    overlay._entries.remove(this);
    if (SchedulerBinding.instance.schedulerPhase == SchedulerPhase.persistentCallbacks) {
      SchedulerBinding.instance.addPostFrameCallback((Duration duration) {
        overlay._markDirty();
      }, debugLabel: 'OverlayEntry.markDirty');
    } else {
      overlay._markDirty();
    }
  }

  /// Cause this entry to rebuild during the next pipeline flush.
  ///
  /// You need to call this function if the output of [builder] has changed.
  void markNeedsBuild() {
    assert(!_disposedByOwner);
    _key.currentState?._markNeedsBuild();
  }

  void _didUnmount() {
    assert(!mounted);
    if (_disposedByOwner) {
      _overlayEntryStateNotifier?.dispose();
      _overlayEntryStateNotifier = null;
    }
  }

  bool _disposedByOwner = false;

  /// Discards any resources used by this [OverlayEntry].
  ///
  /// This method must be called after [remove] if the [OverlayEntry] is
  /// inserted into an [Overlay].
  ///
  /// After this is called, the object is not in a usable state and should be
  /// discarded (calls to [addListener] will throw after the object is disposed).
  /// However, the listeners registered may not be immediately released until
  /// the widget built using this [OverlayEntry] is unmounted from the widget
  /// tree.
  ///
  /// This method should only be called by the object's owner.
  void dispose() {
    assert(!_disposedByOwner);
    assert(
      _overlay == null,
      'An OverlayEntry must first be removed from the Overlay before dispose is called.',
    );
    if (kFlutterMemoryAllocationsEnabled) {
      FlutterMemoryAllocations.instance.dispatchObjectDisposed(object: this);
    }
    _disposedByOwner = true;
    if (!mounted) {
      // If we're still mounted when disposed, then this will be disposed in
      // _didUnmount, to allow notifications to occur until the entry is
      // unmounted.
      _overlayEntryStateNotifier?.dispose();
      _overlayEntryStateNotifier = null;
    }
  }

  @override
  String toString() =>
      '${describeIdentity(this)}(opaque: $opaque; maintainState: $maintainState)${_disposedByOwner ? "(DISPOSED)" : ""}';
}

class _OverlayEntryWidget extends StatefulWidget {
  const _OverlayEntryWidget({
    required Key super.key,
    required this.entry,
    required this.overlayState,
    this.tickerEnabled = true,
  });

  final OverlayEntry entry;
  final OverlayState overlayState;
  final bool tickerEnabled;

  @override
  _OverlayEntryWidgetState createState() => _OverlayEntryWidgetState();
}

class _OverlayEntryWidgetState extends State<_OverlayEntryWidget> {
  late _RenderTheater _theater;

  // Manages the stack of theater children whose paint order are sorted by their
  // _zOrderIndex. The children added by OverlayPortal are added to this linked
  // list, and they will be shown _above_ the OverlayEntry tied to this widget.
  // The children with larger zOrderIndex values (i.e. those called `show`
  // recently) will be painted last.
  //
  // This linked list is lazily created in `_add`, and the entries are added/removed
  // via `_add`/`_remove`, called by OverlayPortals lower in the tree. `_add` or
  // `_remove` does not cause this widget to rebuild, the linked list will be
  // read by _RenderTheater as part of its render child model. This would ideally
  // be in a RenderObject but there may not be RenderObjects between
  // _RenderTheater and the render subtree OverlayEntry builds.
  LinkedList<_OverlayEntryLocation>? _sortedTheaterSiblings;

  // Worst-case O(N), N being the number of children added to the top spot in
  // the same frame. This can be a bit expensive when there's a lot of global
  // key reparenting in the same frame but N is usually a small number.
  void _add(_OverlayEntryLocation child) {
    assert(mounted);
    final LinkedList<_OverlayEntryLocation> children =
        _sortedTheaterSiblings ??= LinkedList<_OverlayEntryLocation>();
    assert(!children.contains(child));
    _OverlayEntryLocation? insertPosition = children.isEmpty ? null : children.last;
    while (insertPosition != null && insertPosition._zOrderIndex > child._zOrderIndex) {
      insertPosition = insertPosition.previous;
    }
    if (insertPosition == null) {
      children.addFirst(child);
    } else {
      insertPosition.insertAfter(child);
    }
    assert(children.contains(child));
  }

  void _remove(_OverlayEntryLocation child) {
    assert(_sortedTheaterSiblings != null);
    final bool wasInCollection = _sortedTheaterSiblings?.remove(child) ?? false;
    assert(wasInCollection);
  }

  // Returns an Iterable that traverse the children in the child model in paint
  // order (from farthest to the user to the closest to the user).
  //
  // The iterator should be safe to use even when the child model is being
  // mutated. The reason for that is it's allowed to add/remove/move deferred
  // children to a _RenderTheater during performLayout, but the affected
  // children don't have to be laid out in the same performLayout call.
  late final Iterable<RenderBox> _paintOrderIterable = _createChildIterable(reversed: false);
  // An Iterable that traverse the children in the child model in
  // hit-test order (from closest to the user to the farthest to the user).
  late final Iterable<RenderBox> _hitTestOrderIterable = _createChildIterable(reversed: true);

  // The following uses sync* because hit-testing is lazy, and LinkedList as a
  // Iterable doesn't support concurrent modification.
  Iterable<RenderBox> _createChildIterable({required bool reversed}) sync* {
    final LinkedList<_OverlayEntryLocation>? children = _sortedTheaterSiblings;
    if (children == null || children.isEmpty) {
      return;
    }
    _OverlayEntryLocation? candidate = reversed ? children.last : children.first;
    while (candidate != null) {
      final RenderBox? renderBox = candidate._overlayChildRenderBox;
      candidate = reversed ? candidate.previous : candidate.next;
      if (renderBox != null) {
        yield renderBox;
      }
    }
  }

  @override
  void initState() {
    super.initState();
    widget.entry._overlayEntryStateNotifier!.value = this;
    _theater = context.findAncestorRenderObjectOfType<_RenderTheater>()!;
    assert(_sortedTheaterSiblings == null);
  }

  @override
  void didUpdateWidget(_OverlayEntryWidget oldWidget) {
    super.didUpdateWidget(oldWidget);
    // OverlayState's build method always returns a RenderObjectWidget _Theater,
    // so it's safe to assume that state equality implies render object equality.
    assert(oldWidget.entry == widget.entry);
    if (oldWidget.overlayState != widget.overlayState) {
      final _RenderTheater newTheater = context.findAncestorRenderObjectOfType<_RenderTheater>()!;
      assert(_theater != newTheater);
      _theater = newTheater;
    }
  }

  @override
  void dispose() {
    widget.entry._overlayEntryStateNotifier?.value = null;
    widget.entry._didUnmount();
    _sortedTheaterSiblings = null;
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    return TickerMode(
      enabled: widget.tickerEnabled,
      child: _RenderTheaterMarker(
        theater: _theater,
        overlayEntryWidgetState: this,
        child: widget.entry.builder(context),
      ),
    );
  }

  void _markNeedsBuild() {
    setState(() {
      /* the state that changed is in the builder */
    });
  }
}

/// A stack of entries that can be managed independently.
///
/// Overlays let independent child widgets "float" visual elements on top of
/// other widgets by inserting them into the overlay's stack. The overlay lets
/// each of these widgets manage their participation in the overlay using
/// [OverlayEntry] objects.
///
/// Although you can create an [Overlay] directly, it's most common to use the
/// overlay created by the [Navigator] in a [WidgetsApp], [CupertinoApp] or a
/// [MaterialApp]. The navigator uses its overlay to manage the visual
/// appearance of its routes.
///
/// The [Overlay] widget uses a custom stack implementation, which is very
/// similar to the [Stack] widget. The main use case of [Overlay] is related to
/// navigation and being able to insert widgets on top of the pages in an app.
/// For layout purposes unrelated to navigation, consider using [Stack] instead.
///
/// An [Overlay] widget requires a [Directionality] widget to be in scope, so
/// that it can resolve direction-sensitive coordinates of any
/// [Positioned.directional] children.
///
/// For widgets drawn in an [OverlayEntry], do not assume that the size of the
/// [Overlay] is the size returned by [MediaQuery.sizeOf]. Nested overlays can
/// have different sizes.
///
/// {@tool dartpad}
/// This example shows how to use the [Overlay] to highlight the [NavigationBar]
/// destination.
///
/// ** See code in examples/api/lib/widgets/overlay/overlay.0.dart **
/// {@end-tool}
///
/// See also:
///
///  * [OverlayEntry], the class that is used for describing the overlay entries.
///  * [OverlayState], which is used to insert the entries into the overlay.
///  * [WidgetsApp], which inserts an [Overlay] widget indirectly via its [Navigator].
///  * [MaterialApp], which inserts an [Overlay] widget indirectly via its [Navigator].
///  * [CupertinoApp], which inserts an [Overlay] widget indirectly via its [Navigator].
///  * [Stack], which allows directly displaying a stack of widgets.
class Overlay extends StatefulWidget {
  /// Creates an overlay.
  ///
  /// The initial entries will be inserted into the overlay when its associated
  /// [OverlayState] is initialized.
  ///
  /// Rather than creating an overlay, consider using the overlay that is
  /// created by the [Navigator] in a [WidgetsApp], [CupertinoApp], or a
  /// [MaterialApp] for the application.
  const Overlay({
    super.key,
    this.initialEntries = const <OverlayEntry>[],
    this.clipBehavior = Clip.hardEdge,
  });

  /// Wrap the provided `child` in an [Overlay] to allow other visual elements
  /// (packed in [OverlayEntry]s) to float on top of the child.
  ///
  /// This is a convenience method over the regular [Overlay] constructor: It
  /// creates an [Overlay] and puts the provided `child` in an [OverlayEntry]
  /// at the bottom of that newly created Overlay.
  static Widget wrap({Key? key, Clip clipBehavior = Clip.hardEdge, required Widget child}) {
    return _WrappingOverlay(key: key, clipBehavior: clipBehavior, child: child);
  }

  /// The entries to include in the overlay initially.
  ///
  /// These entries are only used when the [OverlayState] is initialized. If you
  /// are providing a new [Overlay] description for an overlay that's already in
  /// the tree, then the new entries are ignored.
  ///
  /// To add entries to an [Overlay] that is already in the tree, use
  /// [Overlay.of] to obtain the [OverlayState] (or assign a [GlobalKey] to the
  /// [Overlay] widget and obtain the [OverlayState] via
  /// [GlobalKey.currentState]), and then use [OverlayState.insert] or
  /// [OverlayState.insertAll].
  ///
  /// To remove an entry from an [Overlay], use [OverlayEntry.remove].
  final List<OverlayEntry> initialEntries;

  /// {@macro flutter.material.Material.clipBehavior}
  ///
  /// Defaults to [Clip.hardEdge].
  final Clip clipBehavior;

  /// The [OverlayState] from the closest instance of [Overlay] that encloses
  /// the given context within the closest [LookupBoundary], and, in debug mode,
  /// will throw if one is not found.
  ///
  /// In debug mode, if the `debugRequiredFor` argument is provided and an
  /// overlay isn't found, then this function will throw an exception containing
  /// the runtime type of the given widget in the error message. The exception
  /// attempts to explain that the calling [Widget] (the one given by the
  /// `debugRequiredFor` argument) needs an [Overlay] to be present to function.
  /// If `debugRequiredFor` is not supplied, then the error message is more
  /// generic.
  ///
  /// Typical usage is as follows:
  ///
  /// ```dart
  /// OverlayState overlay = Overlay.of(context);
  /// ```
  ///
  /// If `rootOverlay` is set to true, the state from the furthest instance of
  /// this class is given instead. Useful for installing overlay entries above
  /// all subsequent instances of [Overlay].
  ///
  /// This method can be expensive (it walks the element tree).
  ///
  /// See also:
  ///
  /// * [Overlay.maybeOf] for a similar function that returns null if an
  ///   [Overlay] is not found.
  static OverlayState of(
    BuildContext context, {
    bool rootOverlay = false,
    Widget? debugRequiredFor,
  }) {
    final OverlayState? result = maybeOf(context, rootOverlay: rootOverlay);
    assert(() {
      if (result == null) {
        final bool hiddenByBoundary = LookupBoundary.debugIsHidingAncestorStateOfType<OverlayState>(
          context,
        );
        final List<DiagnosticsNode> information = <DiagnosticsNode>[
          ErrorSummary(
            'No Overlay widget found${hiddenByBoundary ? ' within the closest LookupBoundary' : ''}.',
          ),
          if (hiddenByBoundary)
            ErrorDescription(
              'There is an ancestor Overlay widget, but it is hidden by a LookupBoundary.',
            ),
          ErrorDescription(
            '${debugRequiredFor?.runtimeType ?? 'Some'} widgets require an Overlay widget ancestor for correct operation.',
          ),
          ErrorHint(
            'The most common way to add an Overlay to an application is to include a MaterialApp, CupertinoApp or Navigator widget in the runApp() call.',
          ),
          if (debugRequiredFor != null)
            DiagnosticsProperty<Widget>(
              'The specific widget that failed to find an overlay was',
              debugRequiredFor,
              style: DiagnosticsTreeStyle.errorProperty,
            ),
          if (context.widget != debugRequiredFor)
            context.describeElement(
              'The context from which that widget was searching for an overlay was',
            ),
        ];

        throw FlutterError.fromParts(information);
      }
      return true;
    }());
    return result!;
  }

  /// The [OverlayState] from the closest instance of [Overlay] that encloses
  /// the given context within the closest [LookupBoundary], if any.
  ///
  /// Typical usage is as follows:
  ///
  /// ```dart
  /// OverlayState? overlay = Overlay.maybeOf(context);
  /// ```
  ///
  /// If `rootOverlay` is set to true, the state from the furthest instance of
  /// this class is given instead. Useful for installing overlay entries above
  /// all subsequent instances of [Overlay].
  ///
  /// This method can be expensive (it walks the element tree).
  ///
  /// See also:
  ///
  ///  * [Overlay.of] for a similar function that returns a non-nullable result
  ///    and throws if an [Overlay] is not found.

  static OverlayState? maybeOf(BuildContext context, {bool rootOverlay = false}) {
    return rootOverlay
        ? LookupBoundary.findRootAncestorStateOfType<OverlayState>(context)
        : LookupBoundary.findAncestorStateOfType<OverlayState>(context);
  }

  @override
  OverlayState createState() => OverlayState();
}

/// The current state of an [Overlay].
///
/// Used to insert [OverlayEntry]s into the overlay using the [insert] and
/// [insertAll] functions.
class OverlayState extends State<Overlay> with TickerProviderStateMixin {
  final List<OverlayEntry> _entries = <OverlayEntry>[];

  @protected
  @override
  void initState() {
    super.initState();
    insertAll(widget.initialEntries);
  }

  int _insertionIndex(OverlayEntry? below, OverlayEntry? above) {
    assert(above == null || below == null);
    if (below != null) {
      return _entries.indexOf(below);
    }
    if (above != null) {
      return _entries.indexOf(above) + 1;
    }
    return _entries.length;
  }

  bool _debugCanInsertEntry(OverlayEntry entry) {
    final List<DiagnosticsNode> operandsInformation = <DiagnosticsNode>[
      DiagnosticsProperty<OverlayEntry>(
        'The OverlayEntry was',
        entry,
        style: DiagnosticsTreeStyle.errorProperty,
      ),
      DiagnosticsProperty<OverlayState>(
        'The Overlay the OverlayEntry was trying to insert to was',
        this,
        style: DiagnosticsTreeStyle.errorProperty,
      ),
    ];

    if (!mounted) {
      throw FlutterError.fromParts(<DiagnosticsNode>[
        ErrorSummary('Attempted to insert an OverlayEntry to an already disposed Overlay.'),
        ...operandsInformation,
      ]);
    }

    final OverlayState? currentOverlay = entry._overlay;
    final bool alreadyContainsEntry = _entries.contains(entry);

    if (alreadyContainsEntry) {
      final bool inconsistentOverlayState = !identical(currentOverlay, this);
      throw FlutterError.fromParts(<DiagnosticsNode>[
        ErrorSummary('The specified entry is already present in the target Overlay.'),
        ...operandsInformation,
        if (inconsistentOverlayState)
          ErrorHint('This could be an error in the Flutter framework.')
        else
          ErrorHint(
            'Consider calling remove on the OverlayEntry before inserting it to a different Overlay, '
            'or switching to the OverlayPortal API to avoid manual OverlayEntry management.',
          ),
        if (inconsistentOverlayState)
          DiagnosticsProperty<OverlayState>(
            "The OverlayEntry's current Overlay was",
            currentOverlay,
            style: DiagnosticsTreeStyle.errorProperty,
          ),
      ]);
    }

    if (currentOverlay == null) {
      return true;
    }

    throw FlutterError.fromParts(<DiagnosticsNode>[
      ErrorSummary('The specified entry is already present in a different Overlay.'),
      ...operandsInformation,
      DiagnosticsProperty<OverlayState>(
        "The OverlayEntry's current Overlay was",
        currentOverlay,
        style: DiagnosticsTreeStyle.errorProperty,
      ),
      ErrorHint(
        'Consider calling remove on the OverlayEntry before inserting it to a different Overlay, '
        'or switching to the OverlayPortal API to avoid manual OverlayEntry management.',
      ),
    ]);
  }

  /// Insert the given entry into the overlay.
  ///
  /// If `below` is non-null, the entry is inserted just below `below`.
  /// If `above` is non-null, the entry is inserted just above `above`.
  /// Otherwise, the entry is inserted on top.
  ///
  /// It is an error to specify both `above` and `below`.
  void insert(OverlayEntry entry, {OverlayEntry? below, OverlayEntry? above}) {
    assert(_debugVerifyInsertPosition(above, below));
    assert(_debugCanInsertEntry(entry));
    entry._overlay = this;
    setState(() {
      _entries.insert(_insertionIndex(below, above), entry);
    });
  }

  /// Insert all the entries in the given iterable.
  ///
  /// If `below` is non-null, the entries are inserted just below `below`.
  /// If `above` is non-null, the entries are inserted just above `above`.
  /// Otherwise, the entries are inserted on top.
  ///
  /// It is an error to specify both `above` and `below`.
  void insertAll(Iterable<OverlayEntry> entries, {OverlayEntry? below, OverlayEntry? above}) {
    assert(_debugVerifyInsertPosition(above, below));
    assert(entries.every(_debugCanInsertEntry));
    if (entries.isEmpty) {
      return;
    }
    for (final OverlayEntry entry in entries) {
      assert(entry._overlay == null);
      entry._overlay = this;
    }
    setState(() {
      _entries.insertAll(_insertionIndex(below, above), entries);
    });
  }

  bool _debugVerifyInsertPosition(
    OverlayEntry? above,
    OverlayEntry? below, {
    Iterable<OverlayEntry>? newEntries,
  }) {
    assert(above == null || below == null, 'Only one of `above` and `below` may be specified.');
    assert(
      above == null ||
          (above._overlay == this &&
              _entries.contains(above) &&
              (newEntries?.contains(above) ?? true)),
      'The provided entry used for `above` must be present in the Overlay${newEntries != null ? ' and in the `newEntriesList`' : ''}.',
    );
    assert(
      below == null ||
          (below._overlay == this &&
              _entries.contains(below) &&
              (newEntries?.contains(below) ?? true)),
      'The provided entry used for `below` must be present in the Overlay${newEntries != null ? ' and in the `newEntriesList`' : ''}.',
    );
    return true;
  }

  /// Remove all the entries listed in the given iterable, then reinsert them
  /// into the overlay in the given order.
  ///
  /// Entries mention in `newEntries` but absent from the overlay are inserted
  /// as if with [insertAll].
  ///
  /// Entries not mentioned in `newEntries` but present in the overlay are
  /// positioned as a group in the resulting list relative to the entries that
  /// were moved, as specified by one of `below` or `above`, which, if
  /// specified, must be one of the entries in `newEntries`:
  ///
  /// If `below` is non-null, the group is positioned just below `below`.
  /// If `above` is non-null, the group is positioned just above `above`.
  /// Otherwise, the group is left on top, with all the rearranged entries
  /// below.
  ///
  /// It is an error to specify both `above` and `below`.
  void rearrange(Iterable<OverlayEntry> newEntries, {OverlayEntry? below, OverlayEntry? above}) {
    final List<OverlayEntry> newEntriesList =
        newEntries is List<OverlayEntry> ? newEntries : newEntries.toList(growable: false);
    assert(_debugVerifyInsertPosition(above, below, newEntries: newEntriesList));
    assert(
      newEntriesList.every(
        (OverlayEntry entry) => entry._overlay == null || entry._overlay == this,
      ),
      'One or more of the specified entries are already present in another Overlay.',
    );
    assert(
      newEntriesList.every(
        (OverlayEntry entry) => _entries.indexOf(entry) == _entries.lastIndexOf(entry),
      ),
      'One or more of the specified entries are specified multiple times.',
    );
    if (newEntriesList.isEmpty) {
      return;
    }
    if (listEquals(_entries, newEntriesList)) {
      return;
    }
    final LinkedHashSet<OverlayEntry> old = LinkedHashSet<OverlayEntry>.of(_entries);
    for (final OverlayEntry entry in newEntriesList) {
      entry._overlay ??= this;
    }
    setState(() {
      _entries.clear();
      _entries.addAll(newEntriesList);
      old.removeAll(newEntriesList);
      _entries.insertAll(_insertionIndex(below, above), old);
    });
  }

  void _markDirty() {
    if (mounted) {
      setState(() {});
    }
  }

  /// (DEBUG ONLY) Check whether a given entry is visible (i.e., not behind an
  /// opaque entry).
  ///
  /// This is an O(N) algorithm, and should not be necessary except for debug
  /// asserts. To avoid people depending on it, this function is implemented
  /// only in debug mode, and always returns false in release mode.
  bool debugIsVisible(OverlayEntry entry) {
    bool result = false;
    assert(_entries.contains(entry));
    assert(() {
      for (int i = _entries.length - 1; i > 0; i -= 1) {
        final OverlayEntry candidate = _entries[i];
        if (candidate == entry) {
          result = true;
          break;
        }
        if (candidate.opaque) {
          break;
        }
      }
      return true;
    }());
    return result;
  }

  void _didChangeEntryOpacity() {
    setState(() {
      // We use the opacity of the entry in our build function, which means we
      // our state has changed.
    });
  }

  @protected
  @override
  Widget build(BuildContext context) {
    // This list is filled backwards and then reversed below before
    // it is added to the tree.
    final List<_OverlayEntryWidget> children = <_OverlayEntryWidget>[];
    bool onstage = true;
    int onstageCount = 0;
    for (final OverlayEntry entry in _entries.reversed) {
      if (onstage) {
        onstageCount += 1;
        children.add(_OverlayEntryWidget(key: entry._key, overlayState: this, entry: entry));
        if (entry.opaque) {
          onstage = false;
        }
      } else if (entry.maintainState) {
        children.add(
          _OverlayEntryWidget(
            key: entry._key,
            overlayState: this,
            entry: entry,
            tickerEnabled: false,
          ),
        );
      }
    }
    return _Theater(
      skipCount: children.length - onstageCount,
      clipBehavior: widget.clipBehavior,
      children: children.reversed.toList(growable: false),
    );
  }

  @protected
  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    // TODO(jacobr): use IterableProperty instead as that would
    // provide a slightly more consistent string summary of the List.
    properties.add(DiagnosticsProperty<List<OverlayEntry>>('entries', _entries));
  }
}

class _WrappingOverlay extends StatefulWidget {
  const _WrappingOverlay({super.key, this.clipBehavior = Clip.hardEdge, required this.child});

  final Clip clipBehavior;
  final Widget child;

  @override
  State<_WrappingOverlay> createState() => _WrappingOverlayState();
}

class _WrappingOverlayState extends State<_WrappingOverlay> {
  late final OverlayEntry _entry = OverlayEntry(
    canSizeOverlay: true,
    opaque: true,
    builder: (BuildContext context) {
      return widget.child;
    },
  );

  @override
  void didUpdateWidget(_WrappingOverlay oldWidget) {
    super.didUpdateWidget(oldWidget);
    _entry.markNeedsBuild();
  }

  @override
  void dispose() {
    _entry
      ..remove()
      ..dispose();
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    return Overlay(clipBehavior: widget.clipBehavior, initialEntries: <OverlayEntry>[_entry]);
  }
}

/// Special version of a [Stack], that doesn't layout and render the first
/// [skipCount] children.
///
/// The first [skipCount] children are considered "offstage".
class _Theater extends MultiChildRenderObjectWidget {
  const _Theater({
    this.skipCount = 0,
    this.clipBehavior = Clip.hardEdge,
    required List<_OverlayEntryWidget> super.children,
  }) : assert(skipCount >= 0),
       assert(children.length >= skipCount);

  final int skipCount;

  final Clip clipBehavior;

  @override
  _TheaterElement createElement() => _TheaterElement(this);

  @override
  _RenderTheater createRenderObject(BuildContext context) {
    return _RenderTheater(
      skipCount: skipCount,
      textDirection: Directionality.of(context),
      clipBehavior: clipBehavior,
    );
  }

  @override
  void updateRenderObject(BuildContext context, _RenderTheater renderObject) {
    renderObject
      ..skipCount = skipCount
      ..textDirection = Directionality.of(context)
      ..clipBehavior = clipBehavior;
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties.add(IntProperty('skipCount', skipCount));
  }
}

class _TheaterElement extends MultiChildRenderObjectElement {
  _TheaterElement(_Theater super.widget);

  @override
  _RenderTheater get renderObject => super.renderObject as _RenderTheater;

  @override
  void insertRenderObjectChild(RenderBox child, IndexedSlot<Element?> slot) {
    super.insertRenderObjectChild(child, slot);
    final _TheaterParentData parentData = child.parentData! as _TheaterParentData;
    parentData.overlayEntry =
        ((widget as _Theater).children[slot.index] as _OverlayEntryWidget).entry;
    assert(parentData.overlayEntry != null);
  }

  @override
  void moveRenderObjectChild(
    RenderBox child,
    IndexedSlot<Element?> oldSlot,
    IndexedSlot<Element?> newSlot,
  ) {
    super.moveRenderObjectChild(child, oldSlot, newSlot);
    assert(() {
      final _TheaterParentData parentData = child.parentData! as _TheaterParentData;
      return parentData.overlayEntry ==
          ((widget as _Theater).children[newSlot.index] as _OverlayEntryWidget).entry;
    }());
  }

  @override
  void debugVisitOnstageChildren(ElementVisitor visitor) {
    final _Theater theater = widget as _Theater;
    assert(children.length >= theater.skipCount);
    children.skip(theater.skipCount).forEach(visitor);
  }
}

// A `RenderBox` that sizes itself to its parent's size, implements the stack
// layout algorithm and renders its children in the given `theater`.
mixin _RenderTheaterMixin on RenderBox {
  _RenderTheater get theater;

  Iterable<RenderBox> _childrenInPaintOrder();
  Iterable<RenderBox> _childrenInHitTestOrder();

  @override
  void setupParentData(RenderBox child) {
    if (child.parentData is! StackParentData) {
      child.parentData = StackParentData();
    }
  }

  @override
  double? computeDistanceToActualBaseline(TextBaseline baseline) {
    assert(!debugNeedsLayout);
    BaselineOffset baselineOffset = BaselineOffset.noBaseline;
    for (final RenderBox child in _childrenInPaintOrder()) {
      assert(!child.debugNeedsLayout);
      final StackParentData childParentData = child.parentData! as StackParentData;
      baselineOffset = baselineOffset.minOf(
        BaselineOffset(child.getDistanceToActualBaseline(baseline)) + childParentData.offset.dy,
      );
    }
    return baselineOffset.offset;
  }

  static double? baselineForChild(
    RenderBox child,
    Size theaterSize,
    BoxConstraints nonPositionedChildConstraints,
    Alignment alignment,
    TextBaseline baseline,
  ) {
    final StackParentData childParentData = child.parentData! as StackParentData;
    final BoxConstraints childConstraints =
        childParentData.isPositioned
            ? childParentData.positionedChildConstraints(theaterSize)
            : nonPositionedChildConstraints;
    final double? baselineOffset = child.getDryBaseline(childConstraints, baseline);
    if (baselineOffset == null) {
      return null;
    }
    final double y = switch (childParentData) {
      StackParentData(:final double top?) => top,
      StackParentData(:final double bottom?) =>
        theaterSize.height - bottom - child.getDryLayout(childConstraints).height,
      StackParentData() =>
        alignment.alongOffset(theaterSize - child.getDryLayout(childConstraints) as Offset).dy,
    };
    return baselineOffset + y;
  }

  void layoutChild(RenderBox child, BoxConstraints nonPositionedChildConstraints) {
    final StackParentData childParentData = child.parentData! as StackParentData;
    final Alignment alignment = theater._resolvedAlignment;
    if (!childParentData.isPositioned) {
      child.layout(nonPositionedChildConstraints, parentUsesSize: true);
      childParentData.offset = Offset.zero;
    } else {
      assert(
        child is! _RenderDeferredLayoutBox,
        'all _RenderDeferredLayoutBoxes must be non-positioned children.',
      );
      RenderStack.layoutPositionedChild(child, childParentData, size, alignment);
    }
    assert(child.parentData == childParentData);
  }

  @override
  bool hitTestChildren(BoxHitTestResult result, {required Offset position}) {
    final Iterator<RenderBox> iterator = _childrenInHitTestOrder().iterator;
    bool isHit = false;
    while (!isHit && iterator.moveNext()) {
      final RenderBox child = iterator.current;
      final StackParentData childParentData = child.parentData! as StackParentData;
      final RenderBox localChild = child;
      bool childHitTest(BoxHitTestResult result, Offset position) =>
          localChild.hitTest(result, position: position);
      isHit = result.addWithPaintOffset(
        offset: childParentData.offset,
        position: position,
        hitTest: childHitTest,
      );
    }
    return isHit;
  }

  @override
  void paint(PaintingContext context, Offset offset) {
    for (final RenderBox child in _childrenInPaintOrder()) {
      final StackParentData childParentData = child.parentData! as StackParentData;
      context.paintChild(child, childParentData.offset + offset);
    }
  }
}

class _TheaterParentData extends StackParentData {
  // The OverlayEntry that directly created this child. This field is null for
  // children that are created by an OverlayPortal.
  OverlayEntry? overlayEntry;

  /// A [OverlayPortal] makes its overlay child a render child of an ancestor
  /// [Overlay]. Currently, to make sure the overlay child is painted after its
  /// [OverlayPortal], and before the next [OverlayEntry] (which could be
  /// something that should obstruct the overlay child, such as a [ModalRoute])
  /// in the host [Overlay], the paint order of each overlay child is managed by
  /// the [OverlayEntry] that hosts its [OverlayPortal].
  ///
  /// The following methods are exposed to allow easy access to the overlay
  /// children's render objects whose order is managed by [overlayEntry], in the
  /// right order.

  // _overlayStateMounted is set to null in _OverlayEntryWidgetState's dispose
  // method. This property is only accessed during layout, paint and hit-test so
  // the `value!` should be safe.
  Iterator<RenderBox>? get paintOrderIterator =>
      overlayEntry?._overlayEntryStateNotifier?.value!._paintOrderIterable.iterator;
  Iterator<RenderBox>? get hitTestOrderIterator =>
      overlayEntry?._overlayEntryStateNotifier?.value!._hitTestOrderIterable.iterator;

  // A convenience method for traversing `paintOrderIterator` with a
  // [RenderObjectVisitor].
  void visitOverlayPortalChildrenOnOverlayEntry(RenderObjectVisitor visitor) =>
      overlayEntry?._overlayEntryStateNotifier?.value!._paintOrderIterable.forEach(visitor);
}

class _RenderTheater extends RenderBox
    with ContainerRenderObjectMixin<RenderBox, StackParentData>, _RenderTheaterMixin {
  _RenderTheater({
    List<RenderBox>? children,
    required TextDirection textDirection,
    int skipCount = 0,
    Clip clipBehavior = Clip.hardEdge,
  }) : assert(skipCount >= 0),
       _textDirection = textDirection,
       _skipCount = skipCount,
       _clipBehavior = clipBehavior {
    addAll(children);
  }

  @override
  _RenderTheater get theater => this;

  @override
  void setupParentData(RenderBox child) {
    if (child.parentData is! _TheaterParentData) {
      child.parentData = _TheaterParentData();
    }
  }

  @override
  void attach(PipelineOwner owner) {
    super.attach(owner);
    RenderBox? child = firstChild;
    while (child != null) {
      final _TheaterParentData childParentData = child.parentData! as _TheaterParentData;
      final Iterator<RenderBox>? iterator = childParentData.paintOrderIterator;
      if (iterator != null) {
        while (iterator.moveNext()) {
          iterator.current.attach(owner);
        }
      }
      child = childParentData.nextSibling;
    }
  }

  static void _detachChild(RenderObject child) => child.detach();

  @override
  void detach() {
    super.detach();
    RenderBox? child = firstChild;
    while (child != null) {
      final _TheaterParentData childParentData = child.parentData! as _TheaterParentData;
      childParentData.visitOverlayPortalChildrenOnOverlayEntry(_detachChild);
      child = childParentData.nextSibling;
    }
  }

  @override
  void redepthChildren() => visitChildren(redepthChild);

  Alignment? _alignmentCache;
  Alignment get _resolvedAlignment =>
      _alignmentCache ??= AlignmentDirectional.topStart.resolve(textDirection);

  void _markNeedResolution() {
    _alignmentCache = null;
    markNeedsLayout();
  }

  TextDirection get textDirection => _textDirection;
  TextDirection _textDirection;
  set textDirection(TextDirection value) {
    if (_textDirection == value) {
      return;
    }
    _textDirection = value;
    _markNeedResolution();
  }

  int get skipCount => _skipCount;
  int _skipCount;
  set skipCount(int value) {
    if (_skipCount != value) {
      _skipCount = value;
      markNeedsLayout();
    }
  }

  /// {@macro flutter.material.Material.clipBehavior}
  ///
  /// Defaults to [Clip.hardEdge].
  Clip get clipBehavior => _clipBehavior;
  Clip _clipBehavior = Clip.hardEdge;
  set clipBehavior(Clip value) {
    if (value != _clipBehavior) {
      _clipBehavior = value;
      markNeedsPaint();
      markNeedsSemanticsUpdate();
    }
  }

  // Adding/removing deferred child does not affect the layout of other children,
  // or that of the Overlay, so there's no need to invalidate the layout of the
  // Overlay.
  //
  // When _skipMarkNeedsLayout is true, markNeedsLayout does not do anything.
  bool _skipMarkNeedsLayout = false;
  void _addDeferredChild(_RenderDeferredLayoutBox child) {
    assert(!_skipMarkNeedsLayout);
    _skipMarkNeedsLayout = true;
    adoptChild(child);
    // The Overlay still needs repainting when a deferred child is added. Usually
    // `markNeedsLayout` implies `markNeedsPaint`, but here `markNeedsLayout` is
    // skipped when the `_skipMarkNeedsLayout` flag is set.
    markNeedsPaint();
    _skipMarkNeedsLayout = false;

    // After adding `child` to the render tree, we want to make sure it will be
    // laid out in the same frame. This is done by calling markNeedsLayout on the
    // layout surrogate. This ensures `child` is reachable via tree walk (see
    // _RenderLayoutSurrogateProxyBox.performLayout).
    child._layoutSurrogate.markNeedsLayout();
  }

  void _removeDeferredChild(_RenderDeferredLayoutBox child) {
    assert(!_skipMarkNeedsLayout);
    _skipMarkNeedsLayout = true;
    dropChild(child);
    // The Overlay still needs repainting when a deferred child is dropped. See
    // the comment in `_addDeferredChild`.
    markNeedsPaint();
    _skipMarkNeedsLayout = false;
  }

  @override
  void markNeedsLayout() {
    if (!_skipMarkNeedsLayout) {
      super.markNeedsLayout();
    }
  }

  RenderBox? get _firstOnstageChild {
    if (skipCount == super.childCount) {
      return null;
    }
    RenderBox? child = super.firstChild;
    for (int toSkip = skipCount; toSkip > 0; toSkip--) {
      final StackParentData childParentData = child!.parentData! as StackParentData;
      child = childParentData.nextSibling;
      assert(child != null);
    }
    return child;
  }

  RenderBox? get _lastOnstageChild => skipCount == super.childCount ? null : lastChild;

  @override
  double computeMinIntrinsicWidth(double height) {
    return RenderStack.getIntrinsicDimension(
      _firstOnstageChild,
      (RenderBox child) => child.getMinIntrinsicWidth(height),
    );
  }

  @override
  double computeMaxIntrinsicWidth(double height) {
    return RenderStack.getIntrinsicDimension(
      _firstOnstageChild,
      (RenderBox child) => child.getMaxIntrinsicWidth(height),
    );
  }

  @override
  double computeMinIntrinsicHeight(double width) {
    return RenderStack.getIntrinsicDimension(
      _firstOnstageChild,
      (RenderBox child) => child.getMinIntrinsicHeight(width),
    );
  }

  @override
  double computeMaxIntrinsicHeight(double width) {
    return RenderStack.getIntrinsicDimension(
      _firstOnstageChild,
      (RenderBox child) => child.getMaxIntrinsicHeight(width),
    );
  }

  @override
  double? computeDryBaseline(BoxConstraints constraints, TextBaseline baseline) {
    final Size size =
        constraints.biggest.isFinite
            ? constraints.biggest
            : _findSizeDeterminingChild().getDryLayout(constraints);
    final BoxConstraints nonPositionedChildConstraints = BoxConstraints.tight(size);
    final Alignment alignment = theater._resolvedAlignment;

    BaselineOffset baselineOffset = BaselineOffset.noBaseline;
    for (final RenderBox child in _childrenInPaintOrder()) {
      baselineOffset = baselineOffset.minOf(
        BaselineOffset(
          _RenderTheaterMixin.baselineForChild(
            child,
            size,
            nonPositionedChildConstraints,
            alignment,
            baseline,
          ),
        ),
      );
    }
    return baselineOffset.offset;
  }

  @override
  Size computeDryLayout(BoxConstraints constraints) {
    if (constraints.biggest.isFinite) {
      return constraints.biggest;
    }
    return _findSizeDeterminingChild().getDryLayout(constraints);
  }

  @override
  // The following uses sync* because concurrent modifications should be allowed
  // during layout.
  Iterable<RenderBox> _childrenInPaintOrder() sync* {
    RenderBox? child = _firstOnstageChild;
    while (child != null) {
      yield child;
      final _TheaterParentData childParentData = child.parentData! as _TheaterParentData;
      final Iterator<RenderBox>? innerIterator = childParentData.paintOrderIterator;
      if (innerIterator != null) {
        while (innerIterator.moveNext()) {
          yield innerIterator.current;
        }
      }
      child = childParentData.nextSibling;
    }
  }

  @override
  // The following uses sync* because hit testing should be lazy.
  Iterable<RenderBox> _childrenInHitTestOrder() sync* {
    RenderBox? child = _lastOnstageChild;
    int childLeft = childCount - skipCount;
    while (child != null) {
      final _TheaterParentData childParentData = child.parentData! as _TheaterParentData;
      final Iterator<RenderBox>? innerIterator = childParentData.hitTestOrderIterator;
      if (innerIterator != null) {
        while (innerIterator.moveNext()) {
          yield innerIterator.current;
        }
      }
      yield child;
      childLeft -= 1;
      child = childLeft <= 0 ? null : childParentData.previousSibling;
    }
  }

  @override
  bool get sizedByParent => false;

  bool _layingOutSizeDeterminingChild = false;
  @override
  void performLayout() {
    RenderBox? sizeDeterminingChild;
    if (constraints.biggest.isFinite) {
      size = constraints.biggest;
    } else {
      sizeDeterminingChild = _findSizeDeterminingChild();
      _layingOutSizeDeterminingChild = true;
      layoutChild(sizeDeterminingChild, constraints);
      _layingOutSizeDeterminingChild = false;
      size = sizeDeterminingChild.size;
    }

    // Equivalent to BoxConstraints used by RenderStack for StackFit.expand.
    final BoxConstraints nonPositionedChildConstraints = BoxConstraints.tight(size);
    for (final RenderBox child in _childrenInPaintOrder()) {
      if (child != sizeDeterminingChild) {
        layoutChild(child, nonPositionedChildConstraints);
      }
    }
  }

  RenderBox _findSizeDeterminingChild() {
    RenderBox? child = _lastOnstageChild;
    while (child != null) {
      final _TheaterParentData childParentData = child.parentData! as _TheaterParentData;
      if ((childParentData.overlayEntry?.canSizeOverlay ?? false) &&
          !childParentData.isPositioned) {
        return child;
      }
      child = childParentData.previousSibling;
    }
    throw FlutterError.fromParts(<DiagnosticsNode>[
      ErrorSummary(
        'Overlay was given infinite constraints and cannot be sized by a suitable child.',
      ),
      ErrorDescription(
        'The constraints given to the overlay ($constraints) would result in an illegal '
        'infinite size (${constraints.biggest}). To avoid that, the Overlay tried to size '
        'itself to one of its children, but no suitable non-positioned child that belongs to an '
        'OverlayEntry with canSizeOverlay set to true could be found.',
      ),
      ErrorHint(
        'Try wrapping the Overlay in a SizedBox to give it a finite size or '
        'use an OverlayEntry with canSizeOverlay set to true.',
      ),
    ]);
  }

  final LayerHandle<ClipRectLayer> _clipRectLayer = LayerHandle<ClipRectLayer>();

  @override
  void paint(PaintingContext context, Offset offset) {
    if (clipBehavior != Clip.none) {
      _clipRectLayer.layer = context.pushClipRect(
        needsCompositing,
        offset,
        Offset.zero & size,
        super.paint,
        clipBehavior: clipBehavior,
        oldLayer: _clipRectLayer.layer,
      );
    } else {
      _clipRectLayer.layer = null;
      super.paint(context, offset);
    }
  }

  @override
  void dispose() {
    _clipRectLayer.layer = null;
    super.dispose();
  }

  @override
  void visitChildren(RenderObjectVisitor visitor) {
    RenderBox? child = firstChild;
    while (child != null) {
      visitor(child);
      final _TheaterParentData childParentData = child.parentData! as _TheaterParentData;
      childParentData.visitOverlayPortalChildrenOnOverlayEntry(visitor);
      child = childParentData.nextSibling;
    }
  }

  @override
  void visitChildrenForSemantics(RenderObjectVisitor visitor) {
    RenderBox? child = _firstOnstageChild;
    while (child != null) {
      visitor(child);
      final _TheaterParentData childParentData = child.parentData! as _TheaterParentData;
      child = childParentData.nextSibling;
    }
  }

  @override
  Rect? describeApproximatePaintClip(RenderObject child) {
    switch (clipBehavior) {
      case Clip.none:
        return null;
      case Clip.hardEdge:
      case Clip.antiAlias:
      case Clip.antiAliasWithSaveLayer:
        return Offset.zero & size;
    }
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties.add(IntProperty('skipCount', skipCount));
    properties.add(EnumProperty<TextDirection>('textDirection', textDirection));
  }

  @override
  List<DiagnosticsNode> debugDescribeChildren() {
    final List<DiagnosticsNode> offstageChildren = <DiagnosticsNode>[];
    final List<DiagnosticsNode> onstageChildren = <DiagnosticsNode>[];

    int count = 1;
    bool onstage = false;
    RenderBox? child = firstChild;
    final RenderBox? firstOnstageChild = _firstOnstageChild;
    while (child != null) {
      final _TheaterParentData childParentData = child.parentData! as _TheaterParentData;
      if (child == firstOnstageChild) {
        onstage = true;
        count = 1;
      }

      if (onstage) {
        onstageChildren.add(child.toDiagnosticsNode(name: 'onstage $count'));
      } else {
        offstageChildren.add(
          child.toDiagnosticsNode(name: 'offstage $count', style: DiagnosticsTreeStyle.offstage),
        );
      }

      int subcount = 1;
      childParentData.visitOverlayPortalChildrenOnOverlayEntry((RenderObject renderObject) {
        final RenderBox child = renderObject as RenderBox;
        if (onstage) {
          onstageChildren.add(child.toDiagnosticsNode(name: 'onstage $count - $subcount'));
        } else {
          offstageChildren.add(
            child.toDiagnosticsNode(
              name: 'offstage $count - $subcount',
              style: DiagnosticsTreeStyle.offstage,
            ),
          );
        }
        subcount += 1;
      });

      child = childParentData.nextSibling;
      count += 1;
    }

    return <DiagnosticsNode>[
      ...onstageChildren,
      if (offstageChildren.isNotEmpty)
        ...offstageChildren
      else
        DiagnosticsNode.message('no offstage children', style: DiagnosticsTreeStyle.offstage),
    ];
  }
}

// * OverlayPortal Implementation
//  OverlayPortal is inspired by the
//  [flutter_portal](https://pub.dev/packages/flutter_portal) package.
//
// ** RenderObject hierarchy
// The widget works by inserting its overlay child's render subtree directly
// under [Overlay]'s render object (_RenderTheater).
// https://user-images.githubusercontent.com/31859944/171971838-62ed3975-4b5d-4733-a9c9-f79e263b8fcc.jpg
//
// To ensure the overlay child render subtree does not do layout twice, the
// subtree must only perform layout after both its _RenderTheater and the
// [OverlayPortal]'s render object (_RenderLayoutSurrogateProxyBox) have
// finished layout. This is handled by _RenderDeferredLayoutBox.
//
// ** Z-Index of an overlay child
// [_OverlayEntryLocation] is a (currently private) interface that allows an
// [OverlayPortal] to insert its overlay child into a specific [Overlay], as
// well as specifying the paint order between the overlay child and other
// children of the _RenderTheater.
//
// Since [OverlayPortal] is only allowed to target ancestor [Overlay]s
// (_RenderTheater must finish doing layout before _RenderDeferredLayoutBox),
// the _RenderTheater should typically be acquired using an [InheritedWidget]
// (currently, _RenderTheaterMarker) in case the [OverlayPortal] gets
// reparented.

/// A class to show, hide and bring to top an [OverlayPortal]'s overlay child
/// in the target [Overlay].
///
/// A [OverlayPortalController] can only be given to at most one [OverlayPortal]
/// at a time. When an [OverlayPortalController] is moved from one
/// [OverlayPortal] to another, its [isShowing] state does not carry over.
///
/// [OverlayPortalController.show] and [OverlayPortalController.hide] can be
/// called even before the controller is assigned to any [OverlayPortal], but
/// they typically should not be called while the widget tree is being rebuilt.
class OverlayPortalController {
  /// Creates an [OverlayPortalController], optionally with a String identifier
  /// `debugLabel`.
  OverlayPortalController({String? debugLabel}) : _debugLabel = debugLabel;

  _OverlayPortalState? _attachTarget;

  // A separate _zOrderIndex to allow `show()` or `hide()` to be called when the
  // controller is not yet attached. Once this controller is attached,
  // _attachTarget._zOrderIndex will be used as the source of truth, and this
  // variable will be set to null.
  int? _zOrderIndex;
  final String? _debugLabel;

  static int _wallTime =
      kIsWeb
          ? -9007199254740992 // -2^53
          : -1 << 63;

  // Returns a unique and monotonically increasing timestamp that represents
  // now.
  //
  // The value this method returns increments after each call.
  int _now() {
    final int now = _wallTime += 1;
    assert(_zOrderIndex == null || _zOrderIndex! < now);
    assert(_attachTarget?._zOrderIndex == null || _attachTarget!._zOrderIndex! < now);
    return now;
  }

  /// Show the overlay child of the [OverlayPortal] this controller is attached
  /// to, at the top of the target [Overlay].
  ///
  /// When there are more than one [OverlayPortal]s that target the same
  /// [Overlay], the overlay child of the last [OverlayPortal] to have called
  /// [show] appears at the top level, unobstructed.
  ///
  /// If [isShowing] is already true, calling this method brings the overlay
  /// child it controls to the top.
  ///
  /// This method should typically not be called while the widget tree is being
  /// rebuilt.
  void show() {
    final _OverlayPortalState? state = _attachTarget;
    if (state != null) {
      state.show(_now());
    } else {
      _zOrderIndex = _now();
    }
  }

  /// Hide the [OverlayPortal]'s overlay child.
  ///
  /// Once hidden, the overlay child will be removed from the widget tree the
  /// next time the widget tree rebuilds, and stateful widgets in the overlay
  /// child may lose states as a result.
  ///
  /// This method should typically not be called while the widget tree is being
  /// rebuilt.
  void hide() {
    final _OverlayPortalState? state = _attachTarget;
    if (state != null) {
      state.hide();
    } else {
      assert(_zOrderIndex != null);
      _zOrderIndex = null;
    }
  }

  /// Whether the associated [OverlayPortal] should build and show its overlay
  /// child, using its `overlayChildBuilder`.
  bool get isShowing {
    final _OverlayPortalState? state = _attachTarget;
    return state != null ? state._zOrderIndex != null : _zOrderIndex != null;
  }

  /// Convenience method for toggling the current [isShowing] status.
  ///
  /// This method should typically not be called while the widget tree is being
  /// rebuilt.
  void toggle() => isShowing ? hide() : show();

  @override
  String toString() {
    final String? debugLabel = _debugLabel;
    final String label = debugLabel == null ? '' : '($debugLabel)';
    final String isDetached = _attachTarget != null ? '' : ' DETACHED';
    return '${objectRuntimeType(this, 'OverlayPortalController')}$label$isDetached';
  }
}

/// A widget that renders its overlay child on an [Overlay].
///
/// The overlay child is initially hidden until [OverlayPortalController.show]
/// is called on the associated [controller]. The [OverlayPortal] uses
/// [overlayChildBuilder] to build its overlay child and renders it on the
/// specified [Overlay] as if it was inserted using an [OverlayEntry], while it
/// can depend on the same set of [InheritedWidget]s (such as [Theme]) that this
/// widget can depend on.
///
/// This widget requires an [Overlay] ancestor in the widget tree when its
/// overlay child is showing. The overlay child is rendered by the [Overlay]
/// ancestor, not by the widget itself. This allows the overlay child to float
/// above other widgets, independent of its position in the widget tree.
///
/// When [OverlayPortalController.hide] is called, the widget built using
/// [overlayChildBuilder] will be removed from the widget tree the next time the
/// widget rebuilds. Stateful descendants in the overlay child subtree may lose
/// states as a result.
///
/// {@tool dartpad}
/// This example uses an [OverlayPortal] to build a tooltip that becomes visible
/// when the user taps on the [child] widget. There's a [DefaultTextStyle] above
/// the [OverlayPortal] controlling the [TextStyle] of both the [child] widget
/// and the widget [overlayChildBuilder] builds, which isn't otherwise doable if
/// the tooltip was added as an [OverlayEntry].
///
/// ** See code in examples/api/lib/widgets/overlay/overlay_portal.0.dart **
/// {@end-tool}
///
/// ### Paint Order
///
/// In an [Overlay], an overlay child is painted after the [OverlayEntry]
/// associated with its [OverlayPortal] (that is, the [OverlayEntry] closest to
/// the [OverlayPortal] in the widget tree, which usually represents the
/// enclosing [Route]), and before the next [OverlayEntry].
///
/// When an [OverlayEntry] has multiple associated [OverlayPortal]s, the paint
/// order between their overlay children is the order in which
/// [OverlayPortalController.show] was called. The last [OverlayPortal] to have
/// called `show` gets to paint its overlay child in the foreground.
///
/// ### Semantics
///
/// The semantics subtree generated by the overlay child is considered attached
/// to [OverlayPortal] instead of the target [Overlay]. An [OverlayPortal]'s
/// semantics subtree can be dropped from the semantics tree due to invisibility
/// while the overlay child is still visible (for example, when the
/// [OverlayPortal] is completely invisible in a [ListView] but kept alive by
/// a [KeepAlive] widget). When this happens the semantics subtree generated by
/// the overlay child is also dropped, even if the overlay child is still visible
/// on screen.
///
/// {@template flutter.widgets.overlayPortalVsOverlayEntry}
/// ### Differences between [OverlayPortal] and [OverlayEntry]
///
/// The main difference between [OverlayEntry] and [OverlayPortal] is that
/// [OverlayEntry] builds its widget subtree as a child of the target [Overlay],
/// while [OverlayPortal] uses [OverlayPortal.overlayChildBuilder] to build a
/// child widget of itself. This allows [OverlayPortal]'s overlay child to depend
/// on the same set of [InheritedWidget]s as [OverlayPortal], and it's also
/// guaranteed that the overlay child will not outlive its [OverlayPortal].
///
/// On the other hand, [OverlayPortal]'s implementation is more complex. For
/// instance, it does a bit more work than a regular widget during global key
/// reparenting. If the content to be shown on the [Overlay] doesn't benefit
/// from being a part of [OverlayPortal]'s subtree, consider using an
/// [OverlayEntry] instead.
/// {@endtemplate}
///
/// See also:
///
///  * [OverlayEntry], an alternative API for inserting widgets into an
///    [Overlay].
///  * [Positioned], which can be used to size and position the overlay child in
///    relation to the target [Overlay]'s boundaries.
///  * [CompositedTransformFollower], which can be used to position the overlay
///    child in relation to the linked [CompositedTransformTarget] widget.
class OverlayPortal extends StatefulWidget {
  /// Creates an [OverlayPortal] that renders the widget [overlayChildBuilder]
  /// builds on the closest [Overlay] when [OverlayPortalController.show] is
  /// called.
  const OverlayPortal({
    super.key,
    required this.controller,
    required this.overlayChildBuilder,
    this.child,
  }) : _targetRootOverlay = false;

  /// Creates an [OverlayPortal] that renders the widget [overlayChildBuilder]
  /// builds on the root [Overlay] when [OverlayPortalController.show] is
  /// called.
  const OverlayPortal.targetsRootOverlay({
    super.key,
    required this.controller,
    required this.overlayChildBuilder,
    this.child,
  }) : _targetRootOverlay = true;

  /// The controller to show, hide and bring to top the overlay child.
  final OverlayPortalController controller;

  /// A [WidgetBuilder] used to build a widget below this widget in the tree,
  /// that renders on the closest [Overlay].
  ///
  /// The said widget will only be built and shown in the closest [Overlay] once
  /// [OverlayPortalController.show] is called on the associated [controller].
  /// It will be painted in front of the [OverlayEntry] closest to this widget
  /// in the widget tree (which is usually the enclosing [Route]).
  ///
  /// The built overlay child widget is inserted below this widget in the widget
  /// tree, allowing it to depend on [InheritedWidget]s above it, and be
  /// notified when the [InheritedWidget]s change.
  ///
  /// Unlike [child], the built overlay child can visually extend outside the
  /// bounds of this widget without being clipped, and receive hit-test events
  /// outside of this widget's bounds, as long as it does not extend outside of
  /// the [Overlay] on which it is rendered.
  final WidgetBuilder overlayChildBuilder;

  /// A widget below this widget in the tree.
  final Widget? child;

  final bool _targetRootOverlay;

  @override
  State<OverlayPortal> createState() => _OverlayPortalState();
}

class _OverlayPortalState extends State<OverlayPortal> {
  int? _zOrderIndex;
  // The location of the overlay child within the overlay. This object will be
  // used as the slot of the overlay child widget.
  //
  // The developer must call `show` to reveal the overlay so we can get a unique
  // timestamp of the user interaction for determining the z-index of the
  // overlay child in the overlay.
  //
  // Avoid invalidating the cache if possible, since the framework uses `==` to
  // compare slots, and _OverlayEntryLocation can't override that operator since
  // it's mutable. Changing slots can be relatively slow.
  bool _childModelMayHaveChanged = true;
  _OverlayEntryLocation? _locationCache;
  static bool _isTheSameLocation(_OverlayEntryLocation locationCache, _RenderTheaterMarker marker) {
    return locationCache._childModel == marker.overlayEntryWidgetState &&
        locationCache._theater == marker.theater;
  }

  _OverlayEntryLocation _getLocation(int zOrderIndex, bool targetRootOverlay) {
    final _OverlayEntryLocation? cachedLocation = _locationCache;
    late final _RenderTheaterMarker marker = _RenderTheaterMarker.of(
      context,
      targetRootOverlay: targetRootOverlay,
    );
    final bool isCacheValid =
        cachedLocation != null &&
        (!_childModelMayHaveChanged || _isTheSameLocation(cachedLocation, marker));
    _childModelMayHaveChanged = false;
    if (isCacheValid) {
      assert(cachedLocation._zOrderIndex == zOrderIndex);
      assert(cachedLocation._debugIsLocationValid());
      return cachedLocation;
    }
    // Otherwise invalidate the cache and create a new location.
    cachedLocation?._debugMarkLocationInvalid();
    final _OverlayEntryLocation newLocation = _OverlayEntryLocation(
      zOrderIndex,
      marker.overlayEntryWidgetState,
      marker.theater,
    );
    assert(newLocation._zOrderIndex == zOrderIndex);
    return _locationCache = newLocation;
  }

  @override
  void initState() {
    super.initState();
    _setupController(widget.controller);
  }

  void _setupController(OverlayPortalController controller) {
    assert(
      controller._attachTarget == null || controller._attachTarget == this,
      'Failed to attach $controller to $this. It is already attached to ${controller._attachTarget}.',
    );
    final int? controllerZOrderIndex = controller._zOrderIndex;
    final int? zOrderIndex = _zOrderIndex;
    if (zOrderIndex == null ||
        (controllerZOrderIndex != null && controllerZOrderIndex > zOrderIndex)) {
      _zOrderIndex = controllerZOrderIndex;
    }
    controller._zOrderIndex = null;
    controller._attachTarget = this;
  }

  @override
  void didChangeDependencies() {
    super.didChangeDependencies();
    _childModelMayHaveChanged = true;
  }

  @override
  void didUpdateWidget(OverlayPortal oldWidget) {
    super.didUpdateWidget(oldWidget);
    _childModelMayHaveChanged =
        _childModelMayHaveChanged || oldWidget._targetRootOverlay != widget._targetRootOverlay;
    if (oldWidget.controller != widget.controller) {
      oldWidget.controller._attachTarget = null;
      _setupController(widget.controller);
    }
  }

  @override
  void dispose() {
    assert(widget.controller._attachTarget == this);
    widget.controller._attachTarget = null;
    _locationCache?._debugMarkLocationInvalid();
    _locationCache = null;
    super.dispose();
  }

  void show(int zOrderIndex) {
    assert(
      SchedulerBinding.instance.schedulerPhase != SchedulerPhase.persistentCallbacks,
      '${widget.controller.runtimeType}.show() should not be called during build.',
    );
    setState(() {
      _zOrderIndex = zOrderIndex;
    });
    _locationCache?._debugMarkLocationInvalid();
    _locationCache = null;
  }

  void hide() {
    assert(SchedulerBinding.instance.schedulerPhase != SchedulerPhase.persistentCallbacks);
    setState(() {
      _zOrderIndex = null;
    });
    _locationCache?._debugMarkLocationInvalid();
    _locationCache = null;
  }

  @override
  Widget build(BuildContext context) {
    final int? zOrderIndex = _zOrderIndex;
    if (zOrderIndex == null) {
      return _OverlayPortal(overlayLocation: null, overlayChild: null, child: widget.child);
    }
    return _OverlayPortal(
      overlayLocation: _getLocation(zOrderIndex, widget._targetRootOverlay),
      overlayChild: _DeferredLayout(child: Builder(builder: widget.overlayChildBuilder)),
      child: widget.child,
    );
  }
}

/// A location in an [Overlay].
///
/// An [_OverlayEntryLocation] determines the [Overlay] the associated
/// [OverlayPortal] should put its overlay child onto, as well as the overlay
/// child's paint order in relation to other contents painted on the [Overlay].
//
// An _OverlayEntryLocation is a cursor pointing to a location in a particular
// Overlay's child model, and provides methods to insert/remove/move a
// _RenderDeferredLayoutBox to/from its target _theater.
//
// The occupant (a `RenderBox`) will be painted above the associated
// [OverlayEntry], but below the [OverlayEntry] above that [OverlayEntry].
//
// Additionally, `_activate` and `_deactivate` are called when the overlay
// child's `_OverlayPortalElement` activates/deactivates (for instance, during
// global key reparenting).
// `_OverlayPortalElement` removes its overlay child's render object from the
// target `_RenderTheater` when it deactivates and puts it back on `activated`.
// These 2 methods can be used to "hide" a child in the child model without
// removing it, when the child is expensive/difficult to re-insert at the
// correct location on `activated`.
//
// ### Equality
//
// An `_OverlayEntryLocation` will be used as an Element's slot. These 3 parts
// uniquely identify a place in an overlay's child model:
// - _theater
// - _childModel (the OverlayEntry)
// - _zOrderIndex
//
// Since it can't implement operator== (it's mutable), the same `_OverlayEntryLocation`
// instance must not be used to represent more than one locations.
final class _OverlayEntryLocation extends LinkedListEntry<_OverlayEntryLocation> {
  _OverlayEntryLocation(this._zOrderIndex, this._childModel, this._theater);

  final int _zOrderIndex;
  final _OverlayEntryWidgetState _childModel;
  final _RenderTheater _theater;

  _RenderDeferredLayoutBox? _overlayChildRenderBox;
  void _addToChildModel(_RenderDeferredLayoutBox child) {
    assert(
      _overlayChildRenderBox == null,
      'Failed to add $child. This location ($this) is already occupied by $_overlayChildRenderBox.',
    );
    _overlayChildRenderBox = child;
    _childModel._add(this);
    _theater.markNeedsPaint();
    _theater.markNeedsCompositingBitsUpdate();
    _theater.markNeedsSemanticsUpdate();
  }

  void _removeFromChildModel(_RenderDeferredLayoutBox child) {
    assert(child == _overlayChildRenderBox);
    _overlayChildRenderBox = null;
    assert(_childModel._sortedTheaterSiblings?.contains(this) ?? false);
    _childModel._remove(this);
    _theater.markNeedsPaint();
    _theater.markNeedsCompositingBitsUpdate();
    _theater.markNeedsSemanticsUpdate();
  }

  void _addChild(_RenderDeferredLayoutBox child) {
    assert(_debugIsLocationValid());
    _addToChildModel(child);
    _theater._addDeferredChild(child);
    assert(child.parent == _theater);
  }

  void _removeChild(_RenderDeferredLayoutBox child) {
    // This call is allowed even when this location is disposed.
    _removeFromChildModel(child);
    _theater._removeDeferredChild(child);
    assert(child.parent == null);
  }

  void _moveChild(_RenderDeferredLayoutBox child, _OverlayEntryLocation fromLocation) {
    assert(fromLocation != this);
    assert(_debugIsLocationValid());
    final _RenderTheater fromTheater = fromLocation._theater;
    final _OverlayEntryWidgetState fromModel = fromLocation._childModel;

    if (fromTheater != _theater) {
      fromTheater._removeDeferredChild(child);
      _theater._addDeferredChild(child);
    }

    if (fromModel != _childModel || fromLocation._zOrderIndex != _zOrderIndex) {
      fromLocation._removeFromChildModel(child);
      _addToChildModel(child);
    }
  }

  void _activate(_RenderDeferredLayoutBox child) {
    // This call is allowed even when this location is invalidated.
    // See _OverlayPortalElement.activate.
    assert(_overlayChildRenderBox == null, '$_overlayChildRenderBox');
    _theater._addDeferredChild(child);
    _overlayChildRenderBox = child;
  }

  void _deactivate(_RenderDeferredLayoutBox child) {
    // This call is allowed even when this location is invalidated.
    _theater._removeDeferredChild(child);
    _overlayChildRenderBox = null;
  }

  // Throws a StateError if this location is already invalidated and shouldn't
  // be used as an OverlayPortal slot. Must be used in asserts.
  //
  // Generally, `assert(_debugIsLocationValid())` should be used to prevent
  // invalid accesses to an invalid `_OverlayEntryLocation` object. Exceptions
  // to this rule are _removeChild, _deactivate, which will be called when the
  // OverlayPortal is being removed from the widget tree and may use the
  // location information to perform cleanup tasks.
  //
  // Another exception is the _activate method which is called by
  // _OverlayPortalElement.activate. See the comment in _OverlayPortalElement.activate.
  bool _debugIsLocationValid() {
    if (_debugMarkLocationInvalidStackTrace == null) {
      return true;
    }
    throw StateError(
      '$this is already disposed. Stack trace: $_debugMarkLocationInvalidStackTrace',
    );
  }

  // The StackTrace of the first _debugMarkLocationInvalid call. It's only for
  // debugging purposes and the StackTrace will only be captured in debug builds.
  //
  // The effect of this method is not reversible. Once marked invalid, this
  // object can't be marked as valid again.
  StackTrace? _debugMarkLocationInvalidStackTrace;
  @mustCallSuper
  void _debugMarkLocationInvalid() {
    assert(_debugIsLocationValid());
    assert(() {
      _debugMarkLocationInvalidStackTrace = StackTrace.current;
      return true;
    }());
  }

  @override
  String toString() =>
      '${objectRuntimeType(this, '_OverlayEntryLocation')}[${shortHash(this)}] ${_debugMarkLocationInvalidStackTrace != null ? "(INVALID)" : ""}';
}

class _RenderTheaterMarker extends InheritedWidget {
  const _RenderTheaterMarker({
    required this.theater,
    required this.overlayEntryWidgetState,
    required super.child,
  });

  final _RenderTheater theater;
  final _OverlayEntryWidgetState overlayEntryWidgetState;

  @override
  bool updateShouldNotify(_RenderTheaterMarker oldWidget) {
    return oldWidget.theater != theater ||
        oldWidget.overlayEntryWidgetState != overlayEntryWidgetState;
  }

  static _RenderTheaterMarker of(BuildContext context, {bool targetRootOverlay = false}) {
    final _RenderTheaterMarker? marker;
    if (targetRootOverlay) {
      final InheritedElement? ancestor = _rootRenderTheaterMarkerOf(
        context.getElementForInheritedWidgetOfExactType<_RenderTheaterMarker>(),
      );
      assert(ancestor == null || ancestor.widget is _RenderTheaterMarker);
      marker =
          ancestor != null
              ? context.dependOnInheritedElement(ancestor) as _RenderTheaterMarker?
              : null;
    } else {
      marker = context.dependOnInheritedWidgetOfExactType<_RenderTheaterMarker>();
    }
    if (marker != null) {
      return marker;
    }
    throw FlutterError.fromParts(<DiagnosticsNode>[
      ErrorSummary('No Overlay widget found.'),
      ErrorDescription(
        '${context.widget.runtimeType} widgets require an Overlay widget ancestor.\n'
        'An overlay lets widgets float on top of other widget children.',
      ),
      ErrorHint(
        'To introduce an Overlay widget, you can either directly '
        'include one, or use a widget that contains an Overlay itself, '
        'such as a Navigator, WidgetApp, MaterialApp, or CupertinoApp.',
      ),
      ...context.describeMissingAncestor(expectedAncestorType: Overlay),
    ]);
  }

  static InheritedElement? _rootRenderTheaterMarkerOf(InheritedElement? theaterMarkerElement) {
    assert(theaterMarkerElement == null || theaterMarkerElement.widget is _RenderTheaterMarker);
    if (theaterMarkerElement == null) {
      return null;
    }
    InheritedElement? ancestor;
    theaterMarkerElement.visitAncestorElements((Element element) {
      ancestor = element.getElementForInheritedWidgetOfExactType<_RenderTheaterMarker>();
      return false;
    });
    return ancestor == null ? theaterMarkerElement : _rootRenderTheaterMarkerOf(ancestor);
  }
}

class _OverlayPortal extends RenderObjectWidget {
  /// Creates a widget that renders the given [overlayChild] in the [Overlay]
  /// specified by `overlayLocation`.
  ///
  /// The `overlayLocation` parameter must not be null when [overlayChild] is not
  /// null.
  _OverlayPortal({required this.overlayLocation, required this.overlayChild, required this.child})
    : assert(overlayChild == null || overlayLocation != null),
      assert(overlayLocation == null || overlayLocation._debugIsLocationValid());

  final Widget? overlayChild;

  /// A widget below this widget in the tree.
  final Widget? child;

  final _OverlayEntryLocation? overlayLocation;

  @override
  RenderObjectElement createElement() => _OverlayPortalElement(this);

  @override
  RenderObject createRenderObject(BuildContext context) => _RenderLayoutSurrogateProxyBox();
}

class _OverlayPortalElement extends RenderObjectElement {
  _OverlayPortalElement(_OverlayPortal super.widget);

  @override
  _RenderLayoutSurrogateProxyBox get renderObject =>
      super.renderObject as _RenderLayoutSurrogateProxyBox;

  Element? _overlayChild;
  Element? _child;

  @override
  void mount(Element? parent, Object? newSlot) {
    super.mount(parent, newSlot);
    final _OverlayPortal widget = this.widget as _OverlayPortal;
    _child = updateChild(_child, widget.child, null);
    _overlayChild = updateChild(_overlayChild, widget.overlayChild, widget.overlayLocation);
  }

  @override
  void update(_OverlayPortal newWidget) {
    super.update(newWidget);
    _child = updateChild(_child, newWidget.child, null);
    _overlayChild = updateChild(_overlayChild, newWidget.overlayChild, newWidget.overlayLocation);
  }

  @override
  void forgetChild(Element child) {
    // The _overlayChild Element does not have a key because the _DeferredLayout
    // widget does not take a Key, so only the regular _child can be taken
    // during global key reparenting.
    assert(child == _child);
    _child = null;
    super.forgetChild(child);
  }

  @override
  void visitChildren(ElementVisitor visitor) {
    final Element? child = _child;
    final Element? overlayChild = _overlayChild;
    if (child != null) {
      visitor(child);
    }
    if (overlayChild != null) {
      visitor(overlayChild);
    }
  }

  @override
  void activate() {
    super.activate();
    final _RenderDeferredLayoutBox? box = _overlayChild?.renderObject as _RenderDeferredLayoutBox?;
    if (box != null) {
      assert(!box.attached);
      assert(renderObject._deferredLayoutChild == box);
      // updateChild has not been called at this point so the RenderTheater in
      // the overlay location could be detached. Adding children to a detached
      // RenderObject is still allowed however this isn't the most efficient.
      (_overlayChild!.slot! as _OverlayEntryLocation)._activate(box);
    }
  }

  @override
  void deactivate() {
    // Instead of just detaching the render objects, removing them from the
    // render subtree entirely. This is a workaround for the
    // !renderObject.attached assert in the `super.deactivate()` method.
    final _RenderDeferredLayoutBox? box = _overlayChild?.renderObject as _RenderDeferredLayoutBox?;
    if (box != null) {
      (_overlayChild!.slot! as _OverlayEntryLocation)._deactivate(box);
    }
    super.deactivate();
  }

  @override
  void insertRenderObjectChild(RenderBox child, _OverlayEntryLocation? slot) {
    assert(child.parent == null, "$child's parent is not null: ${child.parent}");
    if (slot != null) {
      renderObject._deferredLayoutChild = child as _RenderDeferredLayoutBox;
      slot._addChild(child);
      renderObject.markNeedsSemanticsUpdate();
    } else {
      renderObject.child = child;
    }
  }

  // The [_DeferredLayout] widget does not have a key so there will be no
  // reparenting between _overlayChild and _child, thus the non-null-typed slots.
  @override
  void moveRenderObjectChild(
    _RenderDeferredLayoutBox child,
    _OverlayEntryLocation oldSlot,
    _OverlayEntryLocation newSlot,
  ) {
    assert(newSlot._debugIsLocationValid());
    newSlot._moveChild(child, oldSlot);
    renderObject.markNeedsSemanticsUpdate();
  }

  @override
  void removeRenderObjectChild(RenderBox child, _OverlayEntryLocation? slot) {
    if (slot == null) {
      renderObject.child = null;
      return;
    }
    assert(renderObject._deferredLayoutChild == child);
    slot._removeChild(child as _RenderDeferredLayoutBox);
    renderObject._deferredLayoutChild = null;
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties.add(DiagnosticsProperty<Element>('child', _child, defaultValue: null));
    properties.add(DiagnosticsProperty<Element>('overlayChild', _overlayChild, defaultValue: null));
    properties.add(
      DiagnosticsProperty<Object>('overlayLocation', _overlayChild?.slot, defaultValue: null),
    );
  }
}

class _DeferredLayout extends SingleChildRenderObjectWidget {
  const _DeferredLayout({
    // This widget must not be given a key: we currently do not support
    // reparenting between the overlayChild and child.
    required Widget child,
  }) : super(child: child);

  _RenderLayoutSurrogateProxyBox getLayoutParent(BuildContext context) {
    return context.findAncestorRenderObjectOfType<_RenderLayoutSurrogateProxyBox>()!;
  }

  @override
  _RenderDeferredLayoutBox createRenderObject(BuildContext context) {
    final _RenderLayoutSurrogateProxyBox parent = getLayoutParent(context);
    final _RenderDeferredLayoutBox renderObject = _RenderDeferredLayoutBox(parent);
    parent._deferredLayoutChild = renderObject;
    return renderObject;
  }

  @override
  void updateRenderObject(BuildContext context, _RenderDeferredLayoutBox renderObject) {
    assert(renderObject._layoutSurrogate == getLayoutParent(context));
    assert(getLayoutParent(context)._deferredLayoutChild == renderObject);
  }
}

// A `RenderProxyBox` that defers its layout until its `_layoutSurrogate` (which
// is not necessarily an ancestor of this RenderBox, but shares at least one
// `_RenderTheater` ancestor with this RenderBox) is laid out.
//
// This `RenderObject` must be a child of a `_RenderTheater`. It guarantees that:
//
// 1. It's a relayout boundary, so calling `markNeedsLayout` on it never dirties
//    its `_RenderTheater`.
//
// 2. Its `layout` implementation is overridden such that `performLayout` does
//    not do anything when its called from `layout`, preventing the parent
//    `_RenderTheater` from laying out this subtree prematurely (but this
//    `RenderObject` may still be resized). Instead, `markNeedsLayout` will be
//    called from within `layout` to schedule a layout update for this relayout
//    boundary when needed.
//
// 3. When invoked from `PipelineOwner.flushLayout`, or
//    `_layoutSurrogate.performLayout`, this `RenderObject` behaves like an
//    `Overlay` that has only one entry.
final class _RenderDeferredLayoutBox extends RenderProxyBox
    with _RenderTheaterMixin, LinkedListEntry<_RenderDeferredLayoutBox> {
  _RenderDeferredLayoutBox(this._layoutSurrogate);

  StackParentData get stackParentData => parentData! as StackParentData;
  final _RenderLayoutSurrogateProxyBox _layoutSurrogate;

  @override
  Iterable<RenderBox> _childrenInPaintOrder() {
    final RenderBox? child = this.child;
    return child == null
        ? const Iterable<RenderBox>.empty()
        : Iterable<RenderBox>.generate(1, (int i) => child);
  }

  @override
  Iterable<RenderBox> _childrenInHitTestOrder() => _childrenInPaintOrder();

  @override
  _RenderTheater get theater {
    final RenderObject? parent = this.parent;
    return parent is _RenderTheater
        ? parent
        : throw FlutterError('$parent of $this is not a _RenderTheater');
  }

  @override
  void redepthChildren() {
    _layoutSurrogate.redepthChild(this);
    super.redepthChildren();
  }

  @override
  bool get sizedByParent => true;

  bool _needsLayout = true;
  @override
  void markNeedsLayout() {
    _needsLayout = true;
    super.markNeedsLayout();
  }

  @override
  RenderObject? get semanticsParent => _layoutSurrogate;

  @override
  double? computeDryBaseline(BoxConstraints constraints, TextBaseline baseline) {
    final RenderBox? child = this.child;
    if (child == null) {
      return null;
    }
    return _RenderTheaterMixin.baselineForChild(
      child,
      constraints.biggest,
      constraints,
      theater._resolvedAlignment,
      baseline,
    );
  }

  @override
  RenderObject? get debugLayoutParent => _layoutSurrogate;

  void layoutByLayoutSurrogate() {
    assert(!_theaterDoingThisLayout);
    final _RenderTheater? theater = parent as _RenderTheater?;
    if (theater == null || !attached) {
      assert(false, '$this is not attached to parent');
      return;
    }
    if (theater._layingOutSizeDeterminingChild) {
      theater.invokeLayoutCallback((BoxConstraints constraints) {
        markNeedsLayout();
      });
    } else {
      final BoxConstraints theaterConstraints = theater.constraints;
      final Size boxSize =
          theaterConstraints.biggest.isFinite
              ? theaterConstraints.biggest
              // Accessing the theater's size is only unsafe if it is laying out the
              // size-determining child.
              : theater.size;
      super.layout(BoxConstraints.tight(boxSize));
    }
  }

  bool _theaterDoingThisLayout = false;
  @override
  void layout(Constraints constraints, {bool parentUsesSize = false}) {
    assert(_needsLayout == debugNeedsLayout);
    // Only _RenderTheater calls this implementation.
    assert(parent != null);
    final bool scheduleDeferredLayout = _needsLayout || this.constraints != constraints;
    assert(!_theaterDoingThisLayout);
    _theaterDoingThisLayout = true;
    super.layout(constraints, parentUsesSize: parentUsesSize);
    assert(_theaterDoingThisLayout);
    _theaterDoingThisLayout = false;
    _needsLayout = false;
    assert(!debugNeedsLayout);
    if (scheduleDeferredLayout) {
      final _RenderTheater parent = this.parent! as _RenderTheater;
      // Invoking markNeedsLayout as a layout callback allows this node to be
      // merged back to the `PipelineOwner`'s dirty list in the right order, if
      // it's not already dirty. Otherwise this may cause some dirty descendants
      // to performLayout a second time.
      parent.invokeLayoutCallback((BoxConstraints constraints) {
        markNeedsLayout();
      });
    }
  }

  @override
  void performResize() {
    size = constraints.biggest;
  }

  bool _debugMutationsLocked = false;
  @override
  void performLayout() {
    assert(!_debugMutationsLocked);
    if (_theaterDoingThisLayout) {
      _needsLayout = false;
      return;
    }
    assert(() {
      _debugMutationsLocked = true;
      return true;
    }());
    // This method is directly being invoked from `PipelineOwner.flushLayout`,
    // or from `_layoutSurrogate`'s performLayout.
    assert(parent != null);
    final RenderBox? child = this.child;
    if (child == null) {
      _needsLayout = false;
      return;
    }
    assert(constraints.isTight);
    layoutChild(child, constraints);
    assert(() {
      _debugMutationsLocked = false;
      return true;
    }());
    _needsLayout = false;
  }

  @override
  void applyPaintTransform(RenderBox child, Matrix4 transform) {
    final BoxParentData childParentData = child.parentData! as BoxParentData;
    final Offset offset = childParentData.offset;
    transform.translate(offset.dx, offset.dy);
  }
}

// A RenderProxyBox that makes sure its `deferredLayoutChild` has a greater
// depth than itself.
class _RenderLayoutSurrogateProxyBox extends RenderProxyBox {
  _RenderDeferredLayoutBox? _deferredLayoutChild;

  @override
  void redepthChildren() {
    super.redepthChildren();
    final _RenderDeferredLayoutBox? child = _deferredLayoutChild;
    // If child is not attached, this method will be invoked by child's real
    // parent when it's attached.
    if (child != null && child.attached) {
      assert(child.attached);
      redepthChild(child);
    }
  }

  @override
  void performLayout() {
    super.performLayout();
    // Try to layout `_deferredLayoutChild` here now that its configuration
    // and constraints are up-to-date. Additionally, during the very first
    // layout, this makes sure that _deferredLayoutChild is reachable via tree
    // walk.
    _deferredLayoutChild?.layoutByLayoutSurrogate();
  }

  @override
  void visitChildrenForSemantics(RenderObjectVisitor visitor) {
    super.visitChildrenForSemantics(visitor);
    final _RenderDeferredLayoutBox? deferredChild = _deferredLayoutChild;
    if (deferredChild != null) {
      visitor(deferredChild);
    }
  }
}


Instructions for the chapter (Generate content in English unless specified otherwise):
- Start with a clear heading (e.g., `# Chapter 1: Overlay
`). Use the provided concept name.

- If this is not the first chapter, begin with a brief transition from the previous chapter, referencing it with a proper Markdown link using its name.

- Begin with a high-level motivation explaining what problem this abstraction solves. Start with a central use case as a concrete example. The whole chapter should guide the reader to understand how to solve this use case. Make it very minimal and friendly to beginners.

- If the abstraction is complex, break it down into key concepts. Explain each concept one-by-one in a very beginner-friendly way.

- Explain how to use this abstraction to solve the use case. Give example inputs and outputs for code snippets (if the output isn't values, describe at a high level what will happen).

- Each code block should be BELOW 10 lines! If longer code blocks are needed, break them down into smaller pieces and walk through them one-by-one. Aggresively simplify the code to make it minimal. Use comments to skip non-important implementation details. Each code block should have a beginner friendly explanation right after it.

- Describe the internal implementation to help understand what's under the hood. First provide a non-code or code-light walkthrough on what happens step-by-step when the abstraction is called. It's recommended to use a simple sequenceDiagram with a dummy example - keep it minimal with at most 5 participants to ensure clarity. If participant name has space, use: `participant QP as Query Processing`. .

- Then dive deeper into code for the internal implementation with references to files. Provide example code blocks, but make them similarly simple and beginner-friendly. Explain.

- IMPORTANT: When you need to refer to other core abstractions covered in other chapters, ALWAYS use proper Markdown links like this: [Chapter Title](filename.md). Use the Complete Tutorial Structure above to find the correct filename and the chapter title. Translate the surrounding text.

- Use mermaid diagrams to illustrate complex concepts (```mermaid``` format). .

- Heavily use analogies and examples throughout to help beginners understand.

- End the chapter with a brief conclusion that summarizes what was learned and provides a transition to the next chapter. If there is a next chapter, use a proper Markdown link: [Next Chapter Title](next_chapter_filename).

- Ensure the tone is welcoming and easy for a newcomer to understand.

- Output *only* the Markdown content for this chapter.

Now, directly provide a super beginner-friendly Markdown output (DON'T need ```markdown``` tags):

2025-05-22 23:56:55,196 - INFO - RESPONSE: # Chapter 1: Overlay

Welcome to the first chapter of our tutorial on Flutter's `overlay.dart`! In this chapter, we'll introduce you to the fundamental concept of an `Overlay`.

Have you ever seen temporary popups, like dialogs, tooltips that appear over your regular screen content, no matter what's currently displayed? How does Flutter manage to show these elements *on top* of everything else? That's where the `Overlay` comes in!

Think of your Flutter app's user interface as a stack of layers, like transparencies on an overhead projector. Your main screen content is on the bottom layer. When you want to show something *over* that content, without affecting how the main content is arranged, you place it on a new, transparent layer on top. The `Overlay` widget is like the frame of this overhead projector that holds the stack of transparent sheets.

The `Overlay` itself is a widget that sits high up in your app's widget tree, often provided automatically by powerful widgets like `MaterialApp` or `WidgetsApp`. It manages a list of "sheets," called [OverlayEntry](03_overlayentry_.md)s. Each [OverlayEntry](03_overlayentry_.md) can hold a widget, and these widgets will be painted *above* the `Overlay`'s regular content.

So, the core idea is:

**An `Overlay` is a stack of entry points where you can place widgets that should appear on top of your primary UI.**

### Our Goal: Displaying a Simple Overlay

To understand the `Overlay` better, let's imagine we want to display a simple message box that floats in the center of the screen when a button is pressed. This message box should appear above all other content on the screen.

Using the `Overlay` and its related components, we can achieve this. Here's the high-level plan:

1.  Find the nearest `Overlay`.
2.  Create an [OverlayEntry](03_overlayentry_.md) containing our message box widget.
3.  Insert this [OverlayEntry](03_overlayentry_.md) into the `Overlay`'s stack.
4.  When we want to hide the message box, we'll remove the [OverlayEntry](03_overlayentry_.md) from the `Overlay`.

### Finding the Overlay

The `Overlay` is usually introduced by the main app widgets like `MaterialApp`. To interact with this `Overlay`, we need to get its state, which is an [OverlayState](02_overlaystate_.md). We can do this using the `Overlay.of` method, passing the current `BuildContext`.

```dart
// Inside a widget's build method or a function called from it:
OverlayState? overlayState = Overlay.of(context);
```

This code snippet uses `Overlay.of(context)` to look up the closest `OverlayState` in the widget tree above the current `context`. If an `Overlay` is found, it gives us its state (the [OverlayState](02_overlaystate_.md) object) that we can use to manage our overlay entries. If no `Overlay` is found (which is unlikely in a typical `MaterialApp`), it would cause an error in debug mode.

### What's Inside the Overlay?

While we don't see it directly in the minimal code we write, the `Overlay` widget itself contains some interesting pieces to manage its entries.

Let's look at a relevant snippet from the `overlay.dart` file:

```dart
class Overlay extends StatefulWidget {
  // ... other properties and methods

  @override
  OverlayState createState() => OverlayState();
}
```

This shows that the `Overlay` widget creates an [OverlayState](02_overlaystate_.md). This is the object we obtained using `Overlay.of`. The [OverlayState](02_overlaystate_.md) is where the real work of managing the list of [OverlayEntry](03_overlayentry_.md) objects happens.

Further down in the code, we see how the `OverlayState` builds its UI:

```dart
class OverlayState extends State<Overlay> with TickerProviderStateMixin {
  final List<OverlayEntry> _entries = <OverlayEntry>[];

  // ... methods for inserting and removing entries

  @protected
  @override
  Widget build(BuildContext context) {
    // ... logic to determine visible entries
    final List<_OverlayEntryWidget> children = <_OverlayEntryWidget>[];
    // ... populate children based on _entries
    return _Theater(
      // ... properties like skipCount, clipBehavior
      children: children.reversed.toList(growable: false),
    );
  }

  // ... other methods
}
```

This snippet reveals a crucial part: the `OverlayState` holds a list of `_entries` (our [OverlayEntry](03_overlayentry_.md) objects). In its `build` method, it creates a list of `_OverlayEntryWidget`s corresponding to the active entries. These widgets are then passed to a special widget called `_Theater`.

The `_Theater` widget is essentially a specialized `Stack`. It's responsible for laying out and painting the widgets from the [OverlayEntry](03_overlayentry_.md)s on top of each other, similar to how layers are stacked in a `Stack`.

Here's a simplified illustration of the key participants and their relationships in displaying an overlay entry:

```mermaid
sequenceDiagram
    participant YourWidget
    participant OverlayDotOf as Overlay.of(context)
    participant OverlayState
    participant OverlayEntry
    participant _Theater

    YourWidget->>OverlayDotOf: Ask for OverlayState
    OverlayDotOf-->>OverlayState: Return the found OverlayState
    YourWidget->>OverlayState: Create and insert OverlayEntry
    OverlayState->>OverlayEntry: Add entry to internal list
    OverlayState->>OverlayState: Schedule rebuild
    OverlayState->>_Theater: Build _Theater with entries as children
    _Theater->>OverlayEntry: Ask entry to build its widget
    OverlayEntry->>_Theater: Return built widget
    _Theater->>_Theater: Layout and paint entry's widget on top

```

This diagram shows that your widget interacts with the global `Overlay.of` to get the [OverlayState](02_overlaystate_.md). You then use the [OverlayState](02_overlaystate_.md) to manage your [OverlayEntry](03_overlayentry_.md). The [OverlayState](02_overlaystate_.md) internally uses `_Theater` to visually stack the widgets provided by the [OverlayEntry](03_overlayentry_.md)s.

### Conclusion

In this chapter, we introduced the concept of the `Overlay` in Flutter. We learned that it acts as a container for widgets that should appear on top of the regular UI, managing them as a stack of [OverlayEntry](03_overlayentry_.md) objects. We saw how to find the `OverlayState` using `Overlay.of` and got a peek into the internal structure involving `_Theater`.

In the next chapter, we will delve deeper into the [OverlayState](02_overlaystate_.md) and explore how to use its methods to actually insert and remove [OverlayEntry](03_overlayentry_.md) objects, allowing us to finally display our floating message box.

[OverlayState](02_overlaystate_.md)
2025-05-22 23:56:55,202 - INFO - PROMPT: 
Write a very beginner-friendly tutorial chapter (in Markdown format) for the project `flutter (overlay.dart)` about the concept: "OverlayState
". This is Chapter 2.

Concept Details:
- Name: OverlayState

- Description:
This is the manager for an Overlay. It keeps track of all the OverlayEntry sheets currently in the stack. You use methods like `insert` and `remove` on the `OverlayState` to add or take out OverlayEntry sheets, changing what's visible on the Overlay.


Complete Tutorial Structure:
1. [Overlay
](01_overlay_.md)
2. [OverlayState
](02_overlaystate_.md)
3. [OverlayEntry
](03_overlayentry_.md)
4. [OverlayPortal
](04_overlayportal_.md)
5. [OverlayPortalController
](05_overlayportalcontroller_.md)
6. [_Theater
](06__theater_.md)
7. [_RenderDeferredLayoutBox
](07__renderdeferredlayoutbox_.md)
8. [_OverlayEntryLocation
](08__overlayentrylocation_.md)

Context from previous chapters:
# Chapter 1: Overlay

Welcome to the first chapter of our tutorial on Flutter's `overlay.dart`! In this chapter, we'll introduce you to the fundamental concept of an `Overlay`.

Have you ever seen temporary popups, like dialogs, tooltips that appear over your regular screen content, no matter what's currently displayed? How does Flutter manage to show these elements *on top* of everything else? That's where the `Overlay` comes in!

Think of your Flutter app's user interface as a stack of layers, like transparencies on an overhead projector. Your main screen content is on the bottom layer. When you want to show something *over* that content, without affecting how the main content is arranged, you place it on a new, transparent layer on top. The `Overlay` widget is like the frame of this overhead projector that holds the stack of transparent sheets.

The `Overlay` itself is a widget that sits high up in your app's widget tree, often provided automatically by powerful widgets like `MaterialApp` or `WidgetsApp`. It manages a list of "sheets," called [OverlayEntry](03_overlayentry_.md)s. Each [OverlayEntry](03_overlayentry_.md) can hold a widget, and these widgets will be painted *above* the `Overlay`'s regular content.

So, the core idea is:

**An `Overlay` is a stack of entry points where you can place widgets that should appear on top of your primary UI.**

### Our Goal: Displaying a Simple Overlay

To understand the `Overlay` better, let's imagine we want to display a simple message box that floats in the center of the screen when a button is pressed. This message box should appear above all other content on the screen.

Using the `Overlay` and its related components, we can achieve this. Here's the high-level plan:

1.  Find the nearest `Overlay`.
2.  Create an [OverlayEntry](03_overlayentry_.md) containing our message box widget.
3.  Insert this [OverlayEntry](03_overlayentry_.md) into the `Overlay`'s stack.
4.  When we want to hide the message box, we'll remove the [OverlayEntry](03_overlayentry_.md) from the `Overlay`.

### Finding the Overlay

The `Overlay` is usually introduced by the main app widgets like `MaterialApp`. To interact with this `Overlay`, we need to get its state, which is an [OverlayState](02_overlaystate_.md). We can do this using the `Overlay.of` method, passing the current `BuildContext`.

```dart
// Inside a widget's build method or a function called from it:
OverlayState? overlayState = Overlay.of(context);
```

This code snippet uses `Overlay.of(context)` to look up the closest `OverlayState` in the widget tree above the current `context`. If an `Overlay` is found, it gives us its state (the [OverlayState](02_overlaystate_.md) object) that we can use to manage our overlay entries. If no `Overlay` is found (which is unlikely in a typical `MaterialApp`), it would cause an error in debug mode.

### What's Inside the Overlay?

While we don't see it directly in the minimal code we write, the `Overlay` widget itself contains some interesting pieces to manage its entries.

Let's look at a relevant snippet from the `overlay.dart` file:

```dart
class Overlay extends StatefulWidget {
  // ... other properties and methods

  @override
  OverlayState createState() => OverlayState();
}
```

This shows that the `Overlay` widget creates an [OverlayState](02_overlaystate_.md). This is the object we obtained using `Overlay.of`. The [OverlayState](02_overlaystate_.md) is where the real work of managing the list of [OverlayEntry](03_overlayentry_.md) objects happens.

Further down in the code, we see how the `OverlayState` builds its UI:

```dart
class OverlayState extends State<Overlay> with TickerProviderStateMixin {
  final List<OverlayEntry> _entries = <OverlayEntry>[];

  // ... methods for inserting and removing entries

  @protected
  @override
  Widget build(BuildContext context) {
    // ... logic to determine visible entries
    final List<_OverlayEntryWidget> children = <_OverlayEntryWidget>[];
    // ... populate children based on _entries
    return _Theater(
      // ... properties like skipCount, clipBehavior
      children: children.reversed.toList(growable: false),
    );
  }

  // ... other methods
}
```

This snippet reveals a crucial part: the `OverlayState` holds a list of `_entries` (our [OverlayEntry](03_overlayentry_.md) objects). In its `build` method, it creates a list of `_OverlayEntryWidget`s corresponding to the active entries. These widgets are then passed to a special widget called `_Theater`.

The `_Theater` widget is essentially a specialized `Stack`. It's responsible for laying out and painting the widgets from the [OverlayEntry](03_overlayentry_.md)s on top of each other, similar to how layers are stacked in a `Stack`.

Here's a simplified illustration of the key participants and their relationships in displaying an overlay entry:

```mermaid
sequenceDiagram
    participant YourWidget
    participant OverlayDotOf as Overlay.of(context)
    participant OverlayState
    participant OverlayEntry
    participant _Theater

    YourWidget->>OverlayDotOf: Ask for OverlayState
    OverlayDotOf-->>OverlayState: Return the found OverlayState
    YourWidget->>OverlayState: Create and insert OverlayEntry
    OverlayState->>OverlayEntry: Add entry to internal list
    OverlayState->>OverlayState: Schedule rebuild
    OverlayState->>_Theater: Build _Theater with entries as children
    _Theater->>OverlayEntry: Ask entry to build its widget
    OverlayEntry->>_Theater: Return built widget
    _Theater->>_Theater: Layout and paint entry's widget on top

```

This diagram shows that your widget interacts with the global `Overlay.of` to get the [OverlayState](02_overlaystate_.md). You then use the [OverlayState](02_overlaystate_.md) to manage your [OverlayEntry](03_overlayentry_.md). The [OverlayState](02_overlaystate_.md) internally uses `_Theater` to visually stack the widgets provided by the [OverlayEntry](03_overlayentry_.md)s.

### Conclusion

In this chapter, we introduced the concept of the `Overlay` in Flutter. We learned that it acts as a container for widgets that should appear on top of the regular UI, managing them as a stack of [OverlayEntry](03_overlayentry_.md) objects. We saw how to find the `OverlayState` using `Overlay.of` and got a peek into the internal structure involving `_Theater`.

In the next chapter, we will delve deeper into the [OverlayState](02_overlaystate_.md) and explore how to use its methods to actually insert and remove [OverlayEntry](03_overlayentry_.md) objects, allowing us to finally display our floating message box.

[OverlayState](02_overlaystate_.md)

Relevant Code Snippets (Code itself remains unchanged):
--- File: packages/flutter/lib/src/widgets/overlay.dart ---
// Copyright 2014 The Flutter Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

/// @docImport 'package:flutter/cupertino.dart';
/// @docImport 'package:flutter/material.dart';
///
/// @docImport 'app.dart';
/// @docImport 'drag_target.dart';
/// @docImport 'implicit_animations.dart';
/// @docImport 'media_query.dart';
/// @docImport 'navigator.dart';
/// @docImport 'routes.dart';
/// @docImport 'scroll_view.dart';
/// @docImport 'sliver.dart';
/// @docImport 'text.dart';
library;

import 'dart:collection';

import 'package:flutter/foundation.dart';
import 'package:flutter/rendering.dart';
import 'package:flutter/scheduler.dart';

import 'basic.dart';
import 'framework.dart';
import 'lookup_boundary.dart';
import 'ticker_provider.dart';

const String _flutterWidgetsLibrary = 'package:flutter/widgets.dart';

// Examples can assume:
// late BuildContext context;

// * OverlayEntry Implementation

/// A place in an [Overlay] that can contain a widget.
///
/// Overlay entries are inserted into an [Overlay] using the
/// [OverlayState.insert] or [OverlayState.insertAll] functions. To find the
/// closest enclosing overlay for a given [BuildContext], use the [Overlay.of]
/// function.
///
/// An overlay entry can be in at most one overlay at a time. To remove an entry
/// from its overlay, call the [remove] function on the overlay entry.
///
/// Because an [Overlay] uses a [Stack] layout, overlay entries can use
/// [Positioned] and [AnimatedPositioned] to position themselves within the
/// overlay.
///
/// For example, [Draggable] uses an [OverlayEntry] to show the drag avatar that
/// follows the user's finger across the screen after the drag begins. Using the
/// overlay to display the drag avatar lets the avatar float over the other
/// widgets in the app. As the user's finger moves, draggable calls
/// [markNeedsBuild] on the overlay entry to cause it to rebuild. In its build,
/// the entry includes a [Positioned] with its top and left property set to
/// position the drag avatar near the user's finger. When the drag is over,
/// [Draggable] removes the entry from the overlay to remove the drag avatar
/// from view.
///
/// By default, if there is an entirely [opaque] entry over this one, then this
/// one will not be included in the widget tree (in particular, stateful widgets
/// within the overlay entry will not be instantiated). To ensure that your
/// overlay entry is still built even if it is not visible, set [maintainState]
/// to true. This is more expensive, so should be done with care. In particular,
/// if widgets in an overlay entry with [maintainState] set to true repeatedly
/// call [State.setState], the user's battery will be drained unnecessarily.
///
/// [OverlayEntry] is a [Listenable] that notifies when the widget built by
/// [builder] is mounted or unmounted, whose exact state can be queried by
/// [mounted]. After the owner of the [OverlayEntry] calls [remove] and then
/// [dispose], the widget may not be immediately removed from the widget tree.
/// As a result listeners of the [OverlayEntry] can get notified for one last
/// time after the [dispose] call, when the widget is eventually unmounted.
///
/// {@macro flutter.widgets.overlayPortalVsOverlayEntry}
///
/// See also:
///
///  * [OverlayPortal], an alternative API for inserting widgets into an
///    [Overlay] using a builder callback.
///  * [Overlay], a stack of entries that can be managed independently.
///  * [OverlayState], the current state of an Overlay.
///  * [WidgetsApp], a convenience widget that wraps a number of widgets that
///    are commonly required for an application.
///  * [MaterialApp], a convenience widget that wraps a number of widgets that
///    are commonly required for Material Design applications.
class OverlayEntry implements Listenable {
  /// Creates an overlay entry.
  ///
  /// To insert the entry into an [Overlay], first find the overlay using
  /// [Overlay.of] and then call [OverlayState.insert]. To remove the entry,
  /// call [remove] on the overlay entry itself.
  OverlayEntry({
    required this.builder,
    bool opaque = false,
    bool maintainState = false,
    this.canSizeOverlay = false,
  }) : _opaque = opaque,
       _maintainState = maintainState {
    if (kFlutterMemoryAllocationsEnabled) {
      _maybeDispatchObjectCreation();
    }
  }

  /// This entry will include the widget built by this builder in the overlay at
  /// the entry's position.
  ///
  /// To cause this builder to be called again, call [markNeedsBuild] on this
  /// overlay entry.
  final WidgetBuilder builder;

  /// Whether this entry occludes the entire overlay.
  ///
  /// If an entry claims to be opaque, then, for efficiency, the overlay will
  /// skip building entries below that entry unless they have [maintainState]
  /// set.
  bool get opaque => _opaque;
  bool _opaque;
  set opaque(bool value) {
    assert(!_disposedByOwner);
    if (_opaque == value) {
      return;
    }
    _opaque = value;
    _overlay?._didChangeEntryOpacity();
  }

  /// Whether this entry must be included in the tree even if there is a fully
  /// [opaque] entry above it.
  ///
  /// By default, if there is an entirely [opaque] entry over this one, then this
  /// one will not be included in the widget tree (in particular, stateful widgets
  /// within the overlay entry will not be instantiated). To ensure that your
  /// overlay entry is still built even if it is not visible, set [maintainState]
  /// to true. This is more expensive, so should be done with care. In particular,
  /// if widgets in an overlay entry with [maintainState] set to true repeatedly
  /// call [State.setState], the user's battery will be drained unnecessarily.
  ///
  /// This is used by the [Navigator] and [Route] objects to ensure that routes
  /// are kept around even when in the background, so that [Future]s promised
  /// from subsequent routes will be handled properly when they complete.
  bool get maintainState => _maintainState;
  bool _maintainState;
  set maintainState(bool value) {
    assert(!_disposedByOwner);
    if (_maintainState == value) {
      return;
    }
    _maintainState = value;
    assert(_overlay != null);
    _overlay!._didChangeEntryOpacity();
  }

  /// Whether the content of this [OverlayEntry] can be used to size the
  /// [Overlay].
  ///
  /// In most situations the overlay sizes itself based on its incoming
  /// constraints to be as large as possible. However, if that would result in
  /// an infinite size, it has to rely on one of its children to size itself. In
  /// this situation, the overlay will consult the topmost non-[Positioned]
  /// overlay entry that has this property set to true, lay it out with the
  /// incoming [BoxConstraints] of the overlay, and force all other
  /// non-[Positioned] overlay entries to have the same size. The [Positioned]
  /// entries are laid out as usual based on the calculated size of the overlay.
  ///
  /// Overlay entries that set this to true must be able to handle unconstrained
  /// [BoxConstraints].
  ///
  /// Setting this to true has no effect if the overlay entry uses a [Positioned]
  /// widget to position itself in the overlay.
  final bool canSizeOverlay;

  /// Whether the [OverlayEntry] is currently mounted in the widget tree.
  ///
  /// The [OverlayEntry] notifies its listeners when this value changes.
  bool get mounted => _overlayEntryStateNotifier?.value != null;

  /// The currently mounted `_OverlayEntryWidgetState` built using this [OverlayEntry].
  ValueNotifier<_OverlayEntryWidgetState?>? _overlayEntryStateNotifier =
      ValueNotifier<_OverlayEntryWidgetState?>(null);

  // TODO(polina-c): stop duplicating code across disposables
  // https://github.com/flutter/flutter/issues/137435
  /// Dispatches event of object creation to [FlutterMemoryAllocations.instance].
  void _maybeDispatchObjectCreation() {
    if (kFlutterMemoryAllocationsEnabled) {
      FlutterMemoryAllocations.instance.dispatchObjectCreated(
        library: _flutterWidgetsLibrary,
        className: '$OverlayEntry',
        object: this,
      );
    }
  }

  @override
  void addListener(VoidCallback listener) {
    assert(!_disposedByOwner);
    _overlayEntryStateNotifier?.addListener(listener);
  }

  @override
  void removeListener(VoidCallback listener) {
    _overlayEntryStateNotifier?.removeListener(listener);
  }

  OverlayState? _overlay;
  final GlobalKey<_OverlayEntryWidgetState> _key = GlobalKey<_OverlayEntryWidgetState>();

  /// Remove this entry from the overlay.
  ///
  /// This should only be called once.
  ///
  /// This method removes this overlay entry from the overlay immediately. The
  /// UI will be updated in the same frame if this method is called before the
  /// overlay rebuild in this frame; otherwise, the UI will be updated in the
  /// next frame. This means that it is safe to call during builds, but also
  /// that if you do call this after the overlay rebuild, the UI will not update
  /// until the next frame (i.e. many milliseconds later).
  void remove() {
    assert(_overlay != null);
    assert(!_disposedByOwner);
    final OverlayState overlay = _overlay!;
    _overlay = null;
    if (!overlay.mounted) {
      return;
    }

    overlay._entries.remove(this);
    if (SchedulerBinding.instance.schedulerPhase == SchedulerPhase.persistentCallbacks) {
      SchedulerBinding.instance.addPostFrameCallback((Duration duration) {
        overlay._markDirty();
      }, debugLabel: 'OverlayEntry.markDirty');
    } else {
      overlay._markDirty();
    }
  }

  /// Cause this entry to rebuild during the next pipeline flush.
  ///
  /// You need to call this function if the output of [builder] has changed.
  void markNeedsBuild() {
    assert(!_disposedByOwner);
    _key.currentState?._markNeedsBuild();
  }

  void _didUnmount() {
    assert(!mounted);
    if (_disposedByOwner) {
      _overlayEntryStateNotifier?.dispose();
      _overlayEntryStateNotifier = null;
    }
  }

  bool _disposedByOwner = false;

  /// Discards any resources used by this [OverlayEntry].
  ///
  /// This method must be called after [remove] if the [OverlayEntry] is
  /// inserted into an [Overlay].
  ///
  /// After this is called, the object is not in a usable state and should be
  /// discarded (calls to [addListener] will throw after the object is disposed).
  /// However, the listeners registered may not be immediately released until
  /// the widget built using this [OverlayEntry] is unmounted from the widget
  /// tree.
  ///
  /// This method should only be called by the object's owner.
  void dispose() {
    assert(!_disposedByOwner);
    assert(
      _overlay == null,
      'An OverlayEntry must first be removed from the Overlay before dispose is called.',
    );
    if (kFlutterMemoryAllocationsEnabled) {
      FlutterMemoryAllocations.instance.dispatchObjectDisposed(object: this);
    }
    _disposedByOwner = true;
    if (!mounted) {
      // If we're still mounted when disposed, then this will be disposed in
      // _didUnmount, to allow notifications to occur until the entry is
      // unmounted.
      _overlayEntryStateNotifier?.dispose();
      _overlayEntryStateNotifier = null;
    }
  }

  @override
  String toString() =>
      '${describeIdentity(this)}(opaque: $opaque; maintainState: $maintainState)${_disposedByOwner ? "(DISPOSED)" : ""}';
}

class _OverlayEntryWidget extends StatefulWidget {
  const _OverlayEntryWidget({
    required Key super.key,
    required this.entry,
    required this.overlayState,
    this.tickerEnabled = true,
  });

  final OverlayEntry entry;
  final OverlayState overlayState;
  final bool tickerEnabled;

  @override
  _OverlayEntryWidgetState createState() => _OverlayEntryWidgetState();
}

class _OverlayEntryWidgetState extends State<_OverlayEntryWidget> {
  late _RenderTheater _theater;

  // Manages the stack of theater children whose paint order are sorted by their
  // _zOrderIndex. The children added by OverlayPortal are added to this linked
  // list, and they will be shown _above_ the OverlayEntry tied to this widget.
  // The children with larger zOrderIndex values (i.e. those called `show`
  // recently) will be painted last.
  //
  // This linked list is lazily created in `_add`, and the entries are added/removed
  // via `_add`/`_remove`, called by OverlayPortals lower in the tree. `_add` or
  // `_remove` does not cause this widget to rebuild, the linked list will be
  // read by _RenderTheater as part of its render child model. This would ideally
  // be in a RenderObject but there may not be RenderObjects between
  // _RenderTheater and the render subtree OverlayEntry builds.
  LinkedList<_OverlayEntryLocation>? _sortedTheaterSiblings;

  // Worst-case O(N), N being the number of children added to the top spot in
  // the same frame. This can be a bit expensive when there's a lot of global
  // key reparenting in the same frame but N is usually a small number.
  void _add(_OverlayEntryLocation child) {
    assert(mounted);
    final LinkedList<_OverlayEntryLocation> children =
        _sortedTheaterSiblings ??= LinkedList<_OverlayEntryLocation>();
    assert(!children.contains(child));
    _OverlayEntryLocation? insertPosition = children.isEmpty ? null : children.last;
    while (insertPosition != null && insertPosition._zOrderIndex > child._zOrderIndex) {
      insertPosition = insertPosition.previous;
    }
    if (insertPosition == null) {
      children.addFirst(child);
    } else {
      insertPosition.insertAfter(child);
    }
    assert(children.contains(child));
  }

  void _remove(_OverlayEntryLocation child) {
    assert(_sortedTheaterSiblings != null);
    final bool wasInCollection = _sortedTheaterSiblings?.remove(child) ?? false;
    assert(wasInCollection);
  }

  // Returns an Iterable that traverse the children in the child model in paint
  // order (from farthest to the user to the closest to the user).
  //
  // The iterator should be safe to use even when the child model is being
  // mutated. The reason for that is it's allowed to add/remove/move deferred
  // children to a _RenderTheater during performLayout, but the affected
  // children don't have to be laid out in the same performLayout call.
  late final Iterable<RenderBox> _paintOrderIterable = _createChildIterable(reversed: false);
  // An Iterable that traverse the children in the child model in
  // hit-test order (from closest to the user to the farthest to the user).
  late final Iterable<RenderBox> _hitTestOrderIterable = _createChildIterable(reversed: true);

  // The following uses sync* because hit-testing is lazy, and LinkedList as a
  // Iterable doesn't support concurrent modification.
  Iterable<RenderBox> _createChildIterable({required bool reversed}) sync* {
    final LinkedList<_OverlayEntryLocation>? children = _sortedTheaterSiblings;
    if (children == null || children.isEmpty) {
      return;
    }
    _OverlayEntryLocation? candidate = reversed ? children.last : children.first;
    while (candidate != null) {
      final RenderBox? renderBox = candidate._overlayChildRenderBox;
      candidate = reversed ? candidate.previous : candidate.next;
      if (renderBox != null) {
        yield renderBox;
      }
    }
  }

  @override
  void initState() {
    super.initState();
    widget.entry._overlayEntryStateNotifier!.value = this;
    _theater = context.findAncestorRenderObjectOfType<_RenderTheater>()!;
    assert(_sortedTheaterSiblings == null);
  }

  @override
  void didUpdateWidget(_OverlayEntryWidget oldWidget) {
    super.didUpdateWidget(oldWidget);
    // OverlayState's build method always returns a RenderObjectWidget _Theater,
    // so it's safe to assume that state equality implies render object equality.
    assert(oldWidget.entry == widget.entry);
    if (oldWidget.overlayState != widget.overlayState) {
      final _RenderTheater newTheater = context.findAncestorRenderObjectOfType<_RenderTheater>()!;
      assert(_theater != newTheater);
      _theater = newTheater;
    }
  }

  @override
  void dispose() {
    widget.entry._overlayEntryStateNotifier?.value = null;
    widget.entry._didUnmount();
    _sortedTheaterSiblings = null;
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    return TickerMode(
      enabled: widget.tickerEnabled,
      child: _RenderTheaterMarker(
        theater: _theater,
        overlayEntryWidgetState: this,
        child: widget.entry.builder(context),
      ),
    );
  }

  void _markNeedsBuild() {
    setState(() {
      /* the state that changed is in the builder */
    });
  }
}

/// A stack of entries that can be managed independently.
///
/// Overlays let independent child widgets "float" visual elements on top of
/// other widgets by inserting them into the overlay's stack. The overlay lets
/// each of these widgets manage their participation in the overlay using
/// [OverlayEntry] objects.
///
/// Although you can create an [Overlay] directly, it's most common to use the
/// overlay created by the [Navigator] in a [WidgetsApp], [CupertinoApp] or a
/// [MaterialApp]. The navigator uses its overlay to manage the visual
/// appearance of its routes.
///
/// The [Overlay] widget uses a custom stack implementation, which is very
/// similar to the [Stack] widget. The main use case of [Overlay] is related to
/// navigation and being able to insert widgets on top of the pages in an app.
/// For layout purposes unrelated to navigation, consider using [Stack] instead.
///
/// An [Overlay] widget requires a [Directionality] widget to be in scope, so
/// that it can resolve direction-sensitive coordinates of any
/// [Positioned.directional] children.
///
/// For widgets drawn in an [OverlayEntry], do not assume that the size of the
/// [Overlay] is the size returned by [MediaQuery.sizeOf]. Nested overlays can
/// have different sizes.
///
/// {@tool dartpad}
/// This example shows how to use the [Overlay] to highlight the [NavigationBar]
/// destination.
///
/// ** See code in examples/api/lib/widgets/overlay/overlay.0.dart **
/// {@end-tool}
///
/// See also:
///
///  * [OverlayEntry], the class that is used for describing the overlay entries.
///  * [OverlayState], which is used to insert the entries into the overlay.
///  * [WidgetsApp], which inserts an [Overlay] widget indirectly via its [Navigator].
///  * [MaterialApp], which inserts an [Overlay] widget indirectly via its [Navigator].
///  * [CupertinoApp], which inserts an [Overlay] widget indirectly via its [Navigator].
///  * [Stack], which allows directly displaying a stack of widgets.
class Overlay extends StatefulWidget {
  /// Creates an overlay.
  ///
  /// The initial entries will be inserted into the overlay when its associated
  /// [OverlayState] is initialized.
  ///
  /// Rather than creating an overlay, consider using the overlay that is
  /// created by the [Navigator] in a [WidgetsApp], [CupertinoApp], or a
  /// [MaterialApp] for the application.
  const Overlay({
    super.key,
    this.initialEntries = const <OverlayEntry>[],
    this.clipBehavior = Clip.hardEdge,
  });

  /// Wrap the provided `child` in an [Overlay] to allow other visual elements
  /// (packed in [OverlayEntry]s) to float on top of the child.
  ///
  /// This is a convenience method over the regular [Overlay] constructor: It
  /// creates an [Overlay] and puts the provided `child` in an [OverlayEntry]
  /// at the bottom of that newly created Overlay.
  static Widget wrap({Key? key, Clip clipBehavior = Clip.hardEdge, required Widget child}) {
    return _WrappingOverlay(key: key, clipBehavior: clipBehavior, child: child);
  }

  /// The entries to include in the overlay initially.
  ///
  /// These entries are only used when the [OverlayState] is initialized. If you
  /// are providing a new [Overlay] description for an overlay that's already in
  /// the tree, then the new entries are ignored.
  ///
  /// To add entries to an [Overlay] that is already in the tree, use
  /// [Overlay.of] to obtain the [OverlayState] (or assign a [GlobalKey] to the
  /// [Overlay] widget and obtain the [OverlayState] via
  /// [GlobalKey.currentState]), and then use [OverlayState.insert] or
  /// [OverlayState.insertAll].
  ///
  /// To remove an entry from an [Overlay], use [OverlayEntry.remove].
  final List<OverlayEntry> initialEntries;

  /// {@macro flutter.material.Material.clipBehavior}
  ///
  /// Defaults to [Clip.hardEdge].
  final Clip clipBehavior;

  /// The [OverlayState] from the closest instance of [Overlay] that encloses
  /// the given context within the closest [LookupBoundary], and, in debug mode,
  /// will throw if one is not found.
  ///
  /// In debug mode, if the `debugRequiredFor` argument is provided and an
  /// overlay isn't found, then this function will throw an exception containing
  /// the runtime type of the given widget in the error message. The exception
  /// attempts to explain that the calling [Widget] (the one given by the
  /// `debugRequiredFor` argument) needs an [Overlay] to be present to function.
  /// If `debugRequiredFor` is not supplied, then the error message is more
  /// generic.
  ///
  /// Typical usage is as follows:
  ///
  /// ```dart
  /// OverlayState overlay = Overlay.of(context);
  /// ```
  ///
  /// If `rootOverlay` is set to true, the state from the furthest instance of
  /// this class is given instead. Useful for installing overlay entries above
  /// all subsequent instances of [Overlay].
  ///
  /// This method can be expensive (it walks the element tree).
  ///
  /// See also:
  ///
  /// * [Overlay.maybeOf] for a similar function that returns null if an
  ///   [Overlay] is not found.
  static OverlayState of(
    BuildContext context, {
    bool rootOverlay = false,
    Widget? debugRequiredFor,
  }) {
    final OverlayState? result = maybeOf(context, rootOverlay: rootOverlay);
    assert(() {
      if (result == null) {
        final bool hiddenByBoundary = LookupBoundary.debugIsHidingAncestorStateOfType<OverlayState>(
          context,
        );
        final List<DiagnosticsNode> information = <DiagnosticsNode>[
          ErrorSummary(
            'No Overlay widget found${hiddenByBoundary ? ' within the closest LookupBoundary' : ''}.',
          ),
          if (hiddenByBoundary)
            ErrorDescription(
              'There is an ancestor Overlay widget, but it is hidden by a LookupBoundary.',
            ),
          ErrorDescription(
            '${debugRequiredFor?.runtimeType ?? 'Some'} widgets require an Overlay widget ancestor for correct operation.',
          ),
          ErrorHint(
            'The most common way to add an Overlay to an application is to include a MaterialApp, CupertinoApp or Navigator widget in the runApp() call.',
          ),
          if (debugRequiredFor != null)
            DiagnosticsProperty<Widget>(
              'The specific widget that failed to find an overlay was',
              debugRequiredFor,
              style: DiagnosticsTreeStyle.errorProperty,
            ),
          if (context.widget != debugRequiredFor)
            context.describeElement(
              'The context from which that widget was searching for an overlay was',
            ),
        ];

        throw FlutterError.fromParts(information);
      }
      return true;
    }());
    return result!;
  }

  /// The [OverlayState] from the closest instance of [Overlay] that encloses
  /// the given context within the closest [LookupBoundary], if any.
  ///
  /// Typical usage is as follows:
  ///
  /// ```dart
  /// OverlayState? overlay = Overlay.maybeOf(context);
  /// ```
  ///
  /// If `rootOverlay` is set to true, the state from the furthest instance of
  /// this class is given instead. Useful for installing overlay entries above
  /// all subsequent instances of [Overlay].
  ///
  /// This method can be expensive (it walks the element tree).
  ///
  /// See also:
  ///
  ///  * [Overlay.of] for a similar function that returns a non-nullable result
  ///    and throws if an [Overlay] is not found.

  static OverlayState? maybeOf(BuildContext context, {bool rootOverlay = false}) {
    return rootOverlay
        ? LookupBoundary.findRootAncestorStateOfType<OverlayState>(context)
        : LookupBoundary.findAncestorStateOfType<OverlayState>(context);
  }

  @override
  OverlayState createState() => OverlayState();
}

/// The current state of an [Overlay].
///
/// Used to insert [OverlayEntry]s into the overlay using the [insert] and
/// [insertAll] functions.
class OverlayState extends State<Overlay> with TickerProviderStateMixin {
  final List<OverlayEntry> _entries = <OverlayEntry>[];

  @protected
  @override
  void initState() {
    super.initState();
    insertAll(widget.initialEntries);
  }

  int _insertionIndex(OverlayEntry? below, OverlayEntry? above) {
    assert(above == null || below == null);
    if (below != null) {
      return _entries.indexOf(below);
    }
    if (above != null) {
      return _entries.indexOf(above) + 1;
    }
    return _entries.length;
  }

  bool _debugCanInsertEntry(OverlayEntry entry) {
    final List<DiagnosticsNode> operandsInformation = <DiagnosticsNode>[
      DiagnosticsProperty<OverlayEntry>(
        'The OverlayEntry was',
        entry,
        style: DiagnosticsTreeStyle.errorProperty,
      ),
      DiagnosticsProperty<OverlayState>(
        'The Overlay the OverlayEntry was trying to insert to was',
        this,
        style: DiagnosticsTreeStyle.errorProperty,
      ),
    ];

    if (!mounted) {
      throw FlutterError.fromParts(<DiagnosticsNode>[
        ErrorSummary('Attempted to insert an OverlayEntry to an already disposed Overlay.'),
        ...operandsInformation,
      ]);
    }

    final OverlayState? currentOverlay = entry._overlay;
    final bool alreadyContainsEntry = _entries.contains(entry);

    if (alreadyContainsEntry) {
      final bool inconsistentOverlayState = !identical(currentOverlay, this);
      throw FlutterError.fromParts(<DiagnosticsNode>[
        ErrorSummary('The specified entry is already present in the target Overlay.'),
        ...operandsInformation,
        if (inconsistentOverlayState)
          ErrorHint('This could be an error in the Flutter framework.')
        else
          ErrorHint(
            'Consider calling remove on the OverlayEntry before inserting it to a different Overlay, '
            'or switching to the OverlayPortal API to avoid manual OverlayEntry management.',
          ),
        if (inconsistentOverlayState)
          DiagnosticsProperty<OverlayState>(
            "The OverlayEntry's current Overlay was",
            currentOverlay,
            style: DiagnosticsTreeStyle.errorProperty,
          ),
      ]);
    }

    if (currentOverlay == null) {
      return true;
    }

    throw FlutterError.fromParts(<DiagnosticsNode>[
      ErrorSummary('The specified entry is already present in a different Overlay.'),
      ...operandsInformation,
      DiagnosticsProperty<OverlayState>(
        "The OverlayEntry's current Overlay was",
        currentOverlay,
        style: DiagnosticsTreeStyle.errorProperty,
      ),
      ErrorHint(
        'Consider calling remove on the OverlayEntry before inserting it to a different Overlay, '
        'or switching to the OverlayPortal API to avoid manual OverlayEntry management.',
      ),
    ]);
  }

  /// Insert the given entry into the overlay.
  ///
  /// If `below` is non-null, the entry is inserted just below `below`.
  /// If `above` is non-null, the entry is inserted just above `above`.
  /// Otherwise, the entry is inserted on top.
  ///
  /// It is an error to specify both `above` and `below`.
  void insert(OverlayEntry entry, {OverlayEntry? below, OverlayEntry? above}) {
    assert(_debugVerifyInsertPosition(above, below));
    assert(_debugCanInsertEntry(entry));
    entry._overlay = this;
    setState(() {
      _entries.insert(_insertionIndex(below, above), entry);
    });
  }

  /// Insert all the entries in the given iterable.
  ///
  /// If `below` is non-null, the entries are inserted just below `below`.
  /// If `above` is non-null, the entries are inserted just above `above`.
  /// Otherwise, the entries are inserted on top.
  ///
  /// It is an error to specify both `above` and `below`.
  void insertAll(Iterable<OverlayEntry> entries, {OverlayEntry? below, OverlayEntry? above}) {
    assert(_debugVerifyInsertPosition(above, below));
    assert(entries.every(_debugCanInsertEntry));
    if (entries.isEmpty) {
      return;
    }
    for (final OverlayEntry entry in entries) {
      assert(entry._overlay == null);
      entry._overlay = this;
    }
    setState(() {
      _entries.insertAll(_insertionIndex(below, above), entries);
    });
  }

  bool _debugVerifyInsertPosition(
    OverlayEntry? above,
    OverlayEntry? below, {
    Iterable<OverlayEntry>? newEntries,
  }) {
    assert(above == null || below == null, 'Only one of `above` and `below` may be specified.');
    assert(
      above == null ||
          (above._overlay == this &&
              _entries.contains(above) &&
              (newEntries?.contains(above) ?? true)),
      'The provided entry used for `above` must be present in the Overlay${newEntries != null ? ' and in the `newEntriesList`' : ''}.',
    );
    assert(
      below == null ||
          (below._overlay == this &&
              _entries.contains(below) &&
              (newEntries?.contains(below) ?? true)),
      'The provided entry used for `below` must be present in the Overlay${newEntries != null ? ' and in the `newEntriesList`' : ''}.',
    );
    return true;
  }

  /// Remove all the entries listed in the given iterable, then reinsert them
  /// into the overlay in the given order.
  ///
  /// Entries mention in `newEntries` but absent from the overlay are inserted
  /// as if with [insertAll].
  ///
  /// Entries not mentioned in `newEntries` but present in the overlay are
  /// positioned as a group in the resulting list relative to the entries that
  /// were moved, as specified by one of `below` or `above`, which, if
  /// specified, must be one of the entries in `newEntries`:
  ///
  /// If `below` is non-null, the group is positioned just below `below`.
  /// If `above` is non-null, the group is positioned just above `above`.
  /// Otherwise, the group is left on top, with all the rearranged entries
  /// below.
  ///
  /// It is an error to specify both `above` and `below`.
  void rearrange(Iterable<OverlayEntry> newEntries, {OverlayEntry? below, OverlayEntry? above}) {
    final List<OverlayEntry> newEntriesList =
        newEntries is List<OverlayEntry> ? newEntries : newEntries.toList(growable: false);
    assert(_debugVerifyInsertPosition(above, below, newEntries: newEntriesList));
    assert(
      newEntriesList.every(
        (OverlayEntry entry) => entry._overlay == null || entry._overlay == this,
      ),
      'One or more of the specified entries are already present in another Overlay.',
    );
    assert(
      newEntriesList.every(
        (OverlayEntry entry) => _entries.indexOf(entry) == _entries.lastIndexOf(entry),
      ),
      'One or more of the specified entries are specified multiple times.',
    );
    if (newEntriesList.isEmpty) {
      return;
    }
    if (listEquals(_entries, newEntriesList)) {
      return;
    }
    final LinkedHashSet<OverlayEntry> old = LinkedHashSet<OverlayEntry>.of(_entries);
    for (final OverlayEntry entry in newEntriesList) {
      entry._overlay ??= this;
    }
    setState(() {
      _entries.clear();
      _entries.addAll(newEntriesList);
      old.removeAll(newEntriesList);
      _entries.insertAll(_insertionIndex(below, above), old);
    });
  }

  void _markDirty() {
    if (mounted) {
      setState(() {});
    }
  }

  /// (DEBUG ONLY) Check whether a given entry is visible (i.e., not behind an
  /// opaque entry).
  ///
  /// This is an O(N) algorithm, and should not be necessary except for debug
  /// asserts. To avoid people depending on it, this function is implemented
  /// only in debug mode, and always returns false in release mode.
  bool debugIsVisible(OverlayEntry entry) {
    bool result = false;
    assert(_entries.contains(entry));
    assert(() {
      for (int i = _entries.length - 1; i > 0; i -= 1) {
        final OverlayEntry candidate = _entries[i];
        if (candidate == entry) {
          result = true;
          break;
        }
        if (candidate.opaque) {
          break;
        }
      }
      return true;
    }());
    return result;
  }

  void _didChangeEntryOpacity() {
    setState(() {
      // We use the opacity of the entry in our build function, which means we
      // our state has changed.
    });
  }

  @protected
  @override
  Widget build(BuildContext context) {
    // This list is filled backwards and then reversed below before
    // it is added to the tree.
    final List<_OverlayEntryWidget> children = <_OverlayEntryWidget>[];
    bool onstage = true;
    int onstageCount = 0;
    for (final OverlayEntry entry in _entries.reversed) {
      if (onstage) {
        onstageCount += 1;
        children.add(_OverlayEntryWidget(key: entry._key, overlayState: this, entry: entry));
        if (entry.opaque) {
          onstage = false;
        }
      } else if (entry.maintainState) {
        children.add(
          _OverlayEntryWidget(
            key: entry._key,
            overlayState: this,
            entry: entry,
            tickerEnabled: false,
          ),
        );
      }
    }
    return _Theater(
      skipCount: children.length - onstageCount,
      clipBehavior: widget.clipBehavior,
      children: children.reversed.toList(growable: false),
    );
  }

  @protected
  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    // TODO(jacobr): use IterableProperty instead as that would
    // provide a slightly more consistent string summary of the List.
    properties.add(DiagnosticsProperty<List<OverlayEntry>>('entries', _entries));
  }
}

class _WrappingOverlay extends StatefulWidget {
  const _WrappingOverlay({super.key, this.clipBehavior = Clip.hardEdge, required this.child});

  final Clip clipBehavior;
  final Widget child;

  @override
  State<_WrappingOverlay> createState() => _WrappingOverlayState();
}

class _WrappingOverlayState extends State<_WrappingOverlay> {
  late final OverlayEntry _entry = OverlayEntry(
    canSizeOverlay: true,
    opaque: true,
    builder: (BuildContext context) {
      return widget.child;
    },
  );

  @override
  void didUpdateWidget(_WrappingOverlay oldWidget) {
    super.didUpdateWidget(oldWidget);
    _entry.markNeedsBuild();
  }

  @override
  void dispose() {
    _entry
      ..remove()
      ..dispose();
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    return Overlay(clipBehavior: widget.clipBehavior, initialEntries: <OverlayEntry>[_entry]);
  }
}

/// Special version of a [Stack], that doesn't layout and render the first
/// [skipCount] children.
///
/// The first [skipCount] children are considered "offstage".
class _Theater extends MultiChildRenderObjectWidget {
  const _Theater({
    this.skipCount = 0,
    this.clipBehavior = Clip.hardEdge,
    required List<_OverlayEntryWidget> super.children,
  }) : assert(skipCount >= 0),
       assert(children.length >= skipCount);

  final int skipCount;

  final Clip clipBehavior;

  @override
  _TheaterElement createElement() => _TheaterElement(this);

  @override
  _RenderTheater createRenderObject(BuildContext context) {
    return _RenderTheater(
      skipCount: skipCount,
      textDirection: Directionality.of(context),
      clipBehavior: clipBehavior,
    );
  }

  @override
  void updateRenderObject(BuildContext context, _RenderTheater renderObject) {
    renderObject
      ..skipCount = skipCount
      ..textDirection = Directionality.of(context)
      ..clipBehavior = clipBehavior;
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties.add(IntProperty('skipCount', skipCount));
  }
}

class _TheaterElement extends MultiChildRenderObjectElement {
  _TheaterElement(_Theater super.widget);

  @override
  _RenderTheater get renderObject => super.renderObject as _RenderTheater;

  @override
  void insertRenderObjectChild(RenderBox child, IndexedSlot<Element?> slot) {
    super.insertRenderObjectChild(child, slot);
    final _TheaterParentData parentData = child.parentData! as _TheaterParentData;
    parentData.overlayEntry =
        ((widget as _Theater).children[slot.index] as _OverlayEntryWidget).entry;
    assert(parentData.overlayEntry != null);
  }

  @override
  void moveRenderObjectChild(
    RenderBox child,
    IndexedSlot<Element?> oldSlot,
    IndexedSlot<Element?> newSlot,
  ) {
    super.moveRenderObjectChild(child, oldSlot, newSlot);
    assert(() {
      final _TheaterParentData parentData = child.parentData! as _TheaterParentData;
      return parentData.overlayEntry ==
          ((widget as _Theater).children[newSlot.index] as _OverlayEntryWidget).entry;
    }());
  }

  @override
  void debugVisitOnstageChildren(ElementVisitor visitor) {
    final _Theater theater = widget as _Theater;
    assert(children.length >= theater.skipCount);
    children.skip(theater.skipCount).forEach(visitor);
  }
}

// A `RenderBox` that sizes itself to its parent's size, implements the stack
// layout algorithm and renders its children in the given `theater`.
mixin _RenderTheaterMixin on RenderBox {
  _RenderTheater get theater;

  Iterable<RenderBox> _childrenInPaintOrder();
  Iterable<RenderBox> _childrenInHitTestOrder();

  @override
  void setupParentData(RenderBox child) {
    if (child.parentData is! StackParentData) {
      child.parentData = StackParentData();
    }
  }

  @override
  double? computeDistanceToActualBaseline(TextBaseline baseline) {
    assert(!debugNeedsLayout);
    BaselineOffset baselineOffset = BaselineOffset.noBaseline;
    for (final RenderBox child in _childrenInPaintOrder()) {
      assert(!child.debugNeedsLayout);
      final StackParentData childParentData = child.parentData! as StackParentData;
      baselineOffset = baselineOffset.minOf(
        BaselineOffset(child.getDistanceToActualBaseline(baseline)) + childParentData.offset.dy,
      );
    }
    return baselineOffset.offset;
  }

  static double? baselineForChild(
    RenderBox child,
    Size theaterSize,
    BoxConstraints nonPositionedChildConstraints,
    Alignment alignment,
    TextBaseline baseline,
  ) {
    final StackParentData childParentData = child.parentData! as StackParentData;
    final BoxConstraints childConstraints =
        childParentData.isPositioned
            ? childParentData.positionedChildConstraints(theaterSize)
            : nonPositionedChildConstraints;
    final double? baselineOffset = child.getDryBaseline(childConstraints, baseline);
    if (baselineOffset == null) {
      return null;
    }
    final double y = switch (childParentData) {
      StackParentData(:final double top?) => top,
      StackParentData(:final double bottom?) =>
        theaterSize.height - bottom - child.getDryLayout(childConstraints).height,
      StackParentData() =>
        alignment.alongOffset(theaterSize - child.getDryLayout(childConstraints) as Offset).dy,
    };
    return baselineOffset + y;
  }

  void layoutChild(RenderBox child, BoxConstraints nonPositionedChildConstraints) {
    final StackParentData childParentData = child.parentData! as StackParentData;
    final Alignment alignment = theater._resolvedAlignment;
    if (!childParentData.isPositioned) {
      child.layout(nonPositionedChildConstraints, parentUsesSize: true);
      childParentData.offset = Offset.zero;
    } else {
      assert(
        child is! _RenderDeferredLayoutBox,
        'all _RenderDeferredLayoutBoxes must be non-positioned children.',
      );
      RenderStack.layoutPositionedChild(child, childParentData, size, alignment);
    }
    assert(child.parentData == childParentData);
  }

  @override
  bool hitTestChildren(BoxHitTestResult result, {required Offset position}) {
    final Iterator<RenderBox> iterator = _childrenInHitTestOrder().iterator;
    bool isHit = false;
    while (!isHit && iterator.moveNext()) {
      final RenderBox child = iterator.current;
      final StackParentData childParentData = child.parentData! as StackParentData;
      final RenderBox localChild = child;
      bool childHitTest(BoxHitTestResult result, Offset position) =>
          localChild.hitTest(result, position: position);
      isHit = result.addWithPaintOffset(
        offset: childParentData.offset,
        position: position,
        hitTest: childHitTest,
      );
    }
    return isHit;
  }

  @override
  void paint(PaintingContext context, Offset offset) {
    for (final RenderBox child in _childrenInPaintOrder()) {
      final StackParentData childParentData = child.parentData! as StackParentData;
      context.paintChild(child, childParentData.offset + offset);
    }
  }
}

class _TheaterParentData extends StackParentData {
  // The OverlayEntry that directly created this child. This field is null for
  // children that are created by an OverlayPortal.
  OverlayEntry? overlayEntry;

  /// A [OverlayPortal] makes its overlay child a render child of an ancestor
  /// [Overlay]. Currently, to make sure the overlay child is painted after its
  /// [OverlayPortal], and before the next [OverlayEntry] (which could be
  /// something that should obstruct the overlay child, such as a [ModalRoute])
  /// in the host [Overlay], the paint order of each overlay child is managed by
  /// the [OverlayEntry] that hosts its [OverlayPortal].
  ///
  /// The following methods are exposed to allow easy access to the overlay
  /// children's render objects whose order is managed by [overlayEntry], in the
  /// right order.

  // _overlayStateMounted is set to null in _OverlayEntryWidgetState's dispose
  // method. This property is only accessed during layout, paint and hit-test so
  // the `value!` should be safe.
  Iterator<RenderBox>? get paintOrderIterator =>
      overlayEntry?._overlayEntryStateNotifier?.value!._paintOrderIterable.iterator;
  Iterator<RenderBox>? get hitTestOrderIterator =>
      overlayEntry?._overlayEntryStateNotifier?.value!._hitTestOrderIterable.iterator;

  // A convenience method for traversing `paintOrderIterator` with a
  // [RenderObjectVisitor].
  void visitOverlayPortalChildrenOnOverlayEntry(RenderObjectVisitor visitor) =>
      overlayEntry?._overlayEntryStateNotifier?.value!._paintOrderIterable.forEach(visitor);
}

class _RenderTheater extends RenderBox
    with ContainerRenderObjectMixin<RenderBox, StackParentData>, _RenderTheaterMixin {
  _RenderTheater({
    List<RenderBox>? children,
    required TextDirection textDirection,
    int skipCount = 0,
    Clip clipBehavior = Clip.hardEdge,
  }) : assert(skipCount >= 0),
       _textDirection = textDirection,
       _skipCount = skipCount,
       _clipBehavior = clipBehavior {
    addAll(children);
  }

  @override
  _RenderTheater get theater => this;

  @override
  void setupParentData(RenderBox child) {
    if (child.parentData is! _TheaterParentData) {
      child.parentData = _TheaterParentData();
    }
  }

  @override
  void attach(PipelineOwner owner) {
    super.attach(owner);
    RenderBox? child = firstChild;
    while (child != null) {
      final _TheaterParentData childParentData = child.parentData! as _TheaterParentData;
      final Iterator<RenderBox>? iterator = childParentData.paintOrderIterator;
      if (iterator != null) {
        while (iterator.moveNext()) {
          iterator.current.attach(owner);
        }
      }
      child = childParentData.nextSibling;
    }
  }

  static void _detachChild(RenderObject child) => child.detach();

  @override
  void detach() {
    super.detach();
    RenderBox? child = firstChild;
    while (child != null) {
      final _TheaterParentData childParentData = child.parentData! as _TheaterParentData;
      childParentData.visitOverlayPortalChildrenOnOverlayEntry(_detachChild);
      child = childParentData.nextSibling;
    }
  }

  @override
  void redepthChildren() => visitChildren(redepthChild);

  Alignment? _alignmentCache;
  Alignment get _resolvedAlignment =>
      _alignmentCache ??= AlignmentDirectional.topStart.resolve(textDirection);

  void _markNeedResolution() {
    _alignmentCache = null;
    markNeedsLayout();
  }

  TextDirection get textDirection => _textDirection;
  TextDirection _textDirection;
  set textDirection(TextDirection value) {
    if (_textDirection == value) {
      return;
    }
    _textDirection = value;
    _markNeedResolution();
  }

  int get skipCount => _skipCount;
  int _skipCount;
  set skipCount(int value) {
    if (_skipCount != value) {
      _skipCount = value;
      markNeedsLayout();
    }
  }

  /// {@macro flutter.material.Material.clipBehavior}
  ///
  /// Defaults to [Clip.hardEdge].
  Clip get clipBehavior => _clipBehavior;
  Clip _clipBehavior = Clip.hardEdge;
  set clipBehavior(Clip value) {
    if (value != _clipBehavior) {
      _clipBehavior = value;
      markNeedsPaint();
      markNeedsSemanticsUpdate();
    }
  }

  // Adding/removing deferred child does not affect the layout of other children,
  // or that of the Overlay, so there's no need to invalidate the layout of the
  // Overlay.
  //
  // When _skipMarkNeedsLayout is true, markNeedsLayout does not do anything.
  bool _skipMarkNeedsLayout = false;
  void _addDeferredChild(_RenderDeferredLayoutBox child) {
    assert(!_skipMarkNeedsLayout);
    _skipMarkNeedsLayout = true;
    adoptChild(child);
    // The Overlay still needs repainting when a deferred child is added. Usually
    // `markNeedsLayout` implies `markNeedsPaint`, but here `markNeedsLayout` is
    // skipped when the `_skipMarkNeedsLayout` flag is set.
    markNeedsPaint();
    _skipMarkNeedsLayout = false;

    // After adding `child` to the render tree, we want to make sure it will be
    // laid out in the same frame. This is done by calling markNeedsLayout on the
    // layout surrogate. This ensures `child` is reachable via tree walk (see
    // _RenderLayoutSurrogateProxyBox.performLayout).
    child._layoutSurrogate.markNeedsLayout();
  }

  void _removeDeferredChild(_RenderDeferredLayoutBox child) {
    assert(!_skipMarkNeedsLayout);
    _skipMarkNeedsLayout = true;
    dropChild(child);
    // The Overlay still needs repainting when a deferred child is dropped. See
    // the comment in `_addDeferredChild`.
    markNeedsPaint();
    _skipMarkNeedsLayout = false;
  }

  @override
  void markNeedsLayout() {
    if (!_skipMarkNeedsLayout) {
      super.markNeedsLayout();
    }
  }

  RenderBox? get _firstOnstageChild {
    if (skipCount == super.childCount) {
      return null;
    }
    RenderBox? child = super.firstChild;
    for (int toSkip = skipCount; toSkip > 0; toSkip--) {
      final StackParentData childParentData = child!.parentData! as StackParentData;
      child = childParentData.nextSibling;
      assert(child != null);
    }
    return child;
  }

  RenderBox? get _lastOnstageChild => skipCount == super.childCount ? null : lastChild;

  @override
  double computeMinIntrinsicWidth(double height) {
    return RenderStack.getIntrinsicDimension(
      _firstOnstageChild,
      (RenderBox child) => child.getMinIntrinsicWidth(height),
    );
  }

  @override
  double computeMaxIntrinsicWidth(double height) {
    return RenderStack.getIntrinsicDimension(
      _firstOnstageChild,
      (RenderBox child) => child.getMaxIntrinsicWidth(height),
    );
  }

  @override
  double computeMinIntrinsicHeight(double width) {
    return RenderStack.getIntrinsicDimension(
      _firstOnstageChild,
      (RenderBox child) => child.getMinIntrinsicHeight(width),
    );
  }

  @override
  double computeMaxIntrinsicHeight(double width) {
    return RenderStack.getIntrinsicDimension(
      _firstOnstageChild,
      (RenderBox child) => child.getMaxIntrinsicHeight(width),
    );
  }

  @override
  double? computeDryBaseline(BoxConstraints constraints, TextBaseline baseline) {
    final Size size =
        constraints.biggest.isFinite
            ? constraints.biggest
            : _findSizeDeterminingChild().getDryLayout(constraints);
    final BoxConstraints nonPositionedChildConstraints = BoxConstraints.tight(size);
    final Alignment alignment = theater._resolvedAlignment;

    BaselineOffset baselineOffset = BaselineOffset.noBaseline;
    for (final RenderBox child in _childrenInPaintOrder()) {
      baselineOffset = baselineOffset.minOf(
        BaselineOffset(
          _RenderTheaterMixin.baselineForChild(
            child,
            size,
            nonPositionedChildConstraints,
            alignment,
            baseline,
          ),
        ),
      );
    }
    return baselineOffset.offset;
  }

  @override
  Size computeDryLayout(BoxConstraints constraints) {
    if (constraints.biggest.isFinite) {
      return constraints.biggest;
    }
    return _findSizeDeterminingChild().getDryLayout(constraints);
  }

  @override
  // The following uses sync* because concurrent modifications should be allowed
  // during layout.
  Iterable<RenderBox> _childrenInPaintOrder() sync* {
    RenderBox? child = _firstOnstageChild;
    while (child != null) {
      yield child;
      final _TheaterParentData childParentData = child.parentData! as _TheaterParentData;
      final Iterator<RenderBox>? innerIterator = childParentData.paintOrderIterator;
      if (innerIterator != null) {
        while (innerIterator.moveNext()) {
          yield innerIterator.current;
        }
      }
      child = childParentData.nextSibling;
    }
  }

  @override
  // The following uses sync* because hit testing should be lazy.
  Iterable<RenderBox> _childrenInHitTestOrder() sync* {
    RenderBox? child = _lastOnstageChild;
    int childLeft = childCount - skipCount;
    while (child != null) {
      final _TheaterParentData childParentData = child.parentData! as _TheaterParentData;
      final Iterator<RenderBox>? innerIterator = childParentData.hitTestOrderIterator;
      if (innerIterator != null) {
        while (innerIterator.moveNext()) {
          yield innerIterator.current;
        }
      }
      yield child;
      childLeft -= 1;
      child = childLeft <= 0 ? null : childParentData.previousSibling;
    }
  }

  @override
  bool get sizedByParent => false;

  bool _layingOutSizeDeterminingChild = false;
  @override
  void performLayout() {
    RenderBox? sizeDeterminingChild;
    if (constraints.biggest.isFinite) {
      size = constraints.biggest;
    } else {
      sizeDeterminingChild = _findSizeDeterminingChild();
      _layingOutSizeDeterminingChild = true;
      layoutChild(sizeDeterminingChild, constraints);
      _layingOutSizeDeterminingChild = false;
      size = sizeDeterminingChild.size;
    }

    // Equivalent to BoxConstraints used by RenderStack for StackFit.expand.
    final BoxConstraints nonPositionedChildConstraints = BoxConstraints.tight(size);
    for (final RenderBox child in _childrenInPaintOrder()) {
      if (child != sizeDeterminingChild) {
        layoutChild(child, nonPositionedChildConstraints);
      }
    }
  }

  RenderBox _findSizeDeterminingChild() {
    RenderBox? child = _lastOnstageChild;
    while (child != null) {
      final _TheaterParentData childParentData = child.parentData! as _TheaterParentData;
      if ((childParentData.overlayEntry?.canSizeOverlay ?? false) &&
          !childParentData.isPositioned) {
        return child;
      }
      child = childParentData.previousSibling;
    }
    throw FlutterError.fromParts(<DiagnosticsNode>[
      ErrorSummary(
        'Overlay was given infinite constraints and cannot be sized by a suitable child.',
      ),
      ErrorDescription(
        'The constraints given to the overlay ($constraints) would result in an illegal '
        'infinite size (${constraints.biggest}). To avoid that, the Overlay tried to size '
        'itself to one of its children, but no suitable non-positioned child that belongs to an '
        'OverlayEntry with canSizeOverlay set to true could be found.',
      ),
      ErrorHint(
        'Try wrapping the Overlay in a SizedBox to give it a finite size or '
        'use an OverlayEntry with canSizeOverlay set to true.',
      ),
    ]);
  }

  final LayerHandle<ClipRectLayer> _clipRectLayer = LayerHandle<ClipRectLayer>();

  @override
  void paint(PaintingContext context, Offset offset) {
    if (clipBehavior != Clip.none) {
      _clipRectLayer.layer = context.pushClipRect(
        needsCompositing,
        offset,
        Offset.zero & size,
        super.paint,
        clipBehavior: clipBehavior,
        oldLayer: _clipRectLayer.layer,
      );
    } else {
      _clipRectLayer.layer = null;
      super.paint(context, offset);
    }
  }

  @override
  void dispose() {
    _clipRectLayer.layer = null;
    super.dispose();
  }

  @override
  void visitChildren(RenderObjectVisitor visitor) {
    RenderBox? child = firstChild;
    while (child != null) {
      visitor(child);
      final _TheaterParentData childParentData = child.parentData! as _TheaterParentData;
      childParentData.visitOverlayPortalChildrenOnOverlayEntry(visitor);
      child = childParentData.nextSibling;
    }
  }

  @override
  void visitChildrenForSemantics(RenderObjectVisitor visitor) {
    RenderBox? child = _firstOnstageChild;
    while (child != null) {
      visitor(child);
      final _TheaterParentData childParentData = child.parentData! as _TheaterParentData;
      child = childParentData.nextSibling;
    }
  }

  @override
  Rect? describeApproximatePaintClip(RenderObject child) {
    switch (clipBehavior) {
      case Clip.none:
        return null;
      case Clip.hardEdge:
      case Clip.antiAlias:
      case Clip.antiAliasWithSaveLayer:
        return Offset.zero & size;
    }
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties.add(IntProperty('skipCount', skipCount));
    properties.add(EnumProperty<TextDirection>('textDirection', textDirection));
  }

  @override
  List<DiagnosticsNode> debugDescribeChildren() {
    final List<DiagnosticsNode> offstageChildren = <DiagnosticsNode>[];
    final List<DiagnosticsNode> onstageChildren = <DiagnosticsNode>[];

    int count = 1;
    bool onstage = false;
    RenderBox? child = firstChild;
    final RenderBox? firstOnstageChild = _firstOnstageChild;
    while (child != null) {
      final _TheaterParentData childParentData = child.parentData! as _TheaterParentData;
      if (child == firstOnstageChild) {
        onstage = true;
        count = 1;
      }

      if (onstage) {
        onstageChildren.add(child.toDiagnosticsNode(name: 'onstage $count'));
      } else {
        offstageChildren.add(
          child.toDiagnosticsNode(name: 'offstage $count', style: DiagnosticsTreeStyle.offstage),
        );
      }

      int subcount = 1;
      childParentData.visitOverlayPortalChildrenOnOverlayEntry((RenderObject renderObject) {
        final RenderBox child = renderObject as RenderBox;
        if (onstage) {
          onstageChildren.add(child.toDiagnosticsNode(name: 'onstage $count - $subcount'));
        } else {
          offstageChildren.add(
            child.toDiagnosticsNode(
              name: 'offstage $count - $subcount',
              style: DiagnosticsTreeStyle.offstage,
            ),
          );
        }
        subcount += 1;
      });

      child = childParentData.nextSibling;
      count += 1;
    }

    return <DiagnosticsNode>[
      ...onstageChildren,
      if (offstageChildren.isNotEmpty)
        ...offstageChildren
      else
        DiagnosticsNode.message('no offstage children', style: DiagnosticsTreeStyle.offstage),
    ];
  }
}

// * OverlayPortal Implementation
//  OverlayPortal is inspired by the
//  [flutter_portal](https://pub.dev/packages/flutter_portal) package.
//
// ** RenderObject hierarchy
// The widget works by inserting its overlay child's render subtree directly
// under [Overlay]'s render object (_RenderTheater).
// https://user-images.githubusercontent.com/31859944/171971838-62ed3975-4b5d-4733-a9c9-f79e263b8fcc.jpg
//
// To ensure the overlay child render subtree does not do layout twice, the
// subtree must only perform layout after both its _RenderTheater and the
// [OverlayPortal]'s render object (_RenderLayoutSurrogateProxyBox) have
// finished layout. This is handled by _RenderDeferredLayoutBox.
//
// ** Z-Index of an overlay child
// [_OverlayEntryLocation] is a (currently private) interface that allows an
// [OverlayPortal] to insert its overlay child into a specific [Overlay], as
// well as specifying the paint order between the overlay child and other
// children of the _RenderTheater.
//
// Since [OverlayPortal] is only allowed to target ancestor [Overlay]s
// (_RenderTheater must finish doing layout before _RenderDeferredLayoutBox),
// the _RenderTheater should typically be acquired using an [InheritedWidget]
// (currently, _RenderTheaterMarker) in case the [OverlayPortal] gets
// reparented.

/// A class to show, hide and bring to top an [OverlayPortal]'s overlay child
/// in the target [Overlay].
///
/// A [OverlayPortalController] can only be given to at most one [OverlayPortal]
/// at a time. When an [OverlayPortalController] is moved from one
/// [OverlayPortal] to another, its [isShowing] state does not carry over.
///
/// [OverlayPortalController.show] and [OverlayPortalController.hide] can be
/// called even before the controller is assigned to any [OverlayPortal], but
/// they typically should not be called while the widget tree is being rebuilt.
class OverlayPortalController {
  /// Creates an [OverlayPortalController], optionally with a String identifier
  /// `debugLabel`.
  OverlayPortalController({String? debugLabel}) : _debugLabel = debugLabel;

  _OverlayPortalState? _attachTarget;

  // A separate _zOrderIndex to allow `show()` or `hide()` to be called when the
  // controller is not yet attached. Once this controller is attached,
  // _attachTarget._zOrderIndex will be used as the source of truth, and this
  // variable will be set to null.
  int? _zOrderIndex;
  final String? _debugLabel;

  static int _wallTime =
      kIsWeb
          ? -9007199254740992 // -2^53
          : -1 << 63;

  // Returns a unique and monotonically increasing timestamp that represents
  // now.
  //
  // The value this method returns increments after each call.
  int _now() {
    final int now = _wallTime += 1;
    assert(_zOrderIndex == null || _zOrderIndex! < now);
    assert(_attachTarget?._zOrderIndex == null || _attachTarget!._zOrderIndex! < now);
    return now;
  }

  /// Show the overlay child of the [OverlayPortal] this controller is attached
  /// to, at the top of the target [Overlay].
  ///
  /// When there are more than one [OverlayPortal]s that target the same
  /// [Overlay], the overlay child of the last [OverlayPortal] to have called
  /// [show] appears at the top level, unobstructed.
  ///
  /// If [isShowing] is already true, calling this method brings the overlay
  /// child it controls to the top.
  ///
  /// This method should typically not be called while the widget tree is being
  /// rebuilt.
  void show() {
    final _OverlayPortalState? state = _attachTarget;
    if (state != null) {
      state.show(_now());
    } else {
      _zOrderIndex = _now();
    }
  }

  /// Hide the [OverlayPortal]'s overlay child.
  ///
  /// Once hidden, the overlay child will be removed from the widget tree the
  /// next time the widget tree rebuilds, and stateful widgets in the overlay
  /// child may lose states as a result.
  ///
  /// This method should typically not be called while the widget tree is being
  /// rebuilt.
  void hide() {
    final _OverlayPortalState? state = _attachTarget;
    if (state != null) {
      state.hide();
    } else {
      assert(_zOrderIndex != null);
      _zOrderIndex = null;
    }
  }

  /// Whether the associated [OverlayPortal] should build and show its overlay
  /// child, using its `overlayChildBuilder`.
  bool get isShowing {
    final _OverlayPortalState? state = _attachTarget;
    return state != null ? state._zOrderIndex != null : _zOrderIndex != null;
  }

  /// Convenience method for toggling the current [isShowing] status.
  ///
  /// This method should typically not be called while the widget tree is being
  /// rebuilt.
  void toggle() => isShowing ? hide() : show();

  @override
  String toString() {
    final String? debugLabel = _debugLabel;
    final String label = debugLabel == null ? '' : '($debugLabel)';
    final String isDetached = _attachTarget != null ? '' : ' DETACHED';
    return '${objectRuntimeType(this, 'OverlayPortalController')}$label$isDetached';
  }
}

/// A widget that renders its overlay child on an [Overlay].
///
/// The overlay child is initially hidden until [OverlayPortalController.show]
/// is called on the associated [controller]. The [OverlayPortal] uses
/// [overlayChildBuilder] to build its overlay child and renders it on the
/// specified [Overlay] as if it was inserted using an [OverlayEntry], while it
/// can depend on the same set of [InheritedWidget]s (such as [Theme]) that this
/// widget can depend on.
///
/// This widget requires an [Overlay] ancestor in the widget tree when its
/// overlay child is showing. The overlay child is rendered by the [Overlay]
/// ancestor, not by the widget itself. This allows the overlay child to float
/// above other widgets, independent of its position in the widget tree.
///
/// When [OverlayPortalController.hide] is called, the widget built using
/// [overlayChildBuilder] will be removed from the widget tree the next time the
/// widget rebuilds. Stateful descendants in the overlay child subtree may lose
/// states as a result.
///
/// {@tool dartpad}
/// This example uses an [OverlayPortal] to build a tooltip that becomes visible
/// when the user taps on the [child] widget. There's a [DefaultTextStyle] above
/// the [OverlayPortal] controlling the [TextStyle] of both the [child] widget
/// and the widget [overlayChildBuilder] builds, which isn't otherwise doable if
/// the tooltip was added as an [OverlayEntry].
///
/// ** See code in examples/api/lib/widgets/overlay/overlay_portal.0.dart **
/// {@end-tool}
///
/// ### Paint Order
///
/// In an [Overlay], an overlay child is painted after the [OverlayEntry]
/// associated with its [OverlayPortal] (that is, the [OverlayEntry] closest to
/// the [OverlayPortal] in the widget tree, which usually represents the
/// enclosing [Route]), and before the next [OverlayEntry].
///
/// When an [OverlayEntry] has multiple associated [OverlayPortal]s, the paint
/// order between their overlay children is the order in which
/// [OverlayPortalController.show] was called. The last [OverlayPortal] to have
/// called `show` gets to paint its overlay child in the foreground.
///
/// ### Semantics
///
/// The semantics subtree generated by the overlay child is considered attached
/// to [OverlayPortal] instead of the target [Overlay]. An [OverlayPortal]'s
/// semantics subtree can be dropped from the semantics tree due to invisibility
/// while the overlay child is still visible (for example, when the
/// [OverlayPortal] is completely invisible in a [ListView] but kept alive by
/// a [KeepAlive] widget). When this happens the semantics subtree generated by
/// the overlay child is also dropped, even if the overlay child is still visible
/// on screen.
///
/// {@template flutter.widgets.overlayPortalVsOverlayEntry}
/// ### Differences between [OverlayPortal] and [OverlayEntry]
///
/// The main difference between [OverlayEntry] and [OverlayPortal] is that
/// [OverlayEntry] builds its widget subtree as a child of the target [Overlay],
/// while [OverlayPortal] uses [OverlayPortal.overlayChildBuilder] to build a
/// child widget of itself. This allows [OverlayPortal]'s overlay child to depend
/// on the same set of [InheritedWidget]s as [OverlayPortal], and it's also
/// guaranteed that the overlay child will not outlive its [OverlayPortal].
///
/// On the other hand, [OverlayPortal]'s implementation is more complex. For
/// instance, it does a bit more work than a regular widget during global key
/// reparenting. If the content to be shown on the [Overlay] doesn't benefit
/// from being a part of [OverlayPortal]'s subtree, consider using an
/// [OverlayEntry] instead.
/// {@endtemplate}
///
/// See also:
///
///  * [OverlayEntry], an alternative API for inserting widgets into an
///    [Overlay].
///  * [Positioned], which can be used to size and position the overlay child in
///    relation to the target [Overlay]'s boundaries.
///  * [CompositedTransformFollower], which can be used to position the overlay
///    child in relation to the linked [CompositedTransformTarget] widget.
class OverlayPortal extends StatefulWidget {
  /// Creates an [OverlayPortal] that renders the widget [overlayChildBuilder]
  /// builds on the closest [Overlay] when [OverlayPortalController.show] is
  /// called.
  const OverlayPortal({
    super.key,
    required this.controller,
    required this.overlayChildBuilder,
    this.child,
  }) : _targetRootOverlay = false;

  /// Creates an [OverlayPortal] that renders the widget [overlayChildBuilder]
  /// builds on the root [Overlay] when [OverlayPortalController.show] is
  /// called.
  const OverlayPortal.targetsRootOverlay({
    super.key,
    required this.controller,
    required this.overlayChildBuilder,
    this.child,
  }) : _targetRootOverlay = true;

  /// The controller to show, hide and bring to top the overlay child.
  final OverlayPortalController controller;

  /// A [WidgetBuilder] used to build a widget below this widget in the tree,
  /// that renders on the closest [Overlay].
  ///
  /// The said widget will only be built and shown in the closest [Overlay] once
  /// [OverlayPortalController.show] is called on the associated [controller].
  /// It will be painted in front of the [OverlayEntry] closest to this widget
  /// in the widget tree (which is usually the enclosing [Route]).
  ///
  /// The built overlay child widget is inserted below this widget in the widget
  /// tree, allowing it to depend on [InheritedWidget]s above it, and be
  /// notified when the [InheritedWidget]s change.
  ///
  /// Unlike [child], the built overlay child can visually extend outside the
  /// bounds of this widget without being clipped, and receive hit-test events
  /// outside of this widget's bounds, as long as it does not extend outside of
  /// the [Overlay] on which it is rendered.
  final WidgetBuilder overlayChildBuilder;

  /// A widget below this widget in the tree.
  final Widget? child;

  final bool _targetRootOverlay;

  @override
  State<OverlayPortal> createState() => _OverlayPortalState();
}

class _OverlayPortalState extends State<OverlayPortal> {
  int? _zOrderIndex;
  // The location of the overlay child within the overlay. This object will be
  // used as the slot of the overlay child widget.
  //
  // The developer must call `show` to reveal the overlay so we can get a unique
  // timestamp of the user interaction for determining the z-index of the
  // overlay child in the overlay.
  //
  // Avoid invalidating the cache if possible, since the framework uses `==` to
  // compare slots, and _OverlayEntryLocation can't override that operator since
  // it's mutable. Changing slots can be relatively slow.
  bool _childModelMayHaveChanged = true;
  _OverlayEntryLocation? _locationCache;
  static bool _isTheSameLocation(_OverlayEntryLocation locationCache, _RenderTheaterMarker marker) {
    return locationCache._childModel == marker.overlayEntryWidgetState &&
        locationCache._theater == marker.theater;
  }

  _OverlayEntryLocation _getLocation(int zOrderIndex, bool targetRootOverlay) {
    final _OverlayEntryLocation? cachedLocation = _locationCache;
    late final _RenderTheaterMarker marker = _RenderTheaterMarker.of(
      context,
      targetRootOverlay: targetRootOverlay,
    );
    final bool isCacheValid =
        cachedLocation != null &&
        (!_childModelMayHaveChanged || _isTheSameLocation(cachedLocation, marker));
    _childModelMayHaveChanged = false;
    if (isCacheValid) {
      assert(cachedLocation._zOrderIndex == zOrderIndex);
      assert(cachedLocation._debugIsLocationValid());
      return cachedLocation;
    }
    // Otherwise invalidate the cache and create a new location.
    cachedLocation?._debugMarkLocationInvalid();
    final _OverlayEntryLocation newLocation = _OverlayEntryLocation(
      zOrderIndex,
      marker.overlayEntryWidgetState,
      marker.theater,
    );
    assert(newLocation._zOrderIndex == zOrderIndex);
    return _locationCache = newLocation;
  }

  @override
  void initState() {
    super.initState();
    _setupController(widget.controller);
  }

  void _setupController(OverlayPortalController controller) {
    assert(
      controller._attachTarget == null || controller._attachTarget == this,
      'Failed to attach $controller to $this. It is already attached to ${controller._attachTarget}.',
    );
    final int? controllerZOrderIndex = controller._zOrderIndex;
    final int? zOrderIndex = _zOrderIndex;
    if (zOrderIndex == null ||
        (controllerZOrderIndex != null && controllerZOrderIndex > zOrderIndex)) {
      _zOrderIndex = controllerZOrderIndex;
    }
    controller._zOrderIndex = null;
    controller._attachTarget = this;
  }

  @override
  void didChangeDependencies() {
    super.didChangeDependencies();
    _childModelMayHaveChanged = true;
  }

  @override
  void didUpdateWidget(OverlayPortal oldWidget) {
    super.didUpdateWidget(oldWidget);
    _childModelMayHaveChanged =
        _childModelMayHaveChanged || oldWidget._targetRootOverlay != widget._targetRootOverlay;
    if (oldWidget.controller != widget.controller) {
      oldWidget.controller._attachTarget = null;
      _setupController(widget.controller);
    }
  }

  @override
  void dispose() {
    assert(widget.controller._attachTarget == this);
    widget.controller._attachTarget = null;
    _locationCache?._debugMarkLocationInvalid();
    _locationCache = null;
    super.dispose();
  }

  void show(int zOrderIndex) {
    assert(
      SchedulerBinding.instance.schedulerPhase != SchedulerPhase.persistentCallbacks,
      '${widget.controller.runtimeType}.show() should not be called during build.',
    );
    setState(() {
      _zOrderIndex = zOrderIndex;
    });
    _locationCache?._debugMarkLocationInvalid();
    _locationCache = null;
  }

  void hide() {
    assert(SchedulerBinding.instance.schedulerPhase != SchedulerPhase.persistentCallbacks);
    setState(() {
      _zOrderIndex = null;
    });
    _locationCache?._debugMarkLocationInvalid();
    _locationCache = null;
  }

  @override
  Widget build(BuildContext context) {
    final int? zOrderIndex = _zOrderIndex;
    if (zOrderIndex == null) {
      return _OverlayPortal(overlayLocation: null, overlayChild: null, child: widget.child);
    }
    return _OverlayPortal(
      overlayLocation: _getLocation(zOrderIndex, widget._targetRootOverlay),
      overlayChild: _DeferredLayout(child: Builder(builder: widget.overlayChildBuilder)),
      child: widget.child,
    );
  }
}

/// A location in an [Overlay].
///
/// An [_OverlayEntryLocation] determines the [Overlay] the associated
/// [OverlayPortal] should put its overlay child onto, as well as the overlay
/// child's paint order in relation to other contents painted on the [Overlay].
//
// An _OverlayEntryLocation is a cursor pointing to a location in a particular
// Overlay's child model, and provides methods to insert/remove/move a
// _RenderDeferredLayoutBox to/from its target _theater.
//
// The occupant (a `RenderBox`) will be painted above the associated
// [OverlayEntry], but below the [OverlayEntry] above that [OverlayEntry].
//
// Additionally, `_activate` and `_deactivate` are called when the overlay
// child's `_OverlayPortalElement` activates/deactivates (for instance, during
// global key reparenting).
// `_OverlayPortalElement` removes its overlay child's render object from the
// target `_RenderTheater` when it deactivates and puts it back on `activated`.
// These 2 methods can be used to "hide" a child in the child model without
// removing it, when the child is expensive/difficult to re-insert at the
// correct location on `activated`.
//
// ### Equality
//
// An `_OverlayEntryLocation` will be used as an Element's slot. These 3 parts
// uniquely identify a place in an overlay's child model:
// - _theater
// - _childModel (the OverlayEntry)
// - _zOrderIndex
//
// Since it can't implement operator== (it's mutable), the same `_OverlayEntryLocation`
// instance must not be used to represent more than one locations.
final class _OverlayEntryLocation extends LinkedListEntry<_OverlayEntryLocation> {
  _OverlayEntryLocation(this._zOrderIndex, this._childModel, this._theater);

  final int _zOrderIndex;
  final _OverlayEntryWidgetState _childModel;
  final _RenderTheater _theater;

  _RenderDeferredLayoutBox? _overlayChildRenderBox;
  void _addToChildModel(_RenderDeferredLayoutBox child) {
    assert(
      _overlayChildRenderBox == null,
      'Failed to add $child. This location ($this) is already occupied by $_overlayChildRenderBox.',
    );
    _overlayChildRenderBox = child;
    _childModel._add(this);
    _theater.markNeedsPaint();
    _theater.markNeedsCompositingBitsUpdate();
    _theater.markNeedsSemanticsUpdate();
  }

  void _removeFromChildModel(_RenderDeferredLayoutBox child) {
    assert(child == _overlayChildRenderBox);
    _overlayChildRenderBox = null;
    assert(_childModel._sortedTheaterSiblings?.contains(this) ?? false);
    _childModel._remove(this);
    _theater.markNeedsPaint();
    _theater.markNeedsCompositingBitsUpdate();
    _theater.markNeedsSemanticsUpdate();
  }

  void _addChild(_RenderDeferredLayoutBox child) {
    assert(_debugIsLocationValid());
    _addToChildModel(child);
    _theater._addDeferredChild(child);
    assert(child.parent == _theater);
  }

  void _removeChild(_RenderDeferredLayoutBox child) {
    // This call is allowed even when this location is disposed.
    _removeFromChildModel(child);
    _theater._removeDeferredChild(child);
    assert(child.parent == null);
  }

  void _moveChild(_RenderDeferredLayoutBox child, _OverlayEntryLocation fromLocation) {
    assert(fromLocation != this);
    assert(_debugIsLocationValid());
    final _RenderTheater fromTheater = fromLocation._theater;
    final _OverlayEntryWidgetState fromModel = fromLocation._childModel;

    if (fromTheater != _theater) {
      fromTheater._removeDeferredChild(child);
      _theater._addDeferredChild(child);
    }

    if (fromModel != _childModel || fromLocation._zOrderIndex != _zOrderIndex) {
      fromLocation._removeFromChildModel(child);
      _addToChildModel(child);
    }
  }

  void _activate(_RenderDeferredLayoutBox child) {
    // This call is allowed even when this location is invalidated.
    // See _OverlayPortalElement.activate.
    assert(_overlayChildRenderBox == null, '$_overlayChildRenderBox');
    _theater._addDeferredChild(child);
    _overlayChildRenderBox = child;
  }

  void _deactivate(_RenderDeferredLayoutBox child) {
    // This call is allowed even when this location is invalidated.
    _theater._removeDeferredChild(child);
    _overlayChildRenderBox = null;
  }

  // Throws a StateError if this location is already invalidated and shouldn't
  // be used as an OverlayPortal slot. Must be used in asserts.
  //
  // Generally, `assert(_debugIsLocationValid())` should be used to prevent
  // invalid accesses to an invalid `_OverlayEntryLocation` object. Exceptions
  // to this rule are _removeChild, _deactivate, which will be called when the
  // OverlayPortal is being removed from the widget tree and may use the
  // location information to perform cleanup tasks.
  //
  // Another exception is the _activate method which is called by
  // _OverlayPortalElement.activate. See the comment in _OverlayPortalElement.activate.
  bool _debugIsLocationValid() {
    if (_debugMarkLocationInvalidStackTrace == null) {
      return true;
    }
    throw StateError(
      '$this is already disposed. Stack trace: $_debugMarkLocationInvalidStackTrace',
    );
  }

  // The StackTrace of the first _debugMarkLocationInvalid call. It's only for
  // debugging purposes and the StackTrace will only be captured in debug builds.
  //
  // The effect of this method is not reversible. Once marked invalid, this
  // object can't be marked as valid again.
  StackTrace? _debugMarkLocationInvalidStackTrace;
  @mustCallSuper
  void _debugMarkLocationInvalid() {
    assert(_debugIsLocationValid());
    assert(() {
      _debugMarkLocationInvalidStackTrace = StackTrace.current;
      return true;
    }());
  }

  @override
  String toString() =>
      '${objectRuntimeType(this, '_OverlayEntryLocation')}[${shortHash(this)}] ${_debugMarkLocationInvalidStackTrace != null ? "(INVALID)" : ""}';
}

class _RenderTheaterMarker extends InheritedWidget {
  const _RenderTheaterMarker({
    required this.theater,
    required this.overlayEntryWidgetState,
    required super.child,
  });

  final _RenderTheater theater;
  final _OverlayEntryWidgetState overlayEntryWidgetState;

  @override
  bool updateShouldNotify(_RenderTheaterMarker oldWidget) {
    return oldWidget.theater != theater ||
        oldWidget.overlayEntryWidgetState != overlayEntryWidgetState;
  }

  static _RenderTheaterMarker of(BuildContext context, {bool targetRootOverlay = false}) {
    final _RenderTheaterMarker? marker;
    if (targetRootOverlay) {
      final InheritedElement? ancestor = _rootRenderTheaterMarkerOf(
        context.getElementForInheritedWidgetOfExactType<_RenderTheaterMarker>(),
      );
      assert(ancestor == null || ancestor.widget is _RenderTheaterMarker);
      marker =
          ancestor != null
              ? context.dependOnInheritedElement(ancestor) as _RenderTheaterMarker?
              : null;
    } else {
      marker = context.dependOnInheritedWidgetOfExactType<_RenderTheaterMarker>();
    }
    if (marker != null) {
      return marker;
    }
    throw FlutterError.fromParts(<DiagnosticsNode>[
      ErrorSummary('No Overlay widget found.'),
      ErrorDescription(
        '${context.widget.runtimeType} widgets require an Overlay widget ancestor.\n'
        'An overlay lets widgets float on top of other widget children.',
      ),
      ErrorHint(
        'To introduce an Overlay widget, you can either directly '
        'include one, or use a widget that contains an Overlay itself, '
        'such as a Navigator, WidgetApp, MaterialApp, or CupertinoApp.',
      ),
      ...context.describeMissingAncestor(expectedAncestorType: Overlay),
    ]);
  }

  static InheritedElement? _rootRenderTheaterMarkerOf(InheritedElement? theaterMarkerElement) {
    assert(theaterMarkerElement == null || theaterMarkerElement.widget is _RenderTheaterMarker);
    if (theaterMarkerElement == null) {
      return null;
    }
    InheritedElement? ancestor;
    theaterMarkerElement.visitAncestorElements((Element element) {
      ancestor = element.getElementForInheritedWidgetOfExactType<_RenderTheaterMarker>();
      return false;
    });
    return ancestor == null ? theaterMarkerElement : _rootRenderTheaterMarkerOf(ancestor);
  }
}

class _OverlayPortal extends RenderObjectWidget {
  /// Creates a widget that renders the given [overlayChild] in the [Overlay]
  /// specified by `overlayLocation`.
  ///
  /// The `overlayLocation` parameter must not be null when [overlayChild] is not
  /// null.
  _OverlayPortal({required this.overlayLocation, required this.overlayChild, required this.child})
    : assert(overlayChild == null || overlayLocation != null),
      assert(overlayLocation == null || overlayLocation._debugIsLocationValid());

  final Widget? overlayChild;

  /// A widget below this widget in the tree.
  final Widget? child;

  final _OverlayEntryLocation? overlayLocation;

  @override
  RenderObjectElement createElement() => _OverlayPortalElement(this);

  @override
  RenderObject createRenderObject(BuildContext context) => _RenderLayoutSurrogateProxyBox();
}

class _OverlayPortalElement extends RenderObjectElement {
  _OverlayPortalElement(_OverlayPortal super.widget);

  @override
  _RenderLayoutSurrogateProxyBox get renderObject =>
      super.renderObject as _RenderLayoutSurrogateProxyBox;

  Element? _overlayChild;
  Element? _child;

  @override
  void mount(Element? parent, Object? newSlot) {
    super.mount(parent, newSlot);
    final _OverlayPortal widget = this.widget as _OverlayPortal;
    _child = updateChild(_child, widget.child, null);
    _overlayChild = updateChild(_overlayChild, widget.overlayChild, widget.overlayLocation);
  }

  @override
  void update(_OverlayPortal newWidget) {
    super.update(newWidget);
    _child = updateChild(_child, newWidget.child, null);
    _overlayChild = updateChild(_overlayChild, newWidget.overlayChild, newWidget.overlayLocation);
  }

  @override
  void forgetChild(Element child) {
    // The _overlayChild Element does not have a key because the _DeferredLayout
    // widget does not take a Key, so only the regular _child can be taken
    // during global key reparenting.
    assert(child == _child);
    _child = null;
    super.forgetChild(child);
  }

  @override
  void visitChildren(ElementVisitor visitor) {
    final Element? child = _child;
    final Element? overlayChild = _overlayChild;
    if (child != null) {
      visitor(child);
    }
    if (overlayChild != null) {
      visitor(overlayChild);
    }
  }

  @override
  void activate() {
    super.activate();
    final _RenderDeferredLayoutBox? box = _overlayChild?.renderObject as _RenderDeferredLayoutBox?;
    if (box != null) {
      assert(!box.attached);
      assert(renderObject._deferredLayoutChild == box);
      // updateChild has not been called at this point so the RenderTheater in
      // the overlay location could be detached. Adding children to a detached
      // RenderObject is still allowed however this isn't the most efficient.
      (_overlayChild!.slot! as _OverlayEntryLocation)._activate(box);
    }
  }

  @override
  void deactivate() {
    // Instead of just detaching the render objects, removing them from the
    // render subtree entirely. This is a workaround for the
    // !renderObject.attached assert in the `super.deactivate()` method.
    final _RenderDeferredLayoutBox? box = _overlayChild?.renderObject as _RenderDeferredLayoutBox?;
    if (box != null) {
      (_overlayChild!.slot! as _OverlayEntryLocation)._deactivate(box);
    }
    super.deactivate();
  }

  @override
  void insertRenderObjectChild(RenderBox child, _OverlayEntryLocation? slot) {
    assert(child.parent == null, "$child's parent is not null: ${child.parent}");
    if (slot != null) {
      renderObject._deferredLayoutChild = child as _RenderDeferredLayoutBox;
      slot._addChild(child);
      renderObject.markNeedsSemanticsUpdate();
    } else {
      renderObject.child = child;
    }
  }

  // The [_DeferredLayout] widget does not have a key so there will be no
  // reparenting between _overlayChild and _child, thus the non-null-typed slots.
  @override
  void moveRenderObjectChild(
    _RenderDeferredLayoutBox child,
    _OverlayEntryLocation oldSlot,
    _OverlayEntryLocation newSlot,
  ) {
    assert(newSlot._debugIsLocationValid());
    newSlot._moveChild(child, oldSlot);
    renderObject.markNeedsSemanticsUpdate();
  }

  @override
  void removeRenderObjectChild(RenderBox child, _OverlayEntryLocation? slot) {
    if (slot == null) {
      renderObject.child = null;
      return;
    }
    assert(renderObject._deferredLayoutChild == child);
    slot._removeChild(child as _RenderDeferredLayoutBox);
    renderObject._deferredLayoutChild = null;
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties.add(DiagnosticsProperty<Element>('child', _child, defaultValue: null));
    properties.add(DiagnosticsProperty<Element>('overlayChild', _overlayChild, defaultValue: null));
    properties.add(
      DiagnosticsProperty<Object>('overlayLocation', _overlayChild?.slot, defaultValue: null),
    );
  }
}

class _DeferredLayout extends SingleChildRenderObjectWidget {
  const _DeferredLayout({
    // This widget must not be given a key: we currently do not support
    // reparenting between the overlayChild and child.
    required Widget child,
  }) : super(child: child);

  _RenderLayoutSurrogateProxyBox getLayoutParent(BuildContext context) {
    return context.findAncestorRenderObjectOfType<_RenderLayoutSurrogateProxyBox>()!;
  }

  @override
  _RenderDeferredLayoutBox createRenderObject(BuildContext context) {
    final _RenderLayoutSurrogateProxyBox parent = getLayoutParent(context);
    final _RenderDeferredLayoutBox renderObject = _RenderDeferredLayoutBox(parent);
    parent._deferredLayoutChild = renderObject;
    return renderObject;
  }

  @override
  void updateRenderObject(BuildContext context, _RenderDeferredLayoutBox renderObject) {
    assert(renderObject._layoutSurrogate == getLayoutParent(context));
    assert(getLayoutParent(context)._deferredLayoutChild == renderObject);
  }
}

// A `RenderProxyBox` that defers its layout until its `_layoutSurrogate` (which
// is not necessarily an ancestor of this RenderBox, but shares at least one
// `_RenderTheater` ancestor with this RenderBox) is laid out.
//
// This `RenderObject` must be a child of a `_RenderTheater`. It guarantees that:
//
// 1. It's a relayout boundary, so calling `markNeedsLayout` on it never dirties
//    its `_RenderTheater`.
//
// 2. Its `layout` implementation is overridden such that `performLayout` does
//    not do anything when its called from `layout`, preventing the parent
//    `_RenderTheater` from laying out this subtree prematurely (but this
//    `RenderObject` may still be resized). Instead, `markNeedsLayout` will be
//    called from within `layout` to schedule a layout update for this relayout
//    boundary when needed.
//
// 3. When invoked from `PipelineOwner.flushLayout`, or
//    `_layoutSurrogate.performLayout`, this `RenderObject` behaves like an
//    `Overlay` that has only one entry.
final class _RenderDeferredLayoutBox extends RenderProxyBox
    with _RenderTheaterMixin, LinkedListEntry<_RenderDeferredLayoutBox> {
  _RenderDeferredLayoutBox(this._layoutSurrogate);

  StackParentData get stackParentData => parentData! as StackParentData;
  final _RenderLayoutSurrogateProxyBox _layoutSurrogate;

  @override
  Iterable<RenderBox> _childrenInPaintOrder() {
    final RenderBox? child = this.child;
    return child == null
        ? const Iterable<RenderBox>.empty()
        : Iterable<RenderBox>.generate(1, (int i) => child);
  }

  @override
  Iterable<RenderBox> _childrenInHitTestOrder() => _childrenInPaintOrder();

  @override
  _RenderTheater get theater {
    final RenderObject? parent = this.parent;
    return parent is _RenderTheater
        ? parent
        : throw FlutterError('$parent of $this is not a _RenderTheater');
  }

  @override
  void redepthChildren() {
    _layoutSurrogate.redepthChild(this);
    super.redepthChildren();
  }

  @override
  bool get sizedByParent => true;

  bool _needsLayout = true;
  @override
  void markNeedsLayout() {
    _needsLayout = true;
    super.markNeedsLayout();
  }

  @override
  RenderObject? get semanticsParent => _layoutSurrogate;

  @override
  double? computeDryBaseline(BoxConstraints constraints, TextBaseline baseline) {
    final RenderBox? child = this.child;
    if (child == null) {
      return null;
    }
    return _RenderTheaterMixin.baselineForChild(
      child,
      constraints.biggest,
      constraints,
      theater._resolvedAlignment,
      baseline,
    );
  }

  @override
  RenderObject? get debugLayoutParent => _layoutSurrogate;

  void layoutByLayoutSurrogate() {
    assert(!_theaterDoingThisLayout);
    final _RenderTheater? theater = parent as _RenderTheater?;
    if (theater == null || !attached) {
      assert(false, '$this is not attached to parent');
      return;
    }
    if (theater._layingOutSizeDeterminingChild) {
      theater.invokeLayoutCallback((BoxConstraints constraints) {
        markNeedsLayout();
      });
    } else {
      final BoxConstraints theaterConstraints = theater.constraints;
      final Size boxSize =
          theaterConstraints.biggest.isFinite
              ? theaterConstraints.biggest
              // Accessing the theater's size is only unsafe if it is laying out the
              // size-determining child.
              : theater.size;
      super.layout(BoxConstraints.tight(boxSize));
    }
  }

  bool _theaterDoingThisLayout = false;
  @override
  void layout(Constraints constraints, {bool parentUsesSize = false}) {
    assert(_needsLayout == debugNeedsLayout);
    // Only _RenderTheater calls this implementation.
    assert(parent != null);
    final bool scheduleDeferredLayout = _needsLayout || this.constraints != constraints;
    assert(!_theaterDoingThisLayout);
    _theaterDoingThisLayout = true;
    super.layout(constraints, parentUsesSize: parentUsesSize);
    assert(_theaterDoingThisLayout);
    _theaterDoingThisLayout = false;
    _needsLayout = false;
    assert(!debugNeedsLayout);
    if (scheduleDeferredLayout) {
      final _RenderTheater parent = this.parent! as _RenderTheater;
      // Invoking markNeedsLayout as a layout callback allows this node to be
      // merged back to the `PipelineOwner`'s dirty list in the right order, if
      // it's not already dirty. Otherwise this may cause some dirty descendants
      // to performLayout a second time.
      parent.invokeLayoutCallback((BoxConstraints constraints) {
        markNeedsLayout();
      });
    }
  }

  @override
  void performResize() {
    size = constraints.biggest;
  }

  bool _debugMutationsLocked = false;
  @override
  void performLayout() {
    assert(!_debugMutationsLocked);
    if (_theaterDoingThisLayout) {
      _needsLayout = false;
      return;
    }
    assert(() {
      _debugMutationsLocked = true;
      return true;
    }());
    // This method is directly being invoked from `PipelineOwner.flushLayout`,
    // or from `_layoutSurrogate`'s performLayout.
    assert(parent != null);
    final RenderBox? child = this.child;
    if (child == null) {
      _needsLayout = false;
      return;
    }
    assert(constraints.isTight);
    layoutChild(child, constraints);
    assert(() {
      _debugMutationsLocked = false;
      return true;
    }());
    _needsLayout = false;
  }

  @override
  void applyPaintTransform(RenderBox child, Matrix4 transform) {
    final BoxParentData childParentData = child.parentData! as BoxParentData;
    final Offset offset = childParentData.offset;
    transform.translate(offset.dx, offset.dy);
  }
}

// A RenderProxyBox that makes sure its `deferredLayoutChild` has a greater
// depth than itself.
class _RenderLayoutSurrogateProxyBox extends RenderProxyBox {
  _RenderDeferredLayoutBox? _deferredLayoutChild;

  @override
  void redepthChildren() {
    super.redepthChildren();
    final _RenderDeferredLayoutBox? child = _deferredLayoutChild;
    // If child is not attached, this method will be invoked by child's real
    // parent when it's attached.
    if (child != null && child.attached) {
      assert(child.attached);
      redepthChild(child);
    }
  }

  @override
  void performLayout() {
    super.performLayout();
    // Try to layout `_deferredLayoutChild` here now that its configuration
    // and constraints are up-to-date. Additionally, during the very first
    // layout, this makes sure that _deferredLayoutChild is reachable via tree
    // walk.
    _deferredLayoutChild?.layoutByLayoutSurrogate();
  }

  @override
  void visitChildrenForSemantics(RenderObjectVisitor visitor) {
    super.visitChildrenForSemantics(visitor);
    final _RenderDeferredLayoutBox? deferredChild = _deferredLayoutChild;
    if (deferredChild != null) {
      visitor(deferredChild);
    }
  }
}


Instructions for the chapter (Generate content in English unless specified otherwise):
- Start with a clear heading (e.g., `# Chapter 2: OverlayState
`). Use the provided concept name.

- If this is not the first chapter, begin with a brief transition from the previous chapter, referencing it with a proper Markdown link using its name.

- Begin with a high-level motivation explaining what problem this abstraction solves. Start with a central use case as a concrete example. The whole chapter should guide the reader to understand how to solve this use case. Make it very minimal and friendly to beginners.

- If the abstraction is complex, break it down into key concepts. Explain each concept one-by-one in a very beginner-friendly way.

- Explain how to use this abstraction to solve the use case. Give example inputs and outputs for code snippets (if the output isn't values, describe at a high level what will happen).

- Each code block should be BELOW 10 lines! If longer code blocks are needed, break them down into smaller pieces and walk through them one-by-one. Aggresively simplify the code to make it minimal. Use comments to skip non-important implementation details. Each code block should have a beginner friendly explanation right after it.

- Describe the internal implementation to help understand what's under the hood. First provide a non-code or code-light walkthrough on what happens step-by-step when the abstraction is called. It's recommended to use a simple sequenceDiagram with a dummy example - keep it minimal with at most 5 participants to ensure clarity. If participant name has space, use: `participant QP as Query Processing`. .

- Then dive deeper into code for the internal implementation with references to files. Provide example code blocks, but make them similarly simple and beginner-friendly. Explain.

- IMPORTANT: When you need to refer to other core abstractions covered in other chapters, ALWAYS use proper Markdown links like this: [Chapter Title](filename.md). Use the Complete Tutorial Structure above to find the correct filename and the chapter title. Translate the surrounding text.

- Use mermaid diagrams to illustrate complex concepts (```mermaid``` format). .

- Heavily use analogies and examples throughout to help beginners understand.

- End the chapter with a brief conclusion that summarizes what was learned and provides a transition to the next chapter. If there is a next chapter, use a proper Markdown link: [Next Chapter Title](next_chapter_filename).

- Ensure the tone is welcoming and easy for a newcomer to understand.

- Output *only* the Markdown content for this chapter.

Now, directly provide a super beginner-friendly Markdown output (DON'T need ```markdown``` tags):

2025-05-22 23:57:17,485 - INFO - RESPONSE: # Chapter 2: OverlayState

Welcome back! In our [previous chapter](01_overlay_.md), we learned that an `Overlay` acts like a transparent layer on top of our regular UI, managed by powerful widgets like `MaterialApp`. We also saw that this `Overlay` holds a stack of "sheets" called [OverlayEntry](03_overlayentry_.md)s. But who is in charge of managing these sheets? That's where the `OverlayState` comes in.

Think of the `Overlay` as the physical structure (the overhead projector frame) and the `OverlayState` as the person operating that projector. The `OverlayState` is the **manager** for the `Overlay`. Its main job is to keep track of which [OverlayEntry](03_overlayentry_.md) sheets are currently in the stack and decide which ones are visible.

Our goal from the last chapter was to display a simple message box that floats in the center of the screen when a button is pressed. To do this, we need to:

1.  Find the `OverlayState` associated with our `Overlay`.
2.  Create an [OverlayEntry](03_overlayentry_.md) containing our message box widget.
3.  Tell the `OverlayState` to **insert** this [OverlayEntry](03_overlayentry_.md) into its stack.
4.  When we want to hide the message box, tell the `OverlayState` to **remove** the [OverlayEntry](03_overlayentry_.md).

In this chapter, we'll focus on how to use the `OverlayState` to perform these insertions and removals.

### Getting the OverlayState

As we briefly saw in the last chapter, we can get the `OverlayState` using the static method `Overlay.of`. This method looks up the widget tree from the given `BuildContext` and finds the nearest `Overlay` widget's state.

```dart
// Inside a widget where you want to show an overlay:
void showMyMessageBox(BuildContext context) {
  OverlayState? overlayState = Overlay.of(context);
  // Now we have the manager (the OverlayState)!
}
```

Here, `Overlay.of(context)` does the important work of finding the correct `OverlayState` for us. The `context` tells Flutter where in the widget tree we are looking from. In a typical app, this `OverlayState` will be the one managed by your `MaterialApp` or `WidgetsApp`.

### Adding an OverlayEntry

Once we have the `OverlayState`, we can add new entries to it. The `OverlayState` has an `insert` method for this purpose. The `insert` method takes an [OverlayEntry](03_overlayentry_.md) object as its argument.

Let's imagine we have created our `OverlayEntry` object (we'll learn more about [OverlayEntry](03_overlayentry_.md) in the next chapter, for now just assume it exists).

```dart
// Continuing from the previous snippet:
void showMyMessageBox(BuildContext context) {
  OverlayState? overlayState = Overlay.of(context);

  if (overlayState != null) {
    // Assume 'myOverlayEntry' is an instance of OverlayEntry
    // that holds our message box widget.
    OverlayEntry myOverlayEntry = createMessageBoxEntry(); // Placeholder function

    overlayState.insert(myOverlayEntry);
    print('Message box inserted!');
  } else {
    print('Could not find OverlayState!');
  }
}

// Placeholder for creating the OverlayEntry
OverlayEntry createMessageBoxEntry() {
  // This would contain the actual widget for the message box
  return OverlayEntry(
    builder: (context) => Center(
      child: Container(
        width: 200,
        height: 100,
        color: Colors.blue,
        child: Center(child: Text('Hello Overlay!')),
      ),
    ),
  );
}
```

In this code:
1.  We get the `overlayState`.
2.  We check if it's not null (meaning an `Overlay` was found).
3.  We create an `OverlayEntry` (using `createMessageBoxEntry`).
4.  We call `overlayState.insert(myOverlayEntry)`. This is the key step! It tells the `OverlayState` to add our entry to its internal list.

When an `OverlayEntry` is inserted, the `OverlayState` marks itself as needing to rebuild. During the next build cycle, the `OverlayState` will include the widget from your newly inserted [OverlayEntry](03_overlayentry_.md) in its list of visible children, making it appear on top of your UI.

### Ordering OverlayEntries

The `insert` method also allows you to control where the entry is inserted in the stack:

*   `overlayState.insert(entry)`: Inserts the entry at the very top (painted last).
*   `overlayState.insert(entry, below: someOtherEntry)`: Inserts the entry just below `someOtherEntry`.
*   `overlayState.insert(entry, above: someOtherEntry)`: Inserts the entry just above `someOtherEntry`.

This is like deciding whether to place your new transparency sheet on the very top of the stack, or insert it right above or below another specific sheet. This is useful for complex overlays or when integrating with system overlays like dialogs or routes managed by the Navigator.

### Removing an OverlayEntry

Adding entries is only half the story. We also need to be able to remove them. For example, when the user closes our message box, we want to take it off the overlay.

To remove an [OverlayEntry](03_overlayentry_.md), you call the `remove()` method directly on the **[OverlayEntry](03_overlayentry_.md) object itself**, not on the `OverlayState`.

```dart
// Continuing the example, we need to keep track of the inserted entry:
OverlayEntry? currentMessageBoxEntry; // Store the active entry

void showMyMessageBox(BuildContext context) {
  // ... find overlayState ...
  if (overlayState != null) {
    // Create and store the entry before inserting
    currentMessageBoxEntry = createMessageBoxEntry();
    overlayState.insert(currentMessageBoxEntry!); // Insert it
    print('Message box inserted!');

    // Example: Automatically remove after 3 seconds (for demonstration)
    Future.delayed(Duration(seconds: 3), () {
      removeMyMessageBox();
    });

  } else {
    print('Could not find OverlayState!');
  }
}

// Function to remove the message box
void removeMyMessageBox() {
  if (currentMessageBoxEntry != null) {
    currentMessageBoxEntry!.remove(); // Call remove on the entry!
    currentMessageBoxEntry = null; // Clear the stored entry
    print('Message box removed!');
  }
}

// (createMessageBoxEntry function remains the same)
// (Remember to import 'package:flutter/material.dart' for Colors/Container/Text)
```

In this updated code:
1.  We declare `currentMessageBoxEntry` to hold a reference to the [OverlayEntry](03_overlayentry_.md) once it's created and inserted.
2.  When showing the box, we assign the new entry to this variable.
3.  When removing the box (`removeMyMessageBox`), we check if `currentMessageBoxEntry` is not null and call its `remove()` method.
4.  After removing, we set `currentMessageBoxEntry` back to null.

Calling `entry.remove()` tells the `OverlayState` to take that specific [OverlayEntry](03_overlayentry_.md) out of its list. Similar to insertion, the `OverlayState` will then mark itself dirty and rebuild, this time *without* including the widget from the removed entry.

### How OverlayState Manages Entries Internally

Let's look peek under the hood again. We saw in the snippet from the last chapter that `OverlayState` holds a `List<OverlayEntry> _entries`. This is the core list it manages.

When you call `insert`:

```dart
// From overlay.dart -> OverlayState -> insert method (simplified)
void insert(OverlayEntry entry, {OverlayEntry? below, OverlayEntry? above}) {
  // ... asserts ...
  entry._overlay = this; // Internal link back to this OverlayState
  setState(() { // Marks state as dirty, schedules a rebuild
    _entries.insert(_insertionIndex(below, above), entry); // Adds to the list
  });
}
```

*   `entry._overlay = this;`: The [OverlayEntry](03_overlayentry_.md) keeps a reference to the `OverlayState` it belongs to. This is how `entry.remove()` knows *which* `OverlayState` to tell to remove it.
*   `setState(() { ... });`: This is standard Flutter State management. It signals to the framework that the state of the `OverlayState` has changed (`_entries` list is different) and it needs to be rebuilt.
*   `_entries.insert(...)`: This is the actual list manipulation. It adds the `entry` at the calculated position in the internal `_entries` list.

When the `OverlayState` rebuilds, its `build` method creates the UI using the current contents of `_entries`. We saw that it uses a widget called `_Theater` for this:

```dart
// From overlay.dart -> OverlayState -> build method (simplified)
@override
Widget build(BuildContext context) {
  // ... logic to determine visible entries ...
  final List<_OverlayEntryWidget> children = <_OverlayEntryWidget>[];
  // Loop through _entries (and inactive maintainedState entries)
  // and create _OverlayEntryWidget for each.
  return _Theater(
    // ...
    children: children.reversed.toList(growable: false), // Passes the list to _Theater
  );
}
```

The `_Theater` is essentially a specialized container that takes a list of child widgets (built from the [OverlayEntry](03_overlayentry_.md)s) and stacks them on top of each other. The children are given to `_Theater` in reversed order because the `_entries` list is ordered from bottom to top, but a `Stack` (which `_Theater` behaves like) paints children from bottom to top based on their position in the list. So, the last entry in `_entries` (the top-most one) needs to be the last child given to `_Theater`.

Here's a sequence diagram illustrating insertion:

```mermaid
sequenceDiagram
    participant YourWidget
    participant OverlayState
    participant OverlayEntry
    participant Framework as Flutter Framework
    participant _Theater

    YourWidget->>OverlayState: call insert(OverlayEntry)
    OverlayState->>OverlayEntry: set internal _overlay reference
    OverlayState->>OverlayState: add OverlayEntry to _entries list
    OverlayState->>Framework: call setState()
    Framework->>OverlayState: scheduled rebuild
    OverlayState->>OverlayState: call build()
    OverlayState->>OverlayEntry: call builder() to get widget
    OverlayEntry->>OverlayState: return widget
    OverlayState->>_Theater: pass widget as child
    _Theater->>_Theater: layout and paint widget on top
```

When you call `entry.remove()`:

```dart
// From overlay.dart -> OverlayEntry -> remove method (simplified)
void remove() {
  assert(_overlay != null);
  final OverlayState overlay = _overlay!; // Get the associated OverlayState
  _overlay = null; // Clear the internal reference

  // ... schedule markDirty or call directly ...
  overlay._entries.remove(this); // Remove from the OverlayState's list
  overlay._markDirty(); // Tell the OverlayState to rebuild
  // ...
}
```

*   `_overlay!`: Accesses the `OverlayState` that this entry is currently in.
*   `_entries.remove(this);`: The `OverlayEntry` tells its manager (`_overlay`) to remove itself from the list.
*   `overlay._markDirty();`: Calls an internal method on the `OverlayState` to signal that it needs to rebuild.

The diagram for removal is similar to insertion, just in reverse:

```mermaid
sequenceDiagram
    participant YourWidget
    participant OverlayEntry
    participant OverlayState
    participant Framework as Flutter Framework
    participant _Theater

    YourWidget->>OverlayEntry: call remove()
    OverlayEntry->>OverlayState: access internal _overlay reference
    OverlayEntry->>OverlayEntry: clear internal _overlay reference
    OverlayEntry->>OverlayState: remove OverlayEntry from _entries list
    OverlayState->>OverlayState: call _markDirty()
    OverlayState->>Framework: setState() called implicitly
    Framework->>OverlayState: scheduled rebuild
    OverlayState->>OverlayState: call build()
    OverlayState->>_Theater: pass children (without the removed entry)
    _Theater->>_Theater: relayout and repaint (entry disappears)
```

This demonstrates how the `OverlayState` acts as the central hub, maintaining the list and triggering UI updates when the list of [OverlayEntry](03_overlayentry_.md) objects changes.

### Conclusion

In this chapter, we explored the crucial role of the `OverlayState`. We learned that it is the manager for an [Overlay](01_overlay_.md), holding the list of [OverlayEntry](03_overlayentry_.md) objects and controlling their visibility. We saw how to obtain the `OverlayState` using `Overlay.of` and, most importantly, how to use its `insert` method to add [OverlayEntry](03_overlayentry_.md)s to the overlay stack and how to call `remove` directly on an [OverlayEntry](03_overlayentry_.md) to take it out.

We also took a look at the internal workings, seeing how `OverlayState`'s `_entries` list is manipulated and how `setState` triggers a rebuild to update the UI using the [_Theater](06__theater_.md) widget.

Now that we understand the container ([Overlay](01_overlay_.md)) and its manager (`OverlayState`), it's time to delve into the "sheets" themselves: the [OverlayEntry](03_overlayentry_.md). In the next chapter, we'll learn how to create our own [OverlayEntry](03_overlayentry_.md) objects with the specific widgets we want to display on the overlay.

[OverlayEntry](03_overlayentry_.md)
2025-05-22 23:57:17,495 - INFO - PROMPT: 
Write a very beginner-friendly tutorial chapter (in Markdown format) for the project `flutter (overlay.dart)` about the concept: "OverlayEntry
". This is Chapter 3.

Concept Details:
- Name: OverlayEntry

- Description:
An OverlayEntry is like one of the transparent sheets you can put into an Overlay. It holds a single widget that will be displayed on the Overlay. You can add or remove entries to control what pops up on top of your content. Each entry can decide if areas below it are visible (`opaque`) or if it should always be built even if hidden (`maintainState`).


Complete Tutorial Structure:
1. [Overlay
](01_overlay_.md)
2. [OverlayState
](02_overlaystate_.md)
3. [OverlayEntry
](03_overlayentry_.md)
4. [OverlayPortal
](04_overlayportal_.md)
5. [OverlayPortalController
](05_overlayportalcontroller_.md)
6. [_Theater
](06__theater_.md)
7. [_RenderDeferredLayoutBox
](07__renderdeferredlayoutbox_.md)
8. [_OverlayEntryLocation
](08__overlayentrylocation_.md)

Context from previous chapters:
# Chapter 1: Overlay

Welcome to the first chapter of our tutorial on Flutter's `overlay.dart`! In this chapter, we'll introduce you to the fundamental concept of an `Overlay`.

Have you ever seen temporary popups, like dialogs, tooltips that appear over your regular screen content, no matter what's currently displayed? How does Flutter manage to show these elements *on top* of everything else? That's where the `Overlay` comes in!

Think of your Flutter app's user interface as a stack of layers, like transparencies on an overhead projector. Your main screen content is on the bottom layer. When you want to show something *over* that content, without affecting how the main content is arranged, you place it on a new, transparent layer on top. The `Overlay` widget is like the frame of this overhead projector that holds the stack of transparent sheets.

The `Overlay` itself is a widget that sits high up in your app's widget tree, often provided automatically by powerful widgets like `MaterialApp` or `WidgetsApp`. It manages a list of "sheets," called [OverlayEntry](03_overlayentry_.md)s. Each [OverlayEntry](03_overlayentry_.md) can hold a widget, and these widgets will be painted *above* the `Overlay`'s regular content.

So, the core idea is:

**An `Overlay` is a stack of entry points where you can place widgets that should appear on top of your primary UI.**

### Our Goal: Displaying a Simple Overlay

To understand the `Overlay` better, let's imagine we want to display a simple message box that floats in the center of the screen when a button is pressed. This message box should appear above all other content on the screen.

Using the `Overlay` and its related components, we can achieve this. Here's the high-level plan:

1.  Find the nearest `Overlay`.
2.  Create an [OverlayEntry](03_overlayentry_.md) containing our message box widget.
3.  Insert this [OverlayEntry](03_overlayentry_.md) into the `Overlay`'s stack.
4.  When we want to hide the message box, we'll remove the [OverlayEntry](03_overlayentry_.md) from the `Overlay`.

### Finding the Overlay

The `Overlay` is usually introduced by the main app widgets like `MaterialApp`. To interact with this `Overlay`, we need to get its state, which is an [OverlayState](02_overlaystate_.md). We can do this using the `Overlay.of` method, passing the current `BuildContext`.

```dart
// Inside a widget's build method or a function called from it:
OverlayState? overlayState = Overlay.of(context);
```

This code snippet uses `Overlay.of(context)` to look up the closest `OverlayState` in the widget tree above the current `context`. If an `Overlay` is found, it gives us its state (the [OverlayState](02_overlaystate_.md) object) that we can use to manage our overlay entries. If no `Overlay` is found (which is unlikely in a typical `MaterialApp`), it would cause an error in debug mode.

### What's Inside the Overlay?

While we don't see it directly in the minimal code we write, the `Overlay` widget itself contains some interesting pieces to manage its entries.

Let's look at a relevant snippet from the `overlay.dart` file:

```dart
class Overlay extends StatefulWidget {
  // ... other properties and methods

  @override
  OverlayState createState() => OverlayState();
}
```

This shows that the `Overlay` widget creates an [OverlayState](02_overlaystate_.md). This is the object we obtained using `Overlay.of`. The [OverlayState](02_overlaystate_.md) is where the real work of managing the list of [OverlayEntry](03_overlayentry_.md) objects happens.

Further down in the code, we see how the `OverlayState` builds its UI:

```dart
class OverlayState extends State<Overlay> with TickerProviderStateMixin {
  final List<OverlayEntry> _entries = <OverlayEntry>[];

  // ... methods for inserting and removing entries

  @protected
  @override
  Widget build(BuildContext context) {
    // ... logic to determine visible entries
    final List<_OverlayEntryWidget> children = <_OverlayEntryWidget>[];
    // ... populate children based on _entries
    return _Theater(
      // ... properties like skipCount, clipBehavior
      children: children.reversed.toList(growable: false),
    );
  }

  // ... other methods
}
```

This snippet reveals a crucial part: the `OverlayState` holds a list of `_entries` (our [OverlayEntry](03_overlayentry_.md) objects). In its `build` method, it creates a list of `_OverlayEntryWidget`s corresponding to the active entries. These widgets are then passed to a special widget called `_Theater`.

The `_Theater` widget is essentially a specialized `Stack`. It's responsible for laying out and painting the widgets from the [OverlayEntry](03_overlayentry_.md)s on top of each other, similar to how layers are stacked in a `Stack`.

Here's a simplified illustration of the key participants and their relationships in displaying an overlay entry:

```mermaid
sequenceDiagram
    participant YourWidget
    participant OverlayDotOf as Overlay.of(context)
    participant OverlayState
    participant OverlayEntry
    participant _Theater

    YourWidget->>OverlayDotOf: Ask for OverlayState
    OverlayDotOf-->>OverlayState: Return the found OverlayState
    YourWidget->>OverlayState: Create and insert OverlayEntry
    OverlayState->>OverlayEntry: Add entry to internal list
    OverlayState->>OverlayState: Schedule rebuild
    OverlayState->>_Theater: Build _Theater with entries as children
    _Theater->>OverlayEntry: Ask entry to build its widget
    OverlayEntry->>_Theater: Return built widget
    _Theater->>_Theater: Layout and paint entry's widget on top

```

This diagram shows that your widget interacts with the global `Overlay.of` to get the [OverlayState](02_overlaystate_.md). You then use the [OverlayState](02_overlaystate_.md) to manage your [OverlayEntry](03_overlayentry_.md). The [OverlayState](02_overlaystate_.md) internally uses `_Theater` to visually stack the widgets provided by the [OverlayEntry](03_overlayentry_.md)s.

### Conclusion

In this chapter, we introduced the concept of the `Overlay` in Flutter. We learned that it acts as a container for widgets that should appear on top of the regular UI, managing them as a stack of [OverlayEntry](03_overlayentry_.md) objects. We saw how to find the `OverlayState` using `Overlay.of` and got a peek into the internal structure involving `_Theater`.

In the next chapter, we will delve deeper into the [OverlayState](02_overlaystate_.md) and explore how to use its methods to actually insert and remove [OverlayEntry](03_overlayentry_.md) objects, allowing us to finally display our floating message box.

[OverlayState](02_overlaystate_.md)
---
# Chapter 2: OverlayState

Welcome back! In our [previous chapter](01_overlay_.md), we learned that an `Overlay` acts like a transparent layer on top of our regular UI, managed by powerful widgets like `MaterialApp`. We also saw that this `Overlay` holds a stack of "sheets" called [OverlayEntry](03_overlayentry_.md)s. But who is in charge of managing these sheets? That's where the `OverlayState` comes in.

Think of the `Overlay` as the physical structure (the overhead projector frame) and the `OverlayState` as the person operating that projector. The `OverlayState` is the **manager** for the `Overlay`. Its main job is to keep track of which [OverlayEntry](03_overlayentry_.md) sheets are currently in the stack and decide which ones are visible.

Our goal from the last chapter was to display a simple message box that floats in the center of the screen when a button is pressed. To do this, we need to:

1.  Find the `OverlayState` associated with our `Overlay`.
2.  Create an [OverlayEntry](03_overlayentry_.md) containing our message box widget.
3.  Tell the `OverlayState` to **insert** this [OverlayEntry](03_overlayentry_.md) into its stack.
4.  When we want to hide the message box, tell the `OverlayState` to **remove** the [OverlayEntry](03_overlayentry_.md).

In this chapter, we'll focus on how to use the `OverlayState` to perform these insertions and removals.

### Getting the OverlayState

As we briefly saw in the last chapter, we can get the `OverlayState` using the static method `Overlay.of`. This method looks up the widget tree from the given `BuildContext` and finds the nearest `Overlay` widget's state.

```dart
// Inside a widget where you want to show an overlay:
void showMyMessageBox(BuildContext context) {
  OverlayState? overlayState = Overlay.of(context);
  // Now we have the manager (the OverlayState)!
}
```

Here, `Overlay.of(context)` does the important work of finding the correct `OverlayState` for us. The `context` tells Flutter where in the widget tree we are looking from. In a typical app, this `OverlayState` will be the one managed by your `MaterialApp` or `WidgetsApp`.

### Adding an OverlayEntry

Once we have the `OverlayState`, we can add new entries to it. The `OverlayState` has an `insert` method for this purpose. The `insert` method takes an [OverlayEntry](03_overlayentry_.md) object as its argument.

Let's imagine we have created our `OverlayEntry` object (we'll learn more about [OverlayEntry](03_overlayentry_.md) in the next chapter, for now just assume it exists).

```dart
// Continuing from the previous snippet:
void showMyMessageBox(BuildContext context) {
  OverlayState? overlayState = Overlay.of(context);

  if (overlayState != null) {
    // Assume 'myOverlayEntry' is an instance of OverlayEntry
    // that holds our message box widget.
    OverlayEntry myOverlayEntry = createMessageBoxEntry(); // Placeholder function

    overlayState.insert(myOverlayEntry);
    print('Message box inserted!');
  } else {
    print('Could not find OverlayState!');
  }
}

// Placeholder for creating the OverlayEntry
OverlayEntry createMessageBoxEntry() {
  // This would contain the actual widget for the message box
  return OverlayEntry(
    builder: (context) => Center(
      child: Container(
        width: 200,
        height: 100,
        color: Colors.blue,
        child: Center(child: Text('Hello Overlay!')),
      ),
    ),
  );
}
```

In this code:
1.  We get the `overlayState`.
2.  We check if it's not null (meaning an `Overlay` was found).
3.  We create an `OverlayEntry` (using `createMessageBoxEntry`).
4.  We call `overlayState.insert(myOverlayEntry)`. This is the key step! It tells the `OverlayState` to add our entry to its internal list.

When an `OverlayEntry` is inserted, the `OverlayState` marks itself as needing to rebuild. During the next build cycle, the `OverlayState` will include the widget from your newly inserted [OverlayEntry](03_overlayentry_.md) in its list of visible children, making it appear on top of your UI.

### Ordering OverlayEntries

The `insert` method also allows you to control where the entry is inserted in the stack:

*   `overlayState.insert(entry)`: Inserts the entry at the very top (painted last).
*   `overlayState.insert(entry, below: someOtherEntry)`: Inserts the entry just below `someOtherEntry`.
*   `overlayState.insert(entry, above: someOtherEntry)`: Inserts the entry just above `someOtherEntry`.

This is like deciding whether to place your new transparency sheet on the very top of the stack, or insert it right above or below another specific sheet. This is useful for complex overlays or when integrating with system overlays like dialogs or routes managed by the Navigator.

### Removing an OverlayEntry

Adding entries is only half the story. We also need to be able to remove them. For example, when the user closes our message box, we want to take it off the overlay.

To remove an [OverlayEntry](03_overlayentry_.md), you call the `remove()` method directly on the **[OverlayEntry](03_overlayentry_.md) object itself**, not on the `OverlayState`.

```dart
// Continuing the example, we need to keep track of the inserted entry:
OverlayEntry? currentMessageBoxEntry; // Store the active entry

void showMyMessageBox(BuildContext context) {
  // ... find overlayState ...
  if (overlayState != null) {
    // Create and store the entry before inserting
    currentMessageBoxEntry = createMessageBoxEntry();
    overlayState.insert(currentMessageBoxEntry!); // Insert it
    print('Message box inserted!');

    // Example: Automatically remove after 3 seconds (for demonstration)
    Future.delayed(Duration(seconds: 3), () {
      removeMyMessageBox();
    });

  } else {
    print('Could not find OverlayState!');
  }
}

// Function to remove the message box
void removeMyMessageBox() {
  if (currentMessageBoxEntry != null) {
    currentMessageBoxEntry!.remove(); // Call remove on the entry!
    currentMessageBoxEntry = null; // Clear the stored entry
    print('Message box removed!');
  }
}

// (createMessageBoxEntry function remains the same)
// (Remember to import 'package:flutter/material.dart' for Colors/Container/Text)
```

In this updated code:
1.  We declare `currentMessageBoxEntry` to hold a reference to the [OverlayEntry](03_overlayentry_.md) once it's created and inserted.
2.  When showing the box, we assign the new entry to this variable.
3.  When removing the box (`removeMyMessageBox`), we check if `currentMessageBoxEntry` is not null and call its `remove()` method.
4.  After removing, we set `currentMessageBoxEntry` back to null.

Calling `entry.remove()` tells the `OverlayState` to take that specific [OverlayEntry](03_overlayentry_.md) out of its list. Similar to insertion, the `OverlayState` will then mark itself dirty and rebuild, this time *without* including the widget from the removed entry.

### How OverlayState Manages Entries Internally

Let's look peek under the hood again. We saw in the snippet from the last chapter that `OverlayState` holds a `List<OverlayEntry> _entries`. This is the core list it manages.

When you call `insert`:

```dart
// From overlay.dart -> OverlayState -> insert method (simplified)
void insert(OverlayEntry entry, {OverlayEntry? below, OverlayEntry? above}) {
  // ... asserts ...
  entry._overlay = this; // Internal link back to this OverlayState
  setState(() { // Marks state as dirty, schedules a rebuild
    _entries.insert(_insertionIndex(below, above), entry); // Adds to the list
  });
}
```

*   `entry._overlay = this;`: The [OverlayEntry](03_overlayentry_.md) keeps a reference to the `OverlayState` it belongs to. This is how `entry.remove()` knows *which* `OverlayState` to tell to remove it.
*   `setState(() { ... });`: This is standard Flutter State management. It signals to the framework that the state of the `OverlayState` has changed (`_entries` list is different) and it needs to be rebuilt.
*   `_entries.insert(...)`: This is the actual list manipulation. It adds the `entry` at the calculated position in the internal `_entries` list.

When the `OverlayState` rebuilds, its `build` method creates the UI using the current contents of `_entries`. We saw that it uses a widget called `_Theater` for this:

```dart
// From overlay.dart -> OverlayState -> build method (simplified)
@override
Widget build(BuildContext context) {
  // ... logic to determine visible entries ...
  final List<_OverlayEntryWidget> children = <_OverlayEntryWidget>[];
  // Loop through _entries (and inactive maintainedState entries)
  // and create _OverlayEntryWidget for each.
  return _Theater(
    // ...
    children: children.reversed.toList(growable: false), // Passes the list to _Theater
  );
}
```

The `_Theater` is essentially a specialized container that takes a list of child widgets (built from the [OverlayEntry](03_overlayentry_.md)s) and stacks them on top of each other. The children are given to `_Theater` in reversed order because the `_entries` list is ordered from bottom to top, but a `Stack` (which `_Theater` behaves like) paints children from bottom to top based on their position in the list. So, the last entry in `_entries` (the top-most one) needs to be the last child given to `_Theater`.

Here's a sequence diagram illustrating insertion:

```mermaid
sequenceDiagram
    participant YourWidget
    participant OverlayState
    participant OverlayEntry
    participant Framework as Flutter Framework
    participant _Theater

    YourWidget->>OverlayState: call insert(OverlayEntry)
    OverlayState->>OverlayEntry: set internal _overlay reference
    OverlayState->>OverlayState: add OverlayEntry to _entries list
    OverlayState->>Framework: call setState()
    Framework->>OverlayState: scheduled rebuild
    OverlayState->>OverlayState: call build()
    OverlayState->>OverlayEntry: call builder() to get widget
    OverlayEntry->>OverlayState: return widget
    OverlayState->>_Theater: pass widget as child
    _Theater->>_Theater: layout and paint widget on top
```

When you call `entry.remove()`:

```dart
// From overlay.dart -> OverlayEntry -> remove method (simplified)
void remove() {
  assert(_overlay != null);
  final OverlayState overlay = _overlay!; // Get the associated OverlayState
  _overlay = null; // Clear the internal reference

  // ... schedule markDirty or call directly ...
  overlay._entries.remove(this); // Remove from the OverlayState's list
  overlay._markDirty(); // Tell the OverlayState to rebuild
  // ...
}
```

*   `_overlay!`: Accesses the `OverlayState` that this entry is currently in.
*   `_entries.remove(this);`: The `OverlayEntry` tells its manager (`_overlay`) to remove itself from the list.
*   `overlay._markDirty();`: Calls an internal method on the `OverlayState` to signal that it needs to rebuild.

The diagram for removal is similar to insertion, just in reverse:

```mermaid
sequenceDiagram
    participant YourWidget
    participant OverlayEntry
    participant OverlayState
    participant Framework as Flutter Framework
    participant _Theater

    YourWidget->>OverlayEntry: call remove()
    OverlayEntry->>OverlayState: access internal _overlay reference
    OverlayEntry->>OverlayEntry: clear internal _overlay reference
    OverlayEntry->>OverlayState: remove OverlayEntry from _entries list
    OverlayState->>OverlayState: call _markDirty()
    OverlayState->>Framework: setState() called implicitly
    Framework->>OverlayState: scheduled rebuild
    OverlayState->>OverlayState: call build()
    OverlayState->>_Theater: pass children (without the removed entry)
    _Theater->>_Theater: relayout and repaint (entry disappears)
```

This demonstrates how the `OverlayState` acts as the central hub, maintaining the list and triggering UI updates when the list of [OverlayEntry](03_overlayentry_.md) objects changes.

### Conclusion

In this chapter, we explored the crucial role of the `OverlayState`. We learned that it is the manager for an [Overlay](01_overlay_.md), holding the list of [OverlayEntry](03_overlayentry_.md) objects and controlling their visibility. We saw how to obtain the `OverlayState` using `Overlay.of` and, most importantly, how to use its `insert` method to add [OverlayEntry](03_overlayentry_.md)s to the overlay stack and how to call `remove` directly on an [OverlayEntry](03_overlayentry_.md) to take it out.

We also took a look at the internal workings, seeing how `OverlayState`'s `_entries` list is manipulated and how `setState` triggers a rebuild to update the UI using the [_Theater](06__theater_.md) widget.

Now that we understand the container ([Overlay](01_overlay_.md)) and its manager (`OverlayState`), it's time to delve into the "sheets" themselves: the [OverlayEntry](03_overlayentry_.md). In the next chapter, we'll learn how to create our own [OverlayEntry](03_overlayentry_.md) objects with the specific widgets we want to display on the overlay.

[OverlayEntry](03_overlayentry_.md)

Relevant Code Snippets (Code itself remains unchanged):
--- File: packages/flutter/lib/src/widgets/overlay.dart ---
// Copyright 2014 The Flutter Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

/// @docImport 'package:flutter/cupertino.dart';
/// @docImport 'package:flutter/material.dart';
///
/// @docImport 'app.dart';
/// @docImport 'drag_target.dart';
/// @docImport 'implicit_animations.dart';
/// @docImport 'media_query.dart';
/// @docImport 'navigator.dart';
/// @docImport 'routes.dart';
/// @docImport 'scroll_view.dart';
/// @docImport 'sliver.dart';
/// @docImport 'text.dart';
library;

import 'dart:collection';

import 'package:flutter/foundation.dart';
import 'package:flutter/rendering.dart';
import 'package:flutter/scheduler.dart';

import 'basic.dart';
import 'framework.dart';
import 'lookup_boundary.dart';
import 'ticker_provider.dart';

const String _flutterWidgetsLibrary = 'package:flutter/widgets.dart';

// Examples can assume:
// late BuildContext context;

// * OverlayEntry Implementation

/// A place in an [Overlay] that can contain a widget.
///
/// Overlay entries are inserted into an [Overlay] using the
/// [OverlayState.insert] or [OverlayState.insertAll] functions. To find the
/// closest enclosing overlay for a given [BuildContext], use the [Overlay.of]
/// function.
///
/// An overlay entry can be in at most one overlay at a time. To remove an entry
/// from its overlay, call the [remove] function on the overlay entry.
///
/// Because an [Overlay] uses a [Stack] layout, overlay entries can use
/// [Positioned] and [AnimatedPositioned] to position themselves within the
/// overlay.
///
/// For example, [Draggable] uses an [OverlayEntry] to show the drag avatar that
/// follows the user's finger across the screen after the drag begins. Using the
/// overlay to display the drag avatar lets the avatar float over the other
/// widgets in the app. As the user's finger moves, draggable calls
/// [markNeedsBuild] on the overlay entry to cause it to rebuild. In its build,
/// the entry includes a [Positioned] with its top and left property set to
/// position the drag avatar near the user's finger. When the drag is over,
/// [Draggable] removes the entry from the overlay to remove the drag avatar
/// from view.
///
/// By default, if there is an entirely [opaque] entry over this one, then this
/// one will not be included in the widget tree (in particular, stateful widgets
/// within the overlay entry will not be instantiated). To ensure that your
/// overlay entry is still built even if it is not visible, set [maintainState]
/// to true. This is more expensive, so should be done with care. In particular,
/// if widgets in an overlay entry with [maintainState] set to true repeatedly
/// call [State.setState], the user's battery will be drained unnecessarily.
///
/// [OverlayEntry] is a [Listenable] that notifies when the widget built by
/// [builder] is mounted or unmounted, whose exact state can be queried by
/// [mounted]. After the owner of the [OverlayEntry] calls [remove] and then
/// [dispose], the widget may not be immediately removed from the widget tree.
/// As a result listeners of the [OverlayEntry] can get notified for one last
/// time after the [dispose] call, when the widget is eventually unmounted.
///
/// {@macro flutter.widgets.overlayPortalVsOverlayEntry}
///
/// See also:
///
///  * [OverlayPortal], an alternative API for inserting widgets into an
///    [Overlay] using a builder callback.
///  * [Overlay], a stack of entries that can be managed independently.
///  * [OverlayState], the current state of an Overlay.
///  * [WidgetsApp], a convenience widget that wraps a number of widgets that
///    are commonly required for an application.
///  * [MaterialApp], a convenience widget that wraps a number of widgets that
///    are commonly required for Material Design applications.
class OverlayEntry implements Listenable {
  /// Creates an overlay entry.
  ///
  /// To insert the entry into an [Overlay], first find the overlay using
  /// [Overlay.of] and then call [OverlayState.insert]. To remove the entry,
  /// call [remove] on the overlay entry itself.
  OverlayEntry({
    required this.builder,
    bool opaque = false,
    bool maintainState = false,
    this.canSizeOverlay = false,
  }) : _opaque = opaque,
       _maintainState = maintainState {
    if (kFlutterMemoryAllocationsEnabled) {
      _maybeDispatchObjectCreation();
    }
  }

  /// This entry will include the widget built by this builder in the overlay at
  /// the entry's position.
  ///
  /// To cause this builder to be called again, call [markNeedsBuild] on this
  /// overlay entry.
  final WidgetBuilder builder;

  /// Whether this entry occludes the entire overlay.
  ///
  /// If an entry claims to be opaque, then, for efficiency, the overlay will
  /// skip building entries below that entry unless they have [maintainState]
  /// set.
  bool get opaque => _opaque;
  bool _opaque;
  set opaque(bool value) {
    assert(!_disposedByOwner);
    if (_opaque == value) {
      return;
    }
    _opaque = value;
    _overlay?._didChangeEntryOpacity();
  }

  /// Whether this entry must be included in the tree even if there is a fully
  /// [opaque] entry above it.
  ///
  /// By default, if there is an entirely [opaque] entry over this one, then this
  /// one will not be included in the widget tree (in particular, stateful widgets
  /// within the overlay entry will not be instantiated). To ensure that your
  /// overlay entry is still built even if it is not visible, set [maintainState]
  /// to true. This is more expensive, so should be done with care. In particular,
  /// if widgets in an overlay entry with [maintainState] set to true repeatedly
  /// call [State.setState], the user's battery will be drained unnecessarily.
  ///
  /// This is used by the [Navigator] and [Route] objects to ensure that routes
  /// are kept around even when in the background, so that [Future]s promised
  /// from subsequent routes will be handled properly when they complete.
  bool get maintainState => _maintainState;
  bool _maintainState;
  set maintainState(bool value) {
    assert(!_disposedByOwner);
    if (_maintainState == value) {
      return;
    }
    _maintainState = value;
    assert(_overlay != null);
    _overlay!._didChangeEntryOpacity();
  }

  /// Whether the content of this [OverlayEntry] can be used to size the
  /// [Overlay].
  ///
  /// In most situations the overlay sizes itself based on its incoming
  /// constraints to be as large as possible. However, if that would result in
  /// an infinite size, it has to rely on one of its children to size itself. In
  /// this situation, the overlay will consult the topmost non-[Positioned]
  /// overlay entry that has this property set to true, lay it out with the
  /// incoming [BoxConstraints] of the overlay, and force all other
  /// non-[Positioned] overlay entries to have the same size. The [Positioned]
  /// entries are laid out as usual based on the calculated size of the overlay.
  ///
  /// Overlay entries that set this to true must be able to handle unconstrained
  /// [BoxConstraints].
  ///
  /// Setting this to true has no effect if the overlay entry uses a [Positioned]
  /// widget to position itself in the overlay.
  final bool canSizeOverlay;

  /// Whether the [OverlayEntry] is currently mounted in the widget tree.
  ///
  /// The [OverlayEntry] notifies its listeners when this value changes.
  bool get mounted => _overlayEntryStateNotifier?.value != null;

  /// The currently mounted `_OverlayEntryWidgetState` built using this [OverlayEntry].
  ValueNotifier<_OverlayEntryWidgetState?>? _overlayEntryStateNotifier =
      ValueNotifier<_OverlayEntryWidgetState?>(null);

  // TODO(polina-c): stop duplicating code across disposables
  // https://github.com/flutter/flutter/issues/137435
  /// Dispatches event of object creation to [FlutterMemoryAllocations.instance].
  void _maybeDispatchObjectCreation() {
    if (kFlutterMemoryAllocationsEnabled) {
      FlutterMemoryAllocations.instance.dispatchObjectCreated(
        library: _flutterWidgetsLibrary,
        className: '$OverlayEntry',
        object: this,
      );
    }
  }

  @override
  void addListener(VoidCallback listener) {
    assert(!_disposedByOwner);
    _overlayEntryStateNotifier?.addListener(listener);
  }

  @override
  void removeListener(VoidCallback listener) {
    _overlayEntryStateNotifier?.removeListener(listener);
  }

  OverlayState? _overlay;
  final GlobalKey<_OverlayEntryWidgetState> _key = GlobalKey<_OverlayEntryWidgetState>();

  /// Remove this entry from the overlay.
  ///
  /// This should only be called once.
  ///
  /// This method removes this overlay entry from the overlay immediately. The
  /// UI will be updated in the same frame if this method is called before the
  /// overlay rebuild in this frame; otherwise, the UI will be updated in the
  /// next frame. This means that it is safe to call during builds, but also
  /// that if you do call this after the overlay rebuild, the UI will not update
  /// until the next frame (i.e. many milliseconds later).
  void remove() {
    assert(_overlay != null);
    assert(!_disposedByOwner);
    final OverlayState overlay = _overlay!;
    _overlay = null;
    if (!overlay.mounted) {
      return;
    }

    overlay._entries.remove(this);
    if (SchedulerBinding.instance.schedulerPhase == SchedulerPhase.persistentCallbacks) {
      SchedulerBinding.instance.addPostFrameCallback((Duration duration) {
        overlay._markDirty();
      }, debugLabel: 'OverlayEntry.markDirty');
    } else {
      overlay._markDirty();
    }
  }

  /// Cause this entry to rebuild during the next pipeline flush.
  ///
  /// You need to call this function if the output of [builder] has changed.
  void markNeedsBuild() {
    assert(!_disposedByOwner);
    _key.currentState?._markNeedsBuild();
  }

  void _didUnmount() {
    assert(!mounted);
    if (_disposedByOwner) {
      _overlayEntryStateNotifier?.dispose();
      _overlayEntryStateNotifier = null;
    }
  }

  bool _disposedByOwner = false;

  /// Discards any resources used by this [OverlayEntry].
  ///
  /// This method must be called after [remove] if the [OverlayEntry] is
  /// inserted into an [Overlay].
  ///
  /// After this is called, the object is not in a usable state and should be
  /// discarded (calls to [addListener] will throw after the object is disposed).
  /// However, the listeners registered may not be immediately released until
  /// the widget built using this [OverlayEntry] is unmounted from the widget
  /// tree.
  ///
  /// This method should only be called by the object's owner.
  void dispose() {
    assert(!_disposedByOwner);
    assert(
      _overlay == null,
      'An OverlayEntry must first be removed from the Overlay before dispose is called.',
    );
    if (kFlutterMemoryAllocationsEnabled) {
      FlutterMemoryAllocations.instance.dispatchObjectDisposed(object: this);
    }
    _disposedByOwner = true;
    if (!mounted) {
      // If we're still mounted when disposed, then this will be disposed in
      // _didUnmount, to allow notifications to occur until the entry is
      // unmounted.
      _overlayEntryStateNotifier?.dispose();
      _overlayEntryStateNotifier = null;
    }
  }

  @override
  String toString() =>
      '${describeIdentity(this)}(opaque: $opaque; maintainState: $maintainState)${_disposedByOwner ? "(DISPOSED)" : ""}';
}

class _OverlayEntryWidget extends StatefulWidget {
  const _OverlayEntryWidget({
    required Key super.key,
    required this.entry,
    required this.overlayState,
    this.tickerEnabled = true,
  });

  final OverlayEntry entry;
  final OverlayState overlayState;
  final bool tickerEnabled;

  @override
  _OverlayEntryWidgetState createState() => _OverlayEntryWidgetState();
}

class _OverlayEntryWidgetState extends State<_OverlayEntryWidget> {
  late _RenderTheater _theater;

  // Manages the stack of theater children whose paint order are sorted by their
  // _zOrderIndex. The children added by OverlayPortal are added to this linked
  // list, and they will be shown _above_ the OverlayEntry tied to this widget.
  // The children with larger zOrderIndex values (i.e. those called `show`
  // recently) will be painted last.
  //
  // This linked list is lazily created in `_add`, and the entries are added/removed
  // via `_add`/`_remove`, called by OverlayPortals lower in the tree. `_add` or
  // `_remove` does not cause this widget to rebuild, the linked list will be
  // read by _RenderTheater as part of its render child model. This would ideally
  // be in a RenderObject but there may not be RenderObjects between
  // _RenderTheater and the render subtree OverlayEntry builds.
  LinkedList<_OverlayEntryLocation>? _sortedTheaterSiblings;

  // Worst-case O(N), N being the number of children added to the top spot in
  // the same frame. This can be a bit expensive when there's a lot of global
  // key reparenting in the same frame but N is usually a small number.
  void _add(_OverlayEntryLocation child) {
    assert(mounted);
    final LinkedList<_OverlayEntryLocation> children =
        _sortedTheaterSiblings ??= LinkedList<_OverlayEntryLocation>();
    assert(!children.contains(child));
    _OverlayEntryLocation? insertPosition = children.isEmpty ? null : children.last;
    while (insertPosition != null && insertPosition._zOrderIndex > child._zOrderIndex) {
      insertPosition = insertPosition.previous;
    }
    if (insertPosition == null) {
      children.addFirst(child);
    } else {
      insertPosition.insertAfter(child);
    }
    assert(children.contains(child));
  }

  void _remove(_OverlayEntryLocation child) {
    assert(_sortedTheaterSiblings != null);
    final bool wasInCollection = _sortedTheaterSiblings?.remove(child) ?? false;
    assert(wasInCollection);
  }

  // Returns an Iterable that traverse the children in the child model in paint
  // order (from farthest to the user to the closest to the user).
  //
  // The iterator should be safe to use even when the child model is being
  // mutated. The reason for that is it's allowed to add/remove/move deferred
  // children to a _RenderTheater during performLayout, but the affected
  // children don't have to be laid out in the same performLayout call.
  late final Iterable<RenderBox> _paintOrderIterable = _createChildIterable(reversed: false);
  // An Iterable that traverse the children in the child model in
  // hit-test order (from closest to the user to the farthest to the user).
  late final Iterable<RenderBox> _hitTestOrderIterable = _createChildIterable(reversed: true);

  // The following uses sync* because hit-testing is lazy, and LinkedList as a
  // Iterable doesn't support concurrent modification.
  Iterable<RenderBox> _createChildIterable({required bool reversed}) sync* {
    final LinkedList<_OverlayEntryLocation>? children = _sortedTheaterSiblings;
    if (children == null || children.isEmpty) {
      return;
    }
    _OverlayEntryLocation? candidate = reversed ? children.last : children.first;
    while (candidate != null) {
      final RenderBox? renderBox = candidate._overlayChildRenderBox;
      candidate = reversed ? candidate.previous : candidate.next;
      if (renderBox != null) {
        yield renderBox;
      }
    }
  }

  @override
  void initState() {
    super.initState();
    widget.entry._overlayEntryStateNotifier!.value = this;
    _theater = context.findAncestorRenderObjectOfType<_RenderTheater>()!;
    assert(_sortedTheaterSiblings == null);
  }

  @override
  void didUpdateWidget(_OverlayEntryWidget oldWidget) {
    super.didUpdateWidget(oldWidget);
    // OverlayState's build method always returns a RenderObjectWidget _Theater,
    // so it's safe to assume that state equality implies render object equality.
    assert(oldWidget.entry == widget.entry);
    if (oldWidget.overlayState != widget.overlayState) {
      final _RenderTheater newTheater = context.findAncestorRenderObjectOfType<_RenderTheater>()!;
      assert(_theater != newTheater);
      _theater = newTheater;
    }
  }

  @override
  void dispose() {
    widget.entry._overlayEntryStateNotifier?.value = null;
    widget.entry._didUnmount();
    _sortedTheaterSiblings = null;
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    return TickerMode(
      enabled: widget.tickerEnabled,
      child: _RenderTheaterMarker(
        theater: _theater,
        overlayEntryWidgetState: this,
        child: widget.entry.builder(context),
      ),
    );
  }

  void _markNeedsBuild() {
    setState(() {
      /* the state that changed is in the builder */
    });
  }
}

/// A stack of entries that can be managed independently.
///
/// Overlays let independent child widgets "float" visual elements on top of
/// other widgets by inserting them into the overlay's stack. The overlay lets
/// each of these widgets manage their participation in the overlay using
/// [OverlayEntry] objects.
///
/// Although you can create an [Overlay] directly, it's most common to use the
/// overlay created by the [Navigator] in a [WidgetsApp], [CupertinoApp] or a
/// [MaterialApp]. The navigator uses its overlay to manage the visual
/// appearance of its routes.
///
/// The [Overlay] widget uses a custom stack implementation, which is very
/// similar to the [Stack] widget. The main use case of [Overlay] is related to
/// navigation and being able to insert widgets on top of the pages in an app.
/// For layout purposes unrelated to navigation, consider using [Stack] instead.
///
/// An [Overlay] widget requires a [Directionality] widget to be in scope, so
/// that it can resolve direction-sensitive coordinates of any
/// [Positioned.directional] children.
///
/// For widgets drawn in an [OverlayEntry], do not assume that the size of the
/// [Overlay] is the size returned by [MediaQuery.sizeOf]. Nested overlays can
/// have different sizes.
///
/// {@tool dartpad}
/// This example shows how to use the [Overlay] to highlight the [NavigationBar]
/// destination.
///
/// ** See code in examples/api/lib/widgets/overlay/overlay.0.dart **
/// {@end-tool}
///
/// See also:
///
///  * [OverlayEntry], the class that is used for describing the overlay entries.
///  * [OverlayState], which is used to insert the entries into the overlay.
///  * [WidgetsApp], which inserts an [Overlay] widget indirectly via its [Navigator].
///  * [MaterialApp], which inserts an [Overlay] widget indirectly via its [Navigator].
///  * [CupertinoApp], which inserts an [Overlay] widget indirectly via its [Navigator].
///  * [Stack], which allows directly displaying a stack of widgets.
class Overlay extends StatefulWidget {
  /// Creates an overlay.
  ///
  /// The initial entries will be inserted into the overlay when its associated
  /// [OverlayState] is initialized.
  ///
  /// Rather than creating an overlay, consider using the overlay that is
  /// created by the [Navigator] in a [WidgetsApp], [CupertinoApp], or a
  /// [MaterialApp] for the application.
  const Overlay({
    super.key,
    this.initialEntries = const <OverlayEntry>[],
    this.clipBehavior = Clip.hardEdge,
  });

  /// Wrap the provided `child` in an [Overlay] to allow other visual elements
  /// (packed in [OverlayEntry]s) to float on top of the child.
  ///
  /// This is a convenience method over the regular [Overlay] constructor: It
  /// creates an [Overlay] and puts the provided `child` in an [OverlayEntry]
  /// at the bottom of that newly created Overlay.
  static Widget wrap({Key? key, Clip clipBehavior = Clip.hardEdge, required Widget child}) {
    return _WrappingOverlay(key: key, clipBehavior: clipBehavior, child: child);
  }

  /// The entries to include in the overlay initially.
  ///
  /// These entries are only used when the [OverlayState] is initialized. If you
  /// are providing a new [Overlay] description for an overlay that's already in
  /// the tree, then the new entries are ignored.
  ///
  /// To add entries to an [Overlay] that is already in the tree, use
  /// [Overlay.of] to obtain the [OverlayState] (or assign a [GlobalKey] to the
  /// [Overlay] widget and obtain the [OverlayState] via
  /// [GlobalKey.currentState]), and then use [OverlayState.insert] or
  /// [OverlayState.insertAll].
  ///
  /// To remove an entry from an [Overlay], use [OverlayEntry.remove].
  final List<OverlayEntry> initialEntries;

  /// {@macro flutter.material.Material.clipBehavior}
  ///
  /// Defaults to [Clip.hardEdge].
  final Clip clipBehavior;

  /// The [OverlayState] from the closest instance of [Overlay] that encloses
  /// the given context within the closest [LookupBoundary], and, in debug mode,
  /// will throw if one is not found.
  ///
  /// In debug mode, if the `debugRequiredFor` argument is provided and an
  /// overlay isn't found, then this function will throw an exception containing
  /// the runtime type of the given widget in the error message. The exception
  /// attempts to explain that the calling [Widget] (the one given by the
  /// `debugRequiredFor` argument) needs an [Overlay] to be present to function.
  /// If `debugRequiredFor` is not supplied, then the error message is more
  /// generic.
  ///
  /// Typical usage is as follows:
  ///
  /// ```dart
  /// OverlayState overlay = Overlay.of(context);
  /// ```
  ///
  /// If `rootOverlay` is set to true, the state from the furthest instance of
  /// this class is given instead. Useful for installing overlay entries above
  /// all subsequent instances of [Overlay].
  ///
  /// This method can be expensive (it walks the element tree).
  ///
  /// See also:
  ///
  /// * [Overlay.maybeOf] for a similar function that returns null if an
  ///   [Overlay] is not found.
  static OverlayState of(
    BuildContext context, {
    bool rootOverlay = false,
    Widget? debugRequiredFor,
  }) {
    final OverlayState? result = maybeOf(context, rootOverlay: rootOverlay);
    assert(() {
      if (result == null) {
        final bool hiddenByBoundary = LookupBoundary.debugIsHidingAncestorStateOfType<OverlayState>(
          context,
        );
        final List<DiagnosticsNode> information = <DiagnosticsNode>[
          ErrorSummary(
            'No Overlay widget found${hiddenByBoundary ? ' within the closest LookupBoundary' : ''}.',
          ),
          if (hiddenByBoundary)
            ErrorDescription(
              'There is an ancestor Overlay widget, but it is hidden by a LookupBoundary.',
            ),
          ErrorDescription(
            '${debugRequiredFor?.runtimeType ?? 'Some'} widgets require an Overlay widget ancestor for correct operation.',
          ),
          ErrorHint(
            'The most common way to add an Overlay to an application is to include a MaterialApp, CupertinoApp or Navigator widget in the runApp() call.',
          ),
          if (debugRequiredFor != null)
            DiagnosticsProperty<Widget>(
              'The specific widget that failed to find an overlay was',
              debugRequiredFor,
              style: DiagnosticsTreeStyle.errorProperty,
            ),
          if (context.widget != debugRequiredFor)
            context.describeElement(
              'The context from which that widget was searching for an overlay was',
            ),
        ];

        throw FlutterError.fromParts(information);
      }
      return true;
    }());
    return result!;
  }

  /// The [OverlayState] from the closest instance of [Overlay] that encloses
  /// the given context within the closest [LookupBoundary], if any.
  ///
  /// Typical usage is as follows:
  ///
  /// ```dart
  /// OverlayState? overlay = Overlay.maybeOf(context);
  /// ```
  ///
  /// If `rootOverlay` is set to true, the state from the furthest instance of
  /// this class is given instead. Useful for installing overlay entries above
  /// all subsequent instances of [Overlay].
  ///
  /// This method can be expensive (it walks the element tree).
  ///
  /// See also:
  ///
  ///  * [Overlay.of] for a similar function that returns a non-nullable result
  ///    and throws if an [Overlay] is not found.

  static OverlayState? maybeOf(BuildContext context, {bool rootOverlay = false}) {
    return rootOverlay
        ? LookupBoundary.findRootAncestorStateOfType<OverlayState>(context)
        : LookupBoundary.findAncestorStateOfType<OverlayState>(context);
  }

  @override
  OverlayState createState() => OverlayState();
}

/// The current state of an [Overlay].
///
/// Used to insert [OverlayEntry]s into the overlay using the [insert] and
/// [insertAll] functions.
class OverlayState extends State<Overlay> with TickerProviderStateMixin {
  final List<OverlayEntry> _entries = <OverlayEntry>[];

  @protected
  @override
  void initState() {
    super.initState();
    insertAll(widget.initialEntries);
  }

  int _insertionIndex(OverlayEntry? below, OverlayEntry? above) {
    assert(above == null || below == null);
    if (below != null) {
      return _entries.indexOf(below);
    }
    if (above != null) {
      return _entries.indexOf(above) + 1;
    }
    return _entries.length;
  }

  bool _debugCanInsertEntry(OverlayEntry entry) {
    final List<DiagnosticsNode> operandsInformation = <DiagnosticsNode>[
      DiagnosticsProperty<OverlayEntry>(
        'The OverlayEntry was',
        entry,
        style: DiagnosticsTreeStyle.errorProperty,
      ),
      DiagnosticsProperty<OverlayState>(
        'The Overlay the OverlayEntry was trying to insert to was',
        this,
        style: DiagnosticsTreeStyle.errorProperty,
      ),
    ];

    if (!mounted) {
      throw FlutterError.fromParts(<DiagnosticsNode>[
        ErrorSummary('Attempted to insert an OverlayEntry to an already disposed Overlay.'),
        ...operandsInformation,
      ]);
    }

    final OverlayState? currentOverlay = entry._overlay;
    final bool alreadyContainsEntry = _entries.contains(entry);

    if (alreadyContainsEntry) {
      final bool inconsistentOverlayState = !identical(currentOverlay, this);
      throw FlutterError.fromParts(<DiagnosticsNode>[
        ErrorSummary('The specified entry is already present in the target Overlay.'),
        ...operandsInformation,
        if (inconsistentOverlayState)
          ErrorHint('This could be an error in the Flutter framework.')
        else
          ErrorHint(
            'Consider calling remove on the OverlayEntry before inserting it to a different Overlay, '
            'or switching to the OverlayPortal API to avoid manual OverlayEntry management.',
          ),
        if (inconsistentOverlayState)
          DiagnosticsProperty<OverlayState>(
            "The OverlayEntry's current Overlay was",
            currentOverlay,
            style: DiagnosticsTreeStyle.errorProperty,
          ),
      ]);
    }

    if (currentOverlay == null) {
      return true;
    }

    throw FlutterError.fromParts(<DiagnosticsNode>[
      ErrorSummary('The specified entry is already present in a different Overlay.'),
      ...operandsInformation,
      DiagnosticsProperty<OverlayState>(
        "The OverlayEntry's current Overlay was",
        currentOverlay,
        style: DiagnosticsTreeStyle.errorProperty,
      ),
      ErrorHint(
        'Consider calling remove on the OverlayEntry before inserting it to a different Overlay, '
        'or switching to the OverlayPortal API to avoid manual OverlayEntry management.',
      ),
    ]);
  }

  /// Insert the given entry into the overlay.
  ///
  /// If `below` is non-null, the entry is inserted just below `below`.
  /// If `above` is non-null, the entry is inserted just above `above`.
  /// Otherwise, the entry is inserted on top.
  ///
  /// It is an error to specify both `above` and `below`.
  void insert(OverlayEntry entry, {OverlayEntry? below, OverlayEntry? above}) {
    assert(_debugVerifyInsertPosition(above, below));
    assert(_debugCanInsertEntry(entry));
    entry._overlay = this;
    setState(() {
      _entries.insert(_insertionIndex(below, above), entry);
    });
  }

  /// Insert all the entries in the given iterable.
  ///
  /// If `below` is non-null, the entries are inserted just below `below`.
  /// If `above` is non-null, the entries are inserted just above `above`.
  /// Otherwise, the entries are inserted on top.
  ///
  /// It is an error to specify both `above` and `below`.
  void insertAll(Iterable<OverlayEntry> entries, {OverlayEntry? below, OverlayEntry? above}) {
    assert(_debugVerifyInsertPosition(above, below));
    assert(entries.every(_debugCanInsertEntry));
    if (entries.isEmpty) {
      return;
    }
    for (final OverlayEntry entry in entries) {
      assert(entry._overlay == null);
      entry._overlay = this;
    }
    setState(() {
      _entries.insertAll(_insertionIndex(below, above), entries);
    });
  }

  bool _debugVerifyInsertPosition(
    OverlayEntry? above,
    OverlayEntry? below, {
    Iterable<OverlayEntry>? newEntries,
  }) {
    assert(above == null || below == null, 'Only one of `above` and `below` may be specified.');
    assert(
      above == null ||
          (above._overlay == this &&
              _entries.contains(above) &&
              (newEntries?.contains(above) ?? true)),
      'The provided entry used for `above` must be present in the Overlay${newEntries != null ? ' and in the `newEntriesList`' : ''}.',
    );
    assert(
      below == null ||
          (below._overlay == this &&
              _entries.contains(below) &&
              (newEntries?.contains(below) ?? true)),
      'The provided entry used for `below` must be present in the Overlay${newEntries != null ? ' and in the `newEntriesList`' : ''}.',
    );
    return true;
  }

  /// Remove all the entries listed in the given iterable, then reinsert them
  /// into the overlay in the given order.
  ///
  /// Entries mention in `newEntries` but absent from the overlay are inserted
  /// as if with [insertAll].
  ///
  /// Entries not mentioned in `newEntries` but present in the overlay are
  /// positioned as a group in the resulting list relative to the entries that
  /// were moved, as specified by one of `below` or `above`, which, if
  /// specified, must be one of the entries in `newEntries`:
  ///
  /// If `below` is non-null, the group is positioned just below `below`.
  /// If `above` is non-null, the group is positioned just above `above`.
  /// Otherwise, the group is left on top, with all the rearranged entries
  /// below.
  ///
  /// It is an error to specify both `above` and `below`.
  void rearrange(Iterable<OverlayEntry> newEntries, {OverlayEntry? below, OverlayEntry? above}) {
    final List<OverlayEntry> newEntriesList =
        newEntries is List<OverlayEntry> ? newEntries : newEntries.toList(growable: false);
    assert(_debugVerifyInsertPosition(above, below, newEntries: newEntriesList));
    assert(
      newEntriesList.every(
        (OverlayEntry entry) => entry._overlay == null || entry._overlay == this,
      ),
      'One or more of the specified entries are already present in another Overlay.',
    );
    assert(
      newEntriesList.every(
        (OverlayEntry entry) => _entries.indexOf(entry) == _entries.lastIndexOf(entry),
      ),
      'One or more of the specified entries are specified multiple times.',
    );
    if (newEntriesList.isEmpty) {
      return;
    }
    if (listEquals(_entries, newEntriesList)) {
      return;
    }
    final LinkedHashSet<OverlayEntry> old = LinkedHashSet<OverlayEntry>.of(_entries);
    for (final OverlayEntry entry in newEntriesList) {
      entry._overlay ??= this;
    }
    setState(() {
      _entries.clear();
      _entries.addAll(newEntriesList);
      old.removeAll(newEntriesList);
      _entries.insertAll(_insertionIndex(below, above), old);
    });
  }

  void _markDirty() {
    if (mounted) {
      setState(() {});
    }
  }

  /// (DEBUG ONLY) Check whether a given entry is visible (i.e., not behind an
  /// opaque entry).
  ///
  /// This is an O(N) algorithm, and should not be necessary except for debug
  /// asserts. To avoid people depending on it, this function is implemented
  /// only in debug mode, and always returns false in release mode.
  bool debugIsVisible(OverlayEntry entry) {
    bool result = false;
    assert(_entries.contains(entry));
    assert(() {
      for (int i = _entries.length - 1; i > 0; i -= 1) {
        final OverlayEntry candidate = _entries[i];
        if (candidate == entry) {
          result = true;
          break;
        }
        if (candidate.opaque) {
          break;
        }
      }
      return true;
    }());
    return result;
  }

  void _didChangeEntryOpacity() {
    setState(() {
      // We use the opacity of the entry in our build function, which means we
      // our state has changed.
    });
  }

  @protected
  @override
  Widget build(BuildContext context) {
    // This list is filled backwards and then reversed below before
    // it is added to the tree.
    final List<_OverlayEntryWidget> children = <_OverlayEntryWidget>[];
    bool onstage = true;
    int onstageCount = 0;
    for (final OverlayEntry entry in _entries.reversed) {
      if (onstage) {
        onstageCount += 1;
        children.add(_OverlayEntryWidget(key: entry._key, overlayState: this, entry: entry));
        if (entry.opaque) {
          onstage = false;
        }
      } else if (entry.maintainState) {
        children.add(
          _OverlayEntryWidget(
            key: entry._key,
            overlayState: this,
            entry: entry,
            tickerEnabled: false,
          ),
        );
      }
    }
    return _Theater(
      skipCount: children.length - onstageCount,
      clipBehavior: widget.clipBehavior,
      children: children.reversed.toList(growable: false),
    );
  }

  @protected
  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    // TODO(jacobr): use IterableProperty instead as that would
    // provide a slightly more consistent string summary of the List.
    properties.add(DiagnosticsProperty<List<OverlayEntry>>('entries', _entries));
  }
}

class _WrappingOverlay extends StatefulWidget {
  const _WrappingOverlay({super.key, this.clipBehavior = Clip.hardEdge, required this.child});

  final Clip clipBehavior;
  final Widget child;

  @override
  State<_WrappingOverlay> createState() => _WrappingOverlayState();
}

class _WrappingOverlayState extends State<_WrappingOverlay> {
  late final OverlayEntry _entry = OverlayEntry(
    canSizeOverlay: true,
    opaque: true,
    builder: (BuildContext context) {
      return widget.child;
    },
  );

  @override
  void didUpdateWidget(_WrappingOverlay oldWidget) {
    super.didUpdateWidget(oldWidget);
    _entry.markNeedsBuild();
  }

  @override
  void dispose() {
    _entry
      ..remove()
      ..dispose();
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    return Overlay(clipBehavior: widget.clipBehavior, initialEntries: <OverlayEntry>[_entry]);
  }
}

/// Special version of a [Stack], that doesn't layout and render the first
/// [skipCount] children.
///
/// The first [skipCount] children are considered "offstage".
class _Theater extends MultiChildRenderObjectWidget {
  const _Theater({
    this.skipCount = 0,
    this.clipBehavior = Clip.hardEdge,
    required List<_OverlayEntryWidget> super.children,
  }) : assert(skipCount >= 0),
       assert(children.length >= skipCount);

  final int skipCount;

  final Clip clipBehavior;

  @override
  _TheaterElement createElement() => _TheaterElement(this);

  @override
  _RenderTheater createRenderObject(BuildContext context) {
    return _RenderTheater(
      skipCount: skipCount,
      textDirection: Directionality.of(context),
      clipBehavior: clipBehavior,
    );
  }

  @override
  void updateRenderObject(BuildContext context, _RenderTheater renderObject) {
    renderObject
      ..skipCount = skipCount
      ..textDirection = Directionality.of(context)
      ..clipBehavior = clipBehavior;
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties.add(IntProperty('skipCount', skipCount));
  }
}

class _TheaterElement extends MultiChildRenderObjectElement {
  _TheaterElement(_Theater super.widget);

  @override
  _RenderTheater get renderObject => super.renderObject as _RenderTheater;

  @override
  void insertRenderObjectChild(RenderBox child, IndexedSlot<Element?> slot) {
    super.insertRenderObjectChild(child, slot);
    final _TheaterParentData parentData = child.parentData! as _TheaterParentData;
    parentData.overlayEntry =
        ((widget as _Theater).children[slot.index] as _OverlayEntryWidget).entry;
    assert(parentData.overlayEntry != null);
  }

  @override
  void moveRenderObjectChild(
    RenderBox child,
    IndexedSlot<Element?> oldSlot,
    IndexedSlot<Element?> newSlot,
  ) {
    super.moveRenderObjectChild(child, oldSlot, newSlot);
    assert(() {
      final _TheaterParentData parentData = child.parentData! as _TheaterParentData;
      return parentData.overlayEntry ==
          ((widget as _Theater).children[newSlot.index] as _OverlayEntryWidget).entry;
    }());
  }

  @override
  void debugVisitOnstageChildren(ElementVisitor visitor) {
    final _Theater theater = widget as _Theater;
    assert(children.length >= theater.skipCount);
    children.skip(theater.skipCount).forEach(visitor);
  }
}

// A `RenderBox` that sizes itself to its parent's size, implements the stack
// layout algorithm and renders its children in the given `theater`.
mixin _RenderTheaterMixin on RenderBox {
  _RenderTheater get theater;

  Iterable<RenderBox> _childrenInPaintOrder();
  Iterable<RenderBox> _childrenInHitTestOrder();

  @override
  void setupParentData(RenderBox child) {
    if (child.parentData is! StackParentData) {
      child.parentData = StackParentData();
    }
  }

  @override
  double? computeDistanceToActualBaseline(TextBaseline baseline) {
    assert(!debugNeedsLayout);
    BaselineOffset baselineOffset = BaselineOffset.noBaseline;
    for (final RenderBox child in _childrenInPaintOrder()) {
      assert(!child.debugNeedsLayout);
      final StackParentData childParentData = child.parentData! as StackParentData;
      baselineOffset = baselineOffset.minOf(
        BaselineOffset(child.getDistanceToActualBaseline(baseline)) + childParentData.offset.dy,
      );
    }
    return baselineOffset.offset;
  }

  static double? baselineForChild(
    RenderBox child,
    Size theaterSize,
    BoxConstraints nonPositionedChildConstraints,
    Alignment alignment,
    TextBaseline baseline,
  ) {
    final StackParentData childParentData = child.parentData! as StackParentData;
    final BoxConstraints childConstraints =
        childParentData.isPositioned
            ? childParentData.positionedChildConstraints(theaterSize)
            : nonPositionedChildConstraints;
    final double? baselineOffset = child.getDryBaseline(childConstraints, baseline);
    if (baselineOffset == null) {
      return null;
    }
    final double y = switch (childParentData) {
      StackParentData(:final double top?) => top,
      StackParentData(:final double bottom?) =>
        theaterSize.height - bottom - child.getDryLayout(childConstraints).height,
      StackParentData() =>
        alignment.alongOffset(theaterSize - child.getDryLayout(childConstraints) as Offset).dy,
    };
    return baselineOffset + y;
  }

  void layoutChild(RenderBox child, BoxConstraints nonPositionedChildConstraints) {
    final StackParentData childParentData = child.parentData! as StackParentData;
    final Alignment alignment = theater._resolvedAlignment;
    if (!childParentData.isPositioned) {
      child.layout(nonPositionedChildConstraints, parentUsesSize: true);
      childParentData.offset = Offset.zero;
    } else {
      assert(
        child is! _RenderDeferredLayoutBox,
        'all _RenderDeferredLayoutBoxes must be non-positioned children.',
      );
      RenderStack.layoutPositionedChild(child, childParentData, size, alignment);
    }
    assert(child.parentData == childParentData);
  }

  @override
  bool hitTestChildren(BoxHitTestResult result, {required Offset position}) {
    final Iterator<RenderBox> iterator = _childrenInHitTestOrder().iterator;
    bool isHit = false;
    while (!isHit && iterator.moveNext()) {
      final RenderBox child = iterator.current;
      final StackParentData childParentData = child.parentData! as StackParentData;
      final RenderBox localChild = child;
      bool childHitTest(BoxHitTestResult result, Offset position) =>
          localChild.hitTest(result, position: position);
      isHit = result.addWithPaintOffset(
        offset: childParentData.offset,
        position: position,
        hitTest: childHitTest,
      );
    }
    return isHit;
  }

  @override
  void paint(PaintingContext context, Offset offset) {
    for (final RenderBox child in _childrenInPaintOrder()) {
      final StackParentData childParentData = child.parentData! as StackParentData;
      context.paintChild(child, childParentData.offset + offset);
    }
  }
}

class _TheaterParentData extends StackParentData {
  // The OverlayEntry that directly created this child. This field is null for
  // children that are created by an OverlayPortal.
  OverlayEntry? overlayEntry;

  /// A [OverlayPortal] makes its overlay child a render child of an ancestor
  /// [Overlay]. Currently, to make sure the overlay child is painted after its
  /// [OverlayPortal], and before the next [OverlayEntry] (which could be
  /// something that should obstruct the overlay child, such as a [ModalRoute])
  /// in the host [Overlay], the paint order of each overlay child is managed by
  /// the [OverlayEntry] that hosts its [OverlayPortal].
  ///
  /// The following methods are exposed to allow easy access to the overlay
  /// children's render objects whose order is managed by [overlayEntry], in the
  /// right order.

  // _overlayStateMounted is set to null in _OverlayEntryWidgetState's dispose
  // method. This property is only accessed during layout, paint and hit-test so
  // the `value!` should be safe.
  Iterator<RenderBox>? get paintOrderIterator =>
      overlayEntry?._overlayEntryStateNotifier?.value!._paintOrderIterable.iterator;
  Iterator<RenderBox>? get hitTestOrderIterator =>
      overlayEntry?._overlayEntryStateNotifier?.value!._hitTestOrderIterable.iterator;

  // A convenience method for traversing `paintOrderIterator` with a
  // [RenderObjectVisitor].
  void visitOverlayPortalChildrenOnOverlayEntry(RenderObjectVisitor visitor) =>
      overlayEntry?._overlayEntryStateNotifier?.value!._paintOrderIterable.forEach(visitor);
}

class _RenderTheater extends RenderBox
    with ContainerRenderObjectMixin<RenderBox, StackParentData>, _RenderTheaterMixin {
  _RenderTheater({
    List<RenderBox>? children,
    required TextDirection textDirection,
    int skipCount = 0,
    Clip clipBehavior = Clip.hardEdge,
  }) : assert(skipCount >= 0),
       _textDirection = textDirection,
       _skipCount = skipCount,
       _clipBehavior = clipBehavior {
    addAll(children);
  }

  @override
  _RenderTheater get theater => this;

  @override
  void setupParentData(RenderBox child) {
    if (child.parentData is! _TheaterParentData) {
      child.parentData = _TheaterParentData();
    }
  }

  @override
  void attach(PipelineOwner owner) {
    super.attach(owner);
    RenderBox? child = firstChild;
    while (child != null) {
      final _TheaterParentData childParentData = child.parentData! as _TheaterParentData;
      final Iterator<RenderBox>? iterator = childParentData.paintOrderIterator;
      if (iterator != null) {
        while (iterator.moveNext()) {
          iterator.current.attach(owner);
        }
      }
      child = childParentData.nextSibling;
    }
  }

  static void _detachChild(RenderObject child) => child.detach();

  @override
  void detach() {
    super.detach();
    RenderBox? child = firstChild;
    while (child != null) {
      final _TheaterParentData childParentData = child.parentData! as _TheaterParentData;
      childParentData.visitOverlayPortalChildrenOnOverlayEntry(_detachChild);
      child = childParentData.nextSibling;
    }
  }

  @override
  void redepthChildren() => visitChildren(redepthChild);

  Alignment? _alignmentCache;
  Alignment get _resolvedAlignment =>
      _alignmentCache ??= AlignmentDirectional.topStart.resolve(textDirection);

  void _markNeedResolution() {
    _alignmentCache = null;
    markNeedsLayout();
  }

  TextDirection get textDirection => _textDirection;
  TextDirection _textDirection;
  set textDirection(TextDirection value) {
    if (_textDirection == value) {
      return;
    }
    _textDirection = value;
    _markNeedResolution();
  }

  int get skipCount => _skipCount;
  int _skipCount;
  set skipCount(int value) {
    if (_skipCount != value) {
      _skipCount = value;
      markNeedsLayout();
    }
  }

  /// {@macro flutter.material.Material.clipBehavior}
  ///
  /// Defaults to [Clip.hardEdge].
  Clip get clipBehavior => _clipBehavior;
  Clip _clipBehavior = Clip.hardEdge;
  set clipBehavior(Clip value) {
    if (value != _clipBehavior) {
      _clipBehavior = value;
      markNeedsPaint();
      markNeedsSemanticsUpdate();
    }
  }

  // Adding/removing deferred child does not affect the layout of other children,
  // or that of the Overlay, so there's no need to invalidate the layout of the
  // Overlay.
  //
  // When _skipMarkNeedsLayout is true, markNeedsLayout does not do anything.
  bool _skipMarkNeedsLayout = false;
  void _addDeferredChild(_RenderDeferredLayoutBox child) {
    assert(!_skipMarkNeedsLayout);
    _skipMarkNeedsLayout = true;
    adoptChild(child);
    // The Overlay still needs repainting when a deferred child is added. Usually
    // `markNeedsLayout` implies `markNeedsPaint`, but here `markNeedsLayout` is
    // skipped when the `_skipMarkNeedsLayout` flag is set.
    markNeedsPaint();
    _skipMarkNeedsLayout = false;

    // After adding `child` to the render tree, we want to make sure it will be
    // laid out in the same frame. This is done by calling markNeedsLayout on the
    // layout surrogate. This ensures `child` is reachable via tree walk (see
    // _RenderLayoutSurrogateProxyBox.performLayout).
    child._layoutSurrogate.markNeedsLayout();
  }

  void _removeDeferredChild(_RenderDeferredLayoutBox child) {
    assert(!_skipMarkNeedsLayout);
    _skipMarkNeedsLayout = true;
    dropChild(child);
    // The Overlay still needs repainting when a deferred child is dropped. See
    // the comment in `_addDeferredChild`.
    markNeedsPaint();
    _skipMarkNeedsLayout = false;
  }

  @override
  void markNeedsLayout() {
    if (!_skipMarkNeedsLayout) {
      super.markNeedsLayout();
    }
  }

  RenderBox? get _firstOnstageChild {
    if (skipCount == super.childCount) {
      return null;
    }
    RenderBox? child = super.firstChild;
    for (int toSkip = skipCount; toSkip > 0; toSkip--) {
      final StackParentData childParentData = child!.parentData! as StackParentData;
      child = childParentData.nextSibling;
      assert(child != null);
    }
    return child;
  }

  RenderBox? get _lastOnstageChild => skipCount == super.childCount ? null : lastChild;

  @override
  double computeMinIntrinsicWidth(double height) {
    return RenderStack.getIntrinsicDimension(
      _firstOnstageChild,
      (RenderBox child) => child.getMinIntrinsicWidth(height),
    );
  }

  @override
  double computeMaxIntrinsicWidth(double height) {
    return RenderStack.getIntrinsicDimension(
      _firstOnstageChild,
      (RenderBox child) => child.getMaxIntrinsicWidth(height),
    );
  }

  @override
  double computeMinIntrinsicHeight(double width) {
    return RenderStack.getIntrinsicDimension(
      _firstOnstageChild,
      (RenderBox child) => child.getMinIntrinsicHeight(width),
    );
  }

  @override
  double computeMaxIntrinsicHeight(double width) {
    return RenderStack.getIntrinsicDimension(
      _firstOnstageChild,
      (RenderBox child) => child.getMaxIntrinsicHeight(width),
    );
  }

  @override
  double? computeDryBaseline(BoxConstraints constraints, TextBaseline baseline) {
    final Size size =
        constraints.biggest.isFinite
            ? constraints.biggest
            : _findSizeDeterminingChild().getDryLayout(constraints);
    final BoxConstraints nonPositionedChildConstraints = BoxConstraints.tight(size);
    final Alignment alignment = theater._resolvedAlignment;

    BaselineOffset baselineOffset = BaselineOffset.noBaseline;
    for (final RenderBox child in _childrenInPaintOrder()) {
      baselineOffset = baselineOffset.minOf(
        BaselineOffset(
          _RenderTheaterMixin.baselineForChild(
            child,
            size,
            nonPositionedChildConstraints,
            alignment,
            baseline,
          ),
        ),
      );
    }
    return baselineOffset.offset;
  }

  @override
  Size computeDryLayout(BoxConstraints constraints) {
    if (constraints.biggest.isFinite) {
      return constraints.biggest;
    }
    return _findSizeDeterminingChild().getDryLayout(constraints);
  }

  @override
  // The following uses sync* because concurrent modifications should be allowed
  // during layout.
  Iterable<RenderBox> _childrenInPaintOrder() sync* {
    RenderBox? child = _firstOnstageChild;
    while (child != null) {
      yield child;
      final _TheaterParentData childParentData = child.parentData! as _TheaterParentData;
      final Iterator<RenderBox>? innerIterator = childParentData.paintOrderIterator;
      if (innerIterator != null) {
        while (innerIterator.moveNext()) {
          yield innerIterator.current;
        }
      }
      child = childParentData.nextSibling;
    }
  }

  @override
  // The following uses sync* because hit testing should be lazy.
  Iterable<RenderBox> _childrenInHitTestOrder() sync* {
    RenderBox? child = _lastOnstageChild;
    int childLeft = childCount - skipCount;
    while (child != null) {
      final _TheaterParentData childParentData = child.parentData! as _TheaterParentData;
      final Iterator<RenderBox>? innerIterator = childParentData.hitTestOrderIterator;
      if (innerIterator != null) {
        while (innerIterator.moveNext()) {
          yield innerIterator.current;
        }
      }
      yield child;
      childLeft -= 1;
      child = childLeft <= 0 ? null : childParentData.previousSibling;
    }
  }

  @override
  bool get sizedByParent => false;

  bool _layingOutSizeDeterminingChild = false;
  @override
  void performLayout() {
    RenderBox? sizeDeterminingChild;
    if (constraints.biggest.isFinite) {
      size = constraints.biggest;
    } else {
      sizeDeterminingChild = _findSizeDeterminingChild();
      _layingOutSizeDeterminingChild = true;
      layoutChild(sizeDeterminingChild, constraints);
      _layingOutSizeDeterminingChild = false;
      size = sizeDeterminingChild.size;
    }

    // Equivalent to BoxConstraints used by RenderStack for StackFit.expand.
    final BoxConstraints nonPositionedChildConstraints = BoxConstraints.tight(size);
    for (final RenderBox child in _childrenInPaintOrder()) {
      if (child != sizeDeterminingChild) {
        layoutChild(child, nonPositionedChildConstraints);
      }
    }
  }

  RenderBox _findSizeDeterminingChild() {
    RenderBox? child = _lastOnstageChild;
    while (child != null) {
      final _TheaterParentData childParentData = child.parentData! as _TheaterParentData;
      if ((childParentData.overlayEntry?.canSizeOverlay ?? false) &&
          !childParentData.isPositioned) {
        return child;
      }
      child = childParentData.previousSibling;
    }
    throw FlutterError.fromParts(<DiagnosticsNode>[
      ErrorSummary(
        'Overlay was given infinite constraints and cannot be sized by a suitable child.',
      ),
      ErrorDescription(
        'The constraints given to the overlay ($constraints) would result in an illegal '
        'infinite size (${constraints.biggest}). To avoid that, the Overlay tried to size '
        'itself to one of its children, but no suitable non-positioned child that belongs to an '
        'OverlayEntry with canSizeOverlay set to true could be found.',
      ),
      ErrorHint(
        'Try wrapping the Overlay in a SizedBox to give it a finite size or '
        'use an OverlayEntry with canSizeOverlay set to true.',
      ),
    ]);
  }

  final LayerHandle<ClipRectLayer> _clipRectLayer = LayerHandle<ClipRectLayer>();

  @override
  void paint(PaintingContext context, Offset offset) {
    if (clipBehavior != Clip.none) {
      _clipRectLayer.layer = context.pushClipRect(
        needsCompositing,
        offset,
        Offset.zero & size,
        super.paint,
        clipBehavior: clipBehavior,
        oldLayer: _clipRectLayer.layer,
      );
    } else {
      _clipRectLayer.layer = null;
      super.paint(context, offset);
    }
  }

  @override
  void dispose() {
    _clipRectLayer.layer = null;
    super.dispose();
  }

  @override
  void visitChildren(RenderObjectVisitor visitor) {
    RenderBox? child = firstChild;
    while (child != null) {
      visitor(child);
      final _TheaterParentData childParentData = child.parentData! as _TheaterParentData;
      childParentData.visitOverlayPortalChildrenOnOverlayEntry(visitor);
      child = childParentData.nextSibling;
    }
  }

  @override
  void visitChildrenForSemantics(RenderObjectVisitor visitor) {
    RenderBox? child = _firstOnstageChild;
    while (child != null) {
      visitor(child);
      final _TheaterParentData childParentData = child.parentData! as _TheaterParentData;
      child = childParentData.nextSibling;
    }
  }

  @override
  Rect? describeApproximatePaintClip(RenderObject child) {
    switch (clipBehavior) {
      case Clip.none:
        return null;
      case Clip.hardEdge:
      case Clip.antiAlias:
      case Clip.antiAliasWithSaveLayer:
        return Offset.zero & size;
    }
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties.add(IntProperty('skipCount', skipCount));
    properties.add(EnumProperty<TextDirection>('textDirection', textDirection));
  }

  @override
  List<DiagnosticsNode> debugDescribeChildren() {
    final List<DiagnosticsNode> offstageChildren = <DiagnosticsNode>[];
    final List<DiagnosticsNode> onstageChildren = <DiagnosticsNode>[];

    int count = 1;
    bool onstage = false;
    RenderBox? child = firstChild;
    final RenderBox? firstOnstageChild = _firstOnstageChild;
    while (child != null) {
      final _TheaterParentData childParentData = child.parentData! as _TheaterParentData;
      if (child == firstOnstageChild) {
        onstage = true;
        count = 1;
      }

      if (onstage) {
        onstageChildren.add(child.toDiagnosticsNode(name: 'onstage $count'));
      } else {
        offstageChildren.add(
          child.toDiagnosticsNode(name: 'offstage $count', style: DiagnosticsTreeStyle.offstage),
        );
      }

      int subcount = 1;
      childParentData.visitOverlayPortalChildrenOnOverlayEntry((RenderObject renderObject) {
        final RenderBox child = renderObject as RenderBox;
        if (onstage) {
          onstageChildren.add(child.toDiagnosticsNode(name: 'onstage $count - $subcount'));
        } else {
          offstageChildren.add(
            child.toDiagnosticsNode(
              name: 'offstage $count - $subcount',
              style: DiagnosticsTreeStyle.offstage,
            ),
          );
        }
        subcount += 1;
      });

      child = childParentData.nextSibling;
      count += 1;
    }

    return <DiagnosticsNode>[
      ...onstageChildren,
      if (offstageChildren.isNotEmpty)
        ...offstageChildren
      else
        DiagnosticsNode.message('no offstage children', style: DiagnosticsTreeStyle.offstage),
    ];
  }
}

// * OverlayPortal Implementation
//  OverlayPortal is inspired by the
//  [flutter_portal](https://pub.dev/packages/flutter_portal) package.
//
// ** RenderObject hierarchy
// The widget works by inserting its overlay child's render subtree directly
// under [Overlay]'s render object (_RenderTheater).
// https://user-images.githubusercontent.com/31859944/171971838-62ed3975-4b5d-4733-a9c9-f79e263b8fcc.jpg
//
// To ensure the overlay child render subtree does not do layout twice, the
// subtree must only perform layout after both its _RenderTheater and the
// [OverlayPortal]'s render object (_RenderLayoutSurrogateProxyBox) have
// finished layout. This is handled by _RenderDeferredLayoutBox.
//
// ** Z-Index of an overlay child
// [_OverlayEntryLocation] is a (currently private) interface that allows an
// [OverlayPortal] to insert its overlay child into a specific [Overlay], as
// well as specifying the paint order between the overlay child and other
// children of the _RenderTheater.
//
// Since [OverlayPortal] is only allowed to target ancestor [Overlay]s
// (_RenderTheater must finish doing layout before _RenderDeferredLayoutBox),
// the _RenderTheater should typically be acquired using an [InheritedWidget]
// (currently, _RenderTheaterMarker) in case the [OverlayPortal] gets
// reparented.

/// A class to show, hide and bring to top an [OverlayPortal]'s overlay child
/// in the target [Overlay].
///
/// A [OverlayPortalController] can only be given to at most one [OverlayPortal]
/// at a time. When an [OverlayPortalController] is moved from one
/// [OverlayPortal] to another, its [isShowing] state does not carry over.
///
/// [OverlayPortalController.show] and [OverlayPortalController.hide] can be
/// called even before the controller is assigned to any [OverlayPortal], but
/// they typically should not be called while the widget tree is being rebuilt.
class OverlayPortalController {
  /// Creates an [OverlayPortalController], optionally with a String identifier
  /// `debugLabel`.
  OverlayPortalController({String? debugLabel}) : _debugLabel = debugLabel;

  _OverlayPortalState? _attachTarget;

  // A separate _zOrderIndex to allow `show()` or `hide()` to be called when the
  // controller is not yet attached. Once this controller is attached,
  // _attachTarget._zOrderIndex will be used as the source of truth, and this
  // variable will be set to null.
  int? _zOrderIndex;
  final String? _debugLabel;

  static int _wallTime =
      kIsWeb
          ? -9007199254740992 // -2^53
          : -1 << 63;

  // Returns a unique and monotonically increasing timestamp that represents
  // now.
  //
  // The value this method returns increments after each call.
  int _now() {
    final int now = _wallTime += 1;
    assert(_zOrderIndex == null || _zOrderIndex! < now);
    assert(_attachTarget?._zOrderIndex == null || _attachTarget!._zOrderIndex! < now);
    return now;
  }

  /// Show the overlay child of the [OverlayPortal] this controller is attached
  /// to, at the top of the target [Overlay].
  ///
  /// When there are more than one [OverlayPortal]s that target the same
  /// [Overlay], the overlay child of the last [OverlayPortal] to have called
  /// [show] appears at the top level, unobstructed.
  ///
  /// If [isShowing] is already true, calling this method brings the overlay
  /// child it controls to the top.
  ///
  /// This method should typically not be called while the widget tree is being
  /// rebuilt.
  void show() {
    final _OverlayPortalState? state = _attachTarget;
    if (state != null) {
      state.show(_now());
    } else {
      _zOrderIndex = _now();
    }
  }

  /// Hide the [OverlayPortal]'s overlay child.
  ///
  /// Once hidden, the overlay child will be removed from the widget tree the
  /// next time the widget tree rebuilds, and stateful widgets in the overlay
  /// child may lose states as a result.
  ///
  /// This method should typically not be called while the widget tree is being
  /// rebuilt.
  void hide() {
    final _OverlayPortalState? state = _attachTarget;
    if (state != null) {
      state.hide();
    } else {
      assert(_zOrderIndex != null);
      _zOrderIndex = null;
    }
  }

  /// Whether the associated [OverlayPortal] should build and show its overlay
  /// child, using its `overlayChildBuilder`.
  bool get isShowing {
    final _OverlayPortalState? state = _attachTarget;
    return state != null ? state._zOrderIndex != null : _zOrderIndex != null;
  }

  /// Convenience method for toggling the current [isShowing] status.
  ///
  /// This method should typically not be called while the widget tree is being
  /// rebuilt.
  void toggle() => isShowing ? hide() : show();

  @override
  String toString() {
    final String? debugLabel = _debugLabel;
    final String label = debugLabel == null ? '' : '($debugLabel)';
    final String isDetached = _attachTarget != null ? '' : ' DETACHED';
    return '${objectRuntimeType(this, 'OverlayPortalController')}$label$isDetached';
  }
}

/// A widget that renders its overlay child on an [Overlay].
///
/// The overlay child is initially hidden until [OverlayPortalController.show]
/// is called on the associated [controller]. The [OverlayPortal] uses
/// [overlayChildBuilder] to build its overlay child and renders it on the
/// specified [Overlay] as if it was inserted using an [OverlayEntry], while it
/// can depend on the same set of [InheritedWidget]s (such as [Theme]) that this
/// widget can depend on.
///
/// This widget requires an [Overlay] ancestor in the widget tree when its
/// overlay child is showing. The overlay child is rendered by the [Overlay]
/// ancestor, not by the widget itself. This allows the overlay child to float
/// above other widgets, independent of its position in the widget tree.
///
/// When [OverlayPortalController.hide] is called, the widget built using
/// [overlayChildBuilder] will be removed from the widget tree the next time the
/// widget rebuilds. Stateful descendants in the overlay child subtree may lose
/// states as a result.
///
/// {@tool dartpad}
/// This example uses an [OverlayPortal] to build a tooltip that becomes visible
/// when the user taps on the [child] widget. There's a [DefaultTextStyle] above
/// the [OverlayPortal] controlling the [TextStyle] of both the [child] widget
/// and the widget [overlayChildBuilder] builds, which isn't otherwise doable if
/// the tooltip was added as an [OverlayEntry].
///
/// ** See code in examples/api/lib/widgets/overlay/overlay_portal.0.dart **
/// {@end-tool}
///
/// ### Paint Order
///
/// In an [Overlay], an overlay child is painted after the [OverlayEntry]
/// associated with its [OverlayPortal] (that is, the [OverlayEntry] closest to
/// the [OverlayPortal] in the widget tree, which usually represents the
/// enclosing [Route]), and before the next [OverlayEntry].
///
/// When an [OverlayEntry] has multiple associated [OverlayPortal]s, the paint
/// order between their overlay children is the order in which
/// [OverlayPortalController.show] was called. The last [OverlayPortal] to have
/// called `show` gets to paint its overlay child in the foreground.
///
/// ### Semantics
///
/// The semantics subtree generated by the overlay child is considered attached
/// to [OverlayPortal] instead of the target [Overlay]. An [OverlayPortal]'s
/// semantics subtree can be dropped from the semantics tree due to invisibility
/// while the overlay child is still visible (for example, when the
/// [OverlayPortal] is completely invisible in a [ListView] but kept alive by
/// a [KeepAlive] widget). When this happens the semantics subtree generated by
/// the overlay child is also dropped, even if the overlay child is still visible
/// on screen.
///
/// {@template flutter.widgets.overlayPortalVsOverlayEntry}
/// ### Differences between [OverlayPortal] and [OverlayEntry]
///
/// The main difference between [OverlayEntry] and [OverlayPortal] is that
/// [OverlayEntry] builds its widget subtree as a child of the target [Overlay],
/// while [OverlayPortal] uses [OverlayPortal.overlayChildBuilder] to build a
/// child widget of itself. This allows [OverlayPortal]'s overlay child to depend
/// on the same set of [InheritedWidget]s as [OverlayPortal], and it's also
/// guaranteed that the overlay child will not outlive its [OverlayPortal].
///
/// On the other hand, [OverlayPortal]'s implementation is more complex. For
/// instance, it does a bit more work than a regular widget during global key
/// reparenting. If the content to be shown on the [Overlay] doesn't benefit
/// from being a part of [OverlayPortal]'s subtree, consider using an
/// [OverlayEntry] instead.
/// {@endtemplate}
///
/// See also:
///
///  * [OverlayEntry], an alternative API for inserting widgets into an
///    [Overlay].
///  * [Positioned], which can be used to size and position the overlay child in
///    relation to the target [Overlay]'s boundaries.
///  * [CompositedTransformFollower], which can be used to position the overlay
///    child in relation to the linked [CompositedTransformTarget] widget.
class OverlayPortal extends StatefulWidget {
  /// Creates an [OverlayPortal] that renders the widget [overlayChildBuilder]
  /// builds on the closest [Overlay] when [OverlayPortalController.show] is
  /// called.
  const OverlayPortal({
    super.key,
    required this.controller,
    required this.overlayChildBuilder,
    this.child,
  }) : _targetRootOverlay = false;

  /// Creates an [OverlayPortal] that renders the widget [overlayChildBuilder]
  /// builds on the root [Overlay] when [OverlayPortalController.show] is
  /// called.
  const OverlayPortal.targetsRootOverlay({
    super.key,
    required this.controller,
    required this.overlayChildBuilder,
    this.child,
  }) : _targetRootOverlay = true;

  /// The controller to show, hide and bring to top the overlay child.
  final OverlayPortalController controller;

  /// A [WidgetBuilder] used to build a widget below this widget in the tree,
  /// that renders on the closest [Overlay].
  ///
  /// The said widget will only be built and shown in the closest [Overlay] once
  /// [OverlayPortalController.show] is called on the associated [controller].
  /// It will be painted in front of the [OverlayEntry] closest to this widget
  /// in the widget tree (which is usually the enclosing [Route]).
  ///
  /// The built overlay child widget is inserted below this widget in the widget
  /// tree, allowing it to depend on [InheritedWidget]s above it, and be
  /// notified when the [InheritedWidget]s change.
  ///
  /// Unlike [child], the built overlay child can visually extend outside the
  /// bounds of this widget without being clipped, and receive hit-test events
  /// outside of this widget's bounds, as long as it does not extend outside of
  /// the [Overlay] on which it is rendered.
  final WidgetBuilder overlayChildBuilder;

  /// A widget below this widget in the tree.
  final Widget? child;

  final bool _targetRootOverlay;

  @override
  State<OverlayPortal> createState() => _OverlayPortalState();
}

class _OverlayPortalState extends State<OverlayPortal> {
  int? _zOrderIndex;
  // The location of the overlay child within the overlay. This object will be
  // used as the slot of the overlay child widget.
  //
  // The developer must call `show` to reveal the overlay so we can get a unique
  // timestamp of the user interaction for determining the z-index of the
  // overlay child in the overlay.
  //
  // Avoid invalidating the cache if possible, since the framework uses `==` to
  // compare slots, and _OverlayEntryLocation can't override that operator since
  // it's mutable. Changing slots can be relatively slow.
  bool _childModelMayHaveChanged = true;
  _OverlayEntryLocation? _locationCache;
  static bool _isTheSameLocation(_OverlayEntryLocation locationCache, _RenderTheaterMarker marker) {
    return locationCache._childModel == marker.overlayEntryWidgetState &&
        locationCache._theater == marker.theater;
  }

  _OverlayEntryLocation _getLocation(int zOrderIndex, bool targetRootOverlay) {
    final _OverlayEntryLocation? cachedLocation = _locationCache;
    late final _RenderTheaterMarker marker = _RenderTheaterMarker.of(
      context,
      targetRootOverlay: targetRootOverlay,
    );
    final bool isCacheValid =
        cachedLocation != null &&
        (!_childModelMayHaveChanged || _isTheSameLocation(cachedLocation, marker));
    _childModelMayHaveChanged = false;
    if (isCacheValid) {
      assert(cachedLocation._zOrderIndex == zOrderIndex);
      assert(cachedLocation._debugIsLocationValid());
      return cachedLocation;
    }
    // Otherwise invalidate the cache and create a new location.
    cachedLocation?._debugMarkLocationInvalid();
    final _OverlayEntryLocation newLocation = _OverlayEntryLocation(
      zOrderIndex,
      marker.overlayEntryWidgetState,
      marker.theater,
    );
    assert(newLocation._zOrderIndex == zOrderIndex);
    return _locationCache = newLocation;
  }

  @override
  void initState() {
    super.initState();
    _setupController(widget.controller);
  }

  void _setupController(OverlayPortalController controller) {
    assert(
      controller._attachTarget == null || controller._attachTarget == this,
      'Failed to attach $controller to $this. It is already attached to ${controller._attachTarget}.',
    );
    final int? controllerZOrderIndex = controller._zOrderIndex;
    final int? zOrderIndex = _zOrderIndex;
    if (zOrderIndex == null ||
        (controllerZOrderIndex != null && controllerZOrderIndex > zOrderIndex)) {
      _zOrderIndex = controllerZOrderIndex;
    }
    controller._zOrderIndex = null;
    controller._attachTarget = this;
  }

  @override
  void didChangeDependencies() {
    super.didChangeDependencies();
    _childModelMayHaveChanged = true;
  }

  @override
  void didUpdateWidget(OverlayPortal oldWidget) {
    super.didUpdateWidget(oldWidget);
    _childModelMayHaveChanged =
        _childModelMayHaveChanged || oldWidget._targetRootOverlay != widget._targetRootOverlay;
    if (oldWidget.controller != widget.controller) {
      oldWidget.controller._attachTarget = null;
      _setupController(widget.controller);
    }
  }

  @override
  void dispose() {
    assert(widget.controller._attachTarget == this);
    widget.controller._attachTarget = null;
    _locationCache?._debugMarkLocationInvalid();
    _locationCache = null;
    super.dispose();
  }

  void show(int zOrderIndex) {
    assert(
      SchedulerBinding.instance.schedulerPhase != SchedulerPhase.persistentCallbacks,
      '${widget.controller.runtimeType}.show() should not be called during build.',
    );
    setState(() {
      _zOrderIndex = zOrderIndex;
    });
    _locationCache?._debugMarkLocationInvalid();
    _locationCache = null;
  }

  void hide() {
    assert(SchedulerBinding.instance.schedulerPhase != SchedulerPhase.persistentCallbacks);
    setState(() {
      _zOrderIndex = null;
    });
    _locationCache?._debugMarkLocationInvalid();
    _locationCache = null;
  }

  @override
  Widget build(BuildContext context) {
    final int? zOrderIndex = _zOrderIndex;
    if (zOrderIndex == null) {
      return _OverlayPortal(overlayLocation: null, overlayChild: null, child: widget.child);
    }
    return _OverlayPortal(
      overlayLocation: _getLocation(zOrderIndex, widget._targetRootOverlay),
      overlayChild: _DeferredLayout(child: Builder(builder: widget.overlayChildBuilder)),
      child: widget.child,
    );
  }
}

/// A location in an [Overlay].
///
/// An [_OverlayEntryLocation] determines the [Overlay] the associated
/// [OverlayPortal] should put its overlay child onto, as well as the overlay
/// child's paint order in relation to other contents painted on the [Overlay].
//
// An _OverlayEntryLocation is a cursor pointing to a location in a particular
// Overlay's child model, and provides methods to insert/remove/move a
// _RenderDeferredLayoutBox to/from its target _theater.
//
// The occupant (a `RenderBox`) will be painted above the associated
// [OverlayEntry], but below the [OverlayEntry] above that [OverlayEntry].
//
// Additionally, `_activate` and `_deactivate` are called when the overlay
// child's `_OverlayPortalElement` activates/deactivates (for instance, during
// global key reparenting).
// `_OverlayPortalElement` removes its overlay child's render object from the
// target `_RenderTheater` when it deactivates and puts it back on `activated`.
// These 2 methods can be used to "hide" a child in the child model without
// removing it, when the child is expensive/difficult to re-insert at the
// correct location on `activated`.
//
// ### Equality
//
// An `_OverlayEntryLocation` will be used as an Element's slot. These 3 parts
// uniquely identify a place in an overlay's child model:
// - _theater
// - _childModel (the OverlayEntry)
// - _zOrderIndex
//
// Since it can't implement operator== (it's mutable), the same `_OverlayEntryLocation`
// instance must not be used to represent more than one locations.
final class _OverlayEntryLocation extends LinkedListEntry<_OverlayEntryLocation> {
  _OverlayEntryLocation(this._zOrderIndex, this._childModel, this._theater);

  final int _zOrderIndex;
  final _OverlayEntryWidgetState _childModel;
  final _RenderTheater _theater;

  _RenderDeferredLayoutBox? _overlayChildRenderBox;
  void _addToChildModel(_RenderDeferredLayoutBox child) {
    assert(
      _overlayChildRenderBox == null,
      'Failed to add $child. This location ($this) is already occupied by $_overlayChildRenderBox.',
    );
    _overlayChildRenderBox = child;
    _childModel._add(this);
    _theater.markNeedsPaint();
    _theater.markNeedsCompositingBitsUpdate();
    _theater.markNeedsSemanticsUpdate();
  }

  void _removeFromChildModel(_RenderDeferredLayoutBox child) {
    assert(child == _overlayChildRenderBox);
    _overlayChildRenderBox = null;
    assert(_childModel._sortedTheaterSiblings?.contains(this) ?? false);
    _childModel._remove(this);
    _theater.markNeedsPaint();
    _theater.markNeedsCompositingBitsUpdate();
    _theater.markNeedsSemanticsUpdate();
  }

  void _addChild(_RenderDeferredLayoutBox child) {
    assert(_debugIsLocationValid());
    _addToChildModel(child);
    _theater._addDeferredChild(child);
    assert(child.parent == _theater);
  }

  void _removeChild(_RenderDeferredLayoutBox child) {
    // This call is allowed even when this location is disposed.
    _removeFromChildModel(child);
    _theater._removeDeferredChild(child);
    assert(child.parent == null);
  }

  void _moveChild(_RenderDeferredLayoutBox child, _OverlayEntryLocation fromLocation) {
    assert(fromLocation != this);
    assert(_debugIsLocationValid());
    final _RenderTheater fromTheater = fromLocation._theater;
    final _OverlayEntryWidgetState fromModel = fromLocation._childModel;

    if (fromTheater != _theater) {
      fromTheater._removeDeferredChild(child);
      _theater._addDeferredChild(child);
    }

    if (fromModel != _childModel || fromLocation._zOrderIndex != _zOrderIndex) {
      fromLocation._removeFromChildModel(child);
      _addToChildModel(child);
    }
  }

  void _activate(_RenderDeferredLayoutBox child) {
    // This call is allowed even when this location is invalidated.
    // See _OverlayPortalElement.activate.
    assert(_overlayChildRenderBox == null, '$_overlayChildRenderBox');
    _theater._addDeferredChild(child);
    _overlayChildRenderBox = child;
  }

  void _deactivate(_RenderDeferredLayoutBox child) {
    // This call is allowed even when this location is invalidated.
    _theater._removeDeferredChild(child);
    _overlayChildRenderBox = null;
  }

  // Throws a StateError if this location is already invalidated and shouldn't
  // be used as an OverlayPortal slot. Must be used in asserts.
  //
  // Generally, `assert(_debugIsLocationValid())` should be used to prevent
  // invalid accesses to an invalid `_OverlayEntryLocation` object. Exceptions
  // to this rule are _removeChild, _deactivate, which will be called when the
  // OverlayPortal is being removed from the widget tree and may use the
  // location information to perform cleanup tasks.
  //
  // Another exception is the _activate method which is called by
  // _OverlayPortalElement.activate. See the comment in _OverlayPortalElement.activate.
  bool _debugIsLocationValid() {
    if (_debugMarkLocationInvalidStackTrace == null) {
      return true;
    }
    throw StateError(
      '$this is already disposed. Stack trace: $_debugMarkLocationInvalidStackTrace',
    );
  }

  // The StackTrace of the first _debugMarkLocationInvalid call. It's only for
  // debugging purposes and the StackTrace will only be captured in debug builds.
  //
  // The effect of this method is not reversible. Once marked invalid, this
  // object can't be marked as valid again.
  StackTrace? _debugMarkLocationInvalidStackTrace;
  @mustCallSuper
  void _debugMarkLocationInvalid() {
    assert(_debugIsLocationValid());
    assert(() {
      _debugMarkLocationInvalidStackTrace = StackTrace.current;
      return true;
    }());
  }

  @override
  String toString() =>
      '${objectRuntimeType(this, '_OverlayEntryLocation')}[${shortHash(this)}] ${_debugMarkLocationInvalidStackTrace != null ? "(INVALID)" : ""}';
}

class _RenderTheaterMarker extends InheritedWidget {
  const _RenderTheaterMarker({
    required this.theater,
    required this.overlayEntryWidgetState,
    required super.child,
  });

  final _RenderTheater theater;
  final _OverlayEntryWidgetState overlayEntryWidgetState;

  @override
  bool updateShouldNotify(_RenderTheaterMarker oldWidget) {
    return oldWidget.theater != theater ||
        oldWidget.overlayEntryWidgetState != overlayEntryWidgetState;
  }

  static _RenderTheaterMarker of(BuildContext context, {bool targetRootOverlay = false}) {
    final _RenderTheaterMarker? marker;
    if (targetRootOverlay) {
      final InheritedElement? ancestor = _rootRenderTheaterMarkerOf(
        context.getElementForInheritedWidgetOfExactType<_RenderTheaterMarker>(),
      );
      assert(ancestor == null || ancestor.widget is _RenderTheaterMarker);
      marker =
          ancestor != null
              ? context.dependOnInheritedElement(ancestor) as _RenderTheaterMarker?
              : null;
    } else {
      marker = context.dependOnInheritedWidgetOfExactType<_RenderTheaterMarker>();
    }
    if (marker != null) {
      return marker;
    }
    throw FlutterError.fromParts(<DiagnosticsNode>[
      ErrorSummary('No Overlay widget found.'),
      ErrorDescription(
        '${context.widget.runtimeType} widgets require an Overlay widget ancestor.\n'
        'An overlay lets widgets float on top of other widget children.',
      ),
      ErrorHint(
        'To introduce an Overlay widget, you can either directly '
        'include one, or use a widget that contains an Overlay itself, '
        'such as a Navigator, WidgetApp, MaterialApp, or CupertinoApp.',
      ),
      ...context.describeMissingAncestor(expectedAncestorType: Overlay),
    ]);
  }

  static InheritedElement? _rootRenderTheaterMarkerOf(InheritedElement? theaterMarkerElement) {
    assert(theaterMarkerElement == null || theaterMarkerElement.widget is _RenderTheaterMarker);
    if (theaterMarkerElement == null) {
      return null;
    }
    InheritedElement? ancestor;
    theaterMarkerElement.visitAncestorElements((Element element) {
      ancestor = element.getElementForInheritedWidgetOfExactType<_RenderTheaterMarker>();
      return false;
    });
    return ancestor == null ? theaterMarkerElement : _rootRenderTheaterMarkerOf(ancestor);
  }
}

class _OverlayPortal extends RenderObjectWidget {
  /// Creates a widget that renders the given [overlayChild] in the [Overlay]
  /// specified by `overlayLocation`.
  ///
  /// The `overlayLocation` parameter must not be null when [overlayChild] is not
  /// null.
  _OverlayPortal({required this.overlayLocation, required this.overlayChild, required this.child})
    : assert(overlayChild == null || overlayLocation != null),
      assert(overlayLocation == null || overlayLocation._debugIsLocationValid());

  final Widget? overlayChild;

  /// A widget below this widget in the tree.
  final Widget? child;

  final _OverlayEntryLocation? overlayLocation;

  @override
  RenderObjectElement createElement() => _OverlayPortalElement(this);

  @override
  RenderObject createRenderObject(BuildContext context) => _RenderLayoutSurrogateProxyBox();
}

class _OverlayPortalElement extends RenderObjectElement {
  _OverlayPortalElement(_OverlayPortal super.widget);

  @override
  _RenderLayoutSurrogateProxyBox get renderObject =>
      super.renderObject as _RenderLayoutSurrogateProxyBox;

  Element? _overlayChild;
  Element? _child;

  @override
  void mount(Element? parent, Object? newSlot) {
    super.mount(parent, newSlot);
    final _OverlayPortal widget = this.widget as _OverlayPortal;
    _child = updateChild(_child, widget.child, null);
    _overlayChild = updateChild(_overlayChild, widget.overlayChild, widget.overlayLocation);
  }

  @override
  void update(_OverlayPortal newWidget) {
    super.update(newWidget);
    _child = updateChild(_child, newWidget.child, null);
    _overlayChild = updateChild(_overlayChild, newWidget.overlayChild, newWidget.overlayLocation);
  }

  @override
  void forgetChild(Element child) {
    // The _overlayChild Element does not have a key because the _DeferredLayout
    // widget does not take a Key, so only the regular _child can be taken
    // during global key reparenting.
    assert(child == _child);
    _child = null;
    super.forgetChild(child);
  }

  @override
  void visitChildren(ElementVisitor visitor) {
    final Element? child = _child;
    final Element? overlayChild = _overlayChild;
    if (child != null) {
      visitor(child);
    }
    if (overlayChild != null) {
      visitor(overlayChild);
    }
  }

  @override
  void activate() {
    super.activate();
    final _RenderDeferredLayoutBox? box = _overlayChild?.renderObject as _RenderDeferredLayoutBox?;
    if (box != null) {
      assert(!box.attached);
      assert(renderObject._deferredLayoutChild == box);
      // updateChild has not been called at this point so the RenderTheater in
      // the overlay location could be detached. Adding children to a detached
      // RenderObject is still allowed however this isn't the most efficient.
      (_overlayChild!.slot! as _OverlayEntryLocation)._activate(box);
    }
  }

  @override
  void deactivate() {
    // Instead of just detaching the render objects, removing them from the
    // render subtree entirely. This is a workaround for the
    // !renderObject.attached assert in the `super.deactivate()` method.
    final _RenderDeferredLayoutBox? box = _overlayChild?.renderObject as _RenderDeferredLayoutBox?;
    if (box != null) {
      (_overlayChild!.slot! as _OverlayEntryLocation)._deactivate(box);
    }
    super.deactivate();
  }

  @override
  void insertRenderObjectChild(RenderBox child, _OverlayEntryLocation? slot) {
    assert(child.parent == null, "$child's parent is not null: ${child.parent}");
    if (slot != null) {
      renderObject._deferredLayoutChild = child as _RenderDeferredLayoutBox;
      slot._addChild(child);
      renderObject.markNeedsSemanticsUpdate();
    } else {
      renderObject.child = child;
    }
  }

  // The [_DeferredLayout] widget does not have a key so there will be no
  // reparenting between _overlayChild and _child, thus the non-null-typed slots.
  @override
  void moveRenderObjectChild(
    _RenderDeferredLayoutBox child,
    _OverlayEntryLocation oldSlot,
    _OverlayEntryLocation newSlot,
  ) {
    assert(newSlot._debugIsLocationValid());
    newSlot._moveChild(child, oldSlot);
    renderObject.markNeedsSemanticsUpdate();
  }

  @override
  void removeRenderObjectChild(RenderBox child, _OverlayEntryLocation? slot) {
    if (slot == null) {
      renderObject.child = null;
      return;
    }
    assert(renderObject._deferredLayoutChild == child);
    slot._removeChild(child as _RenderDeferredLayoutBox);
    renderObject._deferredLayoutChild = null;
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties.add(DiagnosticsProperty<Element>('child', _child, defaultValue: null));
    properties.add(DiagnosticsProperty<Element>('overlayChild', _overlayChild, defaultValue: null));
    properties.add(
      DiagnosticsProperty<Object>('overlayLocation', _overlayChild?.slot, defaultValue: null),
    );
  }
}

class _DeferredLayout extends SingleChildRenderObjectWidget {
  const _DeferredLayout({
    // This widget must not be given a key: we currently do not support
    // reparenting between the overlayChild and child.
    required Widget child,
  }) : super(child: child);

  _RenderLayoutSurrogateProxyBox getLayoutParent(BuildContext context) {
    return context.findAncestorRenderObjectOfType<_RenderLayoutSurrogateProxyBox>()!;
  }

  @override
  _RenderDeferredLayoutBox createRenderObject(BuildContext context) {
    final _RenderLayoutSurrogateProxyBox parent = getLayoutParent(context);
    final _RenderDeferredLayoutBox renderObject = _RenderDeferredLayoutBox(parent);
    parent._deferredLayoutChild = renderObject;
    return renderObject;
  }

  @override
  void updateRenderObject(BuildContext context, _RenderDeferredLayoutBox renderObject) {
    assert(renderObject._layoutSurrogate == getLayoutParent(context));
    assert(getLayoutParent(context)._deferredLayoutChild == renderObject);
  }
}

// A `RenderProxyBox` that defers its layout until its `_layoutSurrogate` (which
// is not necessarily an ancestor of this RenderBox, but shares at least one
// `_RenderTheater` ancestor with this RenderBox) is laid out.
//
// This `RenderObject` must be a child of a `_RenderTheater`. It guarantees that:
//
// 1. It's a relayout boundary, so calling `markNeedsLayout` on it never dirties
//    its `_RenderTheater`.
//
// 2. Its `layout` implementation is overridden such that `performLayout` does
//    not do anything when its called from `layout`, preventing the parent
//    `_RenderTheater` from laying out this subtree prematurely (but this
//    `RenderObject` may still be resized). Instead, `markNeedsLayout` will be
//    called from within `layout` to schedule a layout update for this relayout
//    boundary when needed.
//
// 3. When invoked from `PipelineOwner.flushLayout`, or
//    `_layoutSurrogate.performLayout`, this `RenderObject` behaves like an
//    `Overlay` that has only one entry.
final class _RenderDeferredLayoutBox extends RenderProxyBox
    with _RenderTheaterMixin, LinkedListEntry<_RenderDeferredLayoutBox> {
  _RenderDeferredLayoutBox(this._layoutSurrogate);

  StackParentData get stackParentData => parentData! as StackParentData;
  final _RenderLayoutSurrogateProxyBox _layoutSurrogate;

  @override
  Iterable<RenderBox> _childrenInPaintOrder() {
    final RenderBox? child = this.child;
    return child == null
        ? const Iterable<RenderBox>.empty()
        : Iterable<RenderBox>.generate(1, (int i) => child);
  }

  @override
  Iterable<RenderBox> _childrenInHitTestOrder() => _childrenInPaintOrder();

  @override
  _RenderTheater get theater {
    final RenderObject? parent = this.parent;
    return parent is _RenderTheater
        ? parent
        : throw FlutterError('$parent of $this is not a _RenderTheater');
  }

  @override
  void redepthChildren() {
    _layoutSurrogate.redepthChild(this);
    super.redepthChildren();
  }

  @override
  bool get sizedByParent => true;

  bool _needsLayout = true;
  @override
  void markNeedsLayout() {
    _needsLayout = true;
    super.markNeedsLayout();
  }

  @override
  RenderObject? get semanticsParent => _layoutSurrogate;

  @override
  double? computeDryBaseline(BoxConstraints constraints, TextBaseline baseline) {
    final RenderBox? child = this.child;
    if (child == null) {
      return null;
    }
    return _RenderTheaterMixin.baselineForChild(
      child,
      constraints.biggest,
      constraints,
      theater._resolvedAlignment,
      baseline,
    );
  }

  @override
  RenderObject? get debugLayoutParent => _layoutSurrogate;

  void layoutByLayoutSurrogate() {
    assert(!_theaterDoingThisLayout);
    final _RenderTheater? theater = parent as _RenderTheater?;
    if (theater == null || !attached) {
      assert(false, '$this is not attached to parent');
      return;
    }
    if (theater._layingOutSizeDeterminingChild) {
      theater.invokeLayoutCallback((BoxConstraints constraints) {
        markNeedsLayout();
      });
    } else {
      final BoxConstraints theaterConstraints = theater.constraints;
      final Size boxSize =
          theaterConstraints.biggest.isFinite
              ? theaterConstraints.biggest
              // Accessing the theater's size is only unsafe if it is laying out the
              // size-determining child.
              : theater.size;
      super.layout(BoxConstraints.tight(boxSize));
    }
  }

  bool _theaterDoingThisLayout = false;
  @override
  void layout(Constraints constraints, {bool parentUsesSize = false}) {
    assert(_needsLayout == debugNeedsLayout);
    // Only _RenderTheater calls this implementation.
    assert(parent != null);
    final bool scheduleDeferredLayout = _needsLayout || this.constraints != constraints;
    assert(!_theaterDoingThisLayout);
    _theaterDoingThisLayout = true;
    super.layout(constraints, parentUsesSize: parentUsesSize);
    assert(_theaterDoingThisLayout);
    _theaterDoingThisLayout = false;
    _needsLayout = false;
    assert(!debugNeedsLayout);
    if (scheduleDeferredLayout) {
      final _RenderTheater parent = this.parent! as _RenderTheater;
      // Invoking markNeedsLayout as a layout callback allows this node to be
      // merged back to the `PipelineOwner`'s dirty list in the right order, if
      // it's not already dirty. Otherwise this may cause some dirty descendants
      // to performLayout a second time.
      parent.invokeLayoutCallback((BoxConstraints constraints) {
        markNeedsLayout();
      });
    }
  }

  @override
  void performResize() {
    size = constraints.biggest;
  }

  bool _debugMutationsLocked = false;
  @override
  void performLayout() {
    assert(!_debugMutationsLocked);
    if (_theaterDoingThisLayout) {
      _needsLayout = false;
      return;
    }
    assert(() {
      _debugMutationsLocked = true;
      return true;
    }());
    // This method is directly being invoked from `PipelineOwner.flushLayout`,
    // or from `_layoutSurrogate`'s performLayout.
    assert(parent != null);
    final RenderBox? child = this.child;
    if (child == null) {
      _needsLayout = false;
      return;
    }
    assert(constraints.isTight);
    layoutChild(child, constraints);
    assert(() {
      _debugMutationsLocked = false;
      return true;
    }());
    _needsLayout = false;
  }

  @override
  void applyPaintTransform(RenderBox child, Matrix4 transform) {
    final BoxParentData childParentData = child.parentData! as BoxParentData;
    final Offset offset = childParentData.offset;
    transform.translate(offset.dx, offset.dy);
  }
}

// A RenderProxyBox that makes sure its `deferredLayoutChild` has a greater
// depth than itself.
class _RenderLayoutSurrogateProxyBox extends RenderProxyBox {
  _RenderDeferredLayoutBox? _deferredLayoutChild;

  @override
  void redepthChildren() {
    super.redepthChildren();
    final _RenderDeferredLayoutBox? child = _deferredLayoutChild;
    // If child is not attached, this method will be invoked by child's real
    // parent when it's attached.
    if (child != null && child.attached) {
      assert(child.attached);
      redepthChild(child);
    }
  }

  @override
  void performLayout() {
    super.performLayout();
    // Try to layout `_deferredLayoutChild` here now that its configuration
    // and constraints are up-to-date. Additionally, during the very first
    // layout, this makes sure that _deferredLayoutChild is reachable via tree
    // walk.
    _deferredLayoutChild?.layoutByLayoutSurrogate();
  }

  @override
  void visitChildrenForSemantics(RenderObjectVisitor visitor) {
    super.visitChildrenForSemantics(visitor);
    final _RenderDeferredLayoutBox? deferredChild = _deferredLayoutChild;
    if (deferredChild != null) {
      visitor(deferredChild);
    }
  }
}


Instructions for the chapter (Generate content in English unless specified otherwise):
- Start with a clear heading (e.g., `# Chapter 3: OverlayEntry
`). Use the provided concept name.

- If this is not the first chapter, begin with a brief transition from the previous chapter, referencing it with a proper Markdown link using its name.

- Begin with a high-level motivation explaining what problem this abstraction solves. Start with a central use case as a concrete example. The whole chapter should guide the reader to understand how to solve this use case. Make it very minimal and friendly to beginners.

- If the abstraction is complex, break it down into key concepts. Explain each concept one-by-one in a very beginner-friendly way.

- Explain how to use this abstraction to solve the use case. Give example inputs and outputs for code snippets (if the output isn't values, describe at a high level what will happen).

- Each code block should be BELOW 10 lines! If longer code blocks are needed, break them down into smaller pieces and walk through them one-by-one. Aggresively simplify the code to make it minimal. Use comments to skip non-important implementation details. Each code block should have a beginner friendly explanation right after it.

- Describe the internal implementation to help understand what's under the hood. First provide a non-code or code-light walkthrough on what happens step-by-step when the abstraction is called. It's recommended to use a simple sequenceDiagram with a dummy example - keep it minimal with at most 5 participants to ensure clarity. If participant name has space, use: `participant QP as Query Processing`. .

- Then dive deeper into code for the internal implementation with references to files. Provide example code blocks, but make them similarly simple and beginner-friendly. Explain.

- IMPORTANT: When you need to refer to other core abstractions covered in other chapters, ALWAYS use proper Markdown links like this: [Chapter Title](filename.md). Use the Complete Tutorial Structure above to find the correct filename and the chapter title. Translate the surrounding text.

- Use mermaid diagrams to illustrate complex concepts (```mermaid``` format). .

- Heavily use analogies and examples throughout to help beginners understand.

- End the chapter with a brief conclusion that summarizes what was learned and provides a transition to the next chapter. If there is a next chapter, use a proper Markdown link: [Next Chapter Title](next_chapter_filename).

- Ensure the tone is welcoming and easy for a newcomer to understand.

- Output *only* the Markdown content for this chapter.

Now, directly provide a super beginner-friendly Markdown output (DON'T need ```markdown``` tags):

2025-05-22 23:57:37,937 - INFO - RESPONSE: # Chapter 3: OverlayEntry

Welcome back to our `overlay.dart` tutorial! In the [previous chapters](01_overlay_.md), we learned about the [Overlay](01_overlay_.md) as a container that sits on top of our UI and the [OverlayState](02_overlaystate_.md) as its manager, responsible for inserting and removing items from the overlay stack.

But what exactly are these "items" or "sheets" that get placed onto the [Overlay](01_overlay_.md)? That's where the `OverlayEntry` comes in!

Think of an `OverlayEntry` as a single, transparent sheet that you prepare to put onto the [Overlay](01_overlay_.md)'s overhead projector. This sheet has one purpose: to hold and display **a single widget** on the overlay.

Our goal is to display a simple message box that floats in the center of the screen when a button is pressed. To do this using the [Overlay](01_overlay_.md) and [OverlayState](02_overlaystate_.md), we need to wrap our message box widget inside an `OverlayEntry`.

So, an `OverlayEntry` is the object that carries the self-contained piece of UI you want to show on top of your regular content. It's the payload that the [OverlayState](02_overlaystate_.md) manages.

### Creating an OverlayEntry

Creating an `OverlayEntry` is straightforward. You just need to provide a `builder` function. This `builder` function is a standard Flutter `WidgetBuilder` that takes a `BuildContext` and should return the widget you want to display on the overlay.

Here's how we would create an `OverlayEntry` for our simple message box:

```dart
// This function creates an OverlayEntry for our message box.
OverlayEntry createMessageBoxEntry() {
  OverlayEntry entry = OverlayEntry(
    builder: (BuildContext context) {
      // The widget that will be shown on the overlay
      return Center( // Center it on the overlay
        child: Container(
          width: 200,
          height: 100,
          color: Colors.blue,
          child: const Center(child: Text('Hello OverlayEntry!')),
        ),
      );
    },
  );
  return entry;
}
```

In this snippet:

*   `OverlayEntry(...)`: We call the `OverlayEntry` constructor.
*   `builder: (BuildContext context) { ... }`: We provide the required `builder` function. Flutter will call this function when it needs to display our entry on the overlay.
*   Inside the `builder`, we return a `Center` widget containing our blue message `Container`. This widget is what the `OverlayEntry` will represent visually on the overlay.

Now, when we get the [OverlayState](02_overlaystate_.md) (as shown in the [previous chapter](02_overlaystate_.md)) and call `overlayState.insert(entry)`, our beautiful blue box will appear centered on the screen!

### OverlayEntry Properties: Opaque and MaintainState

Besides the `builder`, `OverlayEntry` has a couple of important properties: `opaque` and `maintainState`. These properties control how the `Overlay` handles layers below this specific entry.

*   **`opaque` (default: `false`)**: If set to `true`, this property signals to the [Overlay](01_overlay_.md) that this entry completely covers whatever is beneath it in the overlay stack. This is mainly an optimization hint. If an entry is `opaque`, the [Overlay](01_overlay_.md) can skip building or painting the parts of the entries below it that are covered. Think of putting a solid, colored sheet on the overhead projector  you can't see through it to the sheets below. Our message box isn't truly opaque unless it fills the whole screen, but for performance, you might mark a dialog or a full-screen route as opaque.

*   **`maintainState` (default: `false`)**: If set to `true`, this property tells the [Overlay](01_overlay_.md) to keep the widget hierarchy for this entry active, even if it's visually hidden by an `opaque` entry on top. This is like keeping the light on for a sheet even if a solid sheet is on top. This is useful for things like keeping the state of a background route alive in a Navigator, even when another route is covering it entirely. Setting this to `true` can use more resources, so use it only when necessary.

For our simple message box, neither of these needs to be `true`. It doesn't cover everything below it entirely (it's just a small box), and we don't need to maintain its state when it's not visible (we'll remove it when hidden). So, the default values work fine.

```dart
OverlayEntry createMessageBoxEntry() {
  return OverlayEntry(
    builder: (BuildContext context) {
      // Our message box widget
      return Center(
        child: Container(
          width: 200,
          height: 100,
          color: Colors.blue,
          child: const Center(child: Text('Hello OverlayEntry!')),
        ),
      );
    },
    // opaque: false, // Default and appropriate for a small box
    // maintainState: false, // Default and appropriate as we remove it
  );
}
```

### Removing an OverlayEntry

As we saw in the [previous chapter](02_overlaystate_.md), to remove an `OverlayEntry`, you call the `remove()` method directly on the `OverlayEntry` object itself.

```dart
// Assuming you have a variable to hold the entry:
OverlayEntry? myActiveMessageBoxEntry;

void hideMyMessageBox() {
  if (myActiveMessageBoxEntry != null) {
    myActiveMessageBoxEntry!.remove(); // Tell the entry to remove itself
    myActiveMessageBoxEntry = null; // Clear our reference
  }
}
```

When `entry.remove()` is called:
1. The `OverlayEntry` looks up the [OverlayState](02_overlaystate_.md) it was inserted into (it holds an internal reference).
2. It tells that [OverlayState](02_overlaystate_.md) to remove it from its list of entries.
3. The [OverlayState](02_overlaystate_.md) rebuilds, and since the entry is no longer in its list, the widget built by this entry's `builder` is no longer included in the UI, making it disappear.

### How OverlayEntry Works Internally

Let's revisit the code snippet from `overlay.dart` for `OverlayEntry`:

```dart
class OverlayEntry implements Listenable {
  // ... constructor and properties ...

  OverlayState? _overlay; // Internal reference to the managing OverlayState
  final GlobalKey<_OverlayEntryWidgetState> _key = GlobalKey<_OverlayEntryWidgetState>();

  /// Remove this entry from the overlay.
  void remove() {
    assert(_overlay != null);
    final OverlayState overlay = _overlay!; // Get the associated OverlayState
    _overlay = null; // Clear the internal reference

    // ... scheduling logic ...
    overlay._entries.remove(this); // Request removal from the OverlayState's list
    overlay._markDirty(); // Tell the OverlayState to rebuild
    // ...
  }

  /// Cause this entry to rebuild during the next pipeline flush.
  ///
  /// You need to call this function if the output of [builder] has changed.
  void markNeedsBuild() {
    assert(!_disposedByOwner);
    _key.currentState?._markNeedsBuild();
  }

  // ... dispose method and other internal details ...
}
```

Key takeaways from this snippet:

*   `OverlayState? _overlay;`: This private variable is how an `OverlayEntry` knows which [OverlayState](02_overlaystate_.md) it belongs to. This reference is set when you call `overlayState.insert(entry)`.
*   `final GlobalKey<_OverlayEntryWidgetState> _key`: Each `OverlayEntry` uses a `GlobalKey` to identify the actual widget (`_OverlayEntryWidget`) that the [OverlayState](02_overlaystate_.md) creates to represent this entry in the widget tree.
*   `remove()`: When you call `remove()`, it uses the `_overlay` reference to find the correct [OverlayState](02_overlaystate_.md) and tells it to remove `this` entry from its internal `_entries` list (`overlay._entries.remove(this)`). It then sets `_overlay` to `null` and calls `overlay._markDirty()` to trigger a rebuild of the [OverlayState](02_overlaystate_.md).
*   `markNeedsBuild()`: If the widget you return from your `builder` function changes (e.g., based on some state within the `OverlayEntry`), you can call `markNeedsBuild()` on the `OverlayEntry` to tell the system that its visual representation needs to be updated. This calls `setState` on the internal `_OverlayEntryWidgetState` associated with this entry's `_key`.

Here's a sequence diagram focusing on the OverlayEntry's role in removal:

```mermaid
sequenceDiagram
    participant YourWidget
    participant OverlayEntry
    participant OverlayState
    participant Framework as Flutter Framework

    YourWidget->>OverlayEntry: call remove()
    OverlayEntry->>OverlayEntry: access internal _overlay reference
    OverlayEntry->>OverlayEntry: clear internal _overlay reference
    OverlayEntry->>OverlayState: remove OverlayEntry from _entries list
    OverlayState->>OverlayState: call _markDirty() (triggers setState)
    OverlayState->>Framework: schedule build
    Framework->>OverlayState: call build()
    OverlayState->>OverlayEntry: Build logic skips removed entry
    OverlayEntry->>Framework: Widget no longer added to tree
    Framework->>Framework: UI updated (entry disappears)
```

This confirms that the `OverlayEntry` is primarily a data holder for the widget and properties, and it delegates the actual UI management (insertion and removal from the visual tree) back to the [OverlayState](02_overlaystate_.md) it belongs to.

### Conclusion

In this chapter, we focused on the `OverlayEntry`, the core object that holds the widget you want to display on an [Overlay](01_overlay_.md). We learned how to create a basic `OverlayEntry` using a `builder` function, how to use its `opaque` and `maintainState` properties, and how calling `remove()` on the entry itself signals to the managing [OverlayState](02_overlaystate_.md) to take it off the screen.

We also briefly looked at the internal structure, understanding that `OverlayEntry` keeps a reference to its [OverlayState](02_overlaystate_.md) and manages a `GlobalKey` to its corresponding widget in the overlay tree.

With the concepts of [Overlay](01_overlay_.md), [OverlayState](02_overlaystate_.md), and `OverlayEntry` under our belt, we now have the foundational knowledge to display custom widgets on top of our application content at a global level!

In the next chapter, we will introduce [OverlayPortal](04_overlayportal_.md), a more modern and often simpler alternative to directly managing `OverlayEntry` objects, especially when you want an overlay widget to stay closely connected to the state and context of its originating widget.

[OverlayPortal](04_overlayportal_.md)
2025-05-22 23:57:37,948 - INFO - PROMPT: 
Write a very beginner-friendly tutorial chapter (in Markdown format) for the project `flutter (overlay.dart)` about the concept: "OverlayPortal
". This is Chapter 4.

Concept Details:
- Name: OverlayPortal

- Description:
An OverlayPortal is an alternative way to put a widget onto an Overlay. Instead of directly managing an OverlayEntry, you give the OverlayPortal a builder function that creates the widget you want to show. This widget then appears on the Overlay, but it acts like it's part of the OverlayPortal's original location in the widget tree for things like themes or other inherited widgets.


Complete Tutorial Structure:
1. [Overlay
](01_overlay_.md)
2. [OverlayState
](02_overlaystate_.md)
3. [OverlayEntry
](03_overlayentry_.md)
4. [OverlayPortal
](04_overlayportal_.md)
5. [OverlayPortalController
](05_overlayportalcontroller_.md)
6. [_Theater
](06__theater_.md)
7. [_RenderDeferredLayoutBox
](07__renderdeferredlayoutbox_.md)
8. [_OverlayEntryLocation
](08__overlayentrylocation_.md)

Context from previous chapters:
# Chapter 1: Overlay

Welcome to the first chapter of our tutorial on Flutter's `overlay.dart`! In this chapter, we'll introduce you to the fundamental concept of an `Overlay`.

Have you ever seen temporary popups, like dialogs, tooltips that appear over your regular screen content, no matter what's currently displayed? How does Flutter manage to show these elements *on top* of everything else? That's where the `Overlay` comes in!

Think of your Flutter app's user interface as a stack of layers, like transparencies on an overhead projector. Your main screen content is on the bottom layer. When you want to show something *over* that content, without affecting how the main content is arranged, you place it on a new, transparent layer on top. The `Overlay` widget is like the frame of this overhead projector that holds the stack of transparent sheets.

The `Overlay` itself is a widget that sits high up in your app's widget tree, often provided automatically by powerful widgets like `MaterialApp` or `WidgetsApp`. It manages a list of "sheets," called [OverlayEntry](03_overlayentry_.md)s. Each [OverlayEntry](03_overlayentry_.md) can hold a widget, and these widgets will be painted *above* the `Overlay`'s regular content.

So, the core idea is:

**An `Overlay` is a stack of entry points where you can place widgets that should appear on top of your primary UI.**

### Our Goal: Displaying a Simple Overlay

To understand the `Overlay` better, let's imagine we want to display a simple message box that floats in the center of the screen when a button is pressed. This message box should appear above all other content on the screen.

Using the `Overlay` and its related components, we can achieve this. Here's the high-level plan:

1.  Find the nearest `Overlay`.
2.  Create an [OverlayEntry](03_overlayentry_.md) containing our message box widget.
3.  Insert this [OverlayEntry](03_overlayentry_.md) into the `Overlay`'s stack.
4.  When we want to hide the message box, we'll remove the [OverlayEntry](03_overlayentry_.md) from the `Overlay`.

### Finding the Overlay

The `Overlay` is usually introduced by the main app widgets like `MaterialApp`. To interact with this `Overlay`, we need to get its state, which is an [OverlayState](02_overlaystate_.md). We can do this using the `Overlay.of` method, passing the current `BuildContext`.

```dart
// Inside a widget's build method or a function called from it:
OverlayState? overlayState = Overlay.of(context);
```

This code snippet uses `Overlay.of(context)` to look up the closest `OverlayState` in the widget tree above the current `context`. If an `Overlay` is found, it gives us its state (the [OverlayState](02_overlaystate_.md) object) that we can use to manage our overlay entries. If no `Overlay` is found (which is unlikely in a typical `MaterialApp`), it would cause an error in debug mode.

### What's Inside the Overlay?

While we don't see it directly in the minimal code we write, the `Overlay` widget itself contains some interesting pieces to manage its entries.

Let's look at a relevant snippet from the `overlay.dart` file:

```dart
class Overlay extends StatefulWidget {
  // ... other properties and methods

  @override
  OverlayState createState() => OverlayState();
}
```

This shows that the `Overlay` widget creates an [OverlayState](02_overlaystate_.md). This is the object we obtained using `Overlay.of`. The [OverlayState](02_overlaystate_.md) is where the real work of managing the list of [OverlayEntry](03_overlayentry_.md) objects happens.

Further down in the code, we see how the `OverlayState` builds its UI:

```dart
class OverlayState extends State<Overlay> with TickerProviderStateMixin {
  final List<OverlayEntry> _entries = <OverlayEntry>[];

  // ... methods for inserting and removing entries

  @protected
  @override
  Widget build(BuildContext context) {
    // ... logic to determine visible entries
    final List<_OverlayEntryWidget> children = <_OverlayEntryWidget>[];
    // ... populate children based on _entries
    return _Theater(
      // ... properties like skipCount, clipBehavior
      children: children.reversed.toList(growable: false),
    );
  }

  // ... other methods
}
```

This snippet reveals a crucial part: the `OverlayState` holds a list of `_entries` (our [OverlayEntry](03_overlayentry_.md) objects). In its `build` method, it creates a list of `_OverlayEntryWidget`s corresponding to the active entries. These widgets are then passed to a special widget called `_Theater`.

The `_Theater` widget is essentially a specialized `Stack`. It's responsible for laying out and painting the widgets from the [OverlayEntry](03_overlayentry_.md)s on top of each other, similar to how layers are stacked in a `Stack`.

Here's a simplified illustration of the key participants and their relationships in displaying an overlay entry:

```mermaid
sequenceDiagram
    participant YourWidget
    participant OverlayDotOf as Overlay.of(context)
    participant OverlayState
    participant OverlayEntry
    participant _Theater

    YourWidget->>OverlayDotOf: Ask for OverlayState
    OverlayDotOf-->>OverlayState: Return the found OverlayState
    YourWidget->>OverlayState: Create and insert OverlayEntry
    OverlayState->>OverlayEntry: Add entry to internal list
    OverlayState->>OverlayState: Schedule rebuild
    OverlayState->>_Theater: Build _Theater with entries as children
    _Theater->>OverlayEntry: Ask entry to build its widget
    OverlayEntry->>_Theater: Return built widget
    _Theater->>_Theater: Layout and paint entry's widget on top

```

This diagram shows that your widget interacts with the global `Overlay.of` to get the [OverlayState](02_overlaystate_.md). You then use the [OverlayState](02_overlaystate_.md) to manage your [OverlayEntry](03_overlayentry_.md). The [OverlayState](02_overlaystate_.md) internally uses `_Theater` to visually stack the widgets provided by the [OverlayEntry](03_overlayentry_.md)s.

### Conclusion

In this chapter, we introduced the concept of the `Overlay` in Flutter. We learned that it acts as a container for widgets that should appear on top of the regular UI, managing them as a stack of [OverlayEntry](03_overlayentry_.md) objects. We saw how to find the `OverlayState` using `Overlay.of` and got a peek into the internal structure involving `_Theater`.

In the next chapter, we will delve deeper into the [OverlayState](02_overlaystate_.md) and explore how to use its methods to actually insert and remove [OverlayEntry](03_overlayentry_.md) objects, allowing us to finally display our floating message box.

[OverlayState](02_overlaystate_.md)
---
# Chapter 2: OverlayState

Welcome back! In our [previous chapter](01_overlay_.md), we learned that an `Overlay` acts like a transparent layer on top of our regular UI, managed by powerful widgets like `MaterialApp`. We also saw that this `Overlay` holds a stack of "sheets" called [OverlayEntry](03_overlayentry_.md)s. But who is in charge of managing these sheets? That's where the `OverlayState` comes in.

Think of the `Overlay` as the physical structure (the overhead projector frame) and the `OverlayState` as the person operating that projector. The `OverlayState` is the **manager** for the `Overlay`. Its main job is to keep track of which [OverlayEntry](03_overlayentry_.md) sheets are currently in the stack and decide which ones are visible.

Our goal from the last chapter was to display a simple message box that floats in the center of the screen when a button is pressed. To do this, we need to:

1.  Find the `OverlayState` associated with our `Overlay`.
2.  Create an [OverlayEntry](03_overlayentry_.md) containing our message box widget.
3.  Tell the `OverlayState` to **insert** this [OverlayEntry](03_overlayentry_.md) into its stack.
4.  When we want to hide the message box, tell the `OverlayState` to **remove** the [OverlayEntry](03_overlayentry_.md).

In this chapter, we'll focus on how to use the `OverlayState` to perform these insertions and removals.

### Getting the OverlayState

As we briefly saw in the last chapter, we can get the `OverlayState` using the static method `Overlay.of`. This method looks up the widget tree from the given `BuildContext` and finds the nearest `Overlay` widget's state.

```dart
// Inside a widget where you want to show an overlay:
void showMyMessageBox(BuildContext context) {
  OverlayState? overlayState = Overlay.of(context);
  // Now we have the manager (the OverlayState)!
}
```

Here, `Overlay.of(context)` does the important work of finding the correct `OverlayState` for us. The `context` tells Flutter where in the widget tree we are looking from. In a typical app, this `OverlayState` will be the one managed by your `MaterialApp` or `WidgetsApp`.

### Adding an OverlayEntry

Once we have the `OverlayState`, we can add new entries to it. The `OverlayState` has an `insert` method for this purpose. The `insert` method takes an [OverlayEntry](03_overlayentry_.md) object as its argument.

Let's imagine we have created our `OverlayEntry` object (we'll learn more about [OverlayEntry](03_overlayentry_.md) in the next chapter, for now just assume it exists).

```dart
// Continuing from the previous snippet:
void showMyMessageBox(BuildContext context) {
  OverlayState? overlayState = Overlay.of(context);

  if (overlayState != null) {
    // Assume 'myOverlayEntry' is an instance of OverlayEntry
    // that holds our message box widget.
    OverlayEntry myOverlayEntry = createMessageBoxEntry(); // Placeholder function

    overlayState.insert(myOverlayEntry);
    print('Message box inserted!');
  } else {
    print('Could not find OverlayState!');
  }
}

// Placeholder for creating the OverlayEntry
OverlayEntry createMessageBoxEntry() {
  // This would contain the actual widget for the message box
  return OverlayEntry(
    builder: (context) => Center(
      child: Container(
        width: 200,
        height: 100,
        color: Colors.blue,
        child: Center(child: Text('Hello Overlay!')),
      ),
    ),
  );
}
```

In this code:
1.  We get the `overlayState`.
2.  We check if it's not null (meaning an `Overlay` was found).
3.  We create an `OverlayEntry` (using `createMessageBoxEntry`).
4.  We call `overlayState.insert(myOverlayEntry)`. This is the key step! It tells the `OverlayState` to add our entry to its internal list.

When an `OverlayEntry` is inserted, the `OverlayState` marks itself as needing to rebuild. During the next build cycle, the `OverlayState` will include the widget from your newly inserted [OverlayEntry](03_overlayentry_.md) in its list of visible children, making it appear on top of your UI.

### Ordering OverlayEntries

The `insert` method also allows you to control where the entry is inserted in the stack:

*   `overlayState.insert(entry)`: Inserts the entry at the very top (painted last).
*   `overlayState.insert(entry, below: someOtherEntry)`: Inserts the entry just below `someOtherEntry`.
*   `overlayState.insert(entry, above: someOtherEntry)`: Inserts the entry just above `someOtherEntry`.

This is like deciding whether to place your new transparency sheet on the very top of the stack, or insert it right above or below another specific sheet. This is useful for complex overlays or when integrating with system overlays like dialogs or routes managed by the Navigator.

### Removing an OverlayEntry

Adding entries is only half the story. We also need to be able to remove them. For example, when the user closes our message box, we want to take it off the overlay.

To remove an [OverlayEntry](03_overlayentry_.md), you call the `remove()` method directly on the **[OverlayEntry](03_overlayentry_.md) object itself**, not on the `OverlayState`.

```dart
// Continuing the example, we need to keep track of the inserted entry:
OverlayEntry? currentMessageBoxEntry; // Store the active entry

void showMyMessageBox(BuildContext context) {
  // ... find overlayState ...
  if (overlayState != null) {
    // Create and store the entry before inserting
    currentMessageBoxEntry = createMessageBoxEntry();
    overlayState.insert(currentMessageBoxEntry!); // Insert it
    print('Message box inserted!');

    // Example: Automatically remove after 3 seconds (for demonstration)
    Future.delayed(Duration(seconds: 3), () {
      removeMyMessageBox();
    });

  } else {
    print('Could not find OverlayState!');
  }
}

// Function to remove the message box
void removeMyMessageBox() {
  if (currentMessageBoxEntry != null) {
    currentMessageBoxEntry!.remove(); // Call remove on the entry!
    currentMessageBoxEntry = null; // Clear the stored entry
    print('Message box removed!');
  }
}

// (createMessageBoxEntry function remains the same)
// (Remember to import 'package:flutter/material.dart' for Colors/Container/Text)
```

In this updated code:
1.  We declare `currentMessageBoxEntry` to hold a reference to the [OverlayEntry](03_overlayentry_.md) once it's created and inserted.
2.  When showing the box, we assign the new entry to this variable.
3.  When removing the box (`removeMyMessageBox`), we check if `currentMessageBoxEntry` is not null and call its `remove()` method.
4.  After removing, we set `currentMessageBoxEntry` back to null.

Calling `entry.remove()` tells the `OverlayState` to take that specific [OverlayEntry](03_overlayentry_.md) out of its list. Similar to insertion, the `OverlayState` will then mark itself dirty and rebuild, this time *without* including the widget from the removed entry.

### How OverlayState Manages Entries Internally

Let's look peek under the hood again. We saw in the snippet from the last chapter that `OverlayState` holds a `List<OverlayEntry> _entries`. This is the core list it manages.

When you call `insert`:

```dart
// From overlay.dart -> OverlayState -> insert method (simplified)
void insert(OverlayEntry entry, {OverlayEntry? below, OverlayEntry? above}) {
  // ... asserts ...
  entry._overlay = this; // Internal link back to this OverlayState
  setState(() { // Marks state as dirty, schedules a rebuild
    _entries.insert(_insertionIndex(below, above), entry); // Adds to the list
  });
}
```

*   `entry._overlay = this;`: The [OverlayEntry](03_overlayentry_.md) keeps a reference to the `OverlayState` it belongs to. This is how `entry.remove()` knows *which* `OverlayState` to tell to remove it.
*   `setState(() { ... });`: This is standard Flutter State management. It signals to the framework that the state of the `OverlayState` has changed (`_entries` list is different) and it needs to be rebuilt.
*   `_entries.insert(...)`: This is the actual list manipulation. It adds the `entry` at the calculated position in the internal `_entries` list.

When the `OverlayState` rebuilds, its `build` method creates the UI using the current contents of `_entries`. We saw that it uses a widget called `_Theater` for this:

```dart
// From overlay.dart -> OverlayState -> build method (simplified)
@override
Widget build(BuildContext context) {
  // ... logic to determine visible entries ...
  final List<_OverlayEntryWidget> children = <_OverlayEntryWidget>[];
  // Loop through _entries (and inactive maintainedState entries)
  // and create _OverlayEntryWidget for each.
  return _Theater(
    // ...
    children: children.reversed.toList(growable: false), // Passes the list to _Theater
  );
}
```

The `_Theater` is essentially a specialized container that takes a list of child widgets (built from the [OverlayEntry](03_overlayentry_.md)s) and stacks them on top of each other. The children are given to `_Theater` in reversed order because the `_entries` list is ordered from bottom to top, but a `Stack` (which `_Theater` behaves like) paints children from bottom to top based on their position in the list. So, the last entry in `_entries` (the top-most one) needs to be the last child given to `_Theater`.

Here's a sequence diagram illustrating insertion:

```mermaid
sequenceDiagram
    participant YourWidget
    participant OverlayState
    participant OverlayEntry
    participant Framework as Flutter Framework
    participant _Theater

    YourWidget->>OverlayState: call insert(OverlayEntry)
    OverlayState->>OverlayEntry: set internal _overlay reference
    OverlayState->>OverlayState: add OverlayEntry to _entries list
    OverlayState->>Framework: call setState()
    Framework->>OverlayState: scheduled rebuild
    OverlayState->>OverlayState: call build()
    OverlayState->>OverlayEntry: call builder() to get widget
    OverlayEntry->>OverlayState: return widget
    OverlayState->>_Theater: pass widget as child
    _Theater->>_Theater: layout and paint widget on top
```

When you call `entry.remove()`:

```dart
// From overlay.dart -> OverlayEntry -> remove method (simplified)
void remove() {
  assert(_overlay != null);
  final OverlayState overlay = _overlay!; // Get the associated OverlayState
  _overlay = null; // Clear the internal reference

  // ... schedule markDirty or call directly ...
  overlay._entries.remove(this); // Remove from the OverlayState's list
  overlay._markDirty(); // Tell the OverlayState to rebuild
  // ...
}
```

*   `_overlay!`: Accesses the `OverlayState` that this entry is currently in.
*   `_entries.remove(this);`: The `OverlayEntry` tells its manager (`_overlay`) to remove itself from the list.
*   `overlay._markDirty();`: Calls an internal method on the `OverlayState` to signal that it needs to rebuild.

The diagram for removal is similar to insertion, just in reverse:

```mermaid
sequenceDiagram
    participant YourWidget
    participant OverlayEntry
    participant OverlayState
    participant Framework as Flutter Framework
    participant _Theater

    YourWidget->>OverlayEntry: call remove()
    OverlayEntry->>OverlayState: access internal _overlay reference
    OverlayEntry->>OverlayEntry: clear internal _overlay reference
    OverlayEntry->>OverlayState: remove OverlayEntry from _entries list
    OverlayState->>OverlayState: call _markDirty()
    OverlayState->>Framework: setState() called implicitly
    Framework->>OverlayState: scheduled rebuild
    OverlayState->>OverlayState: call build()
    OverlayState->>_Theater: pass children (without the removed entry)
    _Theater->>_Theater: relayout and repaint (entry disappears)
```

This demonstrates how the `OverlayState` acts as the central hub, maintaining the list and triggering UI updates when the list of [OverlayEntry](03_overlayentry_.md) objects changes.

### Conclusion

In this chapter, we explored the crucial role of the `OverlayState`. We learned that it is the manager for an [Overlay](01_overlay_.md), holding the list of [OverlayEntry](03_overlayentry_.md) objects and controlling their visibility. We saw how to obtain the `OverlayState` using `Overlay.of` and, most importantly, how to use its `insert` method to add [OverlayEntry](03_overlayentry_.md)s to the overlay stack and how to call `remove` directly on an [OverlayEntry](03_overlayentry_.md) to take it out.

We also took a look at the internal workings, seeing how `OverlayState`'s `_entries` list is manipulated and how `setState` triggers a rebuild to update the UI using the [_Theater](06__theater_.md) widget.

Now that we understand the container ([Overlay](01_overlay_.md)) and its manager (`OverlayState`), it's time to delve into the "sheets" themselves: the [OverlayEntry](03_overlayentry_.md). In the next chapter, we'll learn how to create our own [OverlayEntry](03_overlayentry_.md) objects with the specific widgets we want to display on the overlay.

[OverlayEntry](03_overlayentry_.md)
---
# Chapter 3: OverlayEntry

Welcome back to our `overlay.dart` tutorial! In the [previous chapters](01_overlay_.md), we learned about the [Overlay](01_overlay_.md) as a container that sits on top of our UI and the [OverlayState](02_overlaystate_.md) as its manager, responsible for inserting and removing items from the overlay stack.

But what exactly are these "items" or "sheets" that get placed onto the [Overlay](01_overlay_.md)? That's where the `OverlayEntry` comes in!

Think of an `OverlayEntry` as a single, transparent sheet that you prepare to put onto the [Overlay](01_overlay_.md)'s overhead projector. This sheet has one purpose: to hold and display **a single widget** on the overlay.

Our goal is to display a simple message box that floats in the center of the screen when a button is pressed. To do this using the [Overlay](01_overlay_.md) and [OverlayState](02_overlaystate_.md), we need to wrap our message box widget inside an `OverlayEntry`.

So, an `OverlayEntry` is the object that carries the self-contained piece of UI you want to show on top of your regular content. It's the payload that the [OverlayState](02_overlaystate_.md) manages.

### Creating an OverlayEntry

Creating an `OverlayEntry` is straightforward. You just need to provide a `builder` function. This `builder` function is a standard Flutter `WidgetBuilder` that takes a `BuildContext` and should return the widget you want to display on the overlay.

Here's how we would create an `OverlayEntry` for our simple message box:

```dart
// This function creates an OverlayEntry for our message box.
OverlayEntry createMessageBoxEntry() {
  OverlayEntry entry = OverlayEntry(
    builder: (BuildContext context) {
      // The widget that will be shown on the overlay
      return Center( // Center it on the overlay
        child: Container(
          width: 200,
          height: 100,
          color: Colors.blue,
          child: const Center(child: Text('Hello OverlayEntry!')),
        ),
      );
    },
  );
  return entry;
}
```

In this snippet:

*   `OverlayEntry(...)`: We call the `OverlayEntry` constructor.
*   `builder: (BuildContext context) { ... }`: We provide the required `builder` function. Flutter will call this function when it needs to display our entry on the overlay.
*   Inside the `builder`, we return a `Center` widget containing our blue message `Container`. This widget is what the `OverlayEntry` will represent visually on the overlay.

Now, when we get the [OverlayState](02_overlaystate_.md) (as shown in the [previous chapter](02_overlaystate_.md)) and call `overlayState.insert(entry)`, our beautiful blue box will appear centered on the screen!

### OverlayEntry Properties: Opaque and MaintainState

Besides the `builder`, `OverlayEntry` has a couple of important properties: `opaque` and `maintainState`. These properties control how the `Overlay` handles layers below this specific entry.

*   **`opaque` (default: `false`)**: If set to `true`, this property signals to the [Overlay](01_overlay_.md) that this entry completely covers whatever is beneath it in the overlay stack. This is mainly an optimization hint. If an entry is `opaque`, the [Overlay](01_overlay_.md) can skip building or painting the parts of the entries below it that are covered. Think of putting a solid, colored sheet on the overhead projector  you can't see through it to the sheets below. Our message box isn't truly opaque unless it fills the whole screen, but for performance, you might mark a dialog or a full-screen route as opaque.

*   **`maintainState` (default: `false`)**: If set to `true`, this property tells the [Overlay](01_overlay_.md) to keep the widget hierarchy for this entry active, even if it's visually hidden by an `opaque` entry on top. This is like keeping the light on for a sheet even if a solid sheet is on top. This is useful for things like keeping the state of a background route alive in a Navigator, even when another route is covering it entirely. Setting this to `true` can use more resources, so use it only when necessary.

For our simple message box, neither of these needs to be `true`. It doesn't cover everything below it entirely (it's just a small box), and we don't need to maintain its state when it's not visible (we'll remove it when hidden). So, the default values work fine.

```dart
OverlayEntry createMessageBoxEntry() {
  return OverlayEntry(
    builder: (BuildContext context) {
      // Our message box widget
      return Center(
        child: Container(
          width: 200,
          height: 100,
          color: Colors.blue,
          child: const Center(child: Text('Hello OverlayEntry!')),
        ),
      );
    },
    // opaque: false, // Default and appropriate for a small box
    // maintainState: false, // Default and appropriate as we remove it
  );
}
```

### Removing an OverlayEntry

As we saw in the [previous chapter](02_overlaystate_.md), to remove an `OverlayEntry`, you call the `remove()` method directly on the `OverlayEntry` object itself.

```dart
// Assuming you have a variable to hold the entry:
OverlayEntry? myActiveMessageBoxEntry;

void hideMyMessageBox() {
  if (myActiveMessageBoxEntry != null) {
    myActiveMessageBoxEntry!.remove(); // Tell the entry to remove itself
    myActiveMessageBoxEntry = null; // Clear our reference
  }
}
```

When `entry.remove()` is called:
1. The `OverlayEntry` looks up the [OverlayState](02_overlaystate_.md) it was inserted into (it holds an internal reference).
2. It tells that [OverlayState](02_overlaystate_.md) to remove it from its list of entries.
3. The [OverlayState](02_overlaystate_.md) rebuilds, and since the entry is no longer in its list, the widget built by this entry's `builder` is no longer included in the UI, making it disappear.

### How OverlayEntry Works Internally

Let's revisit the code snippet from `overlay.dart` for `OverlayEntry`:

```dart
class OverlayEntry implements Listenable {
  // ... constructor and properties ...

  OverlayState? _overlay; // Internal reference to the managing OverlayState
  final GlobalKey<_OverlayEntryWidgetState> _key = GlobalKey<_OverlayEntryWidgetState>();

  /// Remove this entry from the overlay.
  void remove() {
    assert(_overlay != null);
    final OverlayState overlay = _overlay!; // Get the associated OverlayState
    _overlay = null; // Clear the internal reference

    // ... scheduling logic ...
    overlay._entries.remove(this); // Request removal from the OverlayState's list
    overlay._markDirty(); // Tell the OverlayState to rebuild
    // ...
  }

  /// Cause this entry to rebuild during the next pipeline flush.
  ///
  /// You need to call this function if the output of [builder] has changed.
  void markNeedsBuild() {
    assert(!_disposedByOwner);
    _key.currentState?._markNeedsBuild();
  }

  // ... dispose method and other internal details ...
}
```

Key takeaways from this snippet:

*   `OverlayState? _overlay;`: This private variable is how an `OverlayEntry` knows which [OverlayState](02_overlaystate_.md) it belongs to. This reference is set when you call `overlayState.insert(entry)`.
*   `final GlobalKey<_OverlayEntryWidgetState> _key`: Each `OverlayEntry` uses a `GlobalKey` to identify the actual widget (`_OverlayEntryWidget`) that the [OverlayState](02_overlaystate_.md) creates to represent this entry in the widget tree.
*   `remove()`: When you call `remove()`, it uses the `_overlay` reference to find the correct [OverlayState](02_overlaystate_.md) and tells it to remove `this` entry from its internal `_entries` list (`overlay._entries.remove(this)`). It then sets `_overlay` to `null` and calls `overlay._markDirty()` to trigger a rebuild of the [OverlayState](02_overlaystate_.md).
*   `markNeedsBuild()`: If the widget you return from your `builder` function changes (e.g., based on some state within the `OverlayEntry`), you can call `markNeedsBuild()` on the `OverlayEntry` to tell the system that its visual representation needs to be updated. This calls `setState` on the internal `_OverlayEntryWidgetState` associated with this entry's `_key`.

Here's a sequence diagram focusing on the OverlayEntry's role in removal:

```mermaid
sequenceDiagram
    participant YourWidget
    participant OverlayEntry
    participant OverlayState
    participant Framework as Flutter Framework

    YourWidget->>OverlayEntry: call remove()
    OverlayEntry->>OverlayEntry: access internal _overlay reference
    OverlayEntry->>OverlayEntry: clear internal _overlay reference
    OverlayEntry->>OverlayState: remove OverlayEntry from _entries list
    OverlayState->>OverlayState: call _markDirty() (triggers setState)
    OverlayState->>Framework: schedule build
    Framework->>OverlayState: call build()
    OverlayState->>OverlayEntry: Build logic skips removed entry
    OverlayEntry->>Framework: Widget no longer added to tree
    Framework->>Framework: UI updated (entry disappears)
```

This confirms that the `OverlayEntry` is primarily a data holder for the widget and properties, and it delegates the actual UI management (insertion and removal from the visual tree) back to the [OverlayState](02_overlaystate_.md) it belongs to.

### Conclusion

In this chapter, we focused on the `OverlayEntry`, the core object that holds the widget you want to display on an [Overlay](01_overlay_.md). We learned how to create a basic `OverlayEntry` using a `builder` function, how to use its `opaque` and `maintainState` properties, and how calling `remove()` on the entry itself signals to the managing [OverlayState](02_overlaystate_.md) to take it off the screen.

We also briefly looked at the internal structure, understanding that `OverlayEntry` keeps a reference to its [OverlayState](02_overlaystate_.md) and manages a `GlobalKey` to its corresponding widget in the overlay tree.

With the concepts of [Overlay](01_overlay_.md), [OverlayState](02_overlaystate_.md), and `OverlayEntry` under our belt, we now have the foundational knowledge to display custom widgets on top of our application content at a global level!

In the next chapter, we will introduce [OverlayPortal](04_overlayportal_.md), a more modern and often simpler alternative to directly managing `OverlayEntry` objects, especially when you want an overlay widget to stay closely connected to the state and context of its originating widget.

[OverlayPortal](04_overlayportal_.md)

Relevant Code Snippets (Code itself remains unchanged):
--- File: packages/flutter/lib/src/widgets/overlay.dart ---
// Copyright 2014 The Flutter Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

/// @docImport 'package:flutter/cupertino.dart';
/// @docImport 'package:flutter/material.dart';
///
/// @docImport 'app.dart';
/// @docImport 'drag_target.dart';
/// @docImport 'implicit_animations.dart';
/// @docImport 'media_query.dart';
/// @docImport 'navigator.dart';
/// @docImport 'routes.dart';
/// @docImport 'scroll_view.dart';
/// @docImport 'sliver.dart';
/// @docImport 'text.dart';
library;

import 'dart:collection';

import 'package:flutter/foundation.dart';
import 'package:flutter/rendering.dart';
import 'package:flutter/scheduler.dart';

import 'basic.dart';
import 'framework.dart';
import 'lookup_boundary.dart';
import 'ticker_provider.dart';

const String _flutterWidgetsLibrary = 'package:flutter/widgets.dart';

// Examples can assume:
// late BuildContext context;

// * OverlayEntry Implementation

/// A place in an [Overlay] that can contain a widget.
///
/// Overlay entries are inserted into an [Overlay] using the
/// [OverlayState.insert] or [OverlayState.insertAll] functions. To find the
/// closest enclosing overlay for a given [BuildContext], use the [Overlay.of]
/// function.
///
/// An overlay entry can be in at most one overlay at a time. To remove an entry
/// from its overlay, call the [remove] function on the overlay entry.
///
/// Because an [Overlay] uses a [Stack] layout, overlay entries can use
/// [Positioned] and [AnimatedPositioned] to position themselves within the
/// overlay.
///
/// For example, [Draggable] uses an [OverlayEntry] to show the drag avatar that
/// follows the user's finger across the screen after the drag begins. Using the
/// overlay to display the drag avatar lets the avatar float over the other
/// widgets in the app. As the user's finger moves, draggable calls
/// [markNeedsBuild] on the overlay entry to cause it to rebuild. In its build,
/// the entry includes a [Positioned] with its top and left property set to
/// position the drag avatar near the user's finger. When the drag is over,
/// [Draggable] removes the entry from the overlay to remove the drag avatar
/// from view.
///
/// By default, if there is an entirely [opaque] entry over this one, then this
/// one will not be included in the widget tree (in particular, stateful widgets
/// within the overlay entry will not be instantiated). To ensure that your
/// overlay entry is still built even if it is not visible, set [maintainState]
/// to true. This is more expensive, so should be done with care. In particular,
/// if widgets in an overlay entry with [maintainState] set to true repeatedly
/// call [State.setState], the user's battery will be drained unnecessarily.
///
/// [OverlayEntry] is a [Listenable] that notifies when the widget built by
/// [builder] is mounted or unmounted, whose exact state can be queried by
/// [mounted]. After the owner of the [OverlayEntry] calls [remove] and then
/// [dispose], the widget may not be immediately removed from the widget tree.
/// As a result listeners of the [OverlayEntry] can get notified for one last
/// time after the [dispose] call, when the widget is eventually unmounted.
///
/// {@macro flutter.widgets.overlayPortalVsOverlayEntry}
///
/// See also:
///
///  * [OverlayPortal], an alternative API for inserting widgets into an
///    [Overlay] using a builder callback.
///  * [Overlay], a stack of entries that can be managed independently.
///  * [OverlayState], the current state of an Overlay.
///  * [WidgetsApp], a convenience widget that wraps a number of widgets that
///    are commonly required for an application.
///  * [MaterialApp], a convenience widget that wraps a number of widgets that
///    are commonly required for Material Design applications.
class OverlayEntry implements Listenable {
  /// Creates an overlay entry.
  ///
  /// To insert the entry into an [Overlay], first find the overlay using
  /// [Overlay.of] and then call [OverlayState.insert]. To remove the entry,
  /// call [remove] on the overlay entry itself.
  OverlayEntry({
    required this.builder,
    bool opaque = false,
    bool maintainState = false,
    this.canSizeOverlay = false,
  }) : _opaque = opaque,
       _maintainState = maintainState {
    if (kFlutterMemoryAllocationsEnabled) {
      _maybeDispatchObjectCreation();
    }
  }

  /// This entry will include the widget built by this builder in the overlay at
  /// the entry's position.
  ///
  /// To cause this builder to be called again, call [markNeedsBuild] on this
  /// overlay entry.
  final WidgetBuilder builder;

  /// Whether this entry occludes the entire overlay.
  ///
  /// If an entry claims to be opaque, then, for efficiency, the overlay will
  /// skip building entries below that entry unless they have [maintainState]
  /// set.
  bool get opaque => _opaque;
  bool _opaque;
  set opaque(bool value) {
    assert(!_disposedByOwner);
    if (_opaque == value) {
      return;
    }
    _opaque = value;
    _overlay?._didChangeEntryOpacity();
  }

  /// Whether this entry must be included in the tree even if there is a fully
  /// [opaque] entry above it.
  ///
  /// By default, if there is an entirely [opaque] entry over this one, then this
  /// one will not be included in the widget tree (in particular, stateful widgets
  /// within the overlay entry will not be instantiated). To ensure that your
  /// overlay entry is still built even if it is not visible, set [maintainState]
  /// to true. This is more expensive, so should be done with care. In particular,
  /// if widgets in an overlay entry with [maintainState] set to true repeatedly
  /// call [State.setState], the user's battery will be drained unnecessarily.
  ///
  /// This is used by the [Navigator] and [Route] objects to ensure that routes
  /// are kept around even when in the background, so that [Future]s promised
  /// from subsequent routes will be handled properly when they complete.
  bool get maintainState => _maintainState;
  bool _maintainState;
  set maintainState(bool value) {
    assert(!_disposedByOwner);
    if (_maintainState == value) {
      return;
    }
    _maintainState = value;
    assert(_overlay != null);
    _overlay!._didChangeEntryOpacity();
  }

  /// Whether the content of this [OverlayEntry] can be used to size the
  /// [Overlay].
  ///
  /// In most situations the overlay sizes itself based on its incoming
  /// constraints to be as large as possible. However, if that would result in
  /// an infinite size, it has to rely on one of its children to size itself. In
  /// this situation, the overlay will consult the topmost non-[Positioned]
  /// overlay entry that has this property set to true, lay it out with the
  /// incoming [BoxConstraints] of the overlay, and force all other
  /// non-[Positioned] overlay entries to have the same size. The [Positioned]
  /// entries are laid out as usual based on the calculated size of the overlay.
  ///
  /// Overlay entries that set this to true must be able to handle unconstrained
  /// [BoxConstraints].
  ///
  /// Setting this to true has no effect if the overlay entry uses a [Positioned]
  /// widget to position itself in the overlay.
  final bool canSizeOverlay;

  /// Whether the [OverlayEntry] is currently mounted in the widget tree.
  ///
  /// The [OverlayEntry] notifies its listeners when this value changes.
  bool get mounted => _overlayEntryStateNotifier?.value != null;

  /// The currently mounted `_OverlayEntryWidgetState` built using this [OverlayEntry].
  ValueNotifier<_OverlayEntryWidgetState?>? _overlayEntryStateNotifier =
      ValueNotifier<_OverlayEntryWidgetState?>(null);

  // TODO(polina-c): stop duplicating code across disposables
  // https://github.com/flutter/flutter/issues/137435
  /// Dispatches event of object creation to [FlutterMemoryAllocations.instance].
  void _maybeDispatchObjectCreation() {
    if (kFlutterMemoryAllocationsEnabled) {
      FlutterMemoryAllocations.instance.dispatchObjectCreated(
        library: _flutterWidgetsLibrary,
        className: '$OverlayEntry',
        object: this,
      );
    }
  }

  @override
  void addListener(VoidCallback listener) {
    assert(!_disposedByOwner);
    _overlayEntryStateNotifier?.addListener(listener);
  }

  @override
  void removeListener(VoidCallback listener) {
    _overlayEntryStateNotifier?.removeListener(listener);
  }

  OverlayState? _overlay;
  final GlobalKey<_OverlayEntryWidgetState> _key = GlobalKey<_OverlayEntryWidgetState>();

  /// Remove this entry from the overlay.
  ///
  /// This should only be called once.
  ///
  /// This method removes this overlay entry from the overlay immediately. The
  /// UI will be updated in the same frame if this method is called before the
  /// overlay rebuild in this frame; otherwise, the UI will be updated in the
  /// next frame. This means that it is safe to call during builds, but also
  /// that if you do call this after the overlay rebuild, the UI will not update
  /// until the next frame (i.e. many milliseconds later).
  void remove() {
    assert(_overlay != null);
    assert(!_disposedByOwner);
    final OverlayState overlay = _overlay!;
    _overlay = null;
    if (!overlay.mounted) {
      return;
    }

    overlay._entries.remove(this);
    if (SchedulerBinding.instance.schedulerPhase == SchedulerPhase.persistentCallbacks) {
      SchedulerBinding.instance.addPostFrameCallback((Duration duration) {
        overlay._markDirty();
      }, debugLabel: 'OverlayEntry.markDirty');
    } else {
      overlay._markDirty();
    }
  }

  /// Cause this entry to rebuild during the next pipeline flush.
  ///
  /// You need to call this function if the output of [builder] has changed.
  void markNeedsBuild() {
    assert(!_disposedByOwner);
    _key.currentState?._markNeedsBuild();
  }

  void _didUnmount() {
    assert(!mounted);
    if (_disposedByOwner) {
      _overlayEntryStateNotifier?.dispose();
      _overlayEntryStateNotifier = null;
    }
  }

  bool _disposedByOwner = false;

  /// Discards any resources used by this [OverlayEntry].
  ///
  /// This method must be called after [remove] if the [OverlayEntry] is
  /// inserted into an [Overlay].
  ///
  /// After this is called, the object is not in a usable state and should be
  /// discarded (calls to [addListener] will throw after the object is disposed).
  /// However, the listeners registered may not be immediately released until
  /// the widget built using this [OverlayEntry] is unmounted from the widget
  /// tree.
  ///
  /// This method should only be called by the object's owner.
  void dispose() {
    assert(!_disposedByOwner);
    assert(
      _overlay == null,
      'An OverlayEntry must first be removed from the Overlay before dispose is called.',
    );
    if (kFlutterMemoryAllocationsEnabled) {
      FlutterMemoryAllocations.instance.dispatchObjectDisposed(object: this);
    }
    _disposedByOwner = true;
    if (!mounted) {
      // If we're still mounted when disposed, then this will be disposed in
      // _didUnmount, to allow notifications to occur until the entry is
      // unmounted.
      _overlayEntryStateNotifier?.dispose();
      _overlayEntryStateNotifier = null;
    }
  }

  @override
  String toString() =>
      '${describeIdentity(this)}(opaque: $opaque; maintainState: $maintainState)${_disposedByOwner ? "(DISPOSED)" : ""}';
}

class _OverlayEntryWidget extends StatefulWidget {
  const _OverlayEntryWidget({
    required Key super.key,
    required this.entry,
    required this.overlayState,
    this.tickerEnabled = true,
  });

  final OverlayEntry entry;
  final OverlayState overlayState;
  final bool tickerEnabled;

  @override
  _OverlayEntryWidgetState createState() => _OverlayEntryWidgetState();
}

class _OverlayEntryWidgetState extends State<_OverlayEntryWidget> {
  late _RenderTheater _theater;

  // Manages the stack of theater children whose paint order are sorted by their
  // _zOrderIndex. The children added by OverlayPortal are added to this linked
  // list, and they will be shown _above_ the OverlayEntry tied to this widget.
  // The children with larger zOrderIndex values (i.e. those called `show`
  // recently) will be painted last.
  //
  // This linked list is lazily created in `_add`, and the entries are added/removed
  // via `_add`/`_remove`, called by OverlayPortals lower in the tree. `_add` or
  // `_remove` does not cause this widget to rebuild, the linked list will be
  // read by _RenderTheater as part of its render child model. This would ideally
  // be in a RenderObject but there may not be RenderObjects between
  // _RenderTheater and the render subtree OverlayEntry builds.
  LinkedList<_OverlayEntryLocation>? _sortedTheaterSiblings;

  // Worst-case O(N), N being the number of children added to the top spot in
  // the same frame. This can be a bit expensive when there's a lot of global
  // key reparenting in the same frame but N is usually a small number.
  void _add(_OverlayEntryLocation child) {
    assert(mounted);
    final LinkedList<_OverlayEntryLocation> children =
        _sortedTheaterSiblings ??= LinkedList<_OverlayEntryLocation>();
    assert(!children.contains(child));
    _OverlayEntryLocation? insertPosition = children.isEmpty ? null : children.last;
    while (insertPosition != null && insertPosition._zOrderIndex > child._zOrderIndex) {
      insertPosition = insertPosition.previous;
    }
    if (insertPosition == null) {
      children.addFirst(child);
    } else {
      insertPosition.insertAfter(child);
    }
    assert(children.contains(child));
  }

  void _remove(_OverlayEntryLocation child) {
    assert(_sortedTheaterSiblings != null);
    final bool wasInCollection = _sortedTheaterSiblings?.remove(child) ?? false;
    assert(wasInCollection);
  }

  // Returns an Iterable that traverse the children in the child model in paint
  // order (from farthest to the user to the closest to the user).
  //
  // The iterator should be safe to use even when the child model is being
  // mutated. The reason for that is it's allowed to add/remove/move deferred
  // children to a _RenderTheater during performLayout, but the affected
  // children don't have to be laid out in the same performLayout call.
  late final Iterable<RenderBox> _paintOrderIterable = _createChildIterable(reversed: false);
  // An Iterable that traverse the children in the child model in
  // hit-test order (from closest to the user to the farthest to the user).
  late final Iterable<RenderBox> _hitTestOrderIterable = _createChildIterable(reversed: true);

  // The following uses sync* because hit-testing is lazy, and LinkedList as a
  // Iterable doesn't support concurrent modification.
  Iterable<RenderBox> _createChildIterable({required bool reversed}) sync* {
    final LinkedList<_OverlayEntryLocation>? children = _sortedTheaterSiblings;
    if (children == null || children.isEmpty) {
      return;
    }
    _OverlayEntryLocation? candidate = reversed ? children.last : children.first;
    while (candidate != null) {
      final RenderBox? renderBox = candidate._overlayChildRenderBox;
      candidate = reversed ? candidate.previous : candidate.next;
      if (renderBox != null) {
        yield renderBox;
      }
    }
  }

  @override
  void initState() {
    super.initState();
    widget.entry._overlayEntryStateNotifier!.value = this;
    _theater = context.findAncestorRenderObjectOfType<_RenderTheater>()!;
    assert(_sortedTheaterSiblings == null);
  }

  @override
  void didUpdateWidget(_OverlayEntryWidget oldWidget) {
    super.didUpdateWidget(oldWidget);
    // OverlayState's build method always returns a RenderObjectWidget _Theater,
    // so it's safe to assume that state equality implies render object equality.
    assert(oldWidget.entry == widget.entry);
    if (oldWidget.overlayState != widget.overlayState) {
      final _RenderTheater newTheater = context.findAncestorRenderObjectOfType<_RenderTheater>()!;
      assert(_theater != newTheater);
      _theater = newTheater;
    }
  }

  @override
  void dispose() {
    widget.entry._overlayEntryStateNotifier?.value = null;
    widget.entry._didUnmount();
    _sortedTheaterSiblings = null;
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    return TickerMode(
      enabled: widget.tickerEnabled,
      child: _RenderTheaterMarker(
        theater: _theater,
        overlayEntryWidgetState: this,
        child: widget.entry.builder(context),
      ),
    );
  }

  void _markNeedsBuild() {
    setState(() {
      /* the state that changed is in the builder */
    });
  }
}

/// A stack of entries that can be managed independently.
///
/// Overlays let independent child widgets "float" visual elements on top of
/// other widgets by inserting them into the overlay's stack. The overlay lets
/// each of these widgets manage their participation in the overlay using
/// [OverlayEntry] objects.
///
/// Although you can create an [Overlay] directly, it's most common to use the
/// overlay created by the [Navigator] in a [WidgetsApp], [CupertinoApp] or a
/// [MaterialApp]. The navigator uses its overlay to manage the visual
/// appearance of its routes.
///
/// The [Overlay] widget uses a custom stack implementation, which is very
/// similar to the [Stack] widget. The main use case of [Overlay] is related to
/// navigation and being able to insert widgets on top of the pages in an app.
/// For layout purposes unrelated to navigation, consider using [Stack] instead.
///
/// An [Overlay] widget requires a [Directionality] widget to be in scope, so
/// that it can resolve direction-sensitive coordinates of any
/// [Positioned.directional] children.
///
/// For widgets drawn in an [OverlayEntry], do not assume that the size of the
/// [Overlay] is the size returned by [MediaQuery.sizeOf]. Nested overlays can
/// have different sizes.
///
/// {@tool dartpad}
/// This example shows how to use the [Overlay] to highlight the [NavigationBar]
/// destination.
///
/// ** See code in examples/api/lib/widgets/overlay/overlay.0.dart **
/// {@end-tool}
///
/// See also:
///
///  * [OverlayEntry], the class that is used for describing the overlay entries.
///  * [OverlayState], which is used to insert the entries into the overlay.
///  * [WidgetsApp], which inserts an [Overlay] widget indirectly via its [Navigator].
///  * [MaterialApp], which inserts an [Overlay] widget indirectly via its [Navigator].
///  * [CupertinoApp], which inserts an [Overlay] widget indirectly via its [Navigator].
///  * [Stack], which allows directly displaying a stack of widgets.
class Overlay extends StatefulWidget {
  /// Creates an overlay.
  ///
  /// The initial entries will be inserted into the overlay when its associated
  /// [OverlayState] is initialized.
  ///
  /// Rather than creating an overlay, consider using the overlay that is
  /// created by the [Navigator] in a [WidgetsApp], [CupertinoApp], or a
  /// [MaterialApp] for the application.
  const Overlay({
    super.key,
    this.initialEntries = const <OverlayEntry>[],
    this.clipBehavior = Clip.hardEdge,
  });

  /// Wrap the provided `child` in an [Overlay] to allow other visual elements
  /// (packed in [OverlayEntry]s) to float on top of the child.
  ///
  /// This is a convenience method over the regular [Overlay] constructor: It
  /// creates an [Overlay] and puts the provided `child` in an [OverlayEntry]
  /// at the bottom of that newly created Overlay.
  static Widget wrap({Key? key, Clip clipBehavior = Clip.hardEdge, required Widget child}) {
    return _WrappingOverlay(key: key, clipBehavior: clipBehavior, child: child);
  }

  /// The entries to include in the overlay initially.
  ///
  /// These entries are only used when the [OverlayState] is initialized. If you
  /// are providing a new [Overlay] description for an overlay that's already in
  /// the tree, then the new entries are ignored.
  ///
  /// To add entries to an [Overlay] that is already in the tree, use
  /// [Overlay.of] to obtain the [OverlayState] (or assign a [GlobalKey] to the
  /// [Overlay] widget and obtain the [OverlayState] via
  /// [GlobalKey.currentState]), and then use [OverlayState.insert] or
  /// [OverlayState.insertAll].
  ///
  /// To remove an entry from an [Overlay], use [OverlayEntry.remove].
  final List<OverlayEntry> initialEntries;

  /// {@macro flutter.material.Material.clipBehavior}
  ///
  /// Defaults to [Clip.hardEdge].
  final Clip clipBehavior;

  /// The [OverlayState] from the closest instance of [Overlay] that encloses
  /// the given context within the closest [LookupBoundary], and, in debug mode,
  /// will throw if one is not found.
  ///
  /// In debug mode, if the `debugRequiredFor` argument is provided and an
  /// overlay isn't found, then this function will throw an exception containing
  /// the runtime type of the given widget in the error message. The exception
  /// attempts to explain that the calling [Widget] (the one given by the
  /// `debugRequiredFor` argument) needs an [Overlay] to be present to function.
  /// If `debugRequiredFor` is not supplied, then the error message is more
  /// generic.
  ///
  /// Typical usage is as follows:
  ///
  /// ```dart
  /// OverlayState overlay = Overlay.of(context);
  /// ```
  ///
  /// If `rootOverlay` is set to true, the state from the furthest instance of
  /// this class is given instead. Useful for installing overlay entries above
  /// all subsequent instances of [Overlay].
  ///
  /// This method can be expensive (it walks the element tree).
  ///
  /// See also:
  ///
  /// * [Overlay.maybeOf] for a similar function that returns null if an
  ///   [Overlay] is not found.
  static OverlayState of(
    BuildContext context, {
    bool rootOverlay = false,
    Widget? debugRequiredFor,
  }) {
    final OverlayState? result = maybeOf(context, rootOverlay: rootOverlay);
    assert(() {
      if (result == null) {
        final bool hiddenByBoundary = LookupBoundary.debugIsHidingAncestorStateOfType<OverlayState>(
          context,
        );
        final List<DiagnosticsNode> information = <DiagnosticsNode>[
          ErrorSummary(
            'No Overlay widget found${hiddenByBoundary ? ' within the closest LookupBoundary' : ''}.',
          ),
          if (hiddenByBoundary)
            ErrorDescription(
              'There is an ancestor Overlay widget, but it is hidden by a LookupBoundary.',
            ),
          ErrorDescription(
            '${debugRequiredFor?.runtimeType ?? 'Some'} widgets require an Overlay widget ancestor for correct operation.',
          ),
          ErrorHint(
            'The most common way to add an Overlay to an application is to include a MaterialApp, CupertinoApp or Navigator widget in the runApp() call.',
          ),
          if (debugRequiredFor != null)
            DiagnosticsProperty<Widget>(
              'The specific widget that failed to find an overlay was',
              debugRequiredFor,
              style: DiagnosticsTreeStyle.errorProperty,
            ),
          if (context.widget != debugRequiredFor)
            context.describeElement(
              'The context from which that widget was searching for an overlay was',
            ),
        ];

        throw FlutterError.fromParts(information);
      }
      return true;
    }());
    return result!;
  }

  /// The [OverlayState] from the closest instance of [Overlay] that encloses
  /// the given context within the closest [LookupBoundary], if any.
  ///
  /// Typical usage is as follows:
  ///
  /// ```dart
  /// OverlayState? overlay = Overlay.maybeOf(context);
  /// ```
  ///
  /// If `rootOverlay` is set to true, the state from the furthest instance of
  /// this class is given instead. Useful for installing overlay entries above
  /// all subsequent instances of [Overlay].
  ///
  /// This method can be expensive (it walks the element tree).
  ///
  /// See also:
  ///
  ///  * [Overlay.of] for a similar function that returns a non-nullable result
  ///    and throws if an [Overlay] is not found.

  static OverlayState? maybeOf(BuildContext context, {bool rootOverlay = false}) {
    return rootOverlay
        ? LookupBoundary.findRootAncestorStateOfType<OverlayState>(context)
        : LookupBoundary.findAncestorStateOfType<OverlayState>(context);
  }

  @override
  OverlayState createState() => OverlayState();
}

/// The current state of an [Overlay].
///
/// Used to insert [OverlayEntry]s into the overlay using the [insert] and
/// [insertAll] functions.
class OverlayState extends State<Overlay> with TickerProviderStateMixin {
  final List<OverlayEntry> _entries = <OverlayEntry>[];

  @protected
  @override
  void initState() {
    super.initState();
    insertAll(widget.initialEntries);
  }

  int _insertionIndex(OverlayEntry? below, OverlayEntry? above) {
    assert(above == null || below == null);
    if (below != null) {
      return _entries.indexOf(below);
    }
    if (above != null) {
      return _entries.indexOf(above) + 1;
    }
    return _entries.length;
  }

  bool _debugCanInsertEntry(OverlayEntry entry) {
    final List<DiagnosticsNode> operandsInformation = <DiagnosticsNode>[
      DiagnosticsProperty<OverlayEntry>(
        'The OverlayEntry was',
        entry,
        style: DiagnosticsTreeStyle.errorProperty,
      ),
      DiagnosticsProperty<OverlayState>(
        'The Overlay the OverlayEntry was trying to insert to was',
        this,
        style: DiagnosticsTreeStyle.errorProperty,
      ),
    ];

    if (!mounted) {
      throw FlutterError.fromParts(<DiagnosticsNode>[
        ErrorSummary('Attempted to insert an OverlayEntry to an already disposed Overlay.'),
        ...operandsInformation,
      ]);
    }

    final OverlayState? currentOverlay = entry._overlay;
    final bool alreadyContainsEntry = _entries.contains(entry);

    if (alreadyContainsEntry) {
      final bool inconsistentOverlayState = !identical(currentOverlay, this);
      throw FlutterError.fromParts(<DiagnosticsNode>[
        ErrorSummary('The specified entry is already present in the target Overlay.'),
        ...operandsInformation,
        if (inconsistentOverlayState)
          ErrorHint('This could be an error in the Flutter framework.')
        else
          ErrorHint(
            'Consider calling remove on the OverlayEntry before inserting it to a different Overlay, '
            'or switching to the OverlayPortal API to avoid manual OverlayEntry management.',
          ),
        if (inconsistentOverlayState)
          DiagnosticsProperty<OverlayState>(
            "The OverlayEntry's current Overlay was",
            currentOverlay,
            style: DiagnosticsTreeStyle.errorProperty,
          ),
      ]);
    }

    if (currentOverlay == null) {
      return true;
    }

    throw FlutterError.fromParts(<DiagnosticsNode>[
      ErrorSummary('The specified entry is already present in a different Overlay.'),
      ...operandsInformation,
      DiagnosticsProperty<OverlayState>(
        "The OverlayEntry's current Overlay was",
        currentOverlay,
        style: DiagnosticsTreeStyle.errorProperty,
      ),
      ErrorHint(
        'Consider calling remove on the OverlayEntry before inserting it to a different Overlay, '
        'or switching to the OverlayPortal API to avoid manual OverlayEntry management.',
      ),
    ]);
  }

  /// Insert the given entry into the overlay.
  ///
  /// If `below` is non-null, the entry is inserted just below `below`.
  /// If `above` is non-null, the entry is inserted just above `above`.
  /// Otherwise, the entry is inserted on top.
  ///
  /// It is an error to specify both `above` and `below`.
  void insert(OverlayEntry entry, {OverlayEntry? below, OverlayEntry? above}) {
    assert(_debugVerifyInsertPosition(above, below));
    assert(_debugCanInsertEntry(entry));
    entry._overlay = this;
    setState(() {
      _entries.insert(_insertionIndex(below, above), entry);
    });
  }

  /// Insert all the entries in the given iterable.
  ///
  /// If `below` is non-null, the entries are inserted just below `below`.
  /// If `above` is non-null, the entries are inserted just above `above`.
  /// Otherwise, the entries are inserted on top.
  ///
  /// It is an error to specify both `above` and `below`.
  void insertAll(Iterable<OverlayEntry> entries, {OverlayEntry? below, OverlayEntry? above}) {
    assert(_debugVerifyInsertPosition(above, below));
    assert(entries.every(_debugCanInsertEntry));
    if (entries.isEmpty) {
      return;
    }
    for (final OverlayEntry entry in entries) {
      assert(entry._overlay == null);
      entry._overlay = this;
    }
    setState(() {
      _entries.insertAll(_insertionIndex(below, above), entries);
    });
  }

  bool _debugVerifyInsertPosition(
    OverlayEntry? above,
    OverlayEntry? below, {
    Iterable<OverlayEntry>? newEntries,
  }) {
    assert(above == null || below == null, 'Only one of `above` and `below` may be specified.');
    assert(
      above == null ||
          (above._overlay == this &&
              _entries.contains(above) &&
              (newEntries?.contains(above) ?? true)),
      'The provided entry used for `above` must be present in the Overlay${newEntries != null ? ' and in the `newEntriesList`' : ''}.',
    );
    assert(
      below == null ||
          (below._overlay == this &&
              _entries.contains(below) &&
              (newEntries?.contains(below) ?? true)),
      'The provided entry used for `below` must be present in the Overlay${newEntries != null ? ' and in the `newEntriesList`' : ''}.',
    );
    return true;
  }

  /// Remove all the entries listed in the given iterable, then reinsert them
  /// into the overlay in the given order.
  ///
  /// Entries mention in `newEntries` but absent from the overlay are inserted
  /// as if with [insertAll].
  ///
  /// Entries not mentioned in `newEntries` but present in the overlay are
  /// positioned as a group in the resulting list relative to the entries that
  /// were moved, as specified by one of `below` or `above`, which, if
  /// specified, must be one of the entries in `newEntries`:
  ///
  /// If `below` is non-null, the group is positioned just below `below`.
  /// If `above` is non-null, the group is positioned just above `above`.
  /// Otherwise, the group is left on top, with all the rearranged entries
  /// below.
  ///
  /// It is an error to specify both `above` and `below`.
  void rearrange(Iterable<OverlayEntry> newEntries, {OverlayEntry? below, OverlayEntry? above}) {
    final List<OverlayEntry> newEntriesList =
        newEntries is List<OverlayEntry> ? newEntries : newEntries.toList(growable: false);
    assert(_debugVerifyInsertPosition(above, below, newEntries: newEntriesList));
    assert(
      newEntriesList.every(
        (OverlayEntry entry) => entry._overlay == null || entry._overlay == this,
      ),
      'One or more of the specified entries are already present in another Overlay.',
    );
    assert(
      newEntriesList.every(
        (OverlayEntry entry) => _entries.indexOf(entry) == _entries.lastIndexOf(entry),
      ),
      'One or more of the specified entries are specified multiple times.',
    );
    if (newEntriesList.isEmpty) {
      return;
    }
    if (listEquals(_entries, newEntriesList)) {
      return;
    }
    final LinkedHashSet<OverlayEntry> old = LinkedHashSet<OverlayEntry>.of(_entries);
    for (final OverlayEntry entry in newEntriesList) {
      entry._overlay ??= this;
    }
    setState(() {
      _entries.clear();
      _entries.addAll(newEntriesList);
      old.removeAll(newEntriesList);
      _entries.insertAll(_insertionIndex(below, above), old);
    });
  }

  void _markDirty() {
    if (mounted) {
      setState(() {});
    }
  }

  /// (DEBUG ONLY) Check whether a given entry is visible (i.e., not behind an
  /// opaque entry).
  ///
  /// This is an O(N) algorithm, and should not be necessary except for debug
  /// asserts. To avoid people depending on it, this function is implemented
  /// only in debug mode, and always returns false in release mode.
  bool debugIsVisible(OverlayEntry entry) {
    bool result = false;
    assert(_entries.contains(entry));
    assert(() {
      for (int i = _entries.length - 1; i > 0; i -= 1) {
        final OverlayEntry candidate = _entries[i];
        if (candidate == entry) {
          result = true;
          break;
        }
        if (candidate.opaque) {
          break;
        }
      }
      return true;
    }());
    return result;
  }

  void _didChangeEntryOpacity() {
    setState(() {
      // We use the opacity of the entry in our build function, which means we
      // our state has changed.
    });
  }

  @protected
  @override
  Widget build(BuildContext context) {
    // This list is filled backwards and then reversed below before
    // it is added to the tree.
    final List<_OverlayEntryWidget> children = <_OverlayEntryWidget>[];
    bool onstage = true;
    int onstageCount = 0;
    for (final OverlayEntry entry in _entries.reversed) {
      if (onstage) {
        onstageCount += 1;
        children.add(_OverlayEntryWidget(key: entry._key, overlayState: this, entry: entry));
        if (entry.opaque) {
          onstage = false;
        }
      } else if (entry.maintainState) {
        children.add(
          _OverlayEntryWidget(
            key: entry._key,
            overlayState: this,
            entry: entry,
            tickerEnabled: false,
          ),
        );
      }
    }
    return _Theater(
      skipCount: children.length - onstageCount,
      clipBehavior: widget.clipBehavior,
      children: children.reversed.toList(growable: false),
    );
  }

  @protected
  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    // TODO(jacobr): use IterableProperty instead as that would
    // provide a slightly more consistent string summary of the List.
    properties.add(DiagnosticsProperty<List<OverlayEntry>>('entries', _entries));
  }
}

class _WrappingOverlay extends StatefulWidget {
  const _WrappingOverlay({super.key, this.clipBehavior = Clip.hardEdge, required this.child});

  final Clip clipBehavior;
  final Widget child;

  @override
  State<_WrappingOverlay> createState() => _WrappingOverlayState();
}

class _WrappingOverlayState extends State<_WrappingOverlay> {
  late final OverlayEntry _entry = OverlayEntry(
    canSizeOverlay: true,
    opaque: true,
    builder: (BuildContext context) {
      return widget.child;
    },
  );

  @override
  void didUpdateWidget(_WrappingOverlay oldWidget) {
    super.didUpdateWidget(oldWidget);
    _entry.markNeedsBuild();
  }

  @override
  void dispose() {
    _entry
      ..remove()
      ..dispose();
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    return Overlay(clipBehavior: widget.clipBehavior, initialEntries: <OverlayEntry>[_entry]);
  }
}

/// Special version of a [Stack], that doesn't layout and render the first
/// [skipCount] children.
///
/// The first [skipCount] children are considered "offstage".
class _Theater extends MultiChildRenderObjectWidget {
  const _Theater({
    this.skipCount = 0,
    this.clipBehavior = Clip.hardEdge,
    required List<_OverlayEntryWidget> super.children,
  }) : assert(skipCount >= 0),
       assert(children.length >= skipCount);

  final int skipCount;

  final Clip clipBehavior;

  @override
  _TheaterElement createElement() => _TheaterElement(this);

  @override
  _RenderTheater createRenderObject(BuildContext context) {
    return _RenderTheater(
      skipCount: skipCount,
      textDirection: Directionality.of(context),
      clipBehavior: clipBehavior,
    );
  }

  @override
  void updateRenderObject(BuildContext context, _RenderTheater renderObject) {
    renderObject
      ..skipCount = skipCount
      ..textDirection = Directionality.of(context)
      ..clipBehavior = clipBehavior;
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties.add(IntProperty('skipCount', skipCount));
  }
}

class _TheaterElement extends MultiChildRenderObjectElement {
  _TheaterElement(_Theater super.widget);

  @override
  _RenderTheater get renderObject => super.renderObject as _RenderTheater;

  @override
  void insertRenderObjectChild(RenderBox child, IndexedSlot<Element?> slot) {
    super.insertRenderObjectChild(child, slot);
    final _TheaterParentData parentData = child.parentData! as _TheaterParentData;
    parentData.overlayEntry =
        ((widget as _Theater).children[slot.index] as _OverlayEntryWidget).entry;
    assert(parentData.overlayEntry != null);
  }

  @override
  void moveRenderObjectChild(
    RenderBox child,
    IndexedSlot<Element?> oldSlot,
    IndexedSlot<Element?> newSlot,
  ) {
    super.moveRenderObjectChild(child, oldSlot, newSlot);
    assert(() {
      final _TheaterParentData parentData = child.parentData! as _TheaterParentData;
      return parentData.overlayEntry ==
          ((widget as _Theater).children[newSlot.index] as _OverlayEntryWidget).entry;
    }());
  }

  @override
  void debugVisitOnstageChildren(ElementVisitor visitor) {
    final _Theater theater = widget as _Theater;
    assert(children.length >= theater.skipCount);
    children.skip(theater.skipCount).forEach(visitor);
  }
}

// A `RenderBox` that sizes itself to its parent's size, implements the stack
// layout algorithm and renders its children in the given `theater`.
mixin _RenderTheaterMixin on RenderBox {
  _RenderTheater get theater;

  Iterable<RenderBox> _childrenInPaintOrder();
  Iterable<RenderBox> _childrenInHitTestOrder();

  @override
  void setupParentData(RenderBox child) {
    if (child.parentData is! StackParentData) {
      child.parentData = StackParentData();
    }
  }

  @override
  double? computeDistanceToActualBaseline(TextBaseline baseline) {
    assert(!debugNeedsLayout);
    BaselineOffset baselineOffset = BaselineOffset.noBaseline;
    for (final RenderBox child in _childrenInPaintOrder()) {
      assert(!child.debugNeedsLayout);
      final StackParentData childParentData = child.parentData! as StackParentData;
      baselineOffset = baselineOffset.minOf(
        BaselineOffset(child.getDistanceToActualBaseline(baseline)) + childParentData.offset.dy,
      );
    }
    return baselineOffset.offset;
  }

  static double? baselineForChild(
    RenderBox child,
    Size theaterSize,
    BoxConstraints nonPositionedChildConstraints,
    Alignment alignment,
    TextBaseline baseline,
  ) {
    final StackParentData childParentData = child.parentData! as StackParentData;
    final BoxConstraints childConstraints =
        childParentData.isPositioned
            ? childParentData.positionedChildConstraints(theaterSize)
            : nonPositionedChildConstraints;
    final double? baselineOffset = child.getDryBaseline(childConstraints, baseline);
    if (baselineOffset == null) {
      return null;
    }
    final double y = switch (childParentData) {
      StackParentData(:final double top?) => top,
      StackParentData(:final double bottom?) =>
        theaterSize.height - bottom - child.getDryLayout(childConstraints).height,
      StackParentData() =>
        alignment.alongOffset(theaterSize - child.getDryLayout(childConstraints) as Offset).dy,
    };
    return baselineOffset + y;
  }

  void layoutChild(RenderBox child, BoxConstraints nonPositionedChildConstraints) {
    final StackParentData childParentData = child.parentData! as StackParentData;
    final Alignment alignment = theater._resolvedAlignment;
    if (!childParentData.isPositioned) {
      child.layout(nonPositionedChildConstraints, parentUsesSize: true);
      childParentData.offset = Offset.zero;
    } else {
      assert(
        child is! _RenderDeferredLayoutBox,
        'all _RenderDeferredLayoutBoxes must be non-positioned children.',
      );
      RenderStack.layoutPositionedChild(child, childParentData, size, alignment);
    }
    assert(child.parentData == childParentData);
  }

  @override
  bool hitTestChildren(BoxHitTestResult result, {required Offset position}) {
    final Iterator<RenderBox> iterator = _childrenInHitTestOrder().iterator;
    bool isHit = false;
    while (!isHit && iterator.moveNext()) {
      final RenderBox child = iterator.current;
      final StackParentData childParentData = child.parentData! as StackParentData;
      final RenderBox localChild = child;
      bool childHitTest(BoxHitTestResult result, Offset position) =>
          localChild.hitTest(result, position: position);
      isHit = result.addWithPaintOffset(
        offset: childParentData.offset,
        position: position,
        hitTest: childHitTest,
      );
    }
    return isHit;
  }

  @override
  void paint(PaintingContext context, Offset offset) {
    for (final RenderBox child in _childrenInPaintOrder()) {
      final StackParentData childParentData = child.parentData! as StackParentData;
      context.paintChild(child, childParentData.offset + offset);
    }
  }
}

class _TheaterParentData extends StackParentData {
  // The OverlayEntry that directly created this child. This field is null for
  // children that are created by an OverlayPortal.
  OverlayEntry? overlayEntry;

  /// A [OverlayPortal] makes its overlay child a render child of an ancestor
  /// [Overlay]. Currently, to make sure the overlay child is painted after its
  /// [OverlayPortal], and before the next [OverlayEntry] (which could be
  /// something that should obstruct the overlay child, such as a [ModalRoute])
  /// in the host [Overlay], the paint order of each overlay child is managed by
  /// the [OverlayEntry] that hosts its [OverlayPortal].
  ///
  /// The following methods are exposed to allow easy access to the overlay
  /// children's render objects whose order is managed by [overlayEntry], in the
  /// right order.

  // _overlayStateMounted is set to null in _OverlayEntryWidgetState's dispose
  // method. This property is only accessed during layout, paint and hit-test so
  // the `value!` should be safe.
  Iterator<RenderBox>? get paintOrderIterator =>
      overlayEntry?._overlayEntryStateNotifier?.value!._paintOrderIterable.iterator;
  Iterator<RenderBox>? get hitTestOrderIterator =>
      overlayEntry?._overlayEntryStateNotifier?.value!._hitTestOrderIterable.iterator;

  // A convenience method for traversing `paintOrderIterator` with a
  // [RenderObjectVisitor].
  void visitOverlayPortalChildrenOnOverlayEntry(RenderObjectVisitor visitor) =>
      overlayEntry?._overlayEntryStateNotifier?.value!._paintOrderIterable.forEach(visitor);
}

class _RenderTheater extends RenderBox
    with ContainerRenderObjectMixin<RenderBox, StackParentData>, _RenderTheaterMixin {
  _RenderTheater({
    List<RenderBox>? children,
    required TextDirection textDirection,
    int skipCount = 0,
    Clip clipBehavior = Clip.hardEdge,
  }) : assert(skipCount >= 0),
       _textDirection = textDirection,
       _skipCount = skipCount,
       _clipBehavior = clipBehavior {
    addAll(children);
  }

  @override
  _RenderTheater get theater => this;

  @override
  void setupParentData(RenderBox child) {
    if (child.parentData is! _TheaterParentData) {
      child.parentData = _TheaterParentData();
    }
  }

  @override
  void attach(PipelineOwner owner) {
    super.attach(owner);
    RenderBox? child = firstChild;
    while (child != null) {
      final _TheaterParentData childParentData = child.parentData! as _TheaterParentData;
      final Iterator<RenderBox>? iterator = childParentData.paintOrderIterator;
      if (iterator != null) {
        while (iterator.moveNext()) {
          iterator.current.attach(owner);
        }
      }
      child = childParentData.nextSibling;
    }
  }

  static void _detachChild(RenderObject child) => child.detach();

  @override
  void detach() {
    super.detach();
    RenderBox? child = firstChild;
    while (child != null) {
      final _TheaterParentData childParentData = child.parentData! as _TheaterParentData;
      childParentData.visitOverlayPortalChildrenOnOverlayEntry(_detachChild);
      child = childParentData.nextSibling;
    }
  }

  @override
  void redepthChildren() => visitChildren(redepthChild);

  Alignment? _alignmentCache;
  Alignment get _resolvedAlignment =>
      _alignmentCache ??= AlignmentDirectional.topStart.resolve(textDirection);

  void _markNeedResolution() {
    _alignmentCache = null;
    markNeedsLayout();
  }

  TextDirection get textDirection => _textDirection;
  TextDirection _textDirection;
  set textDirection(TextDirection value) {
    if (_textDirection == value) {
      return;
    }
    _textDirection = value;
    _markNeedResolution();
  }

  int get skipCount => _skipCount;
  int _skipCount;
  set skipCount(int value) {
    if (_skipCount != value) {
      _skipCount = value;
      markNeedsLayout();
    }
  }

  /// {@macro flutter.material.Material.clipBehavior}
  ///
  /// Defaults to [Clip.hardEdge].
  Clip get clipBehavior => _clipBehavior;
  Clip _clipBehavior = Clip.hardEdge;
  set clipBehavior(Clip value) {
    if (value != _clipBehavior) {
      _clipBehavior = value;
      markNeedsPaint();
      markNeedsSemanticsUpdate();
    }
  }

  // Adding/removing deferred child does not affect the layout of other children,
  // or that of the Overlay, so there's no need to invalidate the layout of the
  // Overlay.
  //
  // When _skipMarkNeedsLayout is true, markNeedsLayout does not do anything.
  bool _skipMarkNeedsLayout = false;
  void _addDeferredChild(_RenderDeferredLayoutBox child) {
    assert(!_skipMarkNeedsLayout);
    _skipMarkNeedsLayout = true;
    adoptChild(child);
    // The Overlay still needs repainting when a deferred child is added. Usually
    // `markNeedsLayout` implies `markNeedsPaint`, but here `markNeedsLayout` is
    // skipped when the `_skipMarkNeedsLayout` flag is set.
    markNeedsPaint();
    _skipMarkNeedsLayout = false;

    // After adding `child` to the render tree, we want to make sure it will be
    // laid out in the same frame. This is done by calling markNeedsLayout on the
    // layout surrogate. This ensures `child` is reachable via tree walk (see
    // _RenderLayoutSurrogateProxyBox.performLayout).
    child._layoutSurrogate.markNeedsLayout();
  }

  void _removeDeferredChild(_RenderDeferredLayoutBox child) {
    assert(!_skipMarkNeedsLayout);
    _skipMarkNeedsLayout = true;
    dropChild(child);
    // The Overlay still needs repainting when a deferred child is dropped. See
    // the comment in `_addDeferredChild`.
    markNeedsPaint();
    _skipMarkNeedsLayout = false;
  }

  @override
  void markNeedsLayout() {
    if (!_skipMarkNeedsLayout) {
      super.markNeedsLayout();
    }
  }

  RenderBox? get _firstOnstageChild {
    if (skipCount == super.childCount) {
      return null;
    }
    RenderBox? child = super.firstChild;
    for (int toSkip = skipCount; toSkip > 0; toSkip--) {
      final StackParentData childParentData = child!.parentData! as StackParentData;
      child = childParentData.nextSibling;
      assert(child != null);
    }
    return child;
  }

  RenderBox? get _lastOnstageChild => skipCount == super.childCount ? null : lastChild;

  @override
  double computeMinIntrinsicWidth(double height) {
    return RenderStack.getIntrinsicDimension(
      _firstOnstageChild,
      (RenderBox child) => child.getMinIntrinsicWidth(height),
    );
  }

  @override
  double computeMaxIntrinsicWidth(double height) {
    return RenderStack.getIntrinsicDimension(
      _firstOnstageChild,
      (RenderBox child) => child.getMaxIntrinsicWidth(height),
    );
  }

  @override
  double computeMinIntrinsicHeight(double width) {
    return RenderStack.getIntrinsicDimension(
      _firstOnstageChild,
      (RenderBox child) => child.getMinIntrinsicHeight(width),
    );
  }

  @override
  double computeMaxIntrinsicHeight(double width) {
    return RenderStack.getIntrinsicDimension(
      _firstOnstageChild,
      (RenderBox child) => child.getMaxIntrinsicHeight(width),
    );
  }

  @override
  double? computeDryBaseline(BoxConstraints constraints, TextBaseline baseline) {
    final Size size =
        constraints.biggest.isFinite
            ? constraints.biggest
            : _findSizeDeterminingChild().getDryLayout(constraints);
    final BoxConstraints nonPositionedChildConstraints = BoxConstraints.tight(size);
    final Alignment alignment = theater._resolvedAlignment;

    BaselineOffset baselineOffset = BaselineOffset.noBaseline;
    for (final RenderBox child in _childrenInPaintOrder()) {
      baselineOffset = baselineOffset.minOf(
        BaselineOffset(
          _RenderTheaterMixin.baselineForChild(
            child,
            size,
            nonPositionedChildConstraints,
            alignment,
            baseline,
          ),
        ),
      );
    }
    return baselineOffset.offset;
  }

  @override
  Size computeDryLayout(BoxConstraints constraints) {
    if (constraints.biggest.isFinite) {
      return constraints.biggest;
    }
    return _findSizeDeterminingChild().getDryLayout(constraints);
  }

  @override
  // The following uses sync* because concurrent modifications should be allowed
  // during layout.
  Iterable<RenderBox> _childrenInPaintOrder() sync* {
    RenderBox? child = _firstOnstageChild;
    while (child != null) {
      yield child;
      final _TheaterParentData childParentData = child.parentData! as _TheaterParentData;
      final Iterator<RenderBox>? innerIterator = childParentData.paintOrderIterator;
      if (innerIterator != null) {
        while (innerIterator.moveNext()) {
          yield innerIterator.current;
        }
      }
      child = childParentData.nextSibling;
    }
  }

  @override
  // The following uses sync* because hit testing should be lazy.
  Iterable<RenderBox> _childrenInHitTestOrder() sync* {
    RenderBox? child = _lastOnstageChild;
    int childLeft = childCount - skipCount;
    while (child != null) {
      final _TheaterParentData childParentData = child.parentData! as _TheaterParentData;
      final Iterator<RenderBox>? innerIterator = childParentData.hitTestOrderIterator;
      if (innerIterator != null) {
        while (innerIterator.moveNext()) {
          yield innerIterator.current;
        }
      }
      yield child;
      childLeft -= 1;
      child = childLeft <= 0 ? null : childParentData.previousSibling;
    }
  }

  @override
  bool get sizedByParent => false;

  bool _layingOutSizeDeterminingChild = false;
  @override
  void performLayout() {
    RenderBox? sizeDeterminingChild;
    if (constraints.biggest.isFinite) {
      size = constraints.biggest;
    } else {
      sizeDeterminingChild = _findSizeDeterminingChild();
      _layingOutSizeDeterminingChild = true;
      layoutChild(sizeDeterminingChild, constraints);
      _layingOutSizeDeterminingChild = false;
      size = sizeDeterminingChild.size;
    }

    // Equivalent to BoxConstraints used by RenderStack for StackFit.expand.
    final BoxConstraints nonPositionedChildConstraints = BoxConstraints.tight(size);
    for (final RenderBox child in _childrenInPaintOrder()) {
      if (child != sizeDeterminingChild) {
        layoutChild(child, nonPositionedChildConstraints);
      }
    }
  }

  RenderBox _findSizeDeterminingChild() {
    RenderBox? child = _lastOnstageChild;
    while (child != null) {
      final _TheaterParentData childParentData = child.parentData! as _TheaterParentData;
      if ((childParentData.overlayEntry?.canSizeOverlay ?? false) &&
          !childParentData.isPositioned) {
        return child;
      }
      child = childParentData.previousSibling;
    }
    throw FlutterError.fromParts(<DiagnosticsNode>[
      ErrorSummary(
        'Overlay was given infinite constraints and cannot be sized by a suitable child.',
      ),
      ErrorDescription(
        'The constraints given to the overlay ($constraints) would result in an illegal '
        'infinite size (${constraints.biggest}). To avoid that, the Overlay tried to size '
        'itself to one of its children, but no suitable non-positioned child that belongs to an '
        'OverlayEntry with canSizeOverlay set to true could be found.',
      ),
      ErrorHint(
        'Try wrapping the Overlay in a SizedBox to give it a finite size or '
        'use an OverlayEntry with canSizeOverlay set to true.',
      ),
    ]);
  }

  final LayerHandle<ClipRectLayer> _clipRectLayer = LayerHandle<ClipRectLayer>();

  @override
  void paint(PaintingContext context, Offset offset) {
    if (clipBehavior != Clip.none) {
      _clipRectLayer.layer = context.pushClipRect(
        needsCompositing,
        offset,
        Offset.zero & size,
        super.paint,
        clipBehavior: clipBehavior,
        oldLayer: _clipRectLayer.layer,
      );
    } else {
      _clipRectLayer.layer = null;
      super.paint(context, offset);
    }
  }

  @override
  void dispose() {
    _clipRectLayer.layer = null;
    super.dispose();
  }

  @override
  void visitChildren(RenderObjectVisitor visitor) {
    RenderBox? child = firstChild;
    while (child != null) {
      visitor(child);
      final _TheaterParentData childParentData = child.parentData! as _TheaterParentData;
      childParentData.visitOverlayPortalChildrenOnOverlayEntry(visitor);
      child = childParentData.nextSibling;
    }
  }

  @override
  void visitChildrenForSemantics(RenderObjectVisitor visitor) {
    RenderBox? child = _firstOnstageChild;
    while (child != null) {
      visitor(child);
      final _TheaterParentData childParentData = child.parentData! as _TheaterParentData;
      child = childParentData.nextSibling;
    }
  }

  @override
  Rect? describeApproximatePaintClip(RenderObject child) {
    switch (clipBehavior) {
      case Clip.none:
        return null;
      case Clip.hardEdge:
      case Clip.antiAlias:
      case Clip.antiAliasWithSaveLayer:
        return Offset.zero & size;
    }
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties.add(IntProperty('skipCount', skipCount));
    properties.add(EnumProperty<TextDirection>('textDirection', textDirection));
  }

  @override
  List<DiagnosticsNode> debugDescribeChildren() {
    final List<DiagnosticsNode> offstageChildren = <DiagnosticsNode>[];
    final List<DiagnosticsNode> onstageChildren = <DiagnosticsNode>[];

    int count = 1;
    bool onstage = false;
    RenderBox? child = firstChild;
    final RenderBox? firstOnstageChild = _firstOnstageChild;
    while (child != null) {
      final _TheaterParentData childParentData = child.parentData! as _TheaterParentData;
      if (child == firstOnstageChild) {
        onstage = true;
        count = 1;
      }

      if (onstage) {
        onstageChildren.add(child.toDiagnosticsNode(name: 'onstage $count'));
      } else {
        offstageChildren.add(
          child.toDiagnosticsNode(name: 'offstage $count', style: DiagnosticsTreeStyle.offstage),
        );
      }

      int subcount = 1;
      childParentData.visitOverlayPortalChildrenOnOverlayEntry((RenderObject renderObject) {
        final RenderBox child = renderObject as RenderBox;
        if (onstage) {
          onstageChildren.add(child.toDiagnosticsNode(name: 'onstage $count - $subcount'));
        } else {
          offstageChildren.add(
            child.toDiagnosticsNode(
              name: 'offstage $count - $subcount',
              style: DiagnosticsTreeStyle.offstage,
            ),
          );
        }
        subcount += 1;
      });

      child = childParentData.nextSibling;
      count += 1;
    }

    return <DiagnosticsNode>[
      ...onstageChildren,
      if (offstageChildren.isNotEmpty)
        ...offstageChildren
      else
        DiagnosticsNode.message('no offstage children', style: DiagnosticsTreeStyle.offstage),
    ];
  }
}

// * OverlayPortal Implementation
//  OverlayPortal is inspired by the
//  [flutter_portal](https://pub.dev/packages/flutter_portal) package.
//
// ** RenderObject hierarchy
// The widget works by inserting its overlay child's render subtree directly
// under [Overlay]'s render object (_RenderTheater).
// https://user-images.githubusercontent.com/31859944/171971838-62ed3975-4b5d-4733-a9c9-f79e263b8fcc.jpg
//
// To ensure the overlay child render subtree does not do layout twice, the
// subtree must only perform layout after both its _RenderTheater and the
// [OverlayPortal]'s render object (_RenderLayoutSurrogateProxyBox) have
// finished layout. This is handled by _RenderDeferredLayoutBox.
//
// ** Z-Index of an overlay child
// [_OverlayEntryLocation] is a (currently private) interface that allows an
// [OverlayPortal] to insert its overlay child into a specific [Overlay], as
// well as specifying the paint order between the overlay child and other
// children of the _RenderTheater.
//
// Since [OverlayPortal] is only allowed to target ancestor [Overlay]s
// (_RenderTheater must finish doing layout before _RenderDeferredLayoutBox),
// the _RenderTheater should typically be acquired using an [InheritedWidget]
// (currently, _RenderTheaterMarker) in case the [OverlayPortal] gets
// reparented.

/// A class to show, hide and bring to top an [OverlayPortal]'s overlay child
/// in the target [Overlay].
///
/// A [OverlayPortalController] can only be given to at most one [OverlayPortal]
/// at a time. When an [OverlayPortalController] is moved from one
/// [OverlayPortal] to another, its [isShowing] state does not carry over.
///
/// [OverlayPortalController.show] and [OverlayPortalController.hide] can be
/// called even before the controller is assigned to any [OverlayPortal], but
/// they typically should not be called while the widget tree is being rebuilt.
class OverlayPortalController {
  /// Creates an [OverlayPortalController], optionally with a String identifier
  /// `debugLabel`.
  OverlayPortalController({String? debugLabel}) : _debugLabel = debugLabel;

  _OverlayPortalState? _attachTarget;

  // A separate _zOrderIndex to allow `show()` or `hide()` to be called when the
  // controller is not yet attached. Once this controller is attached,
  // _attachTarget._zOrderIndex will be used as the source of truth, and this
  // variable will be set to null.
  int? _zOrderIndex;
  final String? _debugLabel;

  static int _wallTime =
      kIsWeb
          ? -9007199254740992 // -2^53
          : -1 << 63;

  // Returns a unique and monotonically increasing timestamp that represents
  // now.
  //
  // The value this method returns increments after each call.
  int _now() {
    final int now = _wallTime += 1;
    assert(_zOrderIndex == null || _zOrderIndex! < now);
    assert(_attachTarget?._zOrderIndex == null || _attachTarget!._zOrderIndex! < now);
    return now;
  }

  /// Show the overlay child of the [OverlayPortal] this controller is attached
  /// to, at the top of the target [Overlay].
  ///
  /// When there are more than one [OverlayPortal]s that target the same
  /// [Overlay], the overlay child of the last [OverlayPortal] to have called
  /// [show] appears at the top level, unobstructed.
  ///
  /// If [isShowing] is already true, calling this method brings the overlay
  /// child it controls to the top.
  ///
  /// This method should typically not be called while the widget tree is being
  /// rebuilt.
  void show() {
    final _OverlayPortalState? state = _attachTarget;
    if (state != null) {
      state.show(_now());
    } else {
      _zOrderIndex = _now();
    }
  }

  /// Hide the [OverlayPortal]'s overlay child.
  ///
  /// Once hidden, the overlay child will be removed from the widget tree the
  /// next time the widget tree rebuilds, and stateful widgets in the overlay
  /// child may lose states as a result.
  ///
  /// This method should typically not be called while the widget tree is being
  /// rebuilt.
  void hide() {
    final _OverlayPortalState? state = _attachTarget;
    if (state != null) {
      state.hide();
    } else {
      assert(_zOrderIndex != null);
      _zOrderIndex = null;
    }
  }

  /// Whether the associated [OverlayPortal] should build and show its overlay
  /// child, using its `overlayChildBuilder`.
  bool get isShowing {
    final _OverlayPortalState? state = _attachTarget;
    return state != null ? state._zOrderIndex != null : _zOrderIndex != null;
  }

  /// Convenience method for toggling the current [isShowing] status.
  ///
  /// This method should typically not be called while the widget tree is being
  /// rebuilt.
  void toggle() => isShowing ? hide() : show();

  @override
  String toString() {
    final String? debugLabel = _debugLabel;
    final String label = debugLabel == null ? '' : '($debugLabel)';
    final String isDetached = _attachTarget != null ? '' : ' DETACHED';
    return '${objectRuntimeType(this, 'OverlayPortalController')}$label$isDetached';
  }
}

/// A widget that renders its overlay child on an [Overlay].
///
/// The overlay child is initially hidden until [OverlayPortalController.show]
/// is called on the associated [controller]. The [OverlayPortal] uses
/// [overlayChildBuilder] to build its overlay child and renders it on the
/// specified [Overlay] as if it was inserted using an [OverlayEntry], while it
/// can depend on the same set of [InheritedWidget]s (such as [Theme]) that this
/// widget can depend on.
///
/// This widget requires an [Overlay] ancestor in the widget tree when its
/// overlay child is showing. The overlay child is rendered by the [Overlay]
/// ancestor, not by the widget itself. This allows the overlay child to float
/// above other widgets, independent of its position in the widget tree.
///
/// When [OverlayPortalController.hide] is called, the widget built using
/// [overlayChildBuilder] will be removed from the widget tree the next time the
/// widget rebuilds. Stateful descendants in the overlay child subtree may lose
/// states as a result.
///
/// {@tool dartpad}
/// This example uses an [OverlayPortal] to build a tooltip that becomes visible
/// when the user taps on the [child] widget. There's a [DefaultTextStyle] above
/// the [OverlayPortal] controlling the [TextStyle] of both the [child] widget
/// and the widget [overlayChildBuilder] builds, which isn't otherwise doable if
/// the tooltip was added as an [OverlayEntry].
///
/// ** See code in examples/api/lib/widgets/overlay/overlay_portal.0.dart **
/// {@end-tool}
///
/// ### Paint Order
///
/// In an [Overlay], an overlay child is painted after the [OverlayEntry]
/// associated with its [OverlayPortal] (that is, the [OverlayEntry] closest to
/// the [OverlayPortal] in the widget tree, which usually represents the
/// enclosing [Route]), and before the next [OverlayEntry].
///
/// When an [OverlayEntry] has multiple associated [OverlayPortal]s, the paint
/// order between their overlay children is the order in which
/// [OverlayPortalController.show] was called. The last [OverlayPortal] to have
/// called `show` gets to paint its overlay child in the foreground.
///
/// ### Semantics
///
/// The semantics subtree generated by the overlay child is considered attached
/// to [OverlayPortal] instead of the target [Overlay]. An [OverlayPortal]'s
/// semantics subtree can be dropped from the semantics tree due to invisibility
/// while the overlay child is still visible (for example, when the
/// [OverlayPortal] is completely invisible in a [ListView] but kept alive by
/// a [KeepAlive] widget). When this happens the semantics subtree generated by
/// the overlay child is also dropped, even if the overlay child is still visible
/// on screen.
///
/// {@template flutter.widgets.overlayPortalVsOverlayEntry}
/// ### Differences between [OverlayPortal] and [OverlayEntry]
///
/// The main difference between [OverlayEntry] and [OverlayPortal] is that
/// [OverlayEntry] builds its widget subtree as a child of the target [Overlay],
/// while [OverlayPortal] uses [OverlayPortal.overlayChildBuilder] to build a
/// child widget of itself. This allows [OverlayPortal]'s overlay child to depend
/// on the same set of [InheritedWidget]s as [OverlayPortal], and it's also
/// guaranteed that the overlay child will not outlive its [OverlayPortal].
///
/// On the other hand, [OverlayPortal]'s implementation is more complex. For
/// instance, it does a bit more work than a regular widget during global key
/// reparenting. If the content to be shown on the [Overlay] doesn't benefit
/// from being a part of [OverlayPortal]'s subtree, consider using an
/// [OverlayEntry] instead.
/// {@endtemplate}
///
/// See also:
///
///  * [OverlayEntry], an alternative API for inserting widgets into an
///    [Overlay].
///  * [Positioned], which can be used to size and position the overlay child in
///    relation to the target [Overlay]'s boundaries.
///  * [CompositedTransformFollower], which can be used to position the overlay
///    child in relation to the linked [CompositedTransformTarget] widget.
class OverlayPortal extends StatefulWidget {
  /// Creates an [OverlayPortal] that renders the widget [overlayChildBuilder]
  /// builds on the closest [Overlay] when [OverlayPortalController.show] is
  /// called.
  const OverlayPortal({
    super.key,
    required this.controller,
    required this.overlayChildBuilder,
    this.child,
  }) : _targetRootOverlay = false;

  /// Creates an [OverlayPortal] that renders the widget [overlayChildBuilder]
  /// builds on the root [Overlay] when [OverlayPortalController.show] is
  /// called.
  const OverlayPortal.targetsRootOverlay({
    super.key,
    required this.controller,
    required this.overlayChildBuilder,
    this.child,
  }) : _targetRootOverlay = true;

  /// The controller to show, hide and bring to top the overlay child.
  final OverlayPortalController controller;

  /// A [WidgetBuilder] used to build a widget below this widget in the tree,
  /// that renders on the closest [Overlay].
  ///
  /// The said widget will only be built and shown in the closest [Overlay] once
  /// [OverlayPortalController.show] is called on the associated [controller].
  /// It will be painted in front of the [OverlayEntry] closest to this widget
  /// in the widget tree (which is usually the enclosing [Route]).
  ///
  /// The built overlay child widget is inserted below this widget in the widget
  /// tree, allowing it to depend on [InheritedWidget]s above it, and be
  /// notified when the [InheritedWidget]s change.
  ///
  /// Unlike [child], the built overlay child can visually extend outside the
  /// bounds of this widget without being clipped, and receive hit-test events
  /// outside of this widget's bounds, as long as it does not extend outside of
  /// the [Overlay] on which it is rendered.
  final WidgetBuilder overlayChildBuilder;

  /// A widget below this widget in the tree.
  final Widget? child;

  final bool _targetRootOverlay;

  @override
  State<OverlayPortal> createState() => _OverlayPortalState();
}

class _OverlayPortalState extends State<OverlayPortal> {
  int? _zOrderIndex;
  // The location of the overlay child within the overlay. This object will be
  // used as the slot of the overlay child widget.
  //
  // The developer must call `show` to reveal the overlay so we can get a unique
  // timestamp of the user interaction for determining the z-index of the
  // overlay child in the overlay.
  //
  // Avoid invalidating the cache if possible, since the framework uses `==` to
  // compare slots, and _OverlayEntryLocation can't override that operator since
  // it's mutable. Changing slots can be relatively slow.
  bool _childModelMayHaveChanged = true;
  _OverlayEntryLocation? _locationCache;
  static bool _isTheSameLocation(_OverlayEntryLocation locationCache, _RenderTheaterMarker marker) {
    return locationCache._childModel == marker.overlayEntryWidgetState &&
        locationCache._theater == marker.theater;
  }

  _OverlayEntryLocation _getLocation(int zOrderIndex, bool targetRootOverlay) {
    final _OverlayEntryLocation? cachedLocation = _locationCache;
    late final _RenderTheaterMarker marker = _RenderTheaterMarker.of(
      context,
      targetRootOverlay: targetRootOverlay,
    );
    final bool isCacheValid =
        cachedLocation != null &&
        (!_childModelMayHaveChanged || _isTheSameLocation(cachedLocation, marker));
    _childModelMayHaveChanged = false;
    if (isCacheValid) {
      assert(cachedLocation._zOrderIndex == zOrderIndex);
      assert(cachedLocation._debugIsLocationValid());
      return cachedLocation;
    }
    // Otherwise invalidate the cache and create a new location.
    cachedLocation?._debugMarkLocationInvalid();
    final _OverlayEntryLocation newLocation = _OverlayEntryLocation(
      zOrderIndex,
      marker.overlayEntryWidgetState,
      marker.theater,
    );
    assert(newLocation._zOrderIndex == zOrderIndex);
    return _locationCache = newLocation;
  }

  @override
  void initState() {
    super.initState();
    _setupController(widget.controller);
  }

  void _setupController(OverlayPortalController controller) {
    assert(
      controller._attachTarget == null || controller._attachTarget == this,
      'Failed to attach $controller to $this. It is already attached to ${controller._attachTarget}.',
    );
    final int? controllerZOrderIndex = controller._zOrderIndex;
    final int? zOrderIndex = _zOrderIndex;
    if (zOrderIndex == null ||
        (controllerZOrderIndex != null && controllerZOrderIndex > zOrderIndex)) {
      _zOrderIndex = controllerZOrderIndex;
    }
    controller._zOrderIndex = null;
    controller._attachTarget = this;
  }

  @override
  void didChangeDependencies() {
    super.didChangeDependencies();
    _childModelMayHaveChanged = true;
  }

  @override
  void didUpdateWidget(OverlayPortal oldWidget) {
    super.didUpdateWidget(oldWidget);
    _childModelMayHaveChanged =
        _childModelMayHaveChanged || oldWidget._targetRootOverlay != widget._targetRootOverlay;
    if (oldWidget.controller != widget.controller) {
      oldWidget.controller._attachTarget = null;
      _setupController(widget.controller);
    }
  }

  @override
  void dispose() {
    assert(widget.controller._attachTarget == this);
    widget.controller._attachTarget = null;
    _locationCache?._debugMarkLocationInvalid();
    _locationCache = null;
    super.dispose();
  }

  void show(int zOrderIndex) {
    assert(
      SchedulerBinding.instance.schedulerPhase != SchedulerPhase.persistentCallbacks,
      '${widget.controller.runtimeType}.show() should not be called during build.',
    );
    setState(() {
      _zOrderIndex = zOrderIndex;
    });
    _locationCache?._debugMarkLocationInvalid();
    _locationCache = null;
  }

  void hide() {
    assert(SchedulerBinding.instance.schedulerPhase != SchedulerPhase.persistentCallbacks);
    setState(() {
      _zOrderIndex = null;
    });
    _locationCache?._debugMarkLocationInvalid();
    _locationCache = null;
  }

  @override
  Widget build(BuildContext context) {
    final int? zOrderIndex = _zOrderIndex;
    if (zOrderIndex == null) {
      return _OverlayPortal(overlayLocation: null, overlayChild: null, child: widget.child);
    }
    return _OverlayPortal(
      overlayLocation: _getLocation(zOrderIndex, widget._targetRootOverlay),
      overlayChild: _DeferredLayout(child: Builder(builder: widget.overlayChildBuilder)),
      child: widget.child,
    );
  }
}

/// A location in an [Overlay].
///
/// An [_OverlayEntryLocation] determines the [Overlay] the associated
/// [OverlayPortal] should put its overlay child onto, as well as the overlay
/// child's paint order in relation to other contents painted on the [Overlay].
//
// An _OverlayEntryLocation is a cursor pointing to a location in a particular
// Overlay's child model, and provides methods to insert/remove/move a
// _RenderDeferredLayoutBox to/from its target _theater.
//
// The occupant (a `RenderBox`) will be painted above the associated
// [OverlayEntry], but below the [OverlayEntry] above that [OverlayEntry].
//
// Additionally, `_activate` and `_deactivate` are called when the overlay
// child's `_OverlayPortalElement` activates/deactivates (for instance, during
// global key reparenting).
// `_OverlayPortalElement` removes its overlay child's render object from the
// target `_RenderTheater` when it deactivates and puts it back on `activated`.
// These 2 methods can be used to "hide" a child in the child model without
// removing it, when the child is expensive/difficult to re-insert at the
// correct location on `activated`.
//
// ### Equality
//
// An `_OverlayEntryLocation` will be used as an Element's slot. These 3 parts
// uniquely identify a place in an overlay's child model:
// - _theater
// - _childModel (the OverlayEntry)
// - _zOrderIndex
//
// Since it can't implement operator== (it's mutable), the same `_OverlayEntryLocation`
// instance must not be used to represent more than one locations.
final class _OverlayEntryLocation extends LinkedListEntry<_OverlayEntryLocation> {
  _OverlayEntryLocation(this._zOrderIndex, this._childModel, this._theater);

  final int _zOrderIndex;
  final _OverlayEntryWidgetState _childModel;
  final _RenderTheater _theater;

  _RenderDeferredLayoutBox? _overlayChildRenderBox;
  void _addToChildModel(_RenderDeferredLayoutBox child) {
    assert(
      _overlayChildRenderBox == null,
      'Failed to add $child. This location ($this) is already occupied by $_overlayChildRenderBox.',
    );
    _overlayChildRenderBox = child;
    _childModel._add(this);
    _theater.markNeedsPaint();
    _theater.markNeedsCompositingBitsUpdate();
    _theater.markNeedsSemanticsUpdate();
  }

  void _removeFromChildModel(_RenderDeferredLayoutBox child) {
    assert(child == _overlayChildRenderBox);
    _overlayChildRenderBox = null;
    assert(_childModel._sortedTheaterSiblings?.contains(this) ?? false);
    _childModel._remove(this);
    _theater.markNeedsPaint();
    _theater.markNeedsCompositingBitsUpdate();
    _theater.markNeedsSemanticsUpdate();
  }

  void _addChild(_RenderDeferredLayoutBox child) {
    assert(_debugIsLocationValid());
    _addToChildModel(child);
    _theater._addDeferredChild(child);
    assert(child.parent == _theater);
  }

  void _removeChild(_RenderDeferredLayoutBox child) {
    // This call is allowed even when this location is disposed.
    _removeFromChildModel(child);
    _theater._removeDeferredChild(child);
    assert(child.parent == null);
  }

  void _moveChild(_RenderDeferredLayoutBox child, _OverlayEntryLocation fromLocation) {
    assert(fromLocation != this);
    assert(_debugIsLocationValid());
    final _RenderTheater fromTheater = fromLocation._theater;
    final _OverlayEntryWidgetState fromModel = fromLocation._childModel;

    if (fromTheater != _theater) {
      fromTheater._removeDeferredChild(child);
      _theater._addDeferredChild(child);
    }

    if (fromModel != _childModel || fromLocation._zOrderIndex != _zOrderIndex) {
      fromLocation._removeFromChildModel(child);
      _addToChildModel(child);
    }
  }

  void _activate(_RenderDeferredLayoutBox child) {
    // This call is allowed even when this location is invalidated.
    // See _OverlayPortalElement.activate.
    assert(_overlayChildRenderBox == null, '$_overlayChildRenderBox');
    _theater._addDeferredChild(child);
    _overlayChildRenderBox = child;
  }

  void _deactivate(_RenderDeferredLayoutBox child) {
    // This call is allowed even when this location is invalidated.
    _theater._removeDeferredChild(child);
    _overlayChildRenderBox = null;
  }

  // Throws a StateError if this location is already invalidated and shouldn't
  // be used as an OverlayPortal slot. Must be used in asserts.
  //
  // Generally, `assert(_debugIsLocationValid())` should be used to prevent
  // invalid accesses to an invalid `_OverlayEntryLocation` object. Exceptions
  // to this rule are _removeChild, _deactivate, which will be called when the
  // OverlayPortal is being removed from the widget tree and may use the
  // location information to perform cleanup tasks.
  //
  // Another exception is the _activate method which is called by
  // _OverlayPortalElement.activate. See the comment in _OverlayPortalElement.activate.
  bool _debugIsLocationValid() {
    if (_debugMarkLocationInvalidStackTrace == null) {
      return true;
    }
    throw StateError(
      '$this is already disposed. Stack trace: $_debugMarkLocationInvalidStackTrace',
    );
  }

  // The StackTrace of the first _debugMarkLocationInvalid call. It's only for
  // debugging purposes and the StackTrace will only be captured in debug builds.
  //
  // The effect of this method is not reversible. Once marked invalid, this
  // object can't be marked as valid again.
  StackTrace? _debugMarkLocationInvalidStackTrace;
  @mustCallSuper
  void _debugMarkLocationInvalid() {
    assert(_debugIsLocationValid());
    assert(() {
      _debugMarkLocationInvalidStackTrace = StackTrace.current;
      return true;
    }());
  }

  @override
  String toString() =>
      '${objectRuntimeType(this, '_OverlayEntryLocation')}[${shortHash(this)}] ${_debugMarkLocationInvalidStackTrace != null ? "(INVALID)" : ""}';
}

class _RenderTheaterMarker extends InheritedWidget {
  const _RenderTheaterMarker({
    required this.theater,
    required this.overlayEntryWidgetState,
    required super.child,
  });

  final _RenderTheater theater;
  final _OverlayEntryWidgetState overlayEntryWidgetState;

  @override
  bool updateShouldNotify(_RenderTheaterMarker oldWidget) {
    return oldWidget.theater != theater ||
        oldWidget.overlayEntryWidgetState != overlayEntryWidgetState;
  }

  static _RenderTheaterMarker of(BuildContext context, {bool targetRootOverlay = false}) {
    final _RenderTheaterMarker? marker;
    if (targetRootOverlay) {
      final InheritedElement? ancestor = _rootRenderTheaterMarkerOf(
        context.getElementForInheritedWidgetOfExactType<_RenderTheaterMarker>(),
      );
      assert(ancestor == null || ancestor.widget is _RenderTheaterMarker);
      marker =
          ancestor != null
              ? context.dependOnInheritedElement(ancestor) as _RenderTheaterMarker?
              : null;
    } else {
      marker = context.dependOnInheritedWidgetOfExactType<_RenderTheaterMarker>();
    }
    if (marker != null) {
      return marker;
    }
    throw FlutterError.fromParts(<DiagnosticsNode>[
      ErrorSummary('No Overlay widget found.'),
      ErrorDescription(
        '${context.widget.runtimeType} widgets require an Overlay widget ancestor.\n'
        'An overlay lets widgets float on top of other widget children.',
      ),
      ErrorHint(
        'To introduce an Overlay widget, you can either directly '
        'include one, or use a widget that contains an Overlay itself, '
        'such as a Navigator, WidgetApp, MaterialApp, or CupertinoApp.',
      ),
      ...context.describeMissingAncestor(expectedAncestorType: Overlay),
    ]);
  }

  static InheritedElement? _rootRenderTheaterMarkerOf(InheritedElement? theaterMarkerElement) {
    assert(theaterMarkerElement == null || theaterMarkerElement.widget is _RenderTheaterMarker);
    if (theaterMarkerElement == null) {
      return null;
    }
    InheritedElement? ancestor;
    theaterMarkerElement.visitAncestorElements((Element element) {
      ancestor = element.getElementForInheritedWidgetOfExactType<_RenderTheaterMarker>();
      return false;
    });
    return ancestor == null ? theaterMarkerElement : _rootRenderTheaterMarkerOf(ancestor);
  }
}

class _OverlayPortal extends RenderObjectWidget {
  /// Creates a widget that renders the given [overlayChild] in the [Overlay]
  /// specified by `overlayLocation`.
  ///
  /// The `overlayLocation` parameter must not be null when [overlayChild] is not
  /// null.
  _OverlayPortal({required this.overlayLocation, required this.overlayChild, required this.child})
    : assert(overlayChild == null || overlayLocation != null),
      assert(overlayLocation == null || overlayLocation._debugIsLocationValid());

  final Widget? overlayChild;

  /// A widget below this widget in the tree.
  final Widget? child;

  final _OverlayEntryLocation? overlayLocation;

  @override
  RenderObjectElement createElement() => _OverlayPortalElement(this);

  @override
  RenderObject createRenderObject(BuildContext context) => _RenderLayoutSurrogateProxyBox();
}

class _OverlayPortalElement extends RenderObjectElement {
  _OverlayPortalElement(_OverlayPortal super.widget);

  @override
  _RenderLayoutSurrogateProxyBox get renderObject =>
      super.renderObject as _RenderLayoutSurrogateProxyBox;

  Element? _overlayChild;
  Element? _child;

  @override
  void mount(Element? parent, Object? newSlot) {
    super.mount(parent, newSlot);
    final _OverlayPortal widget = this.widget as _OverlayPortal;
    _child = updateChild(_child, widget.child, null);
    _overlayChild = updateChild(_overlayChild, widget.overlayChild, widget.overlayLocation);
  }

  @override
  void update(_OverlayPortal newWidget) {
    super.update(newWidget);
    _child = updateChild(_child, newWidget.child, null);
    _overlayChild = updateChild(_overlayChild, newWidget.overlayChild, newWidget.overlayLocation);
  }

  @override
  void forgetChild(Element child) {
    // The _overlayChild Element does not have a key because the _DeferredLayout
    // widget does not take a Key, so only the regular _child can be taken
    // during global key reparenting.
    assert(child == _child);
    _child = null;
    super.forgetChild(child);
  }

  @override
  void visitChildren(ElementVisitor visitor) {
    final Element? child = _child;
    final Element? overlayChild = _overlayChild;
    if (child != null) {
      visitor(child);
    }
    if (overlayChild != null) {
      visitor(overlayChild);
    }
  }

  @override
  void activate() {
    super.activate();
    final _RenderDeferredLayoutBox? box = _overlayChild?.renderObject as _RenderDeferredLayoutBox?;
    if (box != null) {
      assert(!box.attached);
      assert(renderObject._deferredLayoutChild == box);
      // updateChild has not been called at this point so the RenderTheater in
      // the overlay location could be detached. Adding children to a detached
      // RenderObject is still allowed however this isn't the most efficient.
      (_overlayChild!.slot! as _OverlayEntryLocation)._activate(box);
    }
  }

  @override
  void deactivate() {
    // Instead of just detaching the render objects, removing them from the
    // render subtree entirely. This is a workaround for the
    // !renderObject.attached assert in the `super.deactivate()` method.
    final _RenderDeferredLayoutBox? box = _overlayChild?.renderObject as _RenderDeferredLayoutBox?;
    if (box != null) {
      (_overlayChild!.slot! as _OverlayEntryLocation)._deactivate(box);
    }
    super.deactivate();
  }

  @override
  void insertRenderObjectChild(RenderBox child, _OverlayEntryLocation? slot) {
    assert(child.parent == null, "$child's parent is not null: ${child.parent}");
    if (slot != null) {
      renderObject._deferredLayoutChild = child as _RenderDeferredLayoutBox;
      slot._addChild(child);
      renderObject.markNeedsSemanticsUpdate();
    } else {
      renderObject.child = child;
    }
  }

  // The [_DeferredLayout] widget does not have a key so there will be no
  // reparenting between _overlayChild and _child, thus the non-null-typed slots.
  @override
  void moveRenderObjectChild(
    _RenderDeferredLayoutBox child,
    _OverlayEntryLocation oldSlot,
    _OverlayEntryLocation newSlot,
  ) {
    assert(newSlot._debugIsLocationValid());
    newSlot._moveChild(child, oldSlot);
    renderObject.markNeedsSemanticsUpdate();
  }

  @override
  void removeRenderObjectChild(RenderBox child, _OverlayEntryLocation? slot) {
    if (slot == null) {
      renderObject.child = null;
      return;
    }
    assert(renderObject._deferredLayoutChild == child);
    slot._removeChild(child as _RenderDeferredLayoutBox);
    renderObject._deferredLayoutChild = null;
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties.add(DiagnosticsProperty<Element>('child', _child, defaultValue: null));
    properties.add(DiagnosticsProperty<Element>('overlayChild', _overlayChild, defaultValue: null));
    properties.add(
      DiagnosticsProperty<Object>('overlayLocation', _overlayChild?.slot, defaultValue: null),
    );
  }
}

class _DeferredLayout extends SingleChildRenderObjectWidget {
  const _DeferredLayout({
    // This widget must not be given a key: we currently do not support
    // reparenting between the overlayChild and child.
    required Widget child,
  }) : super(child: child);

  _RenderLayoutSurrogateProxyBox getLayoutParent(BuildContext context) {
    return context.findAncestorRenderObjectOfType<_RenderLayoutSurrogateProxyBox>()!;
  }

  @override
  _RenderDeferredLayoutBox createRenderObject(BuildContext context) {
    final _RenderLayoutSurrogateProxyBox parent = getLayoutParent(context);
    final _RenderDeferredLayoutBox renderObject = _RenderDeferredLayoutBox(parent);
    parent._deferredLayoutChild = renderObject;
    return renderObject;
  }

  @override
  void updateRenderObject(BuildContext context, _RenderDeferredLayoutBox renderObject) {
    assert(renderObject._layoutSurrogate == getLayoutParent(context));
    assert(getLayoutParent(context)._deferredLayoutChild == renderObject);
  }
}

// A `RenderProxyBox` that defers its layout until its `_layoutSurrogate` (which
// is not necessarily an ancestor of this RenderBox, but shares at least one
// `_RenderTheater` ancestor with this RenderBox) is laid out.
//
// This `RenderObject` must be a child of a `_RenderTheater`. It guarantees that:
//
// 1. It's a relayout boundary, so calling `markNeedsLayout` on it never dirties
//    its `_RenderTheater`.
//
// 2. Its `layout` implementation is overridden such that `performLayout` does
//    not do anything when its called from `layout`, preventing the parent
//    `_RenderTheater` from laying out this subtree prematurely (but this
//    `RenderObject` may still be resized). Instead, `markNeedsLayout` will be
//    called from within `layout` to schedule a layout update for this relayout
//    boundary when needed.
//
// 3. When invoked from `PipelineOwner.flushLayout`, or
//    `_layoutSurrogate.performLayout`, this `RenderObject` behaves like an
//    `Overlay` that has only one entry.
final class _RenderDeferredLayoutBox extends RenderProxyBox
    with _RenderTheaterMixin, LinkedListEntry<_RenderDeferredLayoutBox> {
  _RenderDeferredLayoutBox(this._layoutSurrogate);

  StackParentData get stackParentData => parentData! as StackParentData;
  final _RenderLayoutSurrogateProxyBox _layoutSurrogate;

  @override
  Iterable<RenderBox> _childrenInPaintOrder() {
    final RenderBox? child = this.child;
    return child == null
        ? const Iterable<RenderBox>.empty()
        : Iterable<RenderBox>.generate(1, (int i) => child);
  }

  @override
  Iterable<RenderBox> _childrenInHitTestOrder() => _childrenInPaintOrder();

  @override
  _RenderTheater get theater {
    final RenderObject? parent = this.parent;
    return parent is _RenderTheater
        ? parent
        : throw FlutterError('$parent of $this is not a _RenderTheater');
  }

  @override
  void redepthChildren() {
    _layoutSurrogate.redepthChild(this);
    super.redepthChildren();
  }

  @override
  bool get sizedByParent => true;

  bool _needsLayout = true;
  @override
  void markNeedsLayout() {
    _needsLayout = true;
    super.markNeedsLayout();
  }

  @override
  RenderObject? get semanticsParent => _layoutSurrogate;

  @override
  double? computeDryBaseline(BoxConstraints constraints, TextBaseline baseline) {
    final RenderBox? child = this.child;
    if (child == null) {
      return null;
    }
    return _RenderTheaterMixin.baselineForChild(
      child,
      constraints.biggest,
      constraints,
      theater._resolvedAlignment,
      baseline,
    );
  }

  @override
  RenderObject? get debugLayoutParent => _layoutSurrogate;

  void layoutByLayoutSurrogate() {
    assert(!_theaterDoingThisLayout);
    final _RenderTheater? theater = parent as _RenderTheater?;
    if (theater == null || !attached) {
      assert(false, '$this is not attached to parent');
      return;
    }
    if (theater._layingOutSizeDeterminingChild) {
      theater.invokeLayoutCallback((BoxConstraints constraints) {
        markNeedsLayout();
      });
    } else {
      final BoxConstraints theaterConstraints = theater.constraints;
      final Size boxSize =
          theaterConstraints.biggest.isFinite
              ? theaterConstraints.biggest
              // Accessing the theater's size is only unsafe if it is laying out the
              // size-determining child.
              : theater.size;
      super.layout(BoxConstraints.tight(boxSize));
    }
  }

  bool _theaterDoingThisLayout = false;
  @override
  void layout(Constraints constraints, {bool parentUsesSize = false}) {
    assert(_needsLayout == debugNeedsLayout);
    // Only _RenderTheater calls this implementation.
    assert(parent != null);
    final bool scheduleDeferredLayout = _needsLayout || this.constraints != constraints;
    assert(!_theaterDoingThisLayout);
    _theaterDoingThisLayout = true;
    super.layout(constraints, parentUsesSize: parentUsesSize);
    assert(_theaterDoingThisLayout);
    _theaterDoingThisLayout = false;
    _needsLayout = false;
    assert(!debugNeedsLayout);
    if (scheduleDeferredLayout) {
      final _RenderTheater parent = this.parent! as _RenderTheater;
      // Invoking markNeedsLayout as a layout callback allows this node to be
      // merged back to the `PipelineOwner`'s dirty list in the right order, if
      // it's not already dirty. Otherwise this may cause some dirty descendants
      // to performLayout a second time.
      parent.invokeLayoutCallback((BoxConstraints constraints) {
        markNeedsLayout();
      });
    }
  }

  @override
  void performResize() {
    size = constraints.biggest;
  }

  bool _debugMutationsLocked = false;
  @override
  void performLayout() {
    assert(!_debugMutationsLocked);
    if (_theaterDoingThisLayout) {
      _needsLayout = false;
      return;
    }
    assert(() {
      _debugMutationsLocked = true;
      return true;
    }());
    // This method is directly being invoked from `PipelineOwner.flushLayout`,
    // or from `_layoutSurrogate`'s performLayout.
    assert(parent != null);
    final RenderBox? child = this.child;
    if (child == null) {
      _needsLayout = false;
      return;
    }
    assert(constraints.isTight);
    layoutChild(child, constraints);
    assert(() {
      _debugMutationsLocked = false;
      return true;
    }());
    _needsLayout = false;
  }

  @override
  void applyPaintTransform(RenderBox child, Matrix4 transform) {
    final BoxParentData childParentData = child.parentData! as BoxParentData;
    final Offset offset = childParentData.offset;
    transform.translate(offset.dx, offset.dy);
  }
}

// A RenderProxyBox that makes sure its `deferredLayoutChild` has a greater
// depth than itself.
class _RenderLayoutSurrogateProxyBox extends RenderProxyBox {
  _RenderDeferredLayoutBox? _deferredLayoutChild;

  @override
  void redepthChildren() {
    super.redepthChildren();
    final _RenderDeferredLayoutBox? child = _deferredLayoutChild;
    // If child is not attached, this method will be invoked by child's real
    // parent when it's attached.
    if (child != null && child.attached) {
      assert(child.attached);
      redepthChild(child);
    }
  }

  @override
  void performLayout() {
    super.performLayout();
    // Try to layout `_deferredLayoutChild` here now that its configuration
    // and constraints are up-to-date. Additionally, during the very first
    // layout, this makes sure that _deferredLayoutChild is reachable via tree
    // walk.
    _deferredLayoutChild?.layoutByLayoutSurrogate();
  }

  @override
  void visitChildrenForSemantics(RenderObjectVisitor visitor) {
    super.visitChildrenForSemantics(visitor);
    final _RenderDeferredLayoutBox? deferredChild = _deferredLayoutChild;
    if (deferredChild != null) {
      visitor(deferredChild);
    }
  }
}


Instructions for the chapter (Generate content in English unless specified otherwise):
- Start with a clear heading (e.g., `# Chapter 4: OverlayPortal
`). Use the provided concept name.

- If this is not the first chapter, begin with a brief transition from the previous chapter, referencing it with a proper Markdown link using its name.

- Begin with a high-level motivation explaining what problem this abstraction solves. Start with a central use case as a concrete example. The whole chapter should guide the reader to understand how to solve this use case. Make it very minimal and friendly to beginners.

- If the abstraction is complex, break it down into key concepts. Explain each concept one-by-one in a very beginner-friendly way.

- Explain how to use this abstraction to solve the use case. Give example inputs and outputs for code snippets (if the output isn't values, describe at a high level what will happen).

- Each code block should be BELOW 10 lines! If longer code blocks are needed, break them down into smaller pieces and walk through them one-by-one. Aggresively simplify the code to make it minimal. Use comments to skip non-important implementation details. Each code block should have a beginner friendly explanation right after it.

- Describe the internal implementation to help understand what's under the hood. First provide a non-code or code-light walkthrough on what happens step-by-step when the abstraction is called. It's recommended to use a simple sequenceDiagram with a dummy example - keep it minimal with at most 5 participants to ensure clarity. If participant name has space, use: `participant QP as Query Processing`. .

- Then dive deeper into code for the internal implementation with references to files. Provide example code blocks, but make them similarly simple and beginner-friendly. Explain.

- IMPORTANT: When you need to refer to other core abstractions covered in other chapters, ALWAYS use proper Markdown links like this: [Chapter Title](filename.md). Use the Complete Tutorial Structure above to find the correct filename and the chapter title. Translate the surrounding text.

- Use mermaid diagrams to illustrate complex concepts (```mermaid``` format). .

- Heavily use analogies and examples throughout to help beginners understand.

- End the chapter with a brief conclusion that summarizes what was learned and provides a transition to the next chapter. If there is a next chapter, use a proper Markdown link: [Next Chapter Title](next_chapter_filename).

- Ensure the tone is welcoming and easy for a newcomer to understand.

- Output *only* the Markdown content for this chapter.

Now, directly provide a super beginner-friendly Markdown output (DON'T need ```markdown``` tags):

2025-05-22 23:58:01,413 - INFO - RESPONSE: # Chapter 4: OverlayPortal

Welcome back! In our [previous chapters](01_overlay_.md), we built a solid understanding of the [Overlay](01_overlay_.md), the [OverlayState](02_overlaystate_.md) (its manager), and the [OverlayEntry](03_overlayentry_.md) (the sheet holding the widget). We learned how to manually create an [OverlayEntry](03_overlayentry_.md), get the [OverlayState](02_overlaystate_.md), and insert/remove the entry to make a widget appear or disappear on top of everything.

While this manual approach works, sometimes it can feel a bit disconnected. You have your original widget (say, a button that triggers the overlay), and the overlay widget itself is managed separately by the [OverlayState](02_overlaystate_.md), potentially far away in the widget tree. This can make things like keeping the overlay visually positioned relative to the original widget or having the overlay widget inherit themes/context from the original widget's location a bit tricky.

This is where `OverlayPortal` comes in!

Think of `OverlayPortal` as a special window from your widget's location directly to the [Overlay](01_overlay_.md). You place the `OverlayPortal` widget in your widget tree like any other widget. When you want to show something on the [Overlay](01_overlay_.md), you tell the `OverlayPortal`, and it uses a builder function you provide to create the widget.

**The key idea is that the widget you want to show on the [Overlay](01_overlay_.md) feels like it's still attached to your `OverlayPortal`'s spot in the widget tree, even though it's visually displayed on the [Overlay](01_overlay_.md).**

### Our Goal: A Context Menu

Let's refine our goal. Instead of just a simple message box, imagine we want a small context menu to appear right next to a button when you tap it. This menu should float on the [Overlay](01_overlay_.md), but its position should be related to the button, and it should inherit styling (like text themes) from where the button is located.

Using `OverlayPortal`, this becomes much more natural than manual [OverlayEntry](03_overlayentry_.md) management.

### Creating an OverlayPortal

An `OverlayPortal` is a `StatefulWidget` you add to your widget tree. It requires a `controller` (an [OverlayPortalController](05_overlayportalcontroller_.md), which we'll cover in the next chapter) and an `overlayChildBuilder`.

```dart
// Inside your widget's build method:
OverlayPortal(
  controller: _myOverlayController, // We'll make this in the next chapter
  overlayChildBuilder: (BuildContext context) {
    // This is the widget that will show on the Overlay
    return Positioned( // We'll position it later
      top: 100, // Just a placeholder for now
      left: 100, // Just a placeholder for now
      child: Material( // Use Material for styling/elevation
        elevation: 4.0,
        child: Container(
          padding: const EdgeInsets.all(8.0),
          color: Colors.yellow[100],
          child: Text('Context Menu!'),
        ),
      ),
    );
  },
  child: ElevatedButton( // This is the original widget (the button)
    onPressed: () {
      // We will show the overlay here using the controller
    },
    child: const Text('Show Menu'),
  ),
)
```

In this example:

1.  We place the `OverlayPortal` widget in our tree.
2.  We give it an `overlayChildBuilder`. This is very similar to the `builder` for an [OverlayEntry](03_overlayentry_.md)  it's the function that creates the widget for the overlay.
3.  We add a `child` property. This is the regular child widget of the `OverlayPortal` (our `ElevatedButton`).

The widget returned by `overlayChildBuilder` (`Positioned` in this case) will be displayed on the [Overlay](01_overlay_.md), but its `BuildContext` will be a special one that's linked back to the `OverlayPortal`'s location. This is why it can easily inherit themes, etc., from its original position.

Notice that we are using a `Positioned` widget directly in the `overlayChildBuilder`. This is common because `OverlayPortal`'s overlay child is placed within the [Overlay](01_overlay_.md) which behaves like a `Stack`. `Positioned` widgets are used to control the placement of children within a `Stack`.

### How OverlayPortal Works Internally (High Level)

When Flutter lays out the widget tree, it encounters the `OverlayPortal`. Importantly, when its `overlayChildBuilder` *is active* (meaning you've told the controller to show the overlay):

1.  The `OverlayPortal`'s `Element` (specifically an `_OverlayPortalElement`) calls its `overlayChildBuilder` to get the overlay widget.
2.  Instead of painting this widget directly where the `OverlayPortal` is located in the tree, the `_OverlayPortalElement` finds the nearest ancestor [Overlay](01_overlay_.md) (using an internal mechanism involving an `InheritedWidget`, which we'll see later).
3.  It then inserts the *render object* corresponding to the overlay widget into the `_RenderTheater` (the specialized `Stack` that the [Overlay](01_overlay_.md) uses to manage its visual children).
4.  The render object is placed correctly relative to other things on the [Overlay](01_overlay_.md) based on the order defined by the `OverlayPortalController`.
5.  The original `OverlayPortal` widget then continues its standard layout and painting for its `child` widget (the button), as if the overlay widget wasn't there.

This gives the illusion that the overlay widget is coming from the `OverlayPortal`'s location, even though its physical rendering happens on the [Overlay](01_overlay_.md).

Sequence diagram illustrating the key interaction:

```mermaid
sequenceDiagram
    participant YourWidget
    participant OverlayPortal
    participant _OverlayPortalState
    participant _OverlayPortalElement
    participant _TheaterMarker as InheritedWidget
    participant OverlayState
    participant _RenderTheater

    YourWidget->>OverlayPortal: build time (includes OverlayPortal)
    OverlayPortal->>_OverlayPortalState: create state
    _OverlayPortalState->>_OverlayPortalElement: mount element
    _OverlayPortalElement->>_TheaterMarker: look up ancestor Overlay info
    _TheaterMarker-->>_OverlayPortalElement: provide _RenderTheater etc.
    YourWidget->>YourWidget: trigger show via controller (next chapter)
    YourWidget->>_OverlayPortalState: call controller.show()
    _OverlayPortalState->>_OverlayPortalState: update internal state (_zOrderIndex)
    _OverlayPortalState->>YourWidget: setState() triggers rebuild
    YourWidget->>OverlayPortal: rebuild with show=true
    OverlayPortal->>_OverlayPortalElement: update element
    _OverlayPortalElement->>_OverlayPortalElement: call overlayChildBuilder
    _OverlayPortalElement->>_RenderTheater: attach overlay child render object
    _RenderTheater->>_RenderTheater: paint child on overlay
```

This shows how the `OverlayPortal` lives in your regular widget tree but has the ability to "reach out" to the ancestor [Overlay](01_overlay_.md)'s render object tree (`_RenderTheater`) to place its overlay child's render objects there.

### Advantages of OverlayPortal over Manual OverlayEntry

*   **Simplified Management:** You don't manually create, store, insert, or remove [OverlayEntry](03_overlayentry_.md) objects. The `OverlayPortal` widget handles this for you based on the state of its controller.
*   **Context and Inherited Widgets:** The `BuildContext` provided to `overlayChildBuilder` is closely tied to the `OverlayPortal`'s original location. This means your overlay widget automatically inherits themes, `MediaQuery`, `Localizations`, etc., making styling and layout much easier.
*   **State Management:** The lifecycle of the overlay widget is tied to the `OverlayPortal`. If the `OverlayPortal` is disposed, the overlay widget goes away too. This simplifies managing the state of complex overlay children.
*   **Relative Positioning:** While basic `Positioned` works, `OverlayPortal` makes it easier to use widgets like `CompositedTransformTarget` and `CompositedTransformFollower` to position the overlay child precisely relative to the `OverlayPortal`'s location. We used a simple `Positioned` as a placeholder for now, but later chapters might explore this.

### Limitations

*   **Must have an ancestor `Overlay`:** Just like manual [OverlayEntry](03_overlayentry_.md), the `OverlayPortal` needs an [Overlay](01_overlay_.md) widget higher up in the tree to paint on. (Usually provided by `MaterialApp`, `WidgetsApp`, or `Navigator`.)
*   **Requires a controller:** You need to manage an [OverlayPortalController](05_overlayportalcontroller_.md) to show/hide the overlay.

### Peek into the Code

Let's look at the `OverlayPortal` class definition:

```dart
class OverlayPortal extends StatefulWidget {
  const OverlayPortal({
    super.key,
    required this.controller,
    required this.overlayChildBuilder,
    this.child,
  }) : _targetRootOverlay = false;

  // ... (targetsRootOverlay constructor) ...

  final OverlayPortalController controller;
  final WidgetBuilder overlayChildBuilder;
  final Widget? child;
  final bool _targetRootOverlay;

  @override
  State<OverlayPortal> createState() => _OverlayPortalState();
}
```

This confirms it's a `StatefulWidget` (hence the need for a `State` object, `_OverlayPortalState`, which will manage the connection to the [Overlay](01_overlay_.md) and the rendering). It takes the required `controller` and `overlayChildBuilder` and an optional `child`.

The `createState()` method simply returns `_OverlayPortalState()`. This is where the logic connecting to the actual [Overlay](01_overlay_.md) will live.

Looking at the `_OverlayPortalState` (parts shown in the file):

```dart
class _OverlayPortalState extends State<OverlayPortal> {
  int? _zOrderIndex; // Controls visibility and paint order

  // ... (methods like show, hide, didUpdateWidget, dispose) ...

  @override
  Widget build(BuildContext context) {
    final int? zOrderIndex = _zOrderIndex;
    if (zOrderIndex == null) {
      // If not showing, return a simple widget that just renders the child
      return _OverlayPortal(overlayLocation: null, overlayChild: null, child: widget.child);
    }
    // If showing, return a special widget that connects to the Overlay
    return _OverlayPortal(
      overlayLocation: _getLocation(zOrderIndex, widget._targetRootOverlay),
      overlayChild: _DeferredLayout(child: Builder(builder: widget.overlayChildBuilder)),
      child: widget.child,
    );
  }
}
```

Here, in `_OverlayPortalState`'s `build` method:

1.  It checks the `_zOrderIndex`. This private variable is controlled by the [OverlayPortalController](05_overlayportalcontroller_.md) (`show` sets it to a timestamp, `hide` sets it to null). The value of `_zOrderIndex` also determines the paint order on the [Overlay](01_overlay_.md).
2.  If `_zOrderIndex` is null (not showing), it returns a simple internal widget (`_OverlayPortal`) with `overlayChild: null`.
3.  If `_zOrderIndex` is not null (showing), it returns the `_OverlayPortal` widget again, but this time it provides an `overlayLocation` (obtained via `_getLocation`) and wraps the result of the `overlayChildBuilder` in a `_DeferredLayout` widget.

The `_OverlayPortal` widget is an internal `RenderObjectWidget` that manages the actual render object connection. `_DeferredLayout` is a key internal widget we'll touch on briefly; it's related to how the layout of the overlay child widget is handled (it's "deferred" until the [Overlay](01_overlay_.md) is ready to lay it out).

The `_getLocation` method is where the `_OverlayPortalState` finds the necessary information about the ancestor [Overlay](01_overlay_.md) by talking to an `InheritedWidget` (`_RenderTheaterMarker`).

```dart
class _RenderTheaterMarker extends InheritedWidget {
  // ... properties (theater, overlayEntryWidgetState) ...
  static _RenderTheaterMarker of(BuildContext context, {bool targetRootOverlay = false}) {
    // ... looks up the nearest or root _RenderTheaterMarker ...
    // ... returns the marker containing info about the Overlay's render objects ...
  }
}
```

This `_RenderTheaterMarker` is an `InheritedWidget` placed in the widget tree by the [OverlayState](02_overlaystate_.md) (specifically by the `_OverlayEntryWidget` which represents a single entry's content). It holds references to the key rendering objects of the [Overlay](01_overlay_.md) (`_RenderTheater`) and the specific [OverlayEntry](03_overlayentry_.md) the `OverlayPortal` is logically contained within (`_OverlayEntryWidgetState`). This mechanism allows the `_OverlayPortalState` to easily find the correct place in the render tree to insert its overlay child.

All of these internal pieces work together to take the widget from your `overlayChildBuilder` and insert its corresponding render object into the [Overlay]'s render tree (`_RenderTheater`) *at the correct paint order level relative to other [OverlayEntry](03_overlayentry_.md)s*.

### Conclusion

In this chapter, we introduced `OverlayPortal` as a more convenient way to display widgets on an [Overlay](01_overlay_.md). We learned that it allows the overlay widget to conceptually remain linked to the `OverlayPortal`'s location in the widget tree, making context inheritance simpler. We saw the basic structure of `OverlayPortal` with its `overlayChildBuilder` and optional `child`, and got a high-level understanding of how it uses internal widgets and render objects (`_OverlayPortal`, `_DeferredLayout`, `_RenderTheaterMarker`) to insert the overlay child's render object into the ancestor [Overlay](01_overlay_.md)'s `_RenderTheater`.

To actually control *when* the overlay child is shown or hidden, we need the `controller`. In the next chapter, we will explore the [OverlayPortalController](05_overlayportalcontroller_.md) and complete our context menu example.

[OverlayPortalController](05_overlayportalcontroller_.md)
2025-05-22 23:58:01,424 - INFO - PROMPT: 
Write a very beginner-friendly tutorial chapter (in Markdown format) for the project `flutter (overlay.dart)` about the concept: "OverlayPortalController
". This is Chapter 5.

Concept Details:
- Name: OverlayPortalController

- Description:
This is like a remote control for an OverlayPortal. You use it to tell the linked OverlayPortal when to show or hide its special overlay widget. Calling `show()` makes the widget appear on the Overlay, and calling `hide()` makes it disappear. You can also use it to bring the widget to the front if multiple OverlayPortals are showing.


Complete Tutorial Structure:
1. [Overlay
](01_overlay_.md)
2. [OverlayState
](02_overlaystate_.md)
3. [OverlayEntry
](03_overlayentry_.md)
4. [OverlayPortal
](04_overlayportal_.md)
5. [OverlayPortalController
](05_overlayportalcontroller_.md)
6. [_Theater
](06__theater_.md)
7. [_RenderDeferredLayoutBox
](07__renderdeferredlayoutbox_.md)
8. [_OverlayEntryLocation
](08__overlayentrylocation_.md)

Context from previous chapters:
# Chapter 1: Overlay

Welcome to the first chapter of our tutorial on Flutter's `overlay.dart`! In this chapter, we'll introduce you to the fundamental concept of an `Overlay`.

Have you ever seen temporary popups, like dialogs, tooltips that appear over your regular screen content, no matter what's currently displayed? How does Flutter manage to show these elements *on top* of everything else? That's where the `Overlay` comes in!

Think of your Flutter app's user interface as a stack of layers, like transparencies on an overhead projector. Your main screen content is on the bottom layer. When you want to show something *over* that content, without affecting how the main content is arranged, you place it on a new, transparent layer on top. The `Overlay` widget is like the frame of this overhead projector that holds the stack of transparent sheets.

The `Overlay` itself is a widget that sits high up in your app's widget tree, often provided automatically by powerful widgets like `MaterialApp` or `WidgetsApp`. It manages a list of "sheets," called [OverlayEntry](03_overlayentry_.md)s. Each [OverlayEntry](03_overlayentry_.md) can hold a widget, and these widgets will be painted *above* the `Overlay`'s regular content.

So, the core idea is:

**An `Overlay` is a stack of entry points where you can place widgets that should appear on top of your primary UI.**

### Our Goal: Displaying a Simple Overlay

To understand the `Overlay` better, let's imagine we want to display a simple message box that floats in the center of the screen when a button is pressed. This message box should appear above all other content on the screen.

Using the `Overlay` and its related components, we can achieve this. Here's the high-level plan:

1.  Find the nearest `Overlay`.
2.  Create an [OverlayEntry](03_overlayentry_.md) containing our message box widget.
3.  Insert this [OverlayEntry](03_overlayentry_.md) into the `Overlay`'s stack.
4.  When we want to hide the message box, we'll remove the [OverlayEntry](03_overlayentry_.md) from the `Overlay`.

### Finding the Overlay

The `Overlay` is usually introduced by the main app widgets like `MaterialApp`. To interact with this `Overlay`, we need to get its state, which is an [OverlayState](02_overlaystate_.md). We can do this using the `Overlay.of` method, passing the current `BuildContext`.

```dart
// Inside a widget's build method or a function called from it:
OverlayState? overlayState = Overlay.of(context);
```

This code snippet uses `Overlay.of(context)` to look up the closest `OverlayState` in the widget tree above the current `context`. If an `Overlay` is found, it gives us its state (the [OverlayState](02_overlaystate_.md) object) that we can use to manage our overlay entries. If no `Overlay` is found (which is unlikely in a typical `MaterialApp`), it would cause an error in debug mode.

### What's Inside the Overlay?

While we don't see it directly in the minimal code we write, the `Overlay` widget itself contains some interesting pieces to manage its entries.

Let's look at a relevant snippet from the `overlay.dart` file:

```dart
class Overlay extends StatefulWidget {
  // ... other properties and methods

  @override
  OverlayState createState() => OverlayState();
}
```

This shows that the `Overlay` widget creates an [OverlayState](02_overlaystate_.md). This is the object we obtained using `Overlay.of`. The [OverlayState](02_overlaystate_.md) is where the real work of managing the list of [OverlayEntry](03_overlayentry_.md) objects happens.

Further down in the code, we see how the `OverlayState` builds its UI:

```dart
class OverlayState extends State<Overlay> with TickerProviderStateMixin {
  final List<OverlayEntry> _entries = <OverlayEntry>[];

  // ... methods for inserting and removing entries

  @protected
  @override
  Widget build(BuildContext context) {
    // ... logic to determine visible entries
    final List<_OverlayEntryWidget> children = <_OverlayEntryWidget>[];
    // ... populate children based on _entries
    return _Theater(
      // ... properties like skipCount, clipBehavior
      children: children.reversed.toList(growable: false),
    );
  }

  // ... other methods
}
```

This snippet reveals a crucial part: the `OverlayState` holds a list of `_entries` (our [OverlayEntry](03_overlayentry_.md) objects). In its `build` method, it creates a list of `_OverlayEntryWidget`s corresponding to the active entries. These widgets are then passed to a special widget called `_Theater`.

The `_Theater` widget is essentially a specialized `Stack`. It's responsible for laying out and painting the widgets from the [OverlayEntry](03_overlayentry_.md)s on top of each other, similar to how layers are stacked in a `Stack`.

Here's a simplified illustration of the key participants and their relationships in displaying an overlay entry:

```mermaid
sequenceDiagram
    participant YourWidget
    participant OverlayDotOf as Overlay.of(context)
    participant OverlayState
    participant OverlayEntry
    participant _Theater

    YourWidget->>OverlayDotOf: Ask for OverlayState
    OverlayDotOf-->>OverlayState: Return the found OverlayState
    YourWidget->>OverlayState: Create and insert OverlayEntry
    OverlayState->>OverlayEntry: Add entry to internal list
    OverlayState->>OverlayState: Schedule rebuild
    OverlayState->>_Theater: Build _Theater with entries as children
    _Theater->>OverlayEntry: Ask entry to build its widget
    OverlayEntry->>_Theater: Return built widget
    _Theater->>_Theater: Layout and paint entry's widget on top

```

This diagram shows that your widget interacts with the global `Overlay.of` to get the [OverlayState](02_overlaystate_.md). You then use the [OverlayState](02_overlaystate_.md) to manage your [OverlayEntry](03_overlayentry_.md). The [OverlayState](02_overlaystate_.md) internally uses `_Theater` to visually stack the widgets provided by the [OverlayEntry](03_overlayentry_.md)s.

### Conclusion

In this chapter, we introduced the concept of the `Overlay` in Flutter. We learned that it acts as a container for widgets that should appear on top of the regular UI, managing them as a stack of [OverlayEntry](03_overlayentry_.md) objects. We saw how to find the `OverlayState` using `Overlay.of` and got a peek into the internal structure involving `_Theater`.

In the next chapter, we will delve deeper into the [OverlayState](02_overlaystate_.md) and explore how to use its methods to actually insert and remove [OverlayEntry](03_overlayentry_.md) objects, allowing us to finally display our floating message box.

[OverlayState](02_overlaystate_.md)
---
# Chapter 2: OverlayState

Welcome back! In our [previous chapter](01_overlay_.md), we learned that an `Overlay` acts like a transparent layer on top of our regular UI, managed by powerful widgets like `MaterialApp`. We also saw that this `Overlay` holds a stack of "sheets" called [OverlayEntry](03_overlayentry_.md)s. But who is in charge of managing these sheets? That's where the `OverlayState` comes in.

Think of the `Overlay` as the physical structure (the overhead projector frame) and the `OverlayState` as the person operating that projector. The `OverlayState` is the **manager** for the `Overlay`. Its main job is to keep track of which [OverlayEntry](03_overlayentry_.md) sheets are currently in the stack and decide which ones are visible.

Our goal from the last chapter was to display a simple message box that floats in the center of the screen when a button is pressed. To do this, we need to:

1.  Find the `OverlayState` associated with our `Overlay`.
2.  Create an [OverlayEntry](03_overlayentry_.md) containing our message box widget.
3.  Tell the `OverlayState` to **insert** this [OverlayEntry](03_overlayentry_.md) into its stack.
4.  When we want to hide the message box, tell the `OverlayState` to **remove** the [OverlayEntry](03_overlayentry_.md).

In this chapter, we'll focus on how to use the `OverlayState` to perform these insertions and removals.

### Getting the OverlayState

As we briefly saw in the last chapter, we can get the `OverlayState` using the static method `Overlay.of`. This method looks up the widget tree from the given `BuildContext` and finds the nearest `Overlay` widget's state.

```dart
// Inside a widget where you want to show an overlay:
void showMyMessageBox(BuildContext context) {
  OverlayState? overlayState = Overlay.of(context);
  // Now we have the manager (the OverlayState)!
}
```

Here, `Overlay.of(context)` does the important work of finding the correct `OverlayState` for us. The `context` tells Flutter where in the widget tree we are looking from. In a typical app, this `OverlayState` will be the one managed by your `MaterialApp` or `WidgetsApp`.

### Adding an OverlayEntry

Once we have the `OverlayState`, we can add new entries to it. The `OverlayState` has an `insert` method for this purpose. The `insert` method takes an [OverlayEntry](03_overlayentry_.md) object as its argument.

Let's imagine we have created our `OverlayEntry` object (we'll learn more about [OverlayEntry](03_overlayentry_.md) in the next chapter, for now just assume it exists).

```dart
// Continuing from the previous snippet:
void showMyMessageBox(BuildContext context) {
  OverlayState? overlayState = Overlay.of(context);

  if (overlayState != null) {
    // Assume 'myOverlayEntry' is an instance of OverlayEntry
    // that holds our message box widget.
    OverlayEntry myOverlayEntry = createMessageBoxEntry(); // Placeholder function

    overlayState.insert(myOverlayEntry);
    print('Message box inserted!');
  } else {
    print('Could not find OverlayState!');
  }
}

// Placeholder for creating the OverlayEntry
OverlayEntry createMessageBoxEntry() {
  // This would contain the actual widget for the message box
  return OverlayEntry(
    builder: (context) => Center(
      child: Container(
        width: 200,
        height: 100,
        color: Colors.blue,
        child: Center(child: Text('Hello Overlay!')),
      ),
    ),
  );
}
```

In this code:
1.  We get the `overlayState`.
2.  We check if it's not null (meaning an `Overlay` was found).
3.  We create an `OverlayEntry` (using `createMessageBoxEntry`).
4.  We call `overlayState.insert(myOverlayEntry)`. This is the key step! It tells the `OverlayState` to add our entry to its internal list.

When an `OverlayEntry` is inserted, the `OverlayState` marks itself as needing to rebuild. During the next build cycle, the `OverlayState` will include the widget from your newly inserted [OverlayEntry](03_overlayentry_.md) in its list of visible children, making it appear on top of your UI.

### Ordering OverlayEntries

The `insert` method also allows you to control where the entry is inserted in the stack:

*   `overlayState.insert(entry)`: Inserts the entry at the very top (painted last).
*   `overlayState.insert(entry, below: someOtherEntry)`: Inserts the entry just below `someOtherEntry`.
*   `overlayState.insert(entry, above: someOtherEntry)`: Inserts the entry just above `someOtherEntry`.

This is like deciding whether to place your new transparency sheet on the very top of the stack, or insert it right above or below another specific sheet. This is useful for complex overlays or when integrating with system overlays like dialogs or routes managed by the Navigator.

### Removing an OverlayEntry

Adding entries is only half the story. We also need to be able to remove them. For example, when the user closes our message box, we want to take it off the overlay.

To remove an [OverlayEntry](03_overlayentry_.md), you call the `remove()` method directly on the **[OverlayEntry](03_overlayentry_.md) object itself**, not on the `OverlayState`.

```dart
// Continuing the example, we need to keep track of the inserted entry:
OverlayEntry? currentMessageBoxEntry; // Store the active entry

void showMyMessageBox(BuildContext context) {
  // ... find overlayState ...
  if (overlayState != null) {
    // Create and store the entry before inserting
    currentMessageBoxEntry = createMessageBoxEntry();
    overlayState.insert(currentMessageBoxEntry!); // Insert it
    print('Message box inserted!');

    // Example: Automatically remove after 3 seconds (for demonstration)
    Future.delayed(Duration(seconds: 3), () {
      removeMyMessageBox();
    });

  } else {
    print('Could not find OverlayState!');
  }
}

// Function to remove the message box
void removeMyMessageBox() {
  if (currentMessageBoxEntry != null) {
    currentMessageBoxEntry!.remove(); // Call remove on the entry!
    currentMessageBoxEntry = null; // Clear the stored entry
    print('Message box removed!');
  }
}

// (createMessageBoxEntry function remains the same)
// (Remember to import 'package:flutter/material.dart' for Colors/Container/Text)
```

In this updated code:
1.  We declare `currentMessageBoxEntry` to hold a reference to the [OverlayEntry](03_overlayentry_.md) once it's created and inserted.
2.  When showing the box, we assign the new entry to this variable.
3.  When removing the box (`removeMyMessageBox`), we check if `currentMessageBoxEntry` is not null and call its `remove()` method.
4.  After removing, we set `currentMessageBoxEntry` back to null.

Calling `entry.remove()` tells the `OverlayState` to take that specific [OverlayEntry](03_overlayentry_.md) out of its list. Similar to insertion, the `OverlayState` will then mark itself dirty and rebuild, this time *without* including the widget from the removed entry.

### How OverlayState Manages Entries Internally

Let's look peek under the hood again. We saw in the snippet from the last chapter that `OverlayState` holds a `List<OverlayEntry> _entries`. This is the core list it manages.

When you call `insert`:

```dart
// From overlay.dart -> OverlayState -> insert method (simplified)
void insert(OverlayEntry entry, {OverlayEntry? below, OverlayEntry? above}) {
  // ... asserts ...
  entry._overlay = this; // Internal link back to this OverlayState
  setState(() { // Marks state as dirty, schedules a rebuild
    _entries.insert(_insertionIndex(below, above), entry); // Adds to the list
  });
}
```

*   `entry._overlay = this;`: The [OverlayEntry](03_overlayentry_.md) keeps a reference to the `OverlayState` it belongs to. This is how `entry.remove()` knows *which* `OverlayState` to tell to remove it.
*   `setState(() { ... });`: This is standard Flutter State management. It signals to the framework that the state of the `OverlayState` has changed (`_entries` list is different) and it needs to be rebuilt.
*   `_entries.insert(...)`: This is the actual list manipulation. It adds the `entry` at the calculated position in the internal `_entries` list.

When the `OverlayState` rebuilds, its `build` method creates the UI using the current contents of `_entries`. We saw that it uses a widget called `_Theater` for this:

```dart
// From overlay.dart -> OverlayState -> build method (simplified)
@override
Widget build(BuildContext context) {
  // ... logic to determine visible entries ...
  final List<_OverlayEntryWidget> children = <_OverlayEntryWidget>[];
  // Loop through _entries (and inactive maintainedState entries)
  // and create _OverlayEntryWidget for each.
  return _Theater(
    // ...
    children: children.reversed.toList(growable: false), // Passes the list to _Theater
  );
}
```

The `_Theater` is essentially a specialized container that takes a list of child widgets (built from the [OverlayEntry](03_overlayentry_.md)s) and stacks them on top of each other. The children are given to `_Theater` in reversed order because the `_entries` list is ordered from bottom to top, but a `Stack` (which `_Theater` behaves like) paints children from bottom to top based on their position in the list. So, the last entry in `_entries` (the top-most one) needs to be the last child given to `_Theater`.

Here's a sequence diagram illustrating insertion:

```mermaid
sequenceDiagram
    participant YourWidget
    participant OverlayState
    participant OverlayEntry
    participant Framework as Flutter Framework
    participant _Theater

    YourWidget->>OverlayState: call insert(OverlayEntry)
    OverlayState->>OverlayEntry: set internal _overlay reference
    OverlayState->>OverlayState: add OverlayEntry to _entries list
    OverlayState->>Framework: call setState()
    Framework->>OverlayState: scheduled rebuild
    OverlayState->>OverlayState: call build()
    OverlayState->>OverlayEntry: call builder() to get widget
    OverlayEntry->>OverlayState: return widget
    OverlayState->>_Theater: pass widget as child
    _Theater->>_Theater: layout and paint widget on top
```

When you call `entry.remove()`:

```dart
// From overlay.dart -> OverlayEntry -> remove method (simplified)
void remove() {
  assert(_overlay != null);
  final OverlayState overlay = _overlay!; // Get the associated OverlayState
  _overlay = null; // Clear the internal reference

  // ... schedule markDirty or call directly ...
  overlay._entries.remove(this); // Remove from the OverlayState's list
  overlay._markDirty(); // Tell the OverlayState to rebuild
  // ...
}
```

*   `_overlay!`: Accesses the `OverlayState` that this entry is currently in.
*   `_entries.remove(this);`: The `OverlayEntry` tells its manager (`_overlay`) to remove itself from the list.
*   `overlay._markDirty();`: Calls an internal method on the `OverlayState` to signal that it needs to rebuild.

The diagram for removal is similar to insertion, just in reverse:

```mermaid
sequenceDiagram
    participant YourWidget
    participant OverlayEntry
    participant OverlayState
    participant Framework as Flutter Framework
    participant _Theater

    YourWidget->>OverlayEntry: call remove()
    OverlayEntry->>OverlayState: access internal _overlay reference
    OverlayEntry->>OverlayEntry: clear internal _overlay reference
    OverlayEntry->>OverlayState: remove OverlayEntry from _entries list
    OverlayState->>OverlayState: call _markDirty()
    OverlayState->>Framework: setState() called implicitly
    Framework->>OverlayState: scheduled rebuild
    OverlayState->>OverlayState: call build()
    OverlayState->>_Theater: pass children (without the removed entry)
    _Theater->>_Theater: relayout and repaint (entry disappears)
```

This demonstrates how the `OverlayState` acts as the central hub, maintaining the list and triggering UI updates when the list of [OverlayEntry](03_overlayentry_.md) objects changes.

### Conclusion

In this chapter, we explored the crucial role of the `OverlayState`. We learned that it is the manager for an [Overlay](01_overlay_.md), holding the list of [OverlayEntry](03_overlayentry_.md) objects and controlling their visibility. We saw how to obtain the `OverlayState` using `Overlay.of` and, most importantly, how to use its `insert` method to add [OverlayEntry](03_overlayentry_.md)s to the overlay stack and how to call `remove` directly on an [OverlayEntry](03_overlayentry_.md) to take it out.

We also took a look at the internal workings, seeing how `OverlayState`'s `_entries` list is manipulated and how `setState` triggers a rebuild to update the UI using the [_Theater](06__theater_.md) widget.

Now that we understand the container ([Overlay](01_overlay_.md)) and its manager (`OverlayState`), it's time to delve into the "sheets" themselves: the [OverlayEntry](03_overlayentry_.md). In the next chapter, we'll learn how to create our own [OverlayEntry](03_overlayentry_.md) objects with the specific widgets we want to display on the overlay.

[OverlayEntry](03_overlayentry_.md)
---
# Chapter 3: OverlayEntry

Welcome back to our `overlay.dart` tutorial! In the [previous chapters](01_overlay_.md), we learned about the [Overlay](01_overlay_.md) as a container that sits on top of our UI and the [OverlayState](02_overlaystate_.md) as its manager, responsible for inserting and removing items from the overlay stack.

But what exactly are these "items" or "sheets" that get placed onto the [Overlay](01_overlay_.md)? That's where the `OverlayEntry` comes in!

Think of an `OverlayEntry` as a single, transparent sheet that you prepare to put onto the [Overlay](01_overlay_.md)'s overhead projector. This sheet has one purpose: to hold and display **a single widget** on the overlay.

Our goal is to display a simple message box that floats in the center of the screen when a button is pressed. To do this using the [Overlay](01_overlay_.md) and [OverlayState](02_overlaystate_.md), we need to wrap our message box widget inside an `OverlayEntry`.

So, an `OverlayEntry` is the object that carries the self-contained piece of UI you want to show on top of your regular content. It's the payload that the [OverlayState](02_overlaystate_.md) manages.

### Creating an OverlayEntry

Creating an `OverlayEntry` is straightforward. You just need to provide a `builder` function. This `builder` function is a standard Flutter `WidgetBuilder` that takes a `BuildContext` and should return the widget you want to display on the overlay.

Here's how we would create an `OverlayEntry` for our simple message box:

```dart
// This function creates an OverlayEntry for our message box.
OverlayEntry createMessageBoxEntry() {
  OverlayEntry entry = OverlayEntry(
    builder: (BuildContext context) {
      // The widget that will be shown on the overlay
      return Center( // Center it on the overlay
        child: Container(
          width: 200,
          height: 100,
          color: Colors.blue,
          child: const Center(child: Text('Hello OverlayEntry!')),
        ),
      );
    },
  );
  return entry;
}
```

In this snippet:

*   `OverlayEntry(...)`: We call the `OverlayEntry` constructor.
*   `builder: (BuildContext context) { ... }`: We provide the required `builder` function. Flutter will call this function when it needs to display our entry on the overlay.
*   Inside the `builder`, we return a `Center` widget containing our blue message `Container`. This widget is what the `OverlayEntry` will represent visually on the overlay.

Now, when we get the [OverlayState](02_overlaystate_.md) (as shown in the [previous chapter](02_overlaystate_.md)) and call `overlayState.insert(entry)`, our beautiful blue box will appear centered on the screen!

### OverlayEntry Properties: Opaque and MaintainState

Besides the `builder`, `OverlayEntry` has a couple of important properties: `opaque` and `maintainState`. These properties control how the `Overlay` handles layers below this specific entry.

*   **`opaque` (default: `false`)**: If set to `true`, this property signals to the [Overlay](01_overlay_.md) that this entry completely covers whatever is beneath it in the overlay stack. This is mainly an optimization hint. If an entry is `opaque`, the [Overlay](01_overlay_.md) can skip building or painting the parts of the entries below it that are covered. Think of putting a solid, colored sheet on the overhead projector  you can't see through it to the sheets below. Our message box isn't truly opaque unless it fills the whole screen, but for performance, you might mark a dialog or a full-screen route as opaque.

*   **`maintainState` (default: `false`)**: If set to `true`, this property tells the [Overlay](01_overlay_.md) to keep the widget hierarchy for this entry active, even if it's visually hidden by an `opaque` entry on top. This is like keeping the light on for a sheet even if a solid sheet is on top. This is useful for things like keeping the state of a background route alive in a Navigator, even when another route is covering it entirely. Setting this to `true` can use more resources, so use it only when necessary.

For our simple message box, neither of these needs to be `true`. It doesn't cover everything below it entirely (it's just a small box), and we don't need to maintain its state when it's not visible (we'll remove it when hidden). So, the default values work fine.

```dart
OverlayEntry createMessageBoxEntry() {
  return OverlayEntry(
    builder: (BuildContext context) {
      // Our message box widget
      return Center(
        child: Container(
          width: 200,
          height: 100,
          color: Colors.blue,
          child: const Center(child: Text('Hello OverlayEntry!')),
        ),
      );
    },
    // opaque: false, // Default and appropriate for a small box
    // maintainState: false, // Default and appropriate as we remove it
  );
}
```

### Removing an OverlayEntry

As we saw in the [previous chapter](02_overlaystate_.md), to remove an `OverlayEntry`, you call the `remove()` method directly on the `OverlayEntry` object itself.

```dart
// Assuming you have a variable to hold the entry:
OverlayEntry? myActiveMessageBoxEntry;

void hideMyMessageBox() {
  if (myActiveMessageBoxEntry != null) {
    myActiveMessageBoxEntry!.remove(); // Tell the entry to remove itself
    myActiveMessageBoxEntry = null; // Clear our reference
  }
}
```

When `entry.remove()` is called:
1. The `OverlayEntry` looks up the [OverlayState](02_overlaystate_.md) it was inserted into (it holds an internal reference).
2. It tells that [OverlayState](02_overlaystate_.md) to remove it from its list of entries.
3. The [OverlayState](02_overlaystate_.md) rebuilds, and since the entry is no longer in its list, the widget built by this entry's `builder` is no longer included in the UI, making it disappear.

### How OverlayEntry Works Internally

Let's revisit the code snippet from `overlay.dart` for `OverlayEntry`:

```dart
class OverlayEntry implements Listenable {
  // ... constructor and properties ...

  OverlayState? _overlay; // Internal reference to the managing OverlayState
  final GlobalKey<_OverlayEntryWidgetState> _key = GlobalKey<_OverlayEntryWidgetState>();

  /// Remove this entry from the overlay.
  void remove() {
    assert(_overlay != null);
    final OverlayState overlay = _overlay!; // Get the associated OverlayState
    _overlay = null; // Clear the internal reference

    // ... scheduling logic ...
    overlay._entries.remove(this); // Request removal from the OverlayState's list
    overlay._markDirty(); // Tell the OverlayState to rebuild
    // ...
  }

  /// Cause this entry to rebuild during the next pipeline flush.
  ///
  /// You need to call this function if the output of [builder] has changed.
  void markNeedsBuild() {
    assert(!_disposedByOwner);
    _key.currentState?._markNeedsBuild();
  }

  // ... dispose method and other internal details ...
}
```

Key takeaways from this snippet:

*   `OverlayState? _overlay;`: This private variable is how an `OverlayEntry` knows which [OverlayState](02_overlaystate_.md) it belongs to. This reference is set when you call `overlayState.insert(entry)`.
*   `final GlobalKey<_OverlayEntryWidgetState> _key`: Each `OverlayEntry` uses a `GlobalKey` to identify the actual widget (`_OverlayEntryWidget`) that the [OverlayState](02_overlaystate_.md) creates to represent this entry in the widget tree.
*   `remove()`: When you call `remove()`, it uses the `_overlay` reference to find the correct [OverlayState](02_overlaystate_.md) and tells it to remove `this` entry from its internal `_entries` list (`overlay._entries.remove(this)`). It then sets `_overlay` to `null` and calls `overlay._markDirty()` to trigger a rebuild of the [OverlayState](02_overlaystate_.md).
*   `markNeedsBuild()`: If the widget you return from your `builder` function changes (e.g., based on some state within the `OverlayEntry`), you can call `markNeedsBuild()` on the `OverlayEntry` to tell the system that its visual representation needs to be updated. This calls `setState` on the internal `_OverlayEntryWidgetState` associated with this entry's `_key`.

Here's a sequence diagram focusing on the OverlayEntry's role in removal:

```mermaid
sequenceDiagram
    participant YourWidget
    participant OverlayEntry
    participant OverlayState
    participant Framework as Flutter Framework

    YourWidget->>OverlayEntry: call remove()
    OverlayEntry->>OverlayEntry: access internal _overlay reference
    OverlayEntry->>OverlayEntry: clear internal _overlay reference
    OverlayEntry->>OverlayState: remove OverlayEntry from _entries list
    OverlayState->>OverlayState: call _markDirty() (triggers setState)
    OverlayState->>Framework: schedule build
    Framework->>OverlayState: call build()
    OverlayState->>OverlayEntry: Build logic skips removed entry
    OverlayEntry->>Framework: Widget no longer added to tree
    Framework->>Framework: UI updated (entry disappears)
```

This confirms that the `OverlayEntry` is primarily a data holder for the widget and properties, and it delegates the actual UI management (insertion and removal from the visual tree) back to the [OverlayState](02_overlaystate_.md) it belongs to.

### Conclusion

In this chapter, we focused on the `OverlayEntry`, the core object that holds the widget you want to display on an [Overlay](01_overlay_.md). We learned how to create a basic `OverlayEntry` using a `builder` function, how to use its `opaque` and `maintainState` properties, and how calling `remove()` on the entry itself signals to the managing [OverlayState](02_overlaystate_.md) to take it off the screen.

We also briefly looked at the internal structure, understanding that `OverlayEntry` keeps a reference to its [OverlayState](02_overlaystate_.md) and manages a `GlobalKey` to its corresponding widget in the overlay tree.

With the concepts of [Overlay](01_overlay_.md), [OverlayState](02_overlaystate_.md), and `OverlayEntry` under our belt, we now have the foundational knowledge to display custom widgets on top of our application content at a global level!

In the next chapter, we will introduce [OverlayPortal](04_overlayportal_.md), a more modern and often simpler alternative to directly managing `OverlayEntry` objects, especially when you want an overlay widget to stay closely connected to the state and context of its originating widget.

[OverlayPortal](04_overlayportal_.md)
---
# Chapter 4: OverlayPortal

Welcome back! In our [previous chapters](01_overlay_.md), we built a solid understanding of the [Overlay](01_overlay_.md), the [OverlayState](02_overlaystate_.md) (its manager), and the [OverlayEntry](03_overlayentry_.md) (the sheet holding the widget). We learned how to manually create an [OverlayEntry](03_overlayentry_.md), get the [OverlayState](02_overlaystate_.md), and insert/remove the entry to make a widget appear or disappear on top of everything.

While this manual approach works, sometimes it can feel a bit disconnected. You have your original widget (say, a button that triggers the overlay), and the overlay widget itself is managed separately by the [OverlayState](02_overlaystate_.md), potentially far away in the widget tree. This can make things like keeping the overlay visually positioned relative to the original widget or having the overlay widget inherit themes/context from the original widget's location a bit tricky.

This is where `OverlayPortal` comes in!

Think of `OverlayPortal` as a special window from your widget's location directly to the [Overlay](01_overlay_.md). You place the `OverlayPortal` widget in your widget tree like any other widget. When you want to show something on the [Overlay](01_overlay_.md), you tell the `OverlayPortal`, and it uses a builder function you provide to create the widget.

**The key idea is that the widget you want to show on the [Overlay](01_overlay_.md) feels like it's still attached to your `OverlayPortal`'s spot in the widget tree, even though it's visually displayed on the [Overlay](01_overlay_.md).**

### Our Goal: A Context Menu

Let's refine our goal. Instead of just a simple message box, imagine we want a small context menu to appear right next to a button when you tap it. This menu should float on the [Overlay](01_overlay_.md), but its position should be related to the button, and it should inherit styling (like text themes) from where the button is located.

Using `OverlayPortal`, this becomes much more natural than manual [OverlayEntry](03_overlayentry_.md) management.

### Creating an OverlayPortal

An `OverlayPortal` is a `StatefulWidget` you add to your widget tree. It requires a `controller` (an [OverlayPortalController](05_overlayportalcontroller_.md), which we'll cover in the next chapter) and an `overlayChildBuilder`.

```dart
// Inside your widget's build method:
OverlayPortal(
  controller: _myOverlayController, // We'll make this in the next chapter
  overlayChildBuilder: (BuildContext context) {
    // This is the widget that will show on the Overlay
    return Positioned( // We'll position it later
      top: 100, // Just a placeholder for now
      left: 100, // Just a placeholder for now
      child: Material( // Use Material for styling/elevation
        elevation: 4.0,
        child: Container(
          padding: const EdgeInsets.all(8.0),
          color: Colors.yellow[100],
          child: Text('Context Menu!'),
        ),
      ),
    );
  },
  child: ElevatedButton( // This is the original widget (the button)
    onPressed: () {
      // We will show the overlay here using the controller
    },
    child: const Text('Show Menu'),
  ),
)
```

In this example:

1.  We place the `OverlayPortal` widget in our tree.
2.  We give it an `overlayChildBuilder`. This is very similar to the `builder` for an [OverlayEntry](03_overlayentry_.md)  it's the function that creates the widget for the overlay.
3.  We add a `child` property. This is the regular child widget of the `OverlayPortal` (our `ElevatedButton`).

The widget returned by `overlayChildBuilder` (`Positioned` in this case) will be displayed on the [Overlay](01_overlay_.md), but its `BuildContext` will be a special one that's linked back to the `OverlayPortal`'s location. This is why it can easily inherit themes, etc., from its original position.

Notice that we are using a `Positioned` widget directly in the `overlayChildBuilder`. This is common because `OverlayPortal`'s overlay child is placed within the [Overlay](01_overlay_.md) which behaves like a `Stack`. `Positioned` widgets are used to control the placement of children within a `Stack`.

### How OverlayPortal Works Internally (High Level)

When Flutter lays out the widget tree, it encounters the `OverlayPortal`. Importantly, when its `overlayChildBuilder` *is active* (meaning you've told the controller to show the overlay):

1.  The `OverlayPortal`'s `Element` (specifically an `_OverlayPortalElement`) calls its `overlayChildBuilder` to get the overlay widget.
2.  Instead of painting this widget directly where the `OverlayPortal` is located in the tree, the `_OverlayPortalElement` finds the nearest ancestor [Overlay](01_overlay_.md) (using an internal mechanism involving an `InheritedWidget`, which we'll see later).
3.  It then inserts the *render object* corresponding to the overlay widget into the `_RenderTheater` (the specialized `Stack` that the [Overlay](01_overlay_.md) uses to manage its visual children).
4.  The render object is placed correctly relative to other things on the [Overlay](01_overlay_.md) based on the order defined by the `OverlayPortalController`.
5.  The original `OverlayPortal` widget then continues its standard layout and painting for its `child` widget (the button), as if the overlay widget wasn't there.

This gives the illusion that the overlay widget is coming from the `OverlayPortal`'s location, even though its physical rendering happens on the [Overlay](01_overlay_.md).

Sequence diagram illustrating the key interaction:

```mermaid
sequenceDiagram
    participant YourWidget
    participant OverlayPortal
    participant _OverlayPortalState
    participant _OverlayPortalElement
    participant _TheaterMarker as InheritedWidget
    participant OverlayState
    participant _RenderTheater

    YourWidget->>OverlayPortal: build time (includes OverlayPortal)
    OverlayPortal->>_OverlayPortalState: create state
    _OverlayPortalState->>_OverlayPortalElement: mount element
    _OverlayPortalElement->>_TheaterMarker: look up ancestor Overlay info
    _TheaterMarker-->>_OverlayPortalElement: provide _RenderTheater etc.
    YourWidget->>YourWidget: trigger show via controller (next chapter)
    YourWidget->>_OverlayPortalState: call controller.show()
    _OverlayPortalState->>_OverlayPortalState: update internal state (_zOrderIndex)
    _OverlayPortalState->>YourWidget: setState() triggers rebuild
    YourWidget->>OverlayPortal: rebuild with show=true
    OverlayPortal->>_OverlayPortalElement: update element
    _OverlayPortalElement->>_OverlayPortalElement: call overlayChildBuilder
    _OverlayPortalElement->>_RenderTheater: attach overlay child render object
    _RenderTheater->>_RenderTheater: paint child on overlay
```

This shows how the `OverlayPortal` lives in your regular widget tree but has the ability to "reach out" to the ancestor [Overlay](01_overlay_.md)'s render object tree (`_RenderTheater`) to place its overlay child's render objects there.

### Advantages of OverlayPortal over Manual OverlayEntry

*   **Simplified Management:** You don't manually create, store, insert, or remove [OverlayEntry](03_overlayentry_.md) objects. The `OverlayPortal` widget handles this for you based on the state of its controller.
*   **Context and Inherited Widgets:** The `BuildContext` provided to `overlayChildBuilder` is closely tied to the `OverlayPortal`'s original location. This means your overlay widget automatically inherits themes, `MediaQuery`, `Localizations`, etc., making styling and layout much easier.
*   **State Management:** The lifecycle of the overlay widget is tied to the `OverlayPortal`. If the `OverlayPortal` is disposed, the overlay widget goes away too. This simplifies managing the state of complex overlay children.
*   **Relative Positioning:** While basic `Positioned` works, `OverlayPortal` makes it easier to use widgets like `CompositedTransformTarget` and `CompositedTransformFollower` to position the overlay child precisely relative to the `OverlayPortal`'s location. We used a simple `Positioned` as a placeholder for now, but later chapters might explore this.

### Limitations

*   **Must have an ancestor `Overlay`:** Just like manual [OverlayEntry](03_overlayentry_.md), the `OverlayPortal` needs an [Overlay](01_overlay_.md) widget higher up in the tree to paint on. (Usually provided by `MaterialApp`, `WidgetsApp`, or `Navigator`.)
*   **Requires a controller:** You need to manage an [OverlayPortalController](05_overlayportalcontroller_.md) to show/hide the overlay.

### Peek into the Code

Let's look at the `OverlayPortal` class definition:

```dart
class OverlayPortal extends StatefulWidget {
  const OverlayPortal({
    super.key,
    required this.controller,
    required this.overlayChildBuilder,
    this.child,
  }) : _targetRootOverlay = false;

  // ... (targetsRootOverlay constructor) ...

  final OverlayPortalController controller;
  final WidgetBuilder overlayChildBuilder;
  final Widget? child;
  final bool _targetRootOverlay;

  @override
  State<OverlayPortal> createState() => _OverlayPortalState();
}
```

This confirms it's a `StatefulWidget` (hence the need for a `State` object, `_OverlayPortalState`, which will manage the connection to the [Overlay](01_overlay_.md) and the rendering). It takes the required `controller` and `overlayChildBuilder` and an optional `child`.

The `createState()` method simply returns `_OverlayPortalState()`. This is where the logic connecting to the actual [Overlay](01_overlay_.md) will live.

Looking at the `_OverlayPortalState` (parts shown in the file):

```dart
class _OverlayPortalState extends State<OverlayPortal> {
  int? _zOrderIndex; // Controls visibility and paint order

  // ... (methods like show, hide, didUpdateWidget, dispose) ...

  @override
  Widget build(BuildContext context) {
    final int? zOrderIndex = _zOrderIndex;
    if (zOrderIndex == null) {
      // If not showing, return a simple widget that just renders the child
      return _OverlayPortal(overlayLocation: null, overlayChild: null, child: widget.child);
    }
    // If showing, return a special widget that connects to the Overlay
    return _OverlayPortal(
      overlayLocation: _getLocation(zOrderIndex, widget._targetRootOverlay),
      overlayChild: _DeferredLayout(child: Builder(builder: widget.overlayChildBuilder)),
      child: widget.child,
    );
  }
}
```

Here, in `_OverlayPortalState`'s `build` method:

1.  It checks the `_zOrderIndex`. This private variable is controlled by the [OverlayPortalController](05_overlayportalcontroller_.md) (`show` sets it to a timestamp, `hide` sets it to null). The value of `_zOrderIndex` also determines the paint order on the [Overlay](01_overlay_.md).
2.  If `_zOrderIndex` is null (not showing), it returns a simple internal widget (`_OverlayPortal`) with `overlayChild: null`.
3.  If `_zOrderIndex` is not null (showing), it returns the `_OverlayPortal` widget again, but this time it provides an `overlayLocation` (obtained via `_getLocation`) and wraps the result of the `overlayChildBuilder` in a `_DeferredLayout` widget.

The `_OverlayPortal` widget is an internal `RenderObjectWidget` that manages the actual render object connection. `_DeferredLayout` is a key internal widget we'll touch on briefly; it's related to how the layout of the overlay child widget is handled (it's "deferred" until the [Overlay](01_overlay_.md) is ready to lay it out).

The `_getLocation` method is where the `_OverlayPortalState` finds the necessary information about the ancestor [Overlay](01_overlay_.md) by talking to an `InheritedWidget` (`_RenderTheaterMarker`).

```dart
class _RenderTheaterMarker extends InheritedWidget {
  // ... properties (theater, overlayEntryWidgetState) ...
  static _RenderTheaterMarker of(BuildContext context, {bool targetRootOverlay = false}) {
    // ... looks up the nearest or root _RenderTheaterMarker ...
    // ... returns the marker containing info about the Overlay's render objects ...
  }
}
```

This `_RenderTheaterMarker` is an `InheritedWidget` placed in the widget tree by the [OverlayState](02_overlaystate_.md) (specifically by the `_OverlayEntryWidget` which represents a single entry's content). It holds references to the key rendering objects of the [Overlay](01_overlay_.md) (`_RenderTheater`) and the specific [OverlayEntry](03_overlayentry_.md) the `OverlayPortal` is logically contained within (`_OverlayEntryWidgetState`). This mechanism allows the `_OverlayPortalState` to easily find the correct place in the render tree to insert its overlay child.

All of these internal pieces work together to take the widget from your `overlayChildBuilder` and insert its corresponding render object into the [Overlay]'s render tree (`_RenderTheater`) *at the correct paint order level relative to other [OverlayEntry](03_overlayentry_.md)s*.

### Conclusion

In this chapter, we introduced `OverlayPortal` as a more convenient way to display widgets on an [Overlay](01_overlay_.md). We learned that it allows the overlay widget to conceptually remain linked to the `OverlayPortal`'s location in the widget tree, making context inheritance simpler. We saw the basic structure of `OverlayPortal` with its `overlayChildBuilder` and optional `child`, and got a high-level understanding of how it uses internal widgets and render objects (`_OverlayPortal`, `_DeferredLayout`, `_RenderTheaterMarker`) to insert the overlay child's render object into the ancestor [Overlay](01_overlay_.md)'s `_RenderTheater`.

To actually control *when* the overlay child is shown or hidden, we need the `controller`. In the next chapter, we will explore the [OverlayPortalController](05_overlayportalcontroller_.md) and complete our context menu example.

[OverlayPortalController](05_overlayportalcontroller_.md)

Relevant Code Snippets (Code itself remains unchanged):
--- File: packages/flutter/lib/src/widgets/overlay.dart ---
// Copyright 2014 The Flutter Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

/// @docImport 'package:flutter/cupertino.dart';
/// @docImport 'package:flutter/material.dart';
///
/// @docImport 'app.dart';
/// @docImport 'drag_target.dart';
/// @docImport 'implicit_animations.dart';
/// @docImport 'media_query.dart';
/// @docImport 'navigator.dart';
/// @docImport 'routes.dart';
/// @docImport 'scroll_view.dart';
/// @docImport 'sliver.dart';
/// @docImport 'text.dart';
library;

import 'dart:collection';

import 'package:flutter/foundation.dart';
import 'package:flutter/rendering.dart';
import 'package:flutter/scheduler.dart';

import 'basic.dart';
import 'framework.dart';
import 'lookup_boundary.dart';
import 'ticker_provider.dart';

const String _flutterWidgetsLibrary = 'package:flutter/widgets.dart';

// Examples can assume:
// late BuildContext context;

// * OverlayEntry Implementation

/// A place in an [Overlay] that can contain a widget.
///
/// Overlay entries are inserted into an [Overlay] using the
/// [OverlayState.insert] or [OverlayState.insertAll] functions. To find the
/// closest enclosing overlay for a given [BuildContext], use the [Overlay.of]
/// function.
///
/// An overlay entry can be in at most one overlay at a time. To remove an entry
/// from its overlay, call the [remove] function on the overlay entry.
///
/// Because an [Overlay] uses a [Stack] layout, overlay entries can use
/// [Positioned] and [AnimatedPositioned] to position themselves within the
/// overlay.
///
/// For example, [Draggable] uses an [OverlayEntry] to show the drag avatar that
/// follows the user's finger across the screen after the drag begins. Using the
/// overlay to display the drag avatar lets the avatar float over the other
/// widgets in the app. As the user's finger moves, draggable calls
/// [markNeedsBuild] on the overlay entry to cause it to rebuild. In its build,
/// the entry includes a [Positioned] with its top and left property set to
/// position the drag avatar near the user's finger. When the drag is over,
/// [Draggable] removes the entry from the overlay to remove the drag avatar
/// from view.
///
/// By default, if there is an entirely [opaque] entry over this one, then this
/// one will not be included in the widget tree (in particular, stateful widgets
/// within the overlay entry will not be instantiated). To ensure that your
/// overlay entry is still built even if it is not visible, set [maintainState]
/// to true. This is more expensive, so should be done with care. In particular,
/// if widgets in an overlay entry with [maintainState] set to true repeatedly
/// call [State.setState], the user's battery will be drained unnecessarily.
///
/// [OverlayEntry] is a [Listenable] that notifies when the widget built by
/// [builder] is mounted or unmounted, whose exact state can be queried by
/// [mounted]. After the owner of the [OverlayEntry] calls [remove] and then
/// [dispose], the widget may not be immediately removed from the widget tree.
/// As a result listeners of the [OverlayEntry] can get notified for one last
/// time after the [dispose] call, when the widget is eventually unmounted.
///
/// {@macro flutter.widgets.overlayPortalVsOverlayEntry}
///
/// See also:
///
///  * [OverlayPortal], an alternative API for inserting widgets into an
///    [Overlay] using a builder callback.
///  * [Overlay], a stack of entries that can be managed independently.
///  * [OverlayState], the current state of an Overlay.
///  * [WidgetsApp], a convenience widget that wraps a number of widgets that
///    are commonly required for an application.
///  * [MaterialApp], a convenience widget that wraps a number of widgets that
///    are commonly required for Material Design applications.
class OverlayEntry implements Listenable {
  /// Creates an overlay entry.
  ///
  /// To insert the entry into an [Overlay], first find the overlay using
  /// [Overlay.of] and then call [OverlayState.insert]. To remove the entry,
  /// call [remove] on the overlay entry itself.
  OverlayEntry({
    required this.builder,
    bool opaque = false,
    bool maintainState = false,
    this.canSizeOverlay = false,
  }) : _opaque = opaque,
       _maintainState = maintainState {
    if (kFlutterMemoryAllocationsEnabled) {
      _maybeDispatchObjectCreation();
    }
  }

  /// This entry will include the widget built by this builder in the overlay at
  /// the entry's position.
  ///
  /// To cause this builder to be called again, call [markNeedsBuild] on this
  /// overlay entry.
  final WidgetBuilder builder;

  /// Whether this entry occludes the entire overlay.
  ///
  /// If an entry claims to be opaque, then, for efficiency, the overlay will
  /// skip building entries below that entry unless they have [maintainState]
  /// set.
  bool get opaque => _opaque;
  bool _opaque;
  set opaque(bool value) {
    assert(!_disposedByOwner);
    if (_opaque == value) {
      return;
    }
    _opaque = value;
    _overlay?._didChangeEntryOpacity();
  }

  /// Whether this entry must be included in the tree even if there is a fully
  /// [opaque] entry above it.
  ///
  /// By default, if there is an entirely [opaque] entry over this one, then this
  /// one will not be included in the widget tree (in particular, stateful widgets
  /// within the overlay entry will not be instantiated). To ensure that your
  /// overlay entry is still built even if it is not visible, set [maintainState]
  /// to true. This is more expensive, so should be done with care. In particular,
  /// if widgets in an overlay entry with [maintainState] set to true repeatedly
  /// call [State.setState], the user's battery will be drained unnecessarily.
  ///
  /// This is used by the [Navigator] and [Route] objects to ensure that routes
  /// are kept around even when in the background, so that [Future]s promised
  /// from subsequent routes will be handled properly when they complete.
  bool get maintainState => _maintainState;
  bool _maintainState;
  set maintainState(bool value) {
    assert(!_disposedByOwner);
    if (_maintainState == value) {
      return;
    }
    _maintainState = value;
    assert(_overlay != null);
    _overlay!._didChangeEntryOpacity();
  }

  /// Whether the content of this [OverlayEntry] can be used to size the
  /// [Overlay].
  ///
  /// In most situations the overlay sizes itself based on its incoming
  /// constraints to be as large as possible. However, if that would result in
  /// an infinite size, it has to rely on one of its children to size itself. In
  /// this situation, the overlay will consult the topmost non-[Positioned]
  /// overlay entry that has this property set to true, lay it out with the
  /// incoming [BoxConstraints] of the overlay, and force all other
  /// non-[Positioned] overlay entries to have the same size. The [Positioned]
  /// entries are laid out as usual based on the calculated size of the overlay.
  ///
  /// Overlay entries that set this to true must be able to handle unconstrained
  /// [BoxConstraints].
  ///
  /// Setting this to true has no effect if the overlay entry uses a [Positioned]
  /// widget to position itself in the overlay.
  final bool canSizeOverlay;

  /// Whether the [OverlayEntry] is currently mounted in the widget tree.
  ///
  /// The [OverlayEntry] notifies its listeners when this value changes.
  bool get mounted => _overlayEntryStateNotifier?.value != null;

  /// The currently mounted `_OverlayEntryWidgetState` built using this [OverlayEntry].
  ValueNotifier<_OverlayEntryWidgetState?>? _overlayEntryStateNotifier =
      ValueNotifier<_OverlayEntryWidgetState?>(null);

  // TODO(polina-c): stop duplicating code across disposables
  // https://github.com/flutter/flutter/issues/137435
  /// Dispatches event of object creation to [FlutterMemoryAllocations.instance].
  void _maybeDispatchObjectCreation() {
    if (kFlutterMemoryAllocationsEnabled) {
      FlutterMemoryAllocations.instance.dispatchObjectCreated(
        library: _flutterWidgetsLibrary,
        className: '$OverlayEntry',
        object: this,
      );
    }
  }

  @override
  void addListener(VoidCallback listener) {
    assert(!_disposedByOwner);
    _overlayEntryStateNotifier?.addListener(listener);
  }

  @override
  void removeListener(VoidCallback listener) {
    _overlayEntryStateNotifier?.removeListener(listener);
  }

  OverlayState? _overlay;
  final GlobalKey<_OverlayEntryWidgetState> _key = GlobalKey<_OverlayEntryWidgetState>();

  /// Remove this entry from the overlay.
  ///
  /// This should only be called once.
  ///
  /// This method removes this overlay entry from the overlay immediately. The
  /// UI will be updated in the same frame if this method is called before the
  /// overlay rebuild in this frame; otherwise, the UI will be updated in the
  /// next frame. This means that it is safe to call during builds, but also
  /// that if you do call this after the overlay rebuild, the UI will not update
  /// until the next frame (i.e. many milliseconds later).
  void remove() {
    assert(_overlay != null);
    assert(!_disposedByOwner);
    final OverlayState overlay = _overlay!;
    _overlay = null;
    if (!overlay.mounted) {
      return;
    }

    overlay._entries.remove(this);
    if (SchedulerBinding.instance.schedulerPhase == SchedulerPhase.persistentCallbacks) {
      SchedulerBinding.instance.addPostFrameCallback((Duration duration) {
        overlay._markDirty();
      }, debugLabel: 'OverlayEntry.markDirty');
    } else {
      overlay._markDirty();
    }
  }

  /// Cause this entry to rebuild during the next pipeline flush.
  ///
  /// You need to call this function if the output of [builder] has changed.
  void markNeedsBuild() {
    assert(!_disposedByOwner);
    _key.currentState?._markNeedsBuild();
  }

  void _didUnmount() {
    assert(!mounted);
    if (_disposedByOwner) {
      _overlayEntryStateNotifier?.dispose();
      _overlayEntryStateNotifier = null;
    }
  }

  bool _disposedByOwner = false;

  /// Discards any resources used by this [OverlayEntry].
  ///
  /// This method must be called after [remove] if the [OverlayEntry] is
  /// inserted into an [Overlay].
  ///
  /// After this is called, the object is not in a usable state and should be
  /// discarded (calls to [addListener] will throw after the object is disposed).
  /// However, the listeners registered may not be immediately released until
  /// the widget built using this [OverlayEntry] is unmounted from the widget
  /// tree.
  ///
  /// This method should only be called by the object's owner.
  void dispose() {
    assert(!_disposedByOwner);
    assert(
      _overlay == null,
      'An OverlayEntry must first be removed from the Overlay before dispose is called.',
    );
    if (kFlutterMemoryAllocationsEnabled) {
      FlutterMemoryAllocations.instance.dispatchObjectDisposed(object: this);
    }
    _disposedByOwner = true;
    if (!mounted) {
      // If we're still mounted when disposed, then this will be disposed in
      // _didUnmount, to allow notifications to occur until the entry is
      // unmounted.
      _overlayEntryStateNotifier?.dispose();
      _overlayEntryStateNotifier = null;
    }
  }

  @override
  String toString() =>
      '${describeIdentity(this)}(opaque: $opaque; maintainState: $maintainState)${_disposedByOwner ? "(DISPOSED)" : ""}';
}

class _OverlayEntryWidget extends StatefulWidget {
  const _OverlayEntryWidget({
    required Key super.key,
    required this.entry,
    required this.overlayState,
    this.tickerEnabled = true,
  });

  final OverlayEntry entry;
  final OverlayState overlayState;
  final bool tickerEnabled;

  @override
  _OverlayEntryWidgetState createState() => _OverlayEntryWidgetState();
}

class _OverlayEntryWidgetState extends State<_OverlayEntryWidget> {
  late _RenderTheater _theater;

  // Manages the stack of theater children whose paint order are sorted by their
  // _zOrderIndex. The children added by OverlayPortal are added to this linked
  // list, and they will be shown _above_ the OverlayEntry tied to this widget.
  // The children with larger zOrderIndex values (i.e. those called `show`
  // recently) will be painted last.
  //
  // This linked list is lazily created in `_add`, and the entries are added/removed
  // via `_add`/`_remove`, called by OverlayPortals lower in the tree. `_add` or
  // `_remove` does not cause this widget to rebuild, the linked list will be
  // read by _RenderTheater as part of its render child model. This would ideally
  // be in a RenderObject but there may not be RenderObjects between
  // _RenderTheater and the render subtree OverlayEntry builds.
  LinkedList<_OverlayEntryLocation>? _sortedTheaterSiblings;

  // Worst-case O(N), N being the number of children added to the top spot in
  // the same frame. This can be a bit expensive when there's a lot of global
  // key reparenting in the same frame but N is usually a small number.
  void _add(_OverlayEntryLocation child) {
    assert(mounted);
    final LinkedList<_OverlayEntryLocation> children =
        _sortedTheaterSiblings ??= LinkedList<_OverlayEntryLocation>();
    assert(!children.contains(child));
    _OverlayEntryLocation? insertPosition = children.isEmpty ? null : children.last;
    while (insertPosition != null && insertPosition._zOrderIndex > child._zOrderIndex) {
      insertPosition = insertPosition.previous;
    }
    if (insertPosition == null) {
      children.addFirst(child);
    } else {
      insertPosition.insertAfter(child);
    }
    assert(children.contains(child));
  }

  void _remove(_OverlayEntryLocation child) {
    assert(_sortedTheaterSiblings != null);
    final bool wasInCollection = _sortedTheaterSiblings?.remove(child) ?? false;
    assert(wasInCollection);
  }

  // Returns an Iterable that traverse the children in the child model in paint
  // order (from farthest to the user to the closest to the user).
  //
  // The iterator should be safe to use even when the child model is being
  // mutated. The reason for that is it's allowed to add/remove/move deferred
  // children to a _RenderTheater during performLayout, but the affected
  // children don't have to be laid out in the same performLayout call.
  late final Iterable<RenderBox> _paintOrderIterable = _createChildIterable(reversed: false);
  // An Iterable that traverse the children in the child model in
  // hit-test order (from closest to the user to the farthest to the user).
  late final Iterable<RenderBox> _hitTestOrderIterable = _createChildIterable(reversed: true);

  // The following uses sync* because hit-testing is lazy, and LinkedList as a
  // Iterable doesn't support concurrent modification.
  Iterable<RenderBox> _createChildIterable({required bool reversed}) sync* {
    final LinkedList<_OverlayEntryLocation>? children = _sortedTheaterSiblings;
    if (children == null || children.isEmpty) {
      return;
    }
    _OverlayEntryLocation? candidate = reversed ? children.last : children.first;
    while (candidate != null) {
      final RenderBox? renderBox = candidate._overlayChildRenderBox;
      candidate = reversed ? candidate.previous : candidate.next;
      if (renderBox != null) {
        yield renderBox;
      }
    }
  }

  @override
  void initState() {
    super.initState();
    widget.entry._overlayEntryStateNotifier!.value = this;
    _theater = context.findAncestorRenderObjectOfType<_RenderTheater>()!;
    assert(_sortedTheaterSiblings == null);
  }

  @override
  void didUpdateWidget(_OverlayEntryWidget oldWidget) {
    super.didUpdateWidget(oldWidget);
    // OverlayState's build method always returns a RenderObjectWidget _Theater,
    // so it's safe to assume that state equality implies render object equality.
    assert(oldWidget.entry == widget.entry);
    if (oldWidget.overlayState != widget.overlayState) {
      final _RenderTheater newTheater = context.findAncestorRenderObjectOfType<_RenderTheater>()!;
      assert(_theater != newTheater);
      _theater = newTheater;
    }
  }

  @override
  void dispose() {
    widget.entry._overlayEntryStateNotifier?.value = null;
    widget.entry._didUnmount();
    _sortedTheaterSiblings = null;
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    return TickerMode(
      enabled: widget.tickerEnabled,
      child: _RenderTheaterMarker(
        theater: _theater,
        overlayEntryWidgetState: this,
        child: widget.entry.builder(context),
      ),
    );
  }

  void _markNeedsBuild() {
    setState(() {
      /* the state that changed is in the builder */
    });
  }
}

/// A stack of entries that can be managed independently.
///
/// Overlays let independent child widgets "float" visual elements on top of
/// other widgets by inserting them into the overlay's stack. The overlay lets
/// each of these widgets manage their participation in the overlay using
/// [OverlayEntry] objects.
///
/// Although you can create an [Overlay] directly, it's most common to use the
/// overlay created by the [Navigator] in a [WidgetsApp], [CupertinoApp] or a
/// [MaterialApp]. The navigator uses its overlay to manage the visual
/// appearance of its routes.
///
/// The [Overlay] widget uses a custom stack implementation, which is very
/// similar to the [Stack] widget. The main use case of [Overlay] is related to
/// navigation and being able to insert widgets on top of the pages in an app.
/// For layout purposes unrelated to navigation, consider using [Stack] instead.
///
/// An [Overlay] widget requires a [Directionality] widget to be in scope, so
/// that it can resolve direction-sensitive coordinates of any
/// [Positioned.directional] children.
///
/// For widgets drawn in an [OverlayEntry], do not assume that the size of the
/// [Overlay] is the size returned by [MediaQuery.sizeOf]. Nested overlays can
/// have different sizes.
///
/// {@tool dartpad}
/// This example shows how to use the [Overlay] to highlight the [NavigationBar]
/// destination.
///
/// ** See code in examples/api/lib/widgets/overlay/overlay.0.dart **
/// {@end-tool}
///
/// See also:
///
///  * [OverlayEntry], the class that is used for describing the overlay entries.
///  * [OverlayState], which is used to insert the entries into the overlay.
///  * [WidgetsApp], which inserts an [Overlay] widget indirectly via its [Navigator].
///  * [MaterialApp], which inserts an [Overlay] widget indirectly via its [Navigator].
///  * [CupertinoApp], which inserts an [Overlay] widget indirectly via its [Navigator].
///  * [Stack], which allows directly displaying a stack of widgets.
class Overlay extends StatefulWidget {
  /// Creates an overlay.
  ///
  /// The initial entries will be inserted into the overlay when its associated
  /// [OverlayState] is initialized.
  ///
  /// Rather than creating an overlay, consider using the overlay that is
  /// created by the [Navigator] in a [WidgetsApp], [CupertinoApp], or a
  /// [MaterialApp] for the application.
  const Overlay({
    super.key,
    this.initialEntries = const <OverlayEntry>[],
    this.clipBehavior = Clip.hardEdge,
  });

  /// Wrap the provided `child` in an [Overlay] to allow other visual elements
  /// (packed in [OverlayEntry]s) to float on top of the child.
  ///
  /// This is a convenience method over the regular [Overlay] constructor: It
  /// creates an [Overlay] and puts the provided `child` in an [OverlayEntry]
  /// at the bottom of that newly created Overlay.
  static Widget wrap({Key? key, Clip clipBehavior = Clip.hardEdge, required Widget child}) {
    return _WrappingOverlay(key: key, clipBehavior: clipBehavior, child: child);
  }

  /// The entries to include in the overlay initially.
  ///
  /// These entries are only used when the [OverlayState] is initialized. If you
  /// are providing a new [Overlay] description for an overlay that's already in
  /// the tree, then the new entries are ignored.
  ///
  /// To add entries to an [Overlay] that is already in the tree, use
  /// [Overlay.of] to obtain the [OverlayState] (or assign a [GlobalKey] to the
  /// [Overlay] widget and obtain the [OverlayState] via
  /// [GlobalKey.currentState]), and then use [OverlayState.insert] or
  /// [OverlayState.insertAll].
  ///
  /// To remove an entry from an [Overlay], use [OverlayEntry.remove].
  final List<OverlayEntry> initialEntries;

  /// {@macro flutter.material.Material.clipBehavior}
  ///
  /// Defaults to [Clip.hardEdge].
  final Clip clipBehavior;

  /// The [OverlayState] from the closest instance of [Overlay] that encloses
  /// the given context within the closest [LookupBoundary], and, in debug mode,
  /// will throw if one is not found.
  ///
  /// In debug mode, if the `debugRequiredFor` argument is provided and an
  /// overlay isn't found, then this function will throw an exception containing
  /// the runtime type of the given widget in the error message. The exception
  /// attempts to explain that the calling [Widget] (the one given by the
  /// `debugRequiredFor` argument) needs an [Overlay] to be present to function.
  /// If `debugRequiredFor` is not supplied, then the error message is more
  /// generic.
  ///
  /// Typical usage is as follows:
  ///
  /// ```dart
  /// OverlayState overlay = Overlay.of(context);
  /// ```
  ///
  /// If `rootOverlay` is set to true, the state from the furthest instance of
  /// this class is given instead. Useful for installing overlay entries above
  /// all subsequent instances of [Overlay].
  ///
  /// This method can be expensive (it walks the element tree).
  ///
  /// See also:
  ///
  /// * [Overlay.maybeOf] for a similar function that returns null if an
  ///   [Overlay] is not found.
  static OverlayState of(
    BuildContext context, {
    bool rootOverlay = false,
    Widget? debugRequiredFor,
  }) {
    final OverlayState? result = maybeOf(context, rootOverlay: rootOverlay);
    assert(() {
      if (result == null) {
        final bool hiddenByBoundary = LookupBoundary.debugIsHidingAncestorStateOfType<OverlayState>(
          context,
        );
        final List<DiagnosticsNode> information = <DiagnosticsNode>[
          ErrorSummary(
            'No Overlay widget found${hiddenByBoundary ? ' within the closest LookupBoundary' : ''}.',
          ),
          if (hiddenByBoundary)
            ErrorDescription(
              'There is an ancestor Overlay widget, but it is hidden by a LookupBoundary.',
            ),
          ErrorDescription(
            '${debugRequiredFor?.runtimeType ?? 'Some'} widgets require an Overlay widget ancestor for correct operation.',
          ),
          ErrorHint(
            'The most common way to add an Overlay to an application is to include a MaterialApp, CupertinoApp or Navigator widget in the runApp() call.',
          ),
          if (debugRequiredFor != null)
            DiagnosticsProperty<Widget>(
              'The specific widget that failed to find an overlay was',
              debugRequiredFor,
              style: DiagnosticsTreeStyle.errorProperty,
            ),
          if (context.widget != debugRequiredFor)
            context.describeElement(
              'The context from which that widget was searching for an overlay was',
            ),
        ];

        throw FlutterError.fromParts(information);
      }
      return true;
    }());
    return result!;
  }

  /// The [OverlayState] from the closest instance of [Overlay] that encloses
  /// the given context within the closest [LookupBoundary], if any.
  ///
  /// Typical usage is as follows:
  ///
  /// ```dart
  /// OverlayState? overlay = Overlay.maybeOf(context);
  /// ```
  ///
  /// If `rootOverlay` is set to true, the state from the furthest instance of
  /// this class is given instead. Useful for installing overlay entries above
  /// all subsequent instances of [Overlay].
  ///
  /// This method can be expensive (it walks the element tree).
  ///
  /// See also:
  ///
  ///  * [Overlay.of] for a similar function that returns a non-nullable result
  ///    and throws if an [Overlay] is not found.

  static OverlayState? maybeOf(BuildContext context, {bool rootOverlay = false}) {
    return rootOverlay
        ? LookupBoundary.findRootAncestorStateOfType<OverlayState>(context)
        : LookupBoundary.findAncestorStateOfType<OverlayState>(context);
  }

  @override
  OverlayState createState() => OverlayState();
}

/// The current state of an [Overlay].
///
/// Used to insert [OverlayEntry]s into the overlay using the [insert] and
/// [insertAll] functions.
class OverlayState extends State<Overlay> with TickerProviderStateMixin {
  final List<OverlayEntry> _entries = <OverlayEntry>[];

  @protected
  @override
  void initState() {
    super.initState();
    insertAll(widget.initialEntries);
  }

  int _insertionIndex(OverlayEntry? below, OverlayEntry? above) {
    assert(above == null || below == null);
    if (below != null) {
      return _entries.indexOf(below);
    }
    if (above != null) {
      return _entries.indexOf(above) + 1;
    }
    return _entries.length;
  }

  bool _debugCanInsertEntry(OverlayEntry entry) {
    final List<DiagnosticsNode> operandsInformation = <DiagnosticsNode>[
      DiagnosticsProperty<OverlayEntry>(
        'The OverlayEntry was',
        entry,
        style: DiagnosticsTreeStyle.errorProperty,
      ),
      DiagnosticsProperty<OverlayState>(
        'The Overlay the OverlayEntry was trying to insert to was',
        this,
        style: DiagnosticsTreeStyle.errorProperty,
      ),
    ];

    if (!mounted) {
      throw FlutterError.fromParts(<DiagnosticsNode>[
        ErrorSummary('Attempted to insert an OverlayEntry to an already disposed Overlay.'),
        ...operandsInformation,
      ]);
    }

    final OverlayState? currentOverlay = entry._overlay;
    final bool alreadyContainsEntry = _entries.contains(entry);

    if (alreadyContainsEntry) {
      final bool inconsistentOverlayState = !identical(currentOverlay, this);
      throw FlutterError.fromParts(<DiagnosticsNode>[
        ErrorSummary('The specified entry is already present in the target Overlay.'),
        ...operandsInformation,
        if (inconsistentOverlayState)
          ErrorHint('This could be an error in the Flutter framework.')
        else
          ErrorHint(
            'Consider calling remove on the OverlayEntry before inserting it to a different Overlay, '
            'or switching to the OverlayPortal API to avoid manual OverlayEntry management.',
          ),
        if (inconsistentOverlayState)
          DiagnosticsProperty<OverlayState>(
            "The OverlayEntry's current Overlay was",
            currentOverlay,
            style: DiagnosticsTreeStyle.errorProperty,
          ),
      ]);
    }

    if (currentOverlay == null) {
      return true;
    }

    throw FlutterError.fromParts(<DiagnosticsNode>[
      ErrorSummary('The specified entry is already present in a different Overlay.'),
      ...operandsInformation,
      DiagnosticsProperty<OverlayState>(
        "The OverlayEntry's current Overlay was",
        currentOverlay,
        style: DiagnosticsTreeStyle.errorProperty,
      ),
      ErrorHint(
        'Consider calling remove on the OverlayEntry before inserting it to a different Overlay, '
        'or switching to the OverlayPortal API to avoid manual OverlayEntry management.',
      ),
    ]);
  }

  /// Insert the given entry into the overlay.
  ///
  /// If `below` is non-null, the entry is inserted just below `below`.
  /// If `above` is non-null, the entry is inserted just above `above`.
  /// Otherwise, the entry is inserted on top.
  ///
  /// It is an error to specify both `above` and `below`.
  void insert(OverlayEntry entry, {OverlayEntry? below, OverlayEntry? above}) {
    assert(_debugVerifyInsertPosition(above, below));
    assert(_debugCanInsertEntry(entry));
    entry._overlay = this;
    setState(() {
      _entries.insert(_insertionIndex(below, above), entry);
    });
  }

  /// Insert all the entries in the given iterable.
  ///
  /// If `below` is non-null, the entries are inserted just below `below`.
  /// If `above` is non-null, the entries are inserted just above `above`.
  /// Otherwise, the entries are inserted on top.
  ///
  /// It is an error to specify both `above` and `below`.
  void insertAll(Iterable<OverlayEntry> entries, {OverlayEntry? below, OverlayEntry? above}) {
    assert(_debugVerifyInsertPosition(above, below));
    assert(entries.every(_debugCanInsertEntry));
    if (entries.isEmpty) {
      return;
    }
    for (final OverlayEntry entry in entries) {
      assert(entry._overlay == null);
      entry._overlay = this;
    }
    setState(() {
      _entries.insertAll(_insertionIndex(below, above), entries);
    });
  }

  bool _debugVerifyInsertPosition(
    OverlayEntry? above,
    OverlayEntry? below, {
    Iterable<OverlayEntry>? newEntries,
  }) {
    assert(above == null || below == null, 'Only one of `above` and `below` may be specified.');
    assert(
      above == null ||
          (above._overlay == this &&
              _entries.contains(above) &&
              (newEntries?.contains(above) ?? true)),
      'The provided entry used for `above` must be present in the Overlay${newEntries != null ? ' and in the `newEntriesList`' : ''}.',
    );
    assert(
      below == null ||
          (below._overlay == this &&
              _entries.contains(below) &&
              (newEntries?.contains(below) ?? true)),
      'The provided entry used for `below` must be present in the Overlay${newEntries != null ? ' and in the `newEntriesList`' : ''}.',
    );
    return true;
  }

  /// Remove all the entries listed in the given iterable, then reinsert them
  /// into the overlay in the given order.
  ///
  /// Entries mention in `newEntries` but absent from the overlay are inserted
  /// as if with [insertAll].
  ///
  /// Entries not mentioned in `newEntries` but present in the overlay are
  /// positioned as a group in the resulting list relative to the entries that
  /// were moved, as specified by one of `below` or `above`, which, if
  /// specified, must be one of the entries in `newEntries`:
  ///
  /// If `below` is non-null, the group is positioned just below `below`.
  /// If `above` is non-null, the group is positioned just above `above`.
  /// Otherwise, the group is left on top, with all the rearranged entries
  /// below.
  ///
  /// It is an error to specify both `above` and `below`.
  void rearrange(Iterable<OverlayEntry> newEntries, {OverlayEntry? below, OverlayEntry? above}) {
    final List<OverlayEntry> newEntriesList =
        newEntries is List<OverlayEntry> ? newEntries : newEntries.toList(growable: false);
    assert(_debugVerifyInsertPosition(above, below, newEntries: newEntriesList));
    assert(
      newEntriesList.every(
        (OverlayEntry entry) => entry._overlay == null || entry._overlay == this,
      ),
      'One or more of the specified entries are already present in another Overlay.',
    );
    assert(
      newEntriesList.every(
        (OverlayEntry entry) => _entries.indexOf(entry) == _entries.lastIndexOf(entry),
      ),
      'One or more of the specified entries are specified multiple times.',
    );
    if (newEntriesList.isEmpty) {
      return;
    }
    if (listEquals(_entries, newEntriesList)) {
      return;
    }
    final LinkedHashSet<OverlayEntry> old = LinkedHashSet<OverlayEntry>.of(_entries);
    for (final OverlayEntry entry in newEntriesList) {
      entry._overlay ??= this;
    }
    setState(() {
      _entries.clear();
      _entries.addAll(newEntriesList);
      old.removeAll(newEntriesList);
      _entries.insertAll(_insertionIndex(below, above), old);
    });
  }

  void _markDirty() {
    if (mounted) {
      setState(() {});
    }
  }

  /// (DEBUG ONLY) Check whether a given entry is visible (i.e., not behind an
  /// opaque entry).
  ///
  /// This is an O(N) algorithm, and should not be necessary except for debug
  /// asserts. To avoid people depending on it, this function is implemented
  /// only in debug mode, and always returns false in release mode.
  bool debugIsVisible(OverlayEntry entry) {
    bool result = false;
    assert(_entries.contains(entry));
    assert(() {
      for (int i = _entries.length - 1; i > 0; i -= 1) {
        final OverlayEntry candidate = _entries[i];
        if (candidate == entry) {
          result = true;
          break;
        }
        if (candidate.opaque) {
          break;
        }
      }
      return true;
    }());
    return result;
  }

  void _didChangeEntryOpacity() {
    setState(() {
      // We use the opacity of the entry in our build function, which means we
      // our state has changed.
    });
  }

  @protected
  @override
  Widget build(BuildContext context) {
    // This list is filled backwards and then reversed below before
    // it is added to the tree.
    final List<_OverlayEntryWidget> children = <_OverlayEntryWidget>[];
    bool onstage = true;
    int onstageCount = 0;
    for (final OverlayEntry entry in _entries.reversed) {
      if (onstage) {
        onstageCount += 1;
        children.add(_OverlayEntryWidget(key: entry._key, overlayState: this, entry: entry));
        if (entry.opaque) {
          onstage = false;
        }
      } else if (entry.maintainState) {
        children.add(
          _OverlayEntryWidget(
            key: entry._key,
            overlayState: this,
            entry: entry,
            tickerEnabled: false,
          ),
        );
      }
    }
    return _Theater(
      skipCount: children.length - onstageCount,
      clipBehavior: widget.clipBehavior,
      children: children.reversed.toList(growable: false),
    );
  }

  @protected
  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    // TODO(jacobr): use IterableProperty instead as that would
    // provide a slightly more consistent string summary of the List.
    properties.add(DiagnosticsProperty<List<OverlayEntry>>('entries', _entries));
  }
}

class _WrappingOverlay extends StatefulWidget {
  const _WrappingOverlay({super.key, this.clipBehavior = Clip.hardEdge, required this.child});

  final Clip clipBehavior;
  final Widget child;

  @override
  State<_WrappingOverlay> createState() => _WrappingOverlayState();
}

class _WrappingOverlayState extends State<_WrappingOverlay> {
  late final OverlayEntry _entry = OverlayEntry(
    canSizeOverlay: true,
    opaque: true,
    builder: (BuildContext context) {
      return widget.child;
    },
  );

  @override
  void didUpdateWidget(_WrappingOverlay oldWidget) {
    super.didUpdateWidget(oldWidget);
    _entry.markNeedsBuild();
  }

  @override
  void dispose() {
    _entry
      ..remove()
      ..dispose();
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    return Overlay(clipBehavior: widget.clipBehavior, initialEntries: <OverlayEntry>[_entry]);
  }
}

/// Special version of a [Stack], that doesn't layout and render the first
/// [skipCount] children.
///
/// The first [skipCount] children are considered "offstage".
class _Theater extends MultiChildRenderObjectWidget {
  const _Theater({
    this.skipCount = 0,
    this.clipBehavior = Clip.hardEdge,
    required List<_OverlayEntryWidget> super.children,
  }) : assert(skipCount >= 0),
       assert(children.length >= skipCount);

  final int skipCount;

  final Clip clipBehavior;

  @override
  _TheaterElement createElement() => _TheaterElement(this);

  @override
  _RenderTheater createRenderObject(BuildContext context) {
    return _RenderTheater(
      skipCount: skipCount,
      textDirection: Directionality.of(context),
      clipBehavior: clipBehavior,
    );
  }

  @override
  void updateRenderObject(BuildContext context, _RenderTheater renderObject) {
    renderObject
      ..skipCount = skipCount
      ..textDirection = Directionality.of(context)
      ..clipBehavior = clipBehavior;
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties.add(IntProperty('skipCount', skipCount));
  }
}

class _TheaterElement extends MultiChildRenderObjectElement {
  _TheaterElement(_Theater super.widget);

  @override
  _RenderTheater get renderObject => super.renderObject as _RenderTheater;

  @override
  void insertRenderObjectChild(RenderBox child, IndexedSlot<Element?> slot) {
    super.insertRenderObjectChild(child, slot);
    final _TheaterParentData parentData = child.parentData! as _TheaterParentData;
    parentData.overlayEntry =
        ((widget as _Theater).children[slot.index] as _OverlayEntryWidget).entry;
    assert(parentData.overlayEntry != null);
  }

  @override
  void moveRenderObjectChild(
    RenderBox child,
    IndexedSlot<Element?> oldSlot,
    IndexedSlot<Element?> newSlot,
  ) {
    super.moveRenderObjectChild(child, oldSlot, newSlot);
    assert(() {
      final _TheaterParentData parentData = child.parentData! as _TheaterParentData;
      return parentData.overlayEntry ==
          ((widget as _Theater).children[newSlot.index] as _OverlayEntryWidget).entry;
    }());
  }

  @override
  void debugVisitOnstageChildren(ElementVisitor visitor) {
    final _Theater theater = widget as _Theater;
    assert(children.length >= theater.skipCount);
    children.skip(theater.skipCount).forEach(visitor);
  }
}

// A `RenderBox` that sizes itself to its parent's size, implements the stack
// layout algorithm and renders its children in the given `theater`.
mixin _RenderTheaterMixin on RenderBox {
  _RenderTheater get theater;

  Iterable<RenderBox> _childrenInPaintOrder();
  Iterable<RenderBox> _childrenInHitTestOrder();

  @override
  void setupParentData(RenderBox child) {
    if (child.parentData is! StackParentData) {
      child.parentData = StackParentData();
    }
  }

  @override
  double? computeDistanceToActualBaseline(TextBaseline baseline) {
    assert(!debugNeedsLayout);
    BaselineOffset baselineOffset = BaselineOffset.noBaseline;
    for (final RenderBox child in _childrenInPaintOrder()) {
      assert(!child.debugNeedsLayout);
      final StackParentData childParentData = child.parentData! as StackParentData;
      baselineOffset = baselineOffset.minOf(
        BaselineOffset(child.getDistanceToActualBaseline(baseline)) + childParentData.offset.dy,
      );
    }
    return baselineOffset.offset;
  }

  static double? baselineForChild(
    RenderBox child,
    Size theaterSize,
    BoxConstraints nonPositionedChildConstraints,
    Alignment alignment,
    TextBaseline baseline,
  ) {
    final StackParentData childParentData = child.parentData! as StackParentData;
    final BoxConstraints childConstraints =
        childParentData.isPositioned
            ? childParentData.positionedChildConstraints(theaterSize)
            : nonPositionedChildConstraints;
    final double? baselineOffset = child.getDryBaseline(childConstraints, baseline);
    if (baselineOffset == null) {
      return null;
    }
    final double y = switch (childParentData) {
      StackParentData(:final double top?) => top,
      StackParentData(:final double bottom?) =>
        theaterSize.height - bottom - child.getDryLayout(childConstraints).height,
      StackParentData() =>
        alignment.alongOffset(theaterSize - child.getDryLayout(childConstraints) as Offset).dy,
    };
    return baselineOffset + y;
  }

  void layoutChild(RenderBox child, BoxConstraints nonPositionedChildConstraints) {
    final StackParentData childParentData = child.parentData! as StackParentData;
    final Alignment alignment = theater._resolvedAlignment;
    if (!childParentData.isPositioned) {
      child.layout(nonPositionedChildConstraints, parentUsesSize: true);
      childParentData.offset = Offset.zero;
    } else {
      assert(
        child is! _RenderDeferredLayoutBox,
        'all _RenderDeferredLayoutBoxes must be non-positioned children.',
      );
      RenderStack.layoutPositionedChild(child, childParentData, size, alignment);
    }
    assert(child.parentData == childParentData);
  }

  @override
  bool hitTestChildren(BoxHitTestResult result, {required Offset position}) {
    final Iterator<RenderBox> iterator = _childrenInHitTestOrder().iterator;
    bool isHit = false;
    while (!isHit && iterator.moveNext()) {
      final RenderBox child = iterator.current;
      final StackParentData childParentData = child.parentData! as StackParentData;
      final RenderBox localChild = child;
      bool childHitTest(BoxHitTestResult result, Offset position) =>
          localChild.hitTest(result, position: position);
      isHit = result.addWithPaintOffset(
        offset: childParentData.offset,
        position: position,
        hitTest: childHitTest,
      );
    }
    return isHit;
  }

  @override
  void paint(PaintingContext context, Offset offset) {
    for (final RenderBox child in _childrenInPaintOrder()) {
      final StackParentData childParentData = child.parentData! as StackParentData;
      context.paintChild(child, childParentData.offset + offset);
    }
  }
}

class _TheaterParentData extends StackParentData {
  // The OverlayEntry that directly created this child. This field is null for
  // children that are created by an OverlayPortal.
  OverlayEntry? overlayEntry;

  /// A [OverlayPortal] makes its overlay child a render child of an ancestor
  /// [Overlay]. Currently, to make sure the overlay child is painted after its
  /// [OverlayPortal], and before the next [OverlayEntry] (which could be
  /// something that should obstruct the overlay child, such as a [ModalRoute])
  /// in the host [Overlay], the paint order of each overlay child is managed by
  /// the [OverlayEntry] that hosts its [OverlayPortal].
  ///
  /// The following methods are exposed to allow easy access to the overlay
  /// children's render objects whose order is managed by [overlayEntry], in the
  /// right order.

  // _overlayStateMounted is set to null in _OverlayEntryWidgetState's dispose
  // method. This property is only accessed during layout, paint and hit-test so
  // the `value!` should be safe.
  Iterator<RenderBox>? get paintOrderIterator =>
      overlayEntry?._overlayEntryStateNotifier?.value!._paintOrderIterable.iterator;
  Iterator<RenderBox>? get hitTestOrderIterator =>
      overlayEntry?._overlayEntryStateNotifier?.value!._hitTestOrderIterable.iterator;

  // A convenience method for traversing `paintOrderIterator` with a
  // [RenderObjectVisitor].
  void visitOverlayPortalChildrenOnOverlayEntry(RenderObjectVisitor visitor) =>
      overlayEntry?._overlayEntryStateNotifier?.value!._paintOrderIterable.forEach(visitor);
}

class _RenderTheater extends RenderBox
    with ContainerRenderObjectMixin<RenderBox, StackParentData>, _RenderTheaterMixin {
  _RenderTheater({
    List<RenderBox>? children,
    required TextDirection textDirection,
    int skipCount = 0,
    Clip clipBehavior = Clip.hardEdge,
  }) : assert(skipCount >= 0),
       _textDirection = textDirection,
       _skipCount = skipCount,
       _clipBehavior = clipBehavior {
    addAll(children);
  }

  @override
  _RenderTheater get theater => this;

  @override
  void setupParentData(RenderBox child) {
    if (child.parentData is! _TheaterParentData) {
      child.parentData = _TheaterParentData();
    }
  }

  @override
  void attach(PipelineOwner owner) {
    super.attach(owner);
    RenderBox? child = firstChild;
    while (child != null) {
      final _TheaterParentData childParentData = child.parentData! as _TheaterParentData;
      final Iterator<RenderBox>? iterator = childParentData.paintOrderIterator;
      if (iterator != null) {
        while (iterator.moveNext()) {
          iterator.current.attach(owner);
        }
      }
      child = childParentData.nextSibling;
    }
  }

  static void _detachChild(RenderObject child) => child.detach();

  @override
  void detach() {
    super.detach();
    RenderBox? child = firstChild;
    while (child != null) {
      final _TheaterParentData childParentData = child.parentData! as _TheaterParentData;
      childParentData.visitOverlayPortalChildrenOnOverlayEntry(_detachChild);
      child = childParentData.nextSibling;
    }
  }

  @override
  void redepthChildren() => visitChildren(redepthChild);

  Alignment? _alignmentCache;
  Alignment get _resolvedAlignment =>
      _alignmentCache ??= AlignmentDirectional.topStart.resolve(textDirection);

  void _markNeedResolution() {
    _alignmentCache = null;
    markNeedsLayout();
  }

  TextDirection get textDirection => _textDirection;
  TextDirection _textDirection;
  set textDirection(TextDirection value) {
    if (_textDirection == value) {
      return;
    }
    _textDirection = value;
    _markNeedResolution();
  }

  int get skipCount => _skipCount;
  int _skipCount;
  set skipCount(int value) {
    if (_skipCount != value) {
      _skipCount = value;
      markNeedsLayout();
    }
  }

  /// {@macro flutter.material.Material.clipBehavior}
  ///
  /// Defaults to [Clip.hardEdge].
  Clip get clipBehavior => _clipBehavior;
  Clip _clipBehavior = Clip.hardEdge;
  set clipBehavior(Clip value) {
    if (value != _clipBehavior) {
      _clipBehavior = value;
      markNeedsPaint();
      markNeedsSemanticsUpdate();
    }
  }

  // Adding/removing deferred child does not affect the layout of other children,
  // or that of the Overlay, so there's no need to invalidate the layout of the
  // Overlay.
  //
  // When _skipMarkNeedsLayout is true, markNeedsLayout does not do anything.
  bool _skipMarkNeedsLayout = false;
  void _addDeferredChild(_RenderDeferredLayoutBox child) {
    assert(!_skipMarkNeedsLayout);
    _skipMarkNeedsLayout = true;
    adoptChild(child);
    // The Overlay still needs repainting when a deferred child is added. Usually
    // `markNeedsLayout` implies `markNeedsPaint`, but here `markNeedsLayout` is
    // skipped when the `_skipMarkNeedsLayout` flag is set.
    markNeedsPaint();
    _skipMarkNeedsLayout = false;

    // After adding `child` to the render tree, we want to make sure it will be
    // laid out in the same frame. This is done by calling markNeedsLayout on the
    // layout surrogate. This ensures `child` is reachable via tree walk (see
    // _RenderLayoutSurrogateProxyBox.performLayout).
    child._layoutSurrogate.markNeedsLayout();
  }

  void _removeDeferredChild(_RenderDeferredLayoutBox child) {
    assert(!_skipMarkNeedsLayout);
    _skipMarkNeedsLayout = true;
    dropChild(child);
    // The Overlay still needs repainting when a deferred child is dropped. See
    // the comment in `_addDeferredChild`.
    markNeedsPaint();
    _skipMarkNeedsLayout = false;
  }

  @override
  void markNeedsLayout() {
    if (!_skipMarkNeedsLayout) {
      super.markNeedsLayout();
    }
  }

  RenderBox? get _firstOnstageChild {
    if (skipCount == super.childCount) {
      return null;
    }
    RenderBox? child = super.firstChild;
    for (int toSkip = skipCount; toSkip > 0; toSkip--) {
      final StackParentData childParentData = child!.parentData! as StackParentData;
      child = childParentData.nextSibling;
      assert(child != null);
    }
    return child;
  }

  RenderBox? get _lastOnstageChild => skipCount == super.childCount ? null : lastChild;

  @override
  double computeMinIntrinsicWidth(double height) {
    return RenderStack.getIntrinsicDimension(
      _firstOnstageChild,
      (RenderBox child) => child.getMinIntrinsicWidth(height),
    );
  }

  @override
  double computeMaxIntrinsicWidth(double height) {
    return RenderStack.getIntrinsicDimension(
      _firstOnstageChild,
      (RenderBox child) => child.getMaxIntrinsicWidth(height),
    );
  }

  @override
  double computeMinIntrinsicHeight(double width) {
    return RenderStack.getIntrinsicDimension(
      _firstOnstageChild,
      (RenderBox child) => child.getMinIntrinsicHeight(width),
    );
  }

  @override
  double computeMaxIntrinsicHeight(double width) {
    return RenderStack.getIntrinsicDimension(
      _firstOnstageChild,
      (RenderBox child) => child.getMaxIntrinsicHeight(width),
    );
  }

  @override
  double? computeDryBaseline(BoxConstraints constraints, TextBaseline baseline) {
    final Size size =
        constraints.biggest.isFinite
            ? constraints.biggest
            : _findSizeDeterminingChild().getDryLayout(constraints);
    final BoxConstraints nonPositionedChildConstraints = BoxConstraints.tight(size);
    final Alignment alignment = theater._resolvedAlignment;

    BaselineOffset baselineOffset = BaselineOffset.noBaseline;
    for (final RenderBox child in _childrenInPaintOrder()) {
      baselineOffset = baselineOffset.minOf(
        BaselineOffset(
          _RenderTheaterMixin.baselineForChild(
            child,
            size,
            nonPositionedChildConstraints,
            alignment,
            baseline,
          ),
        ),
      );
    }
    return baselineOffset.offset;
  }

  @override
  Size computeDryLayout(BoxConstraints constraints) {
    if (constraints.biggest.isFinite) {
      return constraints.biggest;
    }
    return _findSizeDeterminingChild().getDryLayout(constraints);
  }

  @override
  // The following uses sync* because concurrent modifications should be allowed
  // during layout.
  Iterable<RenderBox> _childrenInPaintOrder() sync* {
    RenderBox? child = _firstOnstageChild;
    while (child != null) {
      yield child;
      final _TheaterParentData childParentData = child.parentData! as _TheaterParentData;
      final Iterator<RenderBox>? innerIterator = childParentData.paintOrderIterator;
      if (innerIterator != null) {
        while (innerIterator.moveNext()) {
          yield innerIterator.current;
        }
      }
      child = childParentData.nextSibling;
    }
  }

  @override
  // The following uses sync* because hit testing should be lazy.
  Iterable<RenderBox> _childrenInHitTestOrder() sync* {
    RenderBox? child = _lastOnstageChild;
    int childLeft = childCount - skipCount;
    while (child != null) {
      final _TheaterParentData childParentData = child.parentData! as _TheaterParentData;
      final Iterator<RenderBox>? innerIterator = childParentData.hitTestOrderIterator;
      if (innerIterator != null) {
        while (innerIterator.moveNext()) {
          yield innerIterator.current;
        }
      }
      yield child;
      childLeft -= 1;
      child = childLeft <= 0 ? null : childParentData.previousSibling;
    }
  }

  @override
  bool get sizedByParent => false;

  bool _layingOutSizeDeterminingChild = false;
  @override
  void performLayout() {
    RenderBox? sizeDeterminingChild;
    if (constraints.biggest.isFinite) {
      size = constraints.biggest;
    } else {
      sizeDeterminingChild = _findSizeDeterminingChild();
      _layingOutSizeDeterminingChild = true;
      layoutChild(sizeDeterminingChild, constraints);
      _layingOutSizeDeterminingChild = false;
      size = sizeDeterminingChild.size;
    }

    // Equivalent to BoxConstraints used by RenderStack for StackFit.expand.
    final BoxConstraints nonPositionedChildConstraints = BoxConstraints.tight(size);
    for (final RenderBox child in _childrenInPaintOrder()) {
      if (child != sizeDeterminingChild) {
        layoutChild(child, nonPositionedChildConstraints);
      }
    }
  }

  RenderBox _findSizeDeterminingChild() {
    RenderBox? child = _lastOnstageChild;
    while (child != null) {
      final _TheaterParentData childParentData = child.parentData! as _TheaterParentData;
      if ((childParentData.overlayEntry?.canSizeOverlay ?? false) &&
          !childParentData.isPositioned) {
        return child;
      }
      child = childParentData.previousSibling;
    }
    throw FlutterError.fromParts(<DiagnosticsNode>[
      ErrorSummary(
        'Overlay was given infinite constraints and cannot be sized by a suitable child.',
      ),
      ErrorDescription(
        'The constraints given to the overlay ($constraints) would result in an illegal '
        'infinite size (${constraints.biggest}). To avoid that, the Overlay tried to size '
        'itself to one of its children, but no suitable non-positioned child that belongs to an '
        'OverlayEntry with canSizeOverlay set to true could be found.',
      ),
      ErrorHint(
        'Try wrapping the Overlay in a SizedBox to give it a finite size or '
        'use an OverlayEntry with canSizeOverlay set to true.',
      ),
    ]);
  }

  final LayerHandle<ClipRectLayer> _clipRectLayer = LayerHandle<ClipRectLayer>();

  @override
  void paint(PaintingContext context, Offset offset) {
    if (clipBehavior != Clip.none) {
      _clipRectLayer.layer = context.pushClipRect(
        needsCompositing,
        offset,
        Offset.zero & size,
        super.paint,
        clipBehavior: clipBehavior,
        oldLayer: _clipRectLayer.layer,
      );
    } else {
      _clipRectLayer.layer = null;
      super.paint(context, offset);
    }
  }

  @override
  void dispose() {
    _clipRectLayer.layer = null;
    super.dispose();
  }

  @override
  void visitChildren(RenderObjectVisitor visitor) {
    RenderBox? child = firstChild;
    while (child != null) {
      visitor(child);
      final _TheaterParentData childParentData = child.parentData! as _TheaterParentData;
      childParentData.visitOverlayPortalChildrenOnOverlayEntry(visitor);
      child = childParentData.nextSibling;
    }
  }

  @override
  void visitChildrenForSemantics(RenderObjectVisitor visitor) {
    RenderBox? child = _firstOnstageChild;
    while (child != null) {
      visitor(child);
      final _TheaterParentData childParentData = child.parentData! as _TheaterParentData;
      child = childParentData.nextSibling;
    }
  }

  @override
  Rect? describeApproximatePaintClip(RenderObject child) {
    switch (clipBehavior) {
      case Clip.none:
        return null;
      case Clip.hardEdge:
      case Clip.antiAlias:
      case Clip.antiAliasWithSaveLayer:
        return Offset.zero & size;
    }
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties.add(IntProperty('skipCount', skipCount));
    properties.add(EnumProperty<TextDirection>('textDirection', textDirection));
  }

  @override
  List<DiagnosticsNode> debugDescribeChildren() {
    final List<DiagnosticsNode> offstageChildren = <DiagnosticsNode>[];
    final List<DiagnosticsNode> onstageChildren = <DiagnosticsNode>[];

    int count = 1;
    bool onstage = false;
    RenderBox? child = firstChild;
    final RenderBox? firstOnstageChild = _firstOnstageChild;
    while (child != null) {
      final _TheaterParentData childParentData = child.parentData! as _TheaterParentData;
      if (child == firstOnstageChild) {
        onstage = true;
        count = 1;
      }

      if (onstage) {
        onstageChildren.add(child.toDiagnosticsNode(name: 'onstage $count'));
      } else {
        offstageChildren.add(
          child.toDiagnosticsNode(name: 'offstage $count', style: DiagnosticsTreeStyle.offstage),
        );
      }

      int subcount = 1;
      childParentData.visitOverlayPortalChildrenOnOverlayEntry((RenderObject renderObject) {
        final RenderBox child = renderObject as RenderBox;
        if (onstage) {
          onstageChildren.add(child.toDiagnosticsNode(name: 'onstage $count - $subcount'));
        } else {
          offstageChildren.add(
            child.toDiagnosticsNode(
              name: 'offstage $count - $subcount',
              style: DiagnosticsTreeStyle.offstage,
            ),
          );
        }
        subcount += 1;
      });

      child = childParentData.nextSibling;
      count += 1;
    }

    return <DiagnosticsNode>[
      ...onstageChildren,
      if (offstageChildren.isNotEmpty)
        ...offstageChildren
      else
        DiagnosticsNode.message('no offstage children', style: DiagnosticsTreeStyle.offstage),
    ];
  }
}

// * OverlayPortal Implementation
//  OverlayPortal is inspired by the
//  [flutter_portal](https://pub.dev/packages/flutter_portal) package.
//
// ** RenderObject hierarchy
// The widget works by inserting its overlay child's render subtree directly
// under [Overlay]'s render object (_RenderTheater).
// https://user-images.githubusercontent.com/31859944/171971838-62ed3975-4b5d-4733-a9c9-f79e263b8fcc.jpg
//
// To ensure the overlay child render subtree does not do layout twice, the
// subtree must only perform layout after both its _RenderTheater and the
// [OverlayPortal]'s render object (_RenderLayoutSurrogateProxyBox) have
// finished layout. This is handled by _RenderDeferredLayoutBox.
//
// ** Z-Index of an overlay child
// [_OverlayEntryLocation] is a (currently private) interface that allows an
// [OverlayPortal] to insert its overlay child into a specific [Overlay], as
// well as specifying the paint order between the overlay child and other
// children of the _RenderTheater.
//
// Since [OverlayPortal] is only allowed to target ancestor [Overlay]s
// (_RenderTheater must finish doing layout before _RenderDeferredLayoutBox),
// the _RenderTheater should typically be acquired using an [InheritedWidget]
// (currently, _RenderTheaterMarker) in case the [OverlayPortal] gets
// reparented.

/// A class to show, hide and bring to top an [OverlayPortal]'s overlay child
/// in the target [Overlay].
///
/// A [OverlayPortalController] can only be given to at most one [OverlayPortal]
/// at a time. When an [OverlayPortalController] is moved from one
/// [OverlayPortal] to another, its [isShowing] state does not carry over.
///
/// [OverlayPortalController.show] and [OverlayPortalController.hide] can be
/// called even before the controller is assigned to any [OverlayPortal], but
/// they typically should not be called while the widget tree is being rebuilt.
class OverlayPortalController {
  /// Creates an [OverlayPortalController], optionally with a String identifier
  /// `debugLabel`.
  OverlayPortalController({String? debugLabel}) : _debugLabel = debugLabel;

  _OverlayPortalState? _attachTarget;

  // A separate _zOrderIndex to allow `show()` or `hide()` to be called when the
  // controller is not yet attached. Once this controller is attached,
  // _attachTarget._zOrderIndex will be used as the source of truth, and this
  // variable will be set to null.
  int? _zOrderIndex;
  final String? _debugLabel;

  static int _wallTime =
      kIsWeb
          ? -9007199254740992 // -2^53
          : -1 << 63;

  // Returns a unique and monotonically increasing timestamp that represents
  // now.
  //
  // The value this method returns increments after each call.
  int _now() {
    final int now = _wallTime += 1;
    assert(_zOrderIndex == null || _zOrderIndex! < now);
    assert(_attachTarget?._zOrderIndex == null || _attachTarget!._zOrderIndex! < now);
    return now;
  }

  /// Show the overlay child of the [OverlayPortal] this controller is attached
  /// to, at the top of the target [Overlay].
  ///
  /// When there are more than one [OverlayPortal]s that target the same
  /// [Overlay], the overlay child of the last [OverlayPortal] to have called
  /// [show] appears at the top level, unobstructed.
  ///
  /// If [isShowing] is already true, calling this method brings the overlay
  /// child it controls to the top.
  ///
  /// This method should typically not be called while the widget tree is being
  /// rebuilt.
  void show() {
    final _OverlayPortalState? state = _attachTarget;
    if (state != null) {
      state.show(_now());
    } else {
      _zOrderIndex = _now();
    }
  }

  /// Hide the [OverlayPortal]'s overlay child.
  ///
  /// Once hidden, the overlay child will be removed from the widget tree the
  /// next time the widget tree rebuilds, and stateful widgets in the overlay
  /// child may lose states as a result.
  ///
  /// This method should typically not be called while the widget tree is being
  /// rebuilt.
  void hide() {
    final _OverlayPortalState? state = _attachTarget;
    if (state != null) {
      state.hide();
    } else {
      assert(_zOrderIndex != null);
      _zOrderIndex = null;
    }
  }

  /// Whether the associated [OverlayPortal] should build and show its overlay
  /// child, using its `overlayChildBuilder`.
  bool get isShowing {
    final _OverlayPortalState? state = _attachTarget;
    return state != null ? state._zOrderIndex != null : _zOrderIndex != null;
  }

  /// Convenience method for toggling the current [isShowing] status.
  ///
  /// This method should typically not be called while the widget tree is being
  /// rebuilt.
  void toggle() => isShowing ? hide() : show();

  @override
  String toString() {
    final String? debugLabel = _debugLabel;
    final String label = debugLabel == null ? '' : '($debugLabel)';
    final String isDetached = _attachTarget != null ? '' : ' DETACHED';
    return '${objectRuntimeType(this, 'OverlayPortalController')}$label$isDetached';
  }
}

/// A widget that renders its overlay child on an [Overlay].
///
/// The overlay child is initially hidden until [OverlayPortalController.show]
/// is called on the associated [controller]. The [OverlayPortal] uses
/// [overlayChildBuilder] to build its overlay child and renders it on the
/// specified [Overlay] as if it was inserted using an [OverlayEntry], while it
/// can depend on the same set of [InheritedWidget]s (such as [Theme]) that this
/// widget can depend on.
///
/// This widget requires an [Overlay] ancestor in the widget tree when its
/// overlay child is showing. The overlay child is rendered by the [Overlay]
/// ancestor, not by the widget itself. This allows the overlay child to float
/// above other widgets, independent of its position in the widget tree.
///
/// When [OverlayPortalController.hide] is called, the widget built using
/// [overlayChildBuilder] will be removed from the widget tree the next time the
/// widget rebuilds. Stateful descendants in the overlay child subtree may lose
/// states as a result.
///
/// {@tool dartpad}
/// This example uses an [OverlayPortal] to build a tooltip that becomes visible
/// when the user taps on the [child] widget. There's a [DefaultTextStyle] above
/// the [OverlayPortal] controlling the [TextStyle] of both the [child] widget
/// and the widget [overlayChildBuilder] builds, which isn't otherwise doable if
/// the tooltip was added as an [OverlayEntry].
///
/// ** See code in examples/api/lib/widgets/overlay/overlay_portal.0.dart **
/// {@end-tool}
///
/// ### Paint Order
///
/// In an [Overlay], an overlay child is painted after the [OverlayEntry]
/// associated with its [OverlayPortal] (that is, the [OverlayEntry] closest to
/// the [OverlayPortal] in the widget tree, which usually represents the
/// enclosing [Route]), and before the next [OverlayEntry].
///
/// When an [OverlayEntry] has multiple associated [OverlayPortal]s, the paint
/// order between their overlay children is the order in which
/// [OverlayPortalController.show] was called. The last [OverlayPortal] to have
/// called `show` gets to paint its overlay child in the foreground.
///
/// ### Semantics
///
/// The semantics subtree generated by the overlay child is considered attached
/// to [OverlayPortal] instead of the target [Overlay]. An [OverlayPortal]'s
/// semantics subtree can be dropped from the semantics tree due to invisibility
/// while the overlay child is still visible (for example, when the
/// [OverlayPortal] is completely invisible in a [ListView] but kept alive by
/// a [KeepAlive] widget). When this happens the semantics subtree generated by
/// the overlay child is also dropped, even if the overlay child is still visible
/// on screen.
///
/// {@template flutter.widgets.overlayPortalVsOverlayEntry}
/// ### Differences between [OverlayPortal] and [OverlayEntry]
///
/// The main difference between [OverlayEntry] and [OverlayPortal] is that
/// [OverlayEntry] builds its widget subtree as a child of the target [Overlay],
/// while [OverlayPortal] uses [OverlayPortal.overlayChildBuilder] to build a
/// child widget of itself. This allows [OverlayPortal]'s overlay child to depend
/// on the same set of [InheritedWidget]s as [OverlayPortal], and it's also
/// guaranteed that the overlay child will not outlive its [OverlayPortal].
///
/// On the other hand, [OverlayPortal]'s implementation is more complex. For
/// instance, it does a bit more work than a regular widget during global key
/// reparenting. If the content to be shown on the [Overlay] doesn't benefit
/// from being a part of [OverlayPortal]'s subtree, consider using an
/// [OverlayEntry] instead.
/// {@endtemplate}
///
/// See also:
///
///  * [OverlayEntry], an alternative API for inserting widgets into an
///    [Overlay].
///  * [Positioned], which can be used to size and position the overlay child in
///    relation to the target [Overlay]'s boundaries.
///  * [CompositedTransformFollower], which can be used to position the overlay
///    child in relation to the linked [CompositedTransformTarget] widget.
class OverlayPortal extends StatefulWidget {
  /// Creates an [OverlayPortal] that renders the widget [overlayChildBuilder]
  /// builds on the closest [Overlay] when [OverlayPortalController.show] is
  /// called.
  const OverlayPortal({
    super.key,
    required this.controller,
    required this.overlayChildBuilder,
    this.child,
  }) : _targetRootOverlay = false;

  /// Creates an [OverlayPortal] that renders the widget [overlayChildBuilder]
  /// builds on the root [Overlay] when [OverlayPortalController.show] is
  /// called.
  const OverlayPortal.targetsRootOverlay({
    super.key,
    required this.controller,
    required this.overlayChildBuilder,
    this.child,
  }) : _targetRootOverlay = true;

  /// The controller to show, hide and bring to top the overlay child.
  final OverlayPortalController controller;

  /// A [WidgetBuilder] used to build a widget below this widget in the tree,
  /// that renders on the closest [Overlay].
  ///
  /// The said widget will only be built and shown in the closest [Overlay] once
  /// [OverlayPortalController.show] is called on the associated [controller].
  /// It will be painted in front of the [OverlayEntry] closest to this widget
  /// in the widget tree (which is usually the enclosing [Route]).
  ///
  /// The built overlay child widget is inserted below this widget in the widget
  /// tree, allowing it to depend on [InheritedWidget]s above it, and be
  /// notified when the [InheritedWidget]s change.
  ///
  /// Unlike [child], the built overlay child can visually extend outside the
  /// bounds of this widget without being clipped, and receive hit-test events
  /// outside of this widget's bounds, as long as it does not extend outside of
  /// the [Overlay] on which it is rendered.
  final WidgetBuilder overlayChildBuilder;

  /// A widget below this widget in the tree.
  final Widget? child;

  final bool _targetRootOverlay;

  @override
  State<OverlayPortal> createState() => _OverlayPortalState();
}

class _OverlayPortalState extends State<OverlayPortal> {
  int? _zOrderIndex;
  // The location of the overlay child within the overlay. This object will be
  // used as the slot of the overlay child widget.
  //
  // The developer must call `show` to reveal the overlay so we can get a unique
  // timestamp of the user interaction for determining the z-index of the
  // overlay child in the overlay.
  //
  // Avoid invalidating the cache if possible, since the framework uses `==` to
  // compare slots, and _OverlayEntryLocation can't override that operator since
  // it's mutable. Changing slots can be relatively slow.
  bool _childModelMayHaveChanged = true;
  _OverlayEntryLocation? _locationCache;
  static bool _isTheSameLocation(_OverlayEntryLocation locationCache, _RenderTheaterMarker marker) {
    return locationCache._childModel == marker.overlayEntryWidgetState &&
        locationCache._theater == marker.theater;
  }

  _OverlayEntryLocation _getLocation(int zOrderIndex, bool targetRootOverlay) {
    final _OverlayEntryLocation? cachedLocation = _locationCache;
    late final _RenderTheaterMarker marker = _RenderTheaterMarker.of(
      context,
      targetRootOverlay: targetRootOverlay,
    );
    final bool isCacheValid =
        cachedLocation != null &&
        (!_childModelMayHaveChanged || _isTheSameLocation(cachedLocation, marker));
    _childModelMayHaveChanged = false;
    if (isCacheValid) {
      assert(cachedLocation._zOrderIndex == zOrderIndex);
      assert(cachedLocation._debugIsLocationValid());
      return cachedLocation;
    }
    // Otherwise invalidate the cache and create a new location.
    cachedLocation?._debugMarkLocationInvalid();
    final _OverlayEntryLocation newLocation = _OverlayEntryLocation(
      zOrderIndex,
      marker.overlayEntryWidgetState,
      marker.theater,
    );
    assert(newLocation._zOrderIndex == zOrderIndex);
    return _locationCache = newLocation;
  }

  @override
  void initState() {
    super.initState();
    _setupController(widget.controller);
  }

  void _setupController(OverlayPortalController controller) {
    assert(
      controller._attachTarget == null || controller._attachTarget == this,
      'Failed to attach $controller to $this. It is already attached to ${controller._attachTarget}.',
    );
    final int? controllerZOrderIndex = controller._zOrderIndex;
    final int? zOrderIndex = _zOrderIndex;
    if (zOrderIndex == null ||
        (controllerZOrderIndex != null && controllerZOrderIndex > zOrderIndex)) {
      _zOrderIndex = controllerZOrderIndex;
    }
    controller._zOrderIndex = null;
    controller._attachTarget = this;
  }

  @override
  void didChangeDependencies() {
    super.didChangeDependencies();
    _childModelMayHaveChanged = true;
  }

  @override
  void didUpdateWidget(OverlayPortal oldWidget) {
    super.didUpdateWidget(oldWidget);
    _childModelMayHaveChanged =
        _childModelMayHaveChanged || oldWidget._targetRootOverlay != widget._targetRootOverlay;
    if (oldWidget.controller != widget.controller) {
      oldWidget.controller._attachTarget = null;
      _setupController(widget.controller);
    }
  }

  @override
  void dispose() {
    assert(widget.controller._attachTarget == this);
    widget.controller._attachTarget = null;
    _locationCache?._debugMarkLocationInvalid();
    _locationCache = null;
    super.dispose();
  }

  void show(int zOrderIndex) {
    assert(
      SchedulerBinding.instance.schedulerPhase != SchedulerPhase.persistentCallbacks,
      '${widget.controller.runtimeType}.show() should not be called during build.',
    );
    setState(() {
      _zOrderIndex = zOrderIndex;
    });
    _locationCache?._debugMarkLocationInvalid();
    _locationCache = null;
  }

  void hide() {
    assert(SchedulerBinding.instance.schedulerPhase != SchedulerPhase.persistentCallbacks);
    setState(() {
      _zOrderIndex = null;
    });
    _locationCache?._debugMarkLocationInvalid();
    _locationCache = null;
  }

  @override
  Widget build(BuildContext context) {
    final int? zOrderIndex = _zOrderIndex;
    if (zOrderIndex == null) {
      return _OverlayPortal(overlayLocation: null, overlayChild: null, child: widget.child);
    }
    return _OverlayPortal(
      overlayLocation: _getLocation(zOrderIndex, widget._targetRootOverlay),
      overlayChild: _DeferredLayout(child: Builder(builder: widget.overlayChildBuilder)),
      child: widget.child,
    );
  }
}

/// A location in an [Overlay].
///
/// An [_OverlayEntryLocation] determines the [Overlay] the associated
/// [OverlayPortal] should put its overlay child onto, as well as the overlay
/// child's paint order in relation to other contents painted on the [Overlay].
//
// An _OverlayEntryLocation is a cursor pointing to a location in a particular
// Overlay's child model, and provides methods to insert/remove/move a
// _RenderDeferredLayoutBox to/from its target _theater.
//
// The occupant (a `RenderBox`) will be painted above the associated
// [OverlayEntry], but below the [OverlayEntry] above that [OverlayEntry].
//
// Additionally, `_activate` and `_deactivate` are called when the overlay
// child's `_OverlayPortalElement` activates/deactivates (for instance, during
// global key reparenting).
// `_OverlayPortalElement` removes its overlay child's render object from the
// target `_RenderTheater` when it deactivates and puts it back on `activated`.
// These 2 methods can be used to "hide" a child in the child model without
// removing it, when the child is expensive/difficult to re-insert at the
// correct location on `activated`.
//
// ### Equality
//
// An `_OverlayEntryLocation` will be used as an Element's slot. These 3 parts
// uniquely identify a place in an overlay's child model:
// - _theater
// - _childModel (the OverlayEntry)
// - _zOrderIndex
//
// Since it can't implement operator== (it's mutable), the same `_OverlayEntryLocation`
// instance must not be used to represent more than one locations.
final class _OverlayEntryLocation extends LinkedListEntry<_OverlayEntryLocation> {
  _OverlayEntryLocation(this._zOrderIndex, this._childModel, this._theater);

  final int _zOrderIndex;
  final _OverlayEntryWidgetState _childModel;
  final _RenderTheater _theater;

  _RenderDeferredLayoutBox? _overlayChildRenderBox;
  void _addToChildModel(_RenderDeferredLayoutBox child) {
    assert(
      _overlayChildRenderBox == null,
      'Failed to add $child. This location ($this) is already occupied by $_overlayChildRenderBox.',
    );
    _overlayChildRenderBox = child;
    _childModel._add(this);
    _theater.markNeedsPaint();
    _theater.markNeedsCompositingBitsUpdate();
    _theater.markNeedsSemanticsUpdate();
  }

  void _removeFromChildModel(_RenderDeferredLayoutBox child) {
    assert(child == _overlayChildRenderBox);
    _overlayChildRenderBox = null;
    assert(_childModel._sortedTheaterSiblings?.contains(this) ?? false);
    _childModel._remove(this);
    _theater.markNeedsPaint();
    _theater.markNeedsCompositingBitsUpdate();
    _theater.markNeedsSemanticsUpdate();
  }

  void _addChild(_RenderDeferredLayoutBox child) {
    assert(_debugIsLocationValid());
    _addToChildModel(child);
    _theater._addDeferredChild(child);
    assert(child.parent == _theater);
  }

  void _removeChild(_RenderDeferredLayoutBox child) {
    // This call is allowed even when this location is disposed.
    _removeFromChildModel(child);
    _theater._removeDeferredChild(child);
    assert(child.parent == null);
  }

  void _moveChild(_RenderDeferredLayoutBox child, _OverlayEntryLocation fromLocation) {
    assert(fromLocation != this);
    assert(_debugIsLocationValid());
    final _RenderTheater fromTheater = fromLocation._theater;
    final _OverlayEntryWidgetState fromModel = fromLocation._childModel;

    if (fromTheater != _theater) {
      fromTheater._removeDeferredChild(child);
      _theater._addDeferredChild(child);
    }

    if (fromModel != _childModel || fromLocation._zOrderIndex != _zOrderIndex) {
      fromLocation._removeFromChildModel(child);
      _addToChildModel(child);
    }
  }

  void _activate(_RenderDeferredLayoutBox child) {
    // This call is allowed even when this location is invalidated.
    // See _OverlayPortalElement.activate.
    assert(_overlayChildRenderBox == null, '$_overlayChildRenderBox');
    _theater._addDeferredChild(child);
    _overlayChildRenderBox = child;
  }

  void _deactivate(_RenderDeferredLayoutBox child) {
    // This call is allowed even when this location is invalidated.
    _theater._removeDeferredChild(child);
    _overlayChildRenderBox = null;
  }

  // Throws a StateError if this location is already invalidated and shouldn't
  // be used as an OverlayPortal slot. Must be used in asserts.
  //
  // Generally, `assert(_debugIsLocationValid())` should be used to prevent
  // invalid accesses to an invalid `_OverlayEntryLocation` object. Exceptions
  // to this rule are _removeChild, _deactivate, which will be called when the
  // OverlayPortal is being removed from the widget tree and may use the
  // location information to perform cleanup tasks.
  //
  // Another exception is the _activate method which is called by
  // _OverlayPortalElement.activate. See the comment in _OverlayPortalElement.activate.
  bool _debugIsLocationValid() {
    if (_debugMarkLocationInvalidStackTrace == null) {
      return true;
    }
    throw StateError(
      '$this is already disposed. Stack trace: $_debugMarkLocationInvalidStackTrace',
    );
  }

  // The StackTrace of the first _debugMarkLocationInvalid call. It's only for
  // debugging purposes and the StackTrace will only be captured in debug builds.
  //
  // The effect of this method is not reversible. Once marked invalid, this
  // object can't be marked as valid again.
  StackTrace? _debugMarkLocationInvalidStackTrace;
  @mustCallSuper
  void _debugMarkLocationInvalid() {
    assert(_debugIsLocationValid());
    assert(() {
      _debugMarkLocationInvalidStackTrace = StackTrace.current;
      return true;
    }());
  }

  @override
  String toString() =>
      '${objectRuntimeType(this, '_OverlayEntryLocation')}[${shortHash(this)}] ${_debugMarkLocationInvalidStackTrace != null ? "(INVALID)" : ""}';
}

class _RenderTheaterMarker extends InheritedWidget {
  const _RenderTheaterMarker({
    required this.theater,
    required this.overlayEntryWidgetState,
    required super.child,
  });

  final _RenderTheater theater;
  final _OverlayEntryWidgetState overlayEntryWidgetState;

  @override
  bool updateShouldNotify(_RenderTheaterMarker oldWidget) {
    return oldWidget.theater != theater ||
        oldWidget.overlayEntryWidgetState != overlayEntryWidgetState;
  }

  static _RenderTheaterMarker of(BuildContext context, {bool targetRootOverlay = false}) {
    final _RenderTheaterMarker? marker;
    if (targetRootOverlay) {
      final InheritedElement? ancestor = _rootRenderTheaterMarkerOf(
        context.getElementForInheritedWidgetOfExactType<_RenderTheaterMarker>(),
      );
      assert(ancestor == null || ancestor.widget is _RenderTheaterMarker);
      marker =
          ancestor != null
              ? context.dependOnInheritedElement(ancestor) as _RenderTheaterMarker?
              : null;
    } else {
      marker = context.dependOnInheritedWidgetOfExactType<_RenderTheaterMarker>();
    }
    if (marker != null) {
      return marker;
    }
    throw FlutterError.fromParts(<DiagnosticsNode>[
      ErrorSummary('No Overlay widget found.'),
      ErrorDescription(
        '${context.widget.runtimeType} widgets require an Overlay widget ancestor.\n'
        'An overlay lets widgets float on top of other widget children.',
      ),
      ErrorHint(
        'To introduce an Overlay widget, you can either directly '
        'include one, or use a widget that contains an Overlay itself, '
        'such as a Navigator, WidgetApp, MaterialApp, or CupertinoApp.',
      ),
      ...context.describeMissingAncestor(expectedAncestorType: Overlay),
    ]);
  }

  static InheritedElement? _rootRenderTheaterMarkerOf(InheritedElement? theaterMarkerElement) {
    assert(theaterMarkerElement == null || theaterMarkerElement.widget is _RenderTheaterMarker);
    if (theaterMarkerElement == null) {
      return null;
    }
    InheritedElement? ancestor;
    theaterMarkerElement.visitAncestorElements((Element element) {
      ancestor = element.getElementForInheritedWidgetOfExactType<_RenderTheaterMarker>();
      return false;
    });
    return ancestor == null ? theaterMarkerElement : _rootRenderTheaterMarkerOf(ancestor);
  }
}

class _OverlayPortal extends RenderObjectWidget {
  /// Creates a widget that renders the given [overlayChild] in the [Overlay]
  /// specified by `overlayLocation`.
  ///
  /// The `overlayLocation` parameter must not be null when [overlayChild] is not
  /// null.
  _OverlayPortal({required this.overlayLocation, required this.overlayChild, required this.child})
    : assert(overlayChild == null || overlayLocation != null),
      assert(overlayLocation == null || overlayLocation._debugIsLocationValid());

  final Widget? overlayChild;

  /// A widget below this widget in the tree.
  final Widget? child;

  final _OverlayEntryLocation? overlayLocation;

  @override
  RenderObjectElement createElement() => _OverlayPortalElement(this);

  @override
  RenderObject createRenderObject(BuildContext context) => _RenderLayoutSurrogateProxyBox();
}

class _OverlayPortalElement extends RenderObjectElement {
  _OverlayPortalElement(_OverlayPortal super.widget);

  @override
  _RenderLayoutSurrogateProxyBox get renderObject =>
      super.renderObject as _RenderLayoutSurrogateProxyBox;

  Element? _overlayChild;
  Element? _child;

  @override
  void mount(Element? parent, Object? newSlot) {
    super.mount(parent, newSlot);
    final _OverlayPortal widget = this.widget as _OverlayPortal;
    _child = updateChild(_child, widget.child, null);
    _overlayChild = updateChild(_overlayChild, widget.overlayChild, widget.overlayLocation);
  }

  @override
  void update(_OverlayPortal newWidget) {
    super.update(newWidget);
    _child = updateChild(_child, newWidget.child, null);
    _overlayChild = updateChild(_overlayChild, newWidget.overlayChild, newWidget.overlayLocation);
  }

  @override
  void forgetChild(Element child) {
    // The _overlayChild Element does not have a key because the _DeferredLayout
    // widget does not take a Key, so only the regular _child can be taken
    // during global key reparenting.
    assert(child == _child);
    _child = null;
    super.forgetChild(child);
  }

  @override
  void visitChildren(ElementVisitor visitor) {
    final Element? child = _child;
    final Element? overlayChild = _overlayChild;
    if (child != null) {
      visitor(child);
    }
    if (overlayChild != null) {
      visitor(overlayChild);
    }
  }

  @override
  void activate() {
    super.activate();
    final _RenderDeferredLayoutBox? box = _overlayChild?.renderObject as _RenderDeferredLayoutBox?;
    if (box != null) {
      assert(!box.attached);
      assert(renderObject._deferredLayoutChild == box);
      // updateChild has not been called at this point so the RenderTheater in
      // the overlay location could be detached. Adding children to a detached
      // RenderObject is still allowed however this isn't the most efficient.
      (_overlayChild!.slot! as _OverlayEntryLocation)._activate(box);
    }
  }

  @override
  void deactivate() {
    // Instead of just detaching the render objects, removing them from the
    // render subtree entirely. This is a workaround for the
    // !renderObject.attached assert in the `super.deactivate()` method.
    final _RenderDeferredLayoutBox? box = _overlayChild?.renderObject as _RenderDeferredLayoutBox?;
    if (box != null) {
      (_overlayChild!.slot! as _OverlayEntryLocation)._deactivate(box);
    }
    super.deactivate();
  }

  @override
  void insertRenderObjectChild(RenderBox child, _OverlayEntryLocation? slot) {
    assert(child.parent == null, "$child's parent is not null: ${child.parent}");
    if (slot != null) {
      renderObject._deferredLayoutChild = child as _RenderDeferredLayoutBox;
      slot._addChild(child);
      renderObject.markNeedsSemanticsUpdate();
    } else {
      renderObject.child = child;
    }
  }

  // The [_DeferredLayout] widget does not have a key so there will be no
  // reparenting between _overlayChild and _child, thus the non-null-typed slots.
  @override
  void moveRenderObjectChild(
    _RenderDeferredLayoutBox child,
    _OverlayEntryLocation oldSlot,
    _OverlayEntryLocation newSlot,
  ) {
    assert(newSlot._debugIsLocationValid());
    newSlot._moveChild(child, oldSlot);
    renderObject.markNeedsSemanticsUpdate();
  }

  @override
  void removeRenderObjectChild(RenderBox child, _OverlayEntryLocation? slot) {
    if (slot == null) {
      renderObject.child = null;
      return;
    }
    assert(renderObject._deferredLayoutChild == child);
    slot._removeChild(child as _RenderDeferredLayoutBox);
    renderObject._deferredLayoutChild = null;
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties.add(DiagnosticsProperty<Element>('child', _child, defaultValue: null));
    properties.add(DiagnosticsProperty<Element>('overlayChild', _overlayChild, defaultValue: null));
    properties.add(
      DiagnosticsProperty<Object>('overlayLocation', _overlayChild?.slot, defaultValue: null),
    );
  }
}

class _DeferredLayout extends SingleChildRenderObjectWidget {
  const _DeferredLayout({
    // This widget must not be given a key: we currently do not support
    // reparenting between the overlayChild and child.
    required Widget child,
  }) : super(child: child);

  _RenderLayoutSurrogateProxyBox getLayoutParent(BuildContext context) {
    return context.findAncestorRenderObjectOfType<_RenderLayoutSurrogateProxyBox>()!;
  }

  @override
  _RenderDeferredLayoutBox createRenderObject(BuildContext context) {
    final _RenderLayoutSurrogateProxyBox parent = getLayoutParent(context);
    final _RenderDeferredLayoutBox renderObject = _RenderDeferredLayoutBox(parent);
    parent._deferredLayoutChild = renderObject;
    return renderObject;
  }

  @override
  void updateRenderObject(BuildContext context, _RenderDeferredLayoutBox renderObject) {
    assert(renderObject._layoutSurrogate == getLayoutParent(context));
    assert(getLayoutParent(context)._deferredLayoutChild == renderObject);
  }
}

// A `RenderProxyBox` that defers its layout until its `_layoutSurrogate` (which
// is not necessarily an ancestor of this RenderBox, but shares at least one
// `_RenderTheater` ancestor with this RenderBox) is laid out.
//
// This `RenderObject` must be a child of a `_RenderTheater`. It guarantees that:
//
// 1. It's a relayout boundary, so calling `markNeedsLayout` on it never dirties
//    its `_RenderTheater`.
//
// 2. Its `layout` implementation is overridden such that `performLayout` does
//    not do anything when its called from `layout`, preventing the parent
//    `_RenderTheater` from laying out this subtree prematurely (but this
//    `RenderObject` may still be resized). Instead, `markNeedsLayout` will be
//    called from within `layout` to schedule a layout update for this relayout
//    boundary when needed.
//
// 3. When invoked from `PipelineOwner.flushLayout`, or
//    `_layoutSurrogate.performLayout`, this `RenderObject` behaves like an
//    `Overlay` that has only one entry.
final class _RenderDeferredLayoutBox extends RenderProxyBox
    with _RenderTheaterMixin, LinkedListEntry<_RenderDeferredLayoutBox> {
  _RenderDeferredLayoutBox(this._layoutSurrogate);

  StackParentData get stackParentData => parentData! as StackParentData;
  final _RenderLayoutSurrogateProxyBox _layoutSurrogate;

  @override
  Iterable<RenderBox> _childrenInPaintOrder() {
    final RenderBox? child = this.child;
    return child == null
        ? const Iterable<RenderBox>.empty()
        : Iterable<RenderBox>.generate(1, (int i) => child);
  }

  @override
  Iterable<RenderBox> _childrenInHitTestOrder() => _childrenInPaintOrder();

  @override
  _RenderTheater get theater {
    final RenderObject? parent = this.parent;
    return parent is _RenderTheater
        ? parent
        : throw FlutterError('$parent of $this is not a _RenderTheater');
  }

  @override
  void redepthChildren() {
    _layoutSurrogate.redepthChild(this);
    super.redepthChildren();
  }

  @override
  bool get sizedByParent => true;

  bool _needsLayout = true;
  @override
  void markNeedsLayout() {
    _needsLayout = true;
    super.markNeedsLayout();
  }

  @override
  RenderObject? get semanticsParent => _layoutSurrogate;

  @override
  double? computeDryBaseline(BoxConstraints constraints, TextBaseline baseline) {
    final RenderBox? child = this.child;
    if (child == null) {
      return null;
    }
    return _RenderTheaterMixin.baselineForChild(
      child,
      constraints.biggest,
      constraints,
      theater._resolvedAlignment,
      baseline,
    );
  }

  @override
  RenderObject? get debugLayoutParent => _layoutSurrogate;

  void layoutByLayoutSurrogate() {
    assert(!_theaterDoingThisLayout);
    final _RenderTheater? theater = parent as _RenderTheater?;
    if (theater == null || !attached) {
      assert(false, '$this is not attached to parent');
      return;
    }
    if (theater._layingOutSizeDeterminingChild) {
      theater.invokeLayoutCallback((BoxConstraints constraints) {
        markNeedsLayout();
      });
    } else {
      final BoxConstraints theaterConstraints = theater.constraints;
      final Size boxSize =
          theaterConstraints.biggest.isFinite
              ? theaterConstraints.biggest
              // Accessing the theater's size is only unsafe if it is laying out the
              // size-determining child.
              : theater.size;
      super.layout(BoxConstraints.tight(boxSize));
    }
  }

  bool _theaterDoingThisLayout = false;
  @override
  void layout(Constraints constraints, {bool parentUsesSize = false}) {
    assert(_needsLayout == debugNeedsLayout);
    // Only _RenderTheater calls this implementation.
    assert(parent != null);
    final bool scheduleDeferredLayout = _needsLayout || this.constraints != constraints;
    assert(!_theaterDoingThisLayout);
    _theaterDoingThisLayout = true;
    super.layout(constraints, parentUsesSize: parentUsesSize);
    assert(_theaterDoingThisLayout);
    _theaterDoingThisLayout = false;
    _needsLayout = false;
    assert(!debugNeedsLayout);
    if (scheduleDeferredLayout) {
      final _RenderTheater parent = this.parent! as _RenderTheater;
      // Invoking markNeedsLayout as a layout callback allows this node to be
      // merged back to the `PipelineOwner`'s dirty list in the right order, if
      // it's not already dirty. Otherwise this may cause some dirty descendants
      // to performLayout a second time.
      parent.invokeLayoutCallback((BoxConstraints constraints) {
        markNeedsLayout();
      });
    }
  }

  @override
  void performResize() {
    size = constraints.biggest;
  }

  bool _debugMutationsLocked = false;
  @override
  void performLayout() {
    assert(!_debugMutationsLocked);
    if (_theaterDoingThisLayout) {
      _needsLayout = false;
      return;
    }
    assert(() {
      _debugMutationsLocked = true;
      return true;
    }());
    // This method is directly being invoked from `PipelineOwner.flushLayout`,
    // or from `_layoutSurrogate`'s performLayout.
    assert(parent != null);
    final RenderBox? child = this.child;
    if (child == null) {
      _needsLayout = false;
      return;
    }
    assert(constraints.isTight);
    layoutChild(child, constraints);
    assert(() {
      _debugMutationsLocked = false;
      return true;
    }());
    _needsLayout = false;
  }

  @override
  void applyPaintTransform(RenderBox child, Matrix4 transform) {
    final BoxParentData childParentData = child.parentData! as BoxParentData;
    final Offset offset = childParentData.offset;
    transform.translate(offset.dx, offset.dy);
  }
}

// A RenderProxyBox that makes sure its `deferredLayoutChild` has a greater
// depth than itself.
class _RenderLayoutSurrogateProxyBox extends RenderProxyBox {
  _RenderDeferredLayoutBox? _deferredLayoutChild;

  @override
  void redepthChildren() {
    super.redepthChildren();
    final _RenderDeferredLayoutBox? child = _deferredLayoutChild;
    // If child is not attached, this method will be invoked by child's real
    // parent when it's attached.
    if (child != null && child.attached) {
      assert(child.attached);
      redepthChild(child);
    }
  }

  @override
  void performLayout() {
    super.performLayout();
    // Try to layout `_deferredLayoutChild` here now that its configuration
    // and constraints are up-to-date. Additionally, during the very first
    // layout, this makes sure that _deferredLayoutChild is reachable via tree
    // walk.
    _deferredLayoutChild?.layoutByLayoutSurrogate();
  }

  @override
  void visitChildrenForSemantics(RenderObjectVisitor visitor) {
    super.visitChildrenForSemantics(visitor);
    final _RenderDeferredLayoutBox? deferredChild = _deferredLayoutChild;
    if (deferredChild != null) {
      visitor(deferredChild);
    }
  }
}


Instructions for the chapter (Generate content in English unless specified otherwise):
- Start with a clear heading (e.g., `# Chapter 5: OverlayPortalController
`). Use the provided concept name.

- If this is not the first chapter, begin with a brief transition from the previous chapter, referencing it with a proper Markdown link using its name.

- Begin with a high-level motivation explaining what problem this abstraction solves. Start with a central use case as a concrete example. The whole chapter should guide the reader to understand how to solve this use case. Make it very minimal and friendly to beginners.

- If the abstraction is complex, break it down into key concepts. Explain each concept one-by-one in a very beginner-friendly way.

- Explain how to use this abstraction to solve the use case. Give example inputs and outputs for code snippets (if the output isn't values, describe at a high level what will happen).

- Each code block should be BELOW 10 lines! If longer code blocks are needed, break them down into smaller pieces and walk through them one-by-one. Aggresively simplify the code to make it minimal. Use comments to skip non-important implementation details. Each code block should have a beginner friendly explanation right after it.

- Describe the internal implementation to help understand what's under the hood. First provide a non-code or code-light walkthrough on what happens step-by-step when the abstraction is called. It's recommended to use a simple sequenceDiagram with a dummy example - keep it minimal with at most 5 participants to ensure clarity. If participant name has space, use: `participant QP as Query Processing`. .

- Then dive deeper into code for the internal implementation with references to files. Provide example code blocks, but make them similarly simple and beginner-friendly. Explain.

- IMPORTANT: When you need to refer to other core abstractions covered in other chapters, ALWAYS use proper Markdown links like this: [Chapter Title](filename.md). Use the Complete Tutorial Structure above to find the correct filename and the chapter title. Translate the surrounding text.

- Use mermaid diagrams to illustrate complex concepts (```mermaid``` format). .

- Heavily use analogies and examples throughout to help beginners understand.

- End the chapter with a brief conclusion that summarizes what was learned and provides a transition to the next chapter. If there is a next chapter, use a proper Markdown link: [Next Chapter Title](next_chapter_filename).

- Ensure the tone is welcoming and easy for a newcomer to understand.

- Output *only* the Markdown content for this chapter.

Now, directly provide a super beginner-friendly Markdown output (DON'T need ```markdown``` tags):

2025-05-22 23:58:24,250 - INFO - RESPONSE: # Chapter 5: OverlayPortalController

Welcome to Chapter 5! In our [previous chapter](04_overlayportal_.md), we were introduced to `OverlayPortal`, a special widget that lets you place a child widget onto the global [Overlay](01_overlay_.md) while still feeling connected to the `OverlayPortal`'s spot in the widget tree. We set up the `OverlayPortal` with an `overlayChildBuilder` to define our context menu widget, but we couldn't make it actually appear yet.

To control when an `OverlayPortal` shows or hides its overlay child, we need a remote control! That remote control is the **`OverlayPortalController`**.

Think of the `OverlayPortalController` as a dedicated switch for a single `OverlayPortal`. You give the controller to the `OverlayPortal`, and then you use the methods on that controller to tell the `OverlayPortal` what to do.

Our goal is still to show a small context menu right next to a button when it's tapped. The `OverlayPortalController` is the key piece that lets us trigger this action from the button's `onPressed` callback.

### What is OverlayPortalController?

An `OverlayPortalController` is a simple object that provides methods to manage the visibility and paint order of the `OverlayPortal`'s overlay child. It has three main actions:

*   **`show()`**: Makes the overlay child widget built by the `OverlayPortal`'s `overlayChildBuilder` appear on the [Overlay](01_overlay_.md). If it's already showing, calling `show()` again brings it to the very top of the overlay stack (above other things controlled by different OverlayPortals).
*   **`hide()`**: Hides the overlay child widget. It will be removed from the [Overlay](01_overlay_.md).
*   **`toggle()`**: Switches the state. If it's hidden, it shows it. If it's showing, it hides it.

It also has a property:

*   **`isShowing`**: A boolean (`true` or `false`) that tells you if the overlay child is currently visible on the [Overlay](01_overlay_.md) via this controller.

### Creating and Using an OverlayPortalController

You need to create an instance of `OverlayPortalController`. Since the controller holds the state of whether the overlay is showing or not, it should typically live in a `State` object.

```dart
// Inside a StatefulWidget's State class:
class _MyWidgetState extends State<MyWidget> {
  // Create the controller
  final OverlayPortalController _contextMenuController = OverlayPortalController();

  // Remember to dispose of the controller when the State is disposed
  @override
  void dispose() {
    _contextMenuController.dispose(); // Necessary cleanup!
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    // ... button and OverlayPortal will go here ...
    return Scaffold( // Example wrapper
      appBar: AppBar(title: const Text('Overlay Portal Example')),
      body: Center( // Center the button
        child: OverlayPortal(
          // Provide the controller to the OverlayPortal!
          controller: _contextMenuController,
          overlayChildBuilder: (BuildContext context) {
            // This is the widget that will show on the Overlay
            // We'll refine positioning later, for now a placeholder:
            Offset buttonPosition = const Offset(100, 100); // Placeholder
            return Positioned(
              top: buttonPosition.dy,
              left: buttonPosition.dx,
              child: Material(
                elevation: 4.0,
                child: Container(
                  padding: const EdgeInsets.all(8.0),
                  color: Colors.yellow[100],
                  child: const Text('Context Menu!'),
                ),
              ),
            );
          },
          // The button we tap to show/hide the menu
          child: ElevatedButton(
            onPressed: () {
              // Use the controller to toggle the menu!
              _contextMenuController.toggle();
            },
            child: const Text('Show/Hide Menu'),
          ),
        ),
      ),
    );
  }
}
```

In this code snippet:

1.  We declare a `final OverlayPortalController _contextMenuController` within our `_MyWidgetState`. It's `final` because we create the controller once.
2.  **Crucially, we call `_contextMenuController.dispose()` in the `dispose()` method of the state.** This is important cleanup to release resources when the widget and its state are removed.
3.  We pass this `_contextMenuController` to the `OverlayPortal` widget using the `controller:` property. This establishes the link between the remote control and the device.
4.  Inside the `onPressed` callback of the `ElevatedButton` (which is the `child` of the `OverlayPortal`), we simply call `_contextMenuController.toggle()`.

Now, when you tap the button, the `toggle()` method on the controller is called. The `OverlayPortal` linked to this controller sees this, and if it wasn't showing, it triggers the creation and display of the widget from its `overlayChildBuilder` onto the [Overlay](01_overlay_.md)! Tapping again calls `toggle()` again, sees it's showing, and calls `hide()`, removing the widget.

### Positioning the Overlay Child

In the example above, our context menu appears at a fixed `Positioned(top: 100, left: 100)`. This isn't very useful for a context menu that should appear next to the button that triggered it.

The `BuildContext` given to the `overlayChildBuilder` is very helpful here. It represents the context *at the location of the `OverlayPortal`*. We can use this context to find the position of the `OverlayPortal` (and thus the button, since it's its child) on the screen!

1.  We need to get the `RenderBox` of the `OverlayPortal`. We can use a `GlobalKey` for this.
2.  We can then use the `localToGlobal` method on the `RenderBox` to find its position relative to the entire screen (or the [Overlay](01_overlay_.md)).

```dart
// Inside a StatefulWidget's State class:
class _MyWidgetState extends State<MyWidget> {
  final OverlayPortalController _contextMenuController = OverlayPortalController();
  // Add a GlobalKey to get the RenderBox of the button/OverlayPortal
  final GlobalKey _buttonKey = GlobalKey();

  @override
  void dispose() {
    _contextMenuController.dispose();
    super.dispose();
  }

  void _showMenu() {
    if (_buttonKey.currentContext != null) {
      // Get the RenderBox of the widget associated with the key
      final RenderBox renderBox = _buttonKey.currentContext!.findRenderObject() as RenderBox;
      // Get the position of the *top-left* corner of the button
      final Offset buttonPosition = renderBox.localToGlobal(Offset.zero);
      // Get the size of the button
      final Size buttonSize = renderBox.size;

      // We'll need the position and size in the overlayChildBuilder
      // How to pass this info? We can store it in the State.
      // Let's update the builder to use state variables.

      // Now, tell the controller to show the overlay
      _contextMenuController.show(); // Use show instead of toggle for clearer logic
    }
  }

  // Need variables to store the button's position and size
  Offset _buttonPosition = Offset.zero;
  Size _buttonSize = Size.zero;

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(title: const Text('Overlay Portal Example')),
      body: Center(
        child: OverlayPortal(
          controller: _contextMenuController,
          overlayChildBuilder: (BuildContext context) {
            // Use the stored position and size to position the menu
            // Let's place the menu just below the button
            return Positioned(
              // Place the top of the menu at the bottom of the button
              top: _buttonPosition.dy + _buttonSize.height,
              // Align the left edge of the menu with the left edge of the button
              left: _buttonPosition.dx,
              child: Material(
                elevation: 4.0,
                child: Container(
                  padding: const EdgeInsets.all(8.0),
                  color: Colors.yellow[100],
                  child: const Text('Context Menu!'),
                ),
              ),
            );
          },
          // Wrap the child (the button) with the GlobalKey and onPressed that calls _showMenu
          child: SizedBox( // Use SizedBox to apply the key directly
            key: _buttonKey, // Attach the key here!
            child: ElevatedButton(
              onPressed: _showMenu, // Call our _showMenu function
              child: const Text('Show Menu'),
            ),
          ),
        ),
      ),
    );
  }
}
```

Now, our `_showMenu` function finds the button's position on the screen using the `_buttonKey`, stores this position and size in state variables, and then calls `_contextMenuController.show()`. The `overlayChildBuilder` then uses these state variables (`_buttonPosition` and `_buttonSize`) to calculate where to place the `Positioned` widget, making the menu appear right below the button.

To hide the menu, you'd typically add a tap detector outside the menu or a close button within the menu that calls `_contextMenuController.hide()`.

```dart
// Add this helper function to hide the menu
void _hideMenu() {
   _contextMenuController.hide();
}

// Update the overlayChildBuilder to include a GestureDetector to hide taps outside the menu
overlayChildBuilder: (BuildContext context) {
  return Stack( // Use a Stack to layer the tap catcher below the menu
    children: [
      Positioned.fill(
         // A transparent widget that catches taps outside the menu content
         child: GestureDetector(
           onTap: _hideMenu, // Hide the menu when tapped outside
           behavior: HitTestBehavior.translucent, // Ensure it catches taps
         ),
      ),
      Positioned(
         top: _buttonPosition.dy + _buttonSize.height,
         left: _buttonPosition.dx,
         child: Material(
           elevation: 4.0,
           child: Container(
             padding: const EdgeInsets.all(8.0),
             color: Colors.yellow[100],
             child: const Text('Context Menu!'),
           ),
         ),
      ),
    ],
  );
},
```

This updated `overlayChildBuilder` wraps the `Positioned` menu inside a `Stack`. A `Positioned.fill` `GestureDetector` is placed on top of the entire overlay area (filling the [Overlay](01_overlay_.md)). This transparent detector catches taps *anywhere* on the overlay that isn't blocked by the menu itself and calls `_hideMenu`, making the menu disappear when the user taps outside of it.

### How OverlayPortalController Works Internally

When you call `_contextMenuController.show()` or `_contextMenuController.hide()`:

1.  The `OverlayPortalController` communicates with the `_OverlayPortalState` object it's currently attached to.
2.  The `_OverlayPortalState` updates its internal state, specifically the `_zOrderIndex` variable. `show()` sets this to a new unique timestamp (using `_now()`), `hide()` sets it to `null`.
3.  Updating this state triggers a `setState()` call within the `_OverlayPortalState`.
4.  `setState()` tells the Flutter framework that the `_OverlayPortalState` needs to rebuild.
5.  During the rebuild, the `_OverlayPortalState`'s `build` method checks the `_zOrderIndex`:
    *   If it's `null`, it returns a version of the internal `_OverlayPortal` widget that doesn't include the overlay child (`overlayChild: null`).
    *   If it's not `null`, it returns the `_OverlayPortal` widget with the `overlayChildBuilder`'s widget included (`overlayChild: _DeferredLayout(...)`).
6.  When the framework processes this update, if the `overlayChild` has changed from `null` to a widget (or vice-versa), the corresponding render objects are attached/detached from the ancestor [Overlay]'s [_RenderTheater](07__renderdeferredlayoutbox_.md) render tree. The `_zOrderIndex` is used to determine the correct paint order.

Sequence diagram for calling `show()`:

```mermaid
sequenceDiagram
    participant YourWidget
    participant OverlayPortalController
    participant _OverlayPortalState
    participant Framework as Flutter Framework
    participant OverlayPortalBuild as OverlayPortal.build()
    participant _OverlayPortalElement
    participant _RenderTheater as Overlay Render Tree

    YourWidget->>OverlayPortalController: call show()
    OverlayPortalController->>_OverlayPortalState: update internal state (_zOrderIndex)
    _OverlayPortalState->>Framework: call setState()
    Framework->>_OverlayPortalState: schedule rebuild
    Framework->>_OverlayPortalState: call build()
    _OverlayPortalState->>OverlayPortalBuild: return Widget with overlay child
    OverlayPortalBuild->>_OverlayPortalElement: process widget update
    _OverlayPortalElement->>_RenderTheater: attach/position overlay child render object
    _RenderTheater->>_RenderTheater: paint child on overlay
```

The internal code snippets showed that `_OverlayPortalState` indeed has a `_zOrderIndex` and methods like `show` and `hide` that call `setState`. The `build` method's critical part is checking if `_zOrderIndex == null` to decide whether to include the `overlayChild`.

```dart
// From packages/flutter/lib/src/widgets/overlay.dart -> _OverlayPortalState
void show(int zOrderIndex) {
  // ... asserts ...
  setState(() {
    _zOrderIndex = zOrderIndex; // Update state triggers rebuild
  });
  // ... invalidate location cache ...
}

void hide() {
  // ... asserts ...
  setState(() {
    _zOrderIndex = null; // Update state triggers rebuild
  });
  // ... invalidate location cache ...
}

@override
Widget build(BuildContext context) {
  final int? zOrderIndex = _zOrderIndex; // Check the state variable
  if (zOrderIndex == null) {
    return _OverlayPortal(overlayLocation: null, overlayChild: null, child: widget.child);
  }
  // ... build with overlay child if zOrderIndex is not null ...
  return _OverlayPortal(
    // ...
    overlayChild: _DeferredLayout(child: Builder(builder: widget.overlayChildBuilder)),
    // ...
  );
}
```

This confirms our understanding: the `OverlayPortalController` is just a thin wrapper forwarding commands to the `_OverlayPortalState`, which manages the visibility state (`_zOrderIndex`) and rebuilds itself to reflect that state change in the widget tree structure passed to the framework. The actual attachment/detachment of the render object happens deeper within the element tree logic triggered by the `_OverlayPortal` widget.

### Conclusion

In this chapter, we completed our understanding of the `OverlayPortal` pattern by introducing the `OverlayPortalController`. We learned that this controller acts as the remote control, using its `show()`, `hide()`, and `toggle()` methods to signal to the linked `OverlayPortal` when to display or hide its overlay child. We saw how to create a controller, link it to an `OverlayPortal`, use it in a button's `onPressed`, and importantly, how to dispose of it. We also improved our context menu example by using a `GlobalKey` and the `BuildContext` to position the overlay child relative to the trigger widget. Finally, we confirmed our understanding by looking at the internal code where the controller updates the `_OverlayPortalState`'s `_zOrderIndex`, triggering a rebuild.

With `OverlayPortal` and `OverlayPortalController`, you can elegantly manage temporary widgets that appear on the global [Overlay](01_overlay_.md) while keeping them conceptually linked to their origins.

In the next chapter, we'll take a very brief look at the [_Theater](06__theater_.md) widget, which we've seen mentioned multiple times as the internal widget used by the [OverlayState](02_overlaystate_.md) to manage the display of its children.

[_Theater](06__theater_.md)
2025-05-22 23:58:24,264 - INFO - PROMPT: 
Write a very beginner-friendly tutorial chapter (in Markdown format) for the project `flutter (overlay.dart)` about the concept: "_Theater
". This is Chapter 6.

Concept Details:
- Name: _Theater

- Description:
_Theater is the internal rendering part of the Overlay. It's a special type of layout engine (similar to a Stack) that manages the visual arrangement of all the OverlayEntry widgets and the widgets from OverlayPortals. It handles which entries are visible and where they are positioned on the screen.


Complete Tutorial Structure:
1. [Overlay
](01_overlay_.md)
2. [OverlayState
](02_overlaystate_.md)
3. [OverlayEntry
](03_overlayentry_.md)
4. [OverlayPortal
](04_overlayportal_.md)
5. [OverlayPortalController
](05_overlayportalcontroller_.md)
6. [_Theater
](06__theater_.md)
7. [_RenderDeferredLayoutBox
](07__renderdeferredlayoutbox_.md)
8. [_OverlayEntryLocation
](08__overlayentrylocation_.md)

Context from previous chapters:
# Chapter 1: Overlay

Welcome to the first chapter of our tutorial on Flutter's `overlay.dart`! In this chapter, we'll introduce you to the fundamental concept of an `Overlay`.

Have you ever seen temporary popups, like dialogs, tooltips that appear over your regular screen content, no matter what's currently displayed? How does Flutter manage to show these elements *on top* of everything else? That's where the `Overlay` comes in!

Think of your Flutter app's user interface as a stack of layers, like transparencies on an overhead projector. Your main screen content is on the bottom layer. When you want to show something *over* that content, without affecting how the main content is arranged, you place it on a new, transparent layer on top. The `Overlay` widget is like the frame of this overhead projector that holds the stack of transparent sheets.

The `Overlay` itself is a widget that sits high up in your app's widget tree, often provided automatically by powerful widgets like `MaterialApp` or `WidgetsApp`. It manages a list of "sheets," called [OverlayEntry](03_overlayentry_.md)s. Each [OverlayEntry](03_overlayentry_.md) can hold a widget, and these widgets will be painted *above* the `Overlay`'s regular content.

So, the core idea is:

**An `Overlay` is a stack of entry points where you can place widgets that should appear on top of your primary UI.**

### Our Goal: Displaying a Simple Overlay

To understand the `Overlay` better, let's imagine we want to display a simple message box that floats in the center of the screen when a button is pressed. This message box should appear above all other content on the screen.

Using the `Overlay` and its related components, we can achieve this. Here's the high-level plan:

1.  Find the nearest `Overlay`.
2.  Create an [OverlayEntry](03_overlayentry_.md) containing our message box widget.
3.  Insert this [OverlayEntry](03_overlayentry_.md) into the `Overlay`'s stack.
4.  When we want to hide the message box, we'll remove the [OverlayEntry](03_overlayentry_.md) from the `Overlay`.

### Finding the Overlay

The `Overlay` is usually introduced by the main app widgets like `MaterialApp`. To interact with this `Overlay`, we need to get its state, which is an [OverlayState](02_overlaystate_.md). We can do this using the `Overlay.of` method, passing the current `BuildContext`.

```dart
// Inside a widget's build method or a function called from it:
OverlayState? overlayState = Overlay.of(context);
```

This code snippet uses `Overlay.of(context)` to look up the closest `OverlayState` in the widget tree above the current `context`. If an `Overlay` is found, it gives us its state (the [OverlayState](02_overlaystate_.md) object) that we can use to manage our overlay entries. If no `Overlay` is found (which is unlikely in a typical `MaterialApp`), it would cause an error in debug mode.

### What's Inside the Overlay?

While we don't see it directly in the minimal code we write, the `Overlay` widget itself contains some interesting pieces to manage its entries.

Let's look at a relevant snippet from the `overlay.dart` file:

```dart
class Overlay extends StatefulWidget {
  // ... other properties and methods

  @override
  OverlayState createState() => OverlayState();
}
```

This shows that the `Overlay` widget creates an [OverlayState](02_overlaystate_.md). This is the object we obtained using `Overlay.of`. The [OverlayState](02_overlaystate_.md) is where the real work of managing the list of [OverlayEntry](03_overlayentry_.md) objects happens.

Further down in the code, we see how the `OverlayState` builds its UI:

```dart
class OverlayState extends State<Overlay> with TickerProviderStateMixin {
  final List<OverlayEntry> _entries = <OverlayEntry>[];

  // ... methods for inserting and removing entries

  @protected
  @override
  Widget build(BuildContext context) {
    // ... logic to determine visible entries
    final List<_OverlayEntryWidget> children = <_OverlayEntryWidget>[];
    // ... populate children based on _entries
    return _Theater(
      // ... properties like skipCount, clipBehavior
      children: children.reversed.toList(growable: false),
    );
  }

  // ... other methods
}
```

This snippet reveals a crucial part: the `OverlayState` holds a list of `_entries` (our [OverlayEntry](03_overlayentry_.md) objects). In its `build` method, it creates a list of `_OverlayEntryWidget`s corresponding to the active entries. These widgets are then passed to a special widget called `_Theater`.

The `_Theater` widget is essentially a specialized `Stack`. It's responsible for laying out and painting the widgets from the [OverlayEntry](03_overlayentry_.md)s on top of each other, similar to how layers are stacked in a `Stack`.

Here's a simplified illustration of the key participants and their relationships in displaying an overlay entry:

```mermaid
sequenceDiagram
    participant YourWidget
    participant OverlayDotOf as Overlay.of(context)
    participant OverlayState
    participant OverlayEntry
    participant _Theater

    YourWidget->>OverlayDotOf: Ask for OverlayState
    OverlayDotOf-->>OverlayState: Return the found OverlayState
    YourWidget->>OverlayState: Create and insert OverlayEntry
    OverlayState->>OverlayEntry: Add entry to internal list
    OverlayState->>OverlayState: Schedule rebuild
    OverlayState->>_Theater: Build _Theater with entries as children
    _Theater->>OverlayEntry: Ask entry to build its widget
    OverlayEntry->>_Theater: Return built widget
    _Theater->>_Theater: Layout and paint entry's widget on top

```

This diagram shows that your widget interacts with the global `Overlay.of` to get the [OverlayState](02_overlaystate_.md). You then use the [OverlayState](02_overlaystate_.md) to manage your [OverlayEntry](03_overlayentry_.md). The [OverlayState](02_overlaystate_.md) internally uses `_Theater` to visually stack the widgets provided by the [OverlayEntry](03_overlayentry_.md)s.

### Conclusion

In this chapter, we introduced the concept of the `Overlay` in Flutter. We learned that it acts as a container for widgets that should appear on top of the regular UI, managing them as a stack of [OverlayEntry](03_overlayentry_.md) objects. We saw how to find the `OverlayState` using `Overlay.of` and got a peek into the internal structure involving `_Theater`.

In the next chapter, we will delve deeper into the [OverlayState](02_overlaystate_.md) and explore how to use its methods to actually insert and remove [OverlayEntry](03_overlayentry_.md) objects, allowing us to finally display our floating message box.

[OverlayState](02_overlaystate_.md)
---
# Chapter 2: OverlayState

Welcome back! In our [previous chapter](01_overlay_.md), we learned that an `Overlay` acts like a transparent layer on top of our regular UI, managed by powerful widgets like `MaterialApp`. We also saw that this `Overlay` holds a stack of "sheets" called [OverlayEntry](03_overlayentry_.md)s. But who is in charge of managing these sheets? That's where the `OverlayState` comes in.

Think of the `Overlay` as the physical structure (the overhead projector frame) and the `OverlayState` as the person operating that projector. The `OverlayState` is the **manager** for the `Overlay`. Its main job is to keep track of which [OverlayEntry](03_overlayentry_.md) sheets are currently in the stack and decide which ones are visible.

Our goal from the last chapter was to display a simple message box that floats in the center of the screen when a button is pressed. To do this, we need to:

1.  Find the `OverlayState` associated with our `Overlay`.
2.  Create an [OverlayEntry](03_overlayentry_.md) containing our message box widget.
3.  Tell the `OverlayState` to **insert** this [OverlayEntry](03_overlayentry_.md) into its stack.
4.  When we want to hide the message box, tell the `OverlayState` to **remove** the [OverlayEntry](03_overlayentry_.md).

In this chapter, we'll focus on how to use the `OverlayState` to perform these insertions and removals.

### Getting the OverlayState

As we briefly saw in the last chapter, we can get the `OverlayState` using the static method `Overlay.of`. This method looks up the widget tree from the given `BuildContext` and finds the nearest `Overlay` widget's state.

```dart
// Inside a widget where you want to show an overlay:
void showMyMessageBox(BuildContext context) {
  OverlayState? overlayState = Overlay.of(context);
  // Now we have the manager (the OverlayState)!
}
```

Here, `Overlay.of(context)` does the important work of finding the correct `OverlayState` for us. The `context` tells Flutter where in the widget tree we are looking from. In a typical app, this `OverlayState` will be the one managed by your `MaterialApp` or `WidgetsApp`.

### Adding an OverlayEntry

Once we have the `OverlayState`, we can add new entries to it. The `OverlayState` has an `insert` method for this purpose. The `insert` method takes an [OverlayEntry](03_overlayentry_.md) object as its argument.

Let's imagine we have created our `OverlayEntry` object (we'll learn more about [OverlayEntry](03_overlayentry_.md) in the next chapter, for now just assume it exists).

```dart
// Continuing from the previous snippet:
void showMyMessageBox(BuildContext context) {
  OverlayState? overlayState = Overlay.of(context);

  if (overlayState != null) {
    // Assume 'myOverlayEntry' is an instance of OverlayEntry
    // that holds our message box widget.
    OverlayEntry myOverlayEntry = createMessageBoxEntry(); // Placeholder function

    overlayState.insert(myOverlayEntry);
    print('Message box inserted!');
  } else {
    print('Could not find OverlayState!');
  }
}

// Placeholder for creating the OverlayEntry
OverlayEntry createMessageBoxEntry() {
  // This would contain the actual widget for the message box
  return OverlayEntry(
    builder: (context) => Center(
      child: Container(
        width: 200,
        height: 100,
        color: Colors.blue,
        child: Center(child: Text('Hello Overlay!')),
      ),
    ),
  );
}
```

In this code:
1.  We get the `overlayState`.
2.  We check if it's not null (meaning an `Overlay` was found).
3.  We create an `OverlayEntry` (using `createMessageBoxEntry`).
4.  We call `overlayState.insert(myOverlayEntry)`. This is the key step! It tells the `OverlayState` to add our entry to its internal list.

When an `OverlayEntry` is inserted, the `OverlayState` marks itself as needing to rebuild. During the next build cycle, the `OverlayState` will include the widget from your newly inserted [OverlayEntry](03_overlayentry_.md) in its list of visible children, making it appear on top of your UI.

### Ordering OverlayEntries

The `insert` method also allows you to control where the entry is inserted in the stack:

*   `overlayState.insert(entry)`: Inserts the entry at the very top (painted last).
*   `overlayState.insert(entry, below: someOtherEntry)`: Inserts the entry just below `someOtherEntry`.
*   `overlayState.insert(entry, above: someOtherEntry)`: Inserts the entry just above `someOtherEntry`.

This is like deciding whether to place your new transparency sheet on the very top of the stack, or insert it right above or below another specific sheet. This is useful for complex overlays or when integrating with system overlays like dialogs or routes managed by the Navigator.

### Removing an OverlayEntry

Adding entries is only half the story. We also need to be able to remove them. For example, when the user closes our message box, we want to take it off the overlay.

To remove an [OverlayEntry](03_overlayentry_.md), you call the `remove()` method directly on the **[OverlayEntry](03_overlayentry_.md) object itself**, not on the `OverlayState`.

```dart
// Continuing the example, we need to keep track of the inserted entry:
OverlayEntry? currentMessageBoxEntry; // Store the active entry

void showMyMessageBox(BuildContext context) {
  // ... find overlayState ...
  if (overlayState != null) {
    // Create and store the entry before inserting
    currentMessageBoxEntry = createMessageBoxEntry();
    overlayState.insert(currentMessageBoxEntry!); // Insert it
    print('Message box inserted!');

    // Example: Automatically remove after 3 seconds (for demonstration)
    Future.delayed(Duration(seconds: 3), () {
      removeMyMessageBox();
    });

  } else {
    print('Could not find OverlayState!');
  }
}

// Function to remove the message box
void removeMyMessageBox() {
  if (currentMessageBoxEntry != null) {
    currentMessageBoxEntry!.remove(); // Call remove on the entry!
    currentMessageBoxEntry = null; // Clear the stored entry
    print('Message box removed!');
  }
}

// (createMessageBoxEntry function remains the same)
// (Remember to import 'package:flutter/material.dart' for Colors/Container/Text)
```

In this updated code:
1.  We declare `currentMessageBoxEntry` to hold a reference to the [OverlayEntry](03_overlayentry_.md) once it's created and inserted.
2.  When showing the box, we assign the new entry to this variable.
3.  When removing the box (`removeMyMessageBox`), we check if `currentMessageBoxEntry` is not null and call its `remove()` method.
4.  After removing, we set `currentMessageBoxEntry` back to null.

Calling `entry.remove()` tells the `OverlayState` to take that specific [OverlayEntry](03_overlayentry_.md) out of its list. Similar to insertion, the `OverlayState` will then mark itself dirty and rebuild, this time *without* including the widget from the removed entry.

### How OverlayState Manages Entries Internally

Let's look peek under the hood again. We saw in the snippet from the last chapter that `OverlayState` holds a `List<OverlayEntry> _entries`. This is the core list it manages.

When you call `insert`:

```dart
// From overlay.dart -> OverlayState -> insert method (simplified)
void insert(OverlayEntry entry, {OverlayEntry? below, OverlayEntry? above}) {
  // ... asserts ...
  entry._overlay = this; // Internal link back to this OverlayState
  setState(() { // Marks state as dirty, schedules a rebuild
    _entries.insert(_insertionIndex(below, above), entry); // Adds to the list
  });
}
```

*   `entry._overlay = this;`: The [OverlayEntry](03_overlayentry_.md) keeps a reference to the `OverlayState` it belongs to. This is how `entry.remove()` knows *which* `OverlayState` to tell to remove it.
*   `setState(() { ... });`: This is standard Flutter State management. It signals to the framework that the state of the `OverlayState` has changed (`_entries` list is different) and it needs to be rebuilt.
*   `_entries.insert(...)`: This is the actual list manipulation. It adds the `entry` at the calculated position in the internal `_entries` list.

When the `OverlayState` rebuilds, its `build` method creates the UI using the current contents of `_entries`. We saw that it uses a widget called `_Theater` for this:

```dart
// From overlay.dart -> OverlayState -> build method (simplified)
@override
Widget build(BuildContext context) {
  // ... logic to determine visible entries ...
  final List<_OverlayEntryWidget> children = <_OverlayEntryWidget>[];
  // Loop through _entries (and inactive maintainedState entries)
  // and create _OverlayEntryWidget for each.
  return _Theater(
    // ...
    children: children.reversed.toList(growable: false), // Passes the list to _Theater
  );
}
```

The `_Theater` is essentially a specialized container that takes a list of child widgets (built from the [OverlayEntry](03_overlayentry_.md)s) and stacks them on top of each other. The children are given to `_Theater` in reversed order because the `_entries` list is ordered from bottom to top, but a `Stack` (which `_Theater` behaves like) paints children from bottom to top based on their position in the list. So, the last entry in `_entries` (the top-most one) needs to be the last child given to `_Theater`.

Here's a sequence diagram illustrating insertion:

```mermaid
sequenceDiagram
    participant YourWidget
    participant OverlayState
    participant OverlayEntry
    participant Framework as Flutter Framework
    participant _Theater

    YourWidget->>OverlayState: call insert(OverlayEntry)
    OverlayState->>OverlayEntry: set internal _overlay reference
    OverlayState->>OverlayState: add OverlayEntry to _entries list
    OverlayState->>Framework: call setState()
    Framework->>OverlayState: scheduled rebuild
    OverlayState->>OverlayState: call build()
    OverlayState->>OverlayEntry: call builder() to get widget
    OverlayEntry->>OverlayState: return widget
    OverlayState->>_Theater: pass widget as child
    _Theater->>_Theater: layout and paint widget on top
```

When you call `entry.remove()`:

```dart
// From overlay.dart -> OverlayEntry -> remove method (simplified)
void remove() {
  assert(_overlay != null);
  final OverlayState overlay = _overlay!; // Get the associated OverlayState
  _overlay = null; // Clear the internal reference

  // ... schedule markDirty or call directly ...
  overlay._entries.remove(this); // Remove from the OverlayState's list
  overlay._markDirty(); // Tell the OverlayState to rebuild
  // ...
}
```

*   `_overlay!`: Accesses the `OverlayState` that this entry is currently in.
*   `_entries.remove(this);`: The `OverlayEntry` tells its manager (`_overlay`) to remove itself from the list.
*   `overlay._markDirty();`: Calls an internal method on the `OverlayState` to signal that it needs to rebuild.

The diagram for removal is similar to insertion, just in reverse:

```mermaid
sequenceDiagram
    participant YourWidget
    participant OverlayEntry
    participant OverlayState
    participant Framework as Flutter Framework
    participant _Theater

    YourWidget->>OverlayEntry: call remove()
    OverlayEntry->>OverlayState: access internal _overlay reference
    OverlayEntry->>OverlayEntry: clear internal _overlay reference
    OverlayEntry->>OverlayState: remove OverlayEntry from _entries list
    OverlayState->>OverlayState: call _markDirty()
    OverlayState->>Framework: setState() called implicitly
    Framework->>OverlayState: scheduled rebuild
    OverlayState->>OverlayState: call build()
    OverlayState->>_Theater: pass children (without the removed entry)
    _Theater->>_Theater: relayout and repaint (entry disappears)
```

This demonstrates how the `OverlayState` acts as the central hub, maintaining the list and triggering UI updates when the list of [OverlayEntry](03_overlayentry_.md) objects changes.

### Conclusion

In this chapter, we explored the crucial role of the `OverlayState`. We learned that it is the manager for an [Overlay](01_overlay_.md), holding the list of [OverlayEntry](03_overlayentry_.md) objects and controlling their visibility. We saw how to obtain the `OverlayState` using `Overlay.of` and, most importantly, how to use its `insert` method to add [OverlayEntry](03_overlayentry_.md)s to the overlay stack and how to call `remove` directly on an [OverlayEntry](03_overlayentry_.md) to take it out.

We also took a look at the internal workings, seeing how `OverlayState`'s `_entries` list is manipulated and how `setState` triggers a rebuild to update the UI using the [_Theater](06__theater_.md) widget.

Now that we understand the container ([Overlay](01_overlay_.md)) and its manager (`OverlayState`), it's time to delve into the "sheets" themselves: the [OverlayEntry](03_overlayentry_.md). In the next chapter, we'll learn how to create our own [OverlayEntry](03_overlayentry_.md) objects with the specific widgets we want to display on the overlay.

[OverlayEntry](03_overlayentry_.md)
---
# Chapter 3: OverlayEntry

Welcome back to our `overlay.dart` tutorial! In the [previous chapters](01_overlay_.md), we learned about the [Overlay](01_overlay_.md) as a container that sits on top of our UI and the [OverlayState](02_overlaystate_.md) as its manager, responsible for inserting and removing items from the overlay stack.

But what exactly are these "items" or "sheets" that get placed onto the [Overlay](01_overlay_.md)? That's where the `OverlayEntry` comes in!

Think of an `OverlayEntry` as a single, transparent sheet that you prepare to put onto the [Overlay](01_overlay_.md)'s overhead projector. This sheet has one purpose: to hold and display **a single widget** on the overlay.

Our goal is to display a simple message box that floats in the center of the screen when a button is pressed. To do this using the [Overlay](01_overlay_.md) and [OverlayState](02_overlaystate_.md), we need to wrap our message box widget inside an `OverlayEntry`.

So, an `OverlayEntry` is the object that carries the self-contained piece of UI you want to show on top of your regular content. It's the payload that the [OverlayState](02_overlaystate_.md) manages.

### Creating an OverlayEntry

Creating an `OverlayEntry` is straightforward. You just need to provide a `builder` function. This `builder` function is a standard Flutter `WidgetBuilder` that takes a `BuildContext` and should return the widget you want to display on the overlay.

Here's how we would create an `OverlayEntry` for our simple message box:

```dart
// This function creates an OverlayEntry for our message box.
OverlayEntry createMessageBoxEntry() {
  OverlayEntry entry = OverlayEntry(
    builder: (BuildContext context) {
      // The widget that will be shown on the overlay
      return Center( // Center it on the overlay
        child: Container(
          width: 200,
          height: 100,
          color: Colors.blue,
          child: const Center(child: Text('Hello OverlayEntry!')),
        ),
      );
    },
  );
  return entry;
}
```

In this snippet:

*   `OverlayEntry(...)`: We call the `OverlayEntry` constructor.
*   `builder: (BuildContext context) { ... }`: We provide the required `builder` function. Flutter will call this function when it needs to display our entry on the overlay.
*   Inside the `builder`, we return a `Center` widget containing our blue message `Container`. This widget is what the `OverlayEntry` will represent visually on the overlay.

Now, when we get the [OverlayState](02_overlaystate_.md) (as shown in the [previous chapter](02_overlaystate_.md)) and call `overlayState.insert(entry)`, our beautiful blue box will appear centered on the screen!

### OverlayEntry Properties: Opaque and MaintainState

Besides the `builder`, `OverlayEntry` has a couple of important properties: `opaque` and `maintainState`. These properties control how the `Overlay` handles layers below this specific entry.

*   **`opaque` (default: `false`)**: If set to `true`, this property signals to the [Overlay](01_overlay_.md) that this entry completely covers whatever is beneath it in the overlay stack. This is mainly an optimization hint. If an entry is `opaque`, the [Overlay](01_overlay_.md) can skip building or painting the parts of the entries below it that are covered. Think of putting a solid, colored sheet on the overhead projector  you can't see through it to the sheets below. Our message box isn't truly opaque unless it fills the whole screen, but for performance, you might mark a dialog or a full-screen route as opaque.

*   **`maintainState` (default: `false`)**: If set to `true`, this property tells the [Overlay](01_overlay_.md) to keep the widget hierarchy for this entry active, even if it's visually hidden by an `opaque` entry on top. This is like keeping the light on for a sheet even if a solid sheet is on top. This is useful for things like keeping the state of a background route alive in a Navigator, even when another route is covering it entirely. Setting this to `true` can use more resources, so use it only when necessary.

For our simple message box, neither of these needs to be `true`. It doesn't cover everything below it entirely (it's just a small box), and we don't need to maintain its state when it's not visible (we'll remove it when hidden). So, the default values work fine.

```dart
OverlayEntry createMessageBoxEntry() {
  return OverlayEntry(
    builder: (BuildContext context) {
      // Our message box widget
      return Center(
        child: Container(
          width: 200,
          height: 100,
          color: Colors.blue,
          child: const Center(child: Text('Hello OverlayEntry!')),
        ),
      );
    },
    // opaque: false, // Default and appropriate for a small box
    // maintainState: false, // Default and appropriate as we remove it
  );
}
```

### Removing an OverlayEntry

As we saw in the [previous chapter](02_overlaystate_.md), to remove an `OverlayEntry`, you call the `remove()` method directly on the `OverlayEntry` object itself.

```dart
// Assuming you have a variable to hold the entry:
OverlayEntry? myActiveMessageBoxEntry;

void hideMyMessageBox() {
  if (myActiveMessageBoxEntry != null) {
    myActiveMessageBoxEntry!.remove(); // Tell the entry to remove itself
    myActiveMessageBoxEntry = null; // Clear our reference
  }
}
```

When `entry.remove()` is called:
1. The `OverlayEntry` looks up the [OverlayState](02_overlaystate_.md) it was inserted into (it holds an internal reference).
2. It tells that [OverlayState](02_overlaystate_.md) to remove it from its list of entries.
3. The [OverlayState](02_overlaystate_.md) rebuilds, and since the entry is no longer in its list, the widget built by this entry's `builder` is no longer included in the UI, making it disappear.

### How OverlayEntry Works Internally

Let's revisit the code snippet from `overlay.dart` for `OverlayEntry`:

```dart
class OverlayEntry implements Listenable {
  // ... constructor and properties ...

  OverlayState? _overlay; // Internal reference to the managing OverlayState
  final GlobalKey<_OverlayEntryWidgetState> _key = GlobalKey<_OverlayEntryWidgetState>();

  /// Remove this entry from the overlay.
  void remove() {
    assert(_overlay != null);
    final OverlayState overlay = _overlay!; // Get the associated OverlayState
    _overlay = null; // Clear the internal reference

    // ... scheduling logic ...
    overlay._entries.remove(this); // Request removal from the OverlayState's list
    overlay._markDirty(); // Tell the OverlayState to rebuild
    // ...
  }

  /// Cause this entry to rebuild during the next pipeline flush.
  ///
  /// You need to call this function if the output of [builder] has changed.
  void markNeedsBuild() {
    assert(!_disposedByOwner);
    _key.currentState?._markNeedsBuild();
  }

  // ... dispose method and other internal details ...
}
```

Key takeaways from this snippet:

*   `OverlayState? _overlay;`: This private variable is how an `OverlayEntry` knows which [OverlayState](02_overlaystate_.md) it belongs to. This reference is set when you call `overlayState.insert(entry)`.
*   `final GlobalKey<_OverlayEntryWidgetState> _key`: Each `OverlayEntry` uses a `GlobalKey` to identify the actual widget (`_OverlayEntryWidget`) that the [OverlayState](02_overlaystate_.md) creates to represent this entry in the widget tree.
*   `remove()`: When you call `remove()`, it uses the `_overlay` reference to find the correct [OverlayState](02_overlaystate_.md) and tells it to remove `this` entry from its internal `_entries` list (`overlay._entries.remove(this)`). It then sets `_overlay` to `null` and calls `overlay._markDirty()` to trigger a rebuild of the [OverlayState](02_overlaystate_.md).
*   `markNeedsBuild()`: If the widget you return from your `builder` function changes (e.g., based on some state within the `OverlayEntry`), you can call `markNeedsBuild()` on the `OverlayEntry` to tell the system that its visual representation needs to be updated. This calls `setState` on the internal `_OverlayEntryWidgetState` associated with this entry's `_key`.

Here's a sequence diagram focusing on the OverlayEntry's role in removal:

```mermaid
sequenceDiagram
    participant YourWidget
    participant OverlayEntry
    participant OverlayState
    participant Framework as Flutter Framework

    YourWidget->>OverlayEntry: call remove()
    OverlayEntry->>OverlayEntry: access internal _overlay reference
    OverlayEntry->>OverlayEntry: clear internal _overlay reference
    OverlayEntry->>OverlayState: remove OverlayEntry from _entries list
    OverlayState->>OverlayState: call _markDirty() (triggers setState)
    OverlayState->>Framework: schedule build
    Framework->>OverlayState: call build()
    OverlayState->>OverlayEntry: Build logic skips removed entry
    OverlayEntry->>Framework: Widget no longer added to tree
    Framework->>Framework: UI updated (entry disappears)
```

This confirms that the `OverlayEntry` is primarily a data holder for the widget and properties, and it delegates the actual UI management (insertion and removal from the visual tree) back to the [OverlayState](02_overlaystate_.md) it belongs to.

### Conclusion

In this chapter, we focused on the `OverlayEntry`, the core object that holds the widget you want to display on an [Overlay](01_overlay_.md). We learned how to create a basic `OverlayEntry` using a `builder` function, how to use its `opaque` and `maintainState` properties, and how calling `remove()` on the entry itself signals to the managing [OverlayState](02_overlaystate_.md) to take it off the screen.

We also briefly looked at the internal structure, understanding that `OverlayEntry` keeps a reference to its [OverlayState](02_overlaystate_.md) and manages a `GlobalKey` to its corresponding widget in the overlay tree.

With the concepts of [Overlay](01_overlay_.md), [OverlayState](02_overlaystate_.md), and `OverlayEntry` under our belt, we now have the foundational knowledge to display custom widgets on top of our application content at a global level!

In the next chapter, we will introduce [OverlayPortal](04_overlayportal_.md), a more modern and often simpler alternative to directly managing `OverlayEntry` objects, especially when you want an overlay widget to stay closely connected to the state and context of its originating widget.

[OverlayPortal](04_overlayportal_.md)
---
# Chapter 4: OverlayPortal

Welcome back! In our [previous chapters](01_overlay_.md), we built a solid understanding of the [Overlay](01_overlay_.md), the [OverlayState](02_overlaystate_.md) (its manager), and the [OverlayEntry](03_overlayentry_.md) (the sheet holding the widget). We learned how to manually create an [OverlayEntry](03_overlayentry_.md), get the [OverlayState](02_overlaystate_.md), and insert/remove the entry to make a widget appear or disappear on top of everything.

While this manual approach works, sometimes it can feel a bit disconnected. You have your original widget (say, a button that triggers the overlay), and the overlay widget itself is managed separately by the [OverlayState](02_overlaystate_.md), potentially far away in the widget tree. This can make things like keeping the overlay visually positioned relative to the original widget or having the overlay widget inherit themes/context from the original widget's location a bit tricky.

This is where `OverlayPortal` comes in!

Think of `OverlayPortal` as a special window from your widget's location directly to the [Overlay](01_overlay_.md). You place the `OverlayPortal` widget in your widget tree like any other widget. When you want to show something on the [Overlay](01_overlay_.md), you tell the `OverlayPortal`, and it uses a builder function you provide to create the widget.

**The key idea is that the widget you want to show on the [Overlay](01_overlay_.md) feels like it's still attached to your `OverlayPortal`'s spot in the widget tree, even though it's visually displayed on the [Overlay](01_overlay_.md).**

### Our Goal: A Context Menu

Let's refine our goal. Instead of just a simple message box, imagine we want a small context menu to appear right next to a button when you tap it. This menu should float on the [Overlay](01_overlay_.md), but its position should be related to the button, and it should inherit styling (like text themes) from where the button is located.

Using `OverlayPortal`, this becomes much more natural than manual [OverlayEntry](03_overlayentry_.md) management.

### Creating an OverlayPortal

An `OverlayPortal` is a `StatefulWidget` you add to your widget tree. It requires a `controller` (an [OverlayPortalController](05_overlayportalcontroller_.md), which we'll cover in the next chapter) and an `overlayChildBuilder`.

```dart
// Inside your widget's build method:
OverlayPortal(
  controller: _myOverlayController, // We'll make this in the next chapter
  overlayChildBuilder: (BuildContext context) {
    // This is the widget that will show on the Overlay
    return Positioned( // We'll position it later
      top: 100, // Just a placeholder for now
      left: 100, // Just a placeholder for now
      child: Material( // Use Material for styling/elevation
        elevation: 4.0,
        child: Container(
          padding: const EdgeInsets.all(8.0),
          color: Colors.yellow[100],
          child: Text('Context Menu!'),
        ),
      ),
    );
  },
  child: ElevatedButton( // This is the original widget (the button)
    onPressed: () {
      // We will show the overlay here using the controller
    },
    child: const Text('Show Menu'),
  ),
)
```

In this example:

1.  We place the `OverlayPortal` widget in our tree.
2.  We give it an `overlayChildBuilder`. This is very similar to the `builder` for an [OverlayEntry](03_overlayentry_.md)  it's the function that creates the widget for the overlay.
3.  We add a `child` property. This is the regular child widget of the `OverlayPortal` (our `ElevatedButton`).

The widget returned by `overlayChildBuilder` (`Positioned` in this case) will be displayed on the [Overlay](01_overlay_.md), but its `BuildContext` will be a special one that's linked back to the `OverlayPortal`'s location. This is why it can easily inherit themes, etc., from its original position.

Notice that we are using a `Positioned` widget directly in the `overlayChildBuilder`. This is common because `OverlayPortal`'s overlay child is placed within the [Overlay](01_overlay_.md) which behaves like a `Stack`. `Positioned` widgets are used to control the placement of children within a `Stack`.

### How OverlayPortal Works Internally (High Level)

When Flutter lays out the widget tree, it encounters the `OverlayPortal`. Importantly, when its `overlayChildBuilder` *is active* (meaning you've told the controller to show the overlay):

1.  The `OverlayPortal`'s `Element` (specifically an `_OverlayPortalElement`) calls its `overlayChildBuilder` to get the overlay widget.
2.  Instead of painting this widget directly where the `OverlayPortal` is located in the tree, the `_OverlayPortalElement` finds the nearest ancestor [Overlay](01_overlay_.md) (using an internal mechanism involving an `InheritedWidget`, which we'll see later).
3.  It then inserts the *render object* corresponding to the overlay widget into the `_RenderTheater` (the specialized `Stack` that the [Overlay](01_overlay_.md) uses to manage its visual children).
4.  The render object is placed correctly relative to other things on the [Overlay](01_overlay_.md) based on the order defined by the `OverlayPortalController`.
5.  The original `OverlayPortal` widget then continues its standard layout and painting for its `child` widget (the button), as if the overlay widget wasn't there.

This gives the illusion that the overlay widget is coming from the `OverlayPortal`'s location, even though its physical rendering happens on the [Overlay](01_overlay_.md).

Sequence diagram illustrating the key interaction:

```mermaid
sequenceDiagram
    participant YourWidget
    participant OverlayPortal
    participant _OverlayPortalState
    participant _OverlayPortalElement
    participant _TheaterMarker as InheritedWidget
    participant OverlayState
    participant _RenderTheater

    YourWidget->>OverlayPortal: build time (includes OverlayPortal)
    OverlayPortal->>_OverlayPortalState: create state
    _OverlayPortalState->>_OverlayPortalElement: mount element
    _OverlayPortalElement->>_TheaterMarker: look up ancestor Overlay info
    _TheaterMarker-->>_OverlayPortalElement: provide _RenderTheater etc.
    YourWidget->>YourWidget: trigger show via controller (next chapter)
    YourWidget->>_OverlayPortalState: call controller.show()
    _OverlayPortalState->>_OverlayPortalState: update internal state (_zOrderIndex)
    _OverlayPortalState->>YourWidget: setState() triggers rebuild
    YourWidget->>OverlayPortal: rebuild with show=true
    OverlayPortal->>_OverlayPortalElement: update element
    _OverlayPortalElement->>_OverlayPortalElement: call overlayChildBuilder
    _OverlayPortalElement->>_RenderTheater: attach overlay child render object
    _RenderTheater->>_RenderTheater: paint child on overlay
```

This shows how the `OverlayPortal` lives in your regular widget tree but has the ability to "reach out" to the ancestor [Overlay](01_overlay_.md)'s render object tree (`_RenderTheater`) to place its overlay child's render objects there.

### Advantages of OverlayPortal over Manual OverlayEntry

*   **Simplified Management:** You don't manually create, store, insert, or remove [OverlayEntry](03_overlayentry_.md) objects. The `OverlayPortal` widget handles this for you based on the state of its controller.
*   **Context and Inherited Widgets:** The `BuildContext` provided to `overlayChildBuilder` is closely tied to the `OverlayPortal`'s original location. This means your overlay widget automatically inherits themes, `MediaQuery`, `Localizations`, etc., making styling and layout much easier.
*   **State Management:** The lifecycle of the overlay widget is tied to the `OverlayPortal`. If the `OverlayPortal` is disposed, the overlay widget goes away too. This simplifies managing the state of complex overlay children.
*   **Relative Positioning:** While basic `Positioned` works, `OverlayPortal` makes it easier to use widgets like `CompositedTransformTarget` and `CompositedTransformFollower` to position the overlay child precisely relative to the `OverlayPortal`'s location. We used a simple `Positioned` as a placeholder for now, but later chapters might explore this.

### Limitations

*   **Must have an ancestor `Overlay`:** Just like manual [OverlayEntry](03_overlayentry_.md), the `OverlayPortal` needs an [Overlay](01_overlay_.md) widget higher up in the tree to paint on. (Usually provided by `MaterialApp`, `WidgetsApp`, or `Navigator`.)
*   **Requires a controller:** You need to manage an [OverlayPortalController](05_overlayportalcontroller_.md) to show/hide the overlay.

### Peek into the Code

Let's look at the `OverlayPortal` class definition:

```dart
class OverlayPortal extends StatefulWidget {
  const OverlayPortal({
    super.key,
    required this.controller,
    required this.overlayChildBuilder,
    this.child,
  }) : _targetRootOverlay = false;

  // ... (targetsRootOverlay constructor) ...

  final OverlayPortalController controller;
  final WidgetBuilder overlayChildBuilder;
  final Widget? child;
  final bool _targetRootOverlay;

  @override
  State<OverlayPortal> createState() => _OverlayPortalState();
}
```

This confirms it's a `StatefulWidget` (hence the need for a `State` object, `_OverlayPortalState`, which will manage the connection to the [Overlay](01_overlay_.md) and the rendering). It takes the required `controller` and `overlayChildBuilder` and an optional `child`.

The `createState()` method simply returns `_OverlayPortalState()`. This is where the logic connecting to the actual [Overlay](01_overlay_.md) will live.

Looking at the `_OverlayPortalState` (parts shown in the file):

```dart
class _OverlayPortalState extends State<OverlayPortal> {
  int? _zOrderIndex; // Controls visibility and paint order

  // ... (methods like show, hide, didUpdateWidget, dispose) ...

  @override
  Widget build(BuildContext context) {
    final int? zOrderIndex = _zOrderIndex;
    if (zOrderIndex == null) {
      // If not showing, return a simple widget that just renders the child
      return _OverlayPortal(overlayLocation: null, overlayChild: null, child: widget.child);
    }
    // If showing, return a special widget that connects to the Overlay
    return _OverlayPortal(
      overlayLocation: _getLocation(zOrderIndex, widget._targetRootOverlay),
      overlayChild: _DeferredLayout(child: Builder(builder: widget.overlayChildBuilder)),
      child: widget.child,
    );
  }
}
```

Here, in `_OverlayPortalState`'s `build` method:

1.  It checks the `_zOrderIndex`. This private variable is controlled by the [OverlayPortalController](05_overlayportalcontroller_.md) (`show` sets it to a timestamp, `hide` sets it to null). The value of `_zOrderIndex` also determines the paint order on the [Overlay](01_overlay_.md).
2.  If `_zOrderIndex` is null (not showing), it returns a simple internal widget (`_OverlayPortal`) with `overlayChild: null`.
3.  If `_zOrderIndex` is not null (showing), it returns the `_OverlayPortal` widget again, but this time it provides an `overlayLocation` (obtained via `_getLocation`) and wraps the result of the `overlayChildBuilder` in a `_DeferredLayout` widget.

The `_OverlayPortal` widget is an internal `RenderObjectWidget` that manages the actual render object connection. `_DeferredLayout` is a key internal widget we'll touch on briefly; it's related to how the layout of the overlay child widget is handled (it's "deferred" until the [Overlay](01_overlay_.md) is ready to lay it out).

The `_getLocation` method is where the `_OverlayPortalState` finds the necessary information about the ancestor [Overlay](01_overlay_.md) by talking to an `InheritedWidget` (`_RenderTheaterMarker`).

```dart
class _RenderTheaterMarker extends InheritedWidget {
  // ... properties (theater, overlayEntryWidgetState) ...
  static _RenderTheaterMarker of(BuildContext context, {bool targetRootOverlay = false}) {
    // ... looks up the nearest or root _RenderTheaterMarker ...
    // ... returns the marker containing info about the Overlay's render objects ...
  }
}
```

This `_RenderTheaterMarker` is an `InheritedWidget` placed in the widget tree by the [OverlayState](02_overlaystate_.md) (specifically by the `_OverlayEntryWidget` which represents a single entry's content). It holds references to the key rendering objects of the [Overlay](01_overlay_.md) (`_RenderTheater`) and the specific [OverlayEntry](03_overlayentry_.md) the `OverlayPortal` is logically contained within (`_OverlayEntryWidgetState`). This mechanism allows the `_OverlayPortalState` to easily find the correct place in the render tree to insert its overlay child.

All of these internal pieces work together to take the widget from your `overlayChildBuilder` and insert its corresponding render object into the [Overlay]'s render tree (`_RenderTheater`) *at the correct paint order level relative to other [OverlayEntry](03_overlayentry_.md)s*.

### Conclusion

In this chapter, we introduced `OverlayPortal` as a more convenient way to display widgets on an [Overlay](01_overlay_.md). We learned that it allows the overlay widget to conceptually remain linked to the `OverlayPortal`'s location in the widget tree, making context inheritance simpler. We saw the basic structure of `OverlayPortal` with its `overlayChildBuilder` and optional `child`, and got a high-level understanding of how it uses internal widgets and render objects (`_OverlayPortal`, `_DeferredLayout`, `_RenderTheaterMarker`) to insert the overlay child's render object into the ancestor [Overlay](01_overlay_.md)'s `_RenderTheater`.

To actually control *when* the overlay child is shown or hidden, we need the `controller`. In the next chapter, we will explore the [OverlayPortalController](05_overlayportalcontroller_.md) and complete our context menu example.

[OverlayPortalController](05_overlayportalcontroller_.md)
---
# Chapter 5: OverlayPortalController

Welcome to Chapter 5! In our [previous chapter](04_overlayportal_.md), we were introduced to `OverlayPortal`, a special widget that lets you place a child widget onto the global [Overlay](01_overlay_.md) while still feeling connected to the `OverlayPortal`'s spot in the widget tree. We set up the `OverlayPortal` with an `overlayChildBuilder` to define our context menu widget, but we couldn't make it actually appear yet.

To control when an `OverlayPortal` shows or hides its overlay child, we need a remote control! That remote control is the **`OverlayPortalController`**.

Think of the `OverlayPortalController` as a dedicated switch for a single `OverlayPortal`. You give the controller to the `OverlayPortal`, and then you use the methods on that controller to tell the `OverlayPortal` what to do.

Our goal is still to show a small context menu right next to a button when it's tapped. The `OverlayPortalController` is the key piece that lets us trigger this action from the button's `onPressed` callback.

### What is OverlayPortalController?

An `OverlayPortalController` is a simple object that provides methods to manage the visibility and paint order of the `OverlayPortal`'s overlay child. It has three main actions:

*   **`show()`**: Makes the overlay child widget built by the `OverlayPortal`'s `overlayChildBuilder` appear on the [Overlay](01_overlay_.md). If it's already showing, calling `show()` again brings it to the very top of the overlay stack (above other things controlled by different OverlayPortals).
*   **`hide()`**: Hides the overlay child widget. It will be removed from the [Overlay](01_overlay_.md).
*   **`toggle()`**: Switches the state. If it's hidden, it shows it. If it's showing, it hides it.

It also has a property:

*   **`isShowing`**: A boolean (`true` or `false`) that tells you if the overlay child is currently visible on the [Overlay](01_overlay_.md) via this controller.

### Creating and Using an OverlayPortalController

You need to create an instance of `OverlayPortalController`. Since the controller holds the state of whether the overlay is showing or not, it should typically live in a `State` object.

```dart
// Inside a StatefulWidget's State class:
class _MyWidgetState extends State<MyWidget> {
  // Create the controller
  final OverlayPortalController _contextMenuController = OverlayPortalController();

  // Remember to dispose of the controller when the State is disposed
  @override
  void dispose() {
    _contextMenuController.dispose(); // Necessary cleanup!
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    // ... button and OverlayPortal will go here ...
    return Scaffold( // Example wrapper
      appBar: AppBar(title: const Text('Overlay Portal Example')),
      body: Center( // Center the button
        child: OverlayPortal(
          // Provide the controller to the OverlayPortal!
          controller: _contextMenuController,
          overlayChildBuilder: (BuildContext context) {
            // This is the widget that will show on the Overlay
            // We'll refine positioning later, for now a placeholder:
            Offset buttonPosition = const Offset(100, 100); // Placeholder
            return Positioned(
              top: buttonPosition.dy,
              left: buttonPosition.dx,
              child: Material(
                elevation: 4.0,
                child: Container(
                  padding: const EdgeInsets.all(8.0),
                  color: Colors.yellow[100],
                  child: const Text('Context Menu!'),
                ),
              ),
            );
          },
          // The button we tap to show/hide the menu
          child: ElevatedButton(
            onPressed: () {
              // Use the controller to toggle the menu!
              _contextMenuController.toggle();
            },
            child: const Text('Show/Hide Menu'),
          ),
        ),
      ),
    );
  }
}
```

In this code snippet:

1.  We declare a `final OverlayPortalController _contextMenuController` within our `_MyWidgetState`. It's `final` because we create the controller once.
2.  **Crucially, we call `_contextMenuController.dispose()` in the `dispose()` method of the state.** This is important cleanup to release resources when the widget and its state are removed.
3.  We pass this `_contextMenuController` to the `OverlayPortal` widget using the `controller:` property. This establishes the link between the remote control and the device.
4.  Inside the `onPressed` callback of the `ElevatedButton` (which is the `child` of the `OverlayPortal`), we simply call `_contextMenuController.toggle()`.

Now, when you tap the button, the `toggle()` method on the controller is called. The `OverlayPortal` linked to this controller sees this, and if it wasn't showing, it triggers the creation and display of the widget from its `overlayChildBuilder` onto the [Overlay](01_overlay_.md)! Tapping again calls `toggle()` again, sees it's showing, and calls `hide()`, removing the widget.

### Positioning the Overlay Child

In the example above, our context menu appears at a fixed `Positioned(top: 100, left: 100)`. This isn't very useful for a context menu that should appear next to the button that triggered it.

The `BuildContext` given to the `overlayChildBuilder` is very helpful here. It represents the context *at the location of the `OverlayPortal`*. We can use this context to find the position of the `OverlayPortal` (and thus the button, since it's its child) on the screen!

1.  We need to get the `RenderBox` of the `OverlayPortal`. We can use a `GlobalKey` for this.
2.  We can then use the `localToGlobal` method on the `RenderBox` to find its position relative to the entire screen (or the [Overlay](01_overlay_.md)).

```dart
// Inside a StatefulWidget's State class:
class _MyWidgetState extends State<MyWidget> {
  final OverlayPortalController _contextMenuController = OverlayPortalController();
  // Add a GlobalKey to get the RenderBox of the button/OverlayPortal
  final GlobalKey _buttonKey = GlobalKey();

  @override
  void dispose() {
    _contextMenuController.dispose();
    super.dispose();
  }

  void _showMenu() {
    if (_buttonKey.currentContext != null) {
      // Get the RenderBox of the widget associated with the key
      final RenderBox renderBox = _buttonKey.currentContext!.findRenderObject() as RenderBox;
      // Get the position of the *top-left* corner of the button
      final Offset buttonPosition = renderBox.localToGlobal(Offset.zero);
      // Get the size of the button
      final Size buttonSize = renderBox.size;

      // We'll need the position and size in the overlayChildBuilder
      // How to pass this info? We can store it in the State.
      // Let's update the builder to use state variables.

      // Now, tell the controller to show the overlay
      _contextMenuController.show(); // Use show instead of toggle for clearer logic
    }
  }

  // Need variables to store the button's position and size
  Offset _buttonPosition = Offset.zero;
  Size _buttonSize = Size.zero;

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(title: const Text('Overlay Portal Example')),
      body: Center(
        child: OverlayPortal(
          controller: _contextMenuController,
          overlayChildBuilder: (BuildContext context) {
            // Use the stored position and size to position the menu
            // Let's place the menu just below the button
            return Positioned(
              // Place the top of the menu at the bottom of the button
              top: _buttonPosition.dy + _buttonSize.height,
              // Align the left edge of the menu with the left edge of the button
              left: _buttonPosition.dx,
              child: Material(
                elevation: 4.0,
                child: Container(
                  padding: const EdgeInsets.all(8.0),
                  color: Colors.yellow[100],
                  child: const Text('Context Menu!'),
                ),
              ),
            );
          },
          // Wrap the child (the button) with the GlobalKey and onPressed that calls _showMenu
          child: SizedBox( // Use SizedBox to apply the key directly
            key: _buttonKey, // Attach the key here!
            child: ElevatedButton(
              onPressed: _showMenu, // Call our _showMenu function
              child: const Text('Show Menu'),
            ),
          ),
        ),
      ),
    );
  }
}
```

Now, our `_showMenu` function finds the button's position on the screen using the `_buttonKey`, stores this position and size in state variables, and then calls `_contextMenuController.show()`. The `overlayChildBuilder` then uses these state variables (`_buttonPosition` and `_buttonSize`) to calculate where to place the `Positioned` widget, making the menu appear right below the button.

To hide the menu, you'd typically add a tap detector outside the menu or a close button within the menu that calls `_contextMenuController.hide()`.

```dart
// Add this helper function to hide the menu
void _hideMenu() {
   _contextMenuController.hide();
}

// Update the overlayChildBuilder to include a GestureDetector to hide taps outside the menu
overlayChildBuilder: (BuildContext context) {
  return Stack( // Use a Stack to layer the tap catcher below the menu
    children: [
      Positioned.fill(
         // A transparent widget that catches taps outside the menu content
         child: GestureDetector(
           onTap: _hideMenu, // Hide the menu when tapped outside
           behavior: HitTestBehavior.translucent, // Ensure it catches taps
         ),
      ),
      Positioned(
         top: _buttonPosition.dy + _buttonSize.height,
         left: _buttonPosition.dx,
         child: Material(
           elevation: 4.0,
           child: Container(
             padding: const EdgeInsets.all(8.0),
             color: Colors.yellow[100],
             child: const Text('Context Menu!'),
           ),
         ),
      ),
    ],
  );
},
```

This updated `overlayChildBuilder` wraps the `Positioned` menu inside a `Stack`. A `Positioned.fill` `GestureDetector` is placed on top of the entire overlay area (filling the [Overlay](01_overlay_.md)). This transparent detector catches taps *anywhere* on the overlay that isn't blocked by the menu itself and calls `_hideMenu`, making the menu disappear when the user taps outside of it.

### How OverlayPortalController Works Internally

When you call `_contextMenuController.show()` or `_contextMenuController.hide()`:

1.  The `OverlayPortalController` communicates with the `_OverlayPortalState` object it's currently attached to.
2.  The `_OverlayPortalState` updates its internal state, specifically the `_zOrderIndex` variable. `show()` sets this to a new unique timestamp (using `_now()`), `hide()` sets it to `null`.
3.  Updating this state triggers a `setState()` call within the `_OverlayPortalState`.
4.  `setState()` tells the Flutter framework that the `_OverlayPortalState` needs to rebuild.
5.  During the rebuild, the `_OverlayPortalState`'s `build` method checks the `_zOrderIndex`:
    *   If it's `null`, it returns a version of the internal `_OverlayPortal` widget that doesn't include the overlay child (`overlayChild: null`).
    *   If it's not `null`, it returns the `_OverlayPortal` widget with the `overlayChildBuilder`'s widget included (`overlayChild: _DeferredLayout(...)`).
6.  When the framework processes this update, if the `overlayChild` has changed from `null` to a widget (or vice-versa), the corresponding render objects are attached/detached from the ancestor [Overlay]'s [_RenderTheater](07__renderdeferredlayoutbox_.md) render tree. The `_zOrderIndex` is used to determine the correct paint order.

Sequence diagram for calling `show()`:

```mermaid
sequenceDiagram
    participant YourWidget
    participant OverlayPortalController
    participant _OverlayPortalState
    participant Framework as Flutter Framework
    participant OverlayPortalBuild as OverlayPortal.build()
    participant _OverlayPortalElement
    participant _RenderTheater as Overlay Render Tree

    YourWidget->>OverlayPortalController: call show()
    OverlayPortalController->>_OverlayPortalState: update internal state (_zOrderIndex)
    _OverlayPortalState->>Framework: call setState()
    Framework->>_OverlayPortalState: schedule rebuild
    Framework->>_OverlayPortalState: call build()
    _OverlayPortalState->>OverlayPortalBuild: return Widget with overlay child
    OverlayPortalBuild->>_OverlayPortalElement: process widget update
    _OverlayPortalElement->>_RenderTheater: attach/position overlay child render object
    _RenderTheater->>_RenderTheater: paint child on overlay
```

The internal code snippets showed that `_OverlayPortalState` indeed has a `_zOrderIndex` and methods like `show` and `hide` that call `setState`. The `build` method's critical part is checking if `_zOrderIndex == null` to decide whether to include the `overlayChild`.

```dart
// From packages/flutter/lib/src/widgets/overlay.dart -> _OverlayPortalState
void show(int zOrderIndex) {
  // ... asserts ...
  setState(() {
    _zOrderIndex = zOrderIndex; // Update state triggers rebuild
  });
  // ... invalidate location cache ...
}

void hide() {
  // ... asserts ...
  setState(() {
    _zOrderIndex = null; // Update state triggers rebuild
  });
  // ... invalidate location cache ...
}

@override
Widget build(BuildContext context) {
  final int? zOrderIndex = _zOrderIndex; // Check the state variable
  if (zOrderIndex == null) {
    return _OverlayPortal(overlayLocation: null, overlayChild: null, child: widget.child);
  }
  // ... build with overlay child if zOrderIndex is not null ...
  return _OverlayPortal(
    // ...
    overlayChild: _DeferredLayout(child: Builder(builder: widget.overlayChildBuilder)),
    // ...
  );
}
```

This confirms our understanding: the `OverlayPortalController` is just a thin wrapper forwarding commands to the `_OverlayPortalState`, which manages the visibility state (`_zOrderIndex`) and rebuilds itself to reflect that state change in the widget tree structure passed to the framework. The actual attachment/detachment of the render object happens deeper within the element tree logic triggered by the `_OverlayPortal` widget.

### Conclusion

In this chapter, we completed our understanding of the `OverlayPortal` pattern by introducing the `OverlayPortalController`. We learned that this controller acts as the remote control, using its `show()`, `hide()`, and `toggle()` methods to signal to the linked `OverlayPortal` when to display or hide its overlay child. We saw how to create a controller, link it to an `OverlayPortal`, use it in a button's `onPressed`, and importantly, how to dispose of it. We also improved our context menu example by using a `GlobalKey` and the `BuildContext` to position the overlay child relative to the trigger widget. Finally, we confirmed our understanding by looking at the internal code where the controller updates the `_OverlayPortalState`'s `_zOrderIndex`, triggering a rebuild.

With `OverlayPortal` and `OverlayPortalController`, you can elegantly manage temporary widgets that appear on the global [Overlay](01_overlay_.md) while keeping them conceptually linked to their origins.

In the next chapter, we'll take a very brief look at the [_Theater](06__theater_.md) widget, which we've seen mentioned multiple times as the internal widget used by the [OverlayState](02_overlaystate_.md) to manage the display of its children.

[_Theater](06__theater_.md)

Relevant Code Snippets (Code itself remains unchanged):
--- File: packages/flutter/lib/src/widgets/overlay.dart ---
// Copyright 2014 The Flutter Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

/// @docImport 'package:flutter/cupertino.dart';
/// @docImport 'package:flutter/material.dart';
///
/// @docImport 'app.dart';
/// @docImport 'drag_target.dart';
/// @docImport 'implicit_animations.dart';
/// @docImport 'media_query.dart';
/// @docImport 'navigator.dart';
/// @docImport 'routes.dart';
/// @docImport 'scroll_view.dart';
/// @docImport 'sliver.dart';
/// @docImport 'text.dart';
library;

import 'dart:collection';

import 'package:flutter/foundation.dart';
import 'package:flutter/rendering.dart';
import 'package:flutter/scheduler.dart';

import 'basic.dart';
import 'framework.dart';
import 'lookup_boundary.dart';
import 'ticker_provider.dart';

const String _flutterWidgetsLibrary = 'package:flutter/widgets.dart';

// Examples can assume:
// late BuildContext context;

// * OverlayEntry Implementation

/// A place in an [Overlay] that can contain a widget.
///
/// Overlay entries are inserted into an [Overlay] using the
/// [OverlayState.insert] or [OverlayState.insertAll] functions. To find the
/// closest enclosing overlay for a given [BuildContext], use the [Overlay.of]
/// function.
///
/// An overlay entry can be in at most one overlay at a time. To remove an entry
/// from its overlay, call the [remove] function on the overlay entry.
///
/// Because an [Overlay] uses a [Stack] layout, overlay entries can use
/// [Positioned] and [AnimatedPositioned] to position themselves within the
/// overlay.
///
/// For example, [Draggable] uses an [OverlayEntry] to show the drag avatar that
/// follows the user's finger across the screen after the drag begins. Using the
/// overlay to display the drag avatar lets the avatar float over the other
/// widgets in the app. As the user's finger moves, draggable calls
/// [markNeedsBuild] on the overlay entry to cause it to rebuild. In its build,
/// the entry includes a [Positioned] with its top and left property set to
/// position the drag avatar near the user's finger. When the drag is over,
/// [Draggable] removes the entry from the overlay to remove the drag avatar
/// from view.
///
/// By default, if there is an entirely [opaque] entry over this one, then this
/// one will not be included in the widget tree (in particular, stateful widgets
/// within the overlay entry will not be instantiated). To ensure that your
/// overlay entry is still built even if it is not visible, set [maintainState]
/// to true. This is more expensive, so should be done with care. In particular,
/// if widgets in an overlay entry with [maintainState] set to true repeatedly
/// call [State.setState], the user's battery will be drained unnecessarily.
///
/// [OverlayEntry] is a [Listenable] that notifies when the widget built by
/// [builder] is mounted or unmounted, whose exact state can be queried by
/// [mounted]. After the owner of the [OverlayEntry] calls [remove] and then
/// [dispose], the widget may not be immediately removed from the widget tree.
/// As a result listeners of the [OverlayEntry] can get notified for one last
/// time after the [dispose] call, when the widget is eventually unmounted.
///
/// {@macro flutter.widgets.overlayPortalVsOverlayEntry}
///
/// See also:
///
///  * [OverlayPortal], an alternative API for inserting widgets into an
///    [Overlay] using a builder callback.
///  * [Overlay], a stack of entries that can be managed independently.
///  * [OverlayState], the current state of an Overlay.
///  * [WidgetsApp], a convenience widget that wraps a number of widgets that
///    are commonly required for an application.
///  * [MaterialApp], a convenience widget that wraps a number of widgets that
///    are commonly required for Material Design applications.
class OverlayEntry implements Listenable {
  /// Creates an overlay entry.
  ///
  /// To insert the entry into an [Overlay], first find the overlay using
  /// [Overlay.of] and then call [OverlayState.insert]. To remove the entry,
  /// call [remove] on the overlay entry itself.
  OverlayEntry({
    required this.builder,
    bool opaque = false,
    bool maintainState = false,
    this.canSizeOverlay = false,
  }) : _opaque = opaque,
       _maintainState = maintainState {
    if (kFlutterMemoryAllocationsEnabled) {
      _maybeDispatchObjectCreation();
    }
  }

  /// This entry will include the widget built by this builder in the overlay at
  /// the entry's position.
  ///
  /// To cause this builder to be called again, call [markNeedsBuild] on this
  /// overlay entry.
  final WidgetBuilder builder;

  /// Whether this entry occludes the entire overlay.
  ///
  /// If an entry claims to be opaque, then, for efficiency, the overlay will
  /// skip building entries below that entry unless they have [maintainState]
  /// set.
  bool get opaque => _opaque;
  bool _opaque;
  set opaque(bool value) {
    assert(!_disposedByOwner);
    if (_opaque == value) {
      return;
    }
    _opaque = value;
    _overlay?._didChangeEntryOpacity();
  }

  /// Whether this entry must be included in the tree even if there is a fully
  /// [opaque] entry above it.
  ///
  /// By default, if there is an entirely [opaque] entry over this one, then this
  /// one will not be included in the widget tree (in particular, stateful widgets
  /// within the overlay entry will not be instantiated). To ensure that your
  /// overlay entry is still built even if it is not visible, set [maintainState]
  /// to true. This is more expensive, so should be done with care. In particular,
  /// if widgets in an overlay entry with [maintainState] set to true repeatedly
  /// call [State.setState], the user's battery will be drained unnecessarily.
  ///
  /// This is used by the [Navigator] and [Route] objects to ensure that routes
  /// are kept around even when in the background, so that [Future]s promised
  /// from subsequent routes will be handled properly when they complete.
  bool get maintainState => _maintainState;
  bool _maintainState;
  set maintainState(bool value) {
    assert(!_disposedByOwner);
    if (_maintainState == value) {
      return;
    }
    _maintainState = value;
    assert(_overlay != null);
    _overlay!._didChangeEntryOpacity();
  }

  /// Whether the content of this [OverlayEntry] can be used to size the
  /// [Overlay].
  ///
  /// In most situations the overlay sizes itself based on its incoming
  /// constraints to be as large as possible. However, if that would result in
  /// an infinite size, it has to rely on one of its children to size itself. In
  /// this situation, the overlay will consult the topmost non-[Positioned]
  /// overlay entry that has this property set to true, lay it out with the
  /// incoming [BoxConstraints] of the overlay, and force all other
  /// non-[Positioned] overlay entries to have the same size. The [Positioned]
  /// entries are laid out as usual based on the calculated size of the overlay.
  ///
  /// Overlay entries that set this to true must be able to handle unconstrained
  /// [BoxConstraints].
  ///
  /// Setting this to true has no effect if the overlay entry uses a [Positioned]
  /// widget to position itself in the overlay.
  final bool canSizeOverlay;

  /// Whether the [OverlayEntry] is currently mounted in the widget tree.
  ///
  /// The [OverlayEntry] notifies its listeners when this value changes.
  bool get mounted => _overlayEntryStateNotifier?.value != null;

  /// The currently mounted `_OverlayEntryWidgetState` built using this [OverlayEntry].
  ValueNotifier<_OverlayEntryWidgetState?>? _overlayEntryStateNotifier =
      ValueNotifier<_OverlayEntryWidgetState?>(null);

  // TODO(polina-c): stop duplicating code across disposables
  // https://github.com/flutter/flutter/issues/137435
  /// Dispatches event of object creation to [FlutterMemoryAllocations.instance].
  void _maybeDispatchObjectCreation() {
    if (kFlutterMemoryAllocationsEnabled) {
      FlutterMemoryAllocations.instance.dispatchObjectCreated(
        library: _flutterWidgetsLibrary,
        className: '$OverlayEntry',
        object: this,
      );
    }
  }

  @override
  void addListener(VoidCallback listener) {
    assert(!_disposedByOwner);
    _overlayEntryStateNotifier?.addListener(listener);
  }

  @override
  void removeListener(VoidCallback listener) {
    _overlayEntryStateNotifier?.removeListener(listener);
  }

  OverlayState? _overlay;
  final GlobalKey<_OverlayEntryWidgetState> _key = GlobalKey<_OverlayEntryWidgetState>();

  /// Remove this entry from the overlay.
  ///
  /// This should only be called once.
  ///
  /// This method removes this overlay entry from the overlay immediately. The
  /// UI will be updated in the same frame if this method is called before the
  /// overlay rebuild in this frame; otherwise, the UI will be updated in the
  /// next frame. This means that it is safe to call during builds, but also
  /// that if you do call this after the overlay rebuild, the UI will not update
  /// until the next frame (i.e. many milliseconds later).
  void remove() {
    assert(_overlay != null);
    assert(!_disposedByOwner);
    final OverlayState overlay = _overlay!;
    _overlay = null;
    if (!overlay.mounted) {
      return;
    }

    overlay._entries.remove(this);
    if (SchedulerBinding.instance.schedulerPhase == SchedulerPhase.persistentCallbacks) {
      SchedulerBinding.instance.addPostFrameCallback((Duration duration) {
        overlay._markDirty();
      }, debugLabel: 'OverlayEntry.markDirty');
    } else {
      overlay._markDirty();
    }
  }

  /// Cause this entry to rebuild during the next pipeline flush.
  ///
  /// You need to call this function if the output of [builder] has changed.
  void markNeedsBuild() {
    assert(!_disposedByOwner);
    _key.currentState?._markNeedsBuild();
  }

  void _didUnmount() {
    assert(!mounted);
    if (_disposedByOwner) {
      _overlayEntryStateNotifier?.dispose();
      _overlayEntryStateNotifier = null;
    }
  }

  bool _disposedByOwner = false;

  /// Discards any resources used by this [OverlayEntry].
  ///
  /// This method must be called after [remove] if the [OverlayEntry] is
  /// inserted into an [Overlay].
  ///
  /// After this is called, the object is not in a usable state and should be
  /// discarded (calls to [addListener] will throw after the object is disposed).
  /// However, the listeners registered may not be immediately released until
  /// the widget built using this [OverlayEntry] is unmounted from the widget
  /// tree.
  ///
  /// This method should only be called by the object's owner.
  void dispose() {
    assert(!_disposedByOwner);
    assert(
      _overlay == null,
      'An OverlayEntry must first be removed from the Overlay before dispose is called.',
    );
    if (kFlutterMemoryAllocationsEnabled) {
      FlutterMemoryAllocations.instance.dispatchObjectDisposed(object: this);
    }
    _disposedByOwner = true;
    if (!mounted) {
      // If we're still mounted when disposed, then this will be disposed in
      // _didUnmount, to allow notifications to occur until the entry is
      // unmounted.
      _overlayEntryStateNotifier?.dispose();
      _overlayEntryStateNotifier = null;
    }
  }

  @override
  String toString() =>
      '${describeIdentity(this)}(opaque: $opaque; maintainState: $maintainState)${_disposedByOwner ? "(DISPOSED)" : ""}';
}

class _OverlayEntryWidget extends StatefulWidget {
  const _OverlayEntryWidget({
    required Key super.key,
    required this.entry,
    required this.overlayState,
    this.tickerEnabled = true,
  });

  final OverlayEntry entry;
  final OverlayState overlayState;
  final bool tickerEnabled;

  @override
  _OverlayEntryWidgetState createState() => _OverlayEntryWidgetState();
}

class _OverlayEntryWidgetState extends State<_OverlayEntryWidget> {
  late _RenderTheater _theater;

  // Manages the stack of theater children whose paint order are sorted by their
  // _zOrderIndex. The children added by OverlayPortal are added to this linked
  // list, and they will be shown _above_ the OverlayEntry tied to this widget.
  // The children with larger zOrderIndex values (i.e. those called `show`
  // recently) will be painted last.
  //
  // This linked list is lazily created in `_add`, and the entries are added/removed
  // via `_add`/`_remove`, called by OverlayPortals lower in the tree. `_add` or
  // `_remove` does not cause this widget to rebuild, the linked list will be
  // read by _RenderTheater as part of its render child model. This would ideally
  // be in a RenderObject but there may not be RenderObjects between
  // _RenderTheater and the render subtree OverlayEntry builds.
  LinkedList<_OverlayEntryLocation>? _sortedTheaterSiblings;

  // Worst-case O(N), N being the number of children added to the top spot in
  // the same frame. This can be a bit expensive when there's a lot of global
  // key reparenting in the same frame but N is usually a small number.
  void _add(_OverlayEntryLocation child) {
    assert(mounted);
    final LinkedList<_OverlayEntryLocation> children =
        _sortedTheaterSiblings ??= LinkedList<_OverlayEntryLocation>();
    assert(!children.contains(child));
    _OverlayEntryLocation? insertPosition = children.isEmpty ? null : children.last;
    while (insertPosition != null && insertPosition._zOrderIndex > child._zOrderIndex) {
      insertPosition = insertPosition.previous;
    }
    if (insertPosition == null) {
      children.addFirst(child);
    } else {
      insertPosition.insertAfter(child);
    }
    assert(children.contains(child));
  }

  void _remove(_OverlayEntryLocation child) {
    assert(_sortedTheaterSiblings != null);
    final bool wasInCollection = _sortedTheaterSiblings?.remove(child) ?? false;
    assert(wasInCollection);
  }

  // Returns an Iterable that traverse the children in the child model in paint
  // order (from farthest to the user to the closest to the user).
  //
  // The iterator should be safe to use even when the child model is being
  // mutated. The reason for that is it's allowed to add/remove/move deferred
  // children to a _RenderTheater during performLayout, but the affected
  // children don't have to be laid out in the same performLayout call.
  late final Iterable<RenderBox> _paintOrderIterable = _createChildIterable(reversed: false);
  // An Iterable that traverse the children in the child model in
  // hit-test order (from closest to the user to the farthest to the user).
  late final Iterable<RenderBox> _hitTestOrderIterable = _createChildIterable(reversed: true);

  // The following uses sync* because hit-testing is lazy, and LinkedList as a
  // Iterable doesn't support concurrent modification.
  Iterable<RenderBox> _createChildIterable({required bool reversed}) sync* {
    final LinkedList<_OverlayEntryLocation>? children = _sortedTheaterSiblings;
    if (children == null || children.isEmpty) {
      return;
    }
    _OverlayEntryLocation? candidate = reversed ? children.last : children.first;
    while (candidate != null) {
      final RenderBox? renderBox = candidate._overlayChildRenderBox;
      candidate = reversed ? candidate.previous : candidate.next;
      if (renderBox != null) {
        yield renderBox;
      }
    }
  }

  @override
  void initState() {
    super.initState();
    widget.entry._overlayEntryStateNotifier!.value = this;
    _theater = context.findAncestorRenderObjectOfType<_RenderTheater>()!;
    assert(_sortedTheaterSiblings == null);
  }

  @override
  void didUpdateWidget(_OverlayEntryWidget oldWidget) {
    super.didUpdateWidget(oldWidget);
    // OverlayState's build method always returns a RenderObjectWidget _Theater,
    // so it's safe to assume that state equality implies render object equality.
    assert(oldWidget.entry == widget.entry);
    if (oldWidget.overlayState != widget.overlayState) {
      final _RenderTheater newTheater = context.findAncestorRenderObjectOfType<_RenderTheater>()!;
      assert(_theater != newTheater);
      _theater = newTheater;
    }
  }

  @override
  void dispose() {
    widget.entry._overlayEntryStateNotifier?.value = null;
    widget.entry._didUnmount();
    _sortedTheaterSiblings = null;
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    return TickerMode(
      enabled: widget.tickerEnabled,
      child: _RenderTheaterMarker(
        theater: _theater,
        overlayEntryWidgetState: this,
        child: widget.entry.builder(context),
      ),
    );
  }

  void _markNeedsBuild() {
    setState(() {
      /* the state that changed is in the builder */
    });
  }
}

/// A stack of entries that can be managed independently.
///
/// Overlays let independent child widgets "float" visual elements on top of
/// other widgets by inserting them into the overlay's stack. The overlay lets
/// each of these widgets manage their participation in the overlay using
/// [OverlayEntry] objects.
///
/// Although you can create an [Overlay] directly, it's most common to use the
/// overlay created by the [Navigator] in a [WidgetsApp], [CupertinoApp] or a
/// [MaterialApp]. The navigator uses its overlay to manage the visual
/// appearance of its routes.
///
/// The [Overlay] widget uses a custom stack implementation, which is very
/// similar to the [Stack] widget. The main use case of [Overlay] is related to
/// navigation and being able to insert widgets on top of the pages in an app.
/// For layout purposes unrelated to navigation, consider using [Stack] instead.
///
/// An [Overlay] widget requires a [Directionality] widget to be in scope, so
/// that it can resolve direction-sensitive coordinates of any
/// [Positioned.directional] children.
///
/// For widgets drawn in an [OverlayEntry], do not assume that the size of the
/// [Overlay] is the size returned by [MediaQuery.sizeOf]. Nested overlays can
/// have different sizes.
///
/// {@tool dartpad}
/// This example shows how to use the [Overlay] to highlight the [NavigationBar]
/// destination.
///
/// ** See code in examples/api/lib/widgets/overlay/overlay.0.dart **
/// {@end-tool}
///
/// See also:
///
///  * [OverlayEntry], the class that is used for describing the overlay entries.
///  * [OverlayState], which is used to insert the entries into the overlay.
///  * [WidgetsApp], which inserts an [Overlay] widget indirectly via its [Navigator].
///  * [MaterialApp], which inserts an [Overlay] widget indirectly via its [Navigator].
///  * [CupertinoApp], which inserts an [Overlay] widget indirectly via its [Navigator].
///  * [Stack], which allows directly displaying a stack of widgets.
class Overlay extends StatefulWidget {
  /// Creates an overlay.
  ///
  /// The initial entries will be inserted into the overlay when its associated
  /// [OverlayState] is initialized.
  ///
  /// Rather than creating an overlay, consider using the overlay that is
  /// created by the [Navigator] in a [WidgetsApp], [CupertinoApp], or a
  /// [MaterialApp] for the application.
  const Overlay({
    super.key,
    this.initialEntries = const <OverlayEntry>[],
    this.clipBehavior = Clip.hardEdge,
  });

  /// Wrap the provided `child` in an [Overlay] to allow other visual elements
  /// (packed in [OverlayEntry]s) to float on top of the child.
  ///
  /// This is a convenience method over the regular [Overlay] constructor: It
  /// creates an [Overlay] and puts the provided `child` in an [OverlayEntry]
  /// at the bottom of that newly created Overlay.
  static Widget wrap({Key? key, Clip clipBehavior = Clip.hardEdge, required Widget child}) {
    return _WrappingOverlay(key: key, clipBehavior: clipBehavior, child: child);
  }

  /// The entries to include in the overlay initially.
  ///
  /// These entries are only used when the [OverlayState] is initialized. If you
  /// are providing a new [Overlay] description for an overlay that's already in
  /// the tree, then the new entries are ignored.
  ///
  /// To add entries to an [Overlay] that is already in the tree, use
  /// [Overlay.of] to obtain the [OverlayState] (or assign a [GlobalKey] to the
  /// [Overlay] widget and obtain the [OverlayState] via
  /// [GlobalKey.currentState]), and then use [OverlayState.insert] or
  /// [OverlayState.insertAll].
  ///
  /// To remove an entry from an [Overlay], use [OverlayEntry.remove].
  final List<OverlayEntry> initialEntries;

  /// {@macro flutter.material.Material.clipBehavior}
  ///
  /// Defaults to [Clip.hardEdge].
  final Clip clipBehavior;

  /// The [OverlayState] from the closest instance of [Overlay] that encloses
  /// the given context within the closest [LookupBoundary], and, in debug mode,
  /// will throw if one is not found.
  ///
  /// In debug mode, if the `debugRequiredFor` argument is provided and an
  /// overlay isn't found, then this function will throw an exception containing
  /// the runtime type of the given widget in the error message. The exception
  /// attempts to explain that the calling [Widget] (the one given by the
  /// `debugRequiredFor` argument) needs an [Overlay] to be present to function.
  /// If `debugRequiredFor` is not supplied, then the error message is more
  /// generic.
  ///
  /// Typical usage is as follows:
  ///
  /// ```dart
  /// OverlayState overlay = Overlay.of(context);
  /// ```
  ///
  /// If `rootOverlay` is set to true, the state from the furthest instance of
  /// this class is given instead. Useful for installing overlay entries above
  /// all subsequent instances of [Overlay].
  ///
  /// This method can be expensive (it walks the element tree).
  ///
  /// See also:
  ///
  /// * [Overlay.maybeOf] for a similar function that returns null if an
  ///   [Overlay] is not found.
  static OverlayState of(
    BuildContext context, {
    bool rootOverlay = false,
    Widget? debugRequiredFor,
  }) {
    final OverlayState? result = maybeOf(context, rootOverlay: rootOverlay);
    assert(() {
      if (result == null) {
        final bool hiddenByBoundary = LookupBoundary.debugIsHidingAncestorStateOfType<OverlayState>(
          context,
        );
        final List<DiagnosticsNode> information = <DiagnosticsNode>[
          ErrorSummary(
            'No Overlay widget found${hiddenByBoundary ? ' within the closest LookupBoundary' : ''}.',
          ),
          if (hiddenByBoundary)
            ErrorDescription(
              'There is an ancestor Overlay widget, but it is hidden by a LookupBoundary.',
            ),
          ErrorDescription(
            '${debugRequiredFor?.runtimeType ?? 'Some'} widgets require an Overlay widget ancestor for correct operation.',
          ),
          ErrorHint(
            'The most common way to add an Overlay to an application is to include a MaterialApp, CupertinoApp or Navigator widget in the runApp() call.',
          ),
          if (debugRequiredFor != null)
            DiagnosticsProperty<Widget>(
              'The specific widget that failed to find an overlay was',
              debugRequiredFor,
              style: DiagnosticsTreeStyle.errorProperty,
            ),
          if (context.widget != debugRequiredFor)
            context.describeElement(
              'The context from which that widget was searching for an overlay was',
            ),
        ];

        throw FlutterError.fromParts(information);
      }
      return true;
    }());
    return result!;
  }

  /// The [OverlayState] from the closest instance of [Overlay] that encloses
  /// the given context within the closest [LookupBoundary], if any.
  ///
  /// Typical usage is as follows:
  ///
  /// ```dart
  /// OverlayState? overlay = Overlay.maybeOf(context);
  /// ```
  ///
  /// If `rootOverlay` is set to true, the state from the furthest instance of
  /// this class is given instead. Useful for installing overlay entries above
  /// all subsequent instances of [Overlay].
  ///
  /// This method can be expensive (it walks the element tree).
  ///
  /// See also:
  ///
  ///  * [Overlay.of] for a similar function that returns a non-nullable result
  ///    and throws if an [Overlay] is not found.

  static OverlayState? maybeOf(BuildContext context, {bool rootOverlay = false}) {
    return rootOverlay
        ? LookupBoundary.findRootAncestorStateOfType<OverlayState>(context)
        : LookupBoundary.findAncestorStateOfType<OverlayState>(context);
  }

  @override
  OverlayState createState() => OverlayState();
}

/// The current state of an [Overlay].
///
/// Used to insert [OverlayEntry]s into the overlay using the [insert] and
/// [insertAll] functions.
class OverlayState extends State<Overlay> with TickerProviderStateMixin {
  final List<OverlayEntry> _entries = <OverlayEntry>[];

  @protected
  @override
  void initState() {
    super.initState();
    insertAll(widget.initialEntries);
  }

  int _insertionIndex(OverlayEntry? below, OverlayEntry? above) {
    assert(above == null || below == null);
    if (below != null) {
      return _entries.indexOf(below);
    }
    if (above != null) {
      return _entries.indexOf(above) + 1;
    }
    return _entries.length;
  }

  bool _debugCanInsertEntry(OverlayEntry entry) {
    final List<DiagnosticsNode> operandsInformation = <DiagnosticsNode>[
      DiagnosticsProperty<OverlayEntry>(
        'The OverlayEntry was',
        entry,
        style: DiagnosticsTreeStyle.errorProperty,
      ),
      DiagnosticsProperty<OverlayState>(
        'The Overlay the OverlayEntry was trying to insert to was',
        this,
        style: DiagnosticsTreeStyle.errorProperty,
      ),
    ];

    if (!mounted) {
      throw FlutterError.fromParts(<DiagnosticsNode>[
        ErrorSummary('Attempted to insert an OverlayEntry to an already disposed Overlay.'),
        ...operandsInformation,
      ]);
    }

    final OverlayState? currentOverlay = entry._overlay;
    final bool alreadyContainsEntry = _entries.contains(entry);

    if (alreadyContainsEntry) {
      final bool inconsistentOverlayState = !identical(currentOverlay, this);
      throw FlutterError.fromParts(<DiagnosticsNode>[
        ErrorSummary('The specified entry is already present in the target Overlay.'),
        ...operandsInformation,
        if (inconsistentOverlayState)
          ErrorHint('This could be an error in the Flutter framework.')
        else
          ErrorHint(
            'Consider calling remove on the OverlayEntry before inserting it to a different Overlay, '
            'or switching to the OverlayPortal API to avoid manual OverlayEntry management.',
          ),
        if (inconsistentOverlayState)
          DiagnosticsProperty<OverlayState>(
            "The OverlayEntry's current Overlay was",
            currentOverlay,
            style: DiagnosticsTreeStyle.errorProperty,
          ),
      ]);
    }

    if (currentOverlay == null) {
      return true;
    }

    throw FlutterError.fromParts(<DiagnosticsNode>[
      ErrorSummary('The specified entry is already present in a different Overlay.'),
      ...operandsInformation,
      DiagnosticsProperty<OverlayState>(
        "The OverlayEntry's current Overlay was",
        currentOverlay,
        style: DiagnosticsTreeStyle.errorProperty,
      ),
      ErrorHint(
        'Consider calling remove on the OverlayEntry before inserting it to a different Overlay, '
        'or switching to the OverlayPortal API to avoid manual OverlayEntry management.',
      ),
    ]);
  }

  /// Insert the given entry into the overlay.
  ///
  /// If `below` is non-null, the entry is inserted just below `below`.
  /// If `above` is non-null, the entry is inserted just above `above`.
  /// Otherwise, the entry is inserted on top.
  ///
  /// It is an error to specify both `above` and `below`.
  void insert(OverlayEntry entry, {OverlayEntry? below, OverlayEntry? above}) {
    assert(_debugVerifyInsertPosition(above, below));
    assert(_debugCanInsertEntry(entry));
    entry._overlay = this;
    setState(() {
      _entries.insert(_insertionIndex(below, above), entry);
    });
  }

  /// Insert all the entries in the given iterable.
  ///
  /// If `below` is non-null, the entries are inserted just below `below`.
  /// If `above` is non-null, the entries are inserted just above `above`.
  /// Otherwise, the entries are inserted on top.
  ///
  /// It is an error to specify both `above` and `below`.
  void insertAll(Iterable<OverlayEntry> entries, {OverlayEntry? below, OverlayEntry? above}) {
    assert(_debugVerifyInsertPosition(above, below));
    assert(entries.every(_debugCanInsertEntry));
    if (entries.isEmpty) {
      return;
    }
    for (final OverlayEntry entry in entries) {
      assert(entry._overlay == null);
      entry._overlay = this;
    }
    setState(() {
      _entries.insertAll(_insertionIndex(below, above), entries);
    });
  }

  bool _debugVerifyInsertPosition(
    OverlayEntry? above,
    OverlayEntry? below, {
    Iterable<OverlayEntry>? newEntries,
  }) {
    assert(above == null || below == null, 'Only one of `above` and `below` may be specified.');
    assert(
      above == null ||
          (above._overlay == this &&
              _entries.contains(above) &&
              (newEntries?.contains(above) ?? true)),
      'The provided entry used for `above` must be present in the Overlay${newEntries != null ? ' and in the `newEntriesList`' : ''}.',
    );
    assert(
      below == null ||
          (below._overlay == this &&
              _entries.contains(below) &&
              (newEntries?.contains(below) ?? true)),
      'The provided entry used for `below` must be present in the Overlay${newEntries != null ? ' and in the `newEntriesList`' : ''}.',
    );
    return true;
  }

  /// Remove all the entries listed in the given iterable, then reinsert them
  /// into the overlay in the given order.
  ///
  /// Entries mention in `newEntries` but absent from the overlay are inserted
  /// as if with [insertAll].
  ///
  /// Entries not mentioned in `newEntries` but present in the overlay are
  /// positioned as a group in the resulting list relative to the entries that
  /// were moved, as specified by one of `below` or `above`, which, if
  /// specified, must be one of the entries in `newEntries`:
  ///
  /// If `below` is non-null, the group is positioned just below `below`.
  /// If `above` is non-null, the group is positioned just above `above`.
  /// Otherwise, the group is left on top, with all the rearranged entries
  /// below.
  ///
  /// It is an error to specify both `above` and `below`.
  void rearrange(Iterable<OverlayEntry> newEntries, {OverlayEntry? below, OverlayEntry? above}) {
    final List<OverlayEntry> newEntriesList =
        newEntries is List<OverlayEntry> ? newEntries : newEntries.toList(growable: false);
    assert(_debugVerifyInsertPosition(above, below, newEntries: newEntriesList));
    assert(
      newEntriesList.every(
        (OverlayEntry entry) => entry._overlay == null || entry._overlay == this,
      ),
      'One or more of the specified entries are already present in another Overlay.',
    );
    assert(
      newEntriesList.every(
        (OverlayEntry entry) => _entries.indexOf(entry) == _entries.lastIndexOf(entry),
      ),
      'One or more of the specified entries are specified multiple times.',
    );
    if (newEntriesList.isEmpty) {
      return;
    }
    if (listEquals(_entries, newEntriesList)) {
      return;
    }
    final LinkedHashSet<OverlayEntry> old = LinkedHashSet<OverlayEntry>.of(_entries);
    for (final OverlayEntry entry in newEntriesList) {
      entry._overlay ??= this;
    }
    setState(() {
      _entries.clear();
      _entries.addAll(newEntriesList);
      old.removeAll(newEntriesList);
      _entries.insertAll(_insertionIndex(below, above), old);
    });
  }

  void _markDirty() {
    if (mounted) {
      setState(() {});
    }
  }

  /// (DEBUG ONLY) Check whether a given entry is visible (i.e., not behind an
  /// opaque entry).
  ///
  /// This is an O(N) algorithm, and should not be necessary except for debug
  /// asserts. To avoid people depending on it, this function is implemented
  /// only in debug mode, and always returns false in release mode.
  bool debugIsVisible(OverlayEntry entry) {
    bool result = false;
    assert(_entries.contains(entry));
    assert(() {
      for (int i = _entries.length - 1; i > 0; i -= 1) {
        final OverlayEntry candidate = _entries[i];
        if (candidate == entry) {
          result = true;
          break;
        }
        if (candidate.opaque) {
          break;
        }
      }
      return true;
    }());
    return result;
  }

  void _didChangeEntryOpacity() {
    setState(() {
      // We use the opacity of the entry in our build function, which means we
      // our state has changed.
    });
  }

  @protected
  @override
  Widget build(BuildContext context) {
    // This list is filled backwards and then reversed below before
    // it is added to the tree.
    final List<_OverlayEntryWidget> children = <_OverlayEntryWidget>[];
    bool onstage = true;
    int onstageCount = 0;
    for (final OverlayEntry entry in _entries.reversed) {
      if (onstage) {
        onstageCount += 1;
        children.add(_OverlayEntryWidget(key: entry._key, overlayState: this, entry: entry));
        if (entry.opaque) {
          onstage = false;
        }
      } else if (entry.maintainState) {
        children.add(
          _OverlayEntryWidget(
            key: entry._key,
            overlayState: this,
            entry: entry,
            tickerEnabled: false,
          ),
        );
      }
    }
    return _Theater(
      skipCount: children.length - onstageCount,
      clipBehavior: widget.clipBehavior,
      children: children.reversed.toList(growable: false),
    );
  }

  @protected
  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    // TODO(jacobr): use IterableProperty instead as that would
    // provide a slightly more consistent string summary of the List.
    properties.add(DiagnosticsProperty<List<OverlayEntry>>('entries', _entries));
  }
}

class _WrappingOverlay extends StatefulWidget {
  const _WrappingOverlay({super.key, this.clipBehavior = Clip.hardEdge, required this.child});

  final Clip clipBehavior;
  final Widget child;

  @override
  State<_WrappingOverlay> createState() => _WrappingOverlayState();
}

class _WrappingOverlayState extends State<_WrappingOverlay> {
  late final OverlayEntry _entry = OverlayEntry(
    canSizeOverlay: true,
    opaque: true,
    builder: (BuildContext context) {
      return widget.child;
    },
  );

  @override
  void didUpdateWidget(_WrappingOverlay oldWidget) {
    super.didUpdateWidget(oldWidget);
    _entry.markNeedsBuild();
  }

  @override
  void dispose() {
    _entry
      ..remove()
      ..dispose();
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    return Overlay(clipBehavior: widget.clipBehavior, initialEntries: <OverlayEntry>[_entry]);
  }
}

/// Special version of a [Stack], that doesn't layout and render the first
/// [skipCount] children.
///
/// The first [skipCount] children are considered "offstage".
class _Theater extends MultiChildRenderObjectWidget {
  const _Theater({
    this.skipCount = 0,
    this.clipBehavior = Clip.hardEdge,
    required List<_OverlayEntryWidget> super.children,
  }) : assert(skipCount >= 0),
       assert(children.length >= skipCount);

  final int skipCount;

  final Clip clipBehavior;

  @override
  _TheaterElement createElement() => _TheaterElement(this);

  @override
  _RenderTheater createRenderObject(BuildContext context) {
    return _RenderTheater(
      skipCount: skipCount,
      textDirection: Directionality.of(context),
      clipBehavior: clipBehavior,
    );
  }

  @override
  void updateRenderObject(BuildContext context, _RenderTheater renderObject) {
    renderObject
      ..skipCount = skipCount
      ..textDirection = Directionality.of(context)
      ..clipBehavior = clipBehavior;
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties.add(IntProperty('skipCount', skipCount));
  }
}

class _TheaterElement extends MultiChildRenderObjectElement {
  _TheaterElement(_Theater super.widget);

  @override
  _RenderTheater get renderObject => super.renderObject as _RenderTheater;

  @override
  void insertRenderObjectChild(RenderBox child, IndexedSlot<Element?> slot) {
    super.insertRenderObjectChild(child, slot);
    final _TheaterParentData parentData = child.parentData! as _TheaterParentData;
    parentData.overlayEntry =
        ((widget as _Theater).children[slot.index] as _OverlayEntryWidget).entry;
    assert(parentData.overlayEntry != null);
  }

  @override
  void moveRenderObjectChild(
    RenderBox child,
    IndexedSlot<Element?> oldSlot,
    IndexedSlot<Element?> newSlot,
  ) {
    super.moveRenderObjectChild(child, oldSlot, newSlot);
    assert(() {
      final _TheaterParentData parentData = child.parentData! as _TheaterParentData;
      return parentData.overlayEntry ==
          ((widget as _Theater).children[newSlot.index] as _OverlayEntryWidget).entry;
    }());
  }

  @override
  void debugVisitOnstageChildren(ElementVisitor visitor) {
    final _Theater theater = widget as _Theater;
    assert(children.length >= theater.skipCount);
    children.skip(theater.skipCount).forEach(visitor);
  }
}

// A `RenderBox` that sizes itself to its parent's size, implements the stack
// layout algorithm and renders its children in the given `theater`.
mixin _RenderTheaterMixin on RenderBox {
  _RenderTheater get theater;

  Iterable<RenderBox> _childrenInPaintOrder();
  Iterable<RenderBox> _childrenInHitTestOrder();

  @override
  void setupParentData(RenderBox child) {
    if (child.parentData is! StackParentData) {
      child.parentData = StackParentData();
    }
  }

  @override
  double? computeDistanceToActualBaseline(TextBaseline baseline) {
    assert(!debugNeedsLayout);
    BaselineOffset baselineOffset = BaselineOffset.noBaseline;
    for (final RenderBox child in _childrenInPaintOrder()) {
      assert(!child.debugNeedsLayout);
      final StackParentData childParentData = child.parentData! as StackParentData;
      baselineOffset = baselineOffset.minOf(
        BaselineOffset(child.getDistanceToActualBaseline(baseline)) + childParentData.offset.dy,
      );
    }
    return baselineOffset.offset;
  }

  static double? baselineForChild(
    RenderBox child,
    Size theaterSize,
    BoxConstraints nonPositionedChildConstraints,
    Alignment alignment,
    TextBaseline baseline,
  ) {
    final StackParentData childParentData = child.parentData! as StackParentData;
    final BoxConstraints childConstraints =
        childParentData.isPositioned
            ? childParentData.positionedChildConstraints(theaterSize)
            : nonPositionedChildConstraints;
    final double? baselineOffset = child.getDryBaseline(childConstraints, baseline);
    if (baselineOffset == null) {
      return null;
    }
    final double y = switch (childParentData) {
      StackParentData(:final double top?) => top,
      StackParentData(:final double bottom?) =>
        theaterSize.height - bottom - child.getDryLayout(childConstraints).height,
      StackParentData() =>
        alignment.alongOffset(theaterSize - child.getDryLayout(childConstraints) as Offset).dy,
    };
    return baselineOffset + y;
  }

  void layoutChild(RenderBox child, BoxConstraints nonPositionedChildConstraints) {
    final StackParentData childParentData = child.parentData! as StackParentData;
    final Alignment alignment = theater._resolvedAlignment;
    if (!childParentData.isPositioned) {
      child.layout(nonPositionedChildConstraints, parentUsesSize: true);
      childParentData.offset = Offset.zero;
    } else {
      assert(
        child is! _RenderDeferredLayoutBox,
        'all _RenderDeferredLayoutBoxes must be non-positioned children.',
      );
      RenderStack.layoutPositionedChild(child, childParentData, size, alignment);
    }
    assert(child.parentData == childParentData);
  }

  @override
  bool hitTestChildren(BoxHitTestResult result, {required Offset position}) {
    final Iterator<RenderBox> iterator = _childrenInHitTestOrder().iterator;
    bool isHit = false;
    while (!isHit && iterator.moveNext()) {
      final RenderBox child = iterator.current;
      final StackParentData childParentData = child.parentData! as StackParentData;
      final RenderBox localChild = child;
      bool childHitTest(BoxHitTestResult result, Offset position) =>
          localChild.hitTest(result, position: position);
      isHit = result.addWithPaintOffset(
        offset: childParentData.offset,
        position: position,
        hitTest: childHitTest,
      );
    }
    return isHit;
  }

  @override
  void paint(PaintingContext context, Offset offset) {
    for (final RenderBox child in _childrenInPaintOrder()) {
      final StackParentData childParentData = child.parentData! as StackParentData;
      context.paintChild(child, childParentData.offset + offset);
    }
  }
}

class _TheaterParentData extends StackParentData {
  // The OverlayEntry that directly created this child. This field is null for
  // children that are created by an OverlayPortal.
  OverlayEntry? overlayEntry;

  /// A [OverlayPortal] makes its overlay child a render child of an ancestor
  /// [Overlay]. Currently, to make sure the overlay child is painted after its
  /// [OverlayPortal], and before the next [OverlayEntry] (which could be
  /// something that should obstruct the overlay child, such as a [ModalRoute])
  /// in the host [Overlay], the paint order of each overlay child is managed by
  /// the [OverlayEntry] that hosts its [OverlayPortal].
  ///
  /// The following methods are exposed to allow easy access to the overlay
  /// children's render objects whose order is managed by [overlayEntry], in the
  /// right order.

  // _overlayStateMounted is set to null in _OverlayEntryWidgetState's dispose
  // method. This property is only accessed during layout, paint and hit-test so
  // the `value!` should be safe.
  Iterator<RenderBox>? get paintOrderIterator =>
      overlayEntry?._overlayEntryStateNotifier?.value!._paintOrderIterable.iterator;
  Iterator<RenderBox>? get hitTestOrderIterator =>
      overlayEntry?._overlayEntryStateNotifier?.value!._hitTestOrderIterable.iterator;

  // A convenience method for traversing `paintOrderIterator` with a
  // [RenderObjectVisitor].
  void visitOverlayPortalChildrenOnOverlayEntry(RenderObjectVisitor visitor) =>
      overlayEntry?._overlayEntryStateNotifier?.value!._paintOrderIterable.forEach(visitor);
}

class _RenderTheater extends RenderBox
    with ContainerRenderObjectMixin<RenderBox, StackParentData>, _RenderTheaterMixin {
  _RenderTheater({
    List<RenderBox>? children,
    required TextDirection textDirection,
    int skipCount = 0,
    Clip clipBehavior = Clip.hardEdge,
  }) : assert(skipCount >= 0),
       _textDirection = textDirection,
       _skipCount = skipCount,
       _clipBehavior = clipBehavior {
    addAll(children);
  }

  @override
  _RenderTheater get theater => this;

  @override
  void setupParentData(RenderBox child) {
    if (child.parentData is! _TheaterParentData) {
      child.parentData = _TheaterParentData();
    }
  }

  @override
  void attach(PipelineOwner owner) {
    super.attach(owner);
    RenderBox? child = firstChild;
    while (child != null) {
      final _TheaterParentData childParentData = child.parentData! as _TheaterParentData;
      final Iterator<RenderBox>? iterator = childParentData.paintOrderIterator;
      if (iterator != null) {
        while (iterator.moveNext()) {
          iterator.current.attach(owner);
        }
      }
      child = childParentData.nextSibling;
    }
  }

  static void _detachChild(RenderObject child) => child.detach();

  @override
  void detach() {
    super.detach();
    RenderBox? child = firstChild;
    while (child != null) {
      final _TheaterParentData childParentData = child.parentData! as _TheaterParentData;
      childParentData.visitOverlayPortalChildrenOnOverlayEntry(_detachChild);
      child = childParentData.nextSibling;
    }
  }

  @override
  void redepthChildren() => visitChildren(redepthChild);

  Alignment? _alignmentCache;
  Alignment get _resolvedAlignment =>
      _alignmentCache ??= AlignmentDirectional.topStart.resolve(textDirection);

  void _markNeedResolution() {
    _alignmentCache = null;
    markNeedsLayout();
  }

  TextDirection get textDirection => _textDirection;
  TextDirection _textDirection;
  set textDirection(TextDirection value) {
    if (_textDirection == value) {
      return;
    }
    _textDirection = value;
    _markNeedResolution();
  }

  int get skipCount => _skipCount;
  int _skipCount;
  set skipCount(int value) {
    if (_skipCount != value) {
      _skipCount = value;
      markNeedsLayout();
    }
  }

  /// {@macro flutter.material.Material.clipBehavior}
  ///
  /// Defaults to [Clip.hardEdge].
  Clip get clipBehavior => _clipBehavior;
  Clip _clipBehavior = Clip.hardEdge;
  set clipBehavior(Clip value) {
    if (value != _clipBehavior) {
      _clipBehavior = value;
      markNeedsPaint();
      markNeedsSemanticsUpdate();
    }
  }

  // Adding/removing deferred child does not affect the layout of other children,
  // or that of the Overlay, so there's no need to invalidate the layout of the
  // Overlay.
  //
  // When _skipMarkNeedsLayout is true, markNeedsLayout does not do anything.
  bool _skipMarkNeedsLayout = false;
  void _addDeferredChild(_RenderDeferredLayoutBox child) {
    assert(!_skipMarkNeedsLayout);
    _skipMarkNeedsLayout = true;
    adoptChild(child);
    // The Overlay still needs repainting when a deferred child is added. Usually
    // `markNeedsLayout` implies `markNeedsPaint`, but here `markNeedsLayout` is
    // skipped when the `_skipMarkNeedsLayout` flag is set.
    markNeedsPaint();
    _skipMarkNeedsLayout = false;

    // After adding `child` to the render tree, we want to make sure it will be
    // laid out in the same frame. This is done by calling markNeedsLayout on the
    // layout surrogate. This ensures `child` is reachable via tree walk (see
    // _RenderLayoutSurrogateProxyBox.performLayout).
    child._layoutSurrogate.markNeedsLayout();
  }

  void _removeDeferredChild(_RenderDeferredLayoutBox child) {
    assert(!_skipMarkNeedsLayout);
    _skipMarkNeedsLayout = true;
    dropChild(child);
    // The Overlay still needs repainting when a deferred child is dropped. See
    // the comment in `_addDeferredChild`.
    markNeedsPaint();
    _skipMarkNeedsLayout = false;
  }

  @override
  void markNeedsLayout() {
    if (!_skipMarkNeedsLayout) {
      super.markNeedsLayout();
    }
  }

  RenderBox? get _firstOnstageChild {
    if (skipCount == super.childCount) {
      return null;
    }
    RenderBox? child = super.firstChild;
    for (int toSkip = skipCount; toSkip > 0; toSkip--) {
      final StackParentData childParentData = child!.parentData! as StackParentData;
      child = childParentData.nextSibling;
      assert(child != null);
    }
    return child;
  }

  RenderBox? get _lastOnstageChild => skipCount == super.childCount ? null : lastChild;

  @override
  double computeMinIntrinsicWidth(double height) {
    return RenderStack.getIntrinsicDimension(
      _firstOnstageChild,
      (RenderBox child) => child.getMinIntrinsicWidth(height),
    );
  }

  @override
  double computeMaxIntrinsicWidth(double height) {
    return RenderStack.getIntrinsicDimension(
      _firstOnstageChild,
      (RenderBox child) => child.getMaxIntrinsicWidth(height),
    );
  }

  @override
  double computeMinIntrinsicHeight(double width) {
    return RenderStack.getIntrinsicDimension(
      _firstOnstageChild,
      (RenderBox child) => child.getMinIntrinsicHeight(width),
    );
  }

  @override
  double computeMaxIntrinsicHeight(double width) {
    return RenderStack.getIntrinsicDimension(
      _firstOnstageChild,
      (RenderBox child) => child.getMaxIntrinsicHeight(width),
    );
  }

  @override
  double? computeDryBaseline(BoxConstraints constraints, TextBaseline baseline) {
    final Size size =
        constraints.biggest.isFinite
            ? constraints.biggest
            : _findSizeDeterminingChild().getDryLayout(constraints);
    final BoxConstraints nonPositionedChildConstraints = BoxConstraints.tight(size);
    final Alignment alignment = theater._resolvedAlignment;

    BaselineOffset baselineOffset = BaselineOffset.noBaseline;
    for (final RenderBox child in _childrenInPaintOrder()) {
      baselineOffset = baselineOffset.minOf(
        BaselineOffset(
          _RenderTheaterMixin.baselineForChild(
            child,
            size,
            nonPositionedChildConstraints,
            alignment,
            baseline,
          ),
        ),
      );
    }
    return baselineOffset.offset;
  }

  @override
  Size computeDryLayout(BoxConstraints constraints) {
    if (constraints.biggest.isFinite) {
      return constraints.biggest;
    }
    return _findSizeDeterminingChild().getDryLayout(constraints);
  }

  @override
  // The following uses sync* because concurrent modifications should be allowed
  // during layout.
  Iterable<RenderBox> _childrenInPaintOrder() sync* {
    RenderBox? child = _firstOnstageChild;
    while (child != null) {
      yield child;
      final _TheaterParentData childParentData = child.parentData! as _TheaterParentData;
      final Iterator<RenderBox>? innerIterator = childParentData.paintOrderIterator;
      if (innerIterator != null) {
        while (innerIterator.moveNext()) {
          yield innerIterator.current;
        }
      }
      child = childParentData.nextSibling;
    }
  }

  @override
  // The following uses sync* because hit testing should be lazy.
  Iterable<RenderBox> _childrenInHitTestOrder() sync* {
    RenderBox? child = _lastOnstageChild;
    int childLeft = childCount - skipCount;
    while (child != null) {
      final _TheaterParentData childParentData = child.parentData! as _TheaterParentData;
      final Iterator<RenderBox>? innerIterator = childParentData.hitTestOrderIterator;
      if (innerIterator != null) {
        while (innerIterator.moveNext()) {
          yield innerIterator.current;
        }
      }
      yield child;
      childLeft -= 1;
      child = childLeft <= 0 ? null : childParentData.previousSibling;
    }
  }

  @override
  bool get sizedByParent => false;

  bool _layingOutSizeDeterminingChild = false;
  @override
  void performLayout() {
    RenderBox? sizeDeterminingChild;
    if (constraints.biggest.isFinite) {
      size = constraints.biggest;
    } else {
      sizeDeterminingChild = _findSizeDeterminingChild();
      _layingOutSizeDeterminingChild = true;
      layoutChild(sizeDeterminingChild, constraints);
      _layingOutSizeDeterminingChild = false;
      size = sizeDeterminingChild.size;
    }

    // Equivalent to BoxConstraints used by RenderStack for StackFit.expand.
    final BoxConstraints nonPositionedChildConstraints = BoxConstraints.tight(size);
    for (final RenderBox child in _childrenInPaintOrder()) {
      if (child != sizeDeterminingChild) {
        layoutChild(child, nonPositionedChildConstraints);
      }
    }
  }

  RenderBox _findSizeDeterminingChild() {
    RenderBox? child = _lastOnstageChild;
    while (child != null) {
      final _TheaterParentData childParentData = child.parentData! as _TheaterParentData;
      if ((childParentData.overlayEntry?.canSizeOverlay ?? false) &&
          !childParentData.isPositioned) {
        return child;
      }
      child = childParentData.previousSibling;
    }
    throw FlutterError.fromParts(<DiagnosticsNode>[
      ErrorSummary(
        'Overlay was given infinite constraints and cannot be sized by a suitable child.',
      ),
      ErrorDescription(
        'The constraints given to the overlay ($constraints) would result in an illegal '
        'infinite size (${constraints.biggest}). To avoid that, the Overlay tried to size '
        'itself to one of its children, but no suitable non-positioned child that belongs to an '
        'OverlayEntry with canSizeOverlay set to true could be found.',
      ),
      ErrorHint(
        'Try wrapping the Overlay in a SizedBox to give it a finite size or '
        'use an OverlayEntry with canSizeOverlay set to true.',
      ),
    ]);
  }

  final LayerHandle<ClipRectLayer> _clipRectLayer = LayerHandle<ClipRectLayer>();

  @override
  void paint(PaintingContext context, Offset offset) {
    if (clipBehavior != Clip.none) {
      _clipRectLayer.layer = context.pushClipRect(
        needsCompositing,
        offset,
        Offset.zero & size,
        super.paint,
        clipBehavior: clipBehavior,
        oldLayer: _clipRectLayer.layer,
      );
    } else {
      _clipRectLayer.layer = null;
      super.paint(context, offset);
    }
  }

  @override
  void dispose() {
    _clipRectLayer.layer = null;
    super.dispose();
  }

  @override
  void visitChildren(RenderObjectVisitor visitor) {
    RenderBox? child = firstChild;
    while (child != null) {
      visitor(child);
      final _TheaterParentData childParentData = child.parentData! as _TheaterParentData;
      childParentData.visitOverlayPortalChildrenOnOverlayEntry(visitor);
      child = childParentData.nextSibling;
    }
  }

  @override
  void visitChildrenForSemantics(RenderObjectVisitor visitor) {
    RenderBox? child = _firstOnstageChild;
    while (child != null) {
      visitor(child);
      final _TheaterParentData childParentData = child.parentData! as _TheaterParentData;
      child = childParentData.nextSibling;
    }
  }

  @override
  Rect? describeApproximatePaintClip(RenderObject child) {
    switch (clipBehavior) {
      case Clip.none:
        return null;
      case Clip.hardEdge:
      case Clip.antiAlias:
      case Clip.antiAliasWithSaveLayer:
        return Offset.zero & size;
    }
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties.add(IntProperty('skipCount', skipCount));
    properties.add(EnumProperty<TextDirection>('textDirection', textDirection));
  }

  @override
  List<DiagnosticsNode> debugDescribeChildren() {
    final List<DiagnosticsNode> offstageChildren = <DiagnosticsNode>[];
    final List<DiagnosticsNode> onstageChildren = <DiagnosticsNode>[];

    int count = 1;
    bool onstage = false;
    RenderBox? child = firstChild;
    final RenderBox? firstOnstageChild = _firstOnstageChild;
    while (child != null) {
      final _TheaterParentData childParentData = child.parentData! as _TheaterParentData;
      if (child == firstOnstageChild) {
        onstage = true;
        count = 1;
      }

      if (onstage) {
        onstageChildren.add(child.toDiagnosticsNode(name: 'onstage $count'));
      } else {
        offstageChildren.add(
          child.toDiagnosticsNode(name: 'offstage $count', style: DiagnosticsTreeStyle.offstage),
        );
      }

      int subcount = 1;
      childParentData.visitOverlayPortalChildrenOnOverlayEntry((RenderObject renderObject) {
        final RenderBox child = renderObject as RenderBox;
        if (onstage) {
          onstageChildren.add(child.toDiagnosticsNode(name: 'onstage $count - $subcount'));
        } else {
          offstageChildren.add(
            child.toDiagnosticsNode(
              name: 'offstage $count - $subcount',
              style: DiagnosticsTreeStyle.offstage,
            ),
          );
        }
        subcount += 1;
      });

      child = childParentData.nextSibling;
      count += 1;
    }

    return <DiagnosticsNode>[
      ...onstageChildren,
      if (offstageChildren.isNotEmpty)
        ...offstageChildren
      else
        DiagnosticsNode.message('no offstage children', style: DiagnosticsTreeStyle.offstage),
    ];
  }
}

// * OverlayPortal Implementation
//  OverlayPortal is inspired by the
//  [flutter_portal](https://pub.dev/packages/flutter_portal) package.
//
// ** RenderObject hierarchy
// The widget works by inserting its overlay child's render subtree directly
// under [Overlay]'s render object (_RenderTheater).
// https://user-images.githubusercontent.com/31859944/171971838-62ed3975-4b5d-4733-a9c9-f79e263b8fcc.jpg
//
// To ensure the overlay child render subtree does not do layout twice, the
// subtree must only perform layout after both its _RenderTheater and the
// [OverlayPortal]'s render object (_RenderLayoutSurrogateProxyBox) have
// finished layout. This is handled by _RenderDeferredLayoutBox.
//
// ** Z-Index of an overlay child
// [_OverlayEntryLocation] is a (currently private) interface that allows an
// [OverlayPortal] to insert its overlay child into a specific [Overlay], as
// well as specifying the paint order between the overlay child and other
// children of the _RenderTheater.
//
// Since [OverlayPortal] is only allowed to target ancestor [Overlay]s
// (_RenderTheater must finish doing layout before _RenderDeferredLayoutBox),
// the _RenderTheater should typically be acquired using an [InheritedWidget]
// (currently, _RenderTheaterMarker) in case the [OverlayPortal] gets
// reparented.

/// A class to show, hide and bring to top an [OverlayPortal]'s overlay child
/// in the target [Overlay].
///
/// A [OverlayPortalController] can only be given to at most one [OverlayPortal]
/// at a time. When an [OverlayPortalController] is moved from one
/// [OverlayPortal] to another, its [isShowing] state does not carry over.
///
/// [OverlayPortalController.show] and [OverlayPortalController.hide] can be
/// called even before the controller is assigned to any [OverlayPortal], but
/// they typically should not be called while the widget tree is being rebuilt.
class OverlayPortalController {
  /// Creates an [OverlayPortalController], optionally with a String identifier
  /// `debugLabel`.
  OverlayPortalController({String? debugLabel}) : _debugLabel = debugLabel;

  _OverlayPortalState? _attachTarget;

  // A separate _zOrderIndex to allow `show()` or `hide()` to be called when the
  // controller is not yet attached. Once this controller is attached,
  // _attachTarget._zOrderIndex will be used as the source of truth, and this
  // variable will be set to null.
  int? _zOrderIndex;
  final String? _debugLabel;

  static int _wallTime =
      kIsWeb
          ? -9007199254740992 // -2^53
          : -1 << 63;

  // Returns a unique and monotonically increasing timestamp that represents
  // now.
  //
  // The value this method returns increments after each call.
  int _now() {
    final int now = _wallTime += 1;
    assert(_zOrderIndex == null || _zOrderIndex! < now);
    assert(_attachTarget?._zOrderIndex == null || _attachTarget!._zOrderIndex! < now);
    return now;
  }

  /// Show the overlay child of the [OverlayPortal] this controller is attached
  /// to, at the top of the target [Overlay].
  ///
  /// When there are more than one [OverlayPortal]s that target the same
  /// [Overlay], the overlay child of the last [OverlayPortal] to have called
  /// [show] appears at the top level, unobstructed.
  ///
  /// If [isShowing] is already true, calling this method brings the overlay
  /// child it controls to the top.
  ///
  /// This method should typically not be called while the widget tree is being
  /// rebuilt.
  void show() {
    final _OverlayPortalState? state = _attachTarget;
    if (state != null) {
      state.show(_now());
    } else {
      _zOrderIndex = _now();
    }
  }

  /// Hide the [OverlayPortal]'s overlay child.
  ///
  /// Once hidden, the overlay child will be removed from the widget tree the
  /// next time the widget tree rebuilds, and stateful widgets in the overlay
  /// child may lose states as a result.
  ///
  /// This method should typically not be called while the widget tree is being
  /// rebuilt.
  void hide() {
    final _OverlayPortalState? state = _attachTarget;
    if (state != null) {
      state.hide();
    } else {
      assert(_zOrderIndex != null);
      _zOrderIndex = null;
    }
  }

  /// Whether the associated [OverlayPortal] should build and show its overlay
  /// child, using its `overlayChildBuilder`.
  bool get isShowing {
    final _OverlayPortalState? state = _attachTarget;
    return state != null ? state._zOrderIndex != null : _zOrderIndex != null;
  }

  /// Convenience method for toggling the current [isShowing] status.
  ///
  /// This method should typically not be called while the widget tree is being
  /// rebuilt.
  void toggle() => isShowing ? hide() : show();

  @override
  String toString() {
    final String? debugLabel = _debugLabel;
    final String label = debugLabel == null ? '' : '($debugLabel)';
    final String isDetached = _attachTarget != null ? '' : ' DETACHED';
    return '${objectRuntimeType(this, 'OverlayPortalController')}$label$isDetached';
  }
}

/// A widget that renders its overlay child on an [Overlay].
///
/// The overlay child is initially hidden until [OverlayPortalController.show]
/// is called on the associated [controller]. The [OverlayPortal] uses
/// [overlayChildBuilder] to build its overlay child and renders it on the
/// specified [Overlay] as if it was inserted using an [OverlayEntry], while it
/// can depend on the same set of [InheritedWidget]s (such as [Theme]) that this
/// widget can depend on.
///
/// This widget requires an [Overlay] ancestor in the widget tree when its
/// overlay child is showing. The overlay child is rendered by the [Overlay]
/// ancestor, not by the widget itself. This allows the overlay child to float
/// above other widgets, independent of its position in the widget tree.
///
/// When [OverlayPortalController.hide] is called, the widget built using
/// [overlayChildBuilder] will be removed from the widget tree the next time the
/// widget rebuilds. Stateful descendants in the overlay child subtree may lose
/// states as a result.
///
/// {@tool dartpad}
/// This example uses an [OverlayPortal] to build a tooltip that becomes visible
/// when the user taps on the [child] widget. There's a [DefaultTextStyle] above
/// the [OverlayPortal] controlling the [TextStyle] of both the [child] widget
/// and the widget [overlayChildBuilder] builds, which isn't otherwise doable if
/// the tooltip was added as an [OverlayEntry].
///
/// ** See code in examples/api/lib/widgets/overlay/overlay_portal.0.dart **
/// {@end-tool}
///
/// ### Paint Order
///
/// In an [Overlay], an overlay child is painted after the [OverlayEntry]
/// associated with its [OverlayPortal] (that is, the [OverlayEntry] closest to
/// the [OverlayPortal] in the widget tree, which usually represents the
/// enclosing [Route]), and before the next [OverlayEntry].
///
/// When an [OverlayEntry] has multiple associated [OverlayPortal]s, the paint
/// order between their overlay children is the order in which
/// [OverlayPortalController.show] was called. The last [OverlayPortal] to have
/// called `show` gets to paint its overlay child in the foreground.
///
/// ### Semantics
///
/// The semantics subtree generated by the overlay child is considered attached
/// to [OverlayPortal] instead of the target [Overlay]. An [OverlayPortal]'s
/// semantics subtree can be dropped from the semantics tree due to invisibility
/// while the overlay child is still visible (for example, when the
/// [OverlayPortal] is completely invisible in a [ListView] but kept alive by
/// a [KeepAlive] widget). When this happens the semantics subtree generated by
/// the overlay child is also dropped, even if the overlay child is still visible
/// on screen.
///
/// {@template flutter.widgets.overlayPortalVsOverlayEntry}
/// ### Differences between [OverlayPortal] and [OverlayEntry]
///
/// The main difference between [OverlayEntry] and [OverlayPortal] is that
/// [OverlayEntry] builds its widget subtree as a child of the target [Overlay],
/// while [OverlayPortal] uses [OverlayPortal.overlayChildBuilder] to build a
/// child widget of itself. This allows [OverlayPortal]'s overlay child to depend
/// on the same set of [InheritedWidget]s as [OverlayPortal], and it's also
/// guaranteed that the overlay child will not outlive its [OverlayPortal].
///
/// On the other hand, [OverlayPortal]'s implementation is more complex. For
/// instance, it does a bit more work than a regular widget during global key
/// reparenting. If the content to be shown on the [Overlay] doesn't benefit
/// from being a part of [OverlayPortal]'s subtree, consider using an
/// [OverlayEntry] instead.
/// {@endtemplate}
///
/// See also:
///
///  * [OverlayEntry], an alternative API for inserting widgets into an
///    [Overlay].
///  * [Positioned], which can be used to size and position the overlay child in
///    relation to the target [Overlay]'s boundaries.
///  * [CompositedTransformFollower], which can be used to position the overlay
///    child in relation to the linked [CompositedTransformTarget] widget.
class OverlayPortal extends StatefulWidget {
  /// Creates an [OverlayPortal] that renders the widget [overlayChildBuilder]
  /// builds on the closest [Overlay] when [OverlayPortalController.show] is
  /// called.
  const OverlayPortal({
    super.key,
    required this.controller,
    required this.overlayChildBuilder,
    this.child,
  }) : _targetRootOverlay = false;

  /// Creates an [OverlayPortal] that renders the widget [overlayChildBuilder]
  /// builds on the root [Overlay] when [OverlayPortalController.show] is
  /// called.
  const OverlayPortal.targetsRootOverlay({
    super.key,
    required this.controller,
    required this.overlayChildBuilder,
    this.child,
  }) : _targetRootOverlay = true;

  /// The controller to show, hide and bring to top the overlay child.
  final OverlayPortalController controller;

  /// A [WidgetBuilder] used to build a widget below this widget in the tree,
  /// that renders on the closest [Overlay].
  ///
  /// The said widget will only be built and shown in the closest [Overlay] once
  /// [OverlayPortalController.show] is called on the associated [controller].
  /// It will be painted in front of the [OverlayEntry] closest to this widget
  /// in the widget tree (which is usually the enclosing [Route]).
  ///
  /// The built overlay child widget is inserted below this widget in the widget
  /// tree, allowing it to depend on [InheritedWidget]s above it, and be
  /// notified when the [InheritedWidget]s change.
  ///
  /// Unlike [child], the built overlay child can visually extend outside the
  /// bounds of this widget without being clipped, and receive hit-test events
  /// outside of this widget's bounds, as long as it does not extend outside of
  /// the [Overlay] on which it is rendered.
  final WidgetBuilder overlayChildBuilder;

  /// A widget below this widget in the tree.
  final Widget? child;

  final bool _targetRootOverlay;

  @override
  State<OverlayPortal> createState() => _OverlayPortalState();
}

class _OverlayPortalState extends State<OverlayPortal> {
  int? _zOrderIndex;
  // The location of the overlay child within the overlay. This object will be
  // used as the slot of the overlay child widget.
  //
  // The developer must call `show` to reveal the overlay so we can get a unique
  // timestamp of the user interaction for determining the z-index of the
  // overlay child in the overlay.
  //
  // Avoid invalidating the cache if possible, since the framework uses `==` to
  // compare slots, and _OverlayEntryLocation can't override that operator since
  // it's mutable. Changing slots can be relatively slow.
  bool _childModelMayHaveChanged = true;
  _OverlayEntryLocation? _locationCache;
  static bool _isTheSameLocation(_OverlayEntryLocation locationCache, _RenderTheaterMarker marker) {
    return locationCache._childModel == marker.overlayEntryWidgetState &&
        locationCache._theater == marker.theater;
  }

  _OverlayEntryLocation _getLocation(int zOrderIndex, bool targetRootOverlay) {
    final _OverlayEntryLocation? cachedLocation = _locationCache;
    late final _RenderTheaterMarker marker = _RenderTheaterMarker.of(
      context,
      targetRootOverlay: targetRootOverlay,
    );
    final bool isCacheValid =
        cachedLocation != null &&
        (!_childModelMayHaveChanged || _isTheSameLocation(cachedLocation, marker));
    _childModelMayHaveChanged = false;
    if (isCacheValid) {
      assert(cachedLocation._zOrderIndex == zOrderIndex);
      assert(cachedLocation._debugIsLocationValid());
      return cachedLocation;
    }
    // Otherwise invalidate the cache and create a new location.
    cachedLocation?._debugMarkLocationInvalid();
    final _OverlayEntryLocation newLocation = _OverlayEntryLocation(
      zOrderIndex,
      marker.overlayEntryWidgetState,
      marker.theater,
    );
    assert(newLocation._zOrderIndex == zOrderIndex);
    return _locationCache = newLocation;
  }

  @override
  void initState() {
    super.initState();
    _setupController(widget.controller);
  }

  void _setupController(OverlayPortalController controller) {
    assert(
      controller._attachTarget == null || controller._attachTarget == this,
      'Failed to attach $controller to $this. It is already attached to ${controller._attachTarget}.',
    );
    final int? controllerZOrderIndex = controller._zOrderIndex;
    final int? zOrderIndex = _zOrderIndex;
    if (zOrderIndex == null ||
        (controllerZOrderIndex != null && controllerZOrderIndex > zOrderIndex)) {
      _zOrderIndex = controllerZOrderIndex;
    }
    controller._zOrderIndex = null;
    controller._attachTarget = this;
  }

  @override
  void didChangeDependencies() {
    super.didChangeDependencies();
    _childModelMayHaveChanged = true;
  }

  @override
  void didUpdateWidget(OverlayPortal oldWidget) {
    super.didUpdateWidget(oldWidget);
    _childModelMayHaveChanged =
        _childModelMayHaveChanged || oldWidget._targetRootOverlay != widget._targetRootOverlay;
    if (oldWidget.controller != widget.controller) {
      oldWidget.controller._attachTarget = null;
      _setupController(widget.controller);
    }
  }

  @override
  void dispose() {
    assert(widget.controller._attachTarget == this);
    widget.controller._attachTarget = null;
    _locationCache?._debugMarkLocationInvalid();
    _locationCache = null;
    super.dispose();
  }

  void show(int zOrderIndex) {
    assert(
      SchedulerBinding.instance.schedulerPhase != SchedulerPhase.persistentCallbacks,
      '${widget.controller.runtimeType}.show() should not be called during build.',
    );
    setState(() {
      _zOrderIndex = zOrderIndex;
    });
    _locationCache?._debugMarkLocationInvalid();
    _locationCache = null;
  }

  void hide() {
    assert(SchedulerBinding.instance.schedulerPhase != SchedulerPhase.persistentCallbacks);
    setState(() {
      _zOrderIndex = null;
    });
    _locationCache?._debugMarkLocationInvalid();
    _locationCache = null;
  }

  @override
  Widget build(BuildContext context) {
    final int? zOrderIndex = _zOrderIndex;
    if (zOrderIndex == null) {
      return _OverlayPortal(overlayLocation: null, overlayChild: null, child: widget.child);
    }
    return _OverlayPortal(
      overlayLocation: _getLocation(zOrderIndex, widget._targetRootOverlay),
      overlayChild: _DeferredLayout(child: Builder(builder: widget.overlayChildBuilder)),
      child: widget.child,
    );
  }
}

/// A location in an [Overlay].
///
/// An [_OverlayEntryLocation] determines the [Overlay] the associated
/// [OverlayPortal] should put its overlay child onto, as well as the overlay
/// child's paint order in relation to other contents painted on the [Overlay].
//
// An _OverlayEntryLocation is a cursor pointing to a location in a particular
// Overlay's child model, and provides methods to insert/remove/move a
// _RenderDeferredLayoutBox to/from its target _theater.
//
// The occupant (a `RenderBox`) will be painted above the associated
// [OverlayEntry], but below the [OverlayEntry] above that [OverlayEntry].
//
// Additionally, `_activate` and `_deactivate` are called when the overlay
// child's `_OverlayPortalElement` activates/deactivates (for instance, during
// global key reparenting).
// `_OverlayPortalElement` removes its overlay child's render object from the
// target `_RenderTheater` when it deactivates and puts it back on `activated`.
// These 2 methods can be used to "hide" a child in the child model without
// removing it, when the child is expensive/difficult to re-insert at the
// correct location on `activated`.
//
// ### Equality
//
// An `_OverlayEntryLocation` will be used as an Element's slot. These 3 parts
// uniquely identify a place in an overlay's child model:
// - _theater
// - _childModel (the OverlayEntry)
// - _zOrderIndex
//
// Since it can't implement operator== (it's mutable), the same `_OverlayEntryLocation`
// instance must not be used to represent more than one locations.
final class _OverlayEntryLocation extends LinkedListEntry<_OverlayEntryLocation> {
  _OverlayEntryLocation(this._zOrderIndex, this._childModel, this._theater);

  final int _zOrderIndex;
  final _OverlayEntryWidgetState _childModel;
  final _RenderTheater _theater;

  _RenderDeferredLayoutBox? _overlayChildRenderBox;
  void _addToChildModel(_RenderDeferredLayoutBox child) {
    assert(
      _overlayChildRenderBox == null,
      'Failed to add $child. This location ($this) is already occupied by $_overlayChildRenderBox.',
    );
    _overlayChildRenderBox = child;
    _childModel._add(this);
    _theater.markNeedsPaint();
    _theater.markNeedsCompositingBitsUpdate();
    _theater.markNeedsSemanticsUpdate();
  }

  void _removeFromChildModel(_RenderDeferredLayoutBox child) {
    assert(child == _overlayChildRenderBox);
    _overlayChildRenderBox = null;
    assert(_childModel._sortedTheaterSiblings?.contains(this) ?? false);
    _childModel._remove(this);
    _theater.markNeedsPaint();
    _theater.markNeedsCompositingBitsUpdate();
    _theater.markNeedsSemanticsUpdate();
  }

  void _addChild(_RenderDeferredLayoutBox child) {
    assert(_debugIsLocationValid());
    _addToChildModel(child);
    _theater._addDeferredChild(child);
    assert(child.parent == _theater);
  }

  void _removeChild(_RenderDeferredLayoutBox child) {
    // This call is allowed even when this location is disposed.
    _removeFromChildModel(child);
    _theater._removeDeferredChild(child);
    assert(child.parent == null);
  }

  void _moveChild(_RenderDeferredLayoutBox child, _OverlayEntryLocation fromLocation) {
    assert(fromLocation != this);
    assert(_debugIsLocationValid());
    final _RenderTheater fromTheater = fromLocation._theater;
    final _OverlayEntryWidgetState fromModel = fromLocation._childModel;

    if (fromTheater != _theater) {
      fromTheater._removeDeferredChild(child);
      _theater._addDeferredChild(child);
    }

    if (fromModel != _childModel || fromLocation._zOrderIndex != _zOrderIndex) {
      fromLocation._removeFromChildModel(child);
      _addToChildModel(child);
    }
  }

  void _activate(_RenderDeferredLayoutBox child) {
    // This call is allowed even when this location is invalidated.
    // See _OverlayPortalElement.activate.
    assert(_overlayChildRenderBox == null, '$_overlayChildRenderBox');
    _theater._addDeferredChild(child);
    _overlayChildRenderBox = child;
  }

  void _deactivate(_RenderDeferredLayoutBox child) {
    // This call is allowed even when this location is invalidated.
    _theater._removeDeferredChild(child);
    _overlayChildRenderBox = null;
  }

  // Throws a StateError if this location is already invalidated and shouldn't
  // be used as an OverlayPortal slot. Must be used in asserts.
  //
  // Generally, `assert(_debugIsLocationValid())` should be used to prevent
  // invalid accesses to an invalid `_OverlayEntryLocation` object. Exceptions
  // to this rule are _removeChild, _deactivate, which will be called when the
  // OverlayPortal is being removed from the widget tree and may use the
  // location information to perform cleanup tasks.
  //
  // Another exception is the _activate method which is called by
  // _OverlayPortalElement.activate. See the comment in _OverlayPortalElement.activate.
  bool _debugIsLocationValid() {
    if (_debugMarkLocationInvalidStackTrace == null) {
      return true;
    }
    throw StateError(
      '$this is already disposed. Stack trace: $_debugMarkLocationInvalidStackTrace',
    );
  }

  // The StackTrace of the first _debugMarkLocationInvalid call. It's only for
  // debugging purposes and the StackTrace will only be captured in debug builds.
  //
  // The effect of this method is not reversible. Once marked invalid, this
  // object can't be marked as valid again.
  StackTrace? _debugMarkLocationInvalidStackTrace;
  @mustCallSuper
  void _debugMarkLocationInvalid() {
    assert(_debugIsLocationValid());
    assert(() {
      _debugMarkLocationInvalidStackTrace = StackTrace.current;
      return true;
    }());
  }

  @override
  String toString() =>
      '${objectRuntimeType(this, '_OverlayEntryLocation')}[${shortHash(this)}] ${_debugMarkLocationInvalidStackTrace != null ? "(INVALID)" : ""}';
}

class _RenderTheaterMarker extends InheritedWidget {
  const _RenderTheaterMarker({
    required this.theater,
    required this.overlayEntryWidgetState,
    required super.child,
  });

  final _RenderTheater theater;
  final _OverlayEntryWidgetState overlayEntryWidgetState;

  @override
  bool updateShouldNotify(_RenderTheaterMarker oldWidget) {
    return oldWidget.theater != theater ||
        oldWidget.overlayEntryWidgetState != overlayEntryWidgetState;
  }

  static _RenderTheaterMarker of(BuildContext context, {bool targetRootOverlay = false}) {
    final _RenderTheaterMarker? marker;
    if (targetRootOverlay) {
      final InheritedElement? ancestor = _rootRenderTheaterMarkerOf(
        context.getElementForInheritedWidgetOfExactType<_RenderTheaterMarker>(),
      );
      assert(ancestor == null || ancestor.widget is _RenderTheaterMarker);
      marker =
          ancestor != null
              ? context.dependOnInheritedElement(ancestor) as _RenderTheaterMarker?
              : null;
    } else {
      marker = context.dependOnInheritedWidgetOfExactType<_RenderTheaterMarker>();
    }
    if (marker != null) {
      return marker;
    }
    throw FlutterError.fromParts(<DiagnosticsNode>[
      ErrorSummary('No Overlay widget found.'),
      ErrorDescription(
        '${context.widget.runtimeType} widgets require an Overlay widget ancestor.\n'
        'An overlay lets widgets float on top of other widget children.',
      ),
      ErrorHint(
        'To introduce an Overlay widget, you can either directly '
        'include one, or use a widget that contains an Overlay itself, '
        'such as a Navigator, WidgetApp, MaterialApp, or CupertinoApp.',
      ),
      ...context.describeMissingAncestor(expectedAncestorType: Overlay),
    ]);
  }

  static InheritedElement? _rootRenderTheaterMarkerOf(InheritedElement? theaterMarkerElement) {
    assert(theaterMarkerElement == null || theaterMarkerElement.widget is _RenderTheaterMarker);
    if (theaterMarkerElement == null) {
      return null;
    }
    InheritedElement? ancestor;
    theaterMarkerElement.visitAncestorElements((Element element) {
      ancestor = element.getElementForInheritedWidgetOfExactType<_RenderTheaterMarker>();
      return false;
    });
    return ancestor == null ? theaterMarkerElement : _rootRenderTheaterMarkerOf(ancestor);
  }
}

class _OverlayPortal extends RenderObjectWidget {
  /// Creates a widget that renders the given [overlayChild] in the [Overlay]
  /// specified by `overlayLocation`.
  ///
  /// The `overlayLocation` parameter must not be null when [overlayChild] is not
  /// null.
  _OverlayPortal({required this.overlayLocation, required this.overlayChild, required this.child})
    : assert(overlayChild == null || overlayLocation != null),
      assert(overlayLocation == null || overlayLocation._debugIsLocationValid());

  final Widget? overlayChild;

  /// A widget below this widget in the tree.
  final Widget? child;

  final _OverlayEntryLocation? overlayLocation;

  @override
  RenderObjectElement createElement() => _OverlayPortalElement(this);

  @override
  RenderObject createRenderObject(BuildContext context) => _RenderLayoutSurrogateProxyBox();
}

class _OverlayPortalElement extends RenderObjectElement {
  _OverlayPortalElement(_OverlayPortal super.widget);

  @override
  _RenderLayoutSurrogateProxyBox get renderObject =>
      super.renderObject as _RenderLayoutSurrogateProxyBox;

  Element? _overlayChild;
  Element? _child;

  @override
  void mount(Element? parent, Object? newSlot) {
    super.mount(parent, newSlot);
    final _OverlayPortal widget = this.widget as _OverlayPortal;
    _child = updateChild(_child, widget.child, null);
    _overlayChild = updateChild(_overlayChild, widget.overlayChild, widget.overlayLocation);
  }

  @override
  void update(_OverlayPortal newWidget) {
    super.update(newWidget);
    _child = updateChild(_child, newWidget.child, null);
    _overlayChild = updateChild(_overlayChild, newWidget.overlayChild, newWidget.overlayLocation);
  }

  @override
  void forgetChild(Element child) {
    // The _overlayChild Element does not have a key because the _DeferredLayout
    // widget does not take a Key, so only the regular _child can be taken
    // during global key reparenting.
    assert(child == _child);
    _child = null;
    super.forgetChild(child);
  }

  @override
  void visitChildren(ElementVisitor visitor) {
    final Element? child = _child;
    final Element? overlayChild = _overlayChild;
    if (child != null) {
      visitor(child);
    }
    if (overlayChild != null) {
      visitor(overlayChild);
    }
  }

  @override
  void activate() {
    super.activate();
    final _RenderDeferredLayoutBox? box = _overlayChild?.renderObject as _RenderDeferredLayoutBox?;
    if (box != null) {
      assert(!box.attached);
      assert(renderObject._deferredLayoutChild == box);
      // updateChild has not been called at this point so the RenderTheater in
      // the overlay location could be detached. Adding children to a detached
      // RenderObject is still allowed however this isn't the most efficient.
      (_overlayChild!.slot! as _OverlayEntryLocation)._activate(box);
    }
  }

  @override
  void deactivate() {
    // Instead of just detaching the render objects, removing them from the
    // render subtree entirely. This is a workaround for the
    // !renderObject.attached assert in the `super.deactivate()` method.
    final _RenderDeferredLayoutBox? box = _overlayChild?.renderObject as _RenderDeferredLayoutBox?;
    if (box != null) {
      (_overlayChild!.slot! as _OverlayEntryLocation)._deactivate(box);
    }
    super.deactivate();
  }

  @override
  void insertRenderObjectChild(RenderBox child, _OverlayEntryLocation? slot) {
    assert(child.parent == null, "$child's parent is not null: ${child.parent}");
    if (slot != null) {
      renderObject._deferredLayoutChild = child as _RenderDeferredLayoutBox;
      slot._addChild(child);
      renderObject.markNeedsSemanticsUpdate();
    } else {
      renderObject.child = child;
    }
  }

  // The [_DeferredLayout] widget does not have a key so there will be no
  // reparenting between _overlayChild and _child, thus the non-null-typed slots.
  @override
  void moveRenderObjectChild(
    _RenderDeferredLayoutBox child,
    _OverlayEntryLocation oldSlot,
    _OverlayEntryLocation newSlot,
  ) {
    assert(newSlot._debugIsLocationValid());
    newSlot._moveChild(child, oldSlot);
    renderObject.markNeedsSemanticsUpdate();
  }

  @override
  void removeRenderObjectChild(RenderBox child, _OverlayEntryLocation? slot) {
    if (slot == null) {
      renderObject.child = null;
      return;
    }
    assert(renderObject._deferredLayoutChild == child);
    slot._removeChild(child as _RenderDeferredLayoutBox);
    renderObject._deferredLayoutChild = null;
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties.add(DiagnosticsProperty<Element>('child', _child, defaultValue: null));
    properties.add(DiagnosticsProperty<Element>('overlayChild', _overlayChild, defaultValue: null));
    properties.add(
      DiagnosticsProperty<Object>('overlayLocation', _overlayChild?.slot, defaultValue: null),
    );
  }
}

class _DeferredLayout extends SingleChildRenderObjectWidget {
  const _DeferredLayout({
    // This widget must not be given a key: we currently do not support
    // reparenting between the overlayChild and child.
    required Widget child,
  }) : super(child: child);

  _RenderLayoutSurrogateProxyBox getLayoutParent(BuildContext context) {
    return context.findAncestorRenderObjectOfType<_RenderLayoutSurrogateProxyBox>()!;
  }

  @override
  _RenderDeferredLayoutBox createRenderObject(BuildContext context) {
    final _RenderLayoutSurrogateProxyBox parent = getLayoutParent(context);
    final _RenderDeferredLayoutBox renderObject = _RenderDeferredLayoutBox(parent);
    parent._deferredLayoutChild = renderObject;
    return renderObject;
  }

  @override
  void updateRenderObject(BuildContext context, _RenderDeferredLayoutBox renderObject) {
    assert(renderObject._layoutSurrogate == getLayoutParent(context));
    assert(getLayoutParent(context)._deferredLayoutChild == renderObject);
  }
}

// A `RenderProxyBox` that defers its layout until its `_layoutSurrogate` (which
// is not necessarily an ancestor of this RenderBox, but shares at least one
// `_RenderTheater` ancestor with this RenderBox) is laid out.
//
// This `RenderObject` must be a child of a `_RenderTheater`. It guarantees that:
//
// 1. It's a relayout boundary, so calling `markNeedsLayout` on it never dirties
//    its `_RenderTheater`.
//
// 2. Its `layout` implementation is overridden such that `performLayout` does
//    not do anything when its called from `layout`, preventing the parent
//    `_RenderTheater` from laying out this subtree prematurely (but this
//    `RenderObject` may still be resized). Instead, `markNeedsLayout` will be
//    called from within `layout` to schedule a layout update for this relayout
//    boundary when needed.
//
// 3. When invoked from `PipelineOwner.flushLayout`, or
//    `_layoutSurrogate.performLayout`, this `RenderObject` behaves like an
//    `Overlay` that has only one entry.
final class _RenderDeferredLayoutBox extends RenderProxyBox
    with _RenderTheaterMixin, LinkedListEntry<_RenderDeferredLayoutBox> {
  _RenderDeferredLayoutBox(this._layoutSurrogate);

  StackParentData get stackParentData => parentData! as StackParentData;
  final _RenderLayoutSurrogateProxyBox _layoutSurrogate;

  @override
  Iterable<RenderBox> _childrenInPaintOrder() {
    final RenderBox? child = this.child;
    return child == null
        ? const Iterable<RenderBox>.empty()
        : Iterable<RenderBox>.generate(1, (int i) => child);
  }

  @override
  Iterable<RenderBox> _childrenInHitTestOrder() => _childrenInPaintOrder();

  @override
  _RenderTheater get theater {
    final RenderObject? parent = this.parent;
    return parent is _RenderTheater
        ? parent
        : throw FlutterError('$parent of $this is not a _RenderTheater');
  }

  @override
  void redepthChildren() {
    _layoutSurrogate.redepthChild(this);
    super.redepthChildren();
  }

  @override
  bool get sizedByParent => true;

  bool _needsLayout = true;
  @override
  void markNeedsLayout() {
    _needsLayout = true;
    super.markNeedsLayout();
  }

  @override
  RenderObject? get semanticsParent => _layoutSurrogate;

  @override
  double? computeDryBaseline(BoxConstraints constraints, TextBaseline baseline) {
    final RenderBox? child = this.child;
    if (child == null) {
      return null;
    }
    return _RenderTheaterMixin.baselineForChild(
      child,
      constraints.biggest,
      constraints,
      theater._resolvedAlignment,
      baseline,
    );
  }

  @override
  RenderObject? get debugLayoutParent => _layoutSurrogate;

  void layoutByLayoutSurrogate() {
    assert(!_theaterDoingThisLayout);
    final _RenderTheater? theater = parent as _RenderTheater?;
    if (theater == null || !attached) {
      assert(false, '$this is not attached to parent');
      return;
    }
    if (theater._layingOutSizeDeterminingChild) {
      theater.invokeLayoutCallback((BoxConstraints constraints) {
        markNeedsLayout();
      });
    } else {
      final BoxConstraints theaterConstraints = theater.constraints;
      final Size boxSize =
          theaterConstraints.biggest.isFinite
              ? theaterConstraints.biggest
              // Accessing the theater's size is only unsafe if it is laying out the
              // size-determining child.
              : theater.size;
      super.layout(BoxConstraints.tight(boxSize));
    }
  }

  bool _theaterDoingThisLayout = false;
  @override
  void layout(Constraints constraints, {bool parentUsesSize = false}) {
    assert(_needsLayout == debugNeedsLayout);
    // Only _RenderTheater calls this implementation.
    assert(parent != null);
    final bool scheduleDeferredLayout = _needsLayout || this.constraints != constraints;
    assert(!_theaterDoingThisLayout);
    _theaterDoingThisLayout = true;
    super.layout(constraints, parentUsesSize: parentUsesSize);
    assert(_theaterDoingThisLayout);
    _theaterDoingThisLayout = false;
    _needsLayout = false;
    assert(!debugNeedsLayout);
    if (scheduleDeferredLayout) {
      final _RenderTheater parent = this.parent! as _RenderTheater;
      // Invoking markNeedsLayout as a layout callback allows this node to be
      // merged back to the `PipelineOwner`'s dirty list in the right order, if
      // it's not already dirty. Otherwise this may cause some dirty descendants
      // to performLayout a second time.
      parent.invokeLayoutCallback((BoxConstraints constraints) {
        markNeedsLayout();
      });
    }
  }

  @override
  void performResize() {
    size = constraints.biggest;
  }

  bool _debugMutationsLocked = false;
  @override
  void performLayout() {
    assert(!_debugMutationsLocked);
    if (_theaterDoingThisLayout) {
      _needsLayout = false;
      return;
    }
    assert(() {
      _debugMutationsLocked = true;
      return true;
    }());
    // This method is directly being invoked from `PipelineOwner.flushLayout`,
    // or from `_layoutSurrogate`'s performLayout.
    assert(parent != null);
    final RenderBox? child = this.child;
    if (child == null) {
      _needsLayout = false;
      return;
    }
    assert(constraints.isTight);
    layoutChild(child, constraints);
    assert(() {
      _debugMutationsLocked = false;
      return true;
    }());
    _needsLayout = false;
  }

  @override
  void applyPaintTransform(RenderBox child, Matrix4 transform) {
    final BoxParentData childParentData = child.parentData! as BoxParentData;
    final Offset offset = childParentData.offset;
    transform.translate(offset.dx, offset.dy);
  }
}

// A RenderProxyBox that makes sure its `deferredLayoutChild` has a greater
// depth than itself.
class _RenderLayoutSurrogateProxyBox extends RenderProxyBox {
  _RenderDeferredLayoutBox? _deferredLayoutChild;

  @override
  void redepthChildren() {
    super.redepthChildren();
    final _RenderDeferredLayoutBox? child = _deferredLayoutChild;
    // If child is not attached, this method will be invoked by child's real
    // parent when it's attached.
    if (child != null && child.attached) {
      assert(child.attached);
      redepthChild(child);
    }
  }

  @override
  void performLayout() {
    super.performLayout();
    // Try to layout `_deferredLayoutChild` here now that its configuration
    // and constraints are up-to-date. Additionally, during the very first
    // layout, this makes sure that _deferredLayoutChild is reachable via tree
    // walk.
    _deferredLayoutChild?.layoutByLayoutSurrogate();
  }

  @override
  void visitChildrenForSemantics(RenderObjectVisitor visitor) {
    super.visitChildrenForSemantics(visitor);
    final _RenderDeferredLayoutBox? deferredChild = _deferredLayoutChild;
    if (deferredChild != null) {
      visitor(deferredChild);
    }
  }
}


Instructions for the chapter (Generate content in English unless specified otherwise):
- Start with a clear heading (e.g., `# Chapter 6: _Theater
`). Use the provided concept name.

- If this is not the first chapter, begin with a brief transition from the previous chapter, referencing it with a proper Markdown link using its name.

- Begin with a high-level motivation explaining what problem this abstraction solves. Start with a central use case as a concrete example. The whole chapter should guide the reader to understand how to solve this use case. Make it very minimal and friendly to beginners.

- If the abstraction is complex, break it down into key concepts. Explain each concept one-by-one in a very beginner-friendly way.

- Explain how to use this abstraction to solve the use case. Give example inputs and outputs for code snippets (if the output isn't values, describe at a high level what will happen).

- Each code block should be BELOW 10 lines! If longer code blocks are needed, break them down into smaller pieces and walk through them one-by-one. Aggresively simplify the code to make it minimal. Use comments to skip non-important implementation details. Each code block should have a beginner friendly explanation right after it.

- Describe the internal implementation to help understand what's under the hood. First provide a non-code or code-light walkthrough on what happens step-by-step when the abstraction is called. It's recommended to use a simple sequenceDiagram with a dummy example - keep it minimal with at most 5 participants to ensure clarity. If participant name has space, use: `participant QP as Query Processing`. .

- Then dive deeper into code for the internal implementation with references to files. Provide example code blocks, but make them similarly simple and beginner-friendly. Explain.

- IMPORTANT: When you need to refer to other core abstractions covered in other chapters, ALWAYS use proper Markdown links like this: [Chapter Title](filename.md). Use the Complete Tutorial Structure above to find the correct filename and the chapter title. Translate the surrounding text.

- Use mermaid diagrams to illustrate complex concepts (```mermaid``` format). .

- Heavily use analogies and examples throughout to help beginners understand.

- End the chapter with a brief conclusion that summarizes what was learned and provides a transition to the next chapter. If there is a next chapter, use a proper Markdown link: [Next Chapter Title](next_chapter_filename).

- Ensure the tone is welcoming and easy for a newcomer to understand.

- Output *only* the Markdown content for this chapter.

Now, directly provide a super beginner-friendly Markdown output (DON'T need ```markdown``` tags):

2025-05-22 23:58:44,217 - INFO - RESPONSE: # Chapter 6: _Theater

Welcome back, Flutter explorers! In our [previous chapters](01_overlay_.md), we've uncovered the secrets of the [Overlay](01_overlay_.md), the [OverlayState](02_overlaystate_.md) manager, and the [OverlayEntry](03_overlayentry_.md) or [OverlayPortal](04_overlayportal_.md) which hold the actual widgets we want to show on top. We learned how to insert and remove these entries using the [OverlayState](02_overlaystate_.md) or the [OverlayPortalController](05_overlayportalcontroller_.md), causing widgets to magically appear and disappear on the screen's surface.

But how do these widgets, bundled inside their [OverlayEntry](03_overlayentry_.md)s or managed by their [OverlayPortal](04_overlayportal_.md)s, actually get placed and painted on top of the rest of the UI? Who is responsible for taking the list of active entries and arranging their widgets visually like layers on the overhead projector?

Enter the **`_Theater`**!

Think of the `_Theater` as the physical stage where all the overlay actors (your overlay widgets) perform. It's a specialized **layout engine** that the [OverlayState](02_overlaystate_.md) uses to arrange all the widgets from the active [OverlayEntry](03_overlayentry_.md)s and [OverlayPortal](04_overlayportal_.md)s. It stacks them, one on top of the other, similar to how a `Stack` widget works. The widgets are arranged from bottom to top based on their order in the list provided by the [OverlayState](02_overlaystate_.md).

Our goal throughout this tutorial has been to understand how to display widgets on top of everything. The `_Theater` is the widget *inside* the [Overlay](01_overlay_.md) that makes the final visual magic happen by taking the children (your overlay widgets) and painting them in the correct order.

### Where Does the _Theater Live?

We briefly saw the `_Theater` in the `OverlayState`'s `build` method in [Chapter 1](01_overlay_.md). Let's look at that simplified snippet again:

```dart
class OverlayState extends State<Overlay> with TickerProviderStateMixin {
  final List<OverlayEntry> _entries = <OverlayEntry>[];

  // ... methods for inserting and removing entries ...

  @protected
  @override
  Widget build(BuildContext context) {
    // ... logic to determine visible entries and create widgets ...
    final List<_OverlayEntryWidget> children = <_OverlayEntryWidget>[];
    // ... populate children based on _entries (and other logic) ...
    return _Theater(
      // ... properties like skipCount, clipBehavior ...
      children: children.reversed.toList(growable: false), // THIS IS WHERE _Theater GETS THE WIDGETS!
    );
  }

  // ... other methods
}
```

The `OverlayState` is the `State` object for the [Overlay] widget. When the [OverlayState](02_overlaystate_.md) needs to update its display (because an entry was inserted, removed, or changed), its `build` method is called.

Inside `build`, the `OverlayState` goes through its internal list of active [OverlayEntry](03_overlayentry_.md) and determines which ones should be painted. It also accounts for overlay children managed by [OverlayPortal](04_overlayportal_.md)s. For each widget that needs to be on the screen, it creates a special internal widget called `_OverlayEntryWidget`.

These `_OverlayEntryWidget`s (which in turn contain the widgets you provided in your `OverlayEntry` `builder` or `OverlayPortal` `overlayChildBuilder`) are collected into a list. **This list is then passed as the `children` to the `_Theater` widget.**

The `_Theater` is the very last widget built by the `OverlayState`. It takes all the widgets from your overlay entries and portals and arranges them within the bounds of the `Overlay`.

### _Theater's Role: Layout and Painting

The `_Theater` is a specialized version of a Flutter `Stack`. Its primary responsibilities are:

1.  **Layout:** Determining the size and position of each child widget. Like a `Stack`, children that are not `Positioned` will be laid out based on the `alignment` (which defaults to `topStart` in the `_Theater`'s internal logic, effectively aligning to the top-left unless overridden) and the available space. `Positioned` children (like the ones we used in our [OverlayPortal](04_overlayportal_.md) example context menu) use the `top`, `bottom`, `left`, `right`, `width`, and `height` properties to determine their size and location relative to the `_Theater`'s boundaries (which are the same as the `Overlay`'s boundaries).
2.  **Painting:** Painting the children one on top of the other. The `_Theater` paints its children in the order they appear in its `children` list. Since the `OverlayState` passes the list in reversed order (from top to bottom of the conceptual stack), **the `_Theater` paints the last child in its list on top.** This is how the visual stacking is achieved  the widgets that should appear highest are painted last.

The `_Theater` also has a `skipCount` property (passed from `OverlayState`). This property tells the `_Theater` to completely ignore the first `skipCount` children for both layout and painting. This is an optimization used by the `OverlayState` when there are opaque entries higher in the stack; any entries below the opaque ones can potentially be skipped if they aren't marked with `maintainState`.

```dart
// Simplified snippet from _Theater's paint method (internal Flutter code)
@override
void paint(PaintingContext context, Offset offset) {
  // Loops through children in a specific order...
  for (final RenderBox child in _childrenInPaintOrder()) {
    final StackParentData childParentData = child.parentData! as StackParentData;
    // Paints each child at its calculated offset
    context.paintChild(child, childParentData.offset + offset);
  }
}
```

This snippet from the internal `_RenderTheater` (the render object counterpart of the `_Theater` widget) shows the core painting loop. It iterates through the children in paint order (which is determined by the order received from `OverlayState`, potentially modified by `skipCount` and handling `OverlayPortal` children correctly) and calls `context.paintChild`, effectively drawing each widget onto the screen on top of the previous one.

### _Theater vs. Stack

You might wonder, why not just use a regular `Stack`? The `_Theater` is specialized for the `Overlay`'s needs:

*   **Integration with OverlayEntry and OverlayPortal Logic:** It works correctly with the internal `_OverlayEntryWidgetState` and `_OverlayEntryLocation` to handle children from both direct [OverlayEntry] insertions and [OverlayPortal]s, respecting the paint order determined by the [OverlayState] and [OverlayPortalController] `show()` calls.
*   **`skipCount` Optimization:** It supports the `skipCount` property for performance optimization with opaque entries, which a standard `Stack` does not.
*   **Semantics:** It handles the semantics tree correctly for offstage children.

So, while it lays out and paints like a `Stack`, it's specifically tuned for the way the [OverlayState] manages its children.

### Sequence Diagram: _Theater's Role in Painting

Let's visualize `_Theater`'s role during the paint phase after the `OverlayState` has rebuilt:

```mermaid
sequenceDiagram
    participant OverlayState
    participant _Theater
    participant OverlayEntryWidget as _OverlayEntryWidget (for Entry 1)
    participant OverlayEntryWidget2 as _OverlayEntryWidget (for Entry 2)
    participant OverlayChildRenderObject as RenderBox (from OverlayChild)
    participant OverlayRenderTree as Overlay Render Tree

    OverlayState->>_Theater: build(_Theater) with children list
    _Theater->>OverlayRenderTree: process children, create RenderObjects (_RenderTheater)
    OverlayRenderTree->>OverlayRenderTree: perform layout on children (like Stack)
    OverlayRenderTree->>OverlayRenderTree: start paint phase
    OverlayRenderTree->>OverlayEntryWidget: ask Widget 1 to paint
    OverlayEntryWidget->>OverlayRenderTree: paint Widget 1 at calculated position
    OverlayRenderTree->>OverlayEntryWidget2: ask Widget 2 to paint (on top of Widget 1)
    OverlayEntryWidget2->>OverlayRenderTree: paint Widget 2 at calculated position
    OverlayRenderTree->>OverlayChildRenderObject: ask OverlayPortal child to paint (on top of Widget 2)
    OverlayChildRenderObject->>OverlayRenderTree: paint OverlayPortal child
```

This diagram shows that the `_Theater` widget's render object (`_RenderTheater`) is the one performing the actual layout and painting of the children provided by the `OverlayState`. It happens after the widget tree building phase and the layout phase, where the `_RenderTheater` determines where each child render object should be drawn.

### Peek into the Code (_Theater)

Let's look at the `_Theater` widget definition itself:

```dart
class _Theater extends MultiChildRenderObjectWidget {
  const _Theater({
    this.skipCount = 0,
    this.clipBehavior = Clip.hardEdge,
    required List<_OverlayEntryWidget> super.children,
  }) : assert(skipCount >= 0),
       assert(children.length >= skipCount);

  final int skipCount;
  final Clip clipBehavior;

  @override
  _TheaterElement createElement() => _TheaterElement(this);

  @override
  _RenderTheater createRenderObject(BuildContext context) {
    return _RenderTheater( // Creates the associated RenderObject
      skipCount: skipCount,
      textDirection: Directionality.of(context),
      clipBehavior: clipBehavior,
    );
  }

  @override
  void updateRenderObject(BuildContext context, _RenderTheater renderObject) {
    renderObject // Updates the RenderObject properties
      ..skipCount = skipCount
      ..textDirection = Directionality.of(context)
      ..clipBehavior = clipBehavior;
  }
  // ... debugFillProperties ...
}
```

Key points:

*   It's a `MultiChildRenderObjectWidget`, meaning it's a widget that manages a list of children and has a single corresponding render object that manages their layout and painting.
*   It takes `skipCount` and `clipBehavior` as properties.
*   It creates a `_TheaterElement` (the intermediate element in the tree) and a `_RenderTheater` (the low-level render object). The real layout and paint logic live in the `_RenderTheater`.
*   `updateRenderObject` is used by the framework to update the properties of the existing `_RenderTheater` instance when the `_Theater` widget is rebuilt with different properties.

And a tiny peek at the `_RenderTheater`:

```dart
class _RenderTheater extends RenderBox with ContainerRenderObjectMixin<RenderBox, StackParentData>, _RenderTheaterMixin {
  // ... constructor, properties ...

  // This mixin provides common stack-like logic
  @override
  _RenderTheater get theater => this;

  // ... setupParentData, attach, detach ...

  // This method is where the actual layout of children happens
  @override
  void performLayout() {
    // ... logic similar to Stack layout ...
    // Lays out visible children based on Positioned or default alignment
  }

  // This method is where the actual painting of children happens
  @override
  void paint(PaintingContext context, Offset offset) {
     // ... iterates through children in paint order and paints them ...
  }

  // ... hitTestChildren, debug methods ...
}
```

The `_RenderTheater` extends `RenderBox` (meaning it's a box-shaped render object), uses `ContainerRenderObjectMixin` and `_RenderTheaterMixin` to get multi-child management and stack-like behavior, and overrides `performLayout` and `paint` to implement the core logic we discussed. The `_RenderTheaterMixin` provides shared logic related to handling the children, including those managed by [OverlayPortal]s.

### Conclusion

In this chapter, we demystified the `_Theater`. We learned that it is the specialized widget used internally by the [OverlayState](02_overlaystate_.md) to perform the critical task of laying out and painting the widgets from active [OverlayEntry](03_overlayentry_.md)s and [OverlayPortal](04_overlayportal_.md)s on top of each other, much like a `Stack`. We saw its key role in the `OverlayState`'s build method and got a high-level understanding of how its associated render object, `_RenderTheater`, handles the layout and painting process, including optimizations like `skipCount`.

While you rarely interact directly with `_Theater`, understanding its existence and role helps complete the picture of how the `overlay.dart` components work together to display elements on top of your UI.

In the next chapter, we'll touch upon another internal render object related to `OverlayPortal`s: [_RenderDeferredLayoutBox](07__renderdeferredlayoutbox_.md), and understand why its layout is "deferred".

[_RenderDeferredLayoutBox](07__renderdeferredlayoutbox_.md)
2025-05-22 23:58:44,234 - INFO - PROMPT: 
Write a very beginner-friendly tutorial chapter (in Markdown format) for the project `flutter (overlay.dart)` about the concept: "_RenderDeferredLayoutBox
". This is Chapter 7.

Concept Details:
- Name: _RenderDeferredLayoutBox

- Description:
This is an internal behind-the-scenes helper for OverlayPortal. It receives the widget that should be shown on the Overlay but doesn't lay it out immediately. Instead, it waits for its layout "surrogate" (_RenderLayoutSurrogateProxyBox, the OverlayPortal's own render box) to be laid out first. This ensures the OverlayPortal's floating widget is laid out correctly relative to the Overlay itself, even though it's managed separately.


Complete Tutorial Structure:
1. [Overlay
](01_overlay_.md)
2. [OverlayState
](02_overlaystate_.md)
3. [OverlayEntry
](03_overlayentry_.md)
4. [OverlayPortal
](04_overlayportal_.md)
5. [OverlayPortalController
](05_overlayportalcontroller_.md)
6. [_Theater
](06__theater_.md)
7. [_RenderDeferredLayoutBox
](07__renderdeferredlayoutbox_.md)
8. [_OverlayEntryLocation
](08__overlayentrylocation_.md)

Context from previous chapters:
# Chapter 1: Overlay

Welcome to the first chapter of our tutorial on Flutter's `overlay.dart`! In this chapter, we'll introduce you to the fundamental concept of an `Overlay`.

Have you ever seen temporary popups, like dialogs, tooltips that appear over your regular screen content, no matter what's currently displayed? How does Flutter manage to show these elements *on top* of everything else? That's where the `Overlay` comes in!

Think of your Flutter app's user interface as a stack of layers, like transparencies on an overhead projector. Your main screen content is on the bottom layer. When you want to show something *over* that content, without affecting how the main content is arranged, you place it on a new, transparent layer on top. The `Overlay` widget is like the frame of this overhead projector that holds the stack of transparent sheets.

The `Overlay` itself is a widget that sits high up in your app's widget tree, often provided automatically by powerful widgets like `MaterialApp` or `WidgetsApp`. It manages a list of "sheets," called [OverlayEntry](03_overlayentry_.md)s. Each [OverlayEntry](03_overlayentry_.md) can hold a widget, and these widgets will be painted *above* the `Overlay`'s regular content.

So, the core idea is:

**An `Overlay` is a stack of entry points where you can place widgets that should appear on top of your primary UI.**

### Our Goal: Displaying a Simple Overlay

To understand the `Overlay` better, let's imagine we want to display a simple message box that floats in the center of the screen when a button is pressed. This message box should appear above all other content on the screen.

Using the `Overlay` and its related components, we can achieve this. Here's the high-level plan:

1.  Find the nearest `Overlay`.
2.  Create an [OverlayEntry](03_overlayentry_.md) containing our message box widget.
3.  Insert this [OverlayEntry](03_overlayentry_.md) into the `Overlay`'s stack.
4.  When we want to hide the message box, we'll remove the [OverlayEntry](03_overlayentry_.md) from the `Overlay`.

### Finding the Overlay

The `Overlay` is usually introduced by the main app widgets like `MaterialApp`. To interact with this `Overlay`, we need to get its state, which is an [OverlayState](02_overlaystate_.md). We can do this using the `Overlay.of` method, passing the current `BuildContext`.

```dart
// Inside a widget's build method or a function called from it:
OverlayState? overlayState = Overlay.of(context);
```

This code snippet uses `Overlay.of(context)` to look up the closest `OverlayState` in the widget tree above the current `context`. If an `Overlay` is found, it gives us its state (the [OverlayState](02_overlaystate_.md) object) that we can use to manage our overlay entries. If no `Overlay` is found (which is unlikely in a typical `MaterialApp`), it would cause an error in debug mode.

### What's Inside the Overlay?

While we don't see it directly in the minimal code we write, the `Overlay` widget itself contains some interesting pieces to manage its entries.

Let's look at a relevant snippet from the `overlay.dart` file:

```dart
class Overlay extends StatefulWidget {
  // ... other properties and methods

  @override
  OverlayState createState() => OverlayState();
}
```

This shows that the `Overlay` widget creates an [OverlayState](02_overlaystate_.md). This is the object we obtained using `Overlay.of`. The [OverlayState](02_overlaystate_.md) is where the real work of managing the list of [OverlayEntry](03_overlayentry_.md) objects happens.

Further down in the code, we see how the `OverlayState` builds its UI:

```dart
class OverlayState extends State<Overlay> with TickerProviderStateMixin {
  final List<OverlayEntry> _entries = <OverlayEntry>[];

  // ... methods for inserting and removing entries

  @protected
  @override
  Widget build(BuildContext context) {
    // ... logic to determine visible entries
    final List<_OverlayEntryWidget> children = <_OverlayEntryWidget>[];
    // ... populate children based on _entries
    return _Theater(
      // ... properties like skipCount, clipBehavior
      children: children.reversed.toList(growable: false),
    );
  }

  // ... other methods
}
```

This snippet reveals a crucial part: the `OverlayState` holds a list of `_entries` (our [OverlayEntry](03_overlayentry_.md) objects). In its `build` method, it creates a list of `_OverlayEntryWidget`s corresponding to the active entries. These widgets are then passed to a special widget called `_Theater`.

The `_Theater` widget is essentially a specialized `Stack`. It's responsible for laying out and painting the widgets from the [OverlayEntry](03_overlayentry_.md)s on top of each other, similar to how layers are stacked in a `Stack`.

Here's a simplified illustration of the key participants and their relationships in displaying an overlay entry:

```mermaid
sequenceDiagram
    participant YourWidget
    participant OverlayDotOf as Overlay.of(context)
    participant OverlayState
    participant OverlayEntry
    participant _Theater

    YourWidget->>OverlayDotOf: Ask for OverlayState
    OverlayDotOf-->>OverlayState: Return the found OverlayState
    YourWidget->>OverlayState: Create and insert OverlayEntry
    OverlayState->>OverlayEntry: Add entry to internal list
    OverlayState->>OverlayState: Schedule rebuild
    OverlayState->>_Theater: Build _Theater with entries as children
    _Theater->>OverlayEntry: Ask entry to build its widget
    OverlayEntry->>_Theater: Return built widget
    _Theater->>_Theater: Layout and paint entry's widget on top

```

This diagram shows that your widget interacts with the global `Overlay.of` to get the [OverlayState](02_overlaystate_.md). You then use the [OverlayState](02_overlaystate_.md) to manage your [OverlayEntry](03_overlayentry_.md). The [OverlayState](02_overlaystate_.md) internally uses `_Theater` to visually stack the widgets provided by the [OverlayEntry](03_overlayentry_.md)s.

### Conclusion

In this chapter, we introduced the concept of the `Overlay` in Flutter. We learned that it acts as a container for widgets that should appear on top of the regular UI, managing them as a stack of [OverlayEntry](03_overlayentry_.md) objects. We saw how to find the `OverlayState` using `Overlay.of` and got a peek into the internal structure involving `_Theater`.

In the next chapter, we will delve deeper into the [OverlayState](02_overlaystate_.md) and explore how to use its methods to actually insert and remove [OverlayEntry](03_overlayentry_.md) objects, allowing us to finally display our floating message box.

[OverlayState](02_overlaystate_.md)
---
# Chapter 2: OverlayState

Welcome back! In our [previous chapter](01_overlay_.md), we learned that an `Overlay` acts like a transparent layer on top of our regular UI, managed by powerful widgets like `MaterialApp`. We also saw that this `Overlay` holds a stack of "sheets" called [OverlayEntry](03_overlayentry_.md)s. But who is in charge of managing these sheets? That's where the `OverlayState` comes in.

Think of the `Overlay` as the physical structure (the overhead projector frame) and the `OverlayState` as the person operating that projector. The `OverlayState` is the **manager** for the `Overlay`. Its main job is to keep track of which [OverlayEntry](03_overlayentry_.md) sheets are currently in the stack and decide which ones are visible.

Our goal from the last chapter was to display a simple message box that floats in the center of the screen when a button is pressed. To do this, we need to:

1.  Find the `OverlayState` associated with our `Overlay`.
2.  Create an [OverlayEntry](03_overlayentry_.md) containing our message box widget.
3.  Tell the `OverlayState` to **insert** this [OverlayEntry](03_overlayentry_.md) into its stack.
4.  When we want to hide the message box, tell the `OverlayState` to **remove** the [OverlayEntry](03_overlayentry_.md).

In this chapter, we'll focus on how to use the `OverlayState` to perform these insertions and removals.

### Getting the OverlayState

As we briefly saw in the last chapter, we can get the `OverlayState` using the static method `Overlay.of`. This method looks up the widget tree from the given `BuildContext` and finds the nearest `Overlay` widget's state.

```dart
// Inside a widget where you want to show an overlay:
void showMyMessageBox(BuildContext context) {
  OverlayState? overlayState = Overlay.of(context);
  // Now we have the manager (the OverlayState)!
}
```

Here, `Overlay.of(context)` does the important work of finding the correct `OverlayState` for us. The `context` tells Flutter where in the widget tree we are looking from. In a typical app, this `OverlayState` will be the one managed by your `MaterialApp` or `WidgetsApp`.

### Adding an OverlayEntry

Once we have the `OverlayState`, we can add new entries to it. The `OverlayState` has an `insert` method for this purpose. The `insert` method takes an [OverlayEntry](03_overlayentry_.md) object as its argument.

Let's imagine we have created our `OverlayEntry` object (we'll learn more about [OverlayEntry](03_overlayentry_.md) in the next chapter, for now just assume it exists).

```dart
// Continuing from the previous snippet:
void showMyMessageBox(BuildContext context) {
  OverlayState? overlayState = Overlay.of(context);

  if (overlayState != null) {
    // Assume 'myOverlayEntry' is an instance of OverlayEntry
    // that holds our message box widget.
    OverlayEntry myOverlayEntry = createMessageBoxEntry(); // Placeholder function

    overlayState.insert(myOverlayEntry);
    print('Message box inserted!');
  } else {
    print('Could not find OverlayState!');
  }
}

// Placeholder for creating the OverlayEntry
OverlayEntry createMessageBoxEntry() {
  // This would contain the actual widget for the message box
  return OverlayEntry(
    builder: (context) => Center(
      child: Container(
        width: 200,
        height: 100,
        color: Colors.blue,
        child: Center(child: Text('Hello Overlay!')),
      ),
    ),
  );
}
```

In this code:
1.  We get the `overlayState`.
2.  We check if it's not null (meaning an `Overlay` was found).
3.  We create an `OverlayEntry` (using `createMessageBoxEntry`).
4.  We call `overlayState.insert(myOverlayEntry)`. This is the key step! It tells the `OverlayState` to add our entry to its internal list.

When an `OverlayEntry` is inserted, the `OverlayState` marks itself as needing to rebuild. During the next build cycle, the `OverlayState` will include the widget from your newly inserted [OverlayEntry](03_overlayentry_.md) in its list of visible children, making it appear on top of your UI.

### Ordering OverlayEntries

The `insert` method also allows you to control where the entry is inserted in the stack:

*   `overlayState.insert(entry)`: Inserts the entry at the very top (painted last).
*   `overlayState.insert(entry, below: someOtherEntry)`: Inserts the entry just below `someOtherEntry`.
*   `overlayState.insert(entry, above: someOtherEntry)`: Inserts the entry just above `someOtherEntry`.

This is like deciding whether to place your new transparency sheet on the very top of the stack, or insert it right above or below another specific sheet. This is useful for complex overlays or when integrating with system overlays like dialogs or routes managed by the Navigator.

### Removing an OverlayEntry

Adding entries is only half the story. We also need to be able to remove them. For example, when the user closes our message box, we want to take it off the overlay.

To remove an [OverlayEntry](03_overlayentry_.md), you call the `remove()` method directly on the **[OverlayEntry](03_overlayentry_.md) object itself**, not on the `OverlayState`.

```dart
// Continuing the example, we need to keep track of the inserted entry:
OverlayEntry? currentMessageBoxEntry; // Store the active entry

void showMyMessageBox(BuildContext context) {
  // ... find overlayState ...
  if (overlayState != null) {
    // Create and store the entry before inserting
    currentMessageBoxEntry = createMessageBoxEntry();
    overlayState.insert(currentMessageBoxEntry!); // Insert it
    print('Message box inserted!');

    // Example: Automatically remove after 3 seconds (for demonstration)
    Future.delayed(Duration(seconds: 3), () {
      removeMyMessageBox();
    });

  } else {
    print('Could not find OverlayState!');
  }
}

// Function to remove the message box
void removeMyMessageBox() {
  if (currentMessageBoxEntry != null) {
    currentMessageBoxEntry!.remove(); // Call remove on the entry!
    currentMessageBoxEntry = null; // Clear the stored entry
    print('Message box removed!');
  }
}

// (createMessageBoxEntry function remains the same)
// (Remember to import 'package:flutter/material.dart' for Colors/Container/Text)
```

In this updated code:
1.  We declare `currentMessageBoxEntry` to hold a reference to the [OverlayEntry](03_overlayentry_.md) once it's created and inserted.
2.  When showing the box, we assign the new entry to this variable.
3.  When removing the box (`removeMyMessageBox`), we check if `currentMessageBoxEntry` is not null and call its `remove()` method.
4.  After removing, we set `currentMessageBoxEntry` back to null.

Calling `entry.remove()` tells the `OverlayState` to take that specific [OverlayEntry](03_overlayentry_.md) out of its list. Similar to insertion, the `OverlayState` will then mark itself dirty and rebuild, this time *without* including the widget from the removed entry.

### How OverlayState Manages Entries Internally

Let's look peek under the hood again. We saw in the snippet from the last chapter that `OverlayState` holds a `List<OverlayEntry> _entries`. This is the core list it manages.

When you call `insert`:

```dart
// From overlay.dart -> OverlayState -> insert method (simplified)
void insert(OverlayEntry entry, {OverlayEntry? below, OverlayEntry? above}) {
  // ... asserts ...
  entry._overlay = this; // Internal link back to this OverlayState
  setState(() { // Marks state as dirty, schedules a rebuild
    _entries.insert(_insertionIndex(below, above), entry); // Adds to the list
  });
}
```

*   `entry._overlay = this;`: The [OverlayEntry](03_overlayentry_.md) keeps a reference to the `OverlayState` it belongs to. This is how `entry.remove()` knows *which* `OverlayState` to tell to remove it.
*   `setState(() { ... });`: This is standard Flutter State management. It signals to the framework that the state of the `OverlayState` has changed (`_entries` list is different) and it needs to be rebuilt.
*   `_entries.insert(...)`: This is the actual list manipulation. It adds the `entry` at the calculated position in the internal `_entries` list.

When the `OverlayState` rebuilds, its `build` method creates the UI using the current contents of `_entries`. We saw that it uses a widget called `_Theater` for this:

```dart
// From overlay.dart -> OverlayState -> build method (simplified)
@override
Widget build(BuildContext context) {
  // ... logic to determine visible entries ...
  final List<_OverlayEntryWidget> children = <_OverlayEntryWidget>[];
  // Loop through _entries (and inactive maintainedState entries)
  // and create _OverlayEntryWidget for each.
  return _Theater(
    // ...
    children: children.reversed.toList(growable: false), // Passes the list to _Theater
  );
}
```

The `_Theater` is essentially a specialized container that takes a list of child widgets (built from the [OverlayEntry](03_overlayentry_.md)s) and stacks them on top of each other. The children are given to `_Theater` in reversed order because the `_entries` list is ordered from bottom to top, but a `Stack` (which `_Theater` behaves like) paints children from bottom to top based on their position in the list. So, the last entry in `_entries` (the top-most one) needs to be the last child given to `_Theater`.

Here's a sequence diagram illustrating insertion:

```mermaid
sequenceDiagram
    participant YourWidget
    participant OverlayState
    participant OverlayEntry
    participant Framework as Flutter Framework
    participant _Theater

    YourWidget->>OverlayState: call insert(OverlayEntry)
    OverlayState->>OverlayEntry: set internal _overlay reference
    OverlayState->>OverlayState: add OverlayEntry to _entries list
    OverlayState->>Framework: call setState()
    Framework->>OverlayState: scheduled rebuild
    OverlayState->>OverlayState: call build()
    OverlayState->>OverlayEntry: call builder() to get widget
    OverlayEntry->>OverlayState: return widget
    OverlayState->>_Theater: pass widget as child
    _Theater->>_Theater: layout and paint widget on top
```

When you call `entry.remove()`:

```dart
// From overlay.dart -> OverlayEntry -> remove method (simplified)
void remove() {
  assert(_overlay != null);
  final OverlayState overlay = _overlay!; // Get the associated OverlayState
  _overlay = null; // Clear the internal reference

  // ... schedule markDirty or call directly ...
  overlay._entries.remove(this); // Remove from the OverlayState's list
  overlay._markDirty(); // Tell the OverlayState to rebuild
  // ...
}
```

*   `_overlay!`: Accesses the `OverlayState` that this entry is currently in.
*   `_entries.remove(this);`: The `OverlayEntry` tells its manager (`_overlay`) to remove itself from the list.
*   `overlay._markDirty();`: Calls an internal method on the `OverlayState` to signal that it needs to rebuild.

The diagram for removal is similar to insertion, just in reverse:

```mermaid
sequenceDiagram
    participant YourWidget
    participant OverlayEntry
    participant OverlayState
    participant Framework as Flutter Framework
    participant _Theater

    YourWidget->>OverlayEntry: call remove()
    OverlayEntry->>OverlayState: access internal _overlay reference
    OverlayEntry->>OverlayEntry: clear internal _overlay reference
    OverlayEntry->>OverlayState: remove OverlayEntry from _entries list
    OverlayState->>OverlayState: call _markDirty()
    OverlayState->>Framework: setState() called implicitly
    Framework->>OverlayState: scheduled rebuild
    OverlayState->>OverlayState: call build()
    OverlayState->>_Theater: pass children (without the removed entry)
    _Theater->>_Theater: relayout and repaint (entry disappears)
```

This demonstrates how the `OverlayState` acts as the central hub, maintaining the list and triggering UI updates when the list of [OverlayEntry](03_overlayentry_.md) objects changes.

### Conclusion

In this chapter, we explored the crucial role of the `OverlayState`. We learned that it is the manager for an [Overlay](01_overlay_.md), holding the list of [OverlayEntry](03_overlayentry_.md) objects and controlling their visibility. We saw how to obtain the `OverlayState` using `Overlay.of` and, most importantly, how to use its `insert` method to add [OverlayEntry](03_overlayentry_.md)s to the overlay stack and how to call `remove` directly on an [OverlayEntry](03_overlayentry_.md) to take it out.

We also took a look at the internal workings, seeing how `OverlayState`'s `_entries` list is manipulated and how `setState` triggers a rebuild to update the UI using the [_Theater](06__theater_.md) widget.

Now that we understand the container ([Overlay](01_overlay_.md)) and its manager (`OverlayState`), it's time to delve into the "sheets" themselves: the [OverlayEntry](03_overlayentry_.md). In the next chapter, we'll learn how to create our own [OverlayEntry](03_overlayentry_.md) objects with the specific widgets we want to display on the overlay.

[OverlayEntry](03_overlayentry_.md)
---
# Chapter 3: OverlayEntry

Welcome back to our `overlay.dart` tutorial! In the [previous chapters](01_overlay_.md), we learned about the [Overlay](01_overlay_.md) as a container that sits on top of our UI and the [OverlayState](02_overlaystate_.md) as its manager, responsible for inserting and removing items from the overlay stack.

But what exactly are these "items" or "sheets" that get placed onto the [Overlay](01_overlay_.md)? That's where the `OverlayEntry` comes in!

Think of an `OverlayEntry` as a single, transparent sheet that you prepare to put onto the [Overlay](01_overlay_.md)'s overhead projector. This sheet has one purpose: to hold and display **a single widget** on the overlay.

Our goal is to display a simple message box that floats in the center of the screen when a button is pressed. To do this using the [Overlay](01_overlay_.md) and [OverlayState](02_overlaystate_.md), we need to wrap our message box widget inside an `OverlayEntry`.

So, an `OverlayEntry` is the object that carries the self-contained piece of UI you want to show on top of your regular content. It's the payload that the [OverlayState](02_overlaystate_.md) manages.

### Creating an OverlayEntry

Creating an `OverlayEntry` is straightforward. You just need to provide a `builder` function. This `builder` function is a standard Flutter `WidgetBuilder` that takes a `BuildContext` and should return the widget you want to display on the overlay.

Here's how we would create an `OverlayEntry` for our simple message box:

```dart
// This function creates an OverlayEntry for our message box.
OverlayEntry createMessageBoxEntry() {
  OverlayEntry entry = OverlayEntry(
    builder: (BuildContext context) {
      // The widget that will be shown on the overlay
      return Center( // Center it on the overlay
        child: Container(
          width: 200,
          height: 100,
          color: Colors.blue,
          child: const Center(child: Text('Hello OverlayEntry!')),
        ),
      );
    },
  );
  return entry;
}
```

In this snippet:

*   `OverlayEntry(...)`: We call the `OverlayEntry` constructor.
*   `builder: (BuildContext context) { ... }`: We provide the required `builder` function. Flutter will call this function when it needs to display our entry on the overlay.
*   Inside the `builder`, we return a `Center` widget containing our blue message `Container`. This widget is what the `OverlayEntry` will represent visually on the overlay.

Now, when we get the [OverlayState](02_overlaystate_.md) (as shown in the [previous chapter](02_overlaystate_.md)) and call `overlayState.insert(entry)`, our beautiful blue box will appear centered on the screen!

### OverlayEntry Properties: Opaque and MaintainState

Besides the `builder`, `OverlayEntry` has a couple of important properties: `opaque` and `maintainState`. These properties control how the `Overlay` handles layers below this specific entry.

*   **`opaque` (default: `false`)**: If set to `true`, this property signals to the [Overlay](01_overlay_.md) that this entry completely covers whatever is beneath it in the overlay stack. This is mainly an optimization hint. If an entry is `opaque`, the [Overlay](01_overlay_.md) can skip building or painting the parts of the entries below it that are covered. Think of putting a solid, colored sheet on the overhead projector  you can't see through it to the sheets below. Our message box isn't truly opaque unless it fills the whole screen, but for performance, you might mark a dialog or a full-screen route as opaque.

*   **`maintainState` (default: `false`)**: If set to `true`, this property tells the [Overlay](01_overlay_.md) to keep the widget hierarchy for this entry active, even if it's visually hidden by an `opaque` entry on top. This is like keeping the light on for a sheet even if a solid sheet is on top. This is useful for things like keeping the state of a background route alive in a Navigator, even when another route is covering it entirely. Setting this to `true` can use more resources, so use it only when necessary.

For our simple message box, neither of these needs to be `true`. It doesn't cover everything below it entirely (it's just a small box), and we don't need to maintain its state when it's not visible (we'll remove it when hidden). So, the default values work fine.

```dart
OverlayEntry createMessageBoxEntry() {
  return OverlayEntry(
    builder: (BuildContext context) {
      // Our message box widget
      return Center(
        child: Container(
          width: 200,
          height: 100,
          color: Colors.blue,
          child: const Center(child: Text('Hello OverlayEntry!')),
        ),
      );
    },
    // opaque: false, // Default and appropriate for a small box
    // maintainState: false, // Default and appropriate as we remove it
  );
}
```

### Removing an OverlayEntry

As we saw in the [previous chapter](02_overlaystate_.md), to remove an `OverlayEntry`, you call the `remove()` method directly on the `OverlayEntry` object itself.

```dart
// Assuming you have a variable to hold the entry:
OverlayEntry? myActiveMessageBoxEntry;

void hideMyMessageBox() {
  if (myActiveMessageBoxEntry != null) {
    myActiveMessageBoxEntry!.remove(); // Tell the entry to remove itself
    myActiveMessageBoxEntry = null; // Clear our reference
  }
}
```

When `entry.remove()` is called:
1. The `OverlayEntry` looks up the [OverlayState](02_overlaystate_.md) it was inserted into (it holds an internal reference).
2. It tells that [OverlayState](02_overlaystate_.md) to remove it from its list of entries.
3. The [OverlayState](02_overlaystate_.md) rebuilds, and since the entry is no longer in its list, the widget built by this entry's `builder` is no longer included in the UI, making it disappear.

### How OverlayEntry Works Internally

Let's revisit the code snippet from `overlay.dart` for `OverlayEntry`:

```dart
class OverlayEntry implements Listenable {
  // ... constructor and properties ...

  OverlayState? _overlay; // Internal reference to the managing OverlayState
  final GlobalKey<_OverlayEntryWidgetState> _key = GlobalKey<_OverlayEntryWidgetState>();

  /// Remove this entry from the overlay.
  void remove() {
    assert(_overlay != null);
    final OverlayState overlay = _overlay!; // Get the associated OverlayState
    _overlay = null; // Clear the internal reference

    // ... scheduling logic ...
    overlay._entries.remove(this); // Request removal from the OverlayState's list
    overlay._markDirty(); // Tell the OverlayState to rebuild
    // ...
  }

  /// Cause this entry to rebuild during the next pipeline flush.
  ///
  /// You need to call this function if the output of [builder] has changed.
  void markNeedsBuild() {
    assert(!_disposedByOwner);
    _key.currentState?._markNeedsBuild();
  }

  // ... dispose method and other internal details ...
}
```

Key takeaways from this snippet:

*   `OverlayState? _overlay;`: This private variable is how an `OverlayEntry` knows which [OverlayState](02_overlaystate_.md) it belongs to. This reference is set when you call `overlayState.insert(entry)`.
*   `final GlobalKey<_OverlayEntryWidgetState> _key`: Each `OverlayEntry` uses a `GlobalKey` to identify the actual widget (`_OverlayEntryWidget`) that the [OverlayState](02_overlaystate_.md) creates to represent this entry in the widget tree.
*   `remove()`: When you call `remove()`, it uses the `_overlay` reference to find the correct [OverlayState](02_overlaystate_.md) and tells it to remove `this` entry from its internal `_entries` list (`overlay._entries.remove(this)`). It then sets `_overlay` to `null` and calls `overlay._markDirty()` to trigger a rebuild of the [OverlayState](02_overlaystate_.md).
*   `markNeedsBuild()`: If the widget you return from your `builder` function changes (e.g., based on some state within the `OverlayEntry`), you can call `markNeedsBuild()` on the `OverlayEntry` to tell the system that its visual representation needs to be updated. This calls `setState` on the internal `_OverlayEntryWidgetState` associated with this entry's `_key`.

Here's a sequence diagram focusing on the OverlayEntry's role in removal:

```mermaid
sequenceDiagram
    participant YourWidget
    participant OverlayEntry
    participant OverlayState
    participant Framework as Flutter Framework

    YourWidget->>OverlayEntry: call remove()
    OverlayEntry->>OverlayEntry: access internal _overlay reference
    OverlayEntry->>OverlayEntry: clear internal _overlay reference
    OverlayEntry->>OverlayState: remove OverlayEntry from _entries list
    OverlayState->>OverlayState: call _markDirty() (triggers setState)
    OverlayState->>Framework: schedule build
    Framework->>OverlayState: call build()
    OverlayState->>OverlayEntry: Build logic skips removed entry
    OverlayEntry->>Framework: Widget no longer added to tree
    Framework->>Framework: UI updated (entry disappears)
```

This confirms that the `OverlayEntry` is primarily a data holder for the widget and properties, and it delegates the actual UI management (insertion and removal from the visual tree) back to the [OverlayState](02_overlaystate_.md) it belongs to.

### Conclusion

In this chapter, we focused on the `OverlayEntry`, the core object that holds the widget you want to display on an [Overlay](01_overlay_.md). We learned how to create a basic `OverlayEntry` using a `builder` function, how to use its `opaque` and `maintainState` properties, and how calling `remove()` on the entry itself signals to the managing [OverlayState](02_overlaystate_.md) to take it off the screen.

We also briefly looked at the internal structure, understanding that `OverlayEntry` keeps a reference to its [OverlayState](02_overlaystate_.md) and manages a `GlobalKey` to its corresponding widget in the overlay tree.

With the concepts of [Overlay](01_overlay_.md), [OverlayState](02_overlaystate_.md), and `OverlayEntry` under our belt, we now have the foundational knowledge to display custom widgets on top of our application content at a global level!

In the next chapter, we will introduce [OverlayPortal](04_overlayportal_.md), a more modern and often simpler alternative to directly managing `OverlayEntry` objects, especially when you want an overlay widget to stay closely connected to the state and context of its originating widget.

[OverlayPortal](04_overlayportal_.md)
---
# Chapter 4: OverlayPortal

Welcome back! In our [previous chapters](01_overlay_.md), we built a solid understanding of the [Overlay](01_overlay_.md), the [OverlayState](02_overlaystate_.md) (its manager), and the [OverlayEntry](03_overlayentry_.md) (the sheet holding the widget). We learned how to manually create an [OverlayEntry](03_overlayentry_.md), get the [OverlayState](02_overlaystate_.md), and insert/remove the entry to make a widget appear or disappear on top of everything.

While this manual approach works, sometimes it can feel a bit disconnected. You have your original widget (say, a button that triggers the overlay), and the overlay widget itself is managed separately by the [OverlayState](02_overlaystate_.md), potentially far away in the widget tree. This can make things like keeping the overlay visually positioned relative to the original widget or having the overlay widget inherit themes/context from the original widget's location a bit tricky.

This is where `OverlayPortal` comes in!

Think of `OverlayPortal` as a special window from your widget's location directly to the [Overlay](01_overlay_.md). You place the `OverlayPortal` widget in your widget tree like any other widget. When you want to show something on the [Overlay](01_overlay_.md), you tell the `OverlayPortal`, and it uses a builder function you provide to create the widget.

**The key idea is that the widget you want to show on the [Overlay](01_overlay_.md) feels like it's still attached to your `OverlayPortal`'s spot in the widget tree, even though it's visually displayed on the [Overlay](01_overlay_.md).**

### Our Goal: A Context Menu

Let's refine our goal. Instead of just a simple message box, imagine we want a small context menu to appear right next to a button when you tap it. This menu should float on the [Overlay](01_overlay_.md), but its position should be related to the button, and it should inherit styling (like text themes) from where the button is located.

Using `OverlayPortal`, this becomes much more natural than manual [OverlayEntry](03_overlayentry_.md) management.

### Creating an OverlayPortal

An `OverlayPortal` is a `StatefulWidget` you add to your widget tree. It requires a `controller` (an [OverlayPortalController](05_overlayportalcontroller_.md), which we'll cover in the next chapter) and an `overlayChildBuilder`.

```dart
// Inside your widget's build method:
OverlayPortal(
  controller: _myOverlayController, // We'll make this in the next chapter
  overlayChildBuilder: (BuildContext context) {
    // This is the widget that will show on the Overlay
    return Positioned( // We'll position it later
      top: 100, // Just a placeholder for now
      left: 100, // Just a placeholder for now
      child: Material( // Use Material for styling/elevation
        elevation: 4.0,
        child: Container(
          padding: const EdgeInsets.all(8.0),
          color: Colors.yellow[100],
          child: Text('Context Menu!'),
        ),
      ),
    );
  },
  child: ElevatedButton( // This is the original widget (the button)
    onPressed: () {
      // We will show the overlay here using the controller
    },
    child: const Text('Show Menu'),
  ),
)
```

In this example:

1.  We place the `OverlayPortal` widget in our tree.
2.  We give it an `overlayChildBuilder`. This is very similar to the `builder` for an [OverlayEntry](03_overlayentry_.md)  it's the function that creates the widget for the overlay.
3.  We add a `child` property. This is the regular child widget of the `OverlayPortal` (our `ElevatedButton`).

The widget returned by `overlayChildBuilder` (`Positioned` in this case) will be displayed on the [Overlay](01_overlay_.md), but its `BuildContext` will be a special one that's linked back to the `OverlayPortal`'s location. This is why it can easily inherit themes, etc., from its original position.

Notice that we are using a `Positioned` widget directly in the `overlayChildBuilder`. This is common because `OverlayPortal`'s overlay child is placed within the [Overlay](01_overlay_.md) which behaves like a `Stack`. `Positioned` widgets are used to control the placement of children within a `Stack`.

### How OverlayPortal Works Internally (High Level)

When Flutter lays out the widget tree, it encounters the `OverlayPortal`. Importantly, when its `overlayChildBuilder` *is active* (meaning you've told the controller to show the overlay):

1.  The `OverlayPortal`'s `Element` (specifically an `_OverlayPortalElement`) calls its `overlayChildBuilder` to get the overlay widget.
2.  Instead of painting this widget directly where the `OverlayPortal` is located in the tree, the `_OverlayPortalElement` finds the nearest ancestor [Overlay](01_overlay_.md) (using an internal mechanism involving an `InheritedWidget`, which we'll see later).
3.  It then inserts the *render object* corresponding to the overlay widget into the `_RenderTheater` (the specialized `Stack` that the [Overlay](01_overlay_.md) uses to manage its visual children).
4.  The render object is placed correctly relative to other things on the [Overlay](01_overlay_.md) based on the order defined by the `OverlayPortalController`.
5.  The original `OverlayPortal` widget then continues its standard layout and painting for its `child` widget (the button), as if the overlay widget wasn't there.

This gives the illusion that the overlay widget is coming from the `OverlayPortal`'s location, even though its physical rendering happens on the [Overlay](01_overlay_.md).

Sequence diagram illustrating the key interaction:

```mermaid
sequenceDiagram
    participant YourWidget
    participant OverlayPortal
    participant _OverlayPortalState
    participant _OverlayPortalElement
    participant _TheaterMarker as InheritedWidget
    participant OverlayState
    participant _RenderTheater

    YourWidget->>OverlayPortal: build time (includes OverlayPortal)
    OverlayPortal->>_OverlayPortalState: create state
    _OverlayPortalState->>_OverlayPortalElement: mount element
    _OverlayPortalElement->>_TheaterMarker: look up ancestor Overlay info
    _TheaterMarker-->>_OverlayPortalElement: provide _RenderTheater etc.
    YourWidget->>YourWidget: trigger show via controller (next chapter)
    YourWidget->>_OverlayPortalState: call controller.show()
    _OverlayPortalState->>_OverlayPortalState: update internal state (_zOrderIndex)
    _OverlayPortalState->>YourWidget: setState() triggers rebuild
    YourWidget->>OverlayPortal: rebuild with show=true
    OverlayPortal->>_OverlayPortalElement: update element
    _OverlayPortalElement->>_OverlayPortalElement: call overlayChildBuilder
    _OverlayPortalElement->>_RenderTheater: attach overlay child render object
    _RenderTheater->>_RenderTheater: paint child on overlay
```

This shows how the `OverlayPortal` lives in your regular widget tree but has the ability to "reach out" to the ancestor [Overlay](01_overlay_.md)'s render object tree (`_RenderTheater`) to place its overlay child's render objects there.

### Advantages of OverlayPortal over Manual OverlayEntry

*   **Simplified Management:** You don't manually create, store, insert, or remove [OverlayEntry](03_overlayentry_.md) objects. The `OverlayPortal` widget handles this for you based on the state of its controller.
*   **Context and Inherited Widgets:** The `BuildContext` provided to `overlayChildBuilder` is closely tied to the `OverlayPortal`'s original location. This means your overlay widget automatically inherits themes, `MediaQuery`, `Localizations`, etc., making styling and layout much easier.
*   **State Management:** The lifecycle of the overlay widget is tied to the `OverlayPortal`. If the `OverlayPortal` is disposed, the overlay widget goes away too. This simplifies managing the state of complex overlay children.
*   **Relative Positioning:** While basic `Positioned` works, `OverlayPortal` makes it easier to use widgets like `CompositedTransformTarget` and `CompositedTransformFollower` to position the overlay child precisely relative to the `OverlayPortal`'s location. We used a simple `Positioned` as a placeholder for now, but later chapters might explore this.

### Limitations

*   **Must have an ancestor `Overlay`:** Just like manual [OverlayEntry](03_overlayentry_.md), the `OverlayPortal` needs an [Overlay](01_overlay_.md) widget higher up in the tree to paint on. (Usually provided by `MaterialApp`, `WidgetsApp`, or `Navigator`.)
*   **Requires a controller:** You need to manage an [OverlayPortalController](05_overlayportalcontroller_.md) to show/hide the overlay.

### Peek into the Code

Let's look at the `OverlayPortal` class definition:

```dart
class OverlayPortal extends StatefulWidget {
  const OverlayPortal({
    super.key,
    required this.controller,
    required this.overlayChildBuilder,
    this.child,
  }) : _targetRootOverlay = false;

  // ... (targetsRootOverlay constructor) ...

  final OverlayPortalController controller;
  final WidgetBuilder overlayChildBuilder;
  final Widget? child;
  final bool _targetRootOverlay;

  @override
  State<OverlayPortal> createState() => _OverlayPortalState();
}
```

This confirms it's a `StatefulWidget` (hence the need for a `State` object, `_OverlayPortalState`, which will manage the connection to the [Overlay](01_overlay_.md) and the rendering). It takes the required `controller` and `overlayChildBuilder` and an optional `child`.

The `createState()` method simply returns `_OverlayPortalState()`. This is where the logic connecting to the actual [Overlay](01_overlay_.md) will live.

Looking at the `_OverlayPortalState` (parts shown in the file):

```dart
class _OverlayPortalState extends State<OverlayPortal> {
  int? _zOrderIndex; // Controls visibility and paint order

  // ... (methods like show, hide, didUpdateWidget, dispose) ...

  @override
  Widget build(BuildContext context) {
    final int? zOrderIndex = _zOrderIndex;
    if (zOrderIndex == null) {
      // If not showing, return a simple widget that just renders the child
      return _OverlayPortal(overlayLocation: null, overlayChild: null, child: widget.child);
    }
    // If showing, return a special widget that connects to the Overlay
    return _OverlayPortal(
      overlayLocation: _getLocation(zOrderIndex, widget._targetRootOverlay),
      overlayChild: _DeferredLayout(child: Builder(builder: widget.overlayChildBuilder)),
      child: widget.child,
    );
  }
}
```

Here, in `_OverlayPortalState`'s `build` method:

1.  It checks the `_zOrderIndex`. This private variable is controlled by the [OverlayPortalController](05_overlayportalcontroller_.md) (`show` sets it to a timestamp, `hide` sets it to null). The value of `_zOrderIndex` also determines the paint order on the [Overlay](01_overlay_.md).
2.  If `_zOrderIndex` is null (not showing), it returns a simple internal widget (`_OverlayPortal`) with `overlayChild: null`.
3.  If `_zOrderIndex` is not null (showing), it returns the `_OverlayPortal` widget again, but this time it provides an `overlayLocation` (obtained via `_getLocation`) and wraps the result of the `overlayChildBuilder` in a `_DeferredLayout` widget.

The `_OverlayPortal` widget is an internal `RenderObjectWidget` that manages the actual render object connection. `_DeferredLayout` is a key internal widget we'll touch on briefly; it's related to how the layout of the overlay child widget is handled (it's "deferred" until the [Overlay](01_overlay_.md) is ready to lay it out).

The `_getLocation` method is where the `_OverlayPortalState` finds the necessary information about the ancestor [Overlay](01_overlay_.md) by talking to an `InheritedWidget` (`_RenderTheaterMarker`).

```dart
class _RenderTheaterMarker extends InheritedWidget {
  // ... properties (theater, overlayEntryWidgetState) ...
  static _RenderTheaterMarker of(BuildContext context, {bool targetRootOverlay = false}) {
    // ... looks up the nearest or root _RenderTheaterMarker ...
    // ... returns the marker containing info about the Overlay's render objects ...
  }
}
```

This `_RenderTheaterMarker` is an `InheritedWidget` placed in the widget tree by the [OverlayState](02_overlaystate_.md) (specifically by the `_OverlayEntryWidget` which represents a single entry's content). It holds references to the key rendering objects of the [Overlay](01_overlay_.md) (`_RenderTheater`) and the specific [OverlayEntry](03_overlayentry_.md) the `OverlayPortal` is logically contained within (`_OverlayEntryWidgetState`). This mechanism allows the `_OverlayPortalState` to easily find the correct place in the render tree to insert its overlay child.

All of these internal pieces work together to take the widget from your `overlayChildBuilder` and insert its corresponding render object into the [Overlay]'s render tree (`_RenderTheater`) *at the correct paint order level relative to other [OverlayEntry](03_overlayentry_.md)s*.

### Conclusion

In this chapter, we introduced `OverlayPortal` as a more convenient way to display widgets on an [Overlay](01_overlay_.md). We learned that it allows the overlay widget to conceptually remain linked to the `OverlayPortal`'s location in the widget tree, making context inheritance simpler. We saw the basic structure of `OverlayPortal` with its `overlayChildBuilder` and optional `child`, and got a high-level understanding of how it uses internal widgets and render objects (`_OverlayPortal`, `_DeferredLayout`, `_RenderTheaterMarker`) to insert the overlay child's render object into the ancestor [Overlay](01_overlay_.md)'s `_RenderTheater`.

To actually control *when* the overlay child is shown or hidden, we need the `controller`. In the next chapter, we will explore the [OverlayPortalController](05_overlayportalcontroller_.md) and complete our context menu example.

[OverlayPortalController](05_overlayportalcontroller_.md)
---
# Chapter 5: OverlayPortalController

Welcome to Chapter 5! In our [previous chapter](04_overlayportal_.md), we were introduced to `OverlayPortal`, a special widget that lets you place a child widget onto the global [Overlay](01_overlay_.md) while still feeling connected to the `OverlayPortal`'s spot in the widget tree. We set up the `OverlayPortal` with an `overlayChildBuilder` to define our context menu widget, but we couldn't make it actually appear yet.

To control when an `OverlayPortal` shows or hides its overlay child, we need a remote control! That remote control is the **`OverlayPortalController`**.

Think of the `OverlayPortalController` as a dedicated switch for a single `OverlayPortal`. You give the controller to the `OverlayPortal`, and then you use the methods on that controller to tell the `OverlayPortal` what to do.

Our goal is still to show a small context menu right next to a button when it's tapped. The `OverlayPortalController` is the key piece that lets us trigger this action from the button's `onPressed` callback.

### What is OverlayPortalController?

An `OverlayPortalController` is a simple object that provides methods to manage the visibility and paint order of the `OverlayPortal`'s overlay child. It has three main actions:

*   **`show()`**: Makes the overlay child widget built by the `OverlayPortal`'s `overlayChildBuilder` appear on the [Overlay](01_overlay_.md). If it's already showing, calling `show()` again brings it to the very top of the overlay stack (above other things controlled by different OverlayPortals).
*   **`hide()`**: Hides the overlay child widget. It will be removed from the [Overlay](01_overlay_.md).
*   **`toggle()`**: Switches the state. If it's hidden, it shows it. If it's showing, it hides it.

It also has a property:

*   **`isShowing`**: A boolean (`true` or `false`) that tells you if the overlay child is currently visible on the [Overlay](01_overlay_.md) via this controller.

### Creating and Using an OverlayPortalController

You need to create an instance of `OverlayPortalController`. Since the controller holds the state of whether the overlay is showing or not, it should typically live in a `State` object.

```dart
// Inside a StatefulWidget's State class:
class _MyWidgetState extends State<MyWidget> {
  // Create the controller
  final OverlayPortalController _contextMenuController = OverlayPortalController();

  // Remember to dispose of the controller when the State is disposed
  @override
  void dispose() {
    _contextMenuController.dispose(); // Necessary cleanup!
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    // ... button and OverlayPortal will go here ...
    return Scaffold( // Example wrapper
      appBar: AppBar(title: const Text('Overlay Portal Example')),
      body: Center( // Center the button
        child: OverlayPortal(
          // Provide the controller to the OverlayPortal!
          controller: _contextMenuController,
          overlayChildBuilder: (BuildContext context) {
            // This is the widget that will show on the Overlay
            // We'll refine positioning later, for now a placeholder:
            Offset buttonPosition = const Offset(100, 100); // Placeholder
            return Positioned(
              top: buttonPosition.dy,
              left: buttonPosition.dx,
              child: Material(
                elevation: 4.0,
                child: Container(
                  padding: const EdgeInsets.all(8.0),
                  color: Colors.yellow[100],
                  child: const Text('Context Menu!'),
                ),
              ),
            );
          },
          // The button we tap to show/hide the menu
          child: ElevatedButton(
            onPressed: () {
              // Use the controller to toggle the menu!
              _contextMenuController.toggle();
            },
            child: const Text('Show/Hide Menu'),
          ),
        ),
      ),
    );
  }
}
```

In this code snippet:

1.  We declare a `final OverlayPortalController _contextMenuController` within our `_MyWidgetState`. It's `final` because we create the controller once.
2.  **Crucially, we call `_contextMenuController.dispose()` in the `dispose()` method of the state.** This is important cleanup to release resources when the widget and its state are removed.
3.  We pass this `_contextMenuController` to the `OverlayPortal` widget using the `controller:` property. This establishes the link between the remote control and the device.
4.  Inside the `onPressed` callback of the `ElevatedButton` (which is the `child` of the `OverlayPortal`), we simply call `_contextMenuController.toggle()`.

Now, when you tap the button, the `toggle()` method on the controller is called. The `OverlayPortal` linked to this controller sees this, and if it wasn't showing, it triggers the creation and display of the widget from its `overlayChildBuilder` onto the [Overlay](01_overlay_.md)! Tapping again calls `toggle()` again, sees it's showing, and calls `hide()`, removing the widget.

### Positioning the Overlay Child

In the example above, our context menu appears at a fixed `Positioned(top: 100, left: 100)`. This isn't very useful for a context menu that should appear next to the button that triggered it.

The `BuildContext` given to the `overlayChildBuilder` is very helpful here. It represents the context *at the location of the `OverlayPortal`*. We can use this context to find the position of the `OverlayPortal` (and thus the button, since it's its child) on the screen!

1.  We need to get the `RenderBox` of the `OverlayPortal`. We can use a `GlobalKey` for this.
2.  We can then use the `localToGlobal` method on the `RenderBox` to find its position relative to the entire screen (or the [Overlay](01_overlay_.md)).

```dart
// Inside a StatefulWidget's State class:
class _MyWidgetState extends State<MyWidget> {
  final OverlayPortalController _contextMenuController = OverlayPortalController();
  // Add a GlobalKey to get the RenderBox of the button/OverlayPortal
  final GlobalKey _buttonKey = GlobalKey();

  @override
  void dispose() {
    _contextMenuController.dispose();
    super.dispose();
  }

  void _showMenu() {
    if (_buttonKey.currentContext != null) {
      // Get the RenderBox of the widget associated with the key
      final RenderBox renderBox = _buttonKey.currentContext!.findRenderObject() as RenderBox;
      // Get the position of the *top-left* corner of the button
      final Offset buttonPosition = renderBox.localToGlobal(Offset.zero);
      // Get the size of the button
      final Size buttonSize = renderBox.size;

      // We'll need the position and size in the overlayChildBuilder
      // How to pass this info? We can store it in the State.
      // Let's update the builder to use state variables.

      // Now, tell the controller to show the overlay
      _contextMenuController.show(); // Use show instead of toggle for clearer logic
    }
  }

  // Need variables to store the button's position and size
  Offset _buttonPosition = Offset.zero;
  Size _buttonSize = Size.zero;

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(title: const Text('Overlay Portal Example')),
      body: Center(
        child: OverlayPortal(
          controller: _contextMenuController,
          overlayChildBuilder: (BuildContext context) {
            // Use the stored position and size to position the menu
            // Let's place the menu just below the button
            return Positioned(
              // Place the top of the menu at the bottom of the button
              top: _buttonPosition.dy + _buttonSize.height,
              // Align the left edge of the menu with the left edge of the button
              left: _buttonPosition.dx,
              child: Material(
                elevation: 4.0,
                child: Container(
                  padding: const EdgeInsets.all(8.0),
                  color: Colors.yellow[100],
                  child: const Text('Context Menu!'),
                ),
              ),
            );
          },
          // Wrap the child (the button) with the GlobalKey and onPressed that calls _showMenu
          child: SizedBox( // Use SizedBox to apply the key directly
            key: _buttonKey, // Attach the key here!
            child: ElevatedButton(
              onPressed: _showMenu, // Call our _showMenu function
              child: const Text('Show Menu'),
            ),
          ),
        ),
      ),
    );
  }
}
```

Now, our `_showMenu` function finds the button's position on the screen using the `_buttonKey`, stores this position and size in state variables, and then calls `_contextMenuController.show()`. The `overlayChildBuilder` then uses these state variables (`_buttonPosition` and `_buttonSize`) to calculate where to place the `Positioned` widget, making the menu appear right below the button.

To hide the menu, you'd typically add a tap detector outside the menu or a close button within the menu that calls `_contextMenuController.hide()`.

```dart
// Add this helper function to hide the menu
void _hideMenu() {
   _contextMenuController.hide();
}

// Update the overlayChildBuilder to include a GestureDetector to hide taps outside the menu
overlayChildBuilder: (BuildContext context) {
  return Stack( // Use a Stack to layer the tap catcher below the menu
    children: [
      Positioned.fill(
         // A transparent widget that catches taps outside the menu content
         child: GestureDetector(
           onTap: _hideMenu, // Hide the menu when tapped outside
           behavior: HitTestBehavior.translucent, // Ensure it catches taps
         ),
      ),
      Positioned(
         top: _buttonPosition.dy + _buttonSize.height,
         left: _buttonPosition.dx,
         child: Material(
           elevation: 4.0,
           child: Container(
             padding: const EdgeInsets.all(8.0),
             color: Colors.yellow[100],
             child: const Text('Context Menu!'),
           ),
         ),
      ),
    ],
  );
},
```

This updated `overlayChildBuilder` wraps the `Positioned` menu inside a `Stack`. A `Positioned.fill` `GestureDetector` is placed on top of the entire overlay area (filling the [Overlay](01_overlay_.md)). This transparent detector catches taps *anywhere* on the overlay that isn't blocked by the menu itself and calls `_hideMenu`, making the menu disappear when the user taps outside of it.

### How OverlayPortalController Works Internally

When you call `_contextMenuController.show()` or `_contextMenuController.hide()`:

1.  The `OverlayPortalController` communicates with the `_OverlayPortalState` object it's currently attached to.
2.  The `_OverlayPortalState` updates its internal state, specifically the `_zOrderIndex` variable. `show()` sets this to a new unique timestamp (using `_now()`), `hide()` sets it to `null`.
3.  Updating this state triggers a `setState()` call within the `_OverlayPortalState`.
4.  `setState()` tells the Flutter framework that the `_OverlayPortalState` needs to rebuild.
5.  During the rebuild, the `_OverlayPortalState`'s `build` method checks the `_zOrderIndex`:
    *   If it's `null`, it returns a version of the internal `_OverlayPortal` widget that doesn't include the overlay child (`overlayChild: null`).
    *   If it's not `null`, it returns the `_OverlayPortal` widget with the `overlayChildBuilder`'s widget included (`overlayChild: _DeferredLayout(...)`).
6.  When the framework processes this update, if the `overlayChild` has changed from `null` to a widget (or vice-versa), the corresponding render objects are attached/detached from the ancestor [Overlay]'s [_RenderTheater](07__renderdeferredlayoutbox_.md) render tree. The `_zOrderIndex` is used to determine the correct paint order.

Sequence diagram for calling `show()`:

```mermaid
sequenceDiagram
    participant YourWidget
    participant OverlayPortalController
    participant _OverlayPortalState
    participant Framework as Flutter Framework
    participant OverlayPortalBuild as OverlayPortal.build()
    participant _OverlayPortalElement
    participant _RenderTheater as Overlay Render Tree

    YourWidget->>OverlayPortalController: call show()
    OverlayPortalController->>_OverlayPortalState: update internal state (_zOrderIndex)
    _OverlayPortalState->>Framework: call setState()
    Framework->>_OverlayPortalState: schedule rebuild
    Framework->>_OverlayPortalState: call build()
    _OverlayPortalState->>OverlayPortalBuild: return Widget with overlay child
    OverlayPortalBuild->>_OverlayPortalElement: process widget update
    _OverlayPortalElement->>_RenderTheater: attach/position overlay child render object
    _RenderTheater->>_RenderTheater: paint child on overlay
```

The internal code snippets showed that `_OverlayPortalState` indeed has a `_zOrderIndex` and methods like `show` and `hide` that call `setState`. The `build` method's critical part is checking if `_zOrderIndex == null` to decide whether to include the `overlayChild`.

```dart
// From packages/flutter/lib/src/widgets/overlay.dart -> _OverlayPortalState
void show(int zOrderIndex) {
  // ... asserts ...
  setState(() {
    _zOrderIndex = zOrderIndex; // Update state triggers rebuild
  });
  // ... invalidate location cache ...
}

void hide() {
  // ... asserts ...
  setState(() {
    _zOrderIndex = null; // Update state triggers rebuild
  });
  // ... invalidate location cache ...
}

@override
Widget build(BuildContext context) {
  final int? zOrderIndex = _zOrderIndex; // Check the state variable
  if (zOrderIndex == null) {
    return _OverlayPortal(overlayLocation: null, overlayChild: null, child: widget.child);
  }
  // ... build with overlay child if zOrderIndex is not null ...
  return _OverlayPortal(
    // ...
    overlayChild: _DeferredLayout(child: Builder(builder: widget.overlayChildBuilder)),
    // ...
  );
}
```

This confirms our understanding: the `OverlayPortalController` is just a thin wrapper forwarding commands to the `_OverlayPortalState`, which manages the visibility state (`_zOrderIndex`) and rebuilds itself to reflect that state change in the widget tree structure passed to the framework. The actual attachment/detachment of the render object happens deeper within the element tree logic triggered by the `_OverlayPortal` widget.

### Conclusion

In this chapter, we completed our understanding of the `OverlayPortal` pattern by introducing the `OverlayPortalController`. We learned that this controller acts as the remote control, using its `show()`, `hide()`, and `toggle()` methods to signal to the linked `OverlayPortal` when to display or hide its overlay child. We saw how to create a controller, link it to an `OverlayPortal`, use it in a button's `onPressed`, and importantly, how to dispose of it. We also improved our context menu example by using a `GlobalKey` and the `BuildContext` to position the overlay child relative to the trigger widget. Finally, we confirmed our understanding by looking at the internal code where the controller updates the `_OverlayPortalState`'s `_zOrderIndex`, triggering a rebuild.

With `OverlayPortal` and `OverlayPortalController`, you can elegantly manage temporary widgets that appear on the global [Overlay](01_overlay_.md) while keeping them conceptually linked to their origins.

In the next chapter, we'll take a very brief look at the [_Theater](06__theater_.md) widget, which we've seen mentioned multiple times as the internal widget used by the [OverlayState](02_overlaystate_.md) to manage the display of its children.

[_Theater](06__theater_.md)
---
# Chapter 6: _Theater

Welcome back, Flutter explorers! In our [previous chapters](01_overlay_.md), we've uncovered the secrets of the [Overlay](01_overlay_.md), the [OverlayState](02_overlaystate_.md) manager, and the [OverlayEntry](03_overlayentry_.md) or [OverlayPortal](04_overlayportal_.md) which hold the actual widgets we want to show on top. We learned how to insert and remove these entries using the [OverlayState](02_overlaystate_.md) or the [OverlayPortalController](05_overlayportalcontroller_.md), causing widgets to magically appear and disappear on the screen's surface.

But how do these widgets, bundled inside their [OverlayEntry](03_overlayentry_.md)s or managed by their [OverlayPortal](04_overlayportal_.md)s, actually get placed and painted on top of the rest of the UI? Who is responsible for taking the list of active entries and arranging their widgets visually like layers on the overhead projector?

Enter the **`_Theater`**!

Think of the `_Theater` as the physical stage where all the overlay actors (your overlay widgets) perform. It's a specialized **layout engine** that the [OverlayState](02_overlaystate_.md) uses to arrange all the widgets from the active [OverlayEntry](03_overlayentry_.md)s and [OverlayPortal](04_overlayportal_.md)s. It stacks them, one on top of the other, similar to how a `Stack` widget works. The widgets are arranged from bottom to top based on their order in the list provided by the [OverlayState](02_overlaystate_.md).

Our goal throughout this tutorial has been to understand how to display widgets on top of everything. The `_Theater` is the widget *inside* the [Overlay](01_overlay_.md) that makes the final visual magic happen by taking the children (your overlay widgets) and painting them in the correct order.

### Where Does the _Theater Live?

We briefly saw the `_Theater` in the `OverlayState`'s `build` method in [Chapter 1](01_overlay_.md). Let's look at that simplified snippet again:

```dart
class OverlayState extends State<Overlay> with TickerProviderStateMixin {
  final List<OverlayEntry> _entries = <OverlayEntry>[];

  // ... methods for inserting and removing entries ...

  @protected
  @override
  Widget build(BuildContext context) {
    // ... logic to determine visible entries and create widgets ...
    final List<_OverlayEntryWidget> children = <_OverlayEntryWidget>[];
    // ... populate children based on _entries (and other logic) ...
    return _Theater(
      // ... properties like skipCount, clipBehavior ...
      children: children.reversed.toList(growable: false), // THIS IS WHERE _Theater GETS THE WIDGETS!
    );
  }

  // ... other methods
}
```

The `OverlayState` is the `State` object for the [Overlay] widget. When the [OverlayState](02_overlaystate_.md) needs to update its display (because an entry was inserted, removed, or changed), its `build` method is called.

Inside `build`, the `OverlayState` goes through its internal list of active [OverlayEntry](03_overlayentry_.md) and determines which ones should be painted. It also accounts for overlay children managed by [OverlayPortal](04_overlayportal_.md)s. For each widget that needs to be on the screen, it creates a special internal widget called `_OverlayEntryWidget`.

These `_OverlayEntryWidget`s (which in turn contain the widgets you provided in your `OverlayEntry` `builder` or `OverlayPortal` `overlayChildBuilder`) are collected into a list. **This list is then passed as the `children` to the `_Theater` widget.**

The `_Theater` is the very last widget built by the `OverlayState`. It takes all the widgets from your overlay entries and portals and arranges them within the bounds of the `Overlay`.

### _Theater's Role: Layout and Painting

The `_Theater` is a specialized version of a Flutter `Stack`. Its primary responsibilities are:

1.  **Layout:** Determining the size and position of each child widget. Like a `Stack`, children that are not `Positioned` will be laid out based on the `alignment` (which defaults to `topStart` in the `_Theater`'s internal logic, effectively aligning to the top-left unless overridden) and the available space. `Positioned` children (like the ones we used in our [OverlayPortal](04_overlayportal_.md) example context menu) use the `top`, `bottom`, `left`, `right`, `width`, and `height` properties to determine their size and location relative to the `_Theater`'s boundaries (which are the same as the `Overlay`'s boundaries).
2.  **Painting:** Painting the children one on top of the other. The `_Theater` paints its children in the order they appear in its `children` list. Since the `OverlayState` passes the list in reversed order (from top to bottom of the conceptual stack), **the `_Theater` paints the last child in its list on top.** This is how the visual stacking is achieved  the widgets that should appear highest are painted last.

The `_Theater` also has a `skipCount` property (passed from `OverlayState`). This property tells the `_Theater` to completely ignore the first `skipCount` children for both layout and painting. This is an optimization used by the `OverlayState` when there are opaque entries higher in the stack; any entries below the opaque ones can potentially be skipped if they aren't marked with `maintainState`.

```dart
// Simplified snippet from _Theater's paint method (internal Flutter code)
@override
void paint(PaintingContext context, Offset offset) {
  // Loops through children in a specific order...
  for (final RenderBox child in _childrenInPaintOrder()) {
    final StackParentData childParentData = child.parentData! as StackParentData;
    // Paints each child at its calculated offset
    context.paintChild(child, childParentData.offset + offset);
  }
}
```

This snippet from the internal `_RenderTheater` (the render object counterpart of the `_Theater` widget) shows the core painting loop. It iterates through the children in paint order (which is determined by the order received from `OverlayState`, potentially modified by `skipCount` and handling `OverlayPortal` children correctly) and calls `context.paintChild`, effectively drawing each widget onto the screen on top of the previous one.

### _Theater vs. Stack

You might wonder, why not just use a regular `Stack`? The `_Theater` is specialized for the `Overlay`'s needs:

*   **Integration with OverlayEntry and OverlayPortal Logic:** It works correctly with the internal `_OverlayEntryWidgetState` and `_OverlayEntryLocation` to handle children from both direct [OverlayEntry] insertions and [OverlayPortal]s, respecting the paint order determined by the [OverlayState] and [OverlayPortalController] `show()` calls.
*   **`skipCount` Optimization:** It supports the `skipCount` property for performance optimization with opaque entries, which a standard `Stack` does not.
*   **Semantics:** It handles the semantics tree correctly for offstage children.

So, while it lays out and paints like a `Stack`, it's specifically tuned for the way the [OverlayState] manages its children.

### Sequence Diagram: _Theater's Role in Painting

Let's visualize `_Theater`'s role during the paint phase after the `OverlayState` has rebuilt:

```mermaid
sequenceDiagram
    participant OverlayState
    participant _Theater
    participant OverlayEntryWidget as _OverlayEntryWidget (for Entry 1)
    participant OverlayEntryWidget2 as _OverlayEntryWidget (for Entry 2)
    participant OverlayChildRenderObject as RenderBox (from OverlayChild)
    participant OverlayRenderTree as Overlay Render Tree

    OverlayState->>_Theater: build(_Theater) with children list
    _Theater->>OverlayRenderTree: process children, create RenderObjects (_RenderTheater)
    OverlayRenderTree->>OverlayRenderTree: perform layout on children (like Stack)
    OverlayRenderTree->>OverlayRenderTree: start paint phase
    OverlayRenderTree->>OverlayEntryWidget: ask Widget 1 to paint
    OverlayEntryWidget->>OverlayRenderTree: paint Widget 1 at calculated position
    OverlayRenderTree->>OverlayEntryWidget2: ask Widget 2 to paint (on top of Widget 1)
    OverlayEntryWidget2->>OverlayRenderTree: paint Widget 2 at calculated position
    OverlayRenderTree->>OverlayChildRenderObject: ask OverlayPortal child to paint (on top of Widget 2)
    OverlayChildRenderObject->>OverlayRenderTree: paint OverlayPortal child
```

This diagram shows that the `_Theater` widget's render object (`_RenderTheater`) is the one performing the actual layout and painting of the children provided by the `OverlayState`. It happens after the widget tree building phase and the layout phase, where the `_RenderTheater` determines where each child render object should be drawn.

### Peek into the Code (_Theater)

Let's look at the `_Theater` widget definition itself:

```dart
class _Theater extends MultiChildRenderObjectWidget {
  const _Theater({
    this.skipCount = 0,
    this.clipBehavior = Clip.hardEdge,
    required List<_OverlayEntryWidget> super.children,
  }) : assert(skipCount >= 0),
       assert(children.length >= skipCount);

  final int skipCount;
  final Clip clipBehavior;

  @override
  _TheaterElement createElement() => _TheaterElement(this);

  @override
  _RenderTheater createRenderObject(BuildContext context) {
    return _RenderTheater( // Creates the associated RenderObject
      skipCount: skipCount,
      textDirection: Directionality.of(context),
      clipBehavior: clipBehavior,
    );
  }

  @override
  void updateRenderObject(BuildContext context, _RenderTheater renderObject) {
    renderObject // Updates the RenderObject properties
      ..skipCount = skipCount
      ..textDirection = Directionality.of(context)
      ..clipBehavior = clipBehavior;
  }
  // ... debugFillProperties ...
}
```

Key points:

*   It's a `MultiChildRenderObjectWidget`, meaning it's a widget that manages a list of children and has a single corresponding render object that manages their layout and painting.
*   It takes `skipCount` and `clipBehavior` as properties.
*   It creates a `_TheaterElement` (the intermediate element in the tree) and a `_RenderTheater` (the low-level render object). The real layout and paint logic live in the `_RenderTheater`.
*   `updateRenderObject` is used by the framework to update the properties of the existing `_RenderTheater` instance when the `_Theater` widget is rebuilt with different properties.

And a tiny peek at the `_RenderTheater`:

```dart
class _RenderTheater extends RenderBox with ContainerRenderObjectMixin<RenderBox, StackParentData>, _RenderTheaterMixin {
  // ... constructor, properties ...

  // This mixin provides common stack-like logic
  @override
  _RenderTheater get theater => this;

  // ... setupParentData, attach, detach ...

  // This method is where the actual layout of children happens
  @override
  void performLayout() {
    // ... logic similar to Stack layout ...
    // Lays out visible children based on Positioned or default alignment
  }

  // This method is where the actual painting of children happens
  @override
  void paint(PaintingContext context, Offset offset) {
     // ... iterates through children in paint order and paints them ...
  }

  // ... hitTestChildren, debug methods ...
}
```

The `_RenderTheater` extends `RenderBox` (meaning it's a box-shaped render object), uses `ContainerRenderObjectMixin` and `_RenderTheaterMixin` to get multi-child management and stack-like behavior, and overrides `performLayout` and `paint` to implement the core logic we discussed. The `_RenderTheaterMixin` provides shared logic related to handling the children, including those managed by [OverlayPortal]s.

### Conclusion

In this chapter, we demystified the `_Theater`. We learned that it is the specialized widget used internally by the [OverlayState](02_overlaystate_.md) to perform the critical task of laying out and painting the widgets from active [OverlayEntry](03_overlayentry_.md)s and [OverlayPortal](04_overlayportal_.md)s on top of each other, much like a `Stack`. We saw its key role in the `OverlayState`'s build method and got a high-level understanding of how its associated render object, `_RenderTheater`, handles the layout and painting process, including optimizations like `skipCount`.

While you rarely interact directly with `_Theater`, understanding its existence and role helps complete the picture of how the `overlay.dart` components work together to display elements on top of your UI.

In the next chapter, we'll touch upon another internal render object related to `OverlayPortal`s: [_RenderDeferredLayoutBox](07__renderdeferredlayoutbox_.md), and understand why its layout is "deferred".

[_RenderDeferredLayoutBox](07__renderdeferredlayoutbox_.md)

Relevant Code Snippets (Code itself remains unchanged):
--- File: packages/flutter/lib/src/widgets/overlay.dart ---
// Copyright 2014 The Flutter Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

/// @docImport 'package:flutter/cupertino.dart';
/// @docImport 'package:flutter/material.dart';
///
/// @docImport 'app.dart';
/// @docImport 'drag_target.dart';
/// @docImport 'implicit_animations.dart';
/// @docImport 'media_query.dart';
/// @docImport 'navigator.dart';
/// @docImport 'routes.dart';
/// @docImport 'scroll_view.dart';
/// @docImport 'sliver.dart';
/// @docImport 'text.dart';
library;

import 'dart:collection';

import 'package:flutter/foundation.dart';
import 'package:flutter/rendering.dart';
import 'package:flutter/scheduler.dart';

import 'basic.dart';
import 'framework.dart';
import 'lookup_boundary.dart';
import 'ticker_provider.dart';

const String _flutterWidgetsLibrary = 'package:flutter/widgets.dart';

// Examples can assume:
// late BuildContext context;

// * OverlayEntry Implementation

/// A place in an [Overlay] that can contain a widget.
///
/// Overlay entries are inserted into an [Overlay] using the
/// [OverlayState.insert] or [OverlayState.insertAll] functions. To find the
/// closest enclosing overlay for a given [BuildContext], use the [Overlay.of]
/// function.
///
/// An overlay entry can be in at most one overlay at a time. To remove an entry
/// from its overlay, call the [remove] function on the overlay entry.
///
/// Because an [Overlay] uses a [Stack] layout, overlay entries can use
/// [Positioned] and [AnimatedPositioned] to position themselves within the
/// overlay.
///
/// For example, [Draggable] uses an [OverlayEntry] to show the drag avatar that
/// follows the user's finger across the screen after the drag begins. Using the
/// overlay to display the drag avatar lets the avatar float over the other
/// widgets in the app. As the user's finger moves, draggable calls
/// [markNeedsBuild] on the overlay entry to cause it to rebuild. In its build,
/// the entry includes a [Positioned] with its top and left property set to
/// position the drag avatar near the user's finger. When the drag is over,
/// [Draggable] removes the entry from the overlay to remove the drag avatar
/// from view.
///
/// By default, if there is an entirely [opaque] entry over this one, then this
/// one will not be included in the widget tree (in particular, stateful widgets
/// within the overlay entry will not be instantiated). To ensure that your
/// overlay entry is still built even if it is not visible, set [maintainState]
/// to true. This is more expensive, so should be done with care. In particular,
/// if widgets in an overlay entry with [maintainState] set to true repeatedly
/// call [State.setState], the user's battery will be drained unnecessarily.
///
/// [OverlayEntry] is a [Listenable] that notifies when the widget built by
/// [builder] is mounted or unmounted, whose exact state can be queried by
/// [mounted]. After the owner of the [OverlayEntry] calls [remove] and then
/// [dispose], the widget may not be immediately removed from the widget tree.
/// As a result listeners of the [OverlayEntry] can get notified for one last
/// time after the [dispose] call, when the widget is eventually unmounted.
///
/// {@macro flutter.widgets.overlayPortalVsOverlayEntry}
///
/// See also:
///
///  * [OverlayPortal], an alternative API for inserting widgets into an
///    [Overlay] using a builder callback.
///  * [Overlay], a stack of entries that can be managed independently.
///  * [OverlayState], the current state of an Overlay.
///  * [WidgetsApp], a convenience widget that wraps a number of widgets that
///    are commonly required for an application.
///  * [MaterialApp], a convenience widget that wraps a number of widgets that
///    are commonly required for Material Design applications.
class OverlayEntry implements Listenable {
  /// Creates an overlay entry.
  ///
  /// To insert the entry into an [Overlay], first find the overlay using
  /// [Overlay.of] and then call [OverlayState.insert]. To remove the entry,
  /// call [remove] on the overlay entry itself.
  OverlayEntry({
    required this.builder,
    bool opaque = false,
    bool maintainState = false,
    this.canSizeOverlay = false,
  }) : _opaque = opaque,
       _maintainState = maintainState {
    if (kFlutterMemoryAllocationsEnabled) {
      _maybeDispatchObjectCreation();
    }
  }

  /// This entry will include the widget built by this builder in the overlay at
  /// the entry's position.
  ///
  /// To cause this builder to be called again, call [markNeedsBuild] on this
  /// overlay entry.
  final WidgetBuilder builder;

  /// Whether this entry occludes the entire overlay.
  ///
  /// If an entry claims to be opaque, then, for efficiency, the overlay will
  /// skip building entries below that entry unless they have [maintainState]
  /// set.
  bool get opaque => _opaque;
  bool _opaque;
  set opaque(bool value) {
    assert(!_disposedByOwner);
    if (_opaque == value) {
      return;
    }
    _opaque = value;
    _overlay?._didChangeEntryOpacity();
  }

  /// Whether this entry must be included in the tree even if there is a fully
  /// [opaque] entry above it.
  ///
  /// By default, if there is an entirely [opaque] entry over this one, then this
  /// one will not be included in the widget tree (in particular, stateful widgets
  /// within the overlay entry will not be instantiated). To ensure that your
  /// overlay entry is still built even if it is not visible, set [maintainState]
  /// to true. This is more expensive, so should be done with care. In particular,
  /// if widgets in an overlay entry with [maintainState] set to true repeatedly
  /// call [State.setState], the user's battery will be drained unnecessarily.
  ///
  /// This is used by the [Navigator] and [Route] objects to ensure that routes
  /// are kept around even when in the background, so that [Future]s promised
  /// from subsequent routes will be handled properly when they complete.
  bool get maintainState => _maintainState;
  bool _maintainState;
  set maintainState(bool value) {
    assert(!_disposedByOwner);
    if (_maintainState == value) {
      return;
    }
    _maintainState = value;
    assert(_overlay != null);
    _overlay!._didChangeEntryOpacity();
  }

  /// Whether the content of this [OverlayEntry] can be used to size the
  /// [Overlay].
  ///
  /// In most situations the overlay sizes itself based on its incoming
  /// constraints to be as large as possible. However, if that would result in
  /// an infinite size, it has to rely on one of its children to size itself. In
  /// this situation, the overlay will consult the topmost non-[Positioned]
  /// overlay entry that has this property set to true, lay it out with the
  /// incoming [BoxConstraints] of the overlay, and force all other
  /// non-[Positioned] overlay entries to have the same size. The [Positioned]
  /// entries are laid out as usual based on the calculated size of the overlay.
  ///
  /// Overlay entries that set this to true must be able to handle unconstrained
  /// [BoxConstraints].
  ///
  /// Setting this to true has no effect if the overlay entry uses a [Positioned]
  /// widget to position itself in the overlay.
  final bool canSizeOverlay;

  /// Whether the [OverlayEntry] is currently mounted in the widget tree.
  ///
  /// The [OverlayEntry] notifies its listeners when this value changes.
  bool get mounted => _overlayEntryStateNotifier?.value != null;

  /// The currently mounted `_OverlayEntryWidgetState` built using this [OverlayEntry].
  ValueNotifier<_OverlayEntryWidgetState?>? _overlayEntryStateNotifier =
      ValueNotifier<_OverlayEntryWidgetState?>(null);

  // TODO(polina-c): stop duplicating code across disposables
  // https://github.com/flutter/flutter/issues/137435
  /// Dispatches event of object creation to [FlutterMemoryAllocations.instance].
  void _maybeDispatchObjectCreation() {
    if (kFlutterMemoryAllocationsEnabled) {
      FlutterMemoryAllocations.instance.dispatchObjectCreated(
        library: _flutterWidgetsLibrary,
        className: '$OverlayEntry',
        object: this,
      );
    }
  }

  @override
  void addListener(VoidCallback listener) {
    assert(!_disposedByOwner);
    _overlayEntryStateNotifier?.addListener(listener);
  }

  @override
  void removeListener(VoidCallback listener) {
    _overlayEntryStateNotifier?.removeListener(listener);
  }

  OverlayState? _overlay;
  final GlobalKey<_OverlayEntryWidgetState> _key = GlobalKey<_OverlayEntryWidgetState>();

  /// Remove this entry from the overlay.
  ///
  /// This should only be called once.
  ///
  /// This method removes this overlay entry from the overlay immediately. The
  /// UI will be updated in the same frame if this method is called before the
  /// overlay rebuild in this frame; otherwise, the UI will be updated in the
  /// next frame. This means that it is safe to call during builds, but also
  /// that if you do call this after the overlay rebuild, the UI will not update
  /// until the next frame (i.e. many milliseconds later).
  void remove() {
    assert(_overlay != null);
    assert(!_disposedByOwner);
    final OverlayState overlay = _overlay!;
    _overlay = null;
    if (!overlay.mounted) {
      return;
    }

    overlay._entries.remove(this);
    if (SchedulerBinding.instance.schedulerPhase == SchedulerPhase.persistentCallbacks) {
      SchedulerBinding.instance.addPostFrameCallback((Duration duration) {
        overlay._markDirty();
      }, debugLabel: 'OverlayEntry.markDirty');
    } else {
      overlay._markDirty();
    }
  }

  /// Cause this entry to rebuild during the next pipeline flush.
  ///
  /// You need to call this function if the output of [builder] has changed.
  void markNeedsBuild() {
    assert(!_disposedByOwner);
    _key.currentState?._markNeedsBuild();
  }

  void _didUnmount() {
    assert(!mounted);
    if (_disposedByOwner) {
      _overlayEntryStateNotifier?.dispose();
      _overlayEntryStateNotifier = null;
    }
  }

  bool _disposedByOwner = false;

  /// Discards any resources used by this [OverlayEntry].
  ///
  /// This method must be called after [remove] if the [OverlayEntry] is
  /// inserted into an [Overlay].
  ///
  /// After this is called, the object is not in a usable state and should be
  /// discarded (calls to [addListener] will throw after the object is disposed).
  /// However, the listeners registered may not be immediately released until
  /// the widget built using this [OverlayEntry] is unmounted from the widget
  /// tree.
  ///
  /// This method should only be called by the object's owner.
  void dispose() {
    assert(!_disposedByOwner);
    assert(
      _overlay == null,
      'An OverlayEntry must first be removed from the Overlay before dispose is called.',
    );
    if (kFlutterMemoryAllocationsEnabled) {
      FlutterMemoryAllocations.instance.dispatchObjectDisposed(object: this);
    }
    _disposedByOwner = true;
    if (!mounted) {
      // If we're still mounted when disposed, then this will be disposed in
      // _didUnmount, to allow notifications to occur until the entry is
      // unmounted.
      _overlayEntryStateNotifier?.dispose();
      _overlayEntryStateNotifier = null;
    }
  }

  @override
  String toString() =>
      '${describeIdentity(this)}(opaque: $opaque; maintainState: $maintainState)${_disposedByOwner ? "(DISPOSED)" : ""}';
}

class _OverlayEntryWidget extends StatefulWidget {
  const _OverlayEntryWidget({
    required Key super.key,
    required this.entry,
    required this.overlayState,
    this.tickerEnabled = true,
  });

  final OverlayEntry entry;
  final OverlayState overlayState;
  final bool tickerEnabled;

  @override
  _OverlayEntryWidgetState createState() => _OverlayEntryWidgetState();
}

class _OverlayEntryWidgetState extends State<_OverlayEntryWidget> {
  late _RenderTheater _theater;

  // Manages the stack of theater children whose paint order are sorted by their
  // _zOrderIndex. The children added by OverlayPortal are added to this linked
  // list, and they will be shown _above_ the OverlayEntry tied to this widget.
  // The children with larger zOrderIndex values (i.e. those called `show`
  // recently) will be painted last.
  //
  // This linked list is lazily created in `_add`, and the entries are added/removed
  // via `_add`/`_remove`, called by OverlayPortals lower in the tree. `_add` or
  // `_remove` does not cause this widget to rebuild, the linked list will be
  // read by _RenderTheater as part of its render child model. This would ideally
  // be in a RenderObject but there may not be RenderObjects between
  // _RenderTheater and the render subtree OverlayEntry builds.
  LinkedList<_OverlayEntryLocation>? _sortedTheaterSiblings;

  // Worst-case O(N), N being the number of children added to the top spot in
  // the same frame. This can be a bit expensive when there's a lot of global
  // key reparenting in the same frame but N is usually a small number.
  void _add(_OverlayEntryLocation child) {
    assert(mounted);
    final LinkedList<_OverlayEntryLocation> children =
        _sortedTheaterSiblings ??= LinkedList<_OverlayEntryLocation>();
    assert(!children.contains(child));
    _OverlayEntryLocation? insertPosition = children.isEmpty ? null : children.last;
    while (insertPosition != null && insertPosition._zOrderIndex > child._zOrderIndex) {
      insertPosition = insertPosition.previous;
    }
    if (insertPosition == null) {
      children.addFirst(child);
    } else {
      insertPosition.insertAfter(child);
    }
    assert(children.contains(child));
  }

  void _remove(_OverlayEntryLocation child) {
    assert(_sortedTheaterSiblings != null);
    final bool wasInCollection = _sortedTheaterSiblings?.remove(child) ?? false;
    assert(wasInCollection);
  }

  // Returns an Iterable that traverse the children in the child model in paint
  // order (from farthest to the user to the closest to the user).
  //
  // The iterator should be safe to use even when the child model is being
  // mutated. The reason for that is it's allowed to add/remove/move deferred
  // children to a _RenderTheater during performLayout, but the affected
  // children don't have to be laid out in the same performLayout call.
  late final Iterable<RenderBox> _paintOrderIterable = _createChildIterable(reversed: false);
  // An Iterable that traverse the children in the child model in
  // hit-test order (from closest to the user to the farthest to the user).
  late final Iterable<RenderBox> _hitTestOrderIterable = _createChildIterable(reversed: true);

  // The following uses sync* because hit-testing is lazy, and LinkedList as a
  // Iterable doesn't support concurrent modification.
  Iterable<RenderBox> _createChildIterable({required bool reversed}) sync* {
    final LinkedList<_OverlayEntryLocation>? children = _sortedTheaterSiblings;
    if (children == null || children.isEmpty) {
      return;
    }
    _OverlayEntryLocation? candidate = reversed ? children.last : children.first;
    while (candidate != null) {
      final RenderBox? renderBox = candidate._overlayChildRenderBox;
      candidate = reversed ? candidate.previous : candidate.next;
      if (renderBox != null) {
        yield renderBox;
      }
    }
  }

  @override
  void initState() {
    super.initState();
    widget.entry._overlayEntryStateNotifier!.value = this;
    _theater = context.findAncestorRenderObjectOfType<_RenderTheater>()!;
    assert(_sortedTheaterSiblings == null);
  }

  @override
  void didUpdateWidget(_OverlayEntryWidget oldWidget) {
    super.didUpdateWidget(oldWidget);
    // OverlayState's build method always returns a RenderObjectWidget _Theater,
    // so it's safe to assume that state equality implies render object equality.
    assert(oldWidget.entry == widget.entry);
    if (oldWidget.overlayState != widget.overlayState) {
      final _RenderTheater newTheater = context.findAncestorRenderObjectOfType<_RenderTheater>()!;
      assert(_theater != newTheater);
      _theater = newTheater;
    }
  }

  @override
  void dispose() {
    widget.entry._overlayEntryStateNotifier?.value = null;
    widget.entry._didUnmount();
    _sortedTheaterSiblings = null;
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    return TickerMode(
      enabled: widget.tickerEnabled,
      child: _RenderTheaterMarker(
        theater: _theater,
        overlayEntryWidgetState: this,
        child: widget.entry.builder(context),
      ),
    );
  }

  void _markNeedsBuild() {
    setState(() {
      /* the state that changed is in the builder */
    });
  }
}

/// A stack of entries that can be managed independently.
///
/// Overlays let independent child widgets "float" visual elements on top of
/// other widgets by inserting them into the overlay's stack. The overlay lets
/// each of these widgets manage their participation in the overlay using
/// [OverlayEntry] objects.
///
/// Although you can create an [Overlay] directly, it's most common to use the
/// overlay created by the [Navigator] in a [WidgetsApp], [CupertinoApp] or a
/// [MaterialApp]. The navigator uses its overlay to manage the visual
/// appearance of its routes.
///
/// The [Overlay] widget uses a custom stack implementation, which is very
/// similar to the [Stack] widget. The main use case of [Overlay] is related to
/// navigation and being able to insert widgets on top of the pages in an app.
/// For layout purposes unrelated to navigation, consider using [Stack] instead.
///
/// An [Overlay] widget requires a [Directionality] widget to be in scope, so
/// that it can resolve direction-sensitive coordinates of any
/// [Positioned.directional] children.
///
/// For widgets drawn in an [OverlayEntry], do not assume that the size of the
/// [Overlay] is the size returned by [MediaQuery.sizeOf]. Nested overlays can
/// have different sizes.
///
/// {@tool dartpad}
/// This example shows how to use the [Overlay] to highlight the [NavigationBar]
/// destination.
///
/// ** See code in examples/api/lib/widgets/overlay/overlay.0.dart **
/// {@end-tool}
///
/// See also:
///
///  * [OverlayEntry], the class that is used for describing the overlay entries.
///  * [OverlayState], which is used to insert the entries into the overlay.
///  * [WidgetsApp], which inserts an [Overlay] widget indirectly via its [Navigator].
///  * [MaterialApp], which inserts an [Overlay] widget indirectly via its [Navigator].
///  * [CupertinoApp], which inserts an [Overlay] widget indirectly via its [Navigator].
///  * [Stack], which allows directly displaying a stack of widgets.
class Overlay extends StatefulWidget {
  /// Creates an overlay.
  ///
  /// The initial entries will be inserted into the overlay when its associated
  /// [OverlayState] is initialized.
  ///
  /// Rather than creating an overlay, consider using the overlay that is
  /// created by the [Navigator] in a [WidgetsApp], [CupertinoApp], or a
  /// [MaterialApp] for the application.
  const Overlay({
    super.key,
    this.initialEntries = const <OverlayEntry>[],
    this.clipBehavior = Clip.hardEdge,
  });

  /// Wrap the provided `child` in an [Overlay] to allow other visual elements
  /// (packed in [OverlayEntry]s) to float on top of the child.
  ///
  /// This is a convenience method over the regular [Overlay] constructor: It
  /// creates an [Overlay] and puts the provided `child` in an [OverlayEntry]
  /// at the bottom of that newly created Overlay.
  static Widget wrap({Key? key, Clip clipBehavior = Clip.hardEdge, required Widget child}) {
    return _WrappingOverlay(key: key, clipBehavior: clipBehavior, child: child);
  }

  /// The entries to include in the overlay initially.
  ///
  /// These entries are only used when the [OverlayState] is initialized. If you
  /// are providing a new [Overlay] description for an overlay that's already in
  /// the tree, then the new entries are ignored.
  ///
  /// To add entries to an [Overlay] that is already in the tree, use
  /// [Overlay.of] to obtain the [OverlayState] (or assign a [GlobalKey] to the
  /// [Overlay] widget and obtain the [OverlayState] via
  /// [GlobalKey.currentState]), and then use [OverlayState.insert] or
  /// [OverlayState.insertAll].
  ///
  /// To remove an entry from an [Overlay], use [OverlayEntry.remove].
  final List<OverlayEntry> initialEntries;

  /// {@macro flutter.material.Material.clipBehavior}
  ///
  /// Defaults to [Clip.hardEdge].
  final Clip clipBehavior;

  /// The [OverlayState] from the closest instance of [Overlay] that encloses
  /// the given context within the closest [LookupBoundary], and, in debug mode,
  /// will throw if one is not found.
  ///
  /// In debug mode, if the `debugRequiredFor` argument is provided and an
  /// overlay isn't found, then this function will throw an exception containing
  /// the runtime type of the given widget in the error message. The exception
  /// attempts to explain that the calling [Widget] (the one given by the
  /// `debugRequiredFor` argument) needs an [Overlay] to be present to function.
  /// If `debugRequiredFor` is not supplied, then the error message is more
  /// generic.
  ///
  /// Typical usage is as follows:
  ///
  /// ```dart
  /// OverlayState overlay = Overlay.of(context);
  /// ```
  ///
  /// If `rootOverlay` is set to true, the state from the furthest instance of
  /// this class is given instead. Useful for installing overlay entries above
  /// all subsequent instances of [Overlay].
  ///
  /// This method can be expensive (it walks the element tree).
  ///
  /// See also:
  ///
  /// * [Overlay.maybeOf] for a similar function that returns null if an
  ///   [Overlay] is not found.
  static OverlayState of(
    BuildContext context, {
    bool rootOverlay = false,
    Widget? debugRequiredFor,
  }) {
    final OverlayState? result = maybeOf(context, rootOverlay: rootOverlay);
    assert(() {
      if (result == null) {
        final bool hiddenByBoundary = LookupBoundary.debugIsHidingAncestorStateOfType<OverlayState>(
          context,
        );
        final List<DiagnosticsNode> information = <DiagnosticsNode>[
          ErrorSummary(
            'No Overlay widget found${hiddenByBoundary ? ' within the closest LookupBoundary' : ''}.',
          ),
          if (hiddenByBoundary)
            ErrorDescription(
              'There is an ancestor Overlay widget, but it is hidden by a LookupBoundary.',
            ),
          ErrorDescription(
            '${debugRequiredFor?.runtimeType ?? 'Some'} widgets require an Overlay widget ancestor for correct operation.',
          ),
          ErrorHint(
            'The most common way to add an Overlay to an application is to include a MaterialApp, CupertinoApp or Navigator widget in the runApp() call.',
          ),
          if (debugRequiredFor != null)
            DiagnosticsProperty<Widget>(
              'The specific widget that failed to find an overlay was',
              debugRequiredFor,
              style: DiagnosticsTreeStyle.errorProperty,
            ),
          if (context.widget != debugRequiredFor)
            context.describeElement(
              'The context from which that widget was searching for an overlay was',
            ),
        ];

        throw FlutterError.fromParts(information);
      }
      return true;
    }());
    return result!;
  }

  /// The [OverlayState] from the closest instance of [Overlay] that encloses
  /// the given context within the closest [LookupBoundary], if any.
  ///
  /// Typical usage is as follows:
  ///
  /// ```dart
  /// OverlayState? overlay = Overlay.maybeOf(context);
  /// ```
  ///
  /// If `rootOverlay` is set to true, the state from the furthest instance of
  /// this class is given instead. Useful for installing overlay entries above
  /// all subsequent instances of [Overlay].
  ///
  /// This method can be expensive (it walks the element tree).
  ///
  /// See also:
  ///
  ///  * [Overlay.of] for a similar function that returns a non-nullable result
  ///    and throws if an [Overlay] is not found.

  static OverlayState? maybeOf(BuildContext context, {bool rootOverlay = false}) {
    return rootOverlay
        ? LookupBoundary.findRootAncestorStateOfType<OverlayState>(context)
        : LookupBoundary.findAncestorStateOfType<OverlayState>(context);
  }

  @override
  OverlayState createState() => OverlayState();
}

/// The current state of an [Overlay].
///
/// Used to insert [OverlayEntry]s into the overlay using the [insert] and
/// [insertAll] functions.
class OverlayState extends State<Overlay> with TickerProviderStateMixin {
  final List<OverlayEntry> _entries = <OverlayEntry>[];

  @protected
  @override
  void initState() {
    super.initState();
    insertAll(widget.initialEntries);
  }

  int _insertionIndex(OverlayEntry? below, OverlayEntry? above) {
    assert(above == null || below == null);
    if (below != null) {
      return _entries.indexOf(below);
    }
    if (above != null) {
      return _entries.indexOf(above) + 1;
    }
    return _entries.length;
  }

  bool _debugCanInsertEntry(OverlayEntry entry) {
    final List<DiagnosticsNode> operandsInformation = <DiagnosticsNode>[
      DiagnosticsProperty<OverlayEntry>(
        'The OverlayEntry was',
        entry,
        style: DiagnosticsTreeStyle.errorProperty,
      ),
      DiagnosticsProperty<OverlayState>(
        'The Overlay the OverlayEntry was trying to insert to was',
        this,
        style: DiagnosticsTreeStyle.errorProperty,
      ),
    ];

    if (!mounted) {
      throw FlutterError.fromParts(<DiagnosticsNode>[
        ErrorSummary('Attempted to insert an OverlayEntry to an already disposed Overlay.'),
        ...operandsInformation,
      ]);
    }

    final OverlayState? currentOverlay = entry._overlay;
    final bool alreadyContainsEntry = _entries.contains(entry);

    if (alreadyContainsEntry) {
      final bool inconsistentOverlayState = !identical(currentOverlay, this);
      throw FlutterError.fromParts(<DiagnosticsNode>[
        ErrorSummary('The specified entry is already present in the target Overlay.'),
        ...operandsInformation,
        if (inconsistentOverlayState)
          ErrorHint('This could be an error in the Flutter framework.')
        else
          ErrorHint(
            'Consider calling remove on the OverlayEntry before inserting it to a different Overlay, '
            'or switching to the OverlayPortal API to avoid manual OverlayEntry management.',
          ),
        if (inconsistentOverlayState)
          DiagnosticsProperty<OverlayState>(
            "The OverlayEntry's current Overlay was",
            currentOverlay,
            style: DiagnosticsTreeStyle.errorProperty,
          ),
      ]);
    }

    if (currentOverlay == null) {
      return true;
    }

    throw FlutterError.fromParts(<DiagnosticsNode>[
      ErrorSummary('The specified entry is already present in a different Overlay.'),
      ...operandsInformation,
      DiagnosticsProperty<OverlayState>(
        "The OverlayEntry's current Overlay was",
        currentOverlay,
        style: DiagnosticsTreeStyle.errorProperty,
      ),
      ErrorHint(
        'Consider calling remove on the OverlayEntry before inserting it to a different Overlay, '
        'or switching to the OverlayPortal API to avoid manual OverlayEntry management.',
      ),
    ]);
  }

  /// Insert the given entry into the overlay.
  ///
  /// If `below` is non-null, the entry is inserted just below `below`.
  /// If `above` is non-null, the entry is inserted just above `above`.
  /// Otherwise, the entry is inserted on top.
  ///
  /// It is an error to specify both `above` and `below`.
  void insert(OverlayEntry entry, {OverlayEntry? below, OverlayEntry? above}) {
    assert(_debugVerifyInsertPosition(above, below));
    assert(_debugCanInsertEntry(entry));
    entry._overlay = this;
    setState(() {
      _entries.insert(_insertionIndex(below, above), entry);
    });
  }

  /// Insert all the entries in the given iterable.
  ///
  /// If `below` is non-null, the entries are inserted just below `below`.
  /// If `above` is non-null, the entries are inserted just above `above`.
  /// Otherwise, the entries are inserted on top.
  ///
  /// It is an error to specify both `above` and `below`.
  void insertAll(Iterable<OverlayEntry> entries, {OverlayEntry? below, OverlayEntry? above}) {
    assert(_debugVerifyInsertPosition(above, below));
    assert(entries.every(_debugCanInsertEntry));
    if (entries.isEmpty) {
      return;
    }
    for (final OverlayEntry entry in entries) {
      assert(entry._overlay == null);
      entry._overlay = this;
    }
    setState(() {
      _entries.insertAll(_insertionIndex(below, above), entries);
    });
  }

  bool _debugVerifyInsertPosition(
    OverlayEntry? above,
    OverlayEntry? below, {
    Iterable<OverlayEntry>? newEntries,
  }) {
    assert(above == null || below == null, 'Only one of `above` and `below` may be specified.');
    assert(
      above == null ||
          (above._overlay == this &&
              _entries.contains(above) &&
              (newEntries?.contains(above) ?? true)),
      'The provided entry used for `above` must be present in the Overlay${newEntries != null ? ' and in the `newEntriesList`' : ''}.',
    );
    assert(
      below == null ||
          (below._overlay == this &&
              _entries.contains(below) &&
              (newEntries?.contains(below) ?? true)),
      'The provided entry used for `below` must be present in the Overlay${newEntries != null ? ' and in the `newEntriesList`' : ''}.',
    );
    return true;
  }

  /// Remove all the entries listed in the given iterable, then reinsert them
  /// into the overlay in the given order.
  ///
  /// Entries mention in `newEntries` but absent from the overlay are inserted
  /// as if with [insertAll].
  ///
  /// Entries not mentioned in `newEntries` but present in the overlay are
  /// positioned as a group in the resulting list relative to the entries that
  /// were moved, as specified by one of `below` or `above`, which, if
  /// specified, must be one of the entries in `newEntries`:
  ///
  /// If `below` is non-null, the group is positioned just below `below`.
  /// If `above` is non-null, the group is positioned just above `above`.
  /// Otherwise, the group is left on top, with all the rearranged entries
  /// below.
  ///
  /// It is an error to specify both `above` and `below`.
  void rearrange(Iterable<OverlayEntry> newEntries, {OverlayEntry? below, OverlayEntry? above}) {
    final List<OverlayEntry> newEntriesList =
        newEntries is List<OverlayEntry> ? newEntries : newEntries.toList(growable: false);
    assert(_debugVerifyInsertPosition(above, below, newEntries: newEntriesList));
    assert(
      newEntriesList.every(
        (OverlayEntry entry) => entry._overlay == null || entry._overlay == this,
      ),
      'One or more of the specified entries are already present in another Overlay.',
    );
    assert(
      newEntriesList.every(
        (OverlayEntry entry) => _entries.indexOf(entry) == _entries.lastIndexOf(entry),
      ),
      'One or more of the specified entries are specified multiple times.',
    );
    if (newEntriesList.isEmpty) {
      return;
    }
    if (listEquals(_entries, newEntriesList)) {
      return;
    }
    final LinkedHashSet<OverlayEntry> old = LinkedHashSet<OverlayEntry>.of(_entries);
    for (final OverlayEntry entry in newEntriesList) {
      entry._overlay ??= this;
    }
    setState(() {
      _entries.clear();
      _entries.addAll(newEntriesList);
      old.removeAll(newEntriesList);
      _entries.insertAll(_insertionIndex(below, above), old);
    });
  }

  void _markDirty() {
    if (mounted) {
      setState(() {});
    }
  }

  /// (DEBUG ONLY) Check whether a given entry is visible (i.e., not behind an
  /// opaque entry).
  ///
  /// This is an O(N) algorithm, and should not be necessary except for debug
  /// asserts. To avoid people depending on it, this function is implemented
  /// only in debug mode, and always returns false in release mode.
  bool debugIsVisible(OverlayEntry entry) {
    bool result = false;
    assert(_entries.contains(entry));
    assert(() {
      for (int i = _entries.length - 1; i > 0; i -= 1) {
        final OverlayEntry candidate = _entries[i];
        if (candidate == entry) {
          result = true;
          break;
        }
        if (candidate.opaque) {
          break;
        }
      }
      return true;
    }());
    return result;
  }

  void _didChangeEntryOpacity() {
    setState(() {
      // We use the opacity of the entry in our build function, which means we
      // our state has changed.
    });
  }

  @protected
  @override
  Widget build(BuildContext context) {
    // This list is filled backwards and then reversed below before
    // it is added to the tree.
    final List<_OverlayEntryWidget> children = <_OverlayEntryWidget>[];
    bool onstage = true;
    int onstageCount = 0;
    for (final OverlayEntry entry in _entries.reversed) {
      if (onstage) {
        onstageCount += 1;
        children.add(_OverlayEntryWidget(key: entry._key, overlayState: this, entry: entry));
        if (entry.opaque) {
          onstage = false;
        }
      } else if (entry.maintainState) {
        children.add(
          _OverlayEntryWidget(
            key: entry._key,
            overlayState: this,
            entry: entry,
            tickerEnabled: false,
          ),
        );
      }
    }
    return _Theater(
      skipCount: children.length - onstageCount,
      clipBehavior: widget.clipBehavior,
      children: children.reversed.toList(growable: false),
    );
  }

  @protected
  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    // TODO(jacobr): use IterableProperty instead as that would
    // provide a slightly more consistent string summary of the List.
    properties.add(DiagnosticsProperty<List<OverlayEntry>>('entries', _entries));
  }
}

class _WrappingOverlay extends StatefulWidget {
  const _WrappingOverlay({super.key, this.clipBehavior = Clip.hardEdge, required this.child});

  final Clip clipBehavior;
  final Widget child;

  @override
  State<_WrappingOverlay> createState() => _WrappingOverlayState();
}

class _WrappingOverlayState extends State<_WrappingOverlay> {
  late final OverlayEntry _entry = OverlayEntry(
    canSizeOverlay: true,
    opaque: true,
    builder: (BuildContext context) {
      return widget.child;
    },
  );

  @override
  void didUpdateWidget(_WrappingOverlay oldWidget) {
    super.didUpdateWidget(oldWidget);
    _entry.markNeedsBuild();
  }

  @override
  void dispose() {
    _entry
      ..remove()
      ..dispose();
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    return Overlay(clipBehavior: widget.clipBehavior, initialEntries: <OverlayEntry>[_entry]);
  }
}

/// Special version of a [Stack], that doesn't layout and render the first
/// [skipCount] children.
///
/// The first [skipCount] children are considered "offstage".
class _Theater extends MultiChildRenderObjectWidget {
  const _Theater({
    this.skipCount = 0,
    this.clipBehavior = Clip.hardEdge,
    required List<_OverlayEntryWidget> super.children,
  }) : assert(skipCount >= 0),
       assert(children.length >= skipCount);

  final int skipCount;

  final Clip clipBehavior;

  @override
  _TheaterElement createElement() => _TheaterElement(this);

  @override
  _RenderTheater createRenderObject(BuildContext context) {
    return _RenderTheater(
      skipCount: skipCount,
      textDirection: Directionality.of(context),
      clipBehavior: clipBehavior,
    );
  }

  @override
  void updateRenderObject(BuildContext context, _RenderTheater renderObject) {
    renderObject
      ..skipCount = skipCount
      ..textDirection = Directionality.of(context)
      ..clipBehavior = clipBehavior;
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties.add(IntProperty('skipCount', skipCount));
  }
}

class _TheaterElement extends MultiChildRenderObjectElement {
  _TheaterElement(_Theater super.widget);

  @override
  _RenderTheater get renderObject => super.renderObject as _RenderTheater;

  @override
  void insertRenderObjectChild(RenderBox child, IndexedSlot<Element?> slot) {
    super.insertRenderObjectChild(child, slot);
    final _TheaterParentData parentData = child.parentData! as _TheaterParentData;
    parentData.overlayEntry =
        ((widget as _Theater).children[slot.index] as _OverlayEntryWidget).entry;
    assert(parentData.overlayEntry != null);
  }

  @override
  void moveRenderObjectChild(
    RenderBox child,
    IndexedSlot<Element?> oldSlot,
    IndexedSlot<Element?> newSlot,
  ) {
    super.moveRenderObjectChild(child, oldSlot, newSlot);
    assert(() {
      final _TheaterParentData parentData = child.parentData! as _TheaterParentData;
      return parentData.overlayEntry ==
          ((widget as _Theater).children[newSlot.index] as _OverlayEntryWidget).entry;
    }());
  }

  @override
  void debugVisitOnstageChildren(ElementVisitor visitor) {
    final _Theater theater = widget as _Theater;
    assert(children.length >= theater.skipCount);
    children.skip(theater.skipCount).forEach(visitor);
  }
}

// A `RenderBox` that sizes itself to its parent's size, implements the stack
// layout algorithm and renders its children in the given `theater`.
mixin _RenderTheaterMixin on RenderBox {
  _RenderTheater get theater;

  Iterable<RenderBox> _childrenInPaintOrder();
  Iterable<RenderBox> _childrenInHitTestOrder();

  @override
  void setupParentData(RenderBox child) {
    if (child.parentData is! StackParentData) {
      child.parentData = StackParentData();
    }
  }

  @override
  double? computeDistanceToActualBaseline(TextBaseline baseline) {
    assert(!debugNeedsLayout);
    BaselineOffset baselineOffset = BaselineOffset.noBaseline;
    for (final RenderBox child in _childrenInPaintOrder()) {
      assert(!child.debugNeedsLayout);
      final StackParentData childParentData = child.parentData! as StackParentData;
      baselineOffset = baselineOffset.minOf(
        BaselineOffset(child.getDistanceToActualBaseline(baseline)) + childParentData.offset.dy,
      );
    }
    return baselineOffset.offset;
  }

  static double? baselineForChild(
    RenderBox child,
    Size theaterSize,
    BoxConstraints nonPositionedChildConstraints,
    Alignment alignment,
    TextBaseline baseline,
  ) {
    final StackParentData childParentData = child.parentData! as StackParentData;
    final BoxConstraints childConstraints =
        childParentData.isPositioned
            ? childParentData.positionedChildConstraints(theaterSize)
            : nonPositionedChildConstraints;
    final double? baselineOffset = child.getDryBaseline(childConstraints, baseline);
    if (baselineOffset == null) {
      return null;
    }
    final double y = switch (childParentData) {
      StackParentData(:final double top?) => top,
      StackParentData(:final double bottom?) =>
        theaterSize.height - bottom - child.getDryLayout(childConstraints).height,
      StackParentData() =>
        alignment.alongOffset(theaterSize - child.getDryLayout(childConstraints) as Offset).dy,
    };
    return baselineOffset + y;
  }

  void layoutChild(RenderBox child, BoxConstraints nonPositionedChildConstraints) {
    final StackParentData childParentData = child.parentData! as StackParentData;
    final Alignment alignment = theater._resolvedAlignment;
    if (!childParentData.isPositioned) {
      child.layout(nonPositionedChildConstraints, parentUsesSize: true);
      childParentData.offset = Offset.zero;
    } else {
      assert(
        child is! _RenderDeferredLayoutBox,
        'all _RenderDeferredLayoutBoxes must be non-positioned children.',
      );
      RenderStack.layoutPositionedChild(child, childParentData, size, alignment);
    }
    assert(child.parentData == childParentData);
  }

  @override
  bool hitTestChildren(BoxHitTestResult result, {required Offset position}) {
    final Iterator<RenderBox> iterator = _childrenInHitTestOrder().iterator;
    bool isHit = false;
    while (!isHit && iterator.moveNext()) {
      final RenderBox child = iterator.current;
      final StackParentData childParentData = child.parentData! as StackParentData;
      final RenderBox localChild = child;
      bool childHitTest(BoxHitTestResult result, Offset position) =>
          localChild.hitTest(result, position: position);
      isHit = result.addWithPaintOffset(
        offset: childParentData.offset,
        position: position,
        hitTest: childHitTest,
      );
    }
    return isHit;
  }

  @override
  void paint(PaintingContext context, Offset offset) {
    for (final RenderBox child in _childrenInPaintOrder()) {
      final StackParentData childParentData = child.parentData! as StackParentData;
      context.paintChild(child, childParentData.offset + offset);
    }
  }
}

class _TheaterParentData extends StackParentData {
  // The OverlayEntry that directly created this child. This field is null for
  // children that are created by an OverlayPortal.
  OverlayEntry? overlayEntry;

  /// A [OverlayPortal] makes its overlay child a render child of an ancestor
  /// [Overlay]. Currently, to make sure the overlay child is painted after its
  /// [OverlayPortal], and before the next [OverlayEntry] (which could be
  /// something that should obstruct the overlay child, such as a [ModalRoute])
  /// in the host [Overlay], the paint order of each overlay child is managed by
  /// the [OverlayEntry] that hosts its [OverlayPortal].
  ///
  /// The following methods are exposed to allow easy access to the overlay
  /// children's render objects whose order is managed by [overlayEntry], in the
  /// right order.

  // _overlayStateMounted is set to null in _OverlayEntryWidgetState's dispose
  // method. This property is only accessed during layout, paint and hit-test so
  // the `value!` should be safe.
  Iterator<RenderBox>? get paintOrderIterator =>
      overlayEntry?._overlayEntryStateNotifier?.value!._paintOrderIterable.iterator;
  Iterator<RenderBox>? get hitTestOrderIterator =>
      overlayEntry?._overlayEntryStateNotifier?.value!._hitTestOrderIterable.iterator;

  // A convenience method for traversing `paintOrderIterator` with a
  // [RenderObjectVisitor].
  void visitOverlayPortalChildrenOnOverlayEntry(RenderObjectVisitor visitor) =>
      overlayEntry?._overlayEntryStateNotifier?.value!._paintOrderIterable.forEach(visitor);
}

class _RenderTheater extends RenderBox
    with ContainerRenderObjectMixin<RenderBox, StackParentData>, _RenderTheaterMixin {
  _RenderTheater({
    List<RenderBox>? children,
    required TextDirection textDirection,
    int skipCount = 0,
    Clip clipBehavior = Clip.hardEdge,
  }) : assert(skipCount >= 0),
       _textDirection = textDirection,
       _skipCount = skipCount,
       _clipBehavior = clipBehavior {
    addAll(children);
  }

  @override
  _RenderTheater get theater => this;

  @override
  void setupParentData(RenderBox child) {
    if (child.parentData is! _TheaterParentData) {
      child.parentData = _TheaterParentData();
    }
  }

  @override
  void attach(PipelineOwner owner) {
    super.attach(owner);
    RenderBox? child = firstChild;
    while (child != null) {
      final _TheaterParentData childParentData = child.parentData! as _TheaterParentData;
      final Iterator<RenderBox>? iterator = childParentData.paintOrderIterator;
      if (iterator != null) {
        while (iterator.moveNext()) {
          iterator.current.attach(owner);
        }
      }
      child = childParentData.nextSibling;
    }
  }

  static void _detachChild(RenderObject child) => child.detach();

  @override
  void detach() {
    super.detach();
    RenderBox? child = firstChild;
    while (child != null) {
      final _TheaterParentData childParentData = child.parentData! as _TheaterParentData;
      childParentData.visitOverlayPortalChildrenOnOverlayEntry(_detachChild);
      child = childParentData.nextSibling;
    }
  }

  @override
  void redepthChildren() => visitChildren(redepthChild);

  Alignment? _alignmentCache;
  Alignment get _resolvedAlignment =>
      _alignmentCache ??= AlignmentDirectional.topStart.resolve(textDirection);

  void _markNeedResolution() {
    _alignmentCache = null;
    markNeedsLayout();
  }

  TextDirection get textDirection => _textDirection;
  TextDirection _textDirection;
  set textDirection(TextDirection value) {
    if (_textDirection == value) {
      return;
    }
    _textDirection = value;
    _markNeedResolution();
  }

  int get skipCount => _skipCount;
  int _skipCount;
  set skipCount(int value) {
    if (_skipCount != value) {
      _skipCount = value;
      markNeedsLayout();
    }
  }

  /// {@macro flutter.material.Material.clipBehavior}
  ///
  /// Defaults to [Clip.hardEdge].
  Clip get clipBehavior => _clipBehavior;
  Clip _clipBehavior = Clip.hardEdge;
  set clipBehavior(Clip value) {
    if (value != _clipBehavior) {
      _clipBehavior = value;
      markNeedsPaint();
      markNeedsSemanticsUpdate();
    }
  }

  // Adding/removing deferred child does not affect the layout of other children,
  // or that of the Overlay, so there's no need to invalidate the layout of the
  // Overlay.
  //
  // When _skipMarkNeedsLayout is true, markNeedsLayout does not do anything.
  bool _skipMarkNeedsLayout = false;
  void _addDeferredChild(_RenderDeferredLayoutBox child) {
    assert(!_skipMarkNeedsLayout);
    _skipMarkNeedsLayout = true;
    adoptChild(child);
    // The Overlay still needs repainting when a deferred child is added. Usually
    // `markNeedsLayout` implies `markNeedsPaint`, but here `markNeedsLayout` is
    // skipped when the `_skipMarkNeedsLayout` flag is set.
    markNeedsPaint();
    _skipMarkNeedsLayout = false;

    // After adding `child` to the render tree, we want to make sure it will be
    // laid out in the same frame. This is done by calling markNeedsLayout on the
    // layout surrogate. This ensures `child` is reachable via tree walk (see
    // _RenderLayoutSurrogateProxyBox.performLayout).
    child._layoutSurrogate.markNeedsLayout();
  }

  void _removeDeferredChild(_RenderDeferredLayoutBox child) {
    assert(!_skipMarkNeedsLayout);
    _skipMarkNeedsLayout = true;
    dropChild(child);
    // The Overlay still needs repainting when a deferred child is dropped. See
    // the comment in `_addDeferredChild`.
    markNeedsPaint();
    _skipMarkNeedsLayout = false;
  }

  @override
  void markNeedsLayout() {
    if (!_skipMarkNeedsLayout) {
      super.markNeedsLayout();
    }
  }

  RenderBox? get _firstOnstageChild {
    if (skipCount == super.childCount) {
      return null;
    }
    RenderBox? child = super.firstChild;
    for (int toSkip = skipCount; toSkip > 0; toSkip--) {
      final StackParentData childParentData = child!.parentData! as StackParentData;
      child = childParentData.nextSibling;
      assert(child != null);
    }
    return child;
  }

  RenderBox? get _lastOnstageChild => skipCount == super.childCount ? null : lastChild;

  @override
  double computeMinIntrinsicWidth(double height) {
    return RenderStack.getIntrinsicDimension(
      _firstOnstageChild,
      (RenderBox child) => child.getMinIntrinsicWidth(height),
    );
  }

  @override
  double computeMaxIntrinsicWidth(double height) {
    return RenderStack.getIntrinsicDimension(
      _firstOnstageChild,
      (RenderBox child) => child.getMaxIntrinsicWidth(height),
    );
  }

  @override
  double computeMinIntrinsicHeight(double width) {
    return RenderStack.getIntrinsicDimension(
      _firstOnstageChild,
      (RenderBox child) => child.getMinIntrinsicHeight(width),
    );
  }

  @override
  double computeMaxIntrinsicHeight(double width) {
    return RenderStack.getIntrinsicDimension(
      _firstOnstageChild,
      (RenderBox child) => child.getMaxIntrinsicHeight(width),
    );
  }

  @override
  double? computeDryBaseline(BoxConstraints constraints, TextBaseline baseline) {
    final Size size =
        constraints.biggest.isFinite
            ? constraints.biggest
            : _findSizeDeterminingChild().getDryLayout(constraints);
    final BoxConstraints nonPositionedChildConstraints = BoxConstraints.tight(size);
    final Alignment alignment = theater._resolvedAlignment;

    BaselineOffset baselineOffset = BaselineOffset.noBaseline;
    for (final RenderBox child in _childrenInPaintOrder()) {
      baselineOffset = baselineOffset.minOf(
        BaselineOffset(
          _RenderTheaterMixin.baselineForChild(
            child,
            size,
            nonPositionedChildConstraints,
            alignment,
            baseline,
          ),
        ),
      );
    }
    return baselineOffset.offset;
  }

  @override
  Size computeDryLayout(BoxConstraints constraints) {
    if (constraints.biggest.isFinite) {
      return constraints.biggest;
    }
    return _findSizeDeterminingChild().getDryLayout(constraints);
  }

  @override
  // The following uses sync* because concurrent modifications should be allowed
  // during layout.
  Iterable<RenderBox> _childrenInPaintOrder() sync* {
    RenderBox? child = _firstOnstageChild;
    while (child != null) {
      yield child;
      final _TheaterParentData childParentData = child.parentData! as _TheaterParentData;
      final Iterator<RenderBox>? innerIterator = childParentData.paintOrderIterator;
      if (innerIterator != null) {
        while (innerIterator.moveNext()) {
          yield innerIterator.current;
        }
      }
      child = childParentData.nextSibling;
    }
  }

  @override
  // The following uses sync* because hit testing should be lazy.
  Iterable<RenderBox> _childrenInHitTestOrder() sync* {
    RenderBox? child = _lastOnstageChild;
    int childLeft = childCount - skipCount;
    while (child != null) {
      final _TheaterParentData childParentData = child.parentData! as _TheaterParentData;
      final Iterator<RenderBox>? innerIterator = childParentData.hitTestOrderIterator;
      if (innerIterator != null) {
        while (innerIterator.moveNext()) {
          yield innerIterator.current;
        }
      }
      yield child;
      childLeft -= 1;
      child = childLeft <= 0 ? null : childParentData.previousSibling;
    }
  }

  @override
  bool get sizedByParent => false;

  bool _layingOutSizeDeterminingChild = false;
  @override
  void performLayout() {
    RenderBox? sizeDeterminingChild;
    if (constraints.biggest.isFinite) {
      size = constraints.biggest;
    } else {
      sizeDeterminingChild = _findSizeDeterminingChild();
      _layingOutSizeDeterminingChild = true;
      layoutChild(sizeDeterminingChild, constraints);
      _layingOutSizeDeterminingChild = false;
      size = sizeDeterminingChild.size;
    }

    // Equivalent to BoxConstraints used by RenderStack for StackFit.expand.
    final BoxConstraints nonPositionedChildConstraints = BoxConstraints.tight(size);
    for (final RenderBox child in _childrenInPaintOrder()) {
      if (child != sizeDeterminingChild) {
        layoutChild(child, nonPositionedChildConstraints);
      }
    }
  }

  RenderBox _findSizeDeterminingChild() {
    RenderBox? child = _lastOnstageChild;
    while (child != null) {
      final _TheaterParentData childParentData = child.parentData! as _TheaterParentData;
      if ((childParentData.overlayEntry?.canSizeOverlay ?? false) &&
          !childParentData.isPositioned) {
        return child;
      }
      child = childParentData.previousSibling;
    }
    throw FlutterError.fromParts(<DiagnosticsNode>[
      ErrorSummary(
        'Overlay was given infinite constraints and cannot be sized by a suitable child.',
      ),
      ErrorDescription(
        'The constraints given to the overlay ($constraints) would result in an illegal '
        'infinite size (${constraints.biggest}). To avoid that, the Overlay tried to size '
        'itself to one of its children, but no suitable non-positioned child that belongs to an '
        'OverlayEntry with canSizeOverlay set to true could be found.',
      ),
      ErrorHint(
        'Try wrapping the Overlay in a SizedBox to give it a finite size or '
        'use an OverlayEntry with canSizeOverlay set to true.',
      ),
    ]);
  }

  final LayerHandle<ClipRectLayer> _clipRectLayer = LayerHandle<ClipRectLayer>();

  @override
  void paint(PaintingContext context, Offset offset) {
    if (clipBehavior != Clip.none) {
      _clipRectLayer.layer = context.pushClipRect(
        needsCompositing,
        offset,
        Offset.zero & size,
        super.paint,
        clipBehavior: clipBehavior,
        oldLayer: _clipRectLayer.layer,
      );
    } else {
      _clipRectLayer.layer = null;
      super.paint(context, offset);
    }
  }

  @override
  void dispose() {
    _clipRectLayer.layer = null;
    super.dispose();
  }

  @override
  void visitChildren(RenderObjectVisitor visitor) {
    RenderBox? child = firstChild;
    while (child != null) {
      visitor(child);
      final _TheaterParentData childParentData = child.parentData! as _TheaterParentData;
      childParentData.visitOverlayPortalChildrenOnOverlayEntry(visitor);
      child = childParentData.nextSibling;
    }
  }

  @override
  void visitChildrenForSemantics(RenderObjectVisitor visitor) {
    RenderBox? child = _firstOnstageChild;
    while (child != null) {
      visitor(child);
      final _TheaterParentData childParentData = child.parentData! as _TheaterParentData;
      child = childParentData.nextSibling;
    }
  }

  @override
  Rect? describeApproximatePaintClip(RenderObject child) {
    switch (clipBehavior) {
      case Clip.none:
        return null;
      case Clip.hardEdge:
      case Clip.antiAlias:
      case Clip.antiAliasWithSaveLayer:
        return Offset.zero & size;
    }
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties.add(IntProperty('skipCount', skipCount));
    properties.add(EnumProperty<TextDirection>('textDirection', textDirection));
  }

  @override
  List<DiagnosticsNode> debugDescribeChildren() {
    final List<DiagnosticsNode> offstageChildren = <DiagnosticsNode>[];
    final List<DiagnosticsNode> onstageChildren = <DiagnosticsNode>[];

    int count = 1;
    bool onstage = false;
    RenderBox? child = firstChild;
    final RenderBox? firstOnstageChild = _firstOnstageChild;
    while (child != null) {
      final _TheaterParentData childParentData = child.parentData! as _TheaterParentData;
      if (child == firstOnstageChild) {
        onstage = true;
        count = 1;
      }

      if (onstage) {
        onstageChildren.add(child.toDiagnosticsNode(name: 'onstage $count'));
      } else {
        offstageChildren.add(
          child.toDiagnosticsNode(name: 'offstage $count', style: DiagnosticsTreeStyle.offstage),
        );
      }

      int subcount = 1;
      childParentData.visitOverlayPortalChildrenOnOverlayEntry((RenderObject renderObject) {
        final RenderBox child = renderObject as RenderBox;
        if (onstage) {
          onstageChildren.add(child.toDiagnosticsNode(name: 'onstage $count - $subcount'));
        } else {
          offstageChildren.add(
            child.toDiagnosticsNode(
              name: 'offstage $count - $subcount',
              style: DiagnosticsTreeStyle.offstage,
            ),
          );
        }
        subcount += 1;
      });

      child = childParentData.nextSibling;
      count += 1;
    }

    return <DiagnosticsNode>[
      ...onstageChildren,
      if (offstageChildren.isNotEmpty)
        ...offstageChildren
      else
        DiagnosticsNode.message('no offstage children', style: DiagnosticsTreeStyle.offstage),
    ];
  }
}

// * OverlayPortal Implementation
//  OverlayPortal is inspired by the
//  [flutter_portal](https://pub.dev/packages/flutter_portal) package.
//
// ** RenderObject hierarchy
// The widget works by inserting its overlay child's render subtree directly
// under [Overlay]'s render object (_RenderTheater).
// https://user-images.githubusercontent.com/31859944/171971838-62ed3975-4b5d-4733-a9c9-f79e263b8fcc.jpg
//
// To ensure the overlay child render subtree does not do layout twice, the
// subtree must only perform layout after both its _RenderTheater and the
// [OverlayPortal]'s render object (_RenderLayoutSurrogateProxyBox) have
// finished layout. This is handled by _RenderDeferredLayoutBox.
//
// ** Z-Index of an overlay child
// [_OverlayEntryLocation] is a (currently private) interface that allows an
// [OverlayPortal] to insert its overlay child into a specific [Overlay], as
// well as specifying the paint order between the overlay child and other
// children of the _RenderTheater.
//
// Since [OverlayPortal] is only allowed to target ancestor [Overlay]s
// (_RenderTheater must finish doing layout before _RenderDeferredLayoutBox),
// the _RenderTheater should typically be acquired using an [InheritedWidget]
// (currently, _RenderTheaterMarker) in case the [OverlayPortal] gets
// reparented.

/// A class to show, hide and bring to top an [OverlayPortal]'s overlay child
/// in the target [Overlay].
///
/// A [OverlayPortalController] can only be given to at most one [OverlayPortal]
/// at a time. When an [OverlayPortalController] is moved from one
/// [OverlayPortal] to another, its [isShowing] state does not carry over.
///
/// [OverlayPortalController.show] and [OverlayPortalController.hide] can be
/// called even before the controller is assigned to any [OverlayPortal], but
/// they typically should not be called while the widget tree is being rebuilt.
class OverlayPortalController {
  /// Creates an [OverlayPortalController], optionally with a String identifier
  /// `debugLabel`.
  OverlayPortalController({String? debugLabel}) : _debugLabel = debugLabel;

  _OverlayPortalState? _attachTarget;

  // A separate _zOrderIndex to allow `show()` or `hide()` to be called when the
  // controller is not yet attached. Once this controller is attached,
  // _attachTarget._zOrderIndex will be used as the source of truth, and this
  // variable will be set to null.
  int? _zOrderIndex;
  final String? _debugLabel;

  static int _wallTime =
      kIsWeb
          ? -9007199254740992 // -2^53
          : -1 << 63;

  // Returns a unique and monotonically increasing timestamp that represents
  // now.
  //
  // The value this method returns increments after each call.
  int _now() {
    final int now = _wallTime += 1;
    assert(_zOrderIndex == null || _zOrderIndex! < now);
    assert(_attachTarget?._zOrderIndex == null || _attachTarget!._zOrderIndex! < now);
    return now;
  }

  /// Show the overlay child of the [OverlayPortal] this controller is attached
  /// to, at the top of the target [Overlay].
  ///
  /// When there are more than one [OverlayPortal]s that target the same
  /// [Overlay], the overlay child of the last [OverlayPortal] to have called
  /// [show] appears at the top level, unobstructed.
  ///
  /// If [isShowing] is already true, calling this method brings the overlay
  /// child it controls to the top.
  ///
  /// This method should typically not be called while the widget tree is being
  /// rebuilt.
  void show() {
    final _OverlayPortalState? state = _attachTarget;
    if (state != null) {
      state.show(_now());
    } else {
      _zOrderIndex = _now();
    }
  }

  /// Hide the [OverlayPortal]'s overlay child.
  ///
  /// Once hidden, the overlay child will be removed from the widget tree the
  /// next time the widget tree rebuilds, and stateful widgets in the overlay
  /// child may lose states as a result.
  ///
  /// This method should typically not be called while the widget tree is being
  /// rebuilt.
  void hide() {
    final _OverlayPortalState? state = _attachTarget;
    if (state != null) {
      state.hide();
    } else {
      assert(_zOrderIndex != null);
      _zOrderIndex = null;
    }
  }

  /// Whether the associated [OverlayPortal] should build and show its overlay
  /// child, using its `overlayChildBuilder`.
  bool get isShowing {
    final _OverlayPortalState? state = _attachTarget;
    return state != null ? state._zOrderIndex != null : _zOrderIndex != null;
  }

  /// Convenience method for toggling the current [isShowing] status.
  ///
  /// This method should typically not be called while the widget tree is being
  /// rebuilt.
  void toggle() => isShowing ? hide() : show();

  @override
  String toString() {
    final String? debugLabel = _debugLabel;
    final String label = debugLabel == null ? '' : '($debugLabel)';
    final String isDetached = _attachTarget != null ? '' : ' DETACHED';
    return '${objectRuntimeType(this, 'OverlayPortalController')}$label$isDetached';
  }
}

/// A widget that renders its overlay child on an [Overlay].
///
/// The overlay child is initially hidden until [OverlayPortalController.show]
/// is called on the associated [controller]. The [OverlayPortal] uses
/// [overlayChildBuilder] to build its overlay child and renders it on the
/// specified [Overlay] as if it was inserted using an [OverlayEntry], while it
/// can depend on the same set of [InheritedWidget]s (such as [Theme]) that this
/// widget can depend on.
///
/// This widget requires an [Overlay] ancestor in the widget tree when its
/// overlay child is showing. The overlay child is rendered by the [Overlay]
/// ancestor, not by the widget itself. This allows the overlay child to float
/// above other widgets, independent of its position in the widget tree.
///
/// When [OverlayPortalController.hide] is called, the widget built using
/// [overlayChildBuilder] will be removed from the widget tree the next time the
/// widget rebuilds. Stateful descendants in the overlay child subtree may lose
/// states as a result.
///
/// {@tool dartpad}
/// This example uses an [OverlayPortal] to build a tooltip that becomes visible
/// when the user taps on the [child] widget. There's a [DefaultTextStyle] above
/// the [OverlayPortal] controlling the [TextStyle] of both the [child] widget
/// and the widget [overlayChildBuilder] builds, which isn't otherwise doable if
/// the tooltip was added as an [OverlayEntry].
///
/// ** See code in examples/api/lib/widgets/overlay/overlay_portal.0.dart **
/// {@end-tool}
///
/// ### Paint Order
///
/// In an [Overlay], an overlay child is painted after the [OverlayEntry]
/// associated with its [OverlayPortal] (that is, the [OverlayEntry] closest to
/// the [OverlayPortal] in the widget tree, which usually represents the
/// enclosing [Route]), and before the next [OverlayEntry].
///
/// When an [OverlayEntry] has multiple associated [OverlayPortal]s, the paint
/// order between their overlay children is the order in which
/// [OverlayPortalController.show] was called. The last [OverlayPortal] to have
/// called `show` gets to paint its overlay child in the foreground.
///
/// ### Semantics
///
/// The semantics subtree generated by the overlay child is considered attached
/// to [OverlayPortal] instead of the target [Overlay]. An [OverlayPortal]'s
/// semantics subtree can be dropped from the semantics tree due to invisibility
/// while the overlay child is still visible (for example, when the
/// [OverlayPortal] is completely invisible in a [ListView] but kept alive by
/// a [KeepAlive] widget). When this happens the semantics subtree generated by
/// the overlay child is also dropped, even if the overlay child is still visible
/// on screen.
///
/// {@template flutter.widgets.overlayPortalVsOverlayEntry}
/// ### Differences between [OverlayPortal] and [OverlayEntry]
///
/// The main difference between [OverlayEntry] and [OverlayPortal] is that
/// [OverlayEntry] builds its widget subtree as a child of the target [Overlay],
/// while [OverlayPortal] uses [OverlayPortal.overlayChildBuilder] to build a
/// child widget of itself. This allows [OverlayPortal]'s overlay child to depend
/// on the same set of [InheritedWidget]s as [OverlayPortal], and it's also
/// guaranteed that the overlay child will not outlive its [OverlayPortal].
///
/// On the other hand, [OverlayPortal]'s implementation is more complex. For
/// instance, it does a bit more work than a regular widget during global key
/// reparenting. If the content to be shown on the [Overlay] doesn't benefit
/// from being a part of [OverlayPortal]'s subtree, consider using an
/// [OverlayEntry] instead.
/// {@endtemplate}
///
/// See also:
///
///  * [OverlayEntry], an alternative API for inserting widgets into an
///    [Overlay].
///  * [Positioned], which can be used to size and position the overlay child in
///    relation to the target [Overlay]'s boundaries.
///  * [CompositedTransformFollower], which can be used to position the overlay
///    child in relation to the linked [CompositedTransformTarget] widget.
class OverlayPortal extends StatefulWidget {
  /// Creates an [OverlayPortal] that renders the widget [overlayChildBuilder]
  /// builds on the closest [Overlay] when [OverlayPortalController.show] is
  /// called.
  const OverlayPortal({
    super.key,
    required this.controller,
    required this.overlayChildBuilder,
    this.child,
  }) : _targetRootOverlay = false;

  /// Creates an [OverlayPortal] that renders the widget [overlayChildBuilder]
  /// builds on the root [Overlay] when [OverlayPortalController.show] is
  /// called.
  const OverlayPortal.targetsRootOverlay({
    super.key,
    required this.controller,
    required this.overlayChildBuilder,
    this.child,
  }) : _targetRootOverlay = true;

  /// The controller to show, hide and bring to top the overlay child.
  final OverlayPortalController controller;

  /// A [WidgetBuilder] used to build a widget below this widget in the tree,
  /// that renders on the closest [Overlay].
  ///
  /// The said widget will only be built and shown in the closest [Overlay] once
  /// [OverlayPortalController.show] is called on the associated [controller].
  /// It will be painted in front of the [OverlayEntry] closest to this widget
  /// in the widget tree (which is usually the enclosing [Route]).
  ///
  /// The built overlay child widget is inserted below this widget in the widget
  /// tree, allowing it to depend on [InheritedWidget]s above it, and be
  /// notified when the [InheritedWidget]s change.
  ///
  /// Unlike [child], the built overlay child can visually extend outside the
  /// bounds of this widget without being clipped, and receive hit-test events
  /// outside of this widget's bounds, as long as it does not extend outside of
  /// the [Overlay] on which it is rendered.
  final WidgetBuilder overlayChildBuilder;

  /// A widget below this widget in the tree.
  final Widget? child;

  final bool _targetRootOverlay;

  @override
  State<OverlayPortal> createState() => _OverlayPortalState();
}

class _OverlayPortalState extends State<OverlayPortal> {
  int? _zOrderIndex;
  // The location of the overlay child within the overlay. This object will be
  // used as the slot of the overlay child widget.
  //
  // The developer must call `show` to reveal the overlay so we can get a unique
  // timestamp of the user interaction for determining the z-index of the
  // overlay child in the overlay.
  //
  // Avoid invalidating the cache if possible, since the framework uses `==` to
  // compare slots, and _OverlayEntryLocation can't override that operator since
  // it's mutable. Changing slots can be relatively slow.
  bool _childModelMayHaveChanged = true;
  _OverlayEntryLocation? _locationCache;
  static bool _isTheSameLocation(_OverlayEntryLocation locationCache, _RenderTheaterMarker marker) {
    return locationCache._childModel == marker.overlayEntryWidgetState &&
        locationCache._theater == marker.theater;
  }

  _OverlayEntryLocation _getLocation(int zOrderIndex, bool targetRootOverlay) {
    final _OverlayEntryLocation? cachedLocation = _locationCache;
    late final _RenderTheaterMarker marker = _RenderTheaterMarker.of(
      context,
      targetRootOverlay: targetRootOverlay,
    );
    final bool isCacheValid =
        cachedLocation != null &&
        (!_childModelMayHaveChanged || _isTheSameLocation(cachedLocation, marker));
    _childModelMayHaveChanged = false;
    if (isCacheValid) {
      assert(cachedLocation._zOrderIndex == zOrderIndex);
      assert(cachedLocation._debugIsLocationValid());
      return cachedLocation;
    }
    // Otherwise invalidate the cache and create a new location.
    cachedLocation?._debugMarkLocationInvalid();
    final _OverlayEntryLocation newLocation = _OverlayEntryLocation(
      zOrderIndex,
      marker.overlayEntryWidgetState,
      marker.theater,
    );
    assert(newLocation._zOrderIndex == zOrderIndex);
    return _locationCache = newLocation;
  }

  @override
  void initState() {
    super.initState();
    _setupController(widget.controller);
  }

  void _setupController(OverlayPortalController controller) {
    assert(
      controller._attachTarget == null || controller._attachTarget == this,
      'Failed to attach $controller to $this. It is already attached to ${controller._attachTarget}.',
    );
    final int? controllerZOrderIndex = controller._zOrderIndex;
    final int? zOrderIndex = _zOrderIndex;
    if (zOrderIndex == null ||
        (controllerZOrderIndex != null && controllerZOrderIndex > zOrderIndex)) {
      _zOrderIndex = controllerZOrderIndex;
    }
    controller._zOrderIndex = null;
    controller._attachTarget = this;
  }

  @override
  void didChangeDependencies() {
    super.didChangeDependencies();
    _childModelMayHaveChanged = true;
  }

  @override
  void didUpdateWidget(OverlayPortal oldWidget) {
    super.didUpdateWidget(oldWidget);
    _childModelMayHaveChanged =
        _childModelMayHaveChanged || oldWidget._targetRootOverlay != widget._targetRootOverlay;
    if (oldWidget.controller != widget.controller) {
      oldWidget.controller._attachTarget = null;
      _setupController(widget.controller);
    }
  }

  @override
  void dispose() {
    assert(widget.controller._attachTarget == this);
    widget.controller._attachTarget = null;
    _locationCache?._debugMarkLocationInvalid();
    _locationCache = null;
    super.dispose();
  }

  void show(int zOrderIndex) {
    assert(
      SchedulerBinding.instance.schedulerPhase != SchedulerPhase.persistentCallbacks,
      '${widget.controller.runtimeType}.show() should not be called during build.',
    );
    setState(() {
      _zOrderIndex = zOrderIndex;
    });
    _locationCache?._debugMarkLocationInvalid();
    _locationCache = null;
  }

  void hide() {
    assert(SchedulerBinding.instance.schedulerPhase != SchedulerPhase.persistentCallbacks);
    setState(() {
      _zOrderIndex = null;
    });
    _locationCache?._debugMarkLocationInvalid();
    _locationCache = null;
  }

  @override
  Widget build(BuildContext context) {
    final int? zOrderIndex = _zOrderIndex;
    if (zOrderIndex == null) {
      return _OverlayPortal(overlayLocation: null, overlayChild: null, child: widget.child);
    }
    return _OverlayPortal(
      overlayLocation: _getLocation(zOrderIndex, widget._targetRootOverlay),
      overlayChild: _DeferredLayout(child: Builder(builder: widget.overlayChildBuilder)),
      child: widget.child,
    );
  }
}

/// A location in an [Overlay].
///
/// An [_OverlayEntryLocation] determines the [Overlay] the associated
/// [OverlayPortal] should put its overlay child onto, as well as the overlay
/// child's paint order in relation to other contents painted on the [Overlay].
//
// An _OverlayEntryLocation is a cursor pointing to a location in a particular
// Overlay's child model, and provides methods to insert/remove/move a
// _RenderDeferredLayoutBox to/from its target _theater.
//
// The occupant (a `RenderBox`) will be painted above the associated
// [OverlayEntry], but below the [OverlayEntry] above that [OverlayEntry].
//
// Additionally, `_activate` and `_deactivate` are called when the overlay
// child's `_OverlayPortalElement` activates/deactivates (for instance, during
// global key reparenting).
// `_OverlayPortalElement` removes its overlay child's render object from the
// target `_RenderTheater` when it deactivates and puts it back on `activated`.
// These 2 methods can be used to "hide" a child in the child model without
// removing it, when the child is expensive/difficult to re-insert at the
// correct location on `activated`.
//
// ### Equality
//
// An `_OverlayEntryLocation` will be used as an Element's slot. These 3 parts
// uniquely identify a place in an overlay's child model:
// - _theater
// - _childModel (the OverlayEntry)
// - _zOrderIndex
//
// Since it can't implement operator== (it's mutable), the same `_OverlayEntryLocation`
// instance must not be used to represent more than one locations.
final class _OverlayEntryLocation extends LinkedListEntry<_OverlayEntryLocation> {
  _OverlayEntryLocation(this._zOrderIndex, this._childModel, this._theater);

  final int _zOrderIndex;
  final _OverlayEntryWidgetState _childModel;
  final _RenderTheater _theater;

  _RenderDeferredLayoutBox? _overlayChildRenderBox;
  void _addToChildModel(_RenderDeferredLayoutBox child) {
    assert(
      _overlayChildRenderBox == null,
      'Failed to add $child. This location ($this) is already occupied by $_overlayChildRenderBox.',
    );
    _overlayChildRenderBox = child;
    _childModel._add(this);
    _theater.markNeedsPaint();
    _theater.markNeedsCompositingBitsUpdate();
    _theater.markNeedsSemanticsUpdate();
  }

  void _removeFromChildModel(_RenderDeferredLayoutBox child) {
    assert(child == _overlayChildRenderBox);
    _overlayChildRenderBox = null;
    assert(_childModel._sortedTheaterSiblings?.contains(this) ?? false);
    _childModel._remove(this);
    _theater.markNeedsPaint();
    _theater.markNeedsCompositingBitsUpdate();
    _theater.markNeedsSemanticsUpdate();
  }

  void _addChild(_RenderDeferredLayoutBox child) {
    assert(_debugIsLocationValid());
    _addToChildModel(child);
    _theater._addDeferredChild(child);
    assert(child.parent == _theater);
  }

  void _removeChild(_RenderDeferredLayoutBox child) {
    // This call is allowed even when this location is disposed.
    _removeFromChildModel(child);
    _theater._removeDeferredChild(child);
    assert(child.parent == null);
  }

  void _moveChild(_RenderDeferredLayoutBox child, _OverlayEntryLocation fromLocation) {
    assert(fromLocation != this);
    assert(_debugIsLocationValid());
    final _RenderTheater fromTheater = fromLocation._theater;
    final _OverlayEntryWidgetState fromModel = fromLocation._childModel;

    if (fromTheater != _theater) {
      fromTheater._removeDeferredChild(child);
      _theater._addDeferredChild(child);
    }

    if (fromModel != _childModel || fromLocation._zOrderIndex != _zOrderIndex) {
      fromLocation._removeFromChildModel(child);
      _addToChildModel(child);
    }
  }

  void _activate(_RenderDeferredLayoutBox child) {
    // This call is allowed even when this location is invalidated.
    // See _OverlayPortalElement.activate.
    assert(_overlayChildRenderBox == null, '$_overlayChildRenderBox');
    _theater._addDeferredChild(child);
    _overlayChildRenderBox = child;
  }

  void _deactivate(_RenderDeferredLayoutBox child) {
    // This call is allowed even when this location is invalidated.
    _theater._removeDeferredChild(child);
    _overlayChildRenderBox = null;
  }

  // Throws a StateError if this location is already invalidated and shouldn't
  // be used as an OverlayPortal slot. Must be used in asserts.
  //
  // Generally, `assert(_debugIsLocationValid())` should be used to prevent
  // invalid accesses to an invalid `_OverlayEntryLocation` object. Exceptions
  // to this rule are _removeChild, _deactivate, which will be called when the
  // OverlayPortal is being removed from the widget tree and may use the
  // location information to perform cleanup tasks.
  //
  // Another exception is the _activate method which is called by
  // _OverlayPortalElement.activate. See the comment in _OverlayPortalElement.activate.
  bool _debugIsLocationValid() {
    if (_debugMarkLocationInvalidStackTrace == null) {
      return true;
    }
    throw StateError(
      '$this is already disposed. Stack trace: $_debugMarkLocationInvalidStackTrace',
    );
  }

  // The StackTrace of the first _debugMarkLocationInvalid call. It's only for
  // debugging purposes and the StackTrace will only be captured in debug builds.
  //
  // The effect of this method is not reversible. Once marked invalid, this
  // object can't be marked as valid again.
  StackTrace? _debugMarkLocationInvalidStackTrace;
  @mustCallSuper
  void _debugMarkLocationInvalid() {
    assert(_debugIsLocationValid());
    assert(() {
      _debugMarkLocationInvalidStackTrace = StackTrace.current;
      return true;
    }());
  }

  @override
  String toString() =>
      '${objectRuntimeType(this, '_OverlayEntryLocation')}[${shortHash(this)}] ${_debugMarkLocationInvalidStackTrace != null ? "(INVALID)" : ""}';
}

class _RenderTheaterMarker extends InheritedWidget {
  const _RenderTheaterMarker({
    required this.theater,
    required this.overlayEntryWidgetState,
    required super.child,
  });

  final _RenderTheater theater;
  final _OverlayEntryWidgetState overlayEntryWidgetState;

  @override
  bool updateShouldNotify(_RenderTheaterMarker oldWidget) {
    return oldWidget.theater != theater ||
        oldWidget.overlayEntryWidgetState != overlayEntryWidgetState;
  }

  static _RenderTheaterMarker of(BuildContext context, {bool targetRootOverlay = false}) {
    final _RenderTheaterMarker? marker;
    if (targetRootOverlay) {
      final InheritedElement? ancestor = _rootRenderTheaterMarkerOf(
        context.getElementForInheritedWidgetOfExactType<_RenderTheaterMarker>(),
      );
      assert(ancestor == null || ancestor.widget is _RenderTheaterMarker);
      marker =
          ancestor != null
              ? context.dependOnInheritedElement(ancestor) as _RenderTheaterMarker?
              : null;
    } else {
      marker = context.dependOnInheritedWidgetOfExactType<_RenderTheaterMarker>();
    }
    if (marker != null) {
      return marker;
    }
    throw FlutterError.fromParts(<DiagnosticsNode>[
      ErrorSummary('No Overlay widget found.'),
      ErrorDescription(
        '${context.widget.runtimeType} widgets require an Overlay widget ancestor.\n'
        'An overlay lets widgets float on top of other widget children.',
      ),
      ErrorHint(
        'To introduce an Overlay widget, you can either directly '
        'include one, or use a widget that contains an Overlay itself, '
        'such as a Navigator, WidgetApp, MaterialApp, or CupertinoApp.',
      ),
      ...context.describeMissingAncestor(expectedAncestorType: Overlay),
    ]);
  }

  static InheritedElement? _rootRenderTheaterMarkerOf(InheritedElement? theaterMarkerElement) {
    assert(theaterMarkerElement == null || theaterMarkerElement.widget is _RenderTheaterMarker);
    if (theaterMarkerElement == null) {
      return null;
    }
    InheritedElement? ancestor;
    theaterMarkerElement.visitAncestorElements((Element element) {
      ancestor = element.getElementForInheritedWidgetOfExactType<_RenderTheaterMarker>();
      return false;
    });
    return ancestor == null ? theaterMarkerElement : _rootRenderTheaterMarkerOf(ancestor);
  }
}

class _OverlayPortal extends RenderObjectWidget {
  /// Creates a widget that renders the given [overlayChild] in the [Overlay]
  /// specified by `overlayLocation`.
  ///
  /// The `overlayLocation` parameter must not be null when [overlayChild] is not
  /// null.
  _OverlayPortal({required this.overlayLocation, required this.overlayChild, required this.child})
    : assert(overlayChild == null || overlayLocation != null),
      assert(overlayLocation == null || overlayLocation._debugIsLocationValid());

  final Widget? overlayChild;

  /// A widget below this widget in the tree.
  final Widget? child;

  final _OverlayEntryLocation? overlayLocation;

  @override
  RenderObjectElement createElement() => _OverlayPortalElement(this);

  @override
  RenderObject createRenderObject(BuildContext context) => _RenderLayoutSurrogateProxyBox();
}

class _OverlayPortalElement extends RenderObjectElement {
  _OverlayPortalElement(_OverlayPortal super.widget);

  @override
  _RenderLayoutSurrogateProxyBox get renderObject =>
      super.renderObject as _RenderLayoutSurrogateProxyBox;

  Element? _overlayChild;
  Element? _child;

  @override
  void mount(Element? parent, Object? newSlot) {
    super.mount(parent, newSlot);
    final _OverlayPortal widget = this.widget as _OverlayPortal;
    _child = updateChild(_child, widget.child, null);
    _overlayChild = updateChild(_overlayChild, widget.overlayChild, widget.overlayLocation);
  }

  @override
  void update(_OverlayPortal newWidget) {
    super.update(newWidget);
    _child = updateChild(_child, newWidget.child, null);
    _overlayChild = updateChild(_overlayChild, newWidget.overlayChild, newWidget.overlayLocation);
  }

  @override
  void forgetChild(Element child) {
    // The _overlayChild Element does not have a key because the _DeferredLayout
    // widget does not take a Key, so only the regular _child can be taken
    // during global key reparenting.
    assert(child == _child);
    _child = null;
    super.forgetChild(child);
  }

  @override
  void visitChildren(ElementVisitor visitor) {
    final Element? child = _child;
    final Element? overlayChild = _overlayChild;
    if (child != null) {
      visitor(child);
    }
    if (overlayChild != null) {
      visitor(overlayChild);
    }
  }

  @override
  void activate() {
    super.activate();
    final _RenderDeferredLayoutBox? box = _overlayChild?.renderObject as _RenderDeferredLayoutBox?;
    if (box != null) {
      assert(!box.attached);
      assert(renderObject._deferredLayoutChild == box);
      // updateChild has not been called at this point so the RenderTheater in
      // the overlay location could be detached. Adding children to a detached
      // RenderObject is still allowed however this isn't the most efficient.
      (_overlayChild!.slot! as _OverlayEntryLocation)._activate(box);
    }
  }

  @override
  void deactivate() {
    // Instead of just detaching the render objects, removing them from the
    // render subtree entirely. This is a workaround for the
    // !renderObject.attached assert in the `super.deactivate()` method.
    final _RenderDeferredLayoutBox? box = _overlayChild?.renderObject as _RenderDeferredLayoutBox?;
    if (box != null) {
      (_overlayChild!.slot! as _OverlayEntryLocation)._deactivate(box);
    }
    super.deactivate();
  }

  @override
  void insertRenderObjectChild(RenderBox child, _OverlayEntryLocation? slot) {
    assert(child.parent == null, "$child's parent is not null: ${child.parent}");
    if (slot != null) {
      renderObject._deferredLayoutChild = child as _RenderDeferredLayoutBox;
      slot._addChild(child);
      renderObject.markNeedsSemanticsUpdate();
    } else {
      renderObject.child = child;
    }
  }

  // The [_DeferredLayout] widget does not have a key so there will be no
  // reparenting between _overlayChild and _child, thus the non-null-typed slots.
  @override
  void moveRenderObjectChild(
    _RenderDeferredLayoutBox child,
    _OverlayEntryLocation oldSlot,
    _OverlayEntryLocation newSlot,
  ) {
    assert(newSlot._debugIsLocationValid());
    newSlot._moveChild(child, oldSlot);
    renderObject.markNeedsSemanticsUpdate();
  }

  @override
  void removeRenderObjectChild(RenderBox child, _OverlayEntryLocation? slot) {
    if (slot == null) {
      renderObject.child = null;
      return;
    }
    assert(renderObject._deferredLayoutChild == child);
    slot._removeChild(child as _RenderDeferredLayoutBox);
    renderObject._deferredLayoutChild = null;
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties.add(DiagnosticsProperty<Element>('child', _child, defaultValue: null));
    properties.add(DiagnosticsProperty<Element>('overlayChild', _overlayChild, defaultValue: null));
    properties.add(
      DiagnosticsProperty<Object>('overlayLocation', _overlayChild?.slot, defaultValue: null),
    );
  }
}

class _DeferredLayout extends SingleChildRenderObjectWidget {
  const _DeferredLayout({
    // This widget must not be given a key: we currently do not support
    // reparenting between the overlayChild and child.
    required Widget child,
  }) : super(child: child);

  _RenderLayoutSurrogateProxyBox getLayoutParent(BuildContext context) {
    return context.findAncestorRenderObjectOfType<_RenderLayoutSurrogateProxyBox>()!;
  }

  @override
  _RenderDeferredLayoutBox createRenderObject(BuildContext context) {
    final _RenderLayoutSurrogateProxyBox parent = getLayoutParent(context);
    final _RenderDeferredLayoutBox renderObject = _RenderDeferredLayoutBox(parent);
    parent._deferredLayoutChild = renderObject;
    return renderObject;
  }

  @override
  void updateRenderObject(BuildContext context, _RenderDeferredLayoutBox renderObject) {
    assert(renderObject._layoutSurrogate == getLayoutParent(context));
    assert(getLayoutParent(context)._deferredLayoutChild == renderObject);
  }
}

// A `RenderProxyBox` that defers its layout until its `_layoutSurrogate` (which
// is not necessarily an ancestor of this RenderBox, but shares at least one
// `_RenderTheater` ancestor with this RenderBox) is laid out.
//
// This `RenderObject` must be a child of a `_RenderTheater`. It guarantees that:
//
// 1. It's a relayout boundary, so calling `markNeedsLayout` on it never dirties
//    its `_RenderTheater`.
//
// 2. Its `layout` implementation is overridden such that `performLayout` does
//    not do anything when its called from `layout`, preventing the parent
//    `_RenderTheater` from laying out this subtree prematurely (but this
//    `RenderObject` may still be resized). Instead, `markNeedsLayout` will be
//    called from within `layout` to schedule a layout update for this relayout
//    boundary when needed.
//
// 3. When invoked from `PipelineOwner.flushLayout`, or
//    `_layoutSurrogate.performLayout`, this `RenderObject` behaves like an
//    `Overlay` that has only one entry.
final class _RenderDeferredLayoutBox extends RenderProxyBox
    with _RenderTheaterMixin, LinkedListEntry<_RenderDeferredLayoutBox> {
  _RenderDeferredLayoutBox(this._layoutSurrogate);

  StackParentData get stackParentData => parentData! as StackParentData;
  final _RenderLayoutSurrogateProxyBox _layoutSurrogate;

  @override
  Iterable<RenderBox> _childrenInPaintOrder() {
    final RenderBox? child = this.child;
    return child == null
        ? const Iterable<RenderBox>.empty()
        : Iterable<RenderBox>.generate(1, (int i) => child);
  }

  @override
  Iterable<RenderBox> _childrenInHitTestOrder() => _childrenInPaintOrder();

  @override
  _RenderTheater get theater {
    final RenderObject? parent = this.parent;
    return parent is _RenderTheater
        ? parent
        : throw FlutterError('$parent of $this is not a _RenderTheater');
  }

  @override
  void redepthChildren() {
    _layoutSurrogate.redepthChild(this);
    super.redepthChildren();
  }

  @override
  bool get sizedByParent => true;

  bool _needsLayout = true;
  @override
  void markNeedsLayout() {
    _needsLayout = true;
    super.markNeedsLayout();
  }

  @override
  RenderObject? get semanticsParent => _layoutSurrogate;

  @override
  double? computeDryBaseline(BoxConstraints constraints, TextBaseline baseline) {
    final RenderBox? child = this.child;
    if (child == null) {
      return null;
    }
    return _RenderTheaterMixin.baselineForChild(
      child,
      constraints.biggest,
      constraints,
      theater._resolvedAlignment,
      baseline,
    );
  }

  @override
  RenderObject? get debugLayoutParent => _layoutSurrogate;

  void layoutByLayoutSurrogate() {
    assert(!_theaterDoingThisLayout);
    final _RenderTheater? theater = parent as _RenderTheater?;
    if (theater == null || !attached) {
      assert(false, '$this is not attached to parent');
      return;
    }
    if (theater._layingOutSizeDeterminingChild) {
      theater.invokeLayoutCallback((BoxConstraints constraints) {
        markNeedsLayout();
      });
    } else {
      final BoxConstraints theaterConstraints = theater.constraints;
      final Size boxSize =
          theaterConstraints.biggest.isFinite
              ? theaterConstraints.biggest
              // Accessing the theater's size is only unsafe if it is laying out the
              // size-determining child.
              : theater.size;
      super.layout(BoxConstraints.tight(boxSize));
    }
  }

  bool _theaterDoingThisLayout = false;
  @override
  void layout(Constraints constraints, {bool parentUsesSize = false}) {
    assert(_needsLayout == debugNeedsLayout);
    // Only _RenderTheater calls this implementation.
    assert(parent != null);
    final bool scheduleDeferredLayout = _needsLayout || this.constraints != constraints;
    assert(!_theaterDoingThisLayout);
    _theaterDoingThisLayout = true;
    super.layout(constraints, parentUsesSize: parentUsesSize);
    assert(_theaterDoingThisLayout);
    _theaterDoingThisLayout = false;
    _needsLayout = false;
    assert(!debugNeedsLayout);
    if (scheduleDeferredLayout) {
      final _RenderTheater parent = this.parent! as _RenderTheater;
      // Invoking markNeedsLayout as a layout callback allows this node to be
      // merged back to the `PipelineOwner`'s dirty list in the right order, if
      // it's not already dirty. Otherwise this may cause some dirty descendants
      // to performLayout a second time.
      parent.invokeLayoutCallback((BoxConstraints constraints) {
        markNeedsLayout();
      });
    }
  }

  @override
  void performResize() {
    size = constraints.biggest;
  }

  bool _debugMutationsLocked = false;
  @override
  void performLayout() {
    assert(!_debugMutationsLocked);
    if (_theaterDoingThisLayout) {
      _needsLayout = false;
      return;
    }
    assert(() {
      _debugMutationsLocked = true;
      return true;
    }());
    // This method is directly being invoked from `PipelineOwner.flushLayout`,
    // or from `_layoutSurrogate`'s performLayout.
    assert(parent != null);
    final RenderBox? child = this.child;
    if (child == null) {
      _needsLayout = false;
      return;
    }
    assert(constraints.isTight);
    layoutChild(child, constraints);
    assert(() {
      _debugMutationsLocked = false;
      return true;
    }());
    _needsLayout = false;
  }

  @override
  void applyPaintTransform(RenderBox child, Matrix4 transform) {
    final BoxParentData childParentData = child.parentData! as BoxParentData;
    final Offset offset = childParentData.offset;
    transform.translate(offset.dx, offset.dy);
  }
}

// A RenderProxyBox that makes sure its `deferredLayoutChild` has a greater
// depth than itself.
class _RenderLayoutSurrogateProxyBox extends RenderProxyBox {
  _RenderDeferredLayoutBox? _deferredLayoutChild;

  @override
  void redepthChildren() {
    super.redepthChildren();
    final _RenderDeferredLayoutBox? child = _deferredLayoutChild;
    // If child is not attached, this method will be invoked by child's real
    // parent when it's attached.
    if (child != null && child.attached) {
      assert(child.attached);
      redepthChild(child);
    }
  }

  @override
  void performLayout() {
    super.performLayout();
    // Try to layout `_deferredLayoutChild` here now that its configuration
    // and constraints are up-to-date. Additionally, during the very first
    // layout, this makes sure that _deferredLayoutChild is reachable via tree
    // walk.
    _deferredLayoutChild?.layoutByLayoutSurrogate();
  }

  @override
  void visitChildrenForSemantics(RenderObjectVisitor visitor) {
    super.visitChildrenForSemantics(visitor);
    final _RenderDeferredLayoutBox? deferredChild = _deferredLayoutChild;
    if (deferredChild != null) {
      visitor(deferredChild);
    }
  }
}


Instructions for the chapter (Generate content in English unless specified otherwise):
- Start with a clear heading (e.g., `# Chapter 7: _RenderDeferredLayoutBox
`). Use the provided concept name.

- If this is not the first chapter, begin with a brief transition from the previous chapter, referencing it with a proper Markdown link using its name.

- Begin with a high-level motivation explaining what problem this abstraction solves. Start with a central use case as a concrete example. The whole chapter should guide the reader to understand how to solve this use case. Make it very minimal and friendly to beginners.

- If the abstraction is complex, break it down into key concepts. Explain each concept one-by-one in a very beginner-friendly way.

- Explain how to use this abstraction to solve the use case. Give example inputs and outputs for code snippets (if the output isn't values, describe at a high level what will happen).

- Each code block should be BELOW 10 lines! If longer code blocks are needed, break them down into smaller pieces and walk through them one-by-one. Aggresively simplify the code to make it minimal. Use comments to skip non-important implementation details. Each code block should have a beginner friendly explanation right after it.

- Describe the internal implementation to help understand what's under the hood. First provide a non-code or code-light walkthrough on what happens step-by-step when the abstraction is called. It's recommended to use a simple sequenceDiagram with a dummy example - keep it minimal with at most 5 participants to ensure clarity. If participant name has space, use: `participant QP as Query Processing`. .

- Then dive deeper into code for the internal implementation with references to files. Provide example code blocks, but make them similarly simple and beginner-friendly. Explain.

- IMPORTANT: When you need to refer to other core abstractions covered in other chapters, ALWAYS use proper Markdown links like this: [Chapter Title](filename.md). Use the Complete Tutorial Structure above to find the correct filename and the chapter title. Translate the surrounding text.

- Use mermaid diagrams to illustrate complex concepts (```mermaid``` format). .

- Heavily use analogies and examples throughout to help beginners understand.

- End the chapter with a brief conclusion that summarizes what was learned and provides a transition to the next chapter. If there is a next chapter, use a proper Markdown link: [Next Chapter Title](next_chapter_filename).

- Ensure the tone is welcoming and easy for a newcomer to understand.

- Output *only* the Markdown content for this chapter.

Now, directly provide a super beginner-friendly Markdown output (DON'T need ```markdown``` tags):

2025-05-22 23:59:02,666 - INFO - RESPONSE: # Chapter 7: _RenderDeferredLayoutBox

Welcome to Chapter 7! In our journey through `overlay.dart`, we've learned about the central [Overlay](01_overlay_.md) that manages layers on the screen, the [OverlayState](02_overlaystate_.md) that controls those layers, the [OverlayEntry](03_overlayentry_.md) for manual layer management, the modern [OverlayPortal](04_overlayportal_.md) and its [OverlayPortalController](05_overlayportalcontroller_.md) for attaching overlays to specific widgets, and the [_Theater](06__theater_.md) which acts as the stage where all the overlay children are laid out and painted.

We saw that when using [OverlayPortal](04_overlayportal_.md), the widget you want to show on the overlay is defined in its `overlayChildBuilder`. This widget isn't placed directly in the `OverlayPortal`'s spot in the main widget tree; instead, its *corresponding render object* is attached somewhere within the [_Theater](06__theater_.md)'s render object tree.

This separation is powerful  it allows the overlay child to float on the [Overlay](01_overlay_.md) independently. However, it introduces a challenge: how do you correctly lay out the overlay child? Its size and position might depend on the size and position of the original [OverlayPortal]'s `child` (like positioning a context menu below a button). But the overlay child renders in a totally different part of the render tree ([_Theater](06__theater_.md)), and the `OverlayPortal`'s `child` renders in the main render tree. How does the overlay child know the dimensions and position it needs?

This is where the internal **`_RenderDeferredLayoutBox`** comes in.

Think of `_RenderDeferredLayoutBox` as a placeholder or a messenger box for the `OverlayPortal`'s overlay child within the [_Theater](06__theater_.md)'s render tree. When the `OverlayPortal`'s overlay child is active, the system creates the render object for that child (let's call it the "overlay child render box") and wraps it inside a `_RenderDeferredLayoutBox`. This `_RenderDeferredLayoutBox` is then placed as a child within the [_Theater](06__theater_.md)'s render object hierarchy.

The key job of the `_RenderDeferredLayoutBox` is right there in its name: it **defers** its layout. It doesn't immediately lay out the overlay child inside it when its parent ([_Theater](06__theater_.md)) asks it to. Instead, it relies on a specific signal from its "layout surrogate"  which is the render object corresponding to the `_OverlayPortal` widget back where the `OverlayPortal` lives in the main widget tree.

The goal is to ensure that the overlay child's layout, which might depend on the layout of the `OverlayPortal`'s regular `child`, only happens *after* the `OverlayPortal` and its `child` have been laid out in the main tree.

### Why is Layout Deferred?

Consider our context menu example from [Chapter 5](05_overlayportalcontroller_.md). The context menu needs to know the size and position of the button (the `OverlayPortal`'s `child`) to position itself correctly below it.

1.  The *main* render tree (where the button is) goes through its layout process. The bounds and position of the button are determined.
2.  The *overlay* render tree (the [_Theater](06__theater_.md)) goes through *its* layout process. It encounters the `_RenderDeferredLayoutBox`.
3.  If the `_RenderDeferredLayoutBox` laid out its overlay child *immediately* when requested by the [_Theater](06__theater_.md), it wouldn't have the final, accurate layout information about the button from the main tree yet! This could lead to incorrect positioning.

By deferring its layout, the `_RenderDeferredLayoutBox` waits for a signal from its "layout surrogate" back in the main tree. This surrogate (`_RenderLayoutSurrogateProxyBox`) is laid out *after* the button. Once the surrogate is laid out, it signals the `_RenderDeferredLayoutBox` in the [_Theater](06__theater_.md) to perform *its* layout. At this point, the necessary layout information from the main tree (like the button's position) is available, and the overlay child can be laid out correctly.

### How _RenderDeferredLayoutBox Works Internally

Let's trace the path of the render objects involved:

1.  Your `OverlayPortal` widget is in the main widget tree. Its `build` method (specifically the `_OverlayPortalState`'s build) returns an internal `_OverlayPortal` widget.
2.  This `_OverlayPortal` widget creates a special render object called `_RenderLayoutSurrogateProxyBox`. This is the "layout surrogate" we mentioned. It lives in the main render tree, where the `OverlayPortal` is. It acts as a placeholder and a source of layout information.
3.  If the `OverlayPortalController` is showing the overlay (`_zOrderIndex` is not null), the `_OverlayPortalState`'s build method also includes the widget from your `overlayChildBuilder` wrapped in a `_DeferredLayout` widget.
4.  The `_DeferredLayout` widget creates the `_RenderDeferredLayoutBox`. This is the render object that wraps your actual overlay child render object. It gets a reference to the `_RenderLayoutSurrogateProxyBox` (the surrogate) during its creation.
5.  This `_RenderDeferredLayoutBox` (containing your overlay child render box) is then attached directly to the [_Theater](06__theater_.md)'s render object (`_RenderTheater`) in the overlay render tree.
6.  When the `_RenderTheater` performs layout, it encounters the `_RenderDeferredLayoutBox`.
7.  The `_RenderDeferredLayoutBox`'s `performLayout` method is overridden to **do nothing immediately** when called by the [_Theater](06__theater_.md) during the usual layout phase.
8.  Later, during the layout phase for the *main* tree, the `_RenderLayoutSurrogateProxyBox` (the surrogate in the main tree) is laid out. After its own layout is complete, it explicitly calls a method on the `_RenderDeferredLayoutBox` (`layoutByLayoutSurrogate`) to tell it to **now** perform its layout.
9.  At this point, the `_RenderDeferredLayoutBox` is signaled to lay out the overlay child inside it. Because the surrogate was laid out *after* the button, the button's layout information is available (via `_buttonKey.currentContext!.findRenderObject()!.localToGlobal(Offset.zero)` in our example) and can be used by your `overlayChildBuilder` to size and position the overlay child correctly within the [_Theater](06__theater_.md)'s coordinate space.

Sequence diagram showing deferred layout:

```mermaid
sequenceDiagram
    participant MainRenderTree
    participant ButtonRenderBox
    participant OverlayPortalRender as _RenderLayoutSurrogateProxyBox
    participant OverlayRenderTree as _RenderTheater
    participant DeferredLayoutBox as _RenderDeferredLayoutBox
    participant OverlayChildRender as Your Overlay Child RenderBox

    MainRenderTree->>ButtonRenderBox: performLayout (Main)
    ButtonRenderBox->>MainRenderTree: Layout Complete
    MainRenderTree->>OverlayPortalRender: performLayout (Main)
    OverlayPortalRender->>MainRenderTree: Layout Complete
    OverlayPortalRender->>DeferredLayoutBox: call layoutByLayoutSurrogate() NOW! (Explicit Signal)

    OverlayRenderTree->>DeferredLayoutBox: performLayout (Overlay - DOES NOTHING YET)

    DeferredLayoutBox->>OverlayChildRender: performLayout (TRIGGERED BY layoutByLayoutSurrogate)
    OverlayChildRender->>DeferredLayoutBox: Layout Complete (using button position/size)
    DeferredLayoutBox->>OverlayRenderTree: Layout Complete
```

This illustrates that the layout of the `DeferredLayoutBox` (and thus your overlay child) is skipped during the [_Theater](06__theater_.md)'s initial layout pass and is triggered later by the parallel layout coming from the main tree via the `_RenderLayoutSurrogateProxyBox`.

### Peek into the Code (_RenderDeferredLayoutBox)

Let's look at the definition and some key methods of `_RenderDeferredLayoutBox`:

```dart
final class _RenderDeferredLayoutBox extends RenderProxyBox
    with _RenderTheaterMixin, LinkedListEntry<_RenderDeferredLayoutBox> {
  _RenderDeferredLayoutBox(this._layoutSurrogate); // Gets reference to the surrogate

  final _RenderLayoutSurrogateProxyBox _layoutSurrogate; // The surrogate

  // ... properties and methods ...

  @override
  void markNeedsLayout() {
    _needsLayout = true;
    // IMPORTANT: Calling super.markNeedsLayout() here, but it's overridden
    // below to *not* mark the parent dirty if _skipMarkNeedsLayout is true
    // (which it is when called from _addDeferredChild). This prevents
    // unnecessarily dirtying the _RenderTheater.
    super.markNeedsLayout();
  }

  // This is the method called explicitly by the _RenderLayoutSurrogateProxyBox
  void layoutByLayoutSurrogate() {
    // ... assertions ...
    // Get constraints from the theater and call super.layout
    super.layout(BoxConstraints.tight(boxSize));
  }

  bool _theaterDoingThisLayout = false; // Flag to detect theater-triggered layout
  @override
  void layout(Constraints constraints, {bool parentUsesSize = false}) {
    // If this method is called by the parent (_RenderTheater) during its layout...
    if (_theaterDoingThisLayout) {
       _needsLayout = false;
       return; // ... DO NOTHING FOR LAYOUT YET!
    }
    // If this method is called by layoutByLayoutSurrogate...
    _theaterDoingThisLayout = true;
    super.layout(constraints, parentUsesSize: parentUsesSize); // Perform layout!
    _theaterDoingThisLayout = false;
    // ... schedule another layout update *later* if needed.
    // This looks counter-intuitive but is part of the double buffering/deferral.
    // See the code's comments about PipelineOwner.flushLayout.
    parent! as _RenderTheater.invokeLayoutCallback((BoxConstraints constraints) {
      markNeedsLayout(); // Schedule a future layout pass
    });
  }

  @override
  void performLayout() {
     // This is ONLY called when laid out by layoutByLayoutSurrogate
     // Get constraints, lay out the actual child inside this box.
     layoutChild(child!, constraints);
     _needsLayout = false;
  }

  // ... other overrides ...
}
```

This snippet highlights:

*   The `_RenderDeferredLayoutBox` receives its `_layoutSurrogate` in its constructor.
*   `markNeedsLayout` is overridden to avoid marking the [_Theater](06__theater_.md) dirty directly in some cases.
*   `layoutByLayoutSurrogate` is the public method called by the surrogate to trigger the layout. It gets the constraints from the [_Theater](06__theater_.md) and calls the *standard* `layout` method (`super.layout`).
*   The main `layout` method is overridden. It uses the `_theaterDoingThisLayout` flag to determine *who* is calling it. If it's the [_Theater](06__theater_.md) (`_theaterDoingThisLayout` is false initially), it does minimal work and returns. If it's called by `layoutByLayoutSurrogate` (`_theaterDoingThisLayout` is true), it proceeds to call `super.layout` (which then calls `performLayout`).
*   The `performLayout` method is where the *actual* layout of the overlay child inside the `_RenderDeferredLayoutBox` happens. This method is now only reached when triggered by `layoutByLayoutSurrogate`.

This complex dance ensures that the overlay child's layout (which might depend on the main tree) happens *after* the relevant parts of the main tree are laid out, but still integrates correctly within the overlay's render tree managed by the [_Theater](06__theater_.md).

You can also see the `_RenderLayoutSurrogateProxyBox` has a `_deferredLayoutChild` property and calls `_deferredLayoutChild.layoutByLayoutSurrogate()` in its own `performLayout`.

```dart
// From _RenderLayoutSurrogateProxyBox
@override
void performLayout() {
  super.performLayout(); // Lays out its own static child (if any)
  // Now that we are laid out, tell the deferred child to layout
  _deferredLayoutChild?.layoutByLayoutSurrogate();
}
```

This confirms the surrogate's role in triggering the deferred layout.

### Conclusion

In this chapter, we dug into the inner workings of `_RenderDeferredLayoutBox`, a crucial internal render object used by [OverlayPortal](04_overlayportal_.md). We learned that its purpose is to wrap the rendero bject of the overlay child and deliberately **defer** its layout. This deferral is necessary to ensure the overlay child is laid out *after* the relevant parts of the main widget tree (like the [OverlayPortal](04_overlayportal_.md)'s `child`) have their layout finalized, allowing for correct positioning relative to the originating widget. We saw how it works in conjunction with the `_RenderLayoutSurrogateProxyBox` in the main tree to receive an explicit layout signal, bypassing the [_Theater](06__theater_.md)'s initial layout pass for that child.

Understanding `_RenderDeferredLayoutBox` helps complete the picture of how [OverlayPortal](04_overlayportal_.md) manages to seamlessly integrate an overlay widget into the global [Overlay](01_overlay_.md) while maintaining a conceptual link to its origin point in the main UI.

In the final chapter, we will briefly look at `_OverlayEntryLocation
`, another internal helper related to how [OverlayPortal](04_overlayportal_.md) finds its place within the [Overlay](01_overlay_.md).

[_OverlayEntryLocation](08__overlayentrylocation_.md)
2025-05-22 23:59:02,679 - INFO - PROMPT: 
Write a very beginner-friendly tutorial chapter (in Markdown format) for the project `flutter (overlay.dart)` about the concept: "_OverlayEntryLocation
". This is Chapter 8.

Concept Details:
- Name: _OverlayEntryLocation

- Description:
_OverlayEntryLocation is an internal concept used by OverlayPortal to track where its displayed widget should be placed within the Overlay's rendering structure (_Theater). It's like a ticket with a specific z-index that the OverlayPortal's widget uses to find its spot in the Overlay's visual stack, ensuring it's painted above the correct OverlayEntry.


Complete Tutorial Structure:
1. [Overlay
](01_overlay_.md)
2. [OverlayState
](02_overlaystate_.md)
3. [OverlayEntry
](03_overlayentry_.md)
4. [OverlayPortal
](04_overlayportal_.md)
5. [OverlayPortalController
](05_overlayportalcontroller_.md)
6. [_Theater
](06__theater_.md)
7. [_RenderDeferredLayoutBox
](07__renderdeferredlayoutbox_.md)
8. [_OverlayEntryLocation
](08__overlayentrylocation_.md)

Context from previous chapters:
# Chapter 1: Overlay

Welcome to the first chapter of our tutorial on Flutter's `overlay.dart`! In this chapter, we'll introduce you to the fundamental concept of an `Overlay`.

Have you ever seen temporary popups, like dialogs, tooltips that appear over your regular screen content, no matter what's currently displayed? How does Flutter manage to show these elements *on top* of everything else? That's where the `Overlay` comes in!

Think of your Flutter app's user interface as a stack of layers, like transparencies on an overhead projector. Your main screen content is on the bottom layer. When you want to show something *over* that content, without affecting how the main content is arranged, you place it on a new, transparent layer on top. The `Overlay` widget is like the frame of this overhead projector that holds the stack of transparent sheets.

The `Overlay` itself is a widget that sits high up in your app's widget tree, often provided automatically by powerful widgets like `MaterialApp` or `WidgetsApp`. It manages a list of "sheets," called [OverlayEntry](03_overlayentry_.md)s. Each [OverlayEntry](03_overlayentry_.md) can hold a widget, and these widgets will be painted *above* the `Overlay`'s regular content.

So, the core idea is:

**An `Overlay` is a stack of entry points where you can place widgets that should appear on top of your primary UI.**

### Our Goal: Displaying a Simple Overlay

To understand the `Overlay` better, let's imagine we want to display a simple message box that floats in the center of the screen when a button is pressed. This message box should appear above all other content on the screen.

Using the `Overlay` and its related components, we can achieve this. Here's the high-level plan:

1.  Find the nearest `Overlay`.
2.  Create an [OverlayEntry](03_overlayentry_.md) containing our message box widget.
3.  Insert this [OverlayEntry](03_overlayentry_.md) into the `Overlay`'s stack.
4.  When we want to hide the message box, we'll remove the [OverlayEntry](03_overlayentry_.md) from the `Overlay`.

### Finding the Overlay

The `Overlay` is usually introduced by the main app widgets like `MaterialApp`. To interact with this `Overlay`, we need to get its state, which is an [OverlayState](02_overlaystate_.md). We can do this using the `Overlay.of` method, passing the current `BuildContext`.

```dart
// Inside a widget's build method or a function called from it:
OverlayState? overlayState = Overlay.of(context);
```

This code snippet uses `Overlay.of(context)` to look up the closest `OverlayState` in the widget tree above the current `context`. If an `Overlay` is found, it gives us its state (the [OverlayState](02_overlaystate_.md) object) that we can use to manage our overlay entries. If no `Overlay` is found (which is unlikely in a typical `MaterialApp`), it would cause an error in debug mode.

### What's Inside the Overlay?

While we don't see it directly in the minimal code we write, the `Overlay` widget itself contains some interesting pieces to manage its entries.

Let's look at a relevant snippet from the `overlay.dart` file:

```dart
class Overlay extends StatefulWidget {
  // ... other properties and methods

  @override
  OverlayState createState() => OverlayState();
}
```

This shows that the `Overlay` widget creates an [OverlayState](02_overlaystate_.md). This is the object we obtained using `Overlay.of`. The [OverlayState](02_overlaystate_.md) is where the real work of managing the list of [OverlayEntry](03_overlayentry_.md) objects happens.

Further down in the code, we see how the `OverlayState` builds its UI:

```dart
class OverlayState extends State<Overlay> with TickerProviderStateMixin {
  final List<OverlayEntry> _entries = <OverlayEntry>[];

  // ... methods for inserting and removing entries

  @protected
  @override
  Widget build(BuildContext context) {
    // ... logic to determine visible entries
    final List<_OverlayEntryWidget> children = <_OverlayEntryWidget>[];
    // ... populate children based on _entries
    return _Theater(
      // ... properties like skipCount, clipBehavior
      children: children.reversed.toList(growable: false),
    );
  }

  // ... other methods
}
```

This snippet reveals a crucial part: the `OverlayState` holds a list of `_entries` (our [OverlayEntry](03_overlayentry_.md) objects). In its `build` method, it creates a list of `_OverlayEntryWidget`s corresponding to the active entries. These widgets are then passed to a special widget called `_Theater`.

The `_Theater` widget is essentially a specialized `Stack`. It's responsible for laying out and painting the widgets from the [OverlayEntry](03_overlayentry_.md)s on top of each other, similar to how layers are stacked in a `Stack`.

Here's a simplified illustration of the key participants and their relationships in displaying an overlay entry:

```mermaid
sequenceDiagram
    participant YourWidget
    participant OverlayDotOf as Overlay.of(context)
    participant OverlayState
    participant OverlayEntry
    participant _Theater

    YourWidget->>OverlayDotOf: Ask for OverlayState
    OverlayDotOf-->>OverlayState: Return the found OverlayState
    YourWidget->>OverlayState: Create and insert OverlayEntry
    OverlayState->>OverlayEntry: Add entry to internal list
    OverlayState->>OverlayState: Schedule rebuild
    OverlayState->>_Theater: Build _Theater with entries as children
    _Theater->>OverlayEntry: Ask entry to build its widget
    OverlayEntry->>_Theater: Return built widget
    _Theater->>_Theater: Layout and paint entry's widget on top

```

This diagram shows that your widget interacts with the global `Overlay.of` to get the [OverlayState](02_overlaystate_.md). You then use the [OverlayState](02_overlaystate_.md) to manage your [OverlayEntry](03_overlayentry_.md). The [OverlayState](02_overlaystate_.md) internally uses `_Theater` to visually stack the widgets provided by the [OverlayEntry](03_overlayentry_.md)s.

### Conclusion

In this chapter, we introduced the concept of the `Overlay` in Flutter. We learned that it acts as a container for widgets that should appear on top of the regular UI, managing them as a stack of [OverlayEntry](03_overlayentry_.md) objects. We saw how to find the `OverlayState` using `Overlay.of` and got a peek into the internal structure involving `_Theater`.

In the next chapter, we will delve deeper into the [OverlayState](02_overlaystate_.md) and explore how to use its methods to actually insert and remove [OverlayEntry](03_overlayentry_.md) objects, allowing us to finally display our floating message box.

[OverlayState](02_overlaystate_.md)
---
# Chapter 2: OverlayState

Welcome back! In our [previous chapter](01_overlay_.md), we learned that an `Overlay` acts like a transparent layer on top of our regular UI, managed by powerful widgets like `MaterialApp`. We also saw that this `Overlay` holds a stack of "sheets" called [OverlayEntry](03_overlayentry_.md)s. But who is in charge of managing these sheets? That's where the `OverlayState` comes in.

Think of the `Overlay` as the physical structure (the overhead projector frame) and the `OverlayState` as the person operating that projector. The `OverlayState` is the **manager** for the `Overlay`. Its main job is to keep track of which [OverlayEntry](03_overlayentry_.md) sheets are currently in the stack and decide which ones are visible.

Our goal from the last chapter was to display a simple message box that floats in the center of the screen when a button is pressed. To do this, we need to:

1.  Find the `OverlayState` associated with our `Overlay`.
2.  Create an [OverlayEntry](03_overlayentry_.md) containing our message box widget.
3.  Tell the `OverlayState` to **insert** this [OverlayEntry](03_overlayentry_.md) into its stack.
4.  When we want to hide the message box, tell the `OverlayState` to **remove** the [OverlayEntry](03_overlayentry_.md).

In this chapter, we'll focus on how to use the `OverlayState` to perform these insertions and removals.

### Getting the OverlayState

As we briefly saw in the last chapter, we can get the `OverlayState` using the static method `Overlay.of`. This method looks up the widget tree from the given `BuildContext` and finds the nearest `Overlay` widget's state.

```dart
// Inside a widget where you want to show an overlay:
void showMyMessageBox(BuildContext context) {
  OverlayState? overlayState = Overlay.of(context);
  // Now we have the manager (the OverlayState)!
}
```

Here, `Overlay.of(context)` does the important work of finding the correct `OverlayState` for us. The `context` tells Flutter where in the widget tree we are looking from. In a typical app, this `OverlayState` will be the one managed by your `MaterialApp` or `WidgetsApp`.

### Adding an OverlayEntry

Once we have the `OverlayState`, we can add new entries to it. The `OverlayState` has an `insert` method for this purpose. The `insert` method takes an [OverlayEntry](03_overlayentry_.md) object as its argument.

Let's imagine we have created our `OverlayEntry` object (we'll learn more about [OverlayEntry](03_overlayentry_.md) in the next chapter, for now just assume it exists).

```dart
// Continuing from the previous snippet:
void showMyMessageBox(BuildContext context) {
  OverlayState? overlayState = Overlay.of(context);

  if (overlayState != null) {
    // Assume 'myOverlayEntry' is an instance of OverlayEntry
    // that holds our message box widget.
    OverlayEntry myOverlayEntry = createMessageBoxEntry(); // Placeholder function

    overlayState.insert(myOverlayEntry);
    print('Message box inserted!');
  } else {
    print('Could not find OverlayState!');
  }
}

// Placeholder for creating the OverlayEntry
OverlayEntry createMessageBoxEntry() {
  // This would contain the actual widget for the message box
  return OverlayEntry(
    builder: (context) => Center(
      child: Container(
        width: 200,
        height: 100,
        color: Colors.blue,
        child: Center(child: Text('Hello Overlay!')),
      ),
    ),
  );
}
```

In this code:
1.  We get the `overlayState`.
2.  We check if it's not null (meaning an `Overlay` was found).
3.  We create an `OverlayEntry` (using `createMessageBoxEntry`).
4.  We call `overlayState.insert(myOverlayEntry)`. This is the key step! It tells the `OverlayState` to add our entry to its internal list.

When an `OverlayEntry` is inserted, the `OverlayState` marks itself as needing to rebuild. During the next build cycle, the `OverlayState` will include the widget from your newly inserted [OverlayEntry](03_overlayentry_.md) in its list of visible children, making it appear on top of your UI.

### Ordering OverlayEntries

The `insert` method also allows you to control where the entry is inserted in the stack:

*   `overlayState.insert(entry)`: Inserts the entry at the very top (painted last).
*   `overlayState.insert(entry, below: someOtherEntry)`: Inserts the entry just below `someOtherEntry`.
*   `overlayState.insert(entry, above: someOtherEntry)`: Inserts the entry just above `someOtherEntry`.

This is like deciding whether to place your new transparency sheet on the very top of the stack, or insert it right above or below another specific sheet. This is useful for complex overlays or when integrating with system overlays like dialogs or routes managed by the Navigator.

### Removing an OverlayEntry

Adding entries is only half the story. We also need to be able to remove them. For example, when the user closes our message box, we want to take it off the overlay.

To remove an [OverlayEntry](03_overlayentry_.md), you call the `remove()` method directly on the **[OverlayEntry](03_overlayentry_.md) object itself**, not on the `OverlayState`.

```dart
// Continuing the example, we need to keep track of the inserted entry:
OverlayEntry? currentMessageBoxEntry; // Store the active entry

void showMyMessageBox(BuildContext context) {
  // ... find overlayState ...
  if (overlayState != null) {
    // Create and store the entry before inserting
    currentMessageBoxEntry = createMessageBoxEntry();
    overlayState.insert(currentMessageBoxEntry!); // Insert it
    print('Message box inserted!');

    // Example: Automatically remove after 3 seconds (for demonstration)
    Future.delayed(Duration(seconds: 3), () {
      removeMyMessageBox();
    });

  } else {
    print('Could not find OverlayState!');
  }
}

// Function to remove the message box
void removeMyMessageBox() {
  if (currentMessageBoxEntry != null) {
    currentMessageBoxEntry!.remove(); // Call remove on the entry!
    currentMessageBoxEntry = null; // Clear the stored entry
    print('Message box removed!');
  }
}

// (createMessageBoxEntry function remains the same)
// (Remember to import 'package:flutter/material.dart' for Colors/Container/Text)
```

In this updated code:
1.  We declare `currentMessageBoxEntry` to hold a reference to the [OverlayEntry](03_overlayentry_.md) once it's created and inserted.
2.  When showing the box, we assign the new entry to this variable.
3.  When removing the box (`removeMyMessageBox`), we check if `currentMessageBoxEntry` is not null and call its `remove()` method.
4.  After removing, we set `currentMessageBoxEntry` back to null.

Calling `entry.remove()` tells the `OverlayState` to take that specific [OverlayEntry](03_overlayentry_.md) out of its list. Similar to insertion, the `OverlayState` will then mark itself dirty and rebuild, this time *without* including the widget from the removed entry.

### How OverlayState Manages Entries Internally

Let's look peek under the hood again. We saw in the snippet from the last chapter that `OverlayState` holds a `List<OverlayEntry> _entries`. This is the core list it manages.

When you call `insert`:

```dart
// From overlay.dart -> OverlayState -> insert method (simplified)
void insert(OverlayEntry entry, {OverlayEntry? below, OverlayEntry? above}) {
  // ... asserts ...
  entry._overlay = this; // Internal link back to this OverlayState
  setState(() { // Marks state as dirty, schedules a rebuild
    _entries.insert(_insertionIndex(below, above), entry); // Adds to the list
  });
}
```

*   `entry._overlay = this;`: The [OverlayEntry](03_overlayentry_.md) keeps a reference to the `OverlayState` it belongs to. This is how `entry.remove()` knows *which* `OverlayState` to tell to remove it.
*   `setState(() { ... });`: This is standard Flutter State management. It signals to the framework that the state of the `OverlayState` has changed (`_entries` list is different) and it needs to be rebuilt.
*   `_entries.insert(...)`: This is the actual list manipulation. It adds the `entry` at the calculated position in the internal `_entries` list.

When the `OverlayState` rebuilds, its `build` method creates the UI using the current contents of `_entries`. We saw that it uses a widget called `_Theater` for this:

```dart
// From overlay.dart -> OverlayState -> build method (simplified)
@override
Widget build(BuildContext context) {
  // ... logic to determine visible entries ...
  final List<_OverlayEntryWidget> children = <_OverlayEntryWidget>[];
  // Loop through _entries (and inactive maintainedState entries)
  // and create _OverlayEntryWidget for each.
  return _Theater(
    // ...
    children: children.reversed.toList(growable: false), // Passes the list to _Theater
  );
}
```

The `_Theater` is essentially a specialized container that takes a list of child widgets (built from the [OverlayEntry](03_overlayentry_.md)s) and stacks them on top of each other. The children are given to `_Theater` in reversed order because the `_entries` list is ordered from bottom to top, but a `Stack` (which `_Theater` behaves like) paints children from bottom to top based on their position in the list. So, the last entry in `_entries` (the top-most one) needs to be the last child given to `_Theater`.

Here's a sequence diagram illustrating insertion:

```mermaid
sequenceDiagram
    participant YourWidget
    participant OverlayState
    participant OverlayEntry
    participant Framework as Flutter Framework
    participant _Theater

    YourWidget->>OverlayState: call insert(OverlayEntry)
    OverlayState->>OverlayEntry: set internal _overlay reference
    OverlayState->>OverlayState: add OverlayEntry to _entries list
    OverlayState->>Framework: call setState()
    Framework->>OverlayState: scheduled rebuild
    OverlayState->>OverlayState: call build()
    OverlayState->>OverlayEntry: call builder() to get widget
    OverlayEntry->>OverlayState: return widget
    OverlayState->>_Theater: pass widget as child
    _Theater->>_Theater: layout and paint widget on top
```

When you call `entry.remove()`:

```dart
// From overlay.dart -> OverlayEntry -> remove method (simplified)
void remove() {
  assert(_overlay != null);
  final OverlayState overlay = _overlay!; // Get the associated OverlayState
  _overlay = null; // Clear the internal reference

  // ... schedule markDirty or call directly ...
  overlay._entries.remove(this); // Remove from the OverlayState's list
  overlay._markDirty(); // Tell the OverlayState to rebuild
  // ...
}
```

*   `_overlay!`: Accesses the `OverlayState` that this entry is currently in.
*   `_entries.remove(this);`: The `OverlayEntry` tells its manager (`_overlay`) to remove itself from the list.
*   `overlay._markDirty();`: Calls an internal method on the `OverlayState` to signal that it needs to rebuild.

The diagram for removal is similar to insertion, just in reverse:

```mermaid
sequenceDiagram
    participant YourWidget
    participant OverlayEntry
    participant OverlayState
    participant Framework as Flutter Framework
    participant _Theater

    YourWidget->>OverlayEntry: call remove()
    OverlayEntry->>OverlayState: access internal _overlay reference
    OverlayEntry->>OverlayEntry: clear internal _overlay reference
    OverlayEntry->>OverlayState: remove OverlayEntry from _entries list
    OverlayState->>OverlayState: call _markDirty()
    OverlayState->>Framework: setState() called implicitly
    Framework->>OverlayState: scheduled rebuild
    OverlayState->>OverlayState: call build()
    OverlayState->>_Theater: pass children (without the removed entry)
    _Theater->>_Theater: relayout and repaint (entry disappears)
```

This demonstrates how the `OverlayState` acts as the central hub, maintaining the list and triggering UI updates when the list of [OverlayEntry](03_overlayentry_.md) objects changes.

### Conclusion

In this chapter, we explored the crucial role of the `OverlayState`. We learned that it is the manager for an [Overlay](01_overlay_.md), holding the list of [OverlayEntry](03_overlayentry_.md) objects and controlling their visibility. We saw how to obtain the `OverlayState` using `Overlay.of` and, most importantly, how to use its `insert` method to add [OverlayEntry](03_overlayentry_.md)s to the overlay stack and how to call `remove` directly on an [OverlayEntry](03_overlayentry_.md) to take it out.

We also took a look at the internal workings, seeing how `OverlayState`'s `_entries` list is manipulated and how `setState` triggers a rebuild to update the UI using the [_Theater](06__theater_.md) widget.

Now that we understand the container ([Overlay](01_overlay_.md)) and its manager (`OverlayState`), it's time to delve into the "sheets" themselves: the [OverlayEntry](03_overlayentry_.md). In the next chapter, we'll learn how to create our own [OverlayEntry](03_overlayentry_.md) objects with the specific widgets we want to display on the overlay.

[OverlayEntry](03_overlayentry_.md)
---
# Chapter 3: OverlayEntry

Welcome back to our `overlay.dart` tutorial! In the [previous chapters](01_overlay_.md), we learned about the [Overlay](01_overlay_.md) as a container that sits on top of our UI and the [OverlayState](02_overlaystate_.md) as its manager, responsible for inserting and removing items from the overlay stack.

But what exactly are these "items" or "sheets" that get placed onto the [Overlay](01_overlay_.md)? That's where the `OverlayEntry` comes in!

Think of an `OverlayEntry` as a single, transparent sheet that you prepare to put onto the [Overlay](01_overlay_.md)'s overhead projector. This sheet has one purpose: to hold and display **a single widget** on the overlay.

Our goal is to display a simple message box that floats in the center of the screen when a button is pressed. To do this using the [Overlay](01_overlay_.md) and [OverlayState](02_overlaystate_.md), we need to wrap our message box widget inside an `OverlayEntry`.

So, an `OverlayEntry` is the object that carries the self-contained piece of UI you want to show on top of your regular content. It's the payload that the [OverlayState](02_overlaystate_.md) manages.

### Creating an OverlayEntry

Creating an `OverlayEntry` is straightforward. You just need to provide a `builder` function. This `builder` function is a standard Flutter `WidgetBuilder` that takes a `BuildContext` and should return the widget you want to display on the overlay.

Here's how we would create an `OverlayEntry` for our simple message box:

```dart
// This function creates an OverlayEntry for our message box.
OverlayEntry createMessageBoxEntry() {
  OverlayEntry entry = OverlayEntry(
    builder: (BuildContext context) {
      // The widget that will be shown on the overlay
      return Center( // Center it on the overlay
        child: Container(
          width: 200,
          height: 100,
          color: Colors.blue,
          child: const Center(child: Text('Hello OverlayEntry!')),
        ),
      );
    },
  );
  return entry;
}
```

In this snippet:

*   `OverlayEntry(...)`: We call the `OverlayEntry` constructor.
*   `builder: (BuildContext context) { ... }`: We provide the required `builder` function. Flutter will call this function when it needs to display our entry on the overlay.
*   Inside the `builder`, we return a `Center` widget containing our blue message `Container`. This widget is what the `OverlayEntry` will represent visually on the overlay.

Now, when we get the [OverlayState](02_overlaystate_.md) (as shown in the [previous chapter](02_overlaystate_.md)) and call `overlayState.insert(entry)`, our beautiful blue box will appear centered on the screen!

### OverlayEntry Properties: Opaque and MaintainState

Besides the `builder`, `OverlayEntry` has a couple of important properties: `opaque` and `maintainState`. These properties control how the `Overlay` handles layers below this specific entry.

*   **`opaque` (default: `false`)**: If set to `true`, this property signals to the [Overlay](01_overlay_.md) that this entry completely covers whatever is beneath it in the overlay stack. This is mainly an optimization hint. If an entry is `opaque`, the [Overlay](01_overlay_.md) can skip building or painting the parts of the entries below it that are covered. Think of putting a solid, colored sheet on the overhead projector  you can't see through it to the sheets below. Our message box isn't truly opaque unless it fills the whole screen, but for performance, you might mark a dialog or a full-screen route as opaque.

*   **`maintainState` (default: `false`)**: If set to `true`, this property tells the [Overlay](01_overlay_.md) to keep the widget hierarchy for this entry active, even if it's visually hidden by an `opaque` entry on top. This is like keeping the light on for a sheet even if a solid sheet is on top. This is useful for things like keeping the state of a background route alive in a Navigator, even when another route is covering it entirely. Setting this to `true` can use more resources, so use it only when necessary.

For our simple message box, neither of these needs to be `true`. It doesn't cover everything below it entirely (it's just a small box), and we don't need to maintain its state when it's not visible (we'll remove it when hidden). So, the default values work fine.

```dart
OverlayEntry createMessageBoxEntry() {
  return OverlayEntry(
    builder: (BuildContext context) {
      // Our message box widget
      return Center(
        child: Container(
          width: 200,
          height: 100,
          color: Colors.blue,
          child: const Center(child: Text('Hello OverlayEntry!')),
        ),
      );
    },
    // opaque: false, // Default and appropriate for a small box
    // maintainState: false, // Default and appropriate as we remove it
  );
}
```

### Removing an OverlayEntry

As we saw in the [previous chapter](02_overlaystate_.md), to remove an `OverlayEntry`, you call the `remove()` method directly on the `OverlayEntry` object itself.

```dart
// Assuming you have a variable to hold the entry:
OverlayEntry? myActiveMessageBoxEntry;

void hideMyMessageBox() {
  if (myActiveMessageBoxEntry != null) {
    myActiveMessageBoxEntry!.remove(); // Tell the entry to remove itself
    myActiveMessageBoxEntry = null; // Clear our reference
  }
}
```

When `entry.remove()` is called:
1. The `OverlayEntry` looks up the [OverlayState](02_overlaystate_.md) it was inserted into (it holds an internal reference).
2. It tells that [OverlayState](02_overlaystate_.md) to remove it from its list of entries.
3. The [OverlayState](02_overlaystate_.md) rebuilds, and since the entry is no longer in its list, the widget built by this entry's `builder` is no longer included in the UI, making it disappear.

### How OverlayEntry Works Internally

Let's revisit the code snippet from `overlay.dart` for `OverlayEntry`:

```dart
class OverlayEntry implements Listenable {
  // ... constructor and properties ...

  OverlayState? _overlay; // Internal reference to the managing OverlayState
  final GlobalKey<_OverlayEntryWidgetState> _key = GlobalKey<_OverlayEntryWidgetState>();

  /// Remove this entry from the overlay.
  void remove() {
    assert(_overlay != null);
    final OverlayState overlay = _overlay!; // Get the associated OverlayState
    _overlay = null; // Clear the internal reference

    // ... scheduling logic ...
    overlay._entries.remove(this); // Request removal from the OverlayState's list
    overlay._markDirty(); // Tell the OverlayState to rebuild
    // ...
  }

  /// Cause this entry to rebuild during the next pipeline flush.
  ///
  /// You need to call this function if the output of [builder] has changed.
  void markNeedsBuild() {
    assert(!_disposedByOwner);
    _key.currentState?._markNeedsBuild();
  }

  // ... dispose method and other internal details ...
}
```

Key takeaways from this snippet:

*   `OverlayState? _overlay;`: This private variable is how an `OverlayEntry` knows which [OverlayState](02_overlaystate_.md) it belongs to. This reference is set when you call `overlayState.insert(entry)`.
*   `final GlobalKey<_OverlayEntryWidgetState> _key`: Each `OverlayEntry` uses a `GlobalKey` to identify the actual widget (`_OverlayEntryWidget`) that the [OverlayState](02_overlaystate_.md) creates to represent this entry in the widget tree.
*   `remove()`: When you call `remove()`, it uses the `_overlay` reference to find the correct [OverlayState](02_overlaystate_.md) and tells it to remove `this` entry from its internal `_entries` list (`overlay._entries.remove(this)`). It then sets `_overlay` to `null` and calls `overlay._markDirty()` to trigger a rebuild of the [OverlayState](02_overlaystate_.md).
*   `markNeedsBuild()`: If the widget you return from your `builder` function changes (e.g., based on some state within the `OverlayEntry`), you can call `markNeedsBuild()` on the `OverlayEntry` to tell the system that its visual representation needs to be updated. This calls `setState` on the internal `_OverlayEntryWidgetState` associated with this entry's `_key`.

Here's a sequence diagram focusing on the OverlayEntry's role in removal:

```mermaid
sequenceDiagram
    participant YourWidget
    participant OverlayEntry
    participant OverlayState
    participant Framework as Flutter Framework

    YourWidget->>OverlayEntry: call remove()
    OverlayEntry->>OverlayEntry: access internal _overlay reference
    OverlayEntry->>OverlayEntry: clear internal _overlay reference
    OverlayEntry->>OverlayState: remove OverlayEntry from _entries list
    OverlayState->>OverlayState: call _markDirty() (triggers setState)
    OverlayState->>Framework: schedule build
    Framework->>OverlayState: call build()
    OverlayState->>OverlayEntry: Build logic skips removed entry
    OverlayEntry->>Framework: Widget no longer added to tree
    Framework->>Framework: UI updated (entry disappears)
```

This confirms that the `OverlayEntry` is primarily a data holder for the widget and properties, and it delegates the actual UI management (insertion and removal from the visual tree) back to the [OverlayState](02_overlaystate_.md) it belongs to.

### Conclusion

In this chapter, we focused on the `OverlayEntry`, the core object that holds the widget you want to display on an [Overlay](01_overlay_.md). We learned how to create a basic `OverlayEntry` using a `builder` function, how to use its `opaque` and `maintainState` properties, and how calling `remove()` on the entry itself signals to the managing [OverlayState](02_overlaystate_.md) to take it off the screen.

We also briefly looked at the internal structure, understanding that `OverlayEntry` keeps a reference to its [OverlayState](02_overlaystate_.md) and manages a `GlobalKey` to its corresponding widget in the overlay tree.

With the concepts of [Overlay](01_overlay_.md), [OverlayState](02_overlaystate_.md), and `OverlayEntry` under our belt, we now have the foundational knowledge to display custom widgets on top of our application content at a global level!

In the next chapter, we will introduce [OverlayPortal](04_overlayportal_.md), a more modern and often simpler alternative to directly managing `OverlayEntry` objects, especially when you want an overlay widget to stay closely connected to the state and context of its originating widget.

[OverlayPortal](04_overlayportal_.md)
---
# Chapter 4: OverlayPortal

Welcome back! In our [previous chapters](01_overlay_.md), we built a solid understanding of the [Overlay](01_overlay_.md), the [OverlayState](02_overlaystate_.md) (its manager), and the [OverlayEntry](03_overlayentry_.md) (the sheet holding the widget). We learned how to manually create an [OverlayEntry](03_overlayentry_.md), get the [OverlayState](02_overlaystate_.md), and insert/remove the entry to make a widget appear or disappear on top of everything.

While this manual approach works, sometimes it can feel a bit disconnected. You have your original widget (say, a button that triggers the overlay), and the overlay widget itself is managed separately by the [OverlayState](02_overlaystate_.md), potentially far away in the widget tree. This can make things like keeping the overlay visually positioned relative to the original widget or having the overlay widget inherit themes/context from the original widget's location a bit tricky.

This is where `OverlayPortal` comes in!

Think of `OverlayPortal` as a special window from your widget's location directly to the [Overlay](01_overlay_.md). You place the `OverlayPortal` widget in your widget tree like any other widget. When you want to show something on the [Overlay](01_overlay_.md), you tell the `OverlayPortal`, and it uses a builder function you provide to create the widget.

**The key idea is that the widget you want to show on the [Overlay](01_overlay_.md) feels like it's still attached to your `OverlayPortal`'s spot in the widget tree, even though it's visually displayed on the [Overlay](01_overlay_.md).**

### Our Goal: A Context Menu

Let's refine our goal. Instead of just a simple message box, imagine we want a small context menu to appear right next to a button when you tap it. This menu should float on the [Overlay](01_overlay_.md), but its position should be related to the button, and it should inherit styling (like text themes) from where the button is located.

Using `OverlayPortal`, this becomes much more natural than manual [OverlayEntry](03_overlayentry_.md) management.

### Creating an OverlayPortal

An `OverlayPortal` is a `StatefulWidget` you add to your widget tree. It requires a `controller` (an [OverlayPortalController](05_overlayportalcontroller_.md), which we'll cover in the next chapter) and an `overlayChildBuilder`.

```dart
// Inside your widget's build method:
OverlayPortal(
  controller: _myOverlayController, // We'll make this in the next chapter
  overlayChildBuilder: (BuildContext context) {
    // This is the widget that will show on the Overlay
    return Positioned( // We'll position it later
      top: 100, // Just a placeholder for now
      left: 100, // Just a placeholder for now
      child: Material( // Use Material for styling/elevation
        elevation: 4.0,
        child: Container(
          padding: const EdgeInsets.all(8.0),
          color: Colors.yellow[100],
          child: Text('Context Menu!'),
        ),
      ),
    );
  },
  child: ElevatedButton( // This is the original widget (the button)
    onPressed: () {
      // We will show the overlay here using the controller
    },
    child: const Text('Show Menu'),
  ),
)
```

In this example:

1.  We place the `OverlayPortal` widget in our tree.
2.  We give it an `overlayChildBuilder`. This is very similar to the `builder` for an [OverlayEntry](03_overlayentry_.md)  it's the function that creates the widget for the overlay.
3.  We add a `child` property. This is the regular child widget of the `OverlayPortal` (our `ElevatedButton`).

The widget returned by `overlayChildBuilder` (`Positioned` in this case) will be displayed on the [Overlay](01_overlay_.md), but its `BuildContext` will be a special one that's linked back to the `OverlayPortal`'s location. This is why it can easily inherit themes, etc., from its original position.

Notice that we are using a `Positioned` widget directly in the `overlayChildBuilder`. This is common because `OverlayPortal`'s overlay child is placed within the [Overlay](01_overlay_.md) which behaves like a `Stack`. `Positioned` widgets are used to control the placement of children within a `Stack`.

### How OverlayPortal Works Internally (High Level)

When Flutter lays out the widget tree, it encounters the `OverlayPortal`. Importantly, when its `overlayChildBuilder` *is active* (meaning you've told the controller to show the overlay):

1.  The `OverlayPortal`'s `Element` (specifically an `_OverlayPortalElement`) calls its `overlayChildBuilder` to get the overlay widget.
2.  Instead of painting this widget directly where the `OverlayPortal` is located in the tree, the `_OverlayPortalElement` finds the nearest ancestor [Overlay](01_overlay_.md) (using an internal mechanism involving an `InheritedWidget`, which we'll see later).
3.  It then inserts the *render object* corresponding to the overlay widget into the `_RenderTheater` (the specialized `Stack` that the [Overlay](01_overlay_.md) uses to manage its visual children).
4.  The render object is placed correctly relative to other things on the [Overlay](01_overlay_.md) based on the order defined by the `OverlayPortalController`.
5.  The original `OverlayPortal` widget then continues its standard layout and painting for its `child` widget (the button), as if the overlay widget wasn't there.

This gives the illusion that the overlay widget is coming from the `OverlayPortal`'s location, even though its physical rendering happens on the [Overlay](01_overlay_.md).

Sequence diagram illustrating the key interaction:

```mermaid
sequenceDiagram
    participant YourWidget
    participant OverlayPortal
    participant _OverlayPortalState
    participant _OverlayPortalElement
    participant _TheaterMarker as InheritedWidget
    participant OverlayState
    participant _RenderTheater

    YourWidget->>OverlayPortal: build time (includes OverlayPortal)
    OverlayPortal->>_OverlayPortalState: create state
    _OverlayPortalState->>_OverlayPortalElement: mount element
    _OverlayPortalElement->>_TheaterMarker: look up ancestor Overlay info
    _TheaterMarker-->>_OverlayPortalElement: provide _RenderTheater etc.
    YourWidget->>YourWidget: trigger show via controller (next chapter)
    YourWidget->>_OverlayPortalState: call controller.show()
    _OverlayPortalState->>_OverlayPortalState: update internal state (_zOrderIndex)
    _OverlayPortalState->>YourWidget: setState() triggers rebuild
    YourWidget->>OverlayPortal: rebuild with show=true
    OverlayPortal->>_OverlayPortalElement: update element
    _OverlayPortalElement->>_OverlayPortalElement: call overlayChildBuilder
    _OverlayPortalElement->>_RenderTheater: attach overlay child render object
    _RenderTheater->>_RenderTheater: paint child on overlay
```

This shows how the `OverlayPortal` lives in your regular widget tree but has the ability to "reach out" to the ancestor [Overlay](01_overlay_.md)'s render object tree (`_RenderTheater`) to place its overlay child's render objects there.

### Advantages of OverlayPortal over Manual OverlayEntry

*   **Simplified Management:** You don't manually create, store, insert, or remove [OverlayEntry](03_overlayentry_.md) objects. The `OverlayPortal` widget handles this for you based on the state of its controller.
*   **Context and Inherited Widgets:** The `BuildContext` provided to `overlayChildBuilder` is closely tied to the `OverlayPortal`'s original location. This means your overlay widget automatically inherits themes, `MediaQuery`, `Localizations`, etc., making styling and layout much easier.
*   **State Management:** The lifecycle of the overlay widget is tied to the `OverlayPortal`. If the `OverlayPortal` is disposed, the overlay widget goes away too. This simplifies managing the state of complex overlay children.
*   **Relative Positioning:** While basic `Positioned` works, `OverlayPortal` makes it easier to use widgets like `CompositedTransformTarget` and `CompositedTransformFollower` to position the overlay child precisely relative to the `OverlayPortal`'s location. We used a simple `Positioned` as a placeholder for now, but later chapters might explore this.

### Limitations

*   **Must have an ancestor `Overlay`:** Just like manual [OverlayEntry](03_overlayentry_.md), the `OverlayPortal` needs an [Overlay](01_overlay_.md) widget higher up in the tree to paint on. (Usually provided by `MaterialApp`, `WidgetsApp`, or `Navigator`.)
*   **Requires a controller:** You need to manage an [OverlayPortalController](05_overlayportalcontroller_.md) to show/hide the overlay.

### Peek into the Code

Let's look at the `OverlayPortal` class definition:

```dart
class OverlayPortal extends StatefulWidget {
  const OverlayPortal({
    super.key,
    required this.controller,
    required this.overlayChildBuilder,
    this.child,
  }) : _targetRootOverlay = false;

  // ... (targetsRootOverlay constructor) ...

  final OverlayPortalController controller;
  final WidgetBuilder overlayChildBuilder;
  final Widget? child;
  final bool _targetRootOverlay;

  @override
  State<OverlayPortal> createState() => _OverlayPortalState();
}
```

This confirms it's a `StatefulWidget` (hence the need for a `State` object, `_OverlayPortalState`, which will manage the connection to the [Overlay](01_overlay_.md) and the rendering). It takes the required `controller` and `overlayChildBuilder` and an optional `child`.

The `createState()` method simply returns `_OverlayPortalState()`. This is where the logic connecting to the actual [Overlay](01_overlay_.md) will live.

Looking at the `_OverlayPortalState` (parts shown in the file):

```dart
class _OverlayPortalState extends State<OverlayPortal> {
  int? _zOrderIndex; // Controls visibility and paint order

  // ... (methods like show, hide, didUpdateWidget, dispose) ...

  @override
  Widget build(BuildContext context) {
    final int? zOrderIndex = _zOrderIndex;
    if (zOrderIndex == null) {
      // If not showing, return a simple widget that just renders the child
      return _OverlayPortal(overlayLocation: null, overlayChild: null, child: widget.child);
    }
    // If showing, return a special widget that connects to the Overlay
    return _OverlayPortal(
      overlayLocation: _getLocation(zOrderIndex, widget._targetRootOverlay),
      overlayChild: _DeferredLayout(child: Builder(builder: widget.overlayChildBuilder)),
      child: widget.child,
    );
  }
}
```

Here, in `_OverlayPortalState`'s `build` method:

1.  It checks the `_zOrderIndex`. This private variable is controlled by the [OverlayPortalController](05_overlayportalcontroller_.md) (`show` sets it to a timestamp, `hide` sets it to null). The value of `_zOrderIndex` also determines the paint order on the [Overlay](01_overlay_.md).
2.  If `_zOrderIndex` is null (not showing), it returns a simple internal widget (`_OverlayPortal`) with `overlayChild: null`.
3.  If `_zOrderIndex` is not null (showing), it returns the `_OverlayPortal` widget again, but this time it provides an `overlayLocation` (obtained via `_getLocation`) and wraps the result of the `overlayChildBuilder` in a `_DeferredLayout` widget.

The `_OverlayPortal` widget is an internal `RenderObjectWidget` that manages the actual render object connection. `_DeferredLayout` is a key internal widget we'll touch on briefly; it's related to how the layout of the overlay child widget is handled (it's "deferred" until the [Overlay](01_overlay_.md) is ready to lay it out).

The `_getLocation` method is where the `_OverlayPortalState` finds the necessary information about the ancestor [Overlay](01_overlay_.md) by talking to an `InheritedWidget` (`_RenderTheaterMarker`).

```dart
class _RenderTheaterMarker extends InheritedWidget {
  // ... properties (theater, overlayEntryWidgetState) ...
  static _RenderTheaterMarker of(BuildContext context, {bool targetRootOverlay = false}) {
    // ... looks up the nearest or root _RenderTheaterMarker ...
    // ... returns the marker containing info about the Overlay's render objects ...
  }
}
```

This `_RenderTheaterMarker` is an `InheritedWidget` placed in the widget tree by the [OverlayState](02_overlaystate_.md) (specifically by the `_OverlayEntryWidget` which represents a single entry's content). It holds references to the key rendering objects of the [Overlay](01_overlay_.md) (`_RenderTheater`) and the specific [OverlayEntry](03_overlayentry_.md) the `OverlayPortal` is logically contained within (`_OverlayEntryWidgetState`). This mechanism allows the `_OverlayPortalState` to easily find the correct place in the render tree to insert its overlay child.

All of these internal pieces work together to take the widget from your `overlayChildBuilder` and insert its corresponding render object into the [Overlay]'s render tree (`_RenderTheater`) *at the correct paint order level relative to other [OverlayEntry](03_overlayentry_.md)s*.

### Conclusion

In this chapter, we introduced `OverlayPortal` as a more convenient way to display widgets on an [Overlay](01_overlay_.md). We learned that it allows the overlay widget to conceptually remain linked to the `OverlayPortal`'s location in the widget tree, making context inheritance simpler. We saw the basic structure of `OverlayPortal` with its `overlayChildBuilder` and optional `child`, and got a high-level understanding of how it uses internal widgets and render objects (`_OverlayPortal`, `_DeferredLayout`, `_RenderTheaterMarker`) to insert the overlay child's render object into the ancestor [Overlay](01_overlay_.md)'s `_RenderTheater`.

To actually control *when* the overlay child is shown or hidden, we need the `controller`. In the next chapter, we will explore the [OverlayPortalController](05_overlayportalcontroller_.md) and complete our context menu example.

[OverlayPortalController](05_overlayportalcontroller_.md)
---
# Chapter 5: OverlayPortalController

Welcome to Chapter 5! In our [previous chapter](04_overlayportal_.md), we were introduced to `OverlayPortal`, a special widget that lets you place a child widget onto the global [Overlay](01_overlay_.md) while still feeling connected to the `OverlayPortal`'s spot in the widget tree. We set up the `OverlayPortal` with an `overlayChildBuilder` to define our context menu widget, but we couldn't make it actually appear yet.

To control when an `OverlayPortal` shows or hides its overlay child, we need a remote control! That remote control is the **`OverlayPortalController`**.

Think of the `OverlayPortalController` as a dedicated switch for a single `OverlayPortal`. You give the controller to the `OverlayPortal`, and then you use the methods on that controller to tell the `OverlayPortal` what to do.

Our goal is still to show a small context menu right next to a button when it's tapped. The `OverlayPortalController` is the key piece that lets us trigger this action from the button's `onPressed` callback.

### What is OverlayPortalController?

An `OverlayPortalController` is a simple object that provides methods to manage the visibility and paint order of the `OverlayPortal`'s overlay child. It has three main actions:

*   **`show()`**: Makes the overlay child widget built by the `OverlayPortal`'s `overlayChildBuilder` appear on the [Overlay](01_overlay_.md). If it's already showing, calling `show()` again brings it to the very top of the overlay stack (above other things controlled by different OverlayPortals).
*   **`hide()`**: Hides the overlay child widget. It will be removed from the [Overlay](01_overlay_.md).
*   **`toggle()`**: Switches the state. If it's hidden, it shows it. If it's showing, it hides it.

It also has a property:

*   **`isShowing`**: A boolean (`true` or `false`) that tells you if the overlay child is currently visible on the [Overlay](01_overlay_.md) via this controller.

### Creating and Using an OverlayPortalController

You need to create an instance of `OverlayPortalController`. Since the controller holds the state of whether the overlay is showing or not, it should typically live in a `State` object.

```dart
// Inside a StatefulWidget's State class:
class _MyWidgetState extends State<MyWidget> {
  // Create the controller
  final OverlayPortalController _contextMenuController = OverlayPortalController();

  // Remember to dispose of the controller when the State is disposed
  @override
  void dispose() {
    _contextMenuController.dispose(); // Necessary cleanup!
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    // ... button and OverlayPortal will go here ...
    return Scaffold( // Example wrapper
      appBar: AppBar(title: const Text('Overlay Portal Example')),
      body: Center( // Center the button
        child: OverlayPortal(
          // Provide the controller to the OverlayPortal!
          controller: _contextMenuController,
          overlayChildBuilder: (BuildContext context) {
            // This is the widget that will show on the Overlay
            // We'll refine positioning later, for now a placeholder:
            Offset buttonPosition = const Offset(100, 100); // Placeholder
            return Positioned(
              top: buttonPosition.dy,
              left: buttonPosition.dx,
              child: Material(
                elevation: 4.0,
                child: Container(
                  padding: const EdgeInsets.all(8.0),
                  color: Colors.yellow[100],
                  child: const Text('Context Menu!'),
                ),
              ),
            );
          },
          // The button we tap to show/hide the menu
          child: ElevatedButton(
            onPressed: () {
              // Use the controller to toggle the menu!
              _contextMenuController.toggle();
            },
            child: const Text('Show/Hide Menu'),
          ),
        ),
      ),
    );
  }
}
```

In this code snippet:

1.  We declare a `final OverlayPortalController _contextMenuController` within our `_MyWidgetState`. It's `final` because we create the controller once.
2.  **Crucially, we call `_contextMenuController.dispose()` in the `dispose()` method of the state.** This is important cleanup to release resources when the widget and its state are removed.
3.  We pass this `_contextMenuController` to the `OverlayPortal` widget using the `controller:` property. This establishes the link between the remote control and the device.
4.  Inside the `onPressed` callback of the `ElevatedButton` (which is the `child` of the `OverlayPortal`), we simply call `_contextMenuController.toggle()`.

Now, when you tap the button, the `toggle()` method on the controller is called. The `OverlayPortal` linked to this controller sees this, and if it wasn't showing, it triggers the creation and display of the widget from its `overlayChildBuilder` onto the [Overlay](01_overlay_.md)! Tapping again calls `toggle()` again, sees it's showing, and calls `hide()`, removing the widget.

### Positioning the Overlay Child

In the example above, our context menu appears at a fixed `Positioned(top: 100, left: 100)`. This isn't very useful for a context menu that should appear next to the button that triggered it.

The `BuildContext` given to the `overlayChildBuilder` is very helpful here. It represents the context *at the location of the `OverlayPortal`*. We can use this context to find the position of the `OverlayPortal` (and thus the button, since it's its child) on the screen!

1.  We need to get the `RenderBox` of the `OverlayPortal`. We can use a `GlobalKey` for this.
2.  We can then use the `localToGlobal` method on the `RenderBox` to find its position relative to the entire screen (or the [Overlay](01_overlay_.md)).

```dart
// Inside a StatefulWidget's State class:
class _MyWidgetState extends State<MyWidget> {
  final OverlayPortalController _contextMenuController = OverlayPortalController();
  // Add a GlobalKey to get the RenderBox of the button/OverlayPortal
  final GlobalKey _buttonKey = GlobalKey();

  @override
  void dispose() {
    _contextMenuController.dispose();
    super.dispose();
  }

  void _showMenu() {
    if (_buttonKey.currentContext != null) {
      // Get the RenderBox of the widget associated with the key
      final RenderBox renderBox = _buttonKey.currentContext!.findRenderObject() as RenderBox;
      // Get the position of the *top-left* corner of the button
      final Offset buttonPosition = renderBox.localToGlobal(Offset.zero);
      // Get the size of the button
      final Size buttonSize = renderBox.size;

      // We'll need the position and size in the overlayChildBuilder
      // How to pass this info? We can store it in the State.
      // Let's update the builder to use state variables.

      // Now, tell the controller to show the overlay
      _contextMenuController.show(); // Use show instead of toggle for clearer logic
    }
  }

  // Need variables to store the button's position and size
  Offset _buttonPosition = Offset.zero;
  Size _buttonSize = Size.zero;

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(title: const Text('Overlay Portal Example')),
      body: Center(
        child: OverlayPortal(
          controller: _contextMenuController,
          overlayChildBuilder: (BuildContext context) {
            // Use the stored position and size to position the menu
            // Let's place the menu just below the button
            return Positioned(
              // Place the top of the menu at the bottom of the button
              top: _buttonPosition.dy + _buttonSize.height,
              // Align the left edge of the menu with the left edge of the button
              left: _buttonPosition.dx,
              child: Material(
                elevation: 4.0,
                child: Container(
                  padding: const EdgeInsets.all(8.0),
                  color: Colors.yellow[100],
                  child: const Text('Context Menu!'),
                ),
              ),
            );
          },
          // Wrap the child (the button) with the GlobalKey and onPressed that calls _showMenu
          child: SizedBox( // Use SizedBox to apply the key directly
            key: _buttonKey, // Attach the key here!
            child: ElevatedButton(
              onPressed: _showMenu, // Call our _showMenu function
              child: const Text('Show Menu'),
            ),
          ),
        ),
      ),
    );
  }
}
```

Now, our `_showMenu` function finds the button's position on the screen using the `_buttonKey`, stores this position and size in state variables, and then calls `_contextMenuController.show()`. The `overlayChildBuilder` then uses these state variables (`_buttonPosition` and `_buttonSize`) to calculate where to place the `Positioned` widget, making the menu appear right below the button.

To hide the menu, you'd typically add a tap detector outside the menu or a close button within the menu that calls `_contextMenuController.hide()`.

```dart
// Add this helper function to hide the menu
void _hideMenu() {
   _contextMenuController.hide();
}

// Update the overlayChildBuilder to include a GestureDetector to hide taps outside the menu
overlayChildBuilder: (BuildContext context) {
  return Stack( // Use a Stack to layer the tap catcher below the menu
    children: [
      Positioned.fill(
         // A transparent widget that catches taps outside the menu content
         child: GestureDetector(
           onTap: _hideMenu, // Hide the menu when tapped outside
           behavior: HitTestBehavior.translucent, // Ensure it catches taps
         ),
      ),
      Positioned(
         top: _buttonPosition.dy + _buttonSize.height,
         left: _buttonPosition.dx,
         child: Material(
           elevation: 4.0,
           child: Container(
             padding: const EdgeInsets.all(8.0),
             color: Colors.yellow[100],
             child: const Text('Context Menu!'),
           ),
         ),
      ),
    ],
  );
},
```

This updated `overlayChildBuilder` wraps the `Positioned` menu inside a `Stack`. A `Positioned.fill` `GestureDetector` is placed on top of the entire overlay area (filling the [Overlay](01_overlay_.md)). This transparent detector catches taps *anywhere* on the overlay that isn't blocked by the menu itself and calls `_hideMenu`, making the menu disappear when the user taps outside of it.

### How OverlayPortalController Works Internally

When you call `_contextMenuController.show()` or `_contextMenuController.hide()`:

1.  The `OverlayPortalController` communicates with the `_OverlayPortalState` object it's currently attached to.
2.  The `_OverlayPortalState` updates its internal state, specifically the `_zOrderIndex` variable. `show()` sets this to a new unique timestamp (using `_now()`), `hide()` sets it to `null`.
3.  Updating this state triggers a `setState()` call within the `_OverlayPortalState`.
4.  `setState()` tells the Flutter framework that the `_OverlayPortalState` needs to rebuild.
5.  During the rebuild, the `_OverlayPortalState`'s `build` method checks the `_zOrderIndex`:
    *   If it's `null`, it returns a version of the internal `_OverlayPortal` widget that doesn't include the overlay child (`overlayChild: null`).
    *   If it's not `null`, it returns the `_OverlayPortal` widget with the `overlayChildBuilder`'s widget included (`overlayChild: _DeferredLayout(...)`).
6.  When the framework processes this update, if the `overlayChild` has changed from `null` to a widget (or vice-versa), the corresponding render objects are attached/detached from the ancestor [Overlay]'s [_RenderTheater](07__renderdeferredlayoutbox_.md) render tree. The `_zOrderIndex` is used to determine the correct paint order.

Sequence diagram for calling `show()`:

```mermaid
sequenceDiagram
    participant YourWidget
    participant OverlayPortalController
    participant _OverlayPortalState
    participant Framework as Flutter Framework
    participant OverlayPortalBuild as OverlayPortal.build()
    participant _OverlayPortalElement
    participant _RenderTheater as Overlay Render Tree

    YourWidget->>OverlayPortalController: call show()
    OverlayPortalController->>_OverlayPortalState: update internal state (_zOrderIndex)
    _OverlayPortalState->>Framework: call setState()
    Framework->>_OverlayPortalState: schedule rebuild
    Framework->>_OverlayPortalState: call build()
    _OverlayPortalState->>OverlayPortalBuild: return Widget with overlay child
    OverlayPortalBuild->>_OverlayPortalElement: process widget update
    _OverlayPortalElement->>_RenderTheater: attach/position overlay child render object
    _RenderTheater->>_RenderTheater: paint child on overlay
```

The internal code snippets showed that `_OverlayPortalState` indeed has a `_zOrderIndex` and methods like `show` and `hide` that call `setState`. The `build` method's critical part is checking if `_zOrderIndex == null` to decide whether to include the `overlayChild`.

```dart
// From packages/flutter/lib/src/widgets/overlay.dart -> _OverlayPortalState
void show(int zOrderIndex) {
  // ... asserts ...
  setState(() {
    _zOrderIndex = zOrderIndex; // Update state triggers rebuild
  });
  // ... invalidate location cache ...
}

void hide() {
  // ... asserts ...
  setState(() {
    _zOrderIndex = null; // Update state triggers rebuild
  });
  // ... invalidate location cache ...
}

@override
Widget build(BuildContext context) {
  final int? zOrderIndex = _zOrderIndex; // Check the state variable
  if (zOrderIndex == null) {
    return _OverlayPortal(overlayLocation: null, overlayChild: null, child: widget.child);
  }
  // ... build with overlay child if zOrderIndex is not null ...
  return _OverlayPortal(
    // ...
    overlayChild: _DeferredLayout(child: Builder(builder: widget.overlayChildBuilder)),
    // ...
  );
}
```

This confirms our understanding: the `OverlayPortalController` is just a thin wrapper forwarding commands to the `_OverlayPortalState`, which manages the visibility state (`_zOrderIndex`) and rebuilds itself to reflect that state change in the widget tree structure passed to the framework. The actual attachment/detachment of the render object happens deeper within the element tree logic triggered by the `_OverlayPortal` widget.

### Conclusion

In this chapter, we completed our understanding of the `OverlayPortal` pattern by introducing the `OverlayPortalController`. We learned that this controller acts as the remote control, using its `show()`, `hide()`, and `toggle()` methods to signal to the linked `OverlayPortal` when to display or hide its overlay child. We saw how to create a controller, link it to an `OverlayPortal`, use it in a button's `onPressed`, and importantly, how to dispose of it. We also improved our context menu example by using a `GlobalKey` and the `BuildContext` to position the overlay child relative to the trigger widget. Finally, we confirmed our understanding by looking at the internal code where the controller updates the `_OverlayPortalState`'s `_zOrderIndex`, triggering a rebuild.

With `OverlayPortal` and `OverlayPortalController`, you can elegantly manage temporary widgets that appear on the global [Overlay](01_overlay_.md) while keeping them conceptually linked to their origins.

In the next chapter, we'll take a very brief look at the [_Theater](06__theater_.md) widget, which we've seen mentioned multiple times as the internal widget used by the [OverlayState](02_overlaystate_.md) to manage the display of its children.

[_Theater](06__theater_.md)
---
# Chapter 6: _Theater

Welcome back, Flutter explorers! In our [previous chapters](01_overlay_.md), we've uncovered the secrets of the [Overlay](01_overlay_.md), the [OverlayState](02_overlaystate_.md) manager, and the [OverlayEntry](03_overlayentry_.md) or [OverlayPortal](04_overlayportal_.md) which hold the actual widgets we want to show on top. We learned how to insert and remove these entries using the [OverlayState](02_overlaystate_.md) or the [OverlayPortalController](05_overlayportalcontroller_.md), causing widgets to magically appear and disappear on the screen's surface.

But how do these widgets, bundled inside their [OverlayEntry](03_overlayentry_.md)s or managed by their [OverlayPortal](04_overlayportal_.md)s, actually get placed and painted on top of the rest of the UI? Who is responsible for taking the list of active entries and arranging their widgets visually like layers on the overhead projector?

Enter the **`_Theater`**!

Think of the `_Theater` as the physical stage where all the overlay actors (your overlay widgets) perform. It's a specialized **layout engine** that the [OverlayState](02_overlaystate_.md) uses to arrange all the widgets from the active [OverlayEntry](03_overlayentry_.md)s and [OverlayPortal](04_overlayportal_.md)s. It stacks them, one on top of the other, similar to how a `Stack` widget works. The widgets are arranged from bottom to top based on their order in the list provided by the [OverlayState](02_overlaystate_.md).

Our goal throughout this tutorial has been to understand how to display widgets on top of everything. The `_Theater` is the widget *inside* the [Overlay](01_overlay_.md) that makes the final visual magic happen by taking the children (your overlay widgets) and painting them in the correct order.

### Where Does the _Theater Live?

We briefly saw the `_Theater` in the `OverlayState`'s `build` method in [Chapter 1](01_overlay_.md). Let's look at that simplified snippet again:

```dart
class OverlayState extends State<Overlay> with TickerProviderStateMixin {
  final List<OverlayEntry> _entries = <OverlayEntry>[];

  // ... methods for inserting and removing entries ...

  @protected
  @override
  Widget build(BuildContext context) {
    // ... logic to determine visible entries and create widgets ...
    final List<_OverlayEntryWidget> children = <_OverlayEntryWidget>[];
    // ... populate children based on _entries (and other logic) ...
    return _Theater(
      // ... properties like skipCount, clipBehavior ...
      children: children.reversed.toList(growable: false), // THIS IS WHERE _Theater GETS THE WIDGETS!
    );
  }

  // ... other methods
}
```

The `OverlayState` is the `State` object for the [Overlay] widget. When the [OverlayState](02_overlaystate_.md) needs to update its display (because an entry was inserted, removed, or changed), its `build` method is called.

Inside `build`, the `OverlayState` goes through its internal list of active [OverlayEntry](03_overlayentry_.md) and determines which ones should be painted. It also accounts for overlay children managed by [OverlayPortal](04_overlayportal_.md)s. For each widget that needs to be on the screen, it creates a special internal widget called `_OverlayEntryWidget`.

These `_OverlayEntryWidget`s (which in turn contain the widgets you provided in your `OverlayEntry` `builder` or `OverlayPortal` `overlayChildBuilder`) are collected into a list. **This list is then passed as the `children` to the `_Theater` widget.**

The `_Theater` is the very last widget built by the `OverlayState`. It takes all the widgets from your overlay entries and portals and arranges them within the bounds of the `Overlay`.

### _Theater's Role: Layout and Painting

The `_Theater` is a specialized version of a Flutter `Stack`. Its primary responsibilities are:

1.  **Layout:** Determining the size and position of each child widget. Like a `Stack`, children that are not `Positioned` will be laid out based on the `alignment` (which defaults to `topStart` in the `_Theater`'s internal logic, effectively aligning to the top-left unless overridden) and the available space. `Positioned` children (like the ones we used in our [OverlayPortal](04_overlayportal_.md) example context menu) use the `top`, `bottom`, `left`, `right`, `width`, and `height` properties to determine their size and location relative to the `_Theater`'s boundaries (which are the same as the `Overlay`'s boundaries).
2.  **Painting:** Painting the children one on top of the other. The `_Theater` paints its children in the order they appear in its `children` list. Since the `OverlayState` passes the list in reversed order (from top to bottom of the conceptual stack), **the `_Theater` paints the last child in its list on top.** This is how the visual stacking is achieved  the widgets that should appear highest are painted last.

The `_Theater` also has a `skipCount` property (passed from `OverlayState`). This property tells the `_Theater` to completely ignore the first `skipCount` children for both layout and painting. This is an optimization used by the `OverlayState` when there are opaque entries higher in the stack; any entries below the opaque ones can potentially be skipped if they aren't marked with `maintainState`.

```dart
// Simplified snippet from _Theater's paint method (internal Flutter code)
@override
void paint(PaintingContext context, Offset offset) {
  // Loops through children in a specific order...
  for (final RenderBox child in _childrenInPaintOrder()) {
    final StackParentData childParentData = child.parentData! as StackParentData;
    // Paints each child at its calculated offset
    context.paintChild(child, childParentData.offset + offset);
  }
}
```

This snippet from the internal `_RenderTheater` (the render object counterpart of the `_Theater` widget) shows the core painting loop. It iterates through the children in paint order (which is determined by the order received from `OverlayState`, potentially modified by `skipCount` and handling `OverlayPortal` children correctly) and calls `context.paintChild`, effectively drawing each widget onto the screen on top of the previous one.

### _Theater vs. Stack

You might wonder, why not just use a regular `Stack`? The `_Theater` is specialized for the `Overlay`'s needs:

*   **Integration with OverlayEntry and OverlayPortal Logic:** It works correctly with the internal `_OverlayEntryWidgetState` and `_OverlayEntryLocation` to handle children from both direct [OverlayEntry] insertions and [OverlayPortal]s, respecting the paint order determined by the [OverlayState] and [OverlayPortalController] `show()` calls.
*   **`skipCount` Optimization:** It supports the `skipCount` property for performance optimization with opaque entries, which a standard `Stack` does not.
*   **Semantics:** It handles the semantics tree correctly for offstage children.

So, while it lays out and paints like a `Stack`, it's specifically tuned for the way the [OverlayState] manages its children.

### Sequence Diagram: _Theater's Role in Painting

Let's visualize `_Theater`'s role during the paint phase after the `OverlayState` has rebuilt:

```mermaid
sequenceDiagram
    participant OverlayState
    participant _Theater
    participant OverlayEntryWidget as _OverlayEntryWidget (for Entry 1)
    participant OverlayEntryWidget2 as _OverlayEntryWidget (for Entry 2)
    participant OverlayChildRenderObject as RenderBox (from OverlayChild)
    participant OverlayRenderTree as Overlay Render Tree

    OverlayState->>_Theater: build(_Theater) with children list
    _Theater->>OverlayRenderTree: process children, create RenderObjects (_RenderTheater)
    OverlayRenderTree->>OverlayRenderTree: perform layout on children (like Stack)
    OverlayRenderTree->>OverlayRenderTree: start paint phase
    OverlayRenderTree->>OverlayEntryWidget: ask Widget 1 to paint
    OverlayEntryWidget->>OverlayRenderTree: paint Widget 1 at calculated position
    OverlayRenderTree->>OverlayEntryWidget2: ask Widget 2 to paint (on top of Widget 1)
    OverlayEntryWidget2->>OverlayRenderTree: paint Widget 2 at calculated position
    OverlayRenderTree->>OverlayChildRenderObject: ask OverlayPortal child to paint (on top of Widget 2)
    OverlayChildRenderObject->>OverlayRenderTree: paint OverlayPortal child
```

This diagram shows that the `_Theater` widget's render object (`_RenderTheater`) is the one performing the actual layout and painting of the children provided by the `OverlayState`. It happens after the widget tree building phase and the layout phase, where the `_RenderTheater` determines where each child render object should be drawn.

### Peek into the Code (_Theater)

Let's look at the `_Theater` widget definition itself:

```dart
class _Theater extends MultiChildRenderObjectWidget {
  const _Theater({
    this.skipCount = 0,
    this.clipBehavior = Clip.hardEdge,
    required List<_OverlayEntryWidget> super.children,
  }) : assert(skipCount >= 0),
       assert(children.length >= skipCount);

  final int skipCount;
  final Clip clipBehavior;

  @override
  _TheaterElement createElement() => _TheaterElement(this);

  @override
  _RenderTheater createRenderObject(BuildContext context) {
    return _RenderTheater( // Creates the associated RenderObject
      skipCount: skipCount,
      textDirection: Directionality.of(context),
      clipBehavior: clipBehavior,
    );
  }

  @override
  void updateRenderObject(BuildContext context, _RenderTheater renderObject) {
    renderObject // Updates the RenderObject properties
      ..skipCount = skipCount
      ..textDirection = Directionality.of(context)
      ..clipBehavior = clipBehavior;
  }
  // ... debugFillProperties ...
}
```

Key points:

*   It's a `MultiChildRenderObjectWidget`, meaning it's a widget that manages a list of children and has a single corresponding render object that manages their layout and painting.
*   It takes `skipCount` and `clipBehavior` as properties.
*   It creates a `_TheaterElement` (the intermediate element in the tree) and a `_RenderTheater` (the low-level render object). The real layout and paint logic live in the `_RenderTheater`.
*   `updateRenderObject` is used by the framework to update the properties of the existing `_RenderTheater` instance when the `_Theater` widget is rebuilt with different properties.

And a tiny peek at the `_RenderTheater`:

```dart
class _RenderTheater extends RenderBox with ContainerRenderObjectMixin<RenderBox, StackParentData>, _RenderTheaterMixin {
  // ... constructor, properties ...

  // This mixin provides common stack-like logic
  @override
  _RenderTheater get theater => this;

  // ... setupParentData, attach, detach ...

  // This method is where the actual layout of children happens
  @override
  void performLayout() {
    // ... logic similar to Stack layout ...
    // Lays out visible children based on Positioned or default alignment
  }

  // This method is where the actual painting of children happens
  @override
  void paint(PaintingContext context, Offset offset) {
     // ... iterates through children in paint order and paints them ...
  }

  // ... hitTestChildren, debug methods ...
}
```

The `_RenderTheater` extends `RenderBox` (meaning it's a box-shaped render object), uses `ContainerRenderObjectMixin` and `_RenderTheaterMixin` to get multi-child management and stack-like behavior, and overrides `performLayout` and `paint` to implement the core logic we discussed. The `_RenderTheaterMixin` provides shared logic related to handling the children, including those managed by [OverlayPortal]s.

### Conclusion

In this chapter, we demystified the `_Theater`. We learned that it is the specialized widget used internally by the [OverlayState](02_overlaystate_.md) to perform the critical task of laying out and painting the widgets from active [OverlayEntry](03_overlayentry_.md)s and [OverlayPortal](04_overlayportal_.md)s on top of each other, much like a `Stack`. We saw its key role in the `OverlayState`'s build method and got a high-level understanding of how its associated render object, `_RenderTheater`, handles the layout and painting process, including optimizations like `skipCount`.

While you rarely interact directly with `_Theater`, understanding its existence and role helps complete the picture of how the `overlay.dart` components work together to display elements on top of your UI.

In the next chapter, we'll touch upon another internal render object related to `OverlayPortal`s: [_RenderDeferredLayoutBox](07__renderdeferredlayoutbox_.md), and understand why its layout is "deferred".

[_RenderDeferredLayoutBox](07__renderdeferredlayoutbox_.md)
---
# Chapter 7: _RenderDeferredLayoutBox

Welcome to Chapter 7! In our journey through `overlay.dart`, we've learned about the central [Overlay](01_overlay_.md) that manages layers on the screen, the [OverlayState](02_overlaystate_.md) that controls those layers, the [OverlayEntry](03_overlayentry_.md) for manual layer management, the modern [OverlayPortal](04_overlayportal_.md) and its [OverlayPortalController](05_overlayportalcontroller_.md) for attaching overlays to specific widgets, and the [_Theater](06__theater_.md) which acts as the stage where all the overlay children are laid out and painted.

We saw that when using [OverlayPortal](04_overlayportal_.md), the widget you want to show on the overlay is defined in its `overlayChildBuilder`. This widget isn't placed directly in the `OverlayPortal`'s spot in the main widget tree; instead, its *corresponding render object* is attached somewhere within the [_Theater](06__theater_.md)'s render object tree.

This separation is powerful  it allows the overlay child to float on the [Overlay](01_overlay_.md) independently. However, it introduces a challenge: how do you correctly lay out the overlay child? Its size and position might depend on the size and position of the original [OverlayPortal]'s `child` (like positioning a context menu below a button). But the overlay child renders in a totally different part of the render tree ([_Theater](06__theater_.md)), and the `OverlayPortal`'s `child` renders in the main render tree. How does the overlay child know the dimensions and position it needs?

This is where the internal **`_RenderDeferredLayoutBox`** comes in.

Think of `_RenderDeferredLayoutBox` as a placeholder or a messenger box for the `OverlayPortal`'s overlay child within the [_Theater](06__theater_.md)'s render tree. When the `OverlayPortal`'s overlay child is active, the system creates the render object for that child (let's call it the "overlay child render box") and wraps it inside a `_RenderDeferredLayoutBox`. This `_RenderDeferredLayoutBox` is then placed as a child within the [_Theater](06__theater_.md)'s render object hierarchy.

The key job of the `_RenderDeferredLayoutBox` is right there in its name: it **defers** its layout. It doesn't immediately lay out the overlay child inside it when its parent ([_Theater](06__theater_.md)) asks it to. Instead, it relies on a specific signal from its "layout surrogate"  which is the render object corresponding to the `_OverlayPortal` widget back where the `OverlayPortal` lives in the main widget tree.

The goal is to ensure that the overlay child's layout, which might depend on the layout of the `OverlayPortal`'s regular `child`, only happens *after* the `OverlayPortal` and its `child` have been laid out in the main tree.

### Why is Layout Deferred?

Consider our context menu example from [Chapter 5](05_overlayportalcontroller_.md). The context menu needs to know the size and position of the button (the `OverlayPortal`'s `child`) to position itself correctly below it.

1.  The *main* render tree (where the button is) goes through its layout process. The bounds and position of the button are determined.
2.  The *overlay* render tree (the [_Theater](06__theater_.md)) goes through *its* layout process. It encounters the `_RenderDeferredLayoutBox`.
3.  If the `_RenderDeferredLayoutBox` laid out its overlay child *immediately* when requested by the [_Theater](06__theater_.md), it wouldn't have the final, accurate layout information about the button from the main tree yet! This could lead to incorrect positioning.

By deferring its layout, the `_RenderDeferredLayoutBox` waits for a signal from its "layout surrogate" back in the main tree. This surrogate (`_RenderLayoutSurrogateProxyBox`) is laid out *after* the button. Once the surrogate is laid out, it signals the `_RenderDeferredLayoutBox` in the [_Theater](06__theater_.md) to perform *its* layout. At this point, the necessary layout information from the main tree (like the button's position) is available, and the overlay child can be laid out correctly.

### How _RenderDeferredLayoutBox Works Internally

Let's trace the path of the render objects involved:

1.  Your `OverlayPortal` widget is in the main widget tree. Its `build` method (specifically the `_OverlayPortalState`'s build) returns an internal `_OverlayPortal` widget.
2.  This `_OverlayPortal` widget creates a special render object called `_RenderLayoutSurrogateProxyBox`. This is the "layout surrogate" we mentioned. It lives in the main render tree, where the `OverlayPortal` is. It acts as a placeholder and a source of layout information.
3.  If the `OverlayPortalController` is showing the overlay (`_zOrderIndex` is not null), the `_OverlayPortalState`'s build method also includes the widget from your `overlayChildBuilder` wrapped in a `_DeferredLayout` widget.
4.  The `_DeferredLayout` widget creates the `_RenderDeferredLayoutBox`. This is the render object that wraps your actual overlay child render object. It gets a reference to the `_RenderLayoutSurrogateProxyBox` (the surrogate) during its creation.
5.  This `_RenderDeferredLayoutBox` (containing your overlay child render box) is then attached directly to the [_Theater](06__theater_.md)'s render object (`_RenderTheater`) in the overlay render tree.
6.  When the `_RenderTheater` performs layout, it encounters the `_RenderDeferredLayoutBox`.
7.  The `_RenderDeferredLayoutBox`'s `performLayout` method is overridden to **do nothing immediately** when called by the [_Theater](06__theater_.md) during the usual layout phase.
8.  Later, during the layout phase for the *main* tree, the `_RenderLayoutSurrogateProxyBox` (the surrogate in the main tree) is laid out. After its own layout is complete, it explicitly calls a method on the `_RenderDeferredLayoutBox` (`layoutByLayoutSurrogate`) to tell it to **now** perform its layout.
9.  At this point, the `_RenderDeferredLayoutBox` is signaled to lay out the overlay child inside it. Because the surrogate was laid out *after* the button, the button's layout information is available (via `_buttonKey.currentContext!.findRenderObject()!.localToGlobal(Offset.zero)` in our example) and can be used by your `overlayChildBuilder` to size and position the overlay child correctly within the [_Theater](06__theater_.md)'s coordinate space.

Sequence diagram showing deferred layout:

```mermaid
sequenceDiagram
    participant MainRenderTree
    participant ButtonRenderBox
    participant OverlayPortalRender as _RenderLayoutSurrogateProxyBox
    participant OverlayRenderTree as _RenderTheater
    participant DeferredLayoutBox as _RenderDeferredLayoutBox
    participant OverlayChildRender as Your Overlay Child RenderBox

    MainRenderTree->>ButtonRenderBox: performLayout (Main)
    ButtonRenderBox->>MainRenderTree: Layout Complete
    MainRenderTree->>OverlayPortalRender: performLayout (Main)
    OverlayPortalRender->>MainRenderTree: Layout Complete
    OverlayPortalRender->>DeferredLayoutBox: call layoutByLayoutSurrogate() NOW! (Explicit Signal)

    OverlayRenderTree->>DeferredLayoutBox: performLayout (Overlay - DOES NOTHING YET)

    DeferredLayoutBox->>OverlayChildRender: performLayout (TRIGGERED BY layoutByLayoutSurrogate)
    OverlayChildRender->>DeferredLayoutBox: Layout Complete (using button position/size)
    DeferredLayoutBox->>OverlayRenderTree: Layout Complete
```

This illustrates that the layout of the `DeferredLayoutBox` (and thus your overlay child) is skipped during the [_Theater](06__theater_.md)'s initial layout pass and is triggered later by the parallel layout coming from the main tree via the `_RenderLayoutSurrogateProxyBox`.

### Peek into the Code (_RenderDeferredLayoutBox)

Let's look at the definition and some key methods of `_RenderDeferredLayoutBox`:

```dart
final class _RenderDeferredLayoutBox extends RenderProxyBox
    with _RenderTheaterMixin, LinkedListEntry<_RenderDeferredLayoutBox> {
  _RenderDeferredLayoutBox(this._layoutSurrogate); // Gets reference to the surrogate

  final _RenderLayoutSurrogateProxyBox _layoutSurrogate; // The surrogate

  // ... properties and methods ...

  @override
  void markNeedsLayout() {
    _needsLayout = true;
    // IMPORTANT: Calling super.markNeedsLayout() here, but it's overridden
    // below to *not* mark the parent dirty if _skipMarkNeedsLayout is true
    // (which it is when called from _addDeferredChild). This prevents
    // unnecessarily dirtying the _RenderTheater.
    super.markNeedsLayout();
  }

  // This is the method called explicitly by the _RenderLayoutSurrogateProxyBox
  void layoutByLayoutSurrogate() {
    // ... assertions ...
    // Get constraints from the theater and call super.layout
    super.layout(BoxConstraints.tight(boxSize));
  }

  bool _theaterDoingThisLayout = false; // Flag to detect theater-triggered layout
  @override
  void layout(Constraints constraints, {bool parentUsesSize = false}) {
    // If this method is called by the parent (_RenderTheater) during its layout...
    if (_theaterDoingThisLayout) {
       _needsLayout = false;
       return; // ... DO NOTHING FOR LAYOUT YET!
    }
    // If this method is called by layoutByLayoutSurrogate...
    _theaterDoingThisLayout = true;
    super.layout(constraints, parentUsesSize: parentUsesSize); // Perform layout!
    _theaterDoingThisLayout = false;
    // ... schedule another layout update *later* if needed.
    // This looks counter-intuitive but is part of the double buffering/deferral.
    // See the code's comments about PipelineOwner.flushLayout.
    parent! as _RenderTheater.invokeLayoutCallback((BoxConstraints constraints) {
      markNeedsLayout(); // Schedule a future layout pass
    });
  }

  @override
  void performLayout() {
     // This is ONLY called when laid out by layoutByLayoutSurrogate
     // Get constraints, lay out the actual child inside this box.
     layoutChild(child!, constraints);
     _needsLayout = false;
  }

  // ... other overrides ...
}
```

This snippet highlights:

*   The `_RenderDeferredLayoutBox` receives its `_layoutSurrogate` in its constructor.
*   `markNeedsLayout` is overridden to avoid marking the [_Theater](06__theater_.md) dirty directly in some cases.
*   `layoutByLayoutSurrogate` is the public method called by the surrogate to trigger the layout. It gets the constraints from the [_Theater](06__theater_.md) and calls the *standard* `layout` method (`super.layout`).
*   The main `layout` method is overridden. It uses the `_theaterDoingThisLayout` flag to determine *who* is calling it. If it's the [_Theater](06__theater_.md) (`_theaterDoingThisLayout` is false initially), it does minimal work and returns. If it's called by `layoutByLayoutSurrogate` (`_theaterDoingThisLayout` is true), it proceeds to call `super.layout` (which then calls `performLayout`).
*   The `performLayout` method is where the *actual* layout of the overlay child inside the `_RenderDeferredLayoutBox` happens. This method is now only reached when triggered by `layoutByLayoutSurrogate`.

This complex dance ensures that the overlay child's layout (which might depend on the main tree) happens *after* the relevant parts of the main tree are laid out, but still integrates correctly within the overlay's render tree managed by the [_Theater](06__theater_.md).

You can also see the `_RenderLayoutSurrogateProxyBox` has a `_deferredLayoutChild` property and calls `_deferredLayoutChild.layoutByLayoutSurrogate()` in its own `performLayout`.

```dart
// From _RenderLayoutSurrogateProxyBox
@override
void performLayout() {
  super.performLayout(); // Lays out its own static child (if any)
  // Now that we are laid out, tell the deferred child to layout
  _deferredLayoutChild?.layoutByLayoutSurrogate();
}
```

This confirms the surrogate's role in triggering the deferred layout.

### Conclusion

In this chapter, we dug into the inner workings of `_RenderDeferredLayoutBox`, a crucial internal render object used by [OverlayPortal](04_overlayportal_.md). We learned that its purpose is to wrap the rendero bject of the overlay child and deliberately **defer** its layout. This deferral is necessary to ensure the overlay child is laid out *after* the relevant parts of the main widget tree (like the [OverlayPortal](04_overlayportal_.md)'s `child`) have their layout finalized, allowing for correct positioning relative to the originating widget. We saw how it works in conjunction with the `_RenderLayoutSurrogateProxyBox` in the main tree to receive an explicit layout signal, bypassing the [_Theater](06__theater_.md)'s initial layout pass for that child.

Understanding `_RenderDeferredLayoutBox` helps complete the picture of how [OverlayPortal](04_overlayportal_.md) manages to seamlessly integrate an overlay widget into the global [Overlay](01_overlay_.md) while maintaining a conceptual link to its origin point in the main UI.

In the final chapter, we will briefly look at `_OverlayEntryLocation
`, another internal helper related to how [OverlayPortal](04_overlayportal_.md) finds its place within the [Overlay](01_overlay_.md).

[_OverlayEntryLocation](08__overlayentrylocation_.md)

Relevant Code Snippets (Code itself remains unchanged):
--- File: packages/flutter/lib/src/widgets/overlay.dart ---
// Copyright 2014 The Flutter Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

/// @docImport 'package:flutter/cupertino.dart';
/// @docImport 'package:flutter/material.dart';
///
/// @docImport 'app.dart';
/// @docImport 'drag_target.dart';
/// @docImport 'implicit_animations.dart';
/// @docImport 'media_query.dart';
/// @docImport 'navigator.dart';
/// @docImport 'routes.dart';
/// @docImport 'scroll_view.dart';
/// @docImport 'sliver.dart';
/// @docImport 'text.dart';
library;

import 'dart:collection';

import 'package:flutter/foundation.dart';
import 'package:flutter/rendering.dart';
import 'package:flutter/scheduler.dart';

import 'basic.dart';
import 'framework.dart';
import 'lookup_boundary.dart';
import 'ticker_provider.dart';

const String _flutterWidgetsLibrary = 'package:flutter/widgets.dart';

// Examples can assume:
// late BuildContext context;

// * OverlayEntry Implementation

/// A place in an [Overlay] that can contain a widget.
///
/// Overlay entries are inserted into an [Overlay] using the
/// [OverlayState.insert] or [OverlayState.insertAll] functions. To find the
/// closest enclosing overlay for a given [BuildContext], use the [Overlay.of]
/// function.
///
/// An overlay entry can be in at most one overlay at a time. To remove an entry
/// from its overlay, call the [remove] function on the overlay entry.
///
/// Because an [Overlay] uses a [Stack] layout, overlay entries can use
/// [Positioned] and [AnimatedPositioned] to position themselves within the
/// overlay.
///
/// For example, [Draggable] uses an [OverlayEntry] to show the drag avatar that
/// follows the user's finger across the screen after the drag begins. Using the
/// overlay to display the drag avatar lets the avatar float over the other
/// widgets in the app. As the user's finger moves, draggable calls
/// [markNeedsBuild] on the overlay entry to cause it to rebuild. In its build,
/// the entry includes a [Positioned] with its top and left property set to
/// position the drag avatar near the user's finger. When the drag is over,
/// [Draggable] removes the entry from the overlay to remove the drag avatar
/// from view.
///
/// By default, if there is an entirely [opaque] entry over this one, then this
/// one will not be included in the widget tree (in particular, stateful widgets
/// within the overlay entry will not be instantiated). To ensure that your
/// overlay entry is still built even if it is not visible, set [maintainState]
/// to true. This is more expensive, so should be done with care. In particular,
/// if widgets in an overlay entry with [maintainState] set to true repeatedly
/// call [State.setState], the user's battery will be drained unnecessarily.
///
/// [OverlayEntry] is a [Listenable] that notifies when the widget built by
/// [builder] is mounted or unmounted, whose exact state can be queried by
/// [mounted]. After the owner of the [OverlayEntry] calls [remove] and then
/// [dispose], the widget may not be immediately removed from the widget tree.
/// As a result listeners of the [OverlayEntry] can get notified for one last
/// time after the [dispose] call, when the widget is eventually unmounted.
///
/// {@macro flutter.widgets.overlayPortalVsOverlayEntry}
///
/// See also:
///
///  * [OverlayPortal], an alternative API for inserting widgets into an
///    [Overlay] using a builder callback.
///  * [Overlay], a stack of entries that can be managed independently.
///  * [OverlayState], the current state of an Overlay.
///  * [WidgetsApp], a convenience widget that wraps a number of widgets that
///    are commonly required for an application.
///  * [MaterialApp], a convenience widget that wraps a number of widgets that
///    are commonly required for Material Design applications.
class OverlayEntry implements Listenable {
  /// Creates an overlay entry.
  ///
  /// To insert the entry into an [Overlay], first find the overlay using
  /// [Overlay.of] and then call [OverlayState.insert]. To remove the entry,
  /// call [remove] on the overlay entry itself.
  OverlayEntry({
    required this.builder,
    bool opaque = false,
    bool maintainState = false,
    this.canSizeOverlay = false,
  }) : _opaque = opaque,
       _maintainState = maintainState {
    if (kFlutterMemoryAllocationsEnabled) {
      _maybeDispatchObjectCreation();
    }
  }

  /// This entry will include the widget built by this builder in the overlay at
  /// the entry's position.
  ///
  /// To cause this builder to be called again, call [markNeedsBuild] on this
  /// overlay entry.
  final WidgetBuilder builder;

  /// Whether this entry occludes the entire overlay.
  ///
  /// If an entry claims to be opaque, then, for efficiency, the overlay will
  /// skip building entries below that entry unless they have [maintainState]
  /// set.
  bool get opaque => _opaque;
  bool _opaque;
  set opaque(bool value) {
    assert(!_disposedByOwner);
    if (_opaque == value) {
      return;
    }
    _opaque = value;
    _overlay?._didChangeEntryOpacity();
  }

  /// Whether this entry must be included in the tree even if there is a fully
  /// [opaque] entry above it.
  ///
  /// By default, if there is an entirely [opaque] entry over this one, then this
  /// one will not be included in the widget tree (in particular, stateful widgets
  /// within the overlay entry will not be instantiated). To ensure that your
  /// overlay entry is still built even if it is not visible, set [maintainState]
  /// to true. This is more expensive, so should be done with care. In particular,
  /// if widgets in an overlay entry with [maintainState] set to true repeatedly
  /// call [State.setState], the user's battery will be drained unnecessarily.
  ///
  /// This is used by the [Navigator] and [Route] objects to ensure that routes
  /// are kept around even when in the background, so that [Future]s promised
  /// from subsequent routes will be handled properly when they complete.
  bool get maintainState => _maintainState;
  bool _maintainState;
  set maintainState(bool value) {
    assert(!_disposedByOwner);
    if (_maintainState == value) {
      return;
    }
    _maintainState = value;
    assert(_overlay != null);
    _overlay!._didChangeEntryOpacity();
  }

  /// Whether the content of this [OverlayEntry] can be used to size the
  /// [Overlay].
  ///
  /// In most situations the overlay sizes itself based on its incoming
  /// constraints to be as large as possible. However, if that would result in
  /// an infinite size, it has to rely on one of its children to size itself. In
  /// this situation, the overlay will consult the topmost non-[Positioned]
  /// overlay entry that has this property set to true, lay it out with the
  /// incoming [BoxConstraints] of the overlay, and force all other
  /// non-[Positioned] overlay entries to have the same size. The [Positioned]
  /// entries are laid out as usual based on the calculated size of the overlay.
  ///
  /// Overlay entries that set this to true must be able to handle unconstrained
  /// [BoxConstraints].
  ///
  /// Setting this to true has no effect if the overlay entry uses a [Positioned]
  /// widget to position itself in the overlay.
  final bool canSizeOverlay;

  /// Whether the [OverlayEntry] is currently mounted in the widget tree.
  ///
  /// The [OverlayEntry] notifies its listeners when this value changes.
  bool get mounted => _overlayEntryStateNotifier?.value != null;

  /// The currently mounted `_OverlayEntryWidgetState` built using this [OverlayEntry].
  ValueNotifier<_OverlayEntryWidgetState?>? _overlayEntryStateNotifier =
      ValueNotifier<_OverlayEntryWidgetState?>(null);

  // TODO(polina-c): stop duplicating code across disposables
  // https://github.com/flutter/flutter/issues/137435
  /// Dispatches event of object creation to [FlutterMemoryAllocations.instance].
  void _maybeDispatchObjectCreation() {
    if (kFlutterMemoryAllocationsEnabled) {
      FlutterMemoryAllocations.instance.dispatchObjectCreated(
        library: _flutterWidgetsLibrary,
        className: '$OverlayEntry',
        object: this,
      );
    }
  }

  @override
  void addListener(VoidCallback listener) {
    assert(!_disposedByOwner);
    _overlayEntryStateNotifier?.addListener(listener);
  }

  @override
  void removeListener(VoidCallback listener) {
    _overlayEntryStateNotifier?.removeListener(listener);
  }

  OverlayState? _overlay;
  final GlobalKey<_OverlayEntryWidgetState> _key = GlobalKey<_OverlayEntryWidgetState>();

  /// Remove this entry from the overlay.
  ///
  /// This should only be called once.
  ///
  /// This method removes this overlay entry from the overlay immediately. The
  /// UI will be updated in the same frame if this method is called before the
  /// overlay rebuild in this frame; otherwise, the UI will be updated in the
  /// next frame. This means that it is safe to call during builds, but also
  /// that if you do call this after the overlay rebuild, the UI will not update
  /// until the next frame (i.e. many milliseconds later).
  void remove() {
    assert(_overlay != null);
    assert(!_disposedByOwner);
    final OverlayState overlay = _overlay!;
    _overlay = null;
    if (!overlay.mounted) {
      return;
    }

    overlay._entries.remove(this);
    if (SchedulerBinding.instance.schedulerPhase == SchedulerPhase.persistentCallbacks) {
      SchedulerBinding.instance.addPostFrameCallback((Duration duration) {
        overlay._markDirty();
      }, debugLabel: 'OverlayEntry.markDirty');
    } else {
      overlay._markDirty();
    }
  }

  /// Cause this entry to rebuild during the next pipeline flush.
  ///
  /// You need to call this function if the output of [builder] has changed.
  void markNeedsBuild() {
    assert(!_disposedByOwner);
    _key.currentState?._markNeedsBuild();
  }

  void _didUnmount() {
    assert(!mounted);
    if (_disposedByOwner) {
      _overlayEntryStateNotifier?.dispose();
      _overlayEntryStateNotifier = null;
    }
  }

  bool _disposedByOwner = false;

  /// Discards any resources used by this [OverlayEntry].
  ///
  /// This method must be called after [remove] if the [OverlayEntry] is
  /// inserted into an [Overlay].
  ///
  /// After this is called, the object is not in a usable state and should be
  /// discarded (calls to [addListener] will throw after the object is disposed).
  /// However, the listeners registered may not be immediately released until
  /// the widget built using this [OverlayEntry] is unmounted from the widget
  /// tree.
  ///
  /// This method should only be called by the object's owner.
  void dispose() {
    assert(!_disposedByOwner);
    assert(
      _overlay == null,
      'An OverlayEntry must first be removed from the Overlay before dispose is called.',
    );
    if (kFlutterMemoryAllocationsEnabled) {
      FlutterMemoryAllocations.instance.dispatchObjectDisposed(object: this);
    }
    _disposedByOwner = true;
    if (!mounted) {
      // If we're still mounted when disposed, then this will be disposed in
      // _didUnmount, to allow notifications to occur until the entry is
      // unmounted.
      _overlayEntryStateNotifier?.dispose();
      _overlayEntryStateNotifier = null;
    }
  }

  @override
  String toString() =>
      '${describeIdentity(this)}(opaque: $opaque; maintainState: $maintainState)${_disposedByOwner ? "(DISPOSED)" : ""}';
}

class _OverlayEntryWidget extends StatefulWidget {
  const _OverlayEntryWidget({
    required Key super.key,
    required this.entry,
    required this.overlayState,
    this.tickerEnabled = true,
  });

  final OverlayEntry entry;
  final OverlayState overlayState;
  final bool tickerEnabled;

  @override
  _OverlayEntryWidgetState createState() => _OverlayEntryWidgetState();
}

class _OverlayEntryWidgetState extends State<_OverlayEntryWidget> {
  late _RenderTheater _theater;

  // Manages the stack of theater children whose paint order are sorted by their
  // _zOrderIndex. The children added by OverlayPortal are added to this linked
  // list, and they will be shown _above_ the OverlayEntry tied to this widget.
  // The children with larger zOrderIndex values (i.e. those called `show`
  // recently) will be painted last.
  //
  // This linked list is lazily created in `_add`, and the entries are added/removed
  // via `_add`/`_remove`, called by OverlayPortals lower in the tree. `_add` or
  // `_remove` does not cause this widget to rebuild, the linked list will be
  // read by _RenderTheater as part of its render child model. This would ideally
  // be in a RenderObject but there may not be RenderObjects between
  // _RenderTheater and the render subtree OverlayEntry builds.
  LinkedList<_OverlayEntryLocation>? _sortedTheaterSiblings;

  // Worst-case O(N), N being the number of children added to the top spot in
  // the same frame. This can be a bit expensive when there's a lot of global
  // key reparenting in the same frame but N is usually a small number.
  void _add(_OverlayEntryLocation child) {
    assert(mounted);
    final LinkedList<_OverlayEntryLocation> children =
        _sortedTheaterSiblings ??= LinkedList<_OverlayEntryLocation>();
    assert(!children.contains(child));
    _OverlayEntryLocation? insertPosition = children.isEmpty ? null : children.last;
    while (insertPosition != null && insertPosition._zOrderIndex > child._zOrderIndex) {
      insertPosition = insertPosition.previous;
    }
    if (insertPosition == null) {
      children.addFirst(child);
    } else {
      insertPosition.insertAfter(child);
    }
    assert(children.contains(child));
  }

  void _remove(_OverlayEntryLocation child) {
    assert(_sortedTheaterSiblings != null);
    final bool wasInCollection = _sortedTheaterSiblings?.remove(child) ?? false;
    assert(wasInCollection);
  }

  // Returns an Iterable that traverse the children in the child model in paint
  // order (from farthest to the user to the closest to the user).
  //
  // The iterator should be safe to use even when the child model is being
  // mutated. The reason for that is it's allowed to add/remove/move deferred
  // children to a _RenderTheater during performLayout, but the affected
  // children don't have to be laid out in the same performLayout call.
  late final Iterable<RenderBox> _paintOrderIterable = _createChildIterable(reversed: false);
  // An Iterable that traverse the children in the child model in
  // hit-test order (from closest to the user to the farthest to the user).
  late final Iterable<RenderBox> _hitTestOrderIterable = _createChildIterable(reversed: true);

  // The following uses sync* because hit-testing is lazy, and LinkedList as a
  // Iterable doesn't support concurrent modification.
  Iterable<RenderBox> _createChildIterable({required bool reversed}) sync* {
    final LinkedList<_OverlayEntryLocation>? children = _sortedTheaterSiblings;
    if (children == null || children.isEmpty) {
      return;
    }
    _OverlayEntryLocation? candidate = reversed ? children.last : children.first;
    while (candidate != null) {
      final RenderBox? renderBox = candidate._overlayChildRenderBox;
      candidate = reversed ? candidate.previous : candidate.next;
      if (renderBox != null) {
        yield renderBox;
      }
    }
  }

  @override
  void initState() {
    super.initState();
    widget.entry._overlayEntryStateNotifier!.value = this;
    _theater = context.findAncestorRenderObjectOfType<_RenderTheater>()!;
    assert(_sortedTheaterSiblings == null);
  }

  @override
  void didUpdateWidget(_OverlayEntryWidget oldWidget) {
    super.didUpdateWidget(oldWidget);
    // OverlayState's build method always returns a RenderObjectWidget _Theater,
    // so it's safe to assume that state equality implies render object equality.
    assert(oldWidget.entry == widget.entry);
    if (oldWidget.overlayState != widget.overlayState) {
      final _RenderTheater newTheater = context.findAncestorRenderObjectOfType<_RenderTheater>()!;
      assert(_theater != newTheater);
      _theater = newTheater;
    }
  }

  @override
  void dispose() {
    widget.entry._overlayEntryStateNotifier?.value = null;
    widget.entry._didUnmount();
    _sortedTheaterSiblings = null;
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    return TickerMode(
      enabled: widget.tickerEnabled,
      child: _RenderTheaterMarker(
        theater: _theater,
        overlayEntryWidgetState: this,
        child: widget.entry.builder(context),
      ),
    );
  }

  void _markNeedsBuild() {
    setState(() {
      /* the state that changed is in the builder */
    });
  }
}

/// A stack of entries that can be managed independently.
///
/// Overlays let independent child widgets "float" visual elements on top of
/// other widgets by inserting them into the overlay's stack. The overlay lets
/// each of these widgets manage their participation in the overlay using
/// [OverlayEntry] objects.
///
/// Although you can create an [Overlay] directly, it's most common to use the
/// overlay created by the [Navigator] in a [WidgetsApp], [CupertinoApp] or a
/// [MaterialApp]. The navigator uses its overlay to manage the visual
/// appearance of its routes.
///
/// The [Overlay] widget uses a custom stack implementation, which is very
/// similar to the [Stack] widget. The main use case of [Overlay] is related to
/// navigation and being able to insert widgets on top of the pages in an app.
/// For layout purposes unrelated to navigation, consider using [Stack] instead.
///
/// An [Overlay] widget requires a [Directionality] widget to be in scope, so
/// that it can resolve direction-sensitive coordinates of any
/// [Positioned.directional] children.
///
/// For widgets drawn in an [OverlayEntry], do not assume that the size of the
/// [Overlay] is the size returned by [MediaQuery.sizeOf]. Nested overlays can
/// have different sizes.
///
/// {@tool dartpad}
/// This example shows how to use the [Overlay] to highlight the [NavigationBar]
/// destination.
///
/// ** See code in examples/api/lib/widgets/overlay/overlay.0.dart **
/// {@end-tool}
///
/// See also:
///
///  * [OverlayEntry], the class that is used for describing the overlay entries.
///  * [OverlayState], which is used to insert the entries into the overlay.
///  * [WidgetsApp], which inserts an [Overlay] widget indirectly via its [Navigator].
///  * [MaterialApp], which inserts an [Overlay] widget indirectly via its [Navigator].
///  * [CupertinoApp], which inserts an [Overlay] widget indirectly via its [Navigator].
///  * [Stack], which allows directly displaying a stack of widgets.
class Overlay extends StatefulWidget {
  /// Creates an overlay.
  ///
  /// The initial entries will be inserted into the overlay when its associated
  /// [OverlayState] is initialized.
  ///
  /// Rather than creating an overlay, consider using the overlay that is
  /// created by the [Navigator] in a [WidgetsApp], [CupertinoApp], or a
  /// [MaterialApp] for the application.
  const Overlay({
    super.key,
    this.initialEntries = const <OverlayEntry>[],
    this.clipBehavior = Clip.hardEdge,
  });

  /// Wrap the provided `child` in an [Overlay] to allow other visual elements
  /// (packed in [OverlayEntry]s) to float on top of the child.
  ///
  /// This is a convenience method over the regular [Overlay] constructor: It
  /// creates an [Overlay] and puts the provided `child` in an [OverlayEntry]
  /// at the bottom of that newly created Overlay.
  static Widget wrap({Key? key, Clip clipBehavior = Clip.hardEdge, required Widget child}) {
    return _WrappingOverlay(key: key, clipBehavior: clipBehavior, child: child);
  }

  /// The entries to include in the overlay initially.
  ///
  /// These entries are only used when the [OverlayState] is initialized. If you
  /// are providing a new [Overlay] description for an overlay that's already in
  /// the tree, then the new entries are ignored.
  ///
  /// To add entries to an [Overlay] that is already in the tree, use
  /// [Overlay.of] to obtain the [OverlayState] (or assign a [GlobalKey] to the
  /// [Overlay] widget and obtain the [OverlayState] via
  /// [GlobalKey.currentState]), and then use [OverlayState.insert] or
  /// [OverlayState.insertAll].
  ///
  /// To remove an entry from an [Overlay], use [OverlayEntry.remove].
  final List<OverlayEntry> initialEntries;

  /// {@macro flutter.material.Material.clipBehavior}
  ///
  /// Defaults to [Clip.hardEdge].
  final Clip clipBehavior;

  /// The [OverlayState] from the closest instance of [Overlay] that encloses
  /// the given context within the closest [LookupBoundary], and, in debug mode,
  /// will throw if one is not found.
  ///
  /// In debug mode, if the `debugRequiredFor` argument is provided and an
  /// overlay isn't found, then this function will throw an exception containing
  /// the runtime type of the given widget in the error message. The exception
  /// attempts to explain that the calling [Widget] (the one given by the
  /// `debugRequiredFor` argument) needs an [Overlay] to be present to function.
  /// If `debugRequiredFor` is not supplied, then the error message is more
  /// generic.
  ///
  /// Typical usage is as follows:
  ///
  /// ```dart
  /// OverlayState overlay = Overlay.of(context);
  /// ```
  ///
  /// If `rootOverlay` is set to true, the state from the furthest instance of
  /// this class is given instead. Useful for installing overlay entries above
  /// all subsequent instances of [Overlay].
  ///
  /// This method can be expensive (it walks the element tree).
  ///
  /// See also:
  ///
  /// * [Overlay.maybeOf] for a similar function that returns null if an
  ///   [Overlay] is not found.
  static OverlayState of(
    BuildContext context, {
    bool rootOverlay = false,
    Widget? debugRequiredFor,
  }) {
    final OverlayState? result = maybeOf(context, rootOverlay: rootOverlay);
    assert(() {
      if (result == null) {
        final bool hiddenByBoundary = LookupBoundary.debugIsHidingAncestorStateOfType<OverlayState>(
          context,
        );
        final List<DiagnosticsNode> information = <DiagnosticsNode>[
          ErrorSummary(
            'No Overlay widget found${hiddenByBoundary ? ' within the closest LookupBoundary' : ''}.',
          ),
          if (hiddenByBoundary)
            ErrorDescription(
              'There is an ancestor Overlay widget, but it is hidden by a LookupBoundary.',
            ),
          ErrorDescription(
            '${debugRequiredFor?.runtimeType ?? 'Some'} widgets require an Overlay widget ancestor for correct operation.',
          ),
          ErrorHint(
            'The most common way to add an Overlay to an application is to include a MaterialApp, CupertinoApp or Navigator widget in the runApp() call.',
          ),
          if (debugRequiredFor != null)
            DiagnosticsProperty<Widget>(
              'The specific widget that failed to find an overlay was',
              debugRequiredFor,
              style: DiagnosticsTreeStyle.errorProperty,
            ),
          if (context.widget != debugRequiredFor)
            context.describeElement(
              'The context from which that widget was searching for an overlay was',
            ),
        ];

        throw FlutterError.fromParts(information);
      }
      return true;
    }());
    return result!;
  }

  /// The [OverlayState] from the closest instance of [Overlay] that encloses
  /// the given context within the closest [LookupBoundary], if any.
  ///
  /// Typical usage is as follows:
  ///
  /// ```dart
  /// OverlayState? overlay = Overlay.maybeOf(context);
  /// ```
  ///
  /// If `rootOverlay` is set to true, the state from the furthest instance of
  /// this class is given instead. Useful for installing overlay entries above
  /// all subsequent instances of [Overlay].
  ///
  /// This method can be expensive (it walks the element tree).
  ///
  /// See also:
  ///
  ///  * [Overlay.of] for a similar function that returns a non-nullable result
  ///    and throws if an [Overlay] is not found.

  static OverlayState? maybeOf(BuildContext context, {bool rootOverlay = false}) {
    return rootOverlay
        ? LookupBoundary.findRootAncestorStateOfType<OverlayState>(context)
        : LookupBoundary.findAncestorStateOfType<OverlayState>(context);
  }

  @override
  OverlayState createState() => OverlayState();
}

/// The current state of an [Overlay].
///
/// Used to insert [OverlayEntry]s into the overlay using the [insert] and
/// [insertAll] functions.
class OverlayState extends State<Overlay> with TickerProviderStateMixin {
  final List<OverlayEntry> _entries = <OverlayEntry>[];

  @protected
  @override
  void initState() {
    super.initState();
    insertAll(widget.initialEntries);
  }

  int _insertionIndex(OverlayEntry? below, OverlayEntry? above) {
    assert(above == null || below == null);
    if (below != null) {
      return _entries.indexOf(below);
    }
    if (above != null) {
      return _entries.indexOf(above) + 1;
    }
    return _entries.length;
  }

  bool _debugCanInsertEntry(OverlayEntry entry) {
    final List<DiagnosticsNode> operandsInformation = <DiagnosticsNode>[
      DiagnosticsProperty<OverlayEntry>(
        'The OverlayEntry was',
        entry,
        style: DiagnosticsTreeStyle.errorProperty,
      ),
      DiagnosticsProperty<OverlayState>(
        'The Overlay the OverlayEntry was trying to insert to was',
        this,
        style: DiagnosticsTreeStyle.errorProperty,
      ),
    ];

    if (!mounted) {
      throw FlutterError.fromParts(<DiagnosticsNode>[
        ErrorSummary('Attempted to insert an OverlayEntry to an already disposed Overlay.'),
        ...operandsInformation,
      ]);
    }

    final OverlayState? currentOverlay = entry._overlay;
    final bool alreadyContainsEntry = _entries.contains(entry);

    if (alreadyContainsEntry) {
      final bool inconsistentOverlayState = !identical(currentOverlay, this);
      throw FlutterError.fromParts(<DiagnosticsNode>[
        ErrorSummary('The specified entry is already present in the target Overlay.'),
        ...operandsInformation,
        if (inconsistentOverlayState)
          ErrorHint('This could be an error in the Flutter framework.')
        else
          ErrorHint(
            'Consider calling remove on the OverlayEntry before inserting it to a different Overlay, '
            'or switching to the OverlayPortal API to avoid manual OverlayEntry management.',
          ),
        if (inconsistentOverlayState)
          DiagnosticsProperty<OverlayState>(
            "The OverlayEntry's current Overlay was",
            currentOverlay,
            style: DiagnosticsTreeStyle.errorProperty,
          ),
      ]);
    }

    if (currentOverlay == null) {
      return true;
    }

    throw FlutterError.fromParts(<DiagnosticsNode>[
      ErrorSummary('The specified entry is already present in a different Overlay.'),
      ...operandsInformation,
      DiagnosticsProperty<OverlayState>(
        "The OverlayEntry's current Overlay was",
        currentOverlay,
        style: DiagnosticsTreeStyle.errorProperty,
      ),
      ErrorHint(
        'Consider calling remove on the OverlayEntry before inserting it to a different Overlay, '
        'or switching to the OverlayPortal API to avoid manual OverlayEntry management.',
      ),
    ]);
  }

  /// Insert the given entry into the overlay.
  ///
  /// If `below` is non-null, the entry is inserted just below `below`.
  /// If `above` is non-null, the entry is inserted just above `above`.
  /// Otherwise, the entry is inserted on top.
  ///
  /// It is an error to specify both `above` and `below`.
  void insert(OverlayEntry entry, {OverlayEntry? below, OverlayEntry? above}) {
    assert(_debugVerifyInsertPosition(above, below));
    assert(_debugCanInsertEntry(entry));
    entry._overlay = this;
    setState(() {
      _entries.insert(_insertionIndex(below, above), entry);
    });
  }

  /// Insert all the entries in the given iterable.
  ///
  /// If `below` is non-null, the entries are inserted just below `below`.
  /// If `above` is non-null, the entries are inserted just above `above`.
  /// Otherwise, the entries are inserted on top.
  ///
  /// It is an error to specify both `above` and `below`.
  void insertAll(Iterable<OverlayEntry> entries, {OverlayEntry? below, OverlayEntry? above}) {
    assert(_debugVerifyInsertPosition(above, below));
    assert(entries.every(_debugCanInsertEntry));
    if (entries.isEmpty) {
      return;
    }
    for (final OverlayEntry entry in entries) {
      assert(entry._overlay == null);
      entry._overlay = this;
    }
    setState(() {
      _entries.insertAll(_insertionIndex(below, above), entries);
    });
  }

  bool _debugVerifyInsertPosition(
    OverlayEntry? above,
    OverlayEntry? below, {
    Iterable<OverlayEntry>? newEntries,
  }) {
    assert(above == null || below == null, 'Only one of `above` and `below` may be specified.');
    assert(
      above == null ||
          (above._overlay == this &&
              _entries.contains(above) &&
              (newEntries?.contains(above) ?? true)),
      'The provided entry used for `above` must be present in the Overlay${newEntries != null ? ' and in the `newEntriesList`' : ''}.',
    );
    assert(
      below == null ||
          (below._overlay == this &&
              _entries.contains(below) &&
              (newEntries?.contains(below) ?? true)),
      'The provided entry used for `below` must be present in the Overlay${newEntries != null ? ' and in the `newEntriesList`' : ''}.',
    );
    return true;
  }

  /// Remove all the entries listed in the given iterable, then reinsert them
  /// into the overlay in the given order.
  ///
  /// Entries mention in `newEntries` but absent from the overlay are inserted
  /// as if with [insertAll].
  ///
  /// Entries not mentioned in `newEntries` but present in the overlay are
  /// positioned as a group in the resulting list relative to the entries that
  /// were moved, as specified by one of `below` or `above`, which, if
  /// specified, must be one of the entries in `newEntries`:
  ///
  /// If `below` is non-null, the group is positioned just below `below`.
  /// If `above` is non-null, the group is positioned just above `above`.
  /// Otherwise, the group is left on top, with all the rearranged entries
  /// below.
  ///
  /// It is an error to specify both `above` and `below`.
  void rearrange(Iterable<OverlayEntry> newEntries, {OverlayEntry? below, OverlayEntry? above}) {
    final List<OverlayEntry> newEntriesList =
        newEntries is List<OverlayEntry> ? newEntries : newEntries.toList(growable: false);
    assert(_debugVerifyInsertPosition(above, below, newEntries: newEntriesList));
    assert(
      newEntriesList.every(
        (OverlayEntry entry) => entry._overlay == null || entry._overlay == this,
      ),
      'One or more of the specified entries are already present in another Overlay.',
    );
    assert(
      newEntriesList.every(
        (OverlayEntry entry) => _entries.indexOf(entry) == _entries.lastIndexOf(entry),
      ),
      'One or more of the specified entries are specified multiple times.',
    );
    if (newEntriesList.isEmpty) {
      return;
    }
    if (listEquals(_entries, newEntriesList)) {
      return;
    }
    final LinkedHashSet<OverlayEntry> old = LinkedHashSet<OverlayEntry>.of(_entries);
    for (final OverlayEntry entry in newEntriesList) {
      entry._overlay ??= this;
    }
    setState(() {
      _entries.clear();
      _entries.addAll(newEntriesList);
      old.removeAll(newEntriesList);
      _entries.insertAll(_insertionIndex(below, above), old);
    });
  }

  void _markDirty() {
    if (mounted) {
      setState(() {});
    }
  }

  /// (DEBUG ONLY) Check whether a given entry is visible (i.e., not behind an
  /// opaque entry).
  ///
  /// This is an O(N) algorithm, and should not be necessary except for debug
  /// asserts. To avoid people depending on it, this function is implemented
  /// only in debug mode, and always returns false in release mode.
  bool debugIsVisible(OverlayEntry entry) {
    bool result = false;
    assert(_entries.contains(entry));
    assert(() {
      for (int i = _entries.length - 1; i > 0; i -= 1) {
        final OverlayEntry candidate = _entries[i];
        if (candidate == entry) {
          result = true;
          break;
        }
        if (candidate.opaque) {
          break;
        }
      }
      return true;
    }());
    return result;
  }

  void _didChangeEntryOpacity() {
    setState(() {
      // We use the opacity of the entry in our build function, which means we
      // our state has changed.
    });
  }

  @protected
  @override
  Widget build(BuildContext context) {
    // This list is filled backwards and then reversed below before
    // it is added to the tree.
    final List<_OverlayEntryWidget> children = <_OverlayEntryWidget>[];
    bool onstage = true;
    int onstageCount = 0;
    for (final OverlayEntry entry in _entries.reversed) {
      if (onstage) {
        onstageCount += 1;
        children.add(_OverlayEntryWidget(key: entry._key, overlayState: this, entry: entry));
        if (entry.opaque) {
          onstage = false;
        }
      } else if (entry.maintainState) {
        children.add(
          _OverlayEntryWidget(
            key: entry._key,
            overlayState: this,
            entry: entry,
            tickerEnabled: false,
          ),
        );
      }
    }
    return _Theater(
      skipCount: children.length - onstageCount,
      clipBehavior: widget.clipBehavior,
      children: children.reversed.toList(growable: false),
    );
  }

  @protected
  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    // TODO(jacobr): use IterableProperty instead as that would
    // provide a slightly more consistent string summary of the List.
    properties.add(DiagnosticsProperty<List<OverlayEntry>>('entries', _entries));
  }
}

class _WrappingOverlay extends StatefulWidget {
  const _WrappingOverlay({super.key, this.clipBehavior = Clip.hardEdge, required this.child});

  final Clip clipBehavior;
  final Widget child;

  @override
  State<_WrappingOverlay> createState() => _WrappingOverlayState();
}

class _WrappingOverlayState extends State<_WrappingOverlay> {
  late final OverlayEntry _entry = OverlayEntry(
    canSizeOverlay: true,
    opaque: true,
    builder: (BuildContext context) {
      return widget.child;
    },
  );

  @override
  void didUpdateWidget(_WrappingOverlay oldWidget) {
    super.didUpdateWidget(oldWidget);
    _entry.markNeedsBuild();
  }

  @override
  void dispose() {
    _entry
      ..remove()
      ..dispose();
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    return Overlay(clipBehavior: widget.clipBehavior, initialEntries: <OverlayEntry>[_entry]);
  }
}

/// Special version of a [Stack], that doesn't layout and render the first
/// [skipCount] children.
///
/// The first [skipCount] children are considered "offstage".
class _Theater extends MultiChildRenderObjectWidget {
  const _Theater({
    this.skipCount = 0,
    this.clipBehavior = Clip.hardEdge,
    required List<_OverlayEntryWidget> super.children,
  }) : assert(skipCount >= 0),
       assert(children.length >= skipCount);

  final int skipCount;

  final Clip clipBehavior;

  @override
  _TheaterElement createElement() => _TheaterElement(this);

  @override
  _RenderTheater createRenderObject(BuildContext context) {
    return _RenderTheater(
      skipCount: skipCount,
      textDirection: Directionality.of(context),
      clipBehavior: clipBehavior,
    );
  }

  @override
  void updateRenderObject(BuildContext context, _RenderTheater renderObject) {
    renderObject
      ..skipCount = skipCount
      ..textDirection = Directionality.of(context)
      ..clipBehavior = clipBehavior;
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties.add(IntProperty('skipCount', skipCount));
  }
}

class _TheaterElement extends MultiChildRenderObjectElement {
  _TheaterElement(_Theater super.widget);

  @override
  _RenderTheater get renderObject => super.renderObject as _RenderTheater;

  @override
  void insertRenderObjectChild(RenderBox child, IndexedSlot<Element?> slot) {
    super.insertRenderObjectChild(child, slot);
    final _TheaterParentData parentData = child.parentData! as _TheaterParentData;
    parentData.overlayEntry =
        ((widget as _Theater).children[slot.index] as _OverlayEntryWidget).entry;
    assert(parentData.overlayEntry != null);
  }

  @override
  void moveRenderObjectChild(
    RenderBox child,
    IndexedSlot<Element?> oldSlot,
    IndexedSlot<Element?> newSlot,
  ) {
    super.moveRenderObjectChild(child, oldSlot, newSlot);
    assert(() {
      final _TheaterParentData parentData = child.parentData! as _TheaterParentData;
      return parentData.overlayEntry ==
          ((widget as _Theater).children[newSlot.index] as _OverlayEntryWidget).entry;
    }());
  }

  @override
  void debugVisitOnstageChildren(ElementVisitor visitor) {
    final _Theater theater = widget as _Theater;
    assert(children.length >= theater.skipCount);
    children.skip(theater.skipCount).forEach(visitor);
  }
}

// A `RenderBox` that sizes itself to its parent's size, implements the stack
// layout algorithm and renders its children in the given `theater`.
mixin _RenderTheaterMixin on RenderBox {
  _RenderTheater get theater;

  Iterable<RenderBox> _childrenInPaintOrder();
  Iterable<RenderBox> _childrenInHitTestOrder();

  @override
  void setupParentData(RenderBox child) {
    if (child.parentData is! StackParentData) {
      child.parentData = StackParentData();
    }
  }

  @override
  double? computeDistanceToActualBaseline(TextBaseline baseline) {
    assert(!debugNeedsLayout);
    BaselineOffset baselineOffset = BaselineOffset.noBaseline;
    for (final RenderBox child in _childrenInPaintOrder()) {
      assert(!child.debugNeedsLayout);
      final StackParentData childParentData = child.parentData! as StackParentData;
      baselineOffset = baselineOffset.minOf(
        BaselineOffset(child.getDistanceToActualBaseline(baseline)) + childParentData.offset.dy,
      );
    }
    return baselineOffset.offset;
  }

  static double? baselineForChild(
    RenderBox child,
    Size theaterSize,
    BoxConstraints nonPositionedChildConstraints,
    Alignment alignment,
    TextBaseline baseline,
  ) {
    final StackParentData childParentData = child.parentData! as StackParentData;
    final BoxConstraints childConstraints =
        childParentData.isPositioned
            ? childParentData.positionedChildConstraints(theaterSize)
            : nonPositionedChildConstraints;
    final double? baselineOffset = child.getDryBaseline(childConstraints, baseline);
    if (baselineOffset == null) {
      return null;
    }
    final double y = switch (childParentData) {
      StackParentData(:final double top?) => top,
      StackParentData(:final double bottom?) =>
        theaterSize.height - bottom - child.getDryLayout(childConstraints).height,
      StackParentData() =>
        alignment.alongOffset(theaterSize - child.getDryLayout(childConstraints) as Offset).dy,
    };
    return baselineOffset + y;
  }

  void layoutChild(RenderBox child, BoxConstraints nonPositionedChildConstraints) {
    final StackParentData childParentData = child.parentData! as StackParentData;
    final Alignment alignment = theater._resolvedAlignment;
    if (!childParentData.isPositioned) {
      child.layout(nonPositionedChildConstraints, parentUsesSize: true);
      childParentData.offset = Offset.zero;
    } else {
      assert(
        child is! _RenderDeferredLayoutBox,
        'all _RenderDeferredLayoutBoxes must be non-positioned children.',
      );
      RenderStack.layoutPositionedChild(child, childParentData, size, alignment);
    }
    assert(child.parentData == childParentData);
  }

  @override
  bool hitTestChildren(BoxHitTestResult result, {required Offset position}) {
    final Iterator<RenderBox> iterator = _childrenInHitTestOrder().iterator;
    bool isHit = false;
    while (!isHit && iterator.moveNext()) {
      final RenderBox child = iterator.current;
      final StackParentData childParentData = child.parentData! as StackParentData;
      final RenderBox localChild = child;
      bool childHitTest(BoxHitTestResult result, Offset position) =>
          localChild.hitTest(result, position: position);
      isHit = result.addWithPaintOffset(
        offset: childParentData.offset,
        position: position,
        hitTest: childHitTest,
      );
    }
    return isHit;
  }

  @override
  void paint(PaintingContext context, Offset offset) {
    for (final RenderBox child in _childrenInPaintOrder()) {
      final StackParentData childParentData = child.parentData! as StackParentData;
      context.paintChild(child, childParentData.offset + offset);
    }
  }
}

class _TheaterParentData extends StackParentData {
  // The OverlayEntry that directly created this child. This field is null for
  // children that are created by an OverlayPortal.
  OverlayEntry? overlayEntry;

  /// A [OverlayPortal] makes its overlay child a render child of an ancestor
  /// [Overlay]. Currently, to make sure the overlay child is painted after its
  /// [OverlayPortal], and before the next [OverlayEntry] (which could be
  /// something that should obstruct the overlay child, such as a [ModalRoute])
  /// in the host [Overlay], the paint order of each overlay child is managed by
  /// the [OverlayEntry] that hosts its [OverlayPortal].
  ///
  /// The following methods are exposed to allow easy access to the overlay
  /// children's render objects whose order is managed by [overlayEntry], in the
  /// right order.

  // _overlayStateMounted is set to null in _OverlayEntryWidgetState's dispose
  // method. This property is only accessed during layout, paint and hit-test so
  // the `value!` should be safe.
  Iterator<RenderBox>? get paintOrderIterator =>
      overlayEntry?._overlayEntryStateNotifier?.value!._paintOrderIterable.iterator;
  Iterator<RenderBox>? get hitTestOrderIterator =>
      overlayEntry?._overlayEntryStateNotifier?.value!._hitTestOrderIterable.iterator;

  // A convenience method for traversing `paintOrderIterator` with a
  // [RenderObjectVisitor].
  void visitOverlayPortalChildrenOnOverlayEntry(RenderObjectVisitor visitor) =>
      overlayEntry?._overlayEntryStateNotifier?.value!._paintOrderIterable.forEach(visitor);
}

class _RenderTheater extends RenderBox
    with ContainerRenderObjectMixin<RenderBox, StackParentData>, _RenderTheaterMixin {
  _RenderTheater({
    List<RenderBox>? children,
    required TextDirection textDirection,
    int skipCount = 0,
    Clip clipBehavior = Clip.hardEdge,
  }) : assert(skipCount >= 0),
       _textDirection = textDirection,
       _skipCount = skipCount,
       _clipBehavior = clipBehavior {
    addAll(children);
  }

  @override
  _RenderTheater get theater => this;

  @override
  void setupParentData(RenderBox child) {
    if (child.parentData is! _TheaterParentData) {
      child.parentData = _TheaterParentData();
    }
  }

  @override
  void attach(PipelineOwner owner) {
    super.attach(owner);
    RenderBox? child = firstChild;
    while (child != null) {
      final _TheaterParentData childParentData = child.parentData! as _TheaterParentData;
      final Iterator<RenderBox>? iterator = childParentData.paintOrderIterator;
      if (iterator != null) {
        while (iterator.moveNext()) {
          iterator.current.attach(owner);
        }
      }
      child = childParentData.nextSibling;
    }
  }

  static void _detachChild(RenderObject child) => child.detach();

  @override
  void detach() {
    super.detach();
    RenderBox? child = firstChild;
    while (child != null) {
      final _TheaterParentData childParentData = child.parentData! as _TheaterParentData;
      childParentData.visitOverlayPortalChildrenOnOverlayEntry(_detachChild);
      child = childParentData.nextSibling;
    }
  }

  @override
  void redepthChildren() => visitChildren(redepthChild);

  Alignment? _alignmentCache;
  Alignment get _resolvedAlignment =>
      _alignmentCache ??= AlignmentDirectional.topStart.resolve(textDirection);

  void _markNeedResolution() {
    _alignmentCache = null;
    markNeedsLayout();
  }

  TextDirection get textDirection => _textDirection;
  TextDirection _textDirection;
  set textDirection(TextDirection value) {
    if (_textDirection == value) {
      return;
    }
    _textDirection = value;
    _markNeedResolution();
  }

  int get skipCount => _skipCount;
  int _skipCount;
  set skipCount(int value) {
    if (_skipCount != value) {
      _skipCount = value;
      markNeedsLayout();
    }
  }

  /// {@macro flutter.material.Material.clipBehavior}
  ///
  /// Defaults to [Clip.hardEdge].
  Clip get clipBehavior => _clipBehavior;
  Clip _clipBehavior = Clip.hardEdge;
  set clipBehavior(Clip value) {
    if (value != _clipBehavior) {
      _clipBehavior = value;
      markNeedsPaint();
      markNeedsSemanticsUpdate();
    }
  }

  // Adding/removing deferred child does not affect the layout of other children,
  // or that of the Overlay, so there's no need to invalidate the layout of the
  // Overlay.
  //
  // When _skipMarkNeedsLayout is true, markNeedsLayout does not do anything.
  bool _skipMarkNeedsLayout = false;
  void _addDeferredChild(_RenderDeferredLayoutBox child) {
    assert(!_skipMarkNeedsLayout);
    _skipMarkNeedsLayout = true;
    adoptChild(child);
    // The Overlay still needs repainting when a deferred child is added. Usually
    // `markNeedsLayout` implies `markNeedsPaint`, but here `markNeedsLayout` is
    // skipped when the `_skipMarkNeedsLayout` flag is set.
    markNeedsPaint();
    _skipMarkNeedsLayout = false;

    // After adding `child` to the render tree, we want to make sure it will be
    // laid out in the same frame. This is done by calling markNeedsLayout on the
    // layout surrogate. This ensures `child` is reachable via tree walk (see
    // _RenderLayoutSurrogateProxyBox.performLayout).
    child._layoutSurrogate.markNeedsLayout();
  }

  void _removeDeferredChild(_RenderDeferredLayoutBox child) {
    assert(!_skipMarkNeedsLayout);
    _skipMarkNeedsLayout = true;
    dropChild(child);
    // The Overlay still needs repainting when a deferred child is dropped. See
    // the comment in `_addDeferredChild`.
    markNeedsPaint();
    _skipMarkNeedsLayout = false;
  }

  @override
  void markNeedsLayout() {
    if (!_skipMarkNeedsLayout) {
      super.markNeedsLayout();
    }
  }

  RenderBox? get _firstOnstageChild {
    if (skipCount == super.childCount) {
      return null;
    }
    RenderBox? child = super.firstChild;
    for (int toSkip = skipCount; toSkip > 0; toSkip--) {
      final StackParentData childParentData = child!.parentData! as StackParentData;
      child = childParentData.nextSibling;
      assert(child != null);
    }
    return child;
  }

  RenderBox? get _lastOnstageChild => skipCount == super.childCount ? null : lastChild;

  @override
  double computeMinIntrinsicWidth(double height) {
    return RenderStack.getIntrinsicDimension(
      _firstOnstageChild,
      (RenderBox child) => child.getMinIntrinsicWidth(height),
    );
  }

  @override
  double computeMaxIntrinsicWidth(double height) {
    return RenderStack.getIntrinsicDimension(
      _firstOnstageChild,
      (RenderBox child) => child.getMaxIntrinsicWidth(height),
    );
  }

  @override
  double computeMinIntrinsicHeight(double width) {
    return RenderStack.getIntrinsicDimension(
      _firstOnstageChild,
      (RenderBox child) => child.getMinIntrinsicHeight(width),
    );
  }

  @override
  double computeMaxIntrinsicHeight(double width) {
    return RenderStack.getIntrinsicDimension(
      _firstOnstageChild,
      (RenderBox child) => child.getMaxIntrinsicHeight(width),
    );
  }

  @override
  double? computeDryBaseline(BoxConstraints constraints, TextBaseline baseline) {
    final Size size =
        constraints.biggest.isFinite
            ? constraints.biggest
            : _findSizeDeterminingChild().getDryLayout(constraints);
    final BoxConstraints nonPositionedChildConstraints = BoxConstraints.tight(size);
    final Alignment alignment = theater._resolvedAlignment;

    BaselineOffset baselineOffset = BaselineOffset.noBaseline;
    for (final RenderBox child in _childrenInPaintOrder()) {
      baselineOffset = baselineOffset.minOf(
        BaselineOffset(
          _RenderTheaterMixin.baselineForChild(
            child,
            size,
            nonPositionedChildConstraints,
            alignment,
            baseline,
          ),
        ),
      );
    }
    return baselineOffset.offset;
  }

  @override
  Size computeDryLayout(BoxConstraints constraints) {
    if (constraints.biggest.isFinite) {
      return constraints.biggest;
    }
    return _findSizeDeterminingChild().getDryLayout(constraints);
  }

  @override
  // The following uses sync* because concurrent modifications should be allowed
  // during layout.
  Iterable<RenderBox> _childrenInPaintOrder() sync* {
    RenderBox? child = _firstOnstageChild;
    while (child != null) {
      yield child;
      final _TheaterParentData childParentData = child.parentData! as _TheaterParentData;
      final Iterator<RenderBox>? innerIterator = childParentData.paintOrderIterator;
      if (innerIterator != null) {
        while (innerIterator.moveNext()) {
          yield innerIterator.current;
        }
      }
      child = childParentData.nextSibling;
    }
  }

  @override
  // The following uses sync* because hit testing should be lazy.
  Iterable<RenderBox> _childrenInHitTestOrder() sync* {
    RenderBox? child = _lastOnstageChild;
    int childLeft = childCount - skipCount;
    while (child != null) {
      final _TheaterParentData childParentData = child.parentData! as _TheaterParentData;
      final Iterator<RenderBox>? innerIterator = childParentData.hitTestOrderIterator;
      if (innerIterator != null) {
        while (innerIterator.moveNext()) {
          yield innerIterator.current;
        }
      }
      yield child;
      childLeft -= 1;
      child = childLeft <= 0 ? null : childParentData.previousSibling;
    }
  }

  @override
  bool get sizedByParent => false;

  bool _layingOutSizeDeterminingChild = false;
  @override
  void performLayout() {
    RenderBox? sizeDeterminingChild;
    if (constraints.biggest.isFinite) {
      size = constraints.biggest;
    } else {
      sizeDeterminingChild = _findSizeDeterminingChild();
      _layingOutSizeDeterminingChild = true;
      layoutChild(sizeDeterminingChild, constraints);
      _layingOutSizeDeterminingChild = false;
      size = sizeDeterminingChild.size;
    }

    // Equivalent to BoxConstraints used by RenderStack for StackFit.expand.
    final BoxConstraints nonPositionedChildConstraints = BoxConstraints.tight(size);
    for (final RenderBox child in _childrenInPaintOrder()) {
      if (child != sizeDeterminingChild) {
        layoutChild(child, nonPositionedChildConstraints);
      }
    }
  }

  RenderBox _findSizeDeterminingChild() {
    RenderBox? child = _lastOnstageChild;
    while (child != null) {
      final _TheaterParentData childParentData = child.parentData! as _TheaterParentData;
      if ((childParentData.overlayEntry?.canSizeOverlay ?? false) &&
          !childParentData.isPositioned) {
        return child;
      }
      child = childParentData.previousSibling;
    }
    throw FlutterError.fromParts(<DiagnosticsNode>[
      ErrorSummary(
        'Overlay was given infinite constraints and cannot be sized by a suitable child.',
      ),
      ErrorDescription(
        'The constraints given to the overlay ($constraints) would result in an illegal '
        'infinite size (${constraints.biggest}). To avoid that, the Overlay tried to size '
        'itself to one of its children, but no suitable non-positioned child that belongs to an '
        'OverlayEntry with canSizeOverlay set to true could be found.',
      ),
      ErrorHint(
        'Try wrapping the Overlay in a SizedBox to give it a finite size or '
        'use an OverlayEntry with canSizeOverlay set to true.',
      ),
    ]);
  }

  final LayerHandle<ClipRectLayer> _clipRectLayer = LayerHandle<ClipRectLayer>();

  @override
  void paint(PaintingContext context, Offset offset) {
    if (clipBehavior != Clip.none) {
      _clipRectLayer.layer = context.pushClipRect(
        needsCompositing,
        offset,
        Offset.zero & size,
        super.paint,
        clipBehavior: clipBehavior,
        oldLayer: _clipRectLayer.layer,
      );
    } else {
      _clipRectLayer.layer = null;
      super.paint(context, offset);
    }
  }

  @override
  void dispose() {
    _clipRectLayer.layer = null;
    super.dispose();
  }

  @override
  void visitChildren(RenderObjectVisitor visitor) {
    RenderBox? child = firstChild;
    while (child != null) {
      visitor(child);
      final _TheaterParentData childParentData = child.parentData! as _TheaterParentData;
      childParentData.visitOverlayPortalChildrenOnOverlayEntry(visitor);
      child = childParentData.nextSibling;
    }
  }

  @override
  void visitChildrenForSemantics(RenderObjectVisitor visitor) {
    RenderBox? child = _firstOnstageChild;
    while (child != null) {
      visitor(child);
      final _TheaterParentData childParentData = child.parentData! as _TheaterParentData;
      child = childParentData.nextSibling;
    }
  }

  @override
  Rect? describeApproximatePaintClip(RenderObject child) {
    switch (clipBehavior) {
      case Clip.none:
        return null;
      case Clip.hardEdge:
      case Clip.antiAlias:
      case Clip.antiAliasWithSaveLayer:
        return Offset.zero & size;
    }
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties.add(IntProperty('skipCount', skipCount));
    properties.add(EnumProperty<TextDirection>('textDirection', textDirection));
  }

  @override
  List<DiagnosticsNode> debugDescribeChildren() {
    final List<DiagnosticsNode> offstageChildren = <DiagnosticsNode>[];
    final List<DiagnosticsNode> onstageChildren = <DiagnosticsNode>[];

    int count = 1;
    bool onstage = false;
    RenderBox? child = firstChild;
    final RenderBox? firstOnstageChild = _firstOnstageChild;
    while (child != null) {
      final _TheaterParentData childParentData = child.parentData! as _TheaterParentData;
      if (child == firstOnstageChild) {
        onstage = true;
        count = 1;
      }

      if (onstage) {
        onstageChildren.add(child.toDiagnosticsNode(name: 'onstage $count'));
      } else {
        offstageChildren.add(
          child.toDiagnosticsNode(name: 'offstage $count', style: DiagnosticsTreeStyle.offstage),
        );
      }

      int subcount = 1;
      childParentData.visitOverlayPortalChildrenOnOverlayEntry((RenderObject renderObject) {
        final RenderBox child = renderObject as RenderBox;
        if (onstage) {
          onstageChildren.add(child.toDiagnosticsNode(name: 'onstage $count - $subcount'));
        } else {
          offstageChildren.add(
            child.toDiagnosticsNode(
              name: 'offstage $count - $subcount',
              style: DiagnosticsTreeStyle.offstage,
            ),
          );
        }
        subcount += 1;
      });

      child = childParentData.nextSibling;
      count += 1;
    }

    return <DiagnosticsNode>[
      ...onstageChildren,
      if (offstageChildren.isNotEmpty)
        ...offstageChildren
      else
        DiagnosticsNode.message('no offstage children', style: DiagnosticsTreeStyle.offstage),
    ];
  }
}

// * OverlayPortal Implementation
//  OverlayPortal is inspired by the
//  [flutter_portal](https://pub.dev/packages/flutter_portal) package.
//
// ** RenderObject hierarchy
// The widget works by inserting its overlay child's render subtree directly
// under [Overlay]'s render object (_RenderTheater).
// https://user-images.githubusercontent.com/31859944/171971838-62ed3975-4b5d-4733-a9c9-f79e263b8fcc.jpg
//
// To ensure the overlay child render subtree does not do layout twice, the
// subtree must only perform layout after both its _RenderTheater and the
// [OverlayPortal]'s render object (_RenderLayoutSurrogateProxyBox) have
// finished layout. This is handled by _RenderDeferredLayoutBox.
//
// ** Z-Index of an overlay child
// [_OverlayEntryLocation] is a (currently private) interface that allows an
// [OverlayPortal] to insert its overlay child into a specific [Overlay], as
// well as specifying the paint order between the overlay child and other
// children of the _RenderTheater.
//
// Since [OverlayPortal] is only allowed to target ancestor [Overlay]s
// (_RenderTheater must finish doing layout before _RenderDeferredLayoutBox),
// the _RenderTheater should typically be acquired using an [InheritedWidget]
// (currently, _RenderTheaterMarker) in case the [OverlayPortal] gets
// reparented.

/// A class to show, hide and bring to top an [OverlayPortal]'s overlay child
/// in the target [Overlay].
///
/// A [OverlayPortalController] can only be given to at most one [OverlayPortal]
/// at a time. When an [OverlayPortalController] is moved from one
/// [OverlayPortal] to another, its [isShowing] state does not carry over.
///
/// [OverlayPortalController.show] and [OverlayPortalController.hide] can be
/// called even before the controller is assigned to any [OverlayPortal], but
/// they typically should not be called while the widget tree is being rebuilt.
class OverlayPortalController {
  /// Creates an [OverlayPortalController], optionally with a String identifier
  /// `debugLabel`.
  OverlayPortalController({String? debugLabel}) : _debugLabel = debugLabel;

  _OverlayPortalState? _attachTarget;

  // A separate _zOrderIndex to allow `show()` or `hide()` to be called when the
  // controller is not yet attached. Once this controller is attached,
  // _attachTarget._zOrderIndex will be used as the source of truth, and this
  // variable will be set to null.
  int? _zOrderIndex;
  final String? _debugLabel;

  static int _wallTime =
      kIsWeb
          ? -9007199254740992 // -2^53
          : -1 << 63;

  // Returns a unique and monotonically increasing timestamp that represents
  // now.
  //
  // The value this method returns increments after each call.
  int _now() {
    final int now = _wallTime += 1;
    assert(_zOrderIndex == null || _zOrderIndex! < now);
    assert(_attachTarget?._zOrderIndex == null || _attachTarget!._zOrderIndex! < now);
    return now;
  }

  /// Show the overlay child of the [OverlayPortal] this controller is attached
  /// to, at the top of the target [Overlay].
  ///
  /// When there are more than one [OverlayPortal]s that target the same
  /// [Overlay], the overlay child of the last [OverlayPortal] to have called
  /// [show] appears at the top level, unobstructed.
  ///
  /// If [isShowing] is already true, calling this method brings the overlay
  /// child it controls to the top.
  ///
  /// This method should typically not be called while the widget tree is being
  /// rebuilt.
  void show() {
    final _OverlayPortalState? state = _attachTarget;
    if (state != null) {
      state.show(_now());
    } else {
      _zOrderIndex = _now();
    }
  }

  /// Hide the [OverlayPortal]'s overlay child.
  ///
  /// Once hidden, the overlay child will be removed from the widget tree the
  /// next time the widget tree rebuilds, and stateful widgets in the overlay
  /// child may lose states as a result.
  ///
  /// This method should typically not be called while the widget tree is being
  /// rebuilt.
  void hide() {
    final _OverlayPortalState? state = _attachTarget;
    if (state != null) {
      state.hide();
    } else {
      assert(_zOrderIndex != null);
      _zOrderIndex = null;
    }
  }

  /// Whether the associated [OverlayPortal] should build and show its overlay
  /// child, using its `overlayChildBuilder`.
  bool get isShowing {
    final _OverlayPortalState? state = _attachTarget;
    return state != null ? state._zOrderIndex != null : _zOrderIndex != null;
  }

  /// Convenience method for toggling the current [isShowing] status.
  ///
  /// This method should typically not be called while the widget tree is being
  /// rebuilt.
  void toggle() => isShowing ? hide() : show();

  @override
  String toString() {
    final String? debugLabel = _debugLabel;
    final String label = debugLabel == null ? '' : '($debugLabel)';
    final String isDetached = _attachTarget != null ? '' : ' DETACHED';
    return '${objectRuntimeType(this, 'OverlayPortalController')}$label$isDetached';
  }
}

/// A widget that renders its overlay child on an [Overlay].
///
/// The overlay child is initially hidden until [OverlayPortalController.show]
/// is called on the associated [controller]. The [OverlayPortal] uses
/// [overlayChildBuilder] to build its overlay child and renders it on the
/// specified [Overlay] as if it was inserted using an [OverlayEntry], while it
/// can depend on the same set of [InheritedWidget]s (such as [Theme]) that this
/// widget can depend on.
///
/// This widget requires an [Overlay] ancestor in the widget tree when its
/// overlay child is showing. The overlay child is rendered by the [Overlay]
/// ancestor, not by the widget itself. This allows the overlay child to float
/// above other widgets, independent of its position in the widget tree.
///
/// When [OverlayPortalController.hide] is called, the widget built using
/// [overlayChildBuilder] will be removed from the widget tree the next time the
/// widget rebuilds. Stateful descendants in the overlay child subtree may lose
/// states as a result.
///
/// {@tool dartpad}
/// This example uses an [OverlayPortal] to build a tooltip that becomes visible
/// when the user taps on the [child] widget. There's a [DefaultTextStyle] above
/// the [OverlayPortal] controlling the [TextStyle] of both the [child] widget
/// and the widget [overlayChildBuilder] builds, which isn't otherwise doable if
/// the tooltip was added as an [OverlayEntry].
///
/// ** See code in examples/api/lib/widgets/overlay/overlay_portal.0.dart **
/// {@end-tool}
///
/// ### Paint Order
///
/// In an [Overlay], an overlay child is painted after the [OverlayEntry]
/// associated with its [OverlayPortal] (that is, the [OverlayEntry] closest to
/// the [OverlayPortal] in the widget tree, which usually represents the
/// enclosing [Route]), and before the next [OverlayEntry].
///
/// When an [OverlayEntry] has multiple associated [OverlayPortal]s, the paint
/// order between their overlay children is the order in which
/// [OverlayPortalController.show] was called. The last [OverlayPortal] to have
/// called `show` gets to paint its overlay child in the foreground.
///
/// ### Semantics
///
/// The semantics subtree generated by the overlay child is considered attached
/// to [OverlayPortal] instead of the target [Overlay]. An [OverlayPortal]'s
/// semantics subtree can be dropped from the semantics tree due to invisibility
/// while the overlay child is still visible (for example, when the
/// [OverlayPortal] is completely invisible in a [ListView] but kept alive by
/// a [KeepAlive] widget). When this happens the semantics subtree generated by
/// the overlay child is also dropped, even if the overlay child is still visible
/// on screen.
///
/// {@template flutter.widgets.overlayPortalVsOverlayEntry}
/// ### Differences between [OverlayPortal] and [OverlayEntry]
///
/// The main difference between [OverlayEntry] and [OverlayPortal] is that
/// [OverlayEntry] builds its widget subtree as a child of the target [Overlay],
/// while [OverlayPortal] uses [OverlayPortal.overlayChildBuilder] to build a
/// child widget of itself. This allows [OverlayPortal]'s overlay child to depend
/// on the same set of [InheritedWidget]s as [OverlayPortal], and it's also
/// guaranteed that the overlay child will not outlive its [OverlayPortal].
///
/// On the other hand, [OverlayPortal]'s implementation is more complex. For
/// instance, it does a bit more work than a regular widget during global key
/// reparenting. If the content to be shown on the [Overlay] doesn't benefit
/// from being a part of [OverlayPortal]'s subtree, consider using an
/// [OverlayEntry] instead.
/// {@endtemplate}
///
/// See also:
///
///  * [OverlayEntry], an alternative API for inserting widgets into an
///    [Overlay].
///  * [Positioned], which can be used to size and position the overlay child in
///    relation to the target [Overlay]'s boundaries.
///  * [CompositedTransformFollower], which can be used to position the overlay
///    child in relation to the linked [CompositedTransformTarget] widget.
class OverlayPortal extends StatefulWidget {
  /// Creates an [OverlayPortal] that renders the widget [overlayChildBuilder]
  /// builds on the closest [Overlay] when [OverlayPortalController.show] is
  /// called.
  const OverlayPortal({
    super.key,
    required this.controller,
    required this.overlayChildBuilder,
    this.child,
  }) : _targetRootOverlay = false;

  /// Creates an [OverlayPortal] that renders the widget [overlayChildBuilder]
  /// builds on the root [Overlay] when [OverlayPortalController.show] is
  /// called.
  const OverlayPortal.targetsRootOverlay({
    super.key,
    required this.controller,
    required this.overlayChildBuilder,
    this.child,
  }) : _targetRootOverlay = true;

  /// The controller to show, hide and bring to top the overlay child.
  final OverlayPortalController controller;

  /// A [WidgetBuilder] used to build a widget below this widget in the tree,
  /// that renders on the closest [Overlay].
  ///
  /// The said widget will only be built and shown in the closest [Overlay] once
  /// [OverlayPortalController.show] is called on the associated [controller].
  /// It will be painted in front of the [OverlayEntry] closest to this widget
  /// in the widget tree (which is usually the enclosing [Route]).
  ///
  /// The built overlay child widget is inserted below this widget in the widget
  /// tree, allowing it to depend on [InheritedWidget]s above it, and be
  /// notified when the [InheritedWidget]s change.
  ///
  /// Unlike [child], the built overlay child can visually extend outside the
  /// bounds of this widget without being clipped, and receive hit-test events
  /// outside of this widget's bounds, as long as it does not extend outside of
  /// the [Overlay] on which it is rendered.
  final WidgetBuilder overlayChildBuilder;

  /// A widget below this widget in the tree.
  final Widget? child;

  final bool _targetRootOverlay;

  @override
  State<OverlayPortal> createState() => _OverlayPortalState();
}

class _OverlayPortalState extends State<OverlayPortal> {
  int? _zOrderIndex;
  // The location of the overlay child within the overlay. This object will be
  // used as the slot of the overlay child widget.
  //
  // The developer must call `show` to reveal the overlay so we can get a unique
  // timestamp of the user interaction for determining the z-index of the
  // overlay child in the overlay.
  //
  // Avoid invalidating the cache if possible, since the framework uses `==` to
  // compare slots, and _OverlayEntryLocation can't override that operator since
  // it's mutable. Changing slots can be relatively slow.
  bool _childModelMayHaveChanged = true;
  _OverlayEntryLocation? _locationCache;
  static bool _isTheSameLocation(_OverlayEntryLocation locationCache, _RenderTheaterMarker marker) {
    return locationCache._childModel == marker.overlayEntryWidgetState &&
        locationCache._theater == marker.theater;
  }

  _OverlayEntryLocation _getLocation(int zOrderIndex, bool targetRootOverlay) {
    final _OverlayEntryLocation? cachedLocation = _locationCache;
    late final _RenderTheaterMarker marker = _RenderTheaterMarker.of(
      context,
      targetRootOverlay: targetRootOverlay,
    );
    final bool isCacheValid =
        cachedLocation != null &&
        (!_childModelMayHaveChanged || _isTheSameLocation(cachedLocation, marker));
    _childModelMayHaveChanged = false;
    if (isCacheValid) {
      assert(cachedLocation._zOrderIndex == zOrderIndex);
      assert(cachedLocation._debugIsLocationValid());
      return cachedLocation;
    }
    // Otherwise invalidate the cache and create a new location.
    cachedLocation?._debugMarkLocationInvalid();
    final _OverlayEntryLocation newLocation = _OverlayEntryLocation(
      zOrderIndex,
      marker.overlayEntryWidgetState,
      marker.theater,
    );
    assert(newLocation._zOrderIndex == zOrderIndex);
    return _locationCache = newLocation;
  }

  @override
  void initState() {
    super.initState();
    _setupController(widget.controller);
  }

  void _setupController(OverlayPortalController controller) {
    assert(
      controller._attachTarget == null || controller._attachTarget == this,
      'Failed to attach $controller to $this. It is already attached to ${controller._attachTarget}.',
    );
    final int? controllerZOrderIndex = controller._zOrderIndex;
    final int? zOrderIndex = _zOrderIndex;
    if (zOrderIndex == null ||
        (controllerZOrderIndex != null && controllerZOrderIndex > zOrderIndex)) {
      _zOrderIndex = controllerZOrderIndex;
    }
    controller._zOrderIndex = null;
    controller._attachTarget = this;
  }

  @override
  void didChangeDependencies() {
    super.didChangeDependencies();
    _childModelMayHaveChanged = true;
  }

  @override
  void didUpdateWidget(OverlayPortal oldWidget) {
    super.didUpdateWidget(oldWidget);
    _childModelMayHaveChanged =
        _childModelMayHaveChanged || oldWidget._targetRootOverlay != widget._targetRootOverlay;
    if (oldWidget.controller != widget.controller) {
      oldWidget.controller._attachTarget = null;
      _setupController(widget.controller);
    }
  }

  @override
  void dispose() {
    assert(widget.controller._attachTarget == this);
    widget.controller._attachTarget = null;
    _locationCache?._debugMarkLocationInvalid();
    _locationCache = null;
    super.dispose();
  }

  void show(int zOrderIndex) {
    assert(
      SchedulerBinding.instance.schedulerPhase != SchedulerPhase.persistentCallbacks,
      '${widget.controller.runtimeType}.show() should not be called during build.',
    );
    setState(() {
      _zOrderIndex = zOrderIndex;
    });
    _locationCache?._debugMarkLocationInvalid();
    _locationCache = null;
  }

  void hide() {
    assert(SchedulerBinding.instance.schedulerPhase != SchedulerPhase.persistentCallbacks);
    setState(() {
      _zOrderIndex = null;
    });
    _locationCache?._debugMarkLocationInvalid();
    _locationCache = null;
  }

  @override
  Widget build(BuildContext context) {
    final int? zOrderIndex = _zOrderIndex;
    if (zOrderIndex == null) {
      return _OverlayPortal(overlayLocation: null, overlayChild: null, child: widget.child);
    }
    return _OverlayPortal(
      overlayLocation: _getLocation(zOrderIndex, widget._targetRootOverlay),
      overlayChild: _DeferredLayout(child: Builder(builder: widget.overlayChildBuilder)),
      child: widget.child,
    );
  }
}

/// A location in an [Overlay].
///
/// An [_OverlayEntryLocation] determines the [Overlay] the associated
/// [OverlayPortal] should put its overlay child onto, as well as the overlay
/// child's paint order in relation to other contents painted on the [Overlay].
//
// An _OverlayEntryLocation is a cursor pointing to a location in a particular
// Overlay's child model, and provides methods to insert/remove/move a
// _RenderDeferredLayoutBox to/from its target _theater.
//
// The occupant (a `RenderBox`) will be painted above the associated
// [OverlayEntry], but below the [OverlayEntry] above that [OverlayEntry].
//
// Additionally, `_activate` and `_deactivate` are called when the overlay
// child's `_OverlayPortalElement` activates/deactivates (for instance, during
// global key reparenting).
// `_OverlayPortalElement` removes its overlay child's render object from the
// target `_RenderTheater` when it deactivates and puts it back on `activated`.
// These 2 methods can be used to "hide" a child in the child model without
// removing it, when the child is expensive/difficult to re-insert at the
// correct location on `activated`.
//
// ### Equality
//
// An `_OverlayEntryLocation` will be used as an Element's slot. These 3 parts
// uniquely identify a place in an overlay's child model:
// - _theater
// - _childModel (the OverlayEntry)
// - _zOrderIndex
//
// Since it can't implement operator== (it's mutable), the same `_OverlayEntryLocation`
// instance must not be used to represent more than one locations.
final class _OverlayEntryLocation extends LinkedListEntry<_OverlayEntryLocation> {
  _OverlayEntryLocation(this._zOrderIndex, this._childModel, this._theater);

  final int _zOrderIndex;
  final _OverlayEntryWidgetState _childModel;
  final _RenderTheater _theater;

  _RenderDeferredLayoutBox? _overlayChildRenderBox;
  void _addToChildModel(_RenderDeferredLayoutBox child) {
    assert(
      _overlayChildRenderBox == null,
      'Failed to add $child. This location ($this) is already occupied by $_overlayChildRenderBox.',
    );
    _overlayChildRenderBox = child;
    _childModel._add(this);
    _theater.markNeedsPaint();
    _theater.markNeedsCompositingBitsUpdate();
    _theater.markNeedsSemanticsUpdate();
  }

  void _removeFromChildModel(_RenderDeferredLayoutBox child) {
    assert(child == _overlayChildRenderBox);
    _overlayChildRenderBox = null;
    assert(_childModel._sortedTheaterSiblings?.contains(this) ?? false);
    _childModel._remove(this);
    _theater.markNeedsPaint();
    _theater.markNeedsCompositingBitsUpdate();
    _theater.markNeedsSemanticsUpdate();
  }

  void _addChild(_RenderDeferredLayoutBox child) {
    assert(_debugIsLocationValid());
    _addToChildModel(child);
    _theater._addDeferredChild(child);
    assert(child.parent == _theater);
  }

  void _removeChild(_RenderDeferredLayoutBox child) {
    // This call is allowed even when this location is disposed.
    _removeFromChildModel(child);
    _theater._removeDeferredChild(child);
    assert(child.parent == null);
  }

  void _moveChild(_RenderDeferredLayoutBox child, _OverlayEntryLocation fromLocation) {
    assert(fromLocation != this);
    assert(_debugIsLocationValid());
    final _RenderTheater fromTheater = fromLocation._theater;
    final _OverlayEntryWidgetState fromModel = fromLocation._childModel;

    if (fromTheater != _theater) {
      fromTheater._removeDeferredChild(child);
      _theater._addDeferredChild(child);
    }

    if (fromModel != _childModel || fromLocation._zOrderIndex != _zOrderIndex) {
      fromLocation._removeFromChildModel(child);
      _addToChildModel(child);
    }
  }

  void _activate(_RenderDeferredLayoutBox child) {
    // This call is allowed even when this location is invalidated.
    // See _OverlayPortalElement.activate.
    assert(_overlayChildRenderBox == null, '$_overlayChildRenderBox');
    _theater._addDeferredChild(child);
    _overlayChildRenderBox = child;
  }

  void _deactivate(_RenderDeferredLayoutBox child) {
    // This call is allowed even when this location is invalidated.
    _theater._removeDeferredChild(child);
    _overlayChildRenderBox = null;
  }

  // Throws a StateError if this location is already invalidated and shouldn't
  // be used as an OverlayPortal slot. Must be used in asserts.
  //
  // Generally, `assert(_debugIsLocationValid())` should be used to prevent
  // invalid accesses to an invalid `_OverlayEntryLocation` object. Exceptions
  // to this rule are _removeChild, _deactivate, which will be called when the
  // OverlayPortal is being removed from the widget tree and may use the
  // location information to perform cleanup tasks.
  //
  // Another exception is the _activate method which is called by
  // _OverlayPortalElement.activate. See the comment in _OverlayPortalElement.activate.
  bool _debugIsLocationValid() {
    if (_debugMarkLocationInvalidStackTrace == null) {
      return true;
    }
    throw StateError(
      '$this is already disposed. Stack trace: $_debugMarkLocationInvalidStackTrace',
    );
  }

  // The StackTrace of the first _debugMarkLocationInvalid call. It's only for
  // debugging purposes and the StackTrace will only be captured in debug builds.
  //
  // The effect of this method is not reversible. Once marked invalid, this
  // object can't be marked as valid again.
  StackTrace? _debugMarkLocationInvalidStackTrace;
  @mustCallSuper
  void _debugMarkLocationInvalid() {
    assert(_debugIsLocationValid());
    assert(() {
      _debugMarkLocationInvalidStackTrace = StackTrace.current;
      return true;
    }());
  }

  @override
  String toString() =>
      '${objectRuntimeType(this, '_OverlayEntryLocation')}[${shortHash(this)}] ${_debugMarkLocationInvalidStackTrace != null ? "(INVALID)" : ""}';
}

class _RenderTheaterMarker extends InheritedWidget {
  const _RenderTheaterMarker({
    required this.theater,
    required this.overlayEntryWidgetState,
    required super.child,
  });

  final _RenderTheater theater;
  final _OverlayEntryWidgetState overlayEntryWidgetState;

  @override
  bool updateShouldNotify(_RenderTheaterMarker oldWidget) {
    return oldWidget.theater != theater ||
        oldWidget.overlayEntryWidgetState != overlayEntryWidgetState;
  }

  static _RenderTheaterMarker of(BuildContext context, {bool targetRootOverlay = false}) {
    final _RenderTheaterMarker? marker;
    if (targetRootOverlay) {
      final InheritedElement? ancestor = _rootRenderTheaterMarkerOf(
        context.getElementForInheritedWidgetOfExactType<_RenderTheaterMarker>(),
      );
      assert(ancestor == null || ancestor.widget is _RenderTheaterMarker);
      marker =
          ancestor != null
              ? context.dependOnInheritedElement(ancestor) as _RenderTheaterMarker?
              : null;
    } else {
      marker = context.dependOnInheritedWidgetOfExactType<_RenderTheaterMarker>();
    }
    if (marker != null) {
      return marker;
    }
    throw FlutterError.fromParts(<DiagnosticsNode>[
      ErrorSummary('No Overlay widget found.'),
      ErrorDescription(
        '${context.widget.runtimeType} widgets require an Overlay widget ancestor.\n'
        'An overlay lets widgets float on top of other widget children.',
      ),
      ErrorHint(
        'To introduce an Overlay widget, you can either directly '
        'include one, or use a widget that contains an Overlay itself, '
        'such as a Navigator, WidgetApp, MaterialApp, or CupertinoApp.',
      ),
      ...context.describeMissingAncestor(expectedAncestorType: Overlay),
    ]);
  }

  static InheritedElement? _rootRenderTheaterMarkerOf(InheritedElement? theaterMarkerElement) {
    assert(theaterMarkerElement == null || theaterMarkerElement.widget is _RenderTheaterMarker);
    if (theaterMarkerElement == null) {
      return null;
    }
    InheritedElement? ancestor;
    theaterMarkerElement.visitAncestorElements((Element element) {
      ancestor = element.getElementForInheritedWidgetOfExactType<_RenderTheaterMarker>();
      return false;
    });
    return ancestor == null ? theaterMarkerElement : _rootRenderTheaterMarkerOf(ancestor);
  }
}

class _OverlayPortal extends RenderObjectWidget {
  /// Creates a widget that renders the given [overlayChild] in the [Overlay]
  /// specified by `overlayLocation`.
  ///
  /// The `overlayLocation` parameter must not be null when [overlayChild] is not
  /// null.
  _OverlayPortal({required this.overlayLocation, required this.overlayChild, required this.child})
    : assert(overlayChild == null || overlayLocation != null),
      assert(overlayLocation == null || overlayLocation._debugIsLocationValid());

  final Widget? overlayChild;

  /// A widget below this widget in the tree.
  final Widget? child;

  final _OverlayEntryLocation? overlayLocation;

  @override
  RenderObjectElement createElement() => _OverlayPortalElement(this);

  @override
  RenderObject createRenderObject(BuildContext context) => _RenderLayoutSurrogateProxyBox();
}

class _OverlayPortalElement extends RenderObjectElement {
  _OverlayPortalElement(_OverlayPortal super.widget);

  @override
  _RenderLayoutSurrogateProxyBox get renderObject =>
      super.renderObject as _RenderLayoutSurrogateProxyBox;

  Element? _overlayChild;
  Element? _child;

  @override
  void mount(Element? parent, Object? newSlot) {
    super.mount(parent, newSlot);
    final _OverlayPortal widget = this.widget as _OverlayPortal;
    _child = updateChild(_child, widget.child, null);
    _overlayChild = updateChild(_overlayChild, widget.overlayChild, widget.overlayLocation);
  }

  @override
  void update(_OverlayPortal newWidget) {
    super.update(newWidget);
    _child = updateChild(_child, newWidget.child, null);
    _overlayChild = updateChild(_overlayChild, newWidget.overlayChild, newWidget.overlayLocation);
  }

  @override
  void forgetChild(Element child) {
    // The _overlayChild Element does not have a key because the _DeferredLayout
    // widget does not take a Key, so only the regular _child can be taken
    // during global key reparenting.
    assert(child == _child);
    _child = null;
    super.forgetChild(child);
  }

  @override
  void visitChildren(ElementVisitor visitor) {
    final Element? child = _child;
    final Element? overlayChild = _overlayChild;
    if (child != null) {
      visitor(child);
    }
    if (overlayChild != null) {
      visitor(overlayChild);
    }
  }

  @override
  void activate() {
    super.activate();
    final _RenderDeferredLayoutBox? box = _overlayChild?.renderObject as _RenderDeferredLayoutBox?;
    if (box != null) {
      assert(!box.attached);
      assert(renderObject._deferredLayoutChild == box);
      // updateChild has not been called at this point so the RenderTheater in
      // the overlay location could be detached. Adding children to a detached
      // RenderObject is still allowed however this isn't the most efficient.
      (_overlayChild!.slot! as _OverlayEntryLocation)._activate(box);
    }
  }

  @override
  void deactivate() {
    // Instead of just detaching the render objects, removing them from the
    // render subtree entirely. This is a workaround for the
    // !renderObject.attached assert in the `super.deactivate()` method.
    final _RenderDeferredLayoutBox? box = _overlayChild?.renderObject as _RenderDeferredLayoutBox?;
    if (box != null) {
      (_overlayChild!.slot! as _OverlayEntryLocation)._deactivate(box);
    }
    super.deactivate();
  }

  @override
  void insertRenderObjectChild(RenderBox child, _OverlayEntryLocation? slot) {
    assert(child.parent == null, "$child's parent is not null: ${child.parent}");
    if (slot != null) {
      renderObject._deferredLayoutChild = child as _RenderDeferredLayoutBox;
      slot._addChild(child);
      renderObject.markNeedsSemanticsUpdate();
    } else {
      renderObject.child = child;
    }
  }

  // The [_DeferredLayout] widget does not have a key so there will be no
  // reparenting between _overlayChild and _child, thus the non-null-typed slots.
  @override
  void moveRenderObjectChild(
    _RenderDeferredLayoutBox child,
    _OverlayEntryLocation oldSlot,
    _OverlayEntryLocation newSlot,
  ) {
    assert(newSlot._debugIsLocationValid());
    newSlot._moveChild(child, oldSlot);
    renderObject.markNeedsSemanticsUpdate();
  }

  @override
  void removeRenderObjectChild(RenderBox child, _OverlayEntryLocation? slot) {
    if (slot == null) {
      renderObject.child = null;
      return;
    }
    assert(renderObject._deferredLayoutChild == child);
    slot._removeChild(child as _RenderDeferredLayoutBox);
    renderObject._deferredLayoutChild = null;
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties.add(DiagnosticsProperty<Element>('child', _child, defaultValue: null));
    properties.add(DiagnosticsProperty<Element>('overlayChild', _overlayChild, defaultValue: null));
    properties.add(
      DiagnosticsProperty<Object>('overlayLocation', _overlayChild?.slot, defaultValue: null),
    );
  }
}

class _DeferredLayout extends SingleChildRenderObjectWidget {
  const _DeferredLayout({
    // This widget must not be given a key: we currently do not support
    // reparenting between the overlayChild and child.
    required Widget child,
  }) : super(child: child);

  _RenderLayoutSurrogateProxyBox getLayoutParent(BuildContext context) {
    return context.findAncestorRenderObjectOfType<_RenderLayoutSurrogateProxyBox>()!;
  }

  @override
  _RenderDeferredLayoutBox createRenderObject(BuildContext context) {
    final _RenderLayoutSurrogateProxyBox parent = getLayoutParent(context);
    final _RenderDeferredLayoutBox renderObject = _RenderDeferredLayoutBox(parent);
    parent._deferredLayoutChild = renderObject;
    return renderObject;
  }

  @override
  void updateRenderObject(BuildContext context, _RenderDeferredLayoutBox renderObject) {
    assert(renderObject._layoutSurrogate == getLayoutParent(context));
    assert(getLayoutParent(context)._deferredLayoutChild == renderObject);
  }
}

// A `RenderProxyBox` that defers its layout until its `_layoutSurrogate` (which
// is not necessarily an ancestor of this RenderBox, but shares at least one
// `_RenderTheater` ancestor with this RenderBox) is laid out.
//
// This `RenderObject` must be a child of a `_RenderTheater`. It guarantees that:
//
// 1. It's a relayout boundary, so calling `markNeedsLayout` on it never dirties
//    its `_RenderTheater`.
//
// 2. Its `layout` implementation is overridden such that `performLayout` does
//    not do anything when its called from `layout`, preventing the parent
//    `_RenderTheater` from laying out this subtree prematurely (but this
//    `RenderObject` may still be resized). Instead, `markNeedsLayout` will be
//    called from within `layout` to schedule a layout update for this relayout
//    boundary when needed.
//
// 3. When invoked from `PipelineOwner.flushLayout`, or
//    `_layoutSurrogate.performLayout`, this `RenderObject` behaves like an
//    `Overlay` that has only one entry.
final class _RenderDeferredLayoutBox extends RenderProxyBox
    with _RenderTheaterMixin, LinkedListEntry<_RenderDeferredLayoutBox> {
  _RenderDeferredLayoutBox(this._layoutSurrogate);

  StackParentData get stackParentData => parentData! as StackParentData;
  final _RenderLayoutSurrogateProxyBox _layoutSurrogate;

  @override
  Iterable<RenderBox> _childrenInPaintOrder() {
    final RenderBox? child = this.child;
    return child == null
        ? const Iterable<RenderBox>.empty()
        : Iterable<RenderBox>.generate(1, (int i) => child);
  }

  @override
  Iterable<RenderBox> _childrenInHitTestOrder() => _childrenInPaintOrder();

  @override
  _RenderTheater get theater {
    final RenderObject? parent = this.parent;
    return parent is _RenderTheater
        ? parent
        : throw FlutterError('$parent of $this is not a _RenderTheater');
  }

  @override
  void redepthChildren() {
    _layoutSurrogate.redepthChild(this);
    super.redepthChildren();
  }

  @override
  bool get sizedByParent => true;

  bool _needsLayout = true;
  @override
  void markNeedsLayout() {
    _needsLayout = true;
    super.markNeedsLayout();
  }

  @override
  RenderObject? get semanticsParent => _layoutSurrogate;

  @override
  double? computeDryBaseline(BoxConstraints constraints, TextBaseline baseline) {
    final RenderBox? child = this.child;
    if (child == null) {
      return null;
    }
    return _RenderTheaterMixin.baselineForChild(
      child,
      constraints.biggest,
      constraints,
      theater._resolvedAlignment,
      baseline,
    );
  }

  @override
  RenderObject? get debugLayoutParent => _layoutSurrogate;

  void layoutByLayoutSurrogate() {
    assert(!_theaterDoingThisLayout);
    final _RenderTheater? theater = parent as _RenderTheater?;
    if (theater == null || !attached) {
      assert(false, '$this is not attached to parent');
      return;
    }
    if (theater._layingOutSizeDeterminingChild) {
      theater.invokeLayoutCallback((BoxConstraints constraints) {
        markNeedsLayout();
      });
    } else {
      final BoxConstraints theaterConstraints = theater.constraints;
      final Size boxSize =
          theaterConstraints.biggest.isFinite
              ? theaterConstraints.biggest
              // Accessing the theater's size is only unsafe if it is laying out the
              // size-determining child.
              : theater.size;
      super.layout(BoxConstraints.tight(boxSize));
    }
  }

  bool _theaterDoingThisLayout = false;
  @override
  void layout(Constraints constraints, {bool parentUsesSize = false}) {
    assert(_needsLayout == debugNeedsLayout);
    // Only _RenderTheater calls this implementation.
    assert(parent != null);
    final bool scheduleDeferredLayout = _needsLayout || this.constraints != constraints;
    assert(!_theaterDoingThisLayout);
    _theaterDoingThisLayout = true;
    super.layout(constraints, parentUsesSize: parentUsesSize);
    assert(_theaterDoingThisLayout);
    _theaterDoingThisLayout = false;
    _needsLayout = false;
    assert(!debugNeedsLayout);
    if (scheduleDeferredLayout) {
      final _RenderTheater parent = this.parent! as _RenderTheater;
      // Invoking markNeedsLayout as a layout callback allows this node to be
      // merged back to the `PipelineOwner`'s dirty list in the right order, if
      // it's not already dirty. Otherwise this may cause some dirty descendants
      // to performLayout a second time.
      parent.invokeLayoutCallback((BoxConstraints constraints) {
        markNeedsLayout();
      });
    }
  }

  @override
  void performResize() {
    size = constraints.biggest;
  }

  bool _debugMutationsLocked = false;
  @override
  void performLayout() {
    assert(!_debugMutationsLocked);
    if (_theaterDoingThisLayout) {
      _needsLayout = false;
      return;
    }
    assert(() {
      _debugMutationsLocked = true;
      return true;
    }());
    // This method is directly being invoked from `PipelineOwner.flushLayout`,
    // or from `_layoutSurrogate`'s performLayout.
    assert(parent != null);
    final RenderBox? child = this.child;
    if (child == null) {
      _needsLayout = false;
      return;
    }
    assert(constraints.isTight);
    layoutChild(child, constraints);
    assert(() {
      _debugMutationsLocked = false;
      return true;
    }());
    _needsLayout = false;
  }

  @override
  void applyPaintTransform(RenderBox child, Matrix4 transform) {
    final BoxParentData childParentData = child.parentData! as BoxParentData;
    final Offset offset = childParentData.offset;
    transform.translate(offset.dx, offset.dy);
  }
}

// A RenderProxyBox that makes sure its `deferredLayoutChild` has a greater
// depth than itself.
class _RenderLayoutSurrogateProxyBox extends RenderProxyBox {
  _RenderDeferredLayoutBox? _deferredLayoutChild;

  @override
  void redepthChildren() {
    super.redepthChildren();
    final _RenderDeferredLayoutBox? child = _deferredLayoutChild;
    // If child is not attached, this method will be invoked by child's real
    // parent when it's attached.
    if (child != null && child.attached) {
      assert(child.attached);
      redepthChild(child);
    }
  }

  @override
  void performLayout() {
    super.performLayout();
    // Try to layout `_deferredLayoutChild` here now that its configuration
    // and constraints are up-to-date. Additionally, during the very first
    // layout, this makes sure that _deferredLayoutChild is reachable via tree
    // walk.
    _deferredLayoutChild?.layoutByLayoutSurrogate();
  }

  @override
  void visitChildrenForSemantics(RenderObjectVisitor visitor) {
    super.visitChildrenForSemantics(visitor);
    final _RenderDeferredLayoutBox? deferredChild = _deferredLayoutChild;
    if (deferredChild != null) {
      visitor(deferredChild);
    }
  }
}


Instructions for the chapter (Generate content in English unless specified otherwise):
- Start with a clear heading (e.g., `# Chapter 8: _OverlayEntryLocation
`). Use the provided concept name.

- If this is not the first chapter, begin with a brief transition from the previous chapter, referencing it with a proper Markdown link using its name.

- Begin with a high-level motivation explaining what problem this abstraction solves. Start with a central use case as a concrete example. The whole chapter should guide the reader to understand how to solve this use case. Make it very minimal and friendly to beginners.

- If the abstraction is complex, break it down into key concepts. Explain each concept one-by-one in a very beginner-friendly way.

- Explain how to use this abstraction to solve the use case. Give example inputs and outputs for code snippets (if the output isn't values, describe at a high level what will happen).

- Each code block should be BELOW 10 lines! If longer code blocks are needed, break them down into smaller pieces and walk through them one-by-one. Aggresively simplify the code to make it minimal. Use comments to skip non-important implementation details. Each code block should have a beginner friendly explanation right after it.

- Describe the internal implementation to help understand what's under the hood. First provide a non-code or code-light walkthrough on what happens step-by-step when the abstraction is called. It's recommended to use a simple sequenceDiagram with a dummy example - keep it minimal with at most 5 participants to ensure clarity. If participant name has space, use: `participant QP as Query Processing`. .

- Then dive deeper into code for the internal implementation with references to files. Provide example code blocks, but make them similarly simple and beginner-friendly. Explain.

- IMPORTANT: When you need to refer to other core abstractions covered in other chapters, ALWAYS use proper Markdown links like this: [Chapter Title](filename.md). Use the Complete Tutorial Structure above to find the correct filename and the chapter title. Translate the surrounding text.

- Use mermaid diagrams to illustrate complex concepts (```mermaid``` format). .

- Heavily use analogies and examples throughout to help beginners understand.

- End the chapter with a brief conclusion that summarizes what was learned and provides a transition to the next chapter. If there is a next chapter, use a proper Markdown link: [Next Chapter Title](next_chapter_filename).

- Ensure the tone is welcoming and easy for a newcomer to understand.

- Output *only* the Markdown content for this chapter.

Now, directly provide a super beginner-friendly Markdown output (DON'T need ```markdown``` tags):

2025-05-22 23:59:21,286 - INFO - RESPONSE: # Chapter 8: _OverlayEntryLocation

Welcome back to the final chapter of our basic `overlay.dart` tutorial! We've come a long way, understanding the [Overlay](01_overlay_.md), its manager the [OverlayState](02_overlaystate_.md), and how to display widgets on it using [OverlayEntry](03_overlayentry_.md) or the more modern [OverlayPortal](04_overlayportal_.md) with its [OverlayPortalController](05_overlayportalcontroller_.md). We also peeked at the stage where these widgets are painted, the [_Theater](06__theater_.md), and an internal trick used by [OverlayPortal](04_overlayportal_.md) for layout, [_RenderDeferredLayoutBox](07__renderdeferredlayoutbox_.md).

In this chapter, we'll touch on one last internal concept that helps the [OverlayPortal](04_overlayportal_.md) know *exactly* where and at what painting level its overlay child should be placed within the [_Theater](06__theater_.md): the **`_OverlayEntryLocation`**.

While you don't interact with `_OverlayEntryLocation` directly, understanding its purpose helps solidify how [OverlayPortal](04_overlayportal_.md) works its magic, connecting its overlay child to the global [Overlay](01_overlay_.md) structure.

Think of the [_Theater](06__theater_.md) as a busy concert venue with many performers all on the same stage, layered on top of each other. When an [OverlayPortal](04_overlayportal_.md) wants its performer (its overlay child widget) to join the show, it needs a specific spot and a specific time to appear in the lineup so they are painted in the correct order, relative to other performers controlled by different [OverlayEntry](03_overlayentry_.md)s or [OverlayPortal](04_overlayportal_.md)s.

The `_OverlayEntryLocation` is like a **ticket or a backstage pass** that the [OverlayPortal](04_overlayportal_.md) generates. This ticket contains information about:

1.  **Which** part of the [_Theater](06__theater_.md) (which specific [OverlayEntry](03_overlayentry_.md)'s area) the widget belongs to conceptually.
2.  **When** exactly this performer should appear in the painting order (its "z-order index").

When the [OverlayPortal](04_overlayportal_.md)'s overlay child is active (because its [OverlayPortalController](05_overlayportalcontroller_.md) called `show()`), the `_OverlayPortal` internal widget uses the `_OverlayEntryLocation` to tell the ancestor [_Theater](06__theater_.md) (via the `_OverlayEntryWidgetState` that represents an [OverlayEntry](03_overlayentry_.md)) where to place the overlay child's render object in its internal ordering for painting.

### Where Does _OverlayEntryLocation Come From?

We saw in [Chapter 4](04_overlayportal_.md) and [Chapter 5](05_overlayportalcontroller_.md) snippets of the `_OverlayPortalState`'s `build` method that it calls a private method `_getLocation`:

```dart
// From overlay.dart -> _OverlayPortalState -> build (simplified)
@override
Widget build(BuildContext context) {
  final int? zOrderIndex = _zOrderIndex; // State controlled by OverlayPortalController
  if (zOrderIndex == null) {
    // Not showing, no location needed
    return _OverlayPortal(overlayLocation: null, overlayChild: null, child: widget.child);
  }
  // Showing! Get the location ticket
  return _OverlayPortal(
    overlayLocation: _getLocation(zOrderIndex, widget._targetRootOverlay), // HERE IT IS!
    overlayChild: _DeferredLayout(child: Builder(builder: widget.overlayChildBuilder)),
    child: widget.child,
  );
}
```

And the `_getLocation` method itself (simplified):

```dart
// From overlay.dart -> _OverlayPortalState -> _getLocation (simplified)
_OverlayEntryLocation _getLocation(int zOrderIndex, bool targetRootOverlay) {
  // ... cache logic ...
  // Find information about the nearest or root Overlay's render objects
  late final _RenderTheaterMarker marker = _RenderTheaterMarker.of(
    context,
    targetRootOverlay: targetRootOverlay,
  );
  // Create the location ticket using the zOrderIndex and the marker info
  final _OverlayEntryLocation newLocation = _OverlayEntryLocation(
    zOrderIndex, // The paint order level (timestamp from controller.show())
    marker.overlayEntryWidgetState, // Which OverlayEntryWidgetState it relates to
    marker.theater, // Which RenderTheater it belongs to
  );
  // ... return and potentially cache the newLocation ...
}
```

When `_contextMenuController.show()` is called, the `_OverlayPortalState` updates its `_zOrderIndex` to a new unique value (like a timestamp, as we saw in [Chapter 5](05_overlayportalcontroller_.md)). This `_zOrderIndex` is passed to `_getLocation`.

`_getLocation` uses the `_RenderTheaterMarker` (an `InheritedWidget` provided by the [_Theater](06__theater_.md)'s children, as seen in [Chapter 4](04_overlayportal_.md)) to find two key render objects related to the ancestor [Overlay]:

1.  The `_RenderTheater` itself.
2.  The `_OverlayEntryWidgetState` which represents the specific [OverlayEntry](03_overlayentry_.md) instance that this `OverlayPortal` sits within conceptually (this is how the overlay child knows which [OverlayEntry](03_overlayEntry_.md)'s layer it should paint relative to).

These three pieces of information (`_zOrderIndex`, `_OverlayEntryWidgetState`, and `_RenderTheater`) are bundled together into a new `_OverlayEntryLocation` object. This is the "ticket".

### How _OverlayEntryLocation is Used

The `_OverlayEntryLocation` object is then passed to the internal `_OverlayPortal` RenderObjectWidget:

```dart
// From overlay.dart -> _OverlayPortalState -> build (simplified, returning the internal widget)
return _OverlayPortal(
  overlayLocation: _getLocation(zOrderIndex, widget._targetRootOverlay),
  overlayChild: _DeferredLayout(child: Builder(builder: widget.overlayChildBuilder)),
  child: widget.child,
);
```

The `_OverlayPortal` widget's corresponding Element, `_OverlayPortalElement`, receives this `_OverlayEntryLocation` as the `slot` for the overlay child widget tree it manages (`_overlayChildElement`).

When the `_OverlayPortalElement` needs to insert or move the overlay child's render object (the `_RenderDeferredLayoutBox` we saw in [Chapter 7](07__renderdeferredlayoutbox_.md)) into the render tree, it uses the methods provided by the `_OverlayEntryLocation` ticket:

```dart
// From overlay.dart -> _OverlayPortalElement -> insertRenderObjectChild (simplified)
@override
void insertRenderObjectChild(RenderBox child, _OverlayEntryLocation? slot) {
  assert(child.parent == null);
  if (slot != null) {
    renderObject._deferredLayoutChild = child as _RenderDeferredLayoutBox;
    slot._addChild(child); // Use the ticket to add the child!
    renderObject.markNeedsSemanticsUpdate();
  } else {
    renderObject.child = child;
  }
}
```

The `slot._addChild(child)` call uses the methods on the `_OverlayEntryLocation` object. What does `_OverlayEntryLocation._addChild` do?

```dart
// From overlay.dart -> _OverlayEntryLocation -> _addChild (simplified)
void _addChild(_RenderDeferredLayoutBox child) {
  // Link the render box to this location object internally
  _overlayChildRenderBox = child;

  // Add this location object to the linked list maintained by the _OverlayEntryWidgetState
  _childModel._add(this);

  // Tell the RenderTheater to adopt and possibly re-parent the render child
  _theater._addDeferredChild(child);

  // Mark things dirty for painting and rendering updates
  _theater.markNeedsPaint();
  _theater.markNeedsCompositingBitsUpdate();
  _theater.markNeedsSemanticsUpdate();
}
```
This reveals the key actions `_OverlayEntryLocation` enables:

1.  **It links the specific `_RenderDeferredLayoutBox` (your overlay child render object) to this location object (`_overlayChildRenderBox = child`).**
2.  **It registers itself (`this`, the `_OverlayEntryLocation` object) with the `_OverlayEntryWidgetState` (`_childModel._add(this)`).** The `_OverlayEntryWidgetState` maintains a sorted linked list of `_OverlayEntryLocation`s for the `OverlayPortal` children that should be layered *above* its corresponding [OverlayEntry](03_overlayentry_.md), ordered by their `_zOrderIndex`. This is how the paint order *within* an [OverlayEntry](03_overlayentry_.md)'s layer is managed for sibling [OverlayPortal]s.
3.  **It tells the `_RenderTheater` (`_theater._addDeferredChild(child)`) to add the actual render object (`child`) to its children list.** `_RenderTheater` handles the low-level render tree manipulation.

So, the `_OverlayEntryLocation` acts as the coordinating object. It knows which [_Theater](06__theater_.md) and which `_OverlayEntryWidgetState` are relevant, and it carries the `_zOrderIndex` (paint order) and the render object (`_RenderDeferredLayoutBox`) that needs to be placed. It uses its methods to update the internal lists and the render tree structure.

When the `OverlayPortalController` calls `hide()`, the `_OverlayPortalState` sets `_zOrderIndex` to null. The next rebuild will result in an `_OverlayPortal` widget with `this.overlayLocation = null .` The `_OverlayPortalElement` sees this change and calls `removeRenderObjectChild`:

```dart
// From overlay.dart -> _OverlayPortalElement -> removeRenderObjectChild (simplified)
@override
void removeRenderObjectChild(RenderBox child, _OverlayEntryLocation? slot) {
  if (slot == null) { // This path is taken when hiding
    renderObject.child = null; // Removes child from the surrogate's render tree
    return;
  }
  assert(renderObject._deferredLayoutChild == child);
  // Use the ticket to remove the child from the _OverlayEntryWidgetState's list
  slot._removeChild(child as _RenderDeferredLayoutBox);
  // Clear the reference in the surrogate
  renderObject._deferredLayoutChild = null;
}
```

The `slot._removeChild` method tells the `_OverlayEntryLocation` to remove itself from the `_OverlayEntryWidgetState`'s sorted list and tell the `_RenderTheater` to remove the render object from its children.

Sequence diagram showing _OverlayEntryLocation's role when showing via OverlayPortal:

```mermaid
sequenceDiagram
    participant OverlayPortalController
    participant _OverlayPortalState
    participant BuildContext
    participant _RenderTheaterMarker
    participant _OverlayEntryLocation
    participant _OverlayEntryWidgetState
    participant _RenderTheater
    participant _OverlayPortalElement
    participant _RenderDeferredLayoutBox

    OverlayPortalController->>_OverlayPortalState: show()
    _OverlayPortalState->>_OverlayPortalState: update _zOrderIndex, setState()
    _OverlayPortalState->>_OverlayPortalState: build()
    _OverlayPortalState->>_OverlayPortalState: _getLocation(zOrderIndex, ...)
    _OverlayPortalState->>BuildContext: _RenderTheaterMarker.of(context, ...)
    BuildContext->>_RenderTheaterMarker: Lookup InheritedWidget
    _RenderTheaterMarker-->>_OverlayPortalState: Return theater & entry state info
    _OverlayPortalState->>_OverlayEntryLocation: Create new _OverlayEntryLocation(zOrderIndex, entryState, theater)
    _OverlayPortalState->>_OverlayPortalElement: updateChild(_overlayChild, ..., _OverlayEntryLocation) // pass location as slot
    _OverlayPortalElement->>_RenderDeferredLayoutBox: createRenderObject()
    _OverlayPortalElement->>_OverlayEntryLocation: call _addChild(_RenderDeferredLayoutBox)
    _OverlayEntryLocation->>_OverlayEntryLocation: Store RenderBox reference
    _OverlayEntryLocation->>_OverlayEntryWidgetState: _childModel._add(this _OverlayEntryLocation)
    _OverlayEntryWidgetState->>_OverlayEntryWidgetState: Insert Location into sorted list
    _OverlayEntryLocation->>_RenderTheater: _theater._addDeferredChild(_RenderDeferredLayoutBox)
    _RenderTheater->>_RenderTheater: Add RenderBox to children (internal list)
    _RenderTheater->>_RenderTheater: markNeedsPaint(), etc.
```
This diagram shows how the `_OverlayEntryLocation` acts as the intermediary, created by the `_OverlayPortalState` using data from the `_RenderTheaterMarker`, and then used by the `_OverlayPortalElement` to coordinate the placement of the `_RenderDeferredLayoutBox` within the structures managed by the `_OverlayEntryWidgetState` and the `_RenderTheater`.

### Conclusion

In this final chapter covering basic `overlay.dart` concepts, we briefly explored the internal `_OverlayEntryLocation`. We learned that it's an object created by `OverlayPortalState` that acts like a ticket or coordinates, bundling the `_zOrderIndex` (paint order) with references to the relevant `_RenderTheater` and `_OverlayEntryWidgetState`. This ticket is then used by the `_OverlayPortalElement` to correctly add and remove the `_RenderDeferredLayoutBox` (the render object for your overlay child) into the internal lists managed by the `_OverlayEntryWidgetState` and the children list of the `_RenderTheater`, ensuring it's painted at the correct position within the overlay stack.

While `_OverlayEntryLocation` is an internal detail, understanding its role completes our high-level picture of how `OverlayPortal` seamlessly integrates your widgets into the global `Overlay`'s rendering structure.

This concludes our basic tutorial on Flutter's `overlay.dart` concepts! We've gone from finding and managing the [Overlay](01_overlay_.md) and [OverlayState](02_overlaystate_.md) with [OverlayEntry](03_overlayentry_.md), to using the more modern [OverlayPortal](04_overlayportal_.md) and [OverlayPortalController](05_overlayportalcontroller_.md). We also peeked under the hood at the [_Theater](06__theater_.md), [_RenderDeferredLayoutBox](07__renderdeferredlayoutbox_.md), and `_OverlayEntryLocation` to understand how the internal machinery makes the magic happen. Hopefully, you now feel equipped to confidently use these tools to display floating widgets and temporary UI elements on top of your Flutter applications!


